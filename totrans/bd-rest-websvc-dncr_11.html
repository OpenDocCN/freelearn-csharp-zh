<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Microservices</h1>
                </header>
            
            <article>
                
<p>So far, we have walked through the RESTful APIs with hands-on examples and created small applications. In the previous chapter, we developed an application and discussed the RESTful API, security, testing, performance, and deployment.</p>
<p>This chapter covers a brief introduction to microservices, which is the next stop on our RESTful services journey. In this chapter, we will cover the basic components of microservices and use an example of a monolithic application that is being converted into microservices.</p>
<p>We will cover the following topics:</p>
<ul>
<li>What are microservices?</li>
<li>Communication in microservices</li>
<li>Microservices testing strategy</li>
<li>Scalability</li>
<li>Microservices ecosystem in ASP.NET Core</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of microservices</h1>
                </header>
            
            <article>
                
<p>In simple words, when one divides an application or a module into smaller, independent services, the outcome is also known as <strong>microservices</strong>. These small pieces can also be deployed independently.</p>
<p>If we go back in history, we find that the term microservices was used for the first time in 2011 at the workshop of Software Architects. In March 2012, James Lewis presented some of his ideas about the term microservices. By the end of 2013, various groups in the IT industry had started discussing microservices, and by 2014, microservices had become popular enough to be considered a serious contender for large enterprises.</p>
<p>So, what are microservices really? There are a plethora of definitions so you can define microservices as per your own understanding of the term or what kind of use cases and discussions you may have. Let us look at a microservices definition according to an official website: (source: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview-microservices">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview-microservices</a>)</p>
<div class="packt_quote"><q><em>"Microservice applications are composed of small, independently versioned, and scalable customer-focused services that communicate with each other over standard protocols with well-defined interfaces."</em></q></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice attributes</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw that microservices are completely independent of other services in the system and run in their own processes. As per this definition, there are certain attributes that define microservices to be completely independent from other components. Let’s first look at what the core attributes are:</p>
<ul>
<li><strong>Isolated functionality</strong>: Don’t try to achieve too much within a single microservice. Instead, design it for <span>only </span>one reason and do that well. This means that the design should try and avoid any dependency on any other part of the functionality. This part is extremely important in my opinion as it lays the foundation for the rest of the attributes.</li>
<li><strong>Isolated data and state</strong>: Each service owns its data and its state. It does not share ownership with any other application or part.</li>
<li><strong>Independent deployment</strong>: A cumulative effect of the preceding points. This helps you with continuous deployment.</li>
<li><strong>Technology adoption</strong>: This is easier when the first two points have been taken care of, since there is no longer an impact on any of the existing modules. The beauty here lies in the fact that you could have two different versions of a microservice in two different technologies. Extremely beneficial.</li>
<li><strong>Consistency and resiliency</strong>: It has to be impeccable. If you can’t rely on a service to return within a speculated period or rely on it to be always available, then the whole purpose of it is lost.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding microservice architecture</h1>
                </header>
            
            <article>
                
<p>We have already discussed how the microservice architecture is a way to develop a single application containing a set of smaller services. These services are independent and run in their own processes.</p>
<p>In other words, we can say that microservices are a way to segregate our services so they can be handled independently of each other for design, development, deployment, and upgrade purposes.</p>
<p>Microservices have a lot of benefits, which are as follows:</p>
<ul>
<li><strong>Smaller codebase</strong>: Each service is small, therefore easier to develop and deploy as a unit</li>
<li><strong>Ease of independent environment</strong>: With the separation of services, all developers work independently, deploy independently, and no one is bothered about any module dependencies</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communication in microservices</h1>
                </header>
            
            <article>
                
<p>It is very important to consider the choice of messaging mechanisms carefully when dealing with a microservice architecture. If this one aspect is ignored, then it can compromise the entire purpose of designing with a microservices architecture.</p>
<p>Let's move ahead and consider our choices for both synchronous and asynchronous messaging along with different messaging formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Synchronous messaging</h1>
                </header>
            
            <article>
                
<p>When a timely response is expected from a service by a system and the system waits on it till a response is received from the service, it is called <strong>synchronous messaging</strong>. REST is one of the most sought-after choices in a microservice architecture. It is simple and supports HTTP request-response, therefore there is no need to look for an alternative. This is also one of the reasons that most implementations of microservices use HTTP (API-based styles).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous messaging</h1>
                </header>
            
            <article>
                
<p>When a system is not immediately expecting a response from the service and it can continue processing without blocking the call, it is called as <strong>asynchronous messaging</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message formats</h1>
                </header>
            
            <article>
                
<p>Over the past few years, working with MVC and the like has got me hooked on the JSON format. You could also consider XML. Both these formats would do fine on HTTP with API style<span> </span><span>resource</span><span>. Binary message formats are also available in case you need to use one. We are not recommending any formats here, you can go with any selected message format.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why we should use microservices</h1>
                </header>
            
            <article>
                
<p>Tremendous patterns and architectures have been explored, with some gaining popularity and others losing the battle for internet traffic. Each solution has its own advantages and disadvantages so it has become increasingly important for companies to respond quickly to fundamental demands such as scalability, high performance, and easy deployment. Any single aspect found not to be cost-effective could easily impact large businesses negatively, making the difference between a profitable and an unprofitable venture. The following diagram highlights the advantages of opting Microservices:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d5c09102-7af7-4006-bdbf-567d945b720c.png" style="width:15.58em;height:18.17em;"/></div>
<p>This is where we see microservices coming to the rescue of enterprise system architects. They can ensure their designs don't have any problems with the help of this architectural style. It is also important to consider the fact that this objective is met in a cost-effective and timely manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How a microservice architecture works</h1>
                </header>
            
            <article>
                
<p>In previous sections, we discussed the microservice architecture and tried to shine more light on this term. Now, you can see how a microservices architecture might work; you can use any combination according to your own design approach. Here are a few points to remember when working on a microservice architecture:</p>
<ul>
<li>It is programming for the modern era, where we should follow all SOLID principles. It’s object-oriented programming (OOP).</li>
<li>It is the best way to expose functionality to other or external components so any programming language can use the functionality without adhering to any user interfaces or services (web services, API, REST services, and so on.)</li>
<li>The whole system works in collaboration, which is not interconnected and interdependent.</li>
<li>Each component is responsible for its own functionality.</li>
<li>It segregates code. Segregated code is reusable.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of microservices</h1>
                </header>
            
            <article>
                
<p>The following are some advantages of microservices:</p>
<ul>
<li>You don’t have to invest to make the entire application scalable. In terms of a shopping cart, we could simply load balance the product search module and order-processing module while leaving less frequently used operation services such as inventory management, order cancellation, and delivery confirmation.</li>
<li>We can easily match an organization’s departmental hierarchies. With different departments sponsoring product development in large enterprises this can be a huge advantage.</li>
<li>As the code is already done in a way that it is not dependent on code from other modules with isolated functionality, if done right, then the chances of a change in one microservice affecting another microservice is very small.</li>
<li>Since the entire application is more like a group of ecosystems that are isolated from each other – we can deploy one microservice at a time if required. Failure of any one service need not bring the entire system down.</li>
<li>You could port a single microservice or a whole bunch of them overnight to a different technology without your users even knowing it. And it goes without saying that you need to maintain those service contracts.</li>
<li>Comes implied but a word of caution is necessary here. Make sure that your asynchronous call is used well and synchronous ones are not really blocking the whole flow of information. Use data partitioning well. We will come to this a little later, so don’t worry now.</li>
<li>In a competitive world, it is a definite advantage as users tend to lose interest quickly if you are slow to respond to new feature requests or the adoption of a new technology within your system.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Prerequisites of a microservice architecture</h1>
                </header>
            
            <article>
                
<p>After the adoption of a microservice architecture is agreed upon, it is wise to have the following prerequisites in place:</p>
<ul>
<li>Requirements become more demanding with a quicker turnaround from development. It requires you to deploy and test as quickly as you can. If it is just a small number of services, then it is not a problem. However, with the number of services going up this could very quickly challenge the existing infrastructure and practices. For example—your Q/A and staging environment may no longer suffice to test the number of builds that are coming back from the development team.</li>
<li>As the application goes to the public domain, it won't be long before the age-old script of development versus Q/A is played out again. The difference this time is that the business is at stake. So, you need to be prepared to respond quickly in an automated manner to identify the root cause when required.</li>
<li>With an increasing number of microservices, you will quickly need a way to monitor the functioning and health of the entire system for any possible bottlenecks or issues. Without a means of monitoring the status of the deployed microservices and the resultant business function, it is impossible for any team to take a proactive deployment approach.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scaling</h1>
                </header>
            
            <article>
                
<p>Scaling is one of the biggest challenges that any business faces when trying to cater to an increased user base.</p>
<p>Scalability is simply the capability of a system/program to handle a growing work. In other words, scalability is the ability of the system/program to scale.</p>
<p>The scalability of a system is its ability to handle an increasing/increased load of work. There are two main strategies or types of scalability in which we can scale our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vertical scaling</h1>
                </header>
            
            <article>
                
<p>In vertical scaling, we analyze our existing application to find out the parts of the modules that are causing the application to slow down due to higher execution time. Making the code more efficient could be one strategy, so less memory is consumed. This exercise of reducing memory consumption could be for a specific module or the whole application. On the other hand, due to obvious challenges involved in this strategy, instead of changing an application, we could add more resources to our existing IT infrastructure such as upgrading the RAM, adding more disk drives, and so on. Both of these paths in vertical scaling have a limit to how beneficial they are, as after a specific point in time—the resulting benefit would plateau out. It is important here to keep this fact in mind; this kind of scaling requires downtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Horizontal scaling</h1>
                </header>
            
            <article>
                
<p>In horizontal scaling, we dig deeper into modules that are showing a higher impact on the overall performance. We look at factors such as high concurrency to enable our application to serve an increased user base. We would also implement load balancing to process a greater amount of work. The option of adding more servers to the cluster does not require downtime, which is a definite advantage. It can differ from case to case, so we need to check whether the additional costs of power, licenses, and cooling is worthwhile up to that point.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DevOps culture</h1>
                </header>
            
            <article>
                
<p>With the help of DevOps, a team should emphasize the collaboration of the development team and another operational team. We should set up a system where development, Q/A, and the infrastructure teamwork in collaboration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automation</h1>
                </header>
            
            <article>
                
<p>Infrastructure setup can be a very time-consuming job. A developer can be idle while the infrastructure is being readied for him. He or she will be waiting for some time before joining the team and contributing. The process of infrastructure setup should not stop a developer from becoming productive, as it would reduce overall productivity. This should be an automated process. With the use of Chef or PowerShell, we can easily create our virtual machines and quickly ramp up the developer count as and when required. In that way, our developer can be ready to start work from day one of joining the team.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>Testing is a critical task of any application and its more complex when working with microservices. We have to divide our testing approach as follows:</p>
<ul>
<li><span>With a</span>dopt TDD, a developer is required to test his or her own code. The test is simply another piece of code that validates whether the functionality is working as intended. If any functionality is found to be not satisfying the test code, the corresponding unit test would fail. That functionality can be easily fixed as it is known where the problem is. In order to achieve this, we can utilize frameworks such as MSTest or unit tests.</li>
<li>The Q/A team can use scripts to automate their tasks. They can create scripts by utilizing QTP or the Selenium framework.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>Deployment is a huge challenge. To overcome this, we can introduce CI. In this process, we need to set up a CI server. With the introduction of CI, the entire process is now automated. As soon as the code is checked in by any team member, using version control TFS or Git in our case, the CI process kicks into action. It ensures that the new code is built and unit tests are run along with the integration test. In both scenarios, a successful build or otherwise, the team is alerted of the outcome. This enables the team to respond <span>quickly</span><span> </span><span>to issues.</span></p>
<p>Next, we have continuous deployment. Here, we introduce various environments, namely a development environment, a staging environment, a Q/A environment, and so on. Now, as soon as the code is checked-in by any team member, continuous integration kicks into action. It invokes unit/integration test suites, builds the system, and pushes it out to the various environments we have set up. In this way, the turnaround time of the development team to provide a suitable build for Q/A is reduced.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices ecosystem in ASP.NET Core</h1>
                </header>
            
            <article>
                
<p>Whenever I think about a microservices eco in an ASP.NET Core system I think about various small APIs, async programming, callbacks, event triggering, and so on. Actually, the ecosystem is much bigger and somehow more complex.</p>
<p>We have already discussed that the microservice architectural style is a way to create small and independent units of a big application. This is not possible without the use of various tools and utilities.</p>
<p>The following diagram is a pictorial overview of a typical microservices architectural style that depicts different client requests to various services and how this request validates:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d146cdd-d566-4abe-8651-be846b45fae5.png" style="width:34.83em;height:40.67em;"/></div>
<p>A typical microservice ecosystem consists of the following components, you will get an idea about these components in ASP.NET Core in the sections ahead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Service Fabric – microservice platform</h1>
                </header>
            
            <article>
                
<p>A platform is a must-have component for any ecosystem. It supports the system, works smoothly, and produces the expected results. Azure Service Fabric is simply a platform provided by Microsoft and it is very popular in the microservice ecosystem. It provides container deployment and orchestration.</p>
<p>Official documentation can be found at: <a href="https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview">https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview</a></p>
<div class="packt_quote">"Azure Service Fabric is a distributed systems platform that makes it easy to package, deploy, and manage scalable and reliable microservices and containers."</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateless and Stateful services – a service programming model</h1>
                </header>
            
            <article>
                
<p>A robust service programming model is the backbone of a microservices ecosystem. One should know what type of service model he/she should use as per his/her requirements:</p>
<ul>
<li><strong>Stateless</strong>: Services do not persist any state between requests from the client. That is, the service doesn't know, nor care, that the subsequent request has come from the client that has/hasn't made the previous request. This is the best service programming model when we have external data storage. Our service can be based on a stateless service programming model that interacts and persists data on external database storage.</li>
<li><strong>Stateful</strong>: Services maintain a mutable state, actively processing or retaining state data that is specific to the task for which the service is meant.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communication – a way to exchange data between services</h1>
                </header>
            
            <article>
                
<p>If microservices are all about services then communication between services should be robust. Communication is a way to exchange data between services. Services communicate using Rest API (that is, HTTP calls request/response) and these are synchronous by nature.</p>
<p>When services communicate with each other they are actually exchanging data, also called messaging between services. It is very important to consider the choice of messaging mechanism <span>carefully</span><span> </span><span>when dealing with a microservice architecture. If this one aspect is ignored, then it can compromise the entire purpose of designing with a microservice architecture. In monolithic applications, this is not a concern as the business functionality of components is invoked through function calls. On the other hand, this is happening via loosely coupled web-service-level messaging, where services are primarily based on SOAP. Microservice messaging mechanisms should be simple and lightweight.</span></p>
<p>There are no set rules for making a choice between various frameworks or protocols for a microservice architecture. However, there are a few points worthy of consideration here. Firstly, it should be simple enough to implement without adding any complexity to your system. Secondly, it should be lightweight enough, keeping in mind the fact that the microservice architecture could heavily rely on interservice messaging. Let's move ahead and consider our choices for both synchronous and asynchronous messaging along with different messaging formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The microservice architecture style provides certain benefits. It makes development quick and easy. It allows DevOps (CI and CD) teams to be separated geologically, work smoothly, and in sync. An application is divided into small service components or pieces so maintenance is easy. This allows the development team to let business sponsors choose what industry trends to respond to first. This results in cost benefits, better business responses, timely technology adoption, effective scaling, and removal of human dependence.</p>
<p>In this chapter, you have gained an idea of typical microservice architectural styles and microservice ecosystems in ASP.NET.</p>
<p>Now, I suggest you read the following on microservices to enhance your skills:</p>
<ul>
<li><em>Building Microservices with .NET Core 2.0 – Second Edition</em> by PACKT (<a href="https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition">https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition</a>)</li>
<li><em>Microservice Patterns and Best Practices</em> by PACKT (<a href="https://www.packtpub.com/application-development/microservice-patterns-and-best-practices">https://www.packtpub.com/application-development/microservice-patterns-and-best-practices</a>)</li>
</ul>


            </article>

            
        </section>
    </body></html>