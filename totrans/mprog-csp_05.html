<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-62" class="chapter-number"><a id="_idTextAnchor083"/>5</h1>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor084"/>Leveraging Attributes</h1>
			<p>We briefly touched on the concept of C# attributes in <a href="B19418_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="ita ic">Chapter 2</em></span></a>, <em class="ita ic">Metaprogramming Concepts</em>. They are an obvious choice for adding explicit metadata to your source code. This is what they are intended for. Attributes should not carry heavy logic with them and should be viewed as <span class="No-Break">just metadata.</span></p>
			<p>In this chapter, we will look into how you can leverage them in your code base, providing mechanisms for adorning types and members with valuable, rich information that can be used for <span class="No-Break">different scenarios.</span></p>
			<p>We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What is an attribute and how can it <span class="No-Break">be applied?</span></li>
				<li>Finding types with <span class="No-Break">specific attributes</span></li>
				<li><span class="No-Break">Generic attributes</span></li>
			</ul>
			<p>From this chapter, you should understand the power of attributes as a building block for metaprogramming, how to create your own custom attributes, and how you can discover them <span class="No-Break">being used.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor085"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5</a>) and it builds on top of the <strong class="bo d">Fundamentals</strong> code, which is found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor086"/>What is an attribute and how can it be applied?</h1>
			<p>An <strong class="bo d">attribute</strong> is a special type<a id="_idIndexMarker155"/> that the C# compiler understands. It can be used to associate metadata to assemblies, types, and any member of a type. During compilation, the compiler will pick up the attributes and add them to the compiled assembly as metadata. You can place<a id="_idIndexMarker156"/> more than one attribute on <span class="No-Break">every item.</span></p>
			<p>Creating your own custom attribute is as simple <span class="No-Break">as this:</span></p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
}</pre>
			<p>And then using it is done <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[Custom]
public class MyClass
{
}</pre>
			<p>Notice that you create the attribute with the <strong class="source-in ine">Attribute</strong> postfix in the name. While using it, you don’t need it and you only have <strong class="source-in ine">[Custom]</strong>. The C# compiler has a convention built into it saying you have to have the postfix, but it will ignore it when it’s used. This is a little bit weird and definitely violates the principle of <span class="No-Break">least surprise.</span></p>
			<p>The nice thing about attributes is that they live outside the scope of the element itself, meaning that you don’t have to create an instance of the type with the metadata to access <span class="No-Break">the metadata.</span></p>
			<p>Attributes can take parameters to give them specific information you want to capture. However, all parameters must be available at compile time. This means you can’t create new objects dynamically for any of <span class="No-Break">the parameters.</span></p>
			<p>For instance, we can add a parameter to the attribute by taking the instance of <span class="No-Break">another type:</span></p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
    public CustomAttribute(SomeType instance)
    {
    }
}</pre>
			<p>The compiler will allow the attribute to take the type – after all, it is a valid C# type. However, when you try to use it, you’re not allowed to create a <span class="No-Break">new instance:</span></p>
			<pre class="source-code">
[Custom(new SomeType())] // Will give you a compiler error
public class MyClass
{
}</pre>
			<p>This is because the compiler needs the values to be available at compile time. Even though attributes are ultimately instantiated at runtime, the information captured and added to the compiled assembly is never executed. This means that you’re limited to things the compiler can<a id="_idIndexMarker157"/> resolve, such as primitive types (for example, <strong class="source-in ine">int</strong>, <strong class="source-in ine">float</strong>, and <strong class="source-in ine">double</strong>) and things such as strings – anything that can be represented as constants and not have to be created by the runtime <span class="No-Break">to work.</span></p>
			<p>A valid parameter could be <span class="No-Break">a string:</span></p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
    public CustomAttribute(string information)
    {
    }
}</pre>
			<p>With the constructor now taking a string, it will work not just at compile time but also <span class="No-Break">at runtime.</span></p>
			<p>Since strings can be literal constants, you are allowed to <span class="No-Break">use them:</span></p>
			<pre class="source-code">
[Custom("I'm a valid parameter")]
public class MyClass
{
}</pre>
			<p>Already, you can see the power of attributes – the ability to have additional information sitting there that your <a id="_idIndexMarker158"/>code can reason about and you can use to make decisions or even use <span class="No-Break">for reporti<a id="_idTextAnchor087"/>ng.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor088"/>Limiting attribute usage</h2>
			<p>For attributes, you can also add<a id="_idIndexMarker159"/> metadata to them, which feels a little bit like inception; metadata for the metadata. The metadata that you add is to limit the scope of how the attribute can <span class="No-Break">be used.</span></p>
			<p>You can be very specific about what elements in your code the attribute is for (class, property, field, and <span class="No-Break">so on).</span></p>
			<p>The <strong class="source-in ine">[AttributeUsage]</strong> attribute allows you to be specific about the attribute. Let’s say you want to limit the usage to only classes – you can do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>If you then try to add the attribute to something else other than a class, you will get a <span class="No-Break">compiler error:</span></p>
			<pre class="source-code">
public class MyClass
{
    [Custom] // Compiler error
    public void SomeMethod()
    {
    }
}</pre>
			<p>The <strong class="source-in ine">[AttributeUsage]</strong> type is an enum holding different values for the different code elements attributes support. Every value in the enum represents a flag, making it possible to combine them and target multiple code <span class="No-Break">element types.</span></p>
			<p>Let’s limit the code elements to <strong class="source-in ine">Class</strong>, <strong class="source-in ine">Method</strong>, and <strong class="source-in ine">Property</strong> by applying the <strong class="source-in ine">[AttributeUsage]</strong> attribute with these specified for the <span class="No-Break">custom attribute:</span></p>
			<pre class="source-code">
[AttributeUsage(
    AttributeTargets.Class |
    AttributeTargets.Method |
    AttributeTargets.Property)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>As you can see, using <a id="_idIndexMarker160"/>the bitwise <strong class="bo d">OR</strong> construct (<strong class="source-in ine">|</strong>) you can add all the elements you want <span class="No-Break">to support.</span></p>
			<p>A little fun fact about <strong class="source-in ine">[AttributeUsage]</strong> is that it uses itself to tell the compiler that it can only be used for classes. Again, a little bit <a id="_idIndexMarker161"/>of inception there; the <strong class="source-in ine">[AttributeUsage]</strong> attribute is using <strong class="source-in ine">[AttributeUsage]</strong> to provide metadata <span class="No-Break">about itself.</span></p>
			<p>In addition to limiting the code elements an attribute can be associated with, you can also tell whether or not you allow multiple instances of the attribute to be applied. You can also specify whether or not you allow the attribute to be available as metadata for types inheriting from the type that has the attribute applied <span class="No-Break">to it.</span></p>
			<p>The <strong class="source-in ine">[AttributeUsage]</strong> attribute does, however, only take one parameter in its constructor. That means we have to use its <span class="No-Break">properties explicitly.</span></p>
			<p>By default, attributes are limited to only being associated once per code element type. Trying to associate the attribute more than once will give you a <span class="No-Break">compiler error:</span></p>
			<pre class="source-code">
[Custom]
[Custom] // Compiler error
public class MyClass
{
}</pre>
			<p>This behavior can be changed by simply using the <span class="No-Break"><strong class="source-in ine">AllowMultiple</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class, AllowMultiple =
  true)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>Compiling the same code will now <span class="No-Break">be allowed.</span></p>
			<p>The other property you can <a id="_idIndexMarker162"/>use for limiting the usage of the attributes is the <strong class="source-in ine">Inherited</strong> property. Setting this to <strong class="source-in ine">false</strong> will tell the compiler that the associated attribute is only the specific type it is being used explicitly and not for the <span class="No-Break">derived type:</span></p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class CustomAttribute : Attribute
{
}</pre>
			<p>As you saw earlier, you can add the attribute in a normal way to <span class="No-Break">the class:</span></p>
			<pre class="source-code">
[Custom]
public class MyClass
{
}</pre>
			<p>You can add a class that inherits from the type with the <strong class="source-in ine">[Custom]</strong> attribute applied <span class="No-Break">to it:</span></p>
			<pre class="source-code">
public class MyOtherClass : MyClass
{
}</pre>
			<p>The metadata associated with the <strong class="source-in ine">MyClass</strong> base type will not be associated with <strong class="source-in ine">MyOtherClass</strong> when the <strong class="source-in ine">Inherited</strong> property is set to <strong class="source-in ine">false</strong>. This is, by default, turned on, meaning that the derived type will have the same metadata associated <span class="No-Break">with it.</span></p>
			<p>To create an attribute, inheriting from <strong class="source-in ine">Attribute</strong> and applying <strong class="source-in ine">[AttributeUsage]</strong> is all you need to do. However, you might want to bring more clarity and explicitness to your <a id="_idIndexMarker163"/>metadata by not allowing inheritance from your attribute. Sealing your class will disable anyone inheriting from your <span class="No-Break">custom attribute.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor089"/>Sealing your attribute class</h2>
			<p>Since attributes represent specific metadata, they’re not a regular code construct that you use for holding logic. Therefore, you will <a id="_idIndexMarker164"/>find that you don’t need to create base attributes that other, more specific attributes inherit from. In fact, it could make your metadata unclear if you use inheritance as your metadata will lose explicitness and you would bring implicitness <span class="No-Break">into it.</span></p>
			<p>Because of this, it is considered good practice to not allow for the inheritance of attributes and stop it at a compiler level by making the attribute <span class="No-Break">class </span><span class="No-Break"><strong class="source-in ine">sealed</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public sealed class CustomAttribute : Attribute
{
}</pre>
			<p>If you then try to create a more specific attribute that inherits from it, you will get a <span class="No-Break">compiler error.</span></p>
			<p>Now that we’ve covered all the mechanics involved in creating custom attributes and how you can make them very specific to your use case, you are probably eager to start actually discovering them and putting them to <a id="_idTextAnchor090"/><span class="No-Break">good use.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor091"/>Finding types with specific attributes</h1>
			<p>Since attributes are created at <a id="_idIndexMarker165"/>compile time and do not require you to have an instance of a type that has been associated with attributes, you can discover attributes using the <span class="No-Break">type system.</span></p>
			<p>If you look at the <strong class="source-in ine">System.Type</strong> type, you’ll see that it implements a type called <strong class="source-in ine">MemberInfo</strong> that sits in the <strong class="source-in ine">System.Reflection</strong> namespace. This base class serves as the base class for <strong class="source-in ine">PropertyInfo</strong>, <strong class="source-in ine">MethodInfo</strong>, <strong class="source-in ine">FieldInfo</strong>, and most of the specific info types representing code elements we can discover through the <span class="No-Break">type system.</span></p>
			<p>On the <strong class="source-in ine">MemberInfo</strong> type, you<a id="_idIndexMarker166"/> find a method called <strong class="source-in ine">GetCustomAttributes()</strong>. This lets you get a collection of attributes associated with the particular <span class="No-Break">code element.</span></p>
			<p>Take the class we <span class="No-Break">had before:</span></p>
			<pre class="source-code">
[Custom]
public class MyClass
{
}</pre>
			<p>You can then quite easily get to the custom attributes on a type and loop through them and perform the actions you <span class="No-Break">want to:</span></p>
			<pre class="source-code">
foreach( var attr in typeof(MyClass).GetCustomAttributes() )
{
    // Do something based on the attribute
}</pre>
			<p>Using <strong class="source-in ine">typeof()</strong> is very explicit and can be used just for this type. For a more dynamic solution, you can discover what types have a specific attribute, which you can leverage for the work we did in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types </em><span class="No-Break"><em class="ita ic">Using <a id="_idTextAnchor092"/>Reflection</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor093"/>Personal Identifiable Information (PII)</h2>
			<p>Let’s go back to the GDPR theme we<a id="_idIndexMarker167"/> touched on in previous chapters. In <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, we used types to discover what was personally identifiable information. Another approach could be to use custom attributes as an explicit metadata approach. With attributes, we can associate more than what we did with a base type in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>. You can add metadata about the reason for collecting <span class="No-Break">the data.</span></p>
			<p>You can capture this with an attribute like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class |
  AttributeTargets.Property | AttributeTargets.Parameter,
    AllowMultiple = false, Inherited = true)]
public class PersonalIdentifiableInformationAttribute :
  Attribute
{
    public PersonalIdentifiableInformationAttribute(string
      reasonForCollecting = "")
    {
        ReasonForCollecting = reasonForCollecting;
    }
    public string ReasonForCollecting { get; }
}</pre>
			<p>The code creates an attribute that can be applied to classes, properties, and parameters. It does not <a id="_idIndexMarker168"/>allow multiple instances of itself to be applied to the code element it will be applied to. It allows the metadata to be available for any type that inherits from the type that has this metadata applied to it or its members. One of the things it is interesting to know about GDPR is the reason the system collects specific data – the attribute, therefore, has this as <span class="No-Break">optional metadata.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You’ll find this implementation in the <strong class="source-in ine">Fundamentals</strong> project in the <span class="No-Break">GitHub repository.</span></p>
			<p>Start by creating a folder called <a href="B19418_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="ita ic">Chapter 5</em></span></a>. Change into this folder in your command-line interface and create a new <span class="No-Break">console project:</span></p>
			<pre class="source-code">
dotnet new console</pre>
			<p>The next thing you’ll need to do is to reference the Fundamentals project. If you have the project next to the <strong class="source-in ine">Chapter5</strong> folder, do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet add reference ../Fundamentals/Fundamentals.csproj</pre>
			<p>With that in place, let’s say you want to create an object that encapsulates <span class="No-Break">an employee:</span></p>
			<pre class="source-code">
public class Employee
{
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
}</pre>
			<p>This type clearly holds <a id="_idIndexMarker169"/>properties that would be identifiable for the person; let’s add the appropriate metadata for <span class="No-Break">its members:</span></p>
			<pre class="source-code">
using Fundamentals.Compliance.GDPR;
public class Employee
{
    [PersonalIdentifiableInformation("Employment records")]
    public string FirstName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Employment records")]
    public string LastName { get; set; } = string.Empty;
    [PersonalIdentifiableInformation("Uniquely identifies
      the employee")]
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
}</pre>
			<p>With this, we now have enough information to discover any type in the system that holds this type <span class="No-Break">of information.</span></p>
			<p>Building on the assembly and type discovery system introduced in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, we can query specifically <span class="No-Break">for this.</span></p>
			<p>Since every member on a type inherits from the <strong class="source-in ine">MemberInfo</strong> type found in the <strong class="source-in ine">System.Reflection</strong> namespace, we can easily create a convenience extension method allowing us to check whether a member has a specific attribute associated <span class="No-Break">with it.</span></p>
			<p>You can then create a <a id="_idIndexMarker170"/>simple extension method that allows you to check whether an attribute is associated with <span class="No-Break">a member:</span></p>
			<pre class="source-code">
public static class MemberInfoExtensions
{
    public static bool HasAttribute&lt;TAttribute&gt;(this
      MemberInfo memberInfo) where TAttribute : Attribute
        =&gt; memberInfo.GetCustomAttributes&lt;TAttribute&gt;()
          .Any();
}</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">You’ll find this implementation in the <strong class="source-in ine">Fundamentals</strong> project in the <span class="No-Break">GitHub repository.</span></p>
			<p>With this in place, you can discover all the types with <span class="No-Break">this information:</span></p>
			<pre class="source-code">
using Fundamentals;
var types = new Types();
var piiTypes = types.All.Where(_ =&gt; _
                    .GetMembers()
                    .Any(m =&gt; m.HasAttribute&lt;Personal
                      IdentifiableInformation
                        Attribute&gt;()));
var typeNames = string.Join("\n", piiTypes.Select(_ =&gt;
  _.FullName));
Console.WriteLine(typeNames);</pre>
			<p>The <strong class="source-in ine">HasAttribute&lt;&gt;</strong> extension method is a powerful little helper that you’ll find handy in all scenarios where<a id="_idIndexMarker171"/> you want to do simple querying of type metadata based <span class="No-Break">on attributes.</span></p>
			<p>To create a GDPR report with the reason for collecting information, change the <strong class="source-in ine">Program.cs</strong> file look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Reflection;
using Fundamentals;
var types = new Types();
Console.WriteLine("\n\nGDPR Report");
var typesWithPII = types.All
                        .SelectMany(_ =&gt;
                            _.GetProperties()
                                .Where(p =&gt; p.HasAttribute
                                 &lt;PersonalIdentifiable
                                  InformationAttribute&gt;()))
                        .GroupBy(_ =&gt; _.DeclaringType);
foreach (var typeWithPII in typesWithPII)
{
    Console.WriteLine($"Type: {typeWithPII.Key!
      .FullName}");
    foreach (var property in typeWithPII)
    {
        var pii = property.GetCustomAttribute&lt;
          PersonalIdentifiableInformationAttribute&gt;();
        Console.WriteLine($"  Property : {property.Name}");
        Console.WriteLine($"    Reason :
          {pii.ReasonForCollecting}");
    }
}</pre>
			<p>The code leverages the type <a id="_idIndexMarker172"/>discovery introduced in <a href="B19418_04.xhtml#_idTextAnchor059"><span class="No-Break"><em class="ita ic">Chapter 4</em></span></a>, <em class="ita ic">Reasoning about Types Using Reflection</em>, and uses LINQ extension methods to select all the types that have properties with <strong class="source-in ine">[PersonalIdentifiableInformationAttribute]</strong> applied. It then groups them by type so that you can easily loop through and present the members with the attribute <span class="No-Break">per type.</span></p>
			<p>Running this will yield the <span class="No-Break">following result:</span></p>
			<pre class="source-code">
GDPR Report
Type: Main.Employee
  Property : FirstName
    Reason : Employment records
  Property : LastName
    Reason : Employment records
  Property : SocialSecurityNumber
    Reason : Uniquely identifies the employee</pre>
			<p>This type of metadata is very valuable for a business. If your business gets a query from the government about a GDPR audit, with your code fully loaded with metadata you can easily create a report on what type of data you’re collecting and the reason for <span class="No-Break">collecting it.</span></p>
			<p>You could also present this type of information to the end users of your system. It is very valuable for a user to know what the system collects about them. This builds a trusting relationship between the system and <span class="No-Break">your users.</span></p>
			<p>GDPR is a very good use case for getting very useful metadata into your code base, but it is just one of many use <a id="_idIndexMarker173"/>cases. You can, of course, make use of metadata in a more actionable way other than j<a id="_idTextAnchor094"/>ust <span class="No-Break">for reporting.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor095"/>Generic attributes</h1>
			<p>One of the limitations of C# attributes <a id="_idIndexMarker174"/>that we used to have is that attributes could not be generic types taking generic arguments. Prior to C# 11, you would get a compiler error if you added a <a id="_idIndexMarker175"/>generic argument to your attribute class. This limitation is lifted with the release of <span class="No-Break"><strong class="bo d">C# 11</strong></span><span class="No-Break">.</span></p>
			<p>Up till C# 11, the only way you could collect type information was for the attribute to have parameters or properties that were of type <strong class="source-in ine">System.Type</strong>. This became <span class="No-Break">very verbose:</span></p>
			<pre class="source-code">
public class CustomAttribute : Attribute
{
    public CustomAttribute(Type theType)
}</pre>
			<p>And then adorning a type with the attribute would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[Custom(typeof(string))]
public class MyClass
{
}</pre>
			<p>With C# 11, now you can improve how you get <span class="No-Break">type information:</span></p>
			<pre class="source-code">
public class CustomAttribute&lt;T&gt; : Attribute
{
}</pre>
			<p>When you adorn a type <a id="_idIndexMarker176"/>with the attribute, you use the <span class="No-Break">generic argument:</span></p>
			<pre class="source-code">
[Custom&lt;string&gt;]
public class MyClass
{
}</pre>
			<p>If you’re looking to have a parameter that is dynamic in type, you can do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[AttributeUsage(AttributeTargets.Class, AllowMultiple =
  true)]
public class CustomAttribute&lt;T&gt; : Attribute
{
    public CustomAttribute(T someParameter)
    {
        SomeParameter = someParameter;
    }
    public T SomeParameter { get; }
}</pre>
			<p>The code defines an attribute that takes a generic argument and it then requires a parameter for the attribute, which will then be of the generic type. It then uses the same generic type when exposing the metadata as a property on <span class="No-Break">the attribute.</span></p>
			<p>When adorning types with the attribute, you specify the type and the parameter because the attribute has to be of the <span class="No-Break">type specified:</span></p>
			<pre class="source-code">
[Custom&lt;int&gt;(42)]
[Custom&lt;string&gt;("Forty two)]
public class MyClass
{
}</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Normally the C# compiler is very good at inferring the type for generic arguments based on the type passed in. But with generic attributes, you have to explicitly give it the generic type <span class="No-Break">every time.</span></p>
			<p>Generic attributes can be<a id="_idIndexMarker177"/> another powerful metadata collection approach. It adds flexibility to how you can co<a id="_idTextAnchor096"/>nstruct <span class="No-Break">your metadata.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor097"/>Summary</h1>
			<p>In this chapter, we’ve looked at what C# attributes are and how powerful they are for describing explicit metadata in your code. We’ve looked at all the mechanics of how you can create your own custom attributes and apply them very to different code elements. From this type of metadata, you can now enrich <span class="No-Break">your code.</span></p>
			<p>With the enrichment looked at in this chapter, you’ve seen how you can quite easily discover this metadata and put it to good use for <span class="No-Break">your business.</span></p>
			<p>In our next chapter, we will dive further into the capabilities of the .NET runtime and look at how you can dynamically generate code based on metadata, making you more productive as a developer in <span class="No-Break">doing so.</span></p>
		</div>
	</body></html>