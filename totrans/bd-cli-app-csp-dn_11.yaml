- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging and Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed the development and testing of our application, it
    is time to release it to the world! We will need to package and deploy it in order
    to distribute it to (millions of) users worldwide.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Each platform (such as Windows, macOS, and Linux) has its own approach to distributing
    applications. Since .NET 8 is cross-platform, we can distribute Bookmarkr to even
    more users, no matter what platform they are using.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: However, before we package and distribute the application, it is important that
    we test it on every target platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore different packaging and deployment techniques
    that will help us achieve this goal. More specifically, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Explore the different options when it comes to packaging and distributing a
    CLI application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to package and distribute a cross-platform CLI application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to deploy that CLI application to multiple platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to manage versions of a distributed application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A bit of terminology
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, you will come across the terms “packaging,” “distribution,”
    and “deployment.” For those of you who are not familiar with these terms, here
    is a brief definition of each:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Packaging**: Packaging refers to the process of preparing the application
    for release. This includes bundling all necessary files, libraries, and resources
    into a single unit that can be easily installed or executed by our users. Effective
    packaging ensures that the application is compatible with various environments
    and simplifies the installation process. It often involves creating installers
    or archives that streamline the deployment of the application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt-get` repositories). The goal of distribution is to make the application
    accessible to its intended audience while ensuring that it reaches them in a secure
    and efficient manner.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: Deployment is the mechanism by which the distributed application
    is installed and made operational on the user’s computer. This can involve configuring
    settings, integrating with existing systems, and ensuring that all components
    work appropriately. Deployment can be done manually or can be automated through
    various tools and scripts. The aim is to allow users to access and utilize the
    application effectively.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you may have figured out, making an application (including a CLI application)
    available to a user is a three-step process that can be summarized by this diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The process of making an application available to users](img/B22400_11_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The process of making an application available to users
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the terminology, let’s start by exploring the available
    options when it comes to the packaging, distribution, and deployment of a CLI
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and distribution options for CLI applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to packaging a CLI application, several methods exist, and choosing
    the most appropriate one depends on the way we intend to distribute it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common options are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**MSI installer**: This option allows for a more traditional installation experience
    and can be achieved using tools such as WiX or Visual Studio Installer Projects.
    Keep in mind that this option only works for Windows. Hence, if we intend to distribute
    our CLI application to multiple platforms, this option may not be the best one.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet tool install` command. Since our CLI application is built using a version
    of .NET that is cross-platform, we can distribute it as a .NET tool to various
    platforms. The downside of this approach is in the installation mechanism: it
    requires the .NET CLI. This is great if our audience is developers or IT professionals
    but not that appropriate otherwise. We should only consider this approach if our
    CLI application is a developer or IT administrator tool, which is not the case
    with our bookmark management application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker container**: This is also a great option for multiplatform distribution.
    A noticeable advantage of a Docker container is that it has a lower footprint
    on the local machine since no local installation is performed and limited access
    to the system is required. A Docker container is a self-contained file. However,
    as with the .NET tool option, this option mainly targets developers or IT administrators
    since users need to have knowledge of using Docker in order to deploy our application.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt-get` package manager, while macOS provides Homebrew and Windows provides
    WinGet. These options are great since users of each platform are familiar with
    them no matter their technical knowledge. This means that these distribution mechanisms
    don’t just target developers and IT administrators but everyone! Once again, since
    our CLI application is built with cross-platform technology (.NET), we can use
    the same code and package it for distribution on each of these platforms.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, several packaging and distribution options are provided to
    us, and you can use whichever best suits your situation. In this chapter, we will
    explore the last three packaging and distribution options: .NET tool, Docker container,
    and WinGet (as a platform-specific packaging option).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and distributing a CLI application
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the subtleties of packaging and distributing
    our application, Bookmarkr, using three different options. We will take this opportunity
    to explain when each approach is most appropriate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Option #1 – as a .NET tool'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By packaging and distributing our application as a .NET tool, our users will
    be able to install it using the .NET CLI. It is, however, important that users
    ensure they have the appropriate .NET version installed to avoid version mismatches,
    which may cause unexpected behaviors in the application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的应用程序作为 .NET 工具打包和分发，我们的用户将能够使用 .NET CLI 安装它。然而，重要的是用户要确保他们已安装适当的 .NET
    版本，以避免版本不匹配，这可能导致应用程序中出现意外的行为。
- en: Step 1 – packaging
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 打包
- en: 'The first step is to modify the `.csproj` file to add properties that indicate
    that it should be packaged as a tool. These properties should be added to the
    `<``PropertyGroup>` section:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是修改 `.csproj` 文件，添加表示它应被打包为工具的属性。这些属性应添加到 `<PropertyGroup>` 部分：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s explain what we have just added here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释我们刚刚添加的内容：
- en: '`PackageId`: This represents the unique identifier for our package.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageId`: 这代表我们包的唯一标识符。'
- en: '`Version`: This indicates the version of our package. We will need to change
    this value when we need to package a newer version.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version`: 这表示我们包的版本。当我们需要打包新版本时，我们需要更改此值。'
- en: '`Authors`: This represents the author (or the list of authors) of a package.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authors`: 这代表包的作者（或作者列表）。'
- en: '`Description`: This provides a brief description of what the application does.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`: 这提供了应用程序的简要描述。'
- en: '`PackAsTool`: Set to `true`, this indicates that the application should be
    packaged as a .NET tool.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackAsTool`: 设置为 `true`，表示应用程序应被打包为 .NET 工具。'
- en: '`ToolCommandName`: This is the name of the command users will type into their
    terminal to execute our application.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolCommandName`: 这是用户将在他们的终端中输入以执行我们的应用程序的命令名称。'
- en: '`PackageOutputPath`: Since a .NET tool is packaged as a NuGet package, an `.nupkg`
    file is then generated. This property indicates where this file will be generated.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageOutputPath`: 由于 .NET 工具被打包为 NuGet 包，因此将生成一个 `.nupkg` 文件。此属性表示此文件将在何处生成。'
- en: '`PackageLicenseExpression`: I chose to provide the code as an MIT license since
    it is a permissive license that allows for the reuse of the code in any project
    as long as the original copyright notice and license are included in all copies
    or substantial portions of the software.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageLicenseExpression`: 我选择提供 MIT 许可的代码，因为它是一种允许在任何项目中重用代码的许可，只要在所有副本或软件的实质性部分中包含原始版权声明和许可即可。'
- en: '`PackageReadmeFile`: This points to a Markdown file in which we explain the
    purpose of the application, how to get started using it, and a link to its documentation,
    among other things. The content of this Markdown file will be displayed on the
    package page on the NuGet site for the user to read. You will find that file in
    the code repository.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageReadmeFile`: 这指向一个 Markdown 文件，其中我们解释了应用程序的目的、如何开始使用它以及指向其文档的链接等。此
    Markdown 文件的内容将在 NuGet 网站上的包页面上显示供用户阅读。您将在代码存储库中找到该文件。'
- en: '`Copyright`: This presents the copyright details of the application.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Copyright`: 这展示了应用程序的版权详情。'
- en: '`PackageProjectUrl`: This points to the home page of the project’s website.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageProjectUrl`: 这指向项目网站的首页。'
- en: '`RepositoryUrl`: This points to the repository where the application’s code
    resides.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepositoryUrl`: 这指向应用程序代码所在的存储库。'
- en: '`PackageTags`: This presents a semicolon-delimited list of keywords that can
    be used when searching for packages.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageTags`: 这展示了一个分号分隔的关键词列表，可以在搜索包时使用。'
- en: 'To specify the location and how to treat the `README.md` file, we need to add
    the following XML code to the `.``csproj` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定 `README.md` 文件的位置和如何处理它，我们需要将以下 XML 代码添加到 `.csproj` 文件中：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second step is to package the application. This is achieved by running
    this command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是打包应用程序。这是通过运行以下命令来实现的：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that it will be generated at the location indicated by the value of
    the `PackageOutputPath` property.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，它将在 `PackageOutputPath` 属性的值所指示的位置生成。
- en: Our package is now ready for distribution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的包现在已准备好分发。
- en: Step 2 – distribution
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 分发
- en: The most common way to distribute a .NET tool is to provide it through the NuGet
    site, located at [https://www.nuget.org](https://www.nuget.org).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 分发 .NET 工具最常见的方式是通过位于 [https://www.nuget.org](https://www.nuget.org) 的 NuGet
    网站。
- en: 'So, let’s head to the NuGet site and click on the **Sign in** link in the top-right
    corner of the page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们前往 NuGet 网站，并点击页面右上角的 **Sign in** 链接：
- en: '![Figure 11.2 – Signing in to the NuGet site](img/B22400_11_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 登录到 NuGet 网站](img/B22400_11_02.jpg)'
- en: Figure 11.2 – Signing in to the NuGet site
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'I will be signing in with my personal account and granting the required permissions
    to the NuGet site, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Granting required permissions to the NuGet site](img/B22400_11_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Granting required permissions to the NuGet site
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is the first time I have signed in with this account, the NuGet
    site asks me to provide a username:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Choosing a username for the NuGet site](img/B22400_11_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Choosing a username for the NuGet site
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it! As a publisher of NuGet packages, I am now all set, and I can
    start uploading my packages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – All set as a NuGet package publisher](img/B22400_11_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – All set as a NuGet package publisher
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now upload our package!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is to click on `.nupkg` file we generated earlier. The package
    is then analyzed and the validation results are presented:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Uploading a package to the NuGet website](img/B22400_11_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Uploading a package to the NuGet website
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Since our package is valid, we can submit it by clicking the **Submit** button
    at the bottom of the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Once uploaded, it usually takes around 15 minutes (but can sometimes take up
    to an hour) for the package to be validated and indexed before it appears in search
    results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Package awaiting validation and indexing](img/B22400_11_07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Package awaiting validation and indexing
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the package validation and indexing have been completed, it will appear
    on the NuGet website just as any other NuGet package:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Bookmarkr is available on the NuGet website!](img/B22400_11_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Bookmarkr is available on the NuGet website!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Now that our application can be found by users, let’s see how it can be deployed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – deployment
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A user can deploy (that is, install) our application on their machine very
    easily by typing this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the installation is complete, the user can execute our application by
    typing this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And that’s it! We’ve packaged, distributed, and deployed Bookmarkr as a .NET
    tool.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can deliver Bookmarkr to our users as a Docker container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Option #2 – as a Docker container'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packaging and distributing our application as a Docker container allows our
    users to install and use our application by reducing the footprint of the application
    on their environment (i.e., operating system and data).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – packaging
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with containers, you may already know that in order to create
    a container image, a Dockerfile is required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dockerfile is a file with no extension that should be located at the root
    of the project directory. For our application, its content is the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In essence, this file instructs Docker to build and publish the application
    (the first six lines of it), and then to build a container image out of the published
    application (the remaining five lines).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Before we run the command to actually build the image, we need to ensure that
    both Docker Desktop and **Windows Subsystem for Linux** (**WSL**) are installed
    and running. Note that Docker Desktop requires administrator privileges on the
    local machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行实际构建镜像的命令之前，我们需要确保Docker Desktop和**Windows子系统（WSL**）都已安装并正在运行。请注意，Docker
    Desktop需要在本地机器上具有管理员权限。
- en: 'Docker Desktop can be installed using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装Docker Desktop：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'WSL can be installed using the following command (Windows needs to be rebooted
    after WSL is installed):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装WSL（安装WSL后，Windows需要重启）：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The command for building a Docker image is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像的命令如下：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `-t bookmarkr` parameter is used to tag the Docker image to be generated
    with a name and an optional version number (more on that later).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t bookmarkr`参数用于标记要生成的Docker镜像，并带有名称和可选版本号（稍后会有更多介绍）。'
- en: The last dot character is neither a typo nor is it optional. It refers to what
    we call the **build context**. More specifically, it instructs Docker where to
    look for the Dockerfile, which, in this case, is the current directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个点字符既不是打字错误也不是可选的。它指的是我们所说的**构建上下文**。更具体地说，它指示Docker在哪里查找Dockerfile，在这种情况下，是当前目录。
- en: 'The operation should take about five minutes, and once it is complete, the
    Docker image will be created, and it can be retrieved by typing the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作大约需要五分钟，一旦完成，Docker镜像将被创建，可以通过输入以下内容来检索：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the container image has been generated on our local machine. We should,
    however, distribute it through a location that everyone can easily find.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，容器镜像已经在我们的本地机器上生成。然而，我们应该通过一个每个人都可以轻松找到的位置来分发它。
- en: Step 2 – distribution
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 分发
- en: The most common way to distribute Docker images is through Docker Hub.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分发Docker镜像最常见的方式是通过Docker Hub。
- en: To do that, we need to head to the Docker Hub portal, located at [https://hub.docker.com](https://hub.docker.com).
    If you don’t already have a Docker Hub account, you can create one from there.
    I already have such an account, and my username is `theAzurian`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要前往位于[https://hub.docker.com](https://hub.docker.com)的Docker Hub门户。如果您还没有Docker
    Hub账户，您可以从那里创建一个。我已经有一个这样的账户，我的用户名是`theAzurian`。
- en: So, let’s follow the steps to push our local Docker image to Docker Hub.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照步骤将我们的本地Docker镜像推送到Docker Hub。
- en: 'First, let’s log in to our Docker Hub account using this command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令登录到我们的Docker Hub账户：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I’m passing my `-p` parameter. This PAT was created through the Docker Hub portal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在传递我的`-p`参数。这个PAT是通过Docker Hub门户创建的。
- en: 'Next, we need to tag the image to include the Docker Hub username of its author,
    the name of the application, and its version, such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要标记镜像以包含其作者的Docker Hub用户名、应用程序的名称及其版本，例如以下内容：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we need to push the tagged image to Docker Hub using this command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用以下命令将标记的镜像推送到Docker Hub：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can ensure that the image has effectively been pushed to Docker Hub by heading
    to the portal and looking for it in our Docker Hub profile:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过前往门户并在我们的Docker Hub个人资料中查找它来确保镜像已成功推送到Docker Hub：
- en: '![Figure 11.9 – Bookmarkr is available in the Docker Hub portal!](img/B22400_11_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – Bookmarkr可在Docker Hub门户中找到！](img/B22400_11_09.jpg)'
- en: Figure 11.9 – Bookmarkr is available in the Docker Hub portal!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – Bookmarkr可在Docker Hub门户中找到！
- en: 'We can also perform a search for it in the Docker Hub portal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在Docker Hub门户中搜索它：
- en: '![Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal](img/B22400_11_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 在Docker Hub门户中搜索Bookmarkr](img/B22400_11_10.jpg)'
- en: Figure 11.10 – Searching for Bookmarkr in the Docker Hub portal
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 在Docker Hub门户中搜索Bookmarkr
- en: Our application can now be found by our users. Let’s see how it can be deployed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以被我们的用户找到。让我们看看它是如何部署的。
- en: Step 3 – deployment
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 部署
- en: In order for a user to run Docker on a Windows machine, they also need to have
    both Docker Desktop and WSL installed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户在Windows机器上运行Docker，他们还需要安装Docker Desktop和WSL。
- en: 'Docker Desktop can be installed using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装Docker Desktop：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'WSL can be installed using the following command (Windows needs to be rebooted
    after WSL is installed):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装WSL（安装WSL后，Windows需要重启）：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, our user can obtain the application from Docker Hub by typing this command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户可以通过输入以下命令从Docker Hub获取应用程序：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'They can execute it by typing this command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以通过输入以下命令来执行它：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Bookmarkr can then be run on the user’s computer as a Docker container:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Bookmarkr running as a Docker container](img/B22400_11_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Bookmarkr running as a Docker container
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We packaged, distributed, and deployed Bookmarkr as a Docker
    container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can deliver Bookmarkr to our users as a WinGet package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Option #3 – as a WinGet package'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By packaging and distributing our application as a WinGet package, we allow
    our users to install it as any other application they have installed using WinGet,
    Microsoft’s package manager.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To package a .NET CLI application for distribution through WinGet (the official
    Windows package manager), we first need to create a manifest file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to manually create and submit the manifest to the WinGet
    package repository on GitHub ([https://github.com/microsoft/winget-pkgs](https://github.com/microsoft/winget-pkgs)),
    the easiest way to do so is using the `WingetCreate` CLI.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first install it using this command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we create the new manifest, we first need to build our CLI application
    as a self-contained .NET application using this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s take a closer look at this command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`-c Release`: Since this is a production-ready version of the application,
    we want to publish it using the Release configuration to ensure that it is optimized
    for performance.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r win-x64`: Since WinGet is the package manager for Windows (and Windows
    only), we specify the target runtime to be the 64-bit version of Windows.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p:selfcontained=true`: A self-contained application already includes the
    .NET runtime, so the user’s machine doesn’t need to have it installed. The application
    will then carry everything it needs to run, including the runtime, libraries,
    and dependencies.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p:IncludeNativeLibrariesForSelfExtract=true`: This ensures that platform-specific
    libraries, along with unmanaged native libraries, are included in the published
    application. This is useful if we use some specific Serilog sinks and for the
    SQLite library.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p:PublishSingleFile=true`: This instructs .NET to bundle everything (including
    the application code, the .NET runtime, and the dependencies) into a single executable
    file. While this makes it more convenient for distribution (because we are distributing
    a single file), it results in a file that is larger in size than framework-dependent
    publishing.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application will be generated in the `bin\Release\net8.0\win-x64\publish`
    directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will upload it to a location that should be accessible to the WinGet
    tool. It is common to pick a remote, publicly accessible, read-only location.
    I decided to use an Azure Storage account. Hence, the location of the executable
    will be [https://bookmarkr.blob.core.windows.net/releases/1.0.0/](https://bookmarkr.blob.core.windows.net/releases/1.0.0/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: About GitHub releases
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: If your application is built as an open source project on GitHub, you will likely
    make your executable versions available as releases. However, releases on GitHub
    follow certain guidelines that go way beyond the scope of this book. If this is
    a topic you are interested in, I recommend that you explore these guidelines by
    visiting [https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md](https://github.com/github/docs/blob/main/content/repositories/releasing-projects-on-github/about-releases.md).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create our manifest files! We can do so using this command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The tool will ask a series of questions required to generate the manifest files.
    Here is an example of what it looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Generating the WinGet manifest files](img/B22400_11_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Generating the WinGet manifest files
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be three files generated:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Version manifest (theAzurian.bookmarkr.yaml)**: Contains metadata about the
    specific version of the application being packaged.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installer manifest (theAzurian.bookmarkr.installer.yaml)**: Details the installation
    specifics of the application.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default locale manifest (theAzurian.bookmarkr.locale.en-CA.yaml)**: Defines
    localization settings for the application. It ensures that users receive a version
    of the application that is appropriately localized, enhancing user experience
    by presenting information in their preferred language.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I personally like to keep these files inside my Visual Studio project, inside
    the following folder structure that I create at the root of the project:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, in our case, this folder structure will look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before we submit our manifest to the WinGet team, it is recommended that we
    test it locally to ensure that it works as expected. This is important as submitting
    our package could lead to a delay during the WinGet approval process if the manifest
    contains issues.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to activate the ability to install applications from
    local manifests. This can be done by executing the following command in a terminal
    running as administrator:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we run this command, providing the path to the `manifests.json` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we can see, the application is installed and runs as expected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Testing the WinGet package locally before submission](img/B22400_11_13.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Testing the WinGet package locally before submission
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to submit our manifest to the WinGet team!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Submitting our manifest to the WinGet package repository requires us to generate
    a PAT for our GitHub account. We can do this using the `wingetcreate token` command,
    or we can skip this step and, when submitting the manifest, `wingetcreate` will
    prompt us to authenticate to our GitHub account. Let’s do it this way!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will open the browser and take us to the GitHub sign-in page. We will
    have to log on to our account. Once done, we will need to provide the required
    authorization:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Authorizing WingetCreate for our GitHub account](img/B22400_11_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图11.14 – 授权WingetCreate对我们的GitHub账户](img/B22400_11_14.jpg)'
- en: Figure 11.14 – Authorizing WingetCreate for our GitHub account
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 授权WingetCreate对我们的GitHub账户
- en: It will then take us to the Pull Request page where we can follow its progress.
    After about 30 minutes, the pull request is completed, and the package is available
    for our users to install.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将带我们到拉取请求页面，我们可以跟踪其进度。大约30分钟后，拉取请求完成，该软件包可供我们的用户安装。
- en: 'Users can then install Bookmarkr using WinGet by typing this command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过输入以下命令使用WinGet安装Bookmarkr：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And voilà! We have packaged, distributed, and deployed Bookmarkr as a WinGet
    package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经将Bookmarkr打包、分发和部署为一个WinGet软件包。
- en: So, we have seen three different approaches to packaging, distributing, and
    deploying our application. But how do we manage multiple versions of that application?
    That’s what we are going to explore in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了三种不同的打包、分发和部署我们应用程序的方法。但我们是怎样管理该应用程序的多个版本的呢？这就是我们将在下一节中要探讨的内容。
- en: Managing versions of the application
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序的版本
- en: All the options that we presented earlier provide version management mechanisms.
    Version management is as important as the packaging and distribution mechanism
    that we select.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提出的所有选项都提供了版本管理机制。版本管理与我们选择的打包和分发机制一样重要。
- en: As our application evolves and new features are added, modified, or removed,
    we want to offer a way for our users to consume these updates at their convenience.
    That is where versioning comes into play.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序发展和新功能的添加、修改或删除，我们希望为用户提供一种方便地消费这些更新的方式。这就是版本控制发挥作用的地方。
- en: Currently, only a single version of our application is distributed. We can hence
    install it by either omitting its version number or explicitly indicating it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只分发我们应用程序的一个版本。因此，我们可以通过省略其版本号或明确指出它来安装它。
- en: But what if we update the application? How can we distribute the new version?
    And what if the new version introduces a bug and we need to roll back to the previous
    version?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们更新了应用程序呢？我们如何分发新版本？而且如果新版本引入了错误，我们需要回滚到先前的版本怎么办？
- en: Let’s explore how we can achieve this for each of the distribution methods that
    we covered earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索我们如何实现我们之前涵盖的每种分发方法。
- en: Semantic versioning primer
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本控制入门
- en: Before we dive into managing different versions of an application, let us start
    by introducing **semantic versioning**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨管理应用程序的不同版本之前，让我们首先介绍**语义版本控制**。
- en: If you are familiar with this approach to versioning applications, you know
    that it is probably the most common and widely adopted approach in the industry.
    If you haven’t heard about it before, let me give you a quick introduction. If
    you want to go deeper in your exploration of semantic versioning, I recommend
    that you visit its official website at [https://semver.org](https://semver.org).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉这种应用程序版本控制方法，你知道这可能是行业中最常见和最广泛采用的方法。如果你之前没有听说过它，让我给你做一个简要的介绍。如果你想更深入地探索语义版本控制，我建议你访问其官方网站[https://semver.org](https://semver.org)。
- en: 'In essence, semantic versioning expresses a version number using this format:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，语义版本控制使用以下格式来表示版本号：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '**Major**: Indicates that this version of the application contains breaking
    changes that are incompatible with the previous major version'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要**：表示此版本的应用程序包含与之前主要版本不兼容的破坏性更改。'
- en: '**Minor**: Indicates that this version of the application only adds new functionalities
    that are backward compatible with the previous versions of the same major version'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要**：表示此版本的应用程序仅添加与之前相同主版本的先前版本向后兼容的新功能。'
- en: '**Patch**: Indicates that this version of the application contains bug fixes
    that are backward compatible with the previous versions of the same major version'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补丁**：表示此版本的应用程序包含与之前相同主版本的先前版本向后兼容的错误修复。'
- en: Each part is represented as a number that is incremented with each new version.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都表示为一个数字，每次新版本发布时都会递增。
- en: Now that we understand semantic versioning, let’s use it to manage different
    versions of our application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了语义版本控制，让我们用它来管理我们应用程序的不同版本。
- en: Managing versions of a .NET tool
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理一个.NET工具的版本
- en: 'If you ran the version of Bookmarkr that we provided as a .NET tool, you will
    certainly have noticed that it returns the following error message:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Bookmarkr as a .NET tool fails to execute](img/B22400_11_15.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Bookmarkr as a .NET tool fails to execute
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Let’s then fix the problem and distribute a new version.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The error comes from the fact that the `appsettings.json` file is not being
    made part of the package when the `dotnet pack` command is executed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, fixing this problem is straightforward. Locate the following entry
    in the `.``csproj` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Replace it with the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, since the new version we are about to package and distribute only provides
    a bug fix, we shall increment the patch number, so the version number looks like
    the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now package and distribute the new version by following the same steps
    that we described earlier.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we distribute it, it is recommended to test it locally using
    the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `--add-source` parameter allows us to specify a location from which the
    package will be deployed. Here, I am specifying the path where the NuGet package
    was generated on my local machine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: After ensuring that this new version works successfully on the local machine,
    we can proceed with pushing it to the NuGet website.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can get a specific version of the tool by providing its version number
    as a parameter. In this case, this could be achieved by typing this command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, they can simply type the following command to get the latest version:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once this command is executed, the previous version of the tool will be replaced
    by the new one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the new version of the application, we can now see that the error
    is resolved:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Bookmarkr as a .NET tool running successfully](img/B22400_11_16.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Bookmarkr as a .NET tool running successfully
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We now know how to manage versions of a .NET tool.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we manage versions of a Docker container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Managing versions of a Docker container
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, when we pushed the Docker image to Docker Hub, we tagged
    it with a version number. Hence, if we want to distribute a new version, we can
    tag the new image with a different version number.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are familiar with Docker, you may know about working with containers
    without providing their version number or using the `latest` tag.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: When distributing multiple versions of a container, it is important to indicate
    which one of these is the latest version, by tagging that version using the `latest`
    tag.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s assume that we are distributing a new version of Bookmarkr and that
    we want to indicate that this new version is the latest one. We can achieve this
    as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s explain these commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The first one creates a new Docker image that is tagged with version 2.0.0
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one tags version 2.0.0 as the latest version
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third command pushes the image tagged with version 2.0.0 to Docker Hub
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth one pushes the image tagged with the latest version to Docker Hub
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that we push the same image using two different tags allows our users
    to get it (using the `docker pull` command) with or without specifying its version
    number. Hence, as we keep updating the application and pushing new Docker images,
    we will tag the newest version with the `latest` tag. Should that version contain
    a bug, we can direct our users to a previous version by tagging it with the `latest`
    tag.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'If we head to the Docker Hub portal, we will see that the new version has been
    successfully pushed. Notice that there are two versions of the same image: one
    with version number 2.0.0 as a tag, and the other with the `latest` tag.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – New version of the Docker image pushed to Docker Hub](img/B22400_11_17.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – New version of the Docker image pushed to Docker Hub
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'On the user’s side, they can get a specific version by explicitly mentioning
    its tag, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or, they can get the latest version (i.e., the version tagged as `latest`)
    by omitting the tag, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The user will then see this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Running the new version of the Docker container](img/B22400_11_18.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Running the new version of the Docker container
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We now know how to manage versions of a Docker image.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we manage versions of a WinGet package.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Managing versions of a WinGet package
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to submit a new version of the application, following an update to
    the application’s code or functionalities, we first need to update the version
    number in the `.csproj` file (the `<``Version>` element).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to publish the application again using the same command we saw
    earlier:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then need to upload the resulting binaries to our distribution location,
    which is our Azure Storage account, keeping in mind that we should create a new
    directory for the new version. The path will then look like this for version 1.0.3:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to update the manifest using this command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The new manifest is then generated and is ready for submission.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as we previously learned, it is always good practice to test the new
    version locally before submitting it. To do that, we will execute the same command
    as we did previously:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the tests are successful, we submit the new version using this command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The remaining steps are similar to those we followed when submitting the initial
    version of the application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new version has been approved and added to the WinGet package repository,
    users can find it and install it. They can install the latest version using this
    command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, they can install a specific version by passing the desired version number
    as a parameter to the command, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Figure 11.19 – The updated version of Bookmarkr is available in WinGet](img/B22400_11_19.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – The updated version of Bookmarkr is available in WinGet
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! This is how we manage multiple versions of a WinGet package.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to package and deploy Bookmarkr onto different
    platforms in order to distribute it to users all around the world, no matter their
    platform of choice, be it Windows, Linux, or macOS.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何打包和部署 Bookmarkr 到不同的平台，以便向全球各地的用户分发，无论他们选择哪个平台，无论是 Windows、Linux
    还是 macOS。
- en: This is quite a milestone we achieved, from the inception of the idea of our
    CLI application all the way to getting it into the hands of millions of users
    worldwide. Let’s take a moment to celebrate this achievement and be proud of ourselves.
    Congratulations! 🎉
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们取得的一个相当大的里程碑，从我们的 CLI 应用程序想法的诞生，到将其推广到全球数百万用户手中。让我们花点时间庆祝这个成就，为自己感到自豪。恭喜！🎉
- en: However, some users are telling us that the application is sometimes slow. We
    haven’t experienced these performance issues since we are running on fast and
    powerful computers, but that is not the case with all our users. Although we could
    simply specify the minimum requirements to run Bookmarkr, we don’t want to limit
    the number of users that can benefit from and be able to use it. So, we have decided
    to see whether there is something we can do.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些用户告诉我们，应用程序有时运行缓慢。我们并没有经历过这些性能问题，因为我们运行在快速且强大的计算机上，但并非所有用户都是如此。尽管我们可以简单地指定运行
    Bookmarkr 的最低要求，但我们不想限制能够从中受益和使用它的用户数量。因此，我们决定看看我们是否可以做一些事情。
- en: In the next chapter, we will explore different techniques that will allow us
    to optimize the performance of our application.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨不同的技术，这些技术将使我们能够优化应用程序的性能。
- en: Your turn!
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码进行实践是学习的好方法。
- en: An even better way is by challenging yourself to complete tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是通过挑战自己完成任务。因此，我挑战你通过添加以下功能来改进 Bookmarkr 应用程序。
- en: 'Task #1 – allowing Linux users to install Bookmarkr using apt-get'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 允许 Linux 用户使用 apt-get 安装 Bookmarkr'
- en: Currently, Bookmarkr can be deployed to Windows using WinGet. However, this
    doesn’t work on Linux, where Linux users typically use `apt-get` for deploying
    applications. You are thus challenged to distribute Bookmarkr as an `apt-get`
    package so Linux users can also enjoy using it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Bookmarkr 可以使用 WinGet 在 Windows 上部署。然而，这在 Linux 上不起作用，Linux 用户通常使用 `apt-get`
    部署应用程序。因此，你被挑战将 Bookmarkr 作为 `apt-get` 软件包进行分发，以便 Linux 用户也能享受使用它。
- en: 'Task #2 – allowing macOS users to install Bookmarkr using Homebrew'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 允许 macOS 用户使用 Homebrew 安装 Bookmarkr'
- en: 'The same applies to macOS users: they typically install their applications
    using the `brew` command. You are thus challenged to distribute Bookmarkr as a
    Homebrew formula.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 用户来说，情况也是如此：他们通常使用 `brew` 命令安装应用程序。因此，你被挑战将 Bookmarkr 作为 Homebrew 公式进行分发。
- en: 'Part 5: Advanced Techniques and Best Practices'
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 部分：高级技术和最佳实践
- en: In this part, you will explore crucial aspects of CLI application development
    that enhance performance, security, and functionality. You'll delve into performance
    optimization and tuning techniques, learning how to profile your CLI applications,
    identify bottlenecks, and implement efficient algorithms and data structures.
    This includes strategies like caching, load balancing, and code refactoring to
    improve execution speed and resource utilization. Next, you'll focus on security
    considerations specific to CLI applications, covering best practices and protection
    against common vulnerabilities. You'll learn how to implement strong authentication
    mechanisms, use encryption for sensitive data, and follow the principle of least
    privilege in your CLI tools. Finally, you'll explore additional resources and
    libraries that will allow you to dive deeper into the various concepts and techniques
    presented in this book.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将探索 CLI 应用程序开发的关键方面，这些方面可以增强性能、安全性和功能性。你将深入了解性能优化和调整技术，学习如何分析你的 CLI 应用程序，识别瓶颈，并实现高效的算法和数据结构。这包括缓存、负载均衡和代码重构等策略，以提高执行速度和资源利用率。接下来，你将专注于
    CLI 应用程序特有的安全考虑，涵盖最佳实践和防范常见漏洞。你将学习如何实现强大的身份验证机制，为敏感数据使用加密，并在你的 CLI 工具中遵循最小权限原则。最后，你将探索额外的资源和库，这将使你能够深入了解本书中提出的各种概念和技术。
- en: 'This part has the following chapters:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 12*](B22400_12.xhtml#_idTextAnchor205)*, Performance Optimization
    and Tuning*'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 12 章*](B22400_12.xhtml#_idTextAnchor205)*，性能优化和调整*'
- en: '[*Chapter 13*](B22400_13.xhtml#_idTextAnchor220)*, Security Considerations
    for CLI Applications*'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B22400_13.xhtml#_idTextAnchor220)*，CLI应用程序的安全考虑*'
- en: '[*Chapter 14*](B22400_14.xhtml#_idTextAnchor236)*, Additional Resources and
    Libraries*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B22400_14.xhtml#_idTextAnchor236)*，附加资源和库*'
