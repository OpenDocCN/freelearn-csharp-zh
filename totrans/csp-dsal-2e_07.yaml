- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variants of Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned about many data structures, starting with
    simple ones such as arrays. Now, it is time for you to get to know a significantly
    more complex group of data structures, namely **trees**.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, a **basic tree** will be presented, together
    with its implementation in the C# language, and with some examples showing it
    in action. Then, a **binary tree** will be introduced, with a detailed description
    of its implementation and an example of its application. A **binary search tree**
    (**BST**) is another tree variant and is one of the most popular types of trees,
    used in many algorithms. You will also cover **self-balancing trees**, namely
    **AVL** and **red-black trees** (**RBTs**). Then, you will see a **trie** as a
    specialized data structure for performing operations on strings. The remaining
    part of the chapter is dedicated to a short introduction to the topic of **heaps**.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays, lists, stacks, queues, dictionaries, sets, and now trees. Are you ready
    to increase the level of difficulty and learn the next data structures? If so,
    let’s start reading!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-balancing trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with introducing trees. What are they? Do you have any ideas about
    how such a data structure should look? If not, let’s take a look at the following
    diagram, which depicts a tree with captions regarding its particular elements:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.1 – \uFEFFIllustration of a tree](img/B18069_07_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Illustration of a tree
  prefs: []
  type: TYPE_NORMAL
- en: A tree consists of multiple **nodes**, including one **root** (**100** in the
    diagram). The root does not contain a **parent** node, while all other nodes do.
    For example, the parent element of node **1** is **100**, while node **96** has
    node **30** as the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, each node can have any number of **child** nodes, such as three **children**
    (that is, **50**, **1**, and **150**) in the case of the **root**. The child nodes
    of the same node can be named **siblings**, as in the case of nodes **70** and
    **61**. A node without children is named a **leaf**, such as **45** and **6**
    in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the rectangle with three nodes (that is, **30**, **96**,
    and **9**). Such a part of the tree can be called a **subtree**. Of course, you
    can find many subtrees in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a tree
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a tree, look at the structure of a slightly larger
    company, where at the very top of the hierarchy there is the **chief executive
    officer** (**CEO**), to whom the **chief operating officer** (**COO**), **chief
    marketing officer** (**CMO**), **chief financial officer** (**CFO**), and **chief
    technology officer** (**CTO**) are assigned. As sales is one of the key topics
    in the company’s operations, regional directors report to the COO, and for each
    of them, between three and five sales specialists are assigned. Look for yourself
    – you have a tree in your mind right now! Its root is the CEO, which has four
    children (COO, CMO, CFO, and CTO), which can have further child nodes to create
    subsequent levels of the hierarchy. Sales specialists who no longer have any subordinates
    are named leaves.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly talk about the minimum and maximum numbers of children of a node.
    In general, such numbers are not limited, and each node can contain zero, one,
    two, three, or even more children. However, in practical applications, the number
    of children is often limited to two, as you will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C#-based implementation of a basic tree seems to be quite obvious and not
    complicated. To do so, you declare two classes, representing a single node and
    a whole tree, as described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first class is named `TreeNode` and is declared as a generic class to provide
    a developer with the ability to specify a type of data stored in each node. Thus,
    you can create a strongly typed solution, which eliminates the necessity of casting
    objects to target types. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The class contains three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The data stored in the node (`Data`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the parent node (`Parent`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of references to child nodes (`Children`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the properties, the `TreeNode` class contains the `GetHeight` method,
    which returns the height of the node – that is, the distance from this node to
    the root node. The implementation of this method is very simple because it just
    uses a `while` loop to go up from the node until there is no parent element, which
    means that the root is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next necessary class is named `Tree`. It represents the whole tree, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class contains only one property, `Root`. You can use this property to get
    access to the root node, and then you can use its `Children` property to obtain
    data of its child nodes. Then, you can take a look at each of them and get data
    of their child nodes, as well. By repeating such operations, you can get data
    from all nodes located in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that both `TreeNode` and `Tree` classes are generic, and
    the same type is used in the case of these classes. For instance, if tree nodes
    should store `string` values, the `string` type should be used for instances of
    `Tree` and `TreeNode` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Example – hierarchy of identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you want to see how to use a tree in a C#-based application? Let’s take
    a look at our first example. The aim is to construct a tree with a few nodes,
    as shown in the following diagram. Only the group of nodes with a bolder border
    will be presented in the code. However, it is a good idea to adjust the code to
    construct the whole tree by yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.2 – \uFEFFIllustration of the hierarchy of identifiers example](img/B18069_07_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Illustration of the hierarchy of identifiers example
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, each node stores an integer value, so `int` is the type used for both
    the `Tree` and `TreeNode` classes. The following code should be placed in the
    `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code looks quite simple, doesn’t it? At the beginning, a new instance of
    the `Tree` class is created and the root node is configured by creating a new
    instance of the `TreeNode` class and setting a value of the `Data` property to
    `100`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines, the child nodes of the root node are specified, namely
    the nodes with values equal to `50`, `1`, and `150`. For each of them, a value
    of the `Parent` property is set to a reference to the previously added root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining part of the code shows how to add a child node for a given node,
    namely for the third child of the root node – that is, the node with a value equal
    to `150`. Here, only one node is added: the one with the value set to `30`. Of
    course, you need to specify a reference to the parent node, as well.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s all! You created the first program that uses trees. Now, you can run
    it, but you will not see any output in the console. If you want to see how the
    data of nodes is organized, you can debug the program and see the values of variables
    while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Example – company structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, you saw how to use integer values as data stored in
    each node in a tree. However, it is also possible to store instances of user-defined
    classes in nodes. In this example, you will see how to create a tree presenting
    the structure of a company, divided into three main departments: development,
    research, and sales.'
  prefs: []
  type: TYPE_NORMAL
- en: Within each department, there can be another structure, such as in the case
    of the development team. Here, **John Smith** is head of development. He is a
    boss for **Chris Morris**, who is a manager for two junior developers, **Eric
    Green** and **Ashley Lopez**. The latter is also a supervisor of **Emily Young**,
    who is a developer intern.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example tree is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.3 – \uFEFFIllustration of the company structure example](img/B18069_07_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Illustration of the company structure example
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each node should store more information than just an integer
    value. There should be a name and a role. Such data is stored as values of properties
    in an instance of the `Person` record, which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from creating a new record, it is also necessary to add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, a new instance of the `Tree` class is created. It is worth
    mentioning that the `Person` record is used as a type specified while creating
    new instances of the `Tree` and `TreeNode` classes. Thus, you can easily store
    more than one simple data type for each node. The remaining lines of code look
    similar to the first example for basic trees. Here, you also specify the root
    node (for the `Chief Executive Officer` role), then configure its child elements
    (`John Smith`, `Alice Batman`, and `Lily Smith`), and set a child node for one
    of the existing nodes, namely the node for the `Head of` `Sales` role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does it look simple and straightforward? In the next section, you will see
    a more restricted, but very important and well-known variant of trees: a binary
    tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally speaking, each node in a basic tree can contain any number of children.
    However, in the case of **binary trees**, **a node cannot contain more than two
    children**. It means that **it can contain zero,****one, or two child nodes**.
    Such a requirement has an important impact on the shape of a binary tree, as shown
    in the following two diagrams presenting binary trees:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.4 – \uFEFFIllustration of binary trees](img/B18069_07_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Illustration of binary trees
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, a node in a binary tree can contain at most two children.
    For this reason, they are referred to as the **left child** and the **right child**.
    In the case of the binary tree shown on the left-hand side of the preceding diagram,
    node **21** has two children, namely **68** as the left child and **12** as the
    right child, while node **100** has only a left child.
  prefs: []
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have you thought about how you can iterate through all the nodes in a tree?
    How can you specify an order of nodes during **traversal** of a tree? There are
    three common approaches, namely **pre-order**, **in-order**, and **post-order**,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Pre-order, in-order, and post-order traversal](img/B18069_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Pre-order, in-order, and post-order traversal
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the diagram, there are visible differences between the approaches.
    However, do you have any idea how you can apply pre-order, in-order, or post-order
    traversals for binary trees? Let’s explain all of these approaches in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to traverse a binary tree with the **pre-order** approach, you first
    visit the root node. Then, you visit the left child. Finally, the right child
    is visited. Of course, such a rule does not apply only to the root node, but to
    any node in a tree. For this reason, you can understand the order of pre-order
    traversal as **first visiting the current node, then its left child (the whole
    left subtree using the pre-order approach recursively), and finally its right
    child (the right subtree in a** **similar way)**.
  prefs: []
  type: TYPE_NORMAL
- en: The explanation can sound a bit complicated, so let’s take a look at a simple
    example regarding the tree shown on the left of the preceding diagram. First,
    the root node (that is, **1**) is visited. Then, you analyze its left child node.
    For this reason, the next visited node is the current node, **9**. The next step
    is the pre-order traversal of its left child. Thus, **5** is visited. As this
    node does not contain any children, you can return to the stage of traversing
    when **9** is the current node. It has already been visited, as has its left child
    node, so it is time to proceed to its right child. Here, you first visit the current
    node, **6**, and follow to its left child, **3**. You can apply the same rules
    to continue traversing the tree. The final order is **1**, **9**, **5**, **6**,
    **3**, **4**, **2**, **7**, **8**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it still sounds a bit confusing, the following diagram should remove any
    doubts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Detailed diagram of pre-order traversal](img/B18069_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Detailed diagram of pre-order traversal
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram presents the following steps of the pre-order traversal with additional
    indicators: **C** for the **current node**, **L** for the **left child**, and
    **R** for the **right child**.'
  prefs: []
  type: TYPE_NORMAL
- en: In-order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second traversal mode is called **in-order**. It differs from the pre-order
    approach in the order that nodes are visited: **the left child, the current node,
    and then the** **right child**.'
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the example shown in the diagram with all three traversal
    modes, you can see that the first visited node is **5**. Why? At the beginning,
    the root node is analyzed, but it is not visited because the in-order traversal
    starts with the left child node. Thus, it analyzes node **9**, but it also has
    a left child, **5**, so you proceed to this node. As this node does not have any
    children, the current node (**5**) is visited. Then, you return to the step when
    the current node is **9**, and, as its left child was already visited, you also
    visit the current node. Next, you follow to the right child, but it has a left
    child, **3**, which should be visited first. According to the same rules, you
    visit the remaining nodes in the binary tree. The final order is **5**, **9**,
    **3**, **6**, **1**, **4**, **7**, **8**, **2**.
  prefs: []
  type: TYPE_NORMAL
- en: Post-order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last traversal mode is named **post-order** and supports the following
    order of node traversal: **the left child, the right child, and then the** **current
    node**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the post-order example shown on the right-hand side of the diagram.
    At the beginning, the root node is analyzed but it is not visited because the
    post-order traversal starts with the left child node. Thus, you proceed to node
    **9**, then **5**, which you visit first. Next, you need to analyze the right
    child of node **9**. However, node **6** has the left child (**3**), which should
    be visited earlier. For this reason, after **5**, you visit **3**, and then **6**,
    followed by **9**. What is interesting is that the root node of the binary tree
    is visited at the end. The final order is **5**, **3**, **6**, **9**, **8**, **7**,
    **2**, **4**, **1**.
  prefs: []
  type: TYPE_NORMAL
- en: What about the performance?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check whether a binary tree contains a given value, you need
    to check each node, traversing the tree using one of three available modes: pre-order,
    in-order, or post-order. This means that the lookup time is linear, namely *O(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let’s proceed to the C#-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of a binary tree is simple, especially if you use the already
    described code for the basic tree. Let’s start with a class representing a node.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A node in a binary tree is represented by an instance of `BinaryTreeNode`,
    which inherits from the `TreeNode` generic class. In the `BinaryTreeNode` class,
    it is necessary to hide the `Children` definition from the base class, as well
    as declare two properties, `Left` and `Right`, which represent both possible children
    of a node. The relevant part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, you need to ensure that the array with child nodes contains exactly
    two items, initially set to `null`. Thus, if you want to add a child node, a reference
    to it should be placed as the first or the second element of the array from the
    `Children` property. Therefore, such an array always has exactly two elements,
    and you can access the first or the second one without any exception. If such
    an element is set to any node, a reference to it is returned. Otherwise, `null`
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next necessary class is named `BinaryTree`. It represents the whole binary
    tree. By using the generic class, you can easily specify the type of data stored
    in each node. The first part of the implementation of the `BinaryTree` class is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinaryTree` class contains two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Root` indicates the root node (instance of the `BinaryTreeNode` class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count` stores the total number of nodes placed in the tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, these are not the only members of the class because it is also equipped
    with a set of methods regarding traversing the tree. The first traversal method
    is `TraversePreOrder` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes two parameters: the current node (`node`) and the list of
    already visited nodes (`result`). The recursive implementation is very simple.
    First, you check whether the node exists by ensuring that the parameter is not
    equal to `null`. Then, you add the current node to the collection of visited nodes,
    start the same traversal method for the left child, and then start it for the
    right child.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar implementation is possible for the `TraverseInOrder` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, you call the `TraverseInOrder` method for the left child, add the current
    node to the list of visited nodes, and start the in-order traversal for the right
    child.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is related to the **post-order** traversal mode, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code is similar to the already described methods, but, of course, another
    order of visiting nodes is applied. Here, you start with the left child, then
    you visit the right child, followed by adding the current node to the list of
    visited nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s add a public method for traversing the tree in various modes,
    which calls the private methods presented earlier. The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes only one parameter, namely a value of the `TraversalEnum`
    enumeration, which chooses the proper mode from pre-order, in-order, and post-order.
    The `Traverse` method uses a `switch` statement to call a suitable private method,
    depending on the value of the parameter. The mentioned enumeration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: public int GetHeight() => Root != null
  prefs: []
  type: TYPE_NORMAL
- en: '? Traverse(TraversalEnum.PreOrder)'
  prefs: []
  type: TYPE_NORMAL
- en: .Max(n => n.GetHeight())
  prefs: []
  type: TYPE_NORMAL
- en: ': 0;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: BinaryTree<string> tree = GetTree();
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTreeNode<string>? node = tree.Root;
  prefs: []
  type: TYPE_NORMAL
- en: while (node != null)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (node.Left != null && node.Right != null)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(node.Data);
  prefs: []
  type: TYPE_NORMAL
- en: node = Console.ReadKey(true).Key switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.Y => node.Left,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.N => node.Right,
  prefs: []
  type: TYPE_NORMAL
- en: _ => node
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(node.Data);
  prefs: []
  type: TYPE_NORMAL
- en: node = null;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: BinaryTree<string> GetTree()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTree<string> tree = new();
  prefs: []
  type: TYPE_NORMAL
- en: tree.Root = new BinaryTreeNode<string>()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Data = "Do you have an experience
  prefs: []
  type: TYPE_NORMAL
- en: in app development?",
  prefs: []
  type: TYPE_NORMAL
- en: Children =
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: new BinaryTreeNode<string>()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Data = "Have you worked as a developer
  prefs: []
  type: TYPE_NORMAL
- en: for 5+ years?",
  prefs: []
  type: TYPE_NORMAL
- en: Children =
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: new() { Data = "Apply as
  prefs: []
  type: TYPE_NORMAL
- en: a senior developer" },
  prefs: []
  type: TYPE_NORMAL
- en: new() { Data = "Apply as
  prefs: []
  type: TYPE_NORMAL
- en: a middle developer" }
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new BinaryTreeNode<string>()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Data = "Have you completed a university?",
  prefs: []
  type: TYPE_NORMAL
- en: Children =
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: new() { Data = "Apply as
  prefs: []
  type: TYPE_NORMAL
- en: a junior developer" },
  prefs: []
  type: TYPE_NORMAL
- en: new BinaryTreeNode<string>()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Data = "Will you find some time
  prefs: []
  type: TYPE_NORMAL
- en: during the semester?",
  prefs: []
  type: TYPE_NORMAL
- en: Children =
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: new() { Data = "Apply for
  prefs: []
  type: TYPE_NORMAL
- en: long-time internship" },
  prefs: []
  type: TYPE_NORMAL
- en: new() { Data = "Apply for
  prefs: []
  type: TYPE_NORMAL
- en: summer internship" }
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: tree.Count = 9;
  prefs: []
  type: TYPE_NORMAL
- en: return tree;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: public class BinarySearchTree<T>
  prefs: []
  type: TYPE_NORMAL
- en: ': BinaryTree<T>'
  prefs: []
  type: TYPE_NORMAL
- en: 'where T : IComparable'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: public bool Contains(T data)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTreeNode<T>? node = Root;
  prefs: []
  type: TYPE_NORMAL
- en: while (node != null)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int result = data.CompareTo(node.Data);
  prefs: []
  type: TYPE_NORMAL
- en: if (result == 0) { return true; }
  prefs: []
  type: TYPE_NORMAL
- en: else if (result < 0) { node = node.Left; }
  prefs: []
  type: TYPE_NORMAL
- en: else { node = node.Right; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: public void Add(T data)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTreeNode<T>? parent = GetParentForNewNode(data);
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTreeNode<T> node = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Data = data,
  prefs: []
  type: TYPE_NORMAL
- en: Parent = parent
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: if (parent == null)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Root = node;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (data.CompareTo(parent.Data) < 0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: parent.Left = node;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: parent.Right = node;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Count++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: private BinaryTreeNode<T>? GetParentForNewNode(T data)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTreeNode<T>? current = Root;
  prefs: []
  type: TYPE_NORMAL
- en: BinaryTreeNode<T>? parent = null;
  prefs: []
  type: TYPE_NORMAL
- en: while (current != null)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: parent = current;
  prefs: []
  type: TYPE_NORMAL
- en: int result = data.CompareTo(current.Data);
  prefs: []
  type: TYPE_NORMAL
- en: if (result == 0) { throw new ArgumentException(
  prefs: []
  type: TYPE_NORMAL
- en: $"The node {data} already exists."); }
  prefs: []
  type: TYPE_NORMAL
- en: else if (result < 0) { current = current.Left; }
  prefs: []
  type: TYPE_NORMAL
- en: else { current = current.Right; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return parent;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'public void Remove. The implementation of this private method is more complicated
    and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, the method checks whether the current node (the `node` parameter)
    exists. If not, you exit from the method.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `Remove` method tries to find the node to remove. That is achieved
    by comparing the value of the current node with the value for removal and calling
    the `Remove` method recursively for either the left or right subtree of the current
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting operations are performed in the following part of the
    method. Here, you need to handle four scenarios of node removal, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a leaf node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with only a left child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with only a right child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with both left and right children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of **removing a leaf node**, you just update a reference to the
    deleted node in the parent element. Therefore, there will be no reference from
    the parent node to the deleted node, and it cannot be reached while traversing
    the tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing a node with only a left child** is also simple because you only
    need to replace a reference to the deleted node (in the parent element) with the
    node that is a left child of the deleted node. This scenario is shown in the following
    diagram, which presents how to remove node **80** with only the left child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Removing a node with only a left child from a BST](img/B18069_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Removing a node with only a left child from a BST
  prefs: []
  type: TYPE_NORMAL
- en: The case of **removing a node with only a right child** is very similar to the
    second case. Thus, you just replace a reference to the deleted node (in the parent
    element) with the node that is a right child of the deleted node.
  prefs: []
  type: TYPE_NORMAL
- en: 'All those three cases are handled in the code in a similar way, by calling
    the `ReplaceInParent` auxiliary method, the code of which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes two parameters: the node for removal (`node`) and the node
    that should replace it in the parent node (`newNode`). For this reason, if you
    want to remove a leaf node, you just pass `null` as the second parameter because
    you do not want to replace the removed node with anything else. In the case of
    removing a node with only one child, you pass a reference to the left or right
    child.'
  prefs: []
  type: TYPE_NORMAL
- en: If the node for removal is not the root, you check whether it is the left child
    of the parent. If so, a proper reference is updated. It means that the new node
    is set as the left child of the parent node of the node for removal. In a similar
    way, the method handles the scenario when the node for removal is the right child
    of the parent. If the node for removal is the root, the node for replacing is
    set as the root. At the end, you check whether the new node is not equal to `null`.
    It means that you are not removing a leaf node. In such a case, you set a value
    of the `Parent` property to indicate that the new node should have the same parent
    as the node for removal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit more complicated scenario is `Remove` method recursively for the found
    node. The relevant part of the code is shown in the following code snippet, copied
    here from the `Remove` private method for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last auxiliary method is named `FindMinimumInSubtree` and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The method takes the root of the subtree, where the minimum value should be
    found, as the parameter. Within the method, a `while` loop is used to get the
    leftmost element. When there is no left child, the current value of the `node`
    variable is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Where you can find more information?
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of information about BSTs in books, research papers, as well
    as over the internet. Howe[ver, the presented implementation of a BST is ba](https://en.wikipedia.org/wiki/Binary_search_tree)sed
    on the code shown at https://en.wikipedia.org/wiki/Binary_search_tree, where you
    can also find more information about this data structure. I strongly encourage
    you to be curious about various data structures and algorithms and to broaden
    your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code does not look very difficult, does it? However, how does
    it work in practice? Let’s take a look at a diagram depicting the removal of a
    node with two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Removing a node with two children in a BST](img/B18069_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Removing a node with two children in a BST
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows how to remove the node with **40** as the value. To do so,
    you need to find the successor. It is the node with the minimum value in the right
    subtree of the node for removal. The successor is node **42**, which replaces
    node **40**.
  prefs: []
  type: TYPE_NORMAL
- en: Example – BST visualization
  prefs: []
  type: TYPE_NORMAL
- en: While reading the section regarding BSTs, you learned a lot about this data
    structure. So, it is high time to create an example program to see this variant
    of trees in action. The application will show you how to create a BST, add some
    nodes (both manually and using the previously presented method for insertion),
    remove nodes, traverse the tree, as well as visualize the tree in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning, a new tree (with nodes storing integer values) is prepared
    by creating a new instance of the `BinarySearchTree` class. It is configured manually
    by adding three nodes, together with indicating proper references for children
    and parent elements. The relevant part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you use the `Add` method to add some nodes to the tree and visualize
    the current state of the tree using the `Visualize` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add five more nodes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next set of operations is related to the removal of various nodes from
    the tree, together with visualization of particular changes. The part of the code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, all three traversal modes are presented. The suitable code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting task is the development of a tree visualization in the console.
    Such a feature is really useful because it allows a comfortable and fast way of
    observing the tree without the necessity of debugging the application in the IDE
    and expanding the following elements in the tooltip with the current values of
    variables. However, presenting a tree in the console is not a trivial task. Fortunately,
    you do not need to worry about it because you will learn how to implement such
    a feature in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s take a look at the `Visualize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The method takes two parameters, namely an instance of the `BinarySearchTree`
    class representing the whole tree, and a caption that should be shown above the
    visualization. Within the method, an array with characters that should be presented
    in the console is initialized using the `Initialize` auxiliary method, shown a
    bit later. Then, you call the `VisualizeNode` recursive method to fill various
    parts of the array with data regarding particular nodes existing in the tree.
    At the end, the caption and the board (represented by the array) are written in
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Initialize` method creates the aforementioned array, as presented in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The two-dimensional array contains the number of rows equal to the height of
    the tree multiplied by `2` to have space also for lines connecting nodes with
    parents. The number of columns is calculated according to the formula *columnwidth*
    * 2height - 1, where *columnwidth* is the `ColumnWidth` constant value and *height*
    is the height of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values can be simpler to understand if you take a look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.12 – \uFEFFScreenshot of the BST visualization example](img/B18069_07_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Screenshot of the BST visualization example
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Visualize` method, `VisualizeNode` is called. Are you interested to
    learn about how it works and how you can present not only the values of nodes
    but also lines? If so, let’s take a look at its code, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `VisualizeNode` method takes five parameters, including the current node
    for visualization (`node`), the index of a row (`row`), and the index of a column
    (`column`). Within the method, there is a check for whether the current node exists.
    If it does, the value of the node is obtained as a `char` array, the margin is
    calculated, and the `char` array (with a character-based representation of the
    value) is written in the buffer (the `console` variable) within a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines of code, the `VisualizeNode` method is called for the
    left and right child nodes of the current node. Of course, you need to adjust
    the index of the row (by adding `2`) and the index of the column (by adding or
    subtracting the calculated value).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, lines are drawn by calling the `DrawLineLeft` and `DrawLineRight`
    methods. The first is presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The method also takes five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The current node for which the line should be drawn (`node`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of a row (`row`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of a column (`column`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array as a screen buffer (`console`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A delta value calculated in the `VisualizeNode` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning, you check whether the current node contains a left child because
    only then is it necessary to draw the left part of the line. If so, you calculate
    the start (`sci`, which stands for *start column index*) and end (`eci` as *end
    column index*) indices of columns and fill the proper elements of the array with
    dashes. At the end, a plus sign is added to the array in the place where the drawn
    line will be connected with the right line of another element and on the other
    side of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In almost the same way, you draw the right line for the current node. Of course,
    you need to adjust the code regarding calculating column start and end indices.
    The final version of the code of the `DrawLineRight` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, let’s see the `Draw` method that shows the board in the console.
    It just iterates through all elements of the array and writes them in the console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all! You wrote the whole code necessary to build the project, launch
    the program, and see it in action. Just after launching, you will see the first
    BST, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.13 – \uFEFFScreenshot of the \uFEFFBST visualization example, step\
    \ 1](img/B18069_07_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Screenshot of the BST visualization example, step 1
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the next two nodes, `75` and `125`, the BST looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.14 – \uFEFFScreenshot of the BST visualization example, step 2](img/B18069_07_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Screenshot of the BST visualization example, step 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you perform an insertion operation for the next five elements. These
    operations have a very visible impact on the tree shape, as presented in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.15 – \uFEFFScreenshot of the BST visualization example, step 3](img/B18069_07_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Screenshot of the BST visualization example, step 3
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding 10 elements, the program shows the impact of removing a particular
    node on the shape of the tree. To start, let’s remove the leaf node with `25`
    as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.16 – \uFEFFScreenshot of the BST visualization example, step 4](img/B18069_07_16.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Screenshot of the BST visualization example, step 4
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the program removes a node with only one child node, namely the right
    one. What is interesting is that the right child also has a right child. However,
    the presented algorithm works properly in such conditions, and you receive the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.17 – \uFEFFScreenshot of the BST visualization example, step 5](img/B18069_07_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Screenshot of the BST visualization example, step 5
  prefs: []
  type: TYPE_NORMAL
- en: 'The last removal operation is the most complicated one because it requires
    you to remove the node with both children, and it also performs the role of the
    root. In such a case, the leftmost element from the right subtree of the root
    is found and replaces the node for removal, as shown in the final view of the
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.18 – \uFEFFScreenshot of the BST visualization example, step 6](img/B18069_07_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Screenshot of the BST visualization example, step 6
  prefs: []
  type: TYPE_NORMAL
- en: 'One more set of operations is left, namely traversal of the tree in pre-order,
    in-order, and post-order. The application presents the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The created application looks quite impressive, doesn’t it? You created not
    only the implementation of a BST from scratch but also prepared the platform for
    its visualization in the console. Great job!
  prefs: []
  type: TYPE_NORMAL
- en: Is it already sorted?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take one more look at the results of the in-order approach. As you can
    see, it gives you the nodes sorted in ascending order in the case of a BST.
  prefs: []
  type: TYPE_NORMAL
- en: However, can you see a potential problem with the created solution? What about
    a scenario where you remove nodes only from the given area of a tree or when you
    insert already sorted values? It could mean that a fat tree, with a proper **breadth-depth
    ratio**, could become a skinny one. In the worst case, it could even be depicted
    as a list, where all nodes have only one child. Do you have any idea how to solve
    the problem of unbalanced trees and keep them balanced all the time? If not, next,
    you will find some information on how to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Self-balancing trees
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will get to know two variants of a **self-balancing tree**,
    which **keeps the tree balanced all the time while adding and removing nodes.**
    However, why is it so important? As already mentioned, the lookup performance
    depends on the shape of the tree. In the case of improper organization of nodes,
    forming a list, the process of searching for a given value can be an *O(n)* operation.
    With a correctly arranged tree, the performance can be significantly improved
    with *O(log n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you know that a BST can very easily become an **unbalanced tree**? Let’s
    make a simple test of adding the following nine numbers to the tree, from **1**
    to **9**. Then, you will receive a tree with the shape shown in the following
    diagram on the left. However, the same values can be arranged in another way,
    as a **balanced tree**, with a significantly better breadth-depth ratio, which
    is shown on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Difference between an unbalanced and a balanced tree](img/B18069_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – Difference between an unbalanced and a balanced tree
  prefs: []
  type: TYPE_NORMAL
- en: You now know what unbalanced and balanced trees are, as well as what is the
    aim of self-balancing trees. However, what is an AVL tree or a red-black tree?
    How do they work? What rules should be taken into account while using these data
    structures? You will find answers to these questions next.
  prefs: []
  type: TYPE_NORMAL
- en: AVL trees
  prefs: []
  type: TYPE_NORMAL
- en: An **AVL tree** is named after its inventors, namely Adelson-Velsky and Landis.
    It is **a binary search tree with the additional requirement that, for each node,
    the height of its left and right subtrees cannot differ by more than one**. Of
    course, that rule must be maintained after adding and removing nodes from a tree.
    The important role is performed by **rotations**, used to fix incorrect arrangements
    of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: What about the performance?
  prefs: []
  type: TYPE_NORMAL
- en: While talking about AVL trees, it is crucial to indicate the performance of
    this data structure. In this case, both average and worst-case scenarios of insertion,
    removal, and lookup are *O(log n)*, so there is significant improvement in the
    worst-case scenarios in comparison with a BST.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of AVL trees, including various rotations necessary to keep
    the balanced state of a tree, is not trivial and will require quite a long explanation.
    Due to the limited number of pages in the book, its implementation is not presented
    here. Fortunately, you can use one of the available NuGet packages that support
    such tree-based data structures to benefit from AVL trees in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Red-black trees
  prefs: []
  type: TYPE_NORMAL
- en: 'A **red-black tree** (**RBT**) is the next variant of self-balancing binary
    search trees. As a variant of BSTs, this data structure requires that standard
    BST rules are maintained. Moreover, the following rules must be taken into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Each node must be colored either red or black**. Thus, you need to add additional
    data for a node that stores a color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NIL` pseudo-nodes should be used as leaves in the tree, while all other nodes
    are internal ones. Moreover, all `NIL` pseudo-nodes must be black.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If a node is red, both its children must** **be black**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any node, `NIL` pseudo-node) **must be** **the same**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A proper RBT is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.20 – \uFEFFIllustration of a red-black tree](img/B18069_07_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Illustration of a red-black tree
  prefs: []
  type: TYPE_NORMAL
- en: The tree consists of nine nodes, each colored red or black. It is worth mentioning
    the `NIL` pseudo-nodes, which are added as leaf nodes. If you again take a look
    at the set of rules listed previously, you can confirm that all such rules are
    maintained in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to AVL trees, RBTs also must maintain rules after adding or removing
    a node. In this case, the process of restoring the RBT properties is even more
    complicated because it involves both **recoloring** and **rotations**.
  prefs: []
  type: TYPE_NORMAL
- en: What about the performance?
  prefs: []
  type: TYPE_NORMAL
- en: While talking about this variant of self-balancing BSTs, it is also worth noting
    the performance. In both average and worst-case scenarios, insertion, removal,
    and lookup are *O(log n)* operations, so they are the same as in the case of AVL
    trees and much better in worst-case scenarios in comparison with BSTs.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you do not need to know and understand the internal details, which
    are quite complex, to benefit from this data structure and apply it to your projects.
    As already mentioned in the case of AVL trees, you can also use one of the available
    NuGet packages for RBTs.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: The topic of trees is much broader than shown in this chapter. For this reason,
    if you are interested in such a subject, I strongly encourage you to search for
    more information on your own. You can also find some content on *Wikipedia*, such
    as at [https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree)
    and [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
    Self-balancing trees are covered at [https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree)
    and [https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree).
    The topic of tries and binary heaps (mentioned later in this chapter) is presented
    as well at [https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie)
    and [https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap).
  prefs: []
  type: TYPE_NORMAL
- en: You already learned some basic information about self-balancing trees, namely
    AVL trees and RBTs. So, let’s take a look at another tree-based structure, namely
    a trie, which is a great solution for string-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: Tries
  prefs: []
  type: TYPE_NORMAL
- en: A tree is a powerful data structure that is used in various scenarios. One of
    them is related to processing strings, such as for **autocomplete** and **spellchecker**
    features that you certainly know from many systems. If you want to implement it
    in your application, you can benefit from another tree-based data structure, namely
    a **trie**. It is used to store strings and to perform prefix-based searching.
  prefs: []
  type: TYPE_NORMAL
- en: '**A trie is a tree with one root node, where each node represents a string
    and each edge indicates a character. A trie node contains references to the next
    nodes as an array with 26 elements, representing 26 chars from the alphabet (from**
    **a** **to** **z****). When you go from the root to each node, you receive a string,
    which is either a saved word or** **its substring**.'
  prefs: []
  type: TYPE_NORMAL
- en: Why exactly 26 elements?
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use 26 elements representing 26 chars because it is the exact number
    of basic characters between `a` and `z` in the alphabet, without any special characters
    existing in various languages. Of course, in your implementation, you can expand
    this set with other characters, such as `ą`, `ę`, or `ś` from Polish, as well
    as with even digits or some special characters, such as a dash. Choosing a proper
    set of characters depends on the scenario in which this data structure will be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does it sound complicated? It could, so let’s take a look at the following
    diagram, which should remove any doubts:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.21 – \uFEFFIllustration of a trie](img/B18069_07_21.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Illustration of a trie
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram depicts a trie that stores the following words: **ai**, **aid**,
    **aim**, **air**, **airplane**, **airport**, **algorithm**, **all**, **allergy**,
    **allow**, **allowance**. As you can see, there is a root node (marked with **-**)
    that contains only one child, namely for the **a** substring. This node contains
    two child nodes, regarding the **ai** word and the **al** substring. The **ai**
    node has three children, namely representing **aid**, **aim**, and **air** words.
    In a similar way, you can analyze the whole trie. Please keep in mind that words
    are marked with bolder lines while substrings are shown with lighter ones.'
  prefs: []
  type: TYPE_NORMAL
- en: What about the performance?
  prefs: []
  type: TYPE_NORMAL
- en: The searching and insertion in the case of a trie are *O(n)* operations, where
    *n* indicates a word length. So, a trie is an efficient data structure for string-based
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let’s move to something more exciting – coding!
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs: []
  type: TYPE_NORMAL
- en: 'Please take a look at the following implementation of a class representing
    a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `TrieNode` class contains two properties. The first is named `Children`
    and is an array with `26` elements. Each of them represents a particular letter
    from an alphabet, starting from `a` (index equal to `0`) and ending with `z` (index
    equal to `25`). If there is another word with the same prefix, a reference to
    the next node is located in a suitable element of the `Children` array. The second
    property is named `IsWord` and indicates whether the current node is the last
    char from a word. It means that you can get this word by moving from the root
    element to this node.
  prefs: []
  type: TYPE_NORMAL
- en: Trie
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the code shows the implementation of a class representing
    a trie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there is a private field representing the root element. Of course, you
    need to add some methods to make it operational. First, let’s implement a method
    that checks whether a given word exists in the trie. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, you save a reference to the root element as the current node.
    Then, you iterate through the following characters that form the word. For each
    character (represented by the `c` variable), you get a proper node (`child`).
    If it is `null`, it means that the word does not exist in the trie. Otherwise,
    you save the child element as the current one. When the `foreach` loop ends, the
    current node represents a node of the last character, so you just need to return
    the value of the `IsWord` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method allows you to insert a word into a trie, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a bit similar to that already described. However, there
    is one important difference in the `foreach` loop. Here, you create a new child
    node if it does not exist for any of the chars forming the word. At the end, you
    indicate that the node represents the word by setting the value of the `IsWord`
    property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, a trie is a data structure that allows you to perform
    **prefix-based searching** in an efficient way. So, let’s implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The method takes one parameter, namely the prefix of the searched words. At
    the beginning, you iterate through all characters of the prefix to get a reference
    to the last character forming the prefix. If a child node is not found at any
    phase, you return an empty list, which means that there are no results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you create a `List<string>` instance to store the result, and then
    you call the `GetAllWithPrefix` method, the code of which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You check whether the current node is `null`. If so, you return from the method.
    Otherwise, you verify whether the current node forms a word. If so, you add it
    to `results`. Next, you iterate through all alphabet characters, namely from `a`
    to `z`, and call the same method recursively to find the next words and add them
    to the list with `results`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the basic implementation of a trie is not a complicated task
    and can be done with clear and short code. However, how can you test a trie in
    action? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code forms a trie, as shown in *Figure 7**.21*, with 11 words
    starting with `a`, such as `algorithm` and `allow`. You add such words with the
    `Insert` method. Then, you check whether the `air` word exists with the `DoesExist`
    method. Next, you get all words that start with the `ai` prefix and write them
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the section regarding tries, let’s talk about the space complexity
    of this data structure. As you can see, you need to store 26 references to child
    nodes for each trie node, and there can be a lot of situations where only one
    or two references are set. For instance, you can take a look at the `algorithm`
    word, where a lot of space is wasted. It would be much better to optimize it in
    some way to make the whole tree smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it is possible to use another data structure that is named a **radix
    tree** or a **compressed trie**, which is **a space-optimized version of a trie**.
    The difference is quite simple: namely, **you merge with the parent each node
    that is the only child of this parent**. Of course, **edges can represent a substring**
    in such a case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see what a radix tree looks like for the same input data as
    in the diagram of a trie, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.22 – \uFEFFIllustration of a radix tree](img/B18069_07_22.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Illustration of a radix tree
  prefs: []
  type: TYPE_NORMAL
- en: Looks much simpler, doesn’t it? For example, let’s analyze the path from the
    root node to **algorithm**. Here, you use only three edges, namely **a**, **l**,
    and **gorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: Try to implement it on your own
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding diagram and the implementation of a trie, I encourage
    you to try to implement a radix tree on your own. You should also prepare a method
    for searching a word in such a data structure. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Example – autocomplete
  prefs: []
  type: TYPE_NORMAL
- en: As an example of a trie application, you will create an `Countries.txt` file
    with names of countries, as well as add it to the project as content that will
    be automatically copied to the output directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to add a file to the project?
  prefs: []
  type: TYPE_NORMAL
- en: You should right-click on the project node in the `.txt` extension. After confirmation,
    the file is created. If you want to mark this file as a content file and automatically
    copy it to the output directory, you should click on the file and change two properties
    in the **Properties** window. First, change **Build Action** to **Content**. Then,
    set **Copy to Output Directory** to **Copy always**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A part of the file with country names is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, a lot of country names are omitted in the preceding code snippet.
    However, when the file with country names is ready, you need to read its content
    and form a trie, as presented in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, you create a new instance of the `Trie` class. Then, you read
    all lines from the `Countries.txt` file and store them in the `countries` array.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the code consists of a `foreach` loop that iterates through
    all country names. For each of them, you make it lowercase and remove all chars
    other than `a`-`z`. Such a task is performed with a regular expression and the
    `Regex` class from the `System.Text.RegularExpressions` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the trie is ready, you use a `while` loop, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `while` loop, you wait until the user presses any key. If this key
    is other than `a`-`z`, the program ends its operation. Otherwise, you append the
    entered char to the prefix that is used for searching all country names that start
    with this prefix. If the number of results is equal to zero, the application ends
    its operation. Otherwise, you use the `ForEach` extension method to write each
    suggestion on a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a trie provides you with a powerful and efficient mechanism
    for implementing an autocomplete feature. But what does it look like in practice?
    Let’s take a look at the following output regarding searching for `POLAND`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, you can see names of countries that start with `P`. After
    typing `O`, you limit the results to countries whose names start with `PO`. In
    the same way, you further increase the prefix and get fewer and fewer results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed to the last part of this chapter, which is related to heaps. What
    are they, and why are they featured in a chapter about trees?
  prefs: []
  type: TYPE_NORMAL
- en: Heaps
  prefs: []
  type: TYPE_NORMAL
- en: A **heap** is another variant of a tree, which you already got to know in [*Chapter
    3*](B18069_03.xhtml#_idTextAnchor088), *Arrays and Sorting*. There, you used a
    heap in the heap sort algorithm for sorting an array. For this reason, in the
    current chapter, you will see only a brief summary of this data structure. However,
    I strongly encourage you not to leave this topic and learn much more about heaps
    on your own, as they are powerful and popular data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know, a binary heap exists in two versions: **min-heap** and
    **max-heap**. For each of them, an additional property must be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For min-heap**: The value of each node must be greater than or equal to the
    value of its parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For max-heap**: The value of each node must be less than or equal to the
    value of its parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules perform a very important role because they dictate that **the root
    node always contains the smallest value (in the min-heap) or the largest value
    (in the max-heap)**. You benefited from this assumption while sorting. Do you
    remember?
  prefs: []
  type: TYPE_NORMAL
- en: A binary heap must also adhere to the **complete binary tree** rule, which requires
    that **each node cannot contain more than two children and all levels of a tree
    must be fully filled, except the last one, which must be filled from left to right**
    and can have some space on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following two binary heaps:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.23 – \uFEFFIllustration of a min-heap and a max-heap](img/B18069_07_23.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Illustration of a min-heap and a max-heap
  prefs: []
  type: TYPE_NORMAL
- en: You can easily check whether both heaps adhere to all the rules. As an example,
    let’s verify the heap property for the node with a value equal to **20** from
    the min-heap variant (shown on the left). The node has two children with values
    of **35** and **50**, which are both greater than **20**. In the same way, you
    can check the remaining nodes in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The binary tree rule is also maintained, as each node contains at most two children.
    The last requirement is that each level of the tree is fully filled except the
    last one, which does not need to be fully filled, but must contain nodes from
    left to right. In the min-heap example, three levels are fully filled (with one,
    two, and four nodes), while the last level contains two nodes (**25** and **70**),
    placed on the two leftmost positions. In the same way, you can confirm that the
    max-heap (shown on the right) is configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this short introduction to the topic of heaps, and especially
    to binary heaps, it is worth mentioning the broad range of applications. First
    of all, this data structure is a convenient way of implementing a **priority queue**
    with the operation of inserting a new value and removing the smallest value (in
    the min-heap) or the largest value (in the max-heap). Moreover, a heap is used
    in the **heap sort algorithm**, as well as in **graph algorithms**.
  prefs: []
  type: TYPE_NORMAL
- en: A binary heap can either be implemented from scratch or you can use some of
    the already available implementations as NuGet packages. One of the solutions
    is named `PommaLabs.Hippie` and can be easily installed on the project using the
    **NuGet Package Manager**. The mentioned library contains an implementation of
    a few variants of heaps, including binary heaps, **binomial heaps**, and **Fibonacci
    heaps**.
  prefs: []
  type: TYPE_NORMAL
- en: Trees were everywhere in this chapter, and heaps are also representatives of
    this data structure! As you already learned a lot about trees, let’s proceed to
    the *Summary* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: The current chapter was the longest so far in the book. However, it contained
    a lot of information about variants of trees. Such data structures perform a very
    important role in many algorithms, and it is good to learn more about them, as
    well as to know how to use them in your applications. For this reason, this chapter
    contained not only short theoretical introductions but also diagrams, explanations,
    and code samples.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, **the concept of a tree** was described. As a reminder, a
    tree consists of **nodes**, including one **root**. The root does not contain
    a parent node, while all other nodes do. Each node can have any number of **child
    nodes**. The child nodes of the same node can be named **siblings**, while a node
    without children is named a **leaf**.
  prefs: []
  type: TYPE_NORMAL
- en: Various variants of trees follow this structure. The first one described in
    the chapter is a **binary tree**. In this case, a node can contain at most two
    children. However, the rules for **binary search trees** are even more strict.
    For any node in such trees, the values of all nodes in its left subtree must be
    smaller than the value of the node, while the values of all nodes in its right
    subtree must be greater than the value of the node. BSTs have a broad range of
    applications and provide developers with significant improvements in the lookup
    performance. However, it is possible to easily make a tree unbalanced while adding
    sorted values to the tree. Thus, the positive impact on the performance can be
    limited.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, `NIL` pseudo-nodes. Moreover, it is required that if a node is
    red, both its children must be black, and for any node, the number of black nodes
    on the route to a descendant leaf must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned a lot about **tries** and saw their great performance regarding
    processing strings, such as for autocomplete or spellchecker features. Each trie
    is a tree with one root node, where each node represents a string and each edge
    indicates a character. A trie node contains references to the next nodes as an
    array with elements representing possible characters. When you go from the root
    to each node, you receive a string, which is either a saved word or its substring.
    Within this part, a **radix tree** was mentioned as well, which is a space-optimized
    version of a trie.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the chapter was related to **binary heaps**. As a reminder,
    a heap is another variant of a tree, which exists in two versions, **min-heap**
    and **max-heap**. It is worth noting that the value of each node must be greater
    than or equal to (for min-heaps) or less than or equal to (for max-heaps) the
    value of its parent node.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed to **graphs**, which are the subject of the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
