<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Worker Services Using .NET Core</h1>
                
            
            
                
<p>The latest version of .NET Core includes a simple and convenient way to implement background processes. Moreover, starting from version 3.0, it is possible to create new projects using an out-of-the-box template for worker services. .NET worker services are suitable for multiple use cases. Furthermore, the increasing adoption of cloud technologies and distributed systems also involves event-driven communication between services, which requires the implementation of background processes. This chapter walks through some of the concepts and use cases of the worker services tools provided by ASP.NET Core. We will also have a look at how to integrate the worker service capabilities of ASP.NET Core to consume the <kbd>ItemSoldOut</kbd> event queue implemented in the previous chapter.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li style="font-weight: 400">Introduction to worker services</li>
<li>Implementing a worker service using .NET Core</li>
<li>Deploying and running a worker on Docker</li>
<li>Extending the background services class</li>
</ul>
<p>By the end of this chapter, you will be able to implement a worker service and deploy it using Docker container technology.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing worker services</h1>
                
            
            
                
<p>.NET Core worker services can be really useful every time we need to perform a repetitive or background-running operation. In more detail, they can be used in the application layer to enable asynchronous operations and handle the events of an event-based architecture. If every time you need to publish or listen for a message, you need to refresh data based on a schedule, or your application needs to queue a background work item, then you should probably use a worker service. Furthermore, with worker services, it is possible to run multiple background tasks on the same server without consuming a lot of resources.</p>
<p>The foundation of worker services in .NET Core is the <kbd>IHostedService</kbd> interface. The out-of-the-box worker service template can be used as a guideline to start implementing our worker service project. More importantly, the <kbd>IHostedService</kbd> interface is implemented by a <kbd>BackgroundService</kbd> class, which is the base class we should extend to implement our worker service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the worker services life cycle</h1>
                
            
            
                
<p>.NET Core uses the definition of the <kbd>BackgroundService</kbd> class to identify a worker service. The <kbd>BackgroundService</kbd> class exposes three methods that represent the life cycle stages of the worker service:</p>
<pre>namespace Microsoft.Extensions.Hosting<br/>{<br/>    public abstract class BackgroundService :<strong> IHostedService, </strong><strong>IDisposable</strong><br/>    {<br/>        public virtual Task <strong>StartAsync</strong>(CancellationToken <br/>            cancellationToken);<br/><br/>        protected abstract Task <strong>ExecuteAsync</strong>(CancellationToken <br/>            stoppingToken);<br/>        <br/>        public virtual async Task <strong>StopAsync</strong>(CancellationToken <br/>            cancellationToken);<br/>    }<br/>}</pre>
<p>The preceding code is the abstract implementation of the <kbd>BackgroundService</kbd> class. The class implements both the <kbd>IHostedService</kbd> and <kbd>IDisposable</kbd> interfaces, and it exposes the following methods:</p>
<ul>
<li>The <kbd>StartAsync</kbd> method represents the first stage of the life cycle of the worker. This method is called when the host is ready to run the worker service. It accepts a <kbd>CancellationToken</kbd> type parameter, which can be used to cancel the running task.</li>
<li>The <kbd>ExecuteAsync</kbd> method contains the core implementation of the <kbd>BackgroundService</kbd> class. This method is called once the <kbd>IHostedService</kbd> starts, and it returns a <kbd>Task</kbd> type that represents the status of the <kbd>Task</kbd>.</li>
<li>The <kbd>StopAsync</kbd> method is called when the hosted application is stopped gracefully.</li>
</ul>
<p>This section provided an overview of the worker service life cycle methods. In the next section, we will see the hosting models available for the worker services in .NET Core. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hosting models</h1>
                
            
            
                
<p>The .NET Core worker template is nothing more than a common .NET Core app. Furthermore, we can run the worker template as a common console application. Besides, the worker template also provides the hosting APIs to run the worker as an always-running process. In the case of Windows, it is possible to run the worker using Windows services technology. In the case of Linux, the worker runs using <kbd>systemd</kbd>.</p>
<p>Furthermore, .NET Core provides two different NuGet packages to specify the host behavior of the worker: the <kbd>Microsoft.Extensions.Hosting.WindowsServices</kbd> package and the <kbd>Microsoft.Extensions.Hosting.Systemd</kbd> package, both available on NuGet.</p>
<p>The <kbd>Microsoft.Extensions.Hosting.WindowsServices</kbd> package provides an extension method called <kbd>UseWindowsService()</kbd>, which can be applied after the initialization of the host in the <kbd>Main</kbd> method of the <kbd>Program</kbd> class. The <kbd>UseWindowsService()</kbd> method sets <kbd>WindowsServiceLifetime</kbd> and uses the <em>Windows event log</em> as the default logging output. </p>
<p>If we choose to host our worker as a <kbd>systemd</kbd> service, we need to use the <kbd>Microsoft.Extensions.Hosting.Systemd</kbd> NuGet package. This package provides the <kbd>UseSystemd()</kbd> method, which can be applied in the same way as <kbd>UseWindowsService()</kbd>; in this case, our worker service will use the <kbd>SystemdLifetime</kbd> class, and it configures the logging to be compliant with the <kbd>systemd</kbd> format.</p>
<p>It is important to note that both the <kbd>UseWindowsService()</kbd> and <kbd>UseSystemd()</kbd> methods are executed only if the worker service is running respectively as a Windows service and a <kbd>systemd</kbd> service. </p>
<p>Once we have discovered the different ways to host the worker service, we can proceed by applying these concepts to the concrete of a health-check process. Besides, we will also see how to run the worker on a Docker container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a health-checking worker</h1>
                
            
            
                
<p>The following section focuses on the implementation of a worker service. The use case we will cover is a health-checking worker of a generic web service. Furthermore, let's suppose that we want to check the health status of one of our web services regularly. This kind of check is usually performed at the end of the deployment pipeline, or once a service is deployed, to verify that the web service is up and running. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project structure overview</h1>
                
            
            
                
<p>This section gives you an overview of the worker template project provided out of the box by the .NET Core templating system. We will use this type of project to implement a health-check worker. First of all, let's start by creating a new project using the following CLI command:</p>
<pre><strong>dotnet new worker -n HealthCheckWorker</strong></pre>
<p>This command creates a new folder called <kbd>HealthCheckWorker</kbd> and it creates all of the files needed by a basic worker service project. Let's have a look at the files created by the template <kbd>dotnet new worker</kbd> command executed previously.</p>
<p>Secondly, we can run the <kbd>tree</kbd> CLI command (available both on macOS X and Windows), which shows the folder structure of the project previously created:</p>
<pre>.<br/>├── Program.cs<br/>├── Properties<br/>│   └── launchSettings.json<br/>├── Worker.cs<br/>├── HealthCheckWorker.csproj<br/>├── appsettings.Development.json<br/>├── appsettings.json<br/>├── bin<br/>│   └── Debug<br/>│       └── netcoreapp3.0<br/>└── obj<br/>  ├── Debug<br/>      └── netcoreapp3.0</pre>
<p class="mce-root">The <kbd>Program.cs</kbd> file is the entry point of our worker service. As the <kbd>webapi</kbd> template, the worker template uses the <kbd>Program.cs</kbd> file to initialize and retrieve a new <kbd>IHostBuilder</kbd> instance by calling the <kbd>Host.CreateDefaultBuilder</kbd> and <kbd>ConfigureServices</kbd> methods. The <kbd>Main</kbd> static method in the <kbd>Program.cs</kbd> file initializes a list of workers using the <kbd>AddHostedService</kbd> extension method:</p>
<pre>using Microsoft.Extensions.DependencyInjection;<br/>using Microsoft.Extensions.Hosting;<br/><br/>namespace HealthCheckWorker<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            CreateHostBuilder(args).Build().Run();<br/>        }<br/><br/>        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;<br/>            Host.CreateDefaultBuilder(args)<br/>                .ConfigureServices((hostContext, services) =&gt;<br/>                {<br/>                    <strong>services.AddHostedService&lt;Worker&gt;();</strong><br/>                });<br/>    }<br/>}</pre>
<p>As previously mentioned, the preceding snippet of code uses <kbd>AddHostedService</kbd> to initialize the <kbd>Worker</kbd> class created as a part of the default worker template. It is necessary to notice that, under the hood, <kbd>AddHostedService</kbd> initializes the class with a <kbd>Singleton</kbd> life cycle. Therefore, we will have one instance of the worker for the whole execution time of the worker service. In the next section, we will go deep into the life cycle execution of a worker.</p>
<p>Another major characteristic that distinguishes a worker project from any other .NET Core project is the use of the <kbd>Microsoft.NET.Sdk.Worker</kbd> SDK. Furthermore, we should also notice that the <kbd>*.csproj</kbd> file refers to only one additional NuGet package that provides the hosting extension methods used by the <kbd>Program</kbd> class and the <kbd>Main</kbd> method: <kbd>Microsoft.Extensions.Hosting</kbd>.</p>
<p>The next step is to create a new class that represents the configurations of the <kbd>HealthCheckWorker</kbd> project:</p>
<pre>namespace HealthCheckWorker<br/>{<br/>    public class HealthCheckSettings<br/>    {<br/>        public string Url { get; set; }<br/>        public int IntervalMs { get; set; }<br/>    }<br/>}</pre>
<p><kbd>HealthCheckSettings</kbd> will contain two attributes: the <kbd>Url</kbd> and <kbd>IntervalMs</kbd> attributes. The first attribute contains the HTTP URL of the health check address, specified in <kbd>appsettings.json</kbd><em>. </em>The <kbd>IntervalMs</kbd> attribute represents the frequency life cycle (in milliseconds) of the worker. </p>
<p>Furthermore, it is possible to use the configuration system of .NET Core to bind our configuration object at the execution of the <kbd>Main</kbd> method of the <kbd>Program.cs</kbd> file, using the following approach:</p>
<pre>using Microsoft.Extensions.DependencyInjection;<br/>using Microsoft.Extensions.Hosting;<br/><br/>namespace HealthCheckWorker<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            CreateHostBuilder(args).Build().Run();<br/>        }<br/><br/>        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;<br/>            Host.CreateDefaultBuilder(args)<br/>                <strong>.ConfigureServices((hostContext, services) =&gt;</strong><br/><strong>                {</strong><br/><strong>                    var healthCheckSettings = hostContext</strong><br/><strong>                        .Configuration<br/>                        .GetSection("HealthCheckSettings")</strong><strong><br/>      <br/>                    services.Configure&lt;HealthCheckSettings&gt;<br/>                        (healthCheckSettings);</strong><br/><strong>                    services.AddHostedService&lt;Worker&gt;();</strong><br/><strong>                });</strong><br/>    }<br/>}</pre>
<p>The preceding code uses <kbd>hostContext</kbd> to retrieve the <kbd>Configuration</kbd> instance provided by .NET Core. By default, <kbd>hostContext</kbd> will be populated with the settings structure written in the <kbd>appsettings.json</kbd> file. Moreover, it is possible to use the <kbd>GetSection</kbd> method to retrieve the specific configuration section from our <kbd>appsettings.json</kbd> file and bind it to the <kbd>HealthCheckSettings</kbd> type.</p>
<p>After that, we can proceed with the concrete implementation of the <kbd>Worker</kbd> class. Furthermore, we are now able to inject the <kbd>HealthCheckSettings</kbd> type instance using the built-in dependency injection of .NET Core. The settings are injected using the <kbd>IOption</kbd> interface:</p>
<pre>public class Worker : BackgroundService<br/>    {<br/>        private readonly ILogger&lt;Worker&gt; _logger;<br/>      <strong>  private readonly HealthCheckSettings _settings;</strong><br/>        <strong>private HttpClient _client;</strong><br/><br/>        public Worker(ILogger&lt;Worker&gt; logger, <br/><strong>        IOptions&lt;HealthCheckSettings&gt; options</strong>)<br/>        {<br/>            _logger = logger;<br/>            <strong>_settings = options.Value;</strong><br/>        }<br/>...</pre>
<p>The preceding code defines the attributes of the <kbd>Worker</kbd> class. As mentioned, the class implements an <kbd>_settings</kbd> attribute of the <kbd>HealthCheckSettings</kbd> type initialized using the constructor injection technique. Moreover, we can also see an <kbd>HttpClient</kbd> attribute, which will be initialized by the <kbd>StartAsync</kbd> method exposed by the <kbd>BackgroundService</kbd> class, and it is used in the <kbd>ExecuteAsync</kbd> method:</p>
<pre>public class Worker : BackgroundService<br/>{<br/>    ...<br/><br/><strong>    public override Task StartAsync(CancellationToken cancellationToken)</strong><br/><strong>    {</strong><br/><strong>        _client = new HttpClient();</strong><br/><strong>        return base.StartAsync(cancellationToken);</strong><br/><strong>    }</strong><br/><br/><strong>    protected override async Task ExecuteAsync(CancellationToken <br/>    stoppingToken)</strong><br/><strong>    {</strong><br/><strong>        while (!stoppingToken.IsCancellationRequested)</strong><br/><strong>        {</strong><br/><strong>            var result = await _client.GetAsync(_settings.Url);</strong><br/><br/><strong>            if (result.IsSuccessStatusCode)</strong><br/><strong>                _logger.LogInformation($"The web service is up. <br/>                HTTP {result.StatusCode}");</strong><br/><strong>            <br/>            await Task.Delay(_settings.IntervalMs, stoppingToken);</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/><br/>    ...<br/>}</pre>
<p>After the initialization of the client, the <kbd>ExecuteAsync</kbd> method implements a <kbd>while</kbd> loop that will continue until the <kbd>stoppingToken</kbd> requests the cancellation of the process. The core part of the loop uses the <kbd>GetAsync</kbd> method of <kbd>HttpClient</kbd> to check whether the health check route returns an HTTP status message. Finally, the code calls <kbd>Task.Delay</kbd> with the <kbd>IntervalMs</kbd> property populated with the <kbd>_settings</kbd> instance. </p>
<p>As the last step, the <kbd>Worker</kbd> class overrides the <kbd>StopAsync</kbd> method exposed by the <kbd>BackgroundService</kbd> class:</p>
<pre>public class Worker : BackgroundService<br/>{<br/>    ...<br/><br/><strong>    public override Task StopAsync(CancellationToken cancellationToken)</strong><br/><strong>    {</strong><br/><strong>        _client.Dispose();</strong><br/><strong>        return base.StopAsync(cancellationToken);</strong><br/><strong>    }</strong><br/><br/>}</pre>
<p>The <kbd>StopAsync</kbd> method executes the <kbd>HttpClient</kbd> instance disposition by calling the <kbd>Dispose()</kbd> method, and it calls <kbd>base.StopAsync(cancellationToken)</kbd> of the base <kbd>BackgroundService</kbd> class. </p>
<p>We should notice that the <kbd>StartAsync</kbd> and <kbd>StopAsync</kbd> methods always call the parent methods using the <kbd>base</kbd> keyword. Furthermore, in our case, we need to hold the behavior of the base <kbd>BackgroundService</kbd> class.</p>
<p>The next part of this chapter will be focused on the execution of the worker on a Docker container. We will see how to configure the <kbd>Dockerfile</kbd>, and deploy and run the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running a worker service on Docker</h1>
                
            
            
                
<p>This section is focused on the deployment step of the .NET worker template. We will proceed by running our service on a Docker Linux image. As we have already seen in <a href="d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml">Chapter 12</a>, <em>The Containerization of Services</em>, we will use Docker to run the application in a container.</p>
<p>Let's start by configuring the <kbd>Dockerfile</kbd> in the project folder:</p>
<pre>FROM mcr.microsoft.com/dotnet/core/runtime:3.0 AS base<br/>WORKDIR /app<br/><br/># Step 1 - Building the project<br/>FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build<br/>WORKDIR /src<br/>COPY ["HealthCheckWorker.csproj", "./"]<br/>RUN dotnet restore "./HealthCheckWorker.csproj"<br/>COPY . .<br/>WORKDIR "/src/."<br/>RUN dotnet build "HealthCheckWorker.csproj" -c Release -o /app/build<br/><br/># Step 2 - Publish the project<br/>FROM build AS publish<br/>RUN dotnet publish "HealthCheckWorker.csproj" -c Release -o /app/publish<br/><br/># Step 3 - Run the project<br/>FROM base AS final<br/>WORKDIR /app<br/>COPY --from=publish /app/publish .<br/>ENTRYPOINT ["dotnet", "HealthCheckWorker.dll"]</pre>
<p>The preceding code describes the container build and deployment process for our .NET Core worker application. The <kbd>Dockerfile</kbd> instructions can be grouped into five steps:</p>
<ol>
<li>The first step executes the build of the project using the <kbd>dotnet/core/sdk</kbd> Docker image:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>First of all, it sets the working directory as <kbd>/src</kbd> and copies the files in the project folder.</li>
<li>Secondly, it executes the <kbd>dotnet restore</kbd> and <kbd>dotnet build</kbd> commands.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>The second step runs the <kbd>dotnet publish</kbd> command using the <kbd>Release</kbd> configuration in the <kbd>/app/publish</kbd> folder.</li>
<li>The third step uses the <kbd>dotnet/core/runtime</kbd> Docker image to run the result of the previously executed <kbd>dotnet publish</kbd> using the <kbd>dotnet</kbd> CLI command.</li>
<li>It is possible to build the Docker image using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker build --rm -f "Dockerfile" -t healthcheckworker:latest</strong> </pre>
<ol start="5">
<li>Furthermore, we can run the previously built image using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker run --rm -d healthcheckworker:latest</strong></pre>
<p>The preceding command runs the Docker container and, consequently, the worker service process. The worker service will perform an HTTP <kbd>GET</kbd> request to the URL configured in the <kbd>appsettings.json</kbd> file of the project by applying throttling, also specified in the <kbd>appsettings.json</kbd> file.</p>
<p>The previously mentioned <kbd>Dockerfile</kbd> uses a multi-stage build approach and some other techniques to build the Docker image used to run the project. These concepts, and more, are described in detail in <a href="d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml">Chapter 12</a>, <em>The </em><em>Containerization of Services</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consuming the sold-out event</h1>
                
            
            
                
<p>The sold-out event we implemented in <a href="8f70e186-50f1-4d55-99e6-026c73d5bb96.xhtml">Chapter 13</a>, <em>Service Ecosystem Patterns,</em> provides the information on the items that are not available in the catalog. Furthermore, we can consume this event through the use of the <kbd>BackgroundService</kbd> type capabilities we described in this chapter. The cart service will implement a sold-out handler that will handle and remove the item IDs that are not available from the Redis instance. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a sold-out handler</h1>
                
            
            
                
<p>Let's start by creating a handler that manages the sold-out condition of a product in the cart service. First of all, we should proceed by adding the <kbd>RabbitMQ.Client</kbd> package to the <kbd>Cart.Domain</kbd> project by executing the following command:</p>
<pre><strong>dotnet add ./src/Cart.Domain package RabbitMQ.Client</strong></pre>
<p>We can continue by defining a class that represents the sold-out event that's used by the cart service in a new project that will contain all of the events. Therefore, we will proceed by creating a new <kbd>ItemSoldOutEvent</kbd> type, which represents a sold-out event:</p>
<pre>using MediatR;<br/><br/>namespace Cart.Domain.Events<br/>{<br/>    public class ItemSoldOutEvent : IRequest&lt;Unit&gt;<br/>    {<br/>        public string Id { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>ItemSoldOutEvent</kbd> type contains a reference to <kbd>Id</kbd> of the item that's sold out. The type will be used to deserialize the content of the queue into a strongly typed instance and send a message through the MediatR instance. As we did for the configurations of the catalog service, we will also need an analog class that represents the RabbitMQ configurations in the <kbd>Cart.Infrastructure</kbd> project:</p>
<pre>namespace Cart.Infrastructure.Configurations<br/>{<br/>    public class EventBusSettings<br/>    {<br/>        public string HostName { get; set; }<br/>        public string User { get; set; }<br/>        public string Password { get; set; }<br/>        public string EventQueue { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>EventBusSettings</kbd> type defined previously describes <kbd>HostName</kbd> of the RabbitMQ instance, <kbd>User</kbd> and <kbd>Password</kbd> of the user, and the <kbd>EventQueue</kbd> name to use to push messages. Furthermore, we can proceed by defining the mediator handler for consuming the <kbd>ItemSoldOutEvent</kbd> events by defining a new class in the <kbd>Cart.Domain</kbd> project:</p>
<pre>using System;<br/>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Entities;<br/>using Cart.Domain.Events;<br/>using Cart.Domain.Repositories;<br/>using MediatR;<br/><br/>namespace Cart.Domain.Handlers.Cart<br/>{<br/>    public class ItemSoldOutEventHandler : <br/>        IRequestHandler&lt;ItemSoldOutEvent&gt;<br/>    {<br/>        private readonly ICartRepository _cartRepository;<br/><br/>        public ItemSoldOutEventHandler(ICartRepository cartRepository)<br/>        {<br/>            _cartRepository = cartRepository;<br/>        }<br/>        <br/>        public async Task&lt;Unit&gt; Handle(ItemSoldOutEvent @event, <br/>            CancellationToken cancellationToken)<br/>        {<br/>            var cartIds = _cartRepository.GetCarts().ToList();<br/><br/>            var tasks = cartIds.Select(async x =&gt;<br/>            {<br/>                var cart = await _cartRepository.GetAsync(new Guid(x));<br/>                await RemoveItemsInCart(@event.Id, cart);<br/>            });<br/><br/>            await Task.WhenAll(tasks);<br/>            <br/>            return Unit.Value;<br/>        }<br/><br/>        private async Task RemoveItemsInCart(string itemToRemove, <br/>            CartSession cartSessionSession)<br/>        {<br/>            if (string.IsNullOrEmpty(itemToRemove)) return;<br/><br/>            var toDelete = cartSessionSession?.Items?.Where(x =&gt; <br/>                x.CartItemId.ToString() ==           <br/>                     itemToRemove).ToList();<br/><br/>            if (toDelete == null || toDelete.Count == 0) return;<br/><br/>            foreach (var item in toDelete) <br/>                cartSessionSession.Items?.Remove(item);<br/><br/>            await _cartRepository.AddOrUpdateAsync(cartSessionSession);<br/>        }<br/>    }<br/>}</pre>
<p>The previous <kbd>ItemSoldOutEventHandler</kbd> class implements the <kbd>IRequestHandler&lt;T&gt;</kbd> interface that's provided by the MediatR package. This interface contains the <kbd>Handle</kbd> method, which is the main entry point of the handler. A new <kbd>ItemSoldOutEventHandler</kbd> instance will be executed when an event of the <kbd>ItemSoldOutEvent</kbd> type is received by the cart service. <kbd>ItemSoldOutEventHandler</kbd> depends on <kbd>ICartRepository</kbd>. Furthermore, the <kbd>RemoveItemsInCart</kbd> method retrieves all of the carts stored in our repository, and it removes the sold-out items every time it receives a message of the <kbd>ItemSoldOutEvent</kbd> type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the sold-out process</h1>
                
            
            
                
<p>It is possible to check the sold-out process by testing <kbd>ItemSoldOutHandler</kbd>. The handler will be tested with the same approach we saw for the other handlers:</p>
<pre>using System;<br/>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Events;<br/>using Cart.Domain.Handlers.Cart;<br/>using Cart.Fixtures;<br/>using Shouldly;<br/>using Xunit;<br/><br/>namespace Cart.Domain.Tests.Handlers.Events<br/>{<br/>    public class ItemSoldOutEventHandlerTests : IClassFixture&lt;CartContextFactory&gt;<br/>    {<br/>        private readonly CartContextFactory _contextFactory;<br/><br/>        public ItemSoldOutEventHandlerTests(CartContextFactory <br/>            cartContextFactory)<br/>        {<br/>            _contextFactory = cartContextFactory;<br/>        }<br/><br/>        [Fact]<br/>        public async Task should_not_remove_records_when<em>soldout<br/>            </em>message_contains_not_existing_id()<br/>        {<br/>            var repository = _contextFactory.GetCartRepository();<br/>            var itemSoldOutEventHandler = new <br/>                ItemSoldOutEventHandler(repository);<br/>            var found = false;<br/><br/>            await itemSoldOutEventHandler.Handle(new ItemSoldOutEvent { <br/>                Id = Guid.NewGuid().ToString() }, <br/>                   CancellationToken.None);<br/><br/>            var cartsIds = repository.GetCarts();<br/><br/>            foreach (var cartId in cartsIds)<br/>            {<br/>                var cart = await repository.GetAsync(new Guid(cartId));<br/>                found = cart.Items.Any(i =&gt; i.CartItemId.ToString() == <br/>                    "be05537d-5e80-45c1-bd8c-<br/>                     aa21c0f1251e");<br/>            }<br/><br/>            found.ShouldBeTrue();<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>The <kbd>ItemSoldOutEventHandlerTests</kbd> class uses the <kbd>CartContextFactory</kbd> class to initialize a new repository in each test method using the <kbd>_contextFactory.GetCartRepository();</kbd> method. Furthermore, the <kbd>should_not_remove_records_when_soldout_message_contains_not_existing_id</kbd> test method checks that nothing breaks if the <kbd>ItemSoldOutEvent</kbd> instance has a non-existent ID. On the other hand, the <kbd>should_remove_records_when_soldout_messages_contains_existing_ids</kbd> test method checks that <kbd>ItemSoldOutEventHandler</kbd> deletes the item in the basket when the <kbd>ItemSoldOutEvent</kbd> instance contains an existing ID:</p>
<pre>...<br/>        [Fact]<br/>        public async Task should_remove_records_when<em>soldout<br/>            </em>messages_contains_existing_ids()<br/>        {<br/>            var itemSoldOutId = "be05537d-5e80-45c1-bd8c-aa21c0f1251e";<br/>            var repository = _contextFactory.GetCartRepository();<br/>            var itemSoldOutEventHandler = new <br/>                ItemSoldOutEventHandler(repository);<br/>            var found = false;<br/><br/>            await itemSoldOutEventHandler.Handle(new ItemSoldOutEvent { <br/>              Id = itemSoldOutId }, <br/>                CancellationToken.None);<br/><br/>            foreach (var cartId in repository.GetCarts())<br/>            {<br/>                var cart = await repository.GetAsync(new Guid(cartId));<br/>                found = cart.Items.Any(i =&gt; i.CartItemId.ToString() == <br/>                    itemSoldOutId);<br/>            }<br/><br/>            found.ShouldBeFalse();<br/>        }<br/>    }<br/>}</pre>
<p>The second test method provides an existing item ID and verifies the handle method by checking whether the process has effectively removed the items. Now that we have verified the behavior of <kbd>ItemSoldOutHandler</kbd>, we can proceed by configuring and registering the event bus instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring the background service</h1>
                
            
            
                
<p>Now that we have defined the event bus abstraction, we can proceed by creating a new <kbd>BackgroundService</kbd> type that will use the <kbd>IMediator</kbd> interface to dispatch the sold-out messages. This book uses RabbitMQ because it is open source and easy to configure but keep in mind that there are tons of products and technologies related to this topic. Before continuing with the implementation of the background service, it is necessary to add some packages to the <kbd>Cart.Infrastructure</kbd> project:</p>
<pre><strong>dotnet add package RabbitMQ.Client</strong></pre>
<p>Furthermore, we can proceed by creating a new class that extends the <kbd>BackgroundService</kbd> type:</p>
<pre>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Cart.Domain.Events;<br/>using Cart.Infrastructure.Configurations;<br/>using MediatR;<br/>using Microsoft.Extensions.Hosting;<br/>using Microsoft.Extensions.Logging;<br/>using Microsoft.Extensions.Options;<br/>using Newtonsoft.Json;<br/>using RabbitMQ.Client;<br/>using RabbitMQ.Client.Events;<br/><br/>namespace Cart.Infrastructure.BackgroundServices<br/>{<br/>    public class ItemSoldOutBackgroundService : BackgroundService<br/>    {<br/>        private readonly IMediator _mediator;<br/>        private readonly ILogger&lt;ItemSoldOutBackgroundService&gt; _logger;<br/>        private readonly EventBusSettings _options;<br/>        private readonly IModel _channel;<br/><br/>        public ItemSoldOutBackgroundService( IMediator mediator,<br/>            EventBusSettings options, ConnectionFactory factory, <br/>                ILogger&lt;ItemSoldOutBackgroundService&gt; logger)<br/>        {<br/>            _options = options;<br/>            _logger = logger;<br/>            _mediator = mediator;<br/><br/>            try<br/>            {<br/>              <strong>  var connection = factory.CreateConnection();</strong><br/><strong>                _channel = connection.CreateModel();</strong><br/>            }<br/>            catch (Exception e)<br/>            {<br/>                _logger.LogWarning("Unable to initialize the event bus: <br/>                    {message}", e.Message);<br/>            }<br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>The preceding snippet defines the <kbd>ItemSoldOutBackgroundService</kbd> type. The class extends the <kbd>BackgroundService</kbd> base class exposed by the <kbd>Microsoft.Extensions.Hosting</kbd> namespace. The constructor injects the <kbd>IMediator</kbd> interface to dispatch the collected events to the <kbd>ItemSoldOutEventHandler</kbd> type. Furthermore, it also defines the attribute of the <kbd>IModel</kbd> type that will be populated by the <kbd>ConnectionFactory</kbd> type injected in the constructor. The <kbd>_channel</kbd> attribute will be used by the <kbd>ExecuteAsync</kbd> method provided by the <kbd>BackgroundService</kbd> class to dispatch the events. Let's proceed by overriding the <kbd>ExecuteAsync</kbd> method:</p>
<pre>using MediatR;<br/>using Microsoft.Extensions.Hosting;<br/>using Newtonsoft.Json;<br/>using RabbitMQ.Client;<br/>using RabbitMQ.Client.Events;<br/><br/>namespace Cart.Infrastructure.BackgroundServices<br/>{<br/>    public class ItemSoldOutBackgroundService : BackgroundService<br/>    {<br/>         ...<br/><br/>        protected override Task ExecuteAsync(CancellationToken <br/>            stoppingToken)<br/>        {<br/>            stoppingToken.ThrowIfCancellationRequested();<br/><br/>            var consumer = new EventingBasicConsumer(_channel);<br/>     <br/>            consumer.Received += async (ch, ea) =&gt;<br/>            {<br/>                var content = System.Text.Encoding.UTF8.<br/>                    GetString(ea.Body);<br/>                var @event = JsonConvert.DeserializeObject<br/>                    &lt;ItemSoldOutEvent&gt;(content);<br/><br/>                await _mediator.Send(@event, stoppingToken);<br/>                _channel.BasicAck(ea.DeliveryTag, false);<br/>            };<br/><br/>            try<br/>            {<br/>                consumer.Model.QueueDeclare(_settings.EventQueue, true, <br/>                    false);                                         <br/>                _channel.BasicConsume(_options.EventQueue, false, <br/>                    consumer);<br/>            }<br/>            catch (Exception e)<br/>            {<br/>                _logger.LogWarning("Unable to consume the event bus: <br/>                    {message}", e.Message);<br/>            }<br/><br/>            return Task.CompletedTask;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding snippet uses the <kbd>_channel</kbd> attribute to initialize a new <kbd>EventingBasicConsumer</kbd> instance. For each received message, it deserializes the <kbd>Body</kbd> attribute into an <kbd>ItemSoldOutEvent</kbd> type and it sends the event to the <kbd>IMediator</kbd> instance using the <kbd>Send</kbd> method. Finally, it activates the consuming process by using the <kbd>EventQueue</kbd> name provided by the <kbd>EventBusSettings</kbd> type. Also, in this case, the consumption process is wrapped using a try-catch to isolate the process in the event of failure.</p>
<p>Before we can use RabbitMQ, it is necessary to configure the client so that we connect to the right event bus instance. Let's start by creating a new extension method in the <kbd>Cart.Infrastructure</kbd> project, which can be found under the <kbd>Extensions</kbd> folder:</p>
<pre>using Cart.Infrastructure.Configurations;<br/>using Microsoft.Extensions.Configuration;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using RabbitMQ.Client;<br/><br/>namespace Cart.Infrastructure.Extensions<br/>{<br/>    public static class EventsExtensions<br/>    {<br/>        public static IServiceCollection AddEventBus(this <br/>            IServiceCollection services, IConfiguration    <br/>         configuration)<br/>        {<br/>            var config = new EventBusSettings();<br/>            configuration.Bind("EventBus", config);<br/>            services.AddSingleton(config);<br/><br/>            ConnectionFactory factory = new ConnectionFactory<br/>            {<br/>                HostName = config.HostName,<br/>                UserName = config.User,<br/>                Password = config.Password<br/>            };<br/><br/>            services.AddSingleton(factory);<br/><br/>            return services;<br/>        }<br/>    }<br/>}</pre>
<p>The previous definition implements an extension method bound with the <kbd>IServiceCollection</kbd> interface, which is provided by the dependency injection system of ASP.NET Core. It is used in the <kbd>Startup</kbd> class to connect to RabbitMQ.<em> </em>The <kbd>AddEventBus</kbd> method initializes the <kbd>ConnectionFactory</kbd> class by passing the parameter of RabbitMQ. </p>
<p>Finally, we can proceed by activating the background service by adding the following extension methods to the <kbd>ConfigureServices</kbd> method of the <kbd>Startup</kbd> class:</p>
<pre>using System;<br/>...<br/><br/>namespace Cart.API<br/>{<br/>    public class Startup<br/>    {<br/>     <br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/><strong>            services<br/>                   ...<br/>                .AddEventBus(Configuration)<br/>                .AddHostedService&lt;ItemSoldOutBackgroundService&gt;();</strong><br/>        }<br/><br/>        ...<br/>    }<br/>}</pre>
<p>The <kbd>AddEventBus</kbd> method adds all of the dependencies needed by the consumption process of the sold-out events to the dependency injection. Also, the <kbd>AddHostedService</kbd> method registers <kbd>ItemSoldOutBackgroundService</kbd> as the <kbd>IHostedService</kbd> type. Finally, to use the event bus, we can proceed by defining the connection information in the <kbd>appsettings.json</kbd> file of the <kbd>Cart.API</kbd> project, as follows:</p>
<pre>{<br/>...<br/>  "EventBus": {<br/>    "HostName": "catalog_esb",<br/>    "User": "guest",<br/>    "Password": "guest",<br/>    "EventQueue": "ItemSoldOut"<br/>  }<br/>}<br/></pre>
<p>The connection parameters point to the <kbd>catalog_esb</kbd> instance defined in the <kbd>docker-compose.yml</kbd> file defined in the catalog service. Furthermore, the <kbd>ItemSoldOutBackgroundService</kbd> class will process the message in the <kbd>ItemSoldOut</kbd> queue and trigger the removal of the items.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter described how you can use the .NET Core worker template to implement a continuously running task. .NET Core workers are really useful in distributed systems to perform all of the asynchronous and event-based computations without an increase in the load of the server. </p>
<p>The integration with Windows services and <kbd>systemd</kbd> also provides an efficient way to deploy and to run the worker. This chapter has given you an overview of the .NET Core worker service hosting models, and it showed how to set up and implement a worker service using .NET Core and how to run it on Docker. Finally, we saw how to integrate the <kbd>BackgroundService</kbd> class capabilities with the previously implemented item sold-out message integration.</p>
<p>The next chapter will cover some of the common security practices provided and implemented by .NET Core.</p>


            

            
        
    </body></html>