- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing in ASP.NET Core (Part 2 – Integration Testing)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的测试（第2部分 - 集成测试）
- en: In [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371), we learned how to write
    unit tests for a ASP.NET Core web API application. Unit tests are used to test
    code units in isolation. However, a code unit often depends on other components,
    such as the database, external services, and so on. To test the code thoroughly,
    we need to test the code units in the context of the application. In other words,
    we need to test how the code units interact with other parts of the application.
    This type of testing is called integration testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中，我们学习了如何为 ASP.NET Core Web API 应用程序编写单元测试。单元测试用于测试独立的代码单元。然而，一个代码单元通常依赖于其他组件，例如数据库、外部服务等。为了彻底测试代码，我们需要在应用程序的上下文中测试代码单元。换句话说，我们需要测试代码单元如何与其他应用程序部分交互。这种测试类型被称为集成测试。
- en: 'In this chapter, we will mainly focus on integration testing. We will cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注集成测试。我们将涵盖以下主题：
- en: Writing integration tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: Testing with authentication and authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有身份验证和授权的测试
- en: Understanding code coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码覆盖率
- en: By the end of this chapter, you should be able to write integration tests for
    a ASP.NET Core web API application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够为 ASP.NET Core Web API 应用程序编写集成测试。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
    You can use VS Code or VS 2022 to open the solutions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8)找到。您可以使用
    VS Code 或 VS 2022 打开解决方案。
- en: Writing integration tests
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写集成测试
- en: In the unit tests, we create the instances of the controllers directly. This
    approach does not consider some features of ASP.NET Core, such as routing, model
    binding, and validation and so on. To test the application thoroughly, we need
    to write integration tests. In this section, we will write integration tests for
    the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，我们直接创建控制器的实例。这种方法没有考虑到 ASP.NET Core 的某些特性，例如路由、模型绑定和验证等。为了彻底测试应用程序，我们需要编写集成测试。在本节中，我们将编写应用程序的集成测试。
- en: Unlike unit tests, which focus on isolated units, integration tests focus on
    the interactions between components. These integration tests may involve different
    layers, such as the database, the file system, the network, the HTTP request/response
    pipeline and so on. Integration tests ensure that the components of the application
    work together as expected. So, normally, integration tests use actual dependencies
    instead of mocks. Also, integration tests are slower than unit tests because they
    involve more components. Considering the cost of integration tests, we do not
    need to write too many integration tests. Instead, we should focus on the critical
    parts of the application. Most of the time, we can use unit tests to cover the
    other parts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与关注独立单元的单元测试不同，集成测试关注组件之间的交互。这些集成测试可能涉及不同的层，例如数据库、文件系统、网络、HTTP 请求/响应管道等。集成测试确保应用程序的组件按预期协同工作。因此，通常集成测试使用实际依赖项而不是模拟。此外，由于涉及更多组件，集成测试比单元测试慢。考虑到集成测试的成本，我们不需要编写太多的集成测试。相反，我们应该关注应用程序的关键部分。大多数时候，我们可以使用单元测试来覆盖其他部分。
- en: You can find the sample code of this section in the `IntegrationTestsDemo` folder.
    The code is based on the `InvoiceApp` project we created in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
    You can use VS 2022 or VS Code to open the solution. We will use the term **System
    Under Test** (**SUT**) to refer to the ASP.NET Core web API application we are
    testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `IntegrationTestsDemo` 文件夹中找到本节的示例代码。代码基于我们在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中创建的
    `InvoiceApp` 项目。您可以使用 VS 2022 或 VS Code 打开解决方案。我们将使用术语 **系统测试对象** (**SUT**) 来指代我们正在测试的
    ASP.NET Core Web API 应用程序。
- en: Setting up the integration test project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置集成测试项目
- en: We can continue to use **xUnit** as the test framework for integration tests.
    A good practice is to create a separate integration test project from the unit
    test project. This approach allows us to run the unit tests and integration tests
    separately and also makes it easier to use different configurations for the two
    types of tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用 **xUnit** 作为集成测试的测试框架。一种好的做法是从单元测试项目中创建一个单独的集成测试项目。这种方法允许我们分别运行单元测试和集成测试，并且也使得为这两种类型的测试使用不同的配置变得更容易。
- en: If you are using VS 2022, you can create a new xUnit project by right-clicking
    on the solution and selecting `InvoiceApp.IntegrationTests` and click `InvoiceApp.WebApi`
    project to allow the integration test project to access the classes in the web
    API project (see [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 VS 2022，您可以通过右键单击解决方案并选择 `InvoiceApp.IntegrationTests` 来创建一个新的 xUnit
    项目，然后点击 `InvoiceApp.WebApi` 项目以允许集成测试项目访问 Web API 项目中的类（参见 [*第 9 章*](B18971_09.xhtml#_idTextAnchor371)）。
- en: 'If you are using **.NET CLI**, you can create a new xUnit test project by running
    the following commands in the terminal:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 **.NET CLI**，您可以在终端中运行以下命令来创建一个新的 xUnit 测试项目：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ASP.NET Core provides a built-in test web host that we can use to host the SUT
    to handle the HTTP requests. The benefit of using a test web host is that we can
    use a different configuration for the test environment, and it also saves the
    network traffic because the HTTP requests are handled in the same process. So,
    the tests using a test web host are faster than those using a real web host. To
    use the test web host, we need to add the `Microsoft.AspNetCore.Mvc.Testing` NuGet
    package to the integration test project. You can add the package in VS 2022 by
    right-clicking on the project and selecting `Microsoft.AspNetCore.Mvc.Testing`
    and install the package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一个内置的测试 Web 服务器，我们可以用它来托管 SUT 以处理 HTTP 请求。使用测试 Web 服务器的优点是我们可以为测试环境使用不同的配置，并且它还可以节省网络流量，因为
    HTTP 请求是在同一个进程中处理的。因此，使用测试 Web 服务器进行的测试比使用真实 Web 服务器进行的测试要快。要使用测试 Web 服务器，我们需要将
    `Microsoft.AspNetCore.Mvc.Testing` NuGet 包添加到集成测试项目中。您可以在 VS 2022 中通过右键单击项目并选择
    `Microsoft.AspNetCore.Mvc.Testing` 来添加包，并安装该包。
- en: 'You can also use the following command to add the package:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令来添加包：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default `UnitTest1.cs` file can be removed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `UnitTest1.cs` 文件可以被移除。
- en: Feel free to install **FluentAssertions** if you want to use it in the tests,
    as we demonstrated in the *Using FluentAssertions to verify the test results*
    section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在测试中使用 **FluentAssertions**，请随意安装，正如我们在 [*第 9 章*](B18971_09.xhtml#_idTextAnchor371)
    的 *使用 FluentAssertions 验证测试结果* 部分中所展示的。
- en: Now we can start to write integration tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写集成测试。
- en: Writing basic integration tests with WebApplicationFactory
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WebApplicationFactory 编写基本集成测试
- en: Let'sstart with a simple integration test to check whether the SUT can correctly
    handle the HTTP requests. The sample application has a `WeatherForecastController.cs`
    controller that is provided by the ASP.NET Core project template. It returns a
    list of weather forecasts. We can write an integration test to check whether the
    controller returns the expected result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的集成测试开始，检查 SUT 是否可以正确处理 HTTP 请求。示例应用程序有一个由 ASP.NET Core 项目模板提供的 `WeatherForecastController.cs`
    控制器。它返回一组天气预报。我们可以编写一个集成测试来检查控制器是否返回预期的结果。
- en: 'Create a new file named `WeatherForecastApiTests` in the `InvoiceApp.IntegrationTests`
    project. Then add the following code to the file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InvoiceApp.IntegrationTests` 项目中创建一个名为 `WeatherForecastApiTests` 的新文件。然后向该文件添加以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the test class, we use the `WebApplicationFactory<T>` type to create a test
    web host and use it as the class fixture. The instance of this class fixture will
    be shared across the tests in the class. The `WebApplicationFactory<T>` type is
    provided by the `Microsoft.AspNetCore.Mvc.Testing` package. It is a generic type
    that allows us to create a test web host for the specified application entry point.
    In this case, we use the `Program` class defined in the web API project as the
    entry point. But you will see an error that says `CS0122'Program' is inaccessible
    due to its protection level`. This is because the `Program` class is defined as
    `internal` by default.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类中，我们使用 `WebApplicationFactory<T>` 类型创建一个测试Web主机，并将其用作类固定。这个类固定实例将在类中的所有测试之间共享。`WebApplicationFactory<T>`
    类型由 `Microsoft.AspNetCore.Mvc.Testing` 包提供。它是一个泛型类型，允许我们为指定的应用程序入口点创建测试Web主机。在这种情况下，我们使用Web
    API项目中定义的 `Program` 类作为入口点。但你会看到一个错误，说 `CS0122'Program' is inaccessible due to
    its protection level`。这是因为 `Program` 类默认定义为 `internal`。
- en: 'To solve this issue, there are two ways:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有两种方法：
- en: 'Open the `InvoiceApp.WebApi.csproj` file and add the following line to the
    file:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开 `InvoiceApp.WebApi.csproj` 文件，并向文件中添加以下行：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Replace `MyTestProject` with the name of your test project, such as `InvoiceApp.IntegrationTests`.
    This approach allows the test project to access the internal members of the web
    API project.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `MyTestProject` 替换为你的测试项目名称，例如 `InvoiceApp.IntegrationTests`。这种方法允许测试项目访问Web
    API项目的内部成员。
- en: 'Alternatively, you can change the access modifier of the `Program` class to
    `public`. Add the following code to the end of the `Program.cs` file:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以将 `Program` 类的访问修饰符更改为 `public`。将以下代码添加到 `Program.cs` 文件的末尾：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use either approach to solve the issue. After that, we can write the
    test method, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这两种方法中的任何一种来解决问题。之后，我们可以编写测试方法，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the test method, we first create an instance of the `HttpClient` class using
    the `WebApplicationFactory<T>` instance. Then we send an HTTP `GET` request to
    the `/WeatherForecast` endpoint. The `EnsureSuccessStatusCode` method ensures
    that the response has a status code in the *200-299* range. Then we check whether
    the content type of the response is `application/json; charset=utf-8`. Finally,
    we deserialize the response content to a list of `WeatherForecast` objects and
    check whether the list contains five items.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方法中，我们首先使用 `WebApplicationFactory<T>` 实例创建 `HttpClient` 类的实例。然后，我们向 `/WeatherForecast`
    端点发送HTTP `GET` 请求。`EnsureSuccessStatusCode` 方法确保响应的状态码在 *200-299* 范围内。然后我们检查响应的内容类型是否为
    `application/json; charset=utf-8`。最后，我们将响应内容反序列化为 `WeatherForecast` 对象的列表，并检查列表是否包含五个项目。
- en: Because this controller does not have any dependencies, the test is simple.
    What if the controller has dependencies, such as a database context, other services,
    or other external dependencies? We will see how to handle these scenarios in the
    following sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个控制器没有任何依赖项，测试很简单。如果控制器有依赖项，比如数据库上下文、其他服务或其他外部依赖项，怎么办？我们将在以下章节中看到如何处理这些场景。
- en: Testing with a database context
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据库上下文进行测试
- en: In the sample application, the `ContactController` class has dependencies, such
    as the `IContactRepository` interface. The `ContactRepository` class implements
    this interface and uses the `InvoiceContext` class to access the database. So,
    if we want to test whether the SUT can correctly handle the HTTP requests, we
    need to create a test database and configure the test web host to use the test
    database. Similar to the unit tests, we can use a separate database for integration
    tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，`ContactController` 类有依赖项，例如 `IContactRepository` 接口。`ContactRepository`
    类实现了这个接口，并使用 `InvoiceContext` 类来访问数据库。因此，如果我们想测试系统单元（SUT）是否能够正确处理HTTP请求，我们需要创建一个测试数据库，并配置测试Web主机使用测试数据库。类似于单元测试，我们也可以为集成测试使用一个单独的数据库。
- en: 'The `WebApplicationFactory<T>` type provides a way to configure the test web
    host. We can override the `ConfigureWebHost` method to configure the test web
    host. For example, we can replace the default database context with a test database
    context. Let us create a new text fixture class named `CustomIntegrationTestsFixture`
    and add the following code to the class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplicationFactory<T>` 类型提供了一种配置测试Web主机的方式。我们可以重写 `ConfigureWebHost` 方法来配置测试Web主机。例如，我们可以用测试数据库上下文替换默认的数据库上下文。让我们创建一个新的测试固定类
    `CustomIntegrationTestsFixture` 并向该类添加以下代码：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we override the `ConfigureWebHost()` method to configure
    the test web host for the SUT. When the test web host is created, the `Program`
    class will execute first, which means the default database context defined in
    the `Program` class will be created. Then the `ConfigureWebHost()` method defined
    in the `CustomIntegrationTestsFixture` class will be executed. So we need to find
    the default database context using `services.SingleOrDefault(d => d.ServiceType
    == typeof(DbContextOptions<InvoiceDbContext>))` and then remove it from the service
    collection. Then we add a new database context that uses the test database. This
    approach allows us to use a separate database for integration tests. We also need
    to create the test database and seed some test data when we initialize the test
    fixture.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们重写了 `ConfigureWebHost()` 方法来配置 SUT 的测试 Web 主机。当测试 Web 主机被创建时，`Program`
    类将首先执行，这意味着 `Program` 类中定义的默认数据库上下文将被创建。然后，`CustomIntegrationTestsFixture` 类中定义的
    `ConfigureWebHost()` 方法将被执行。因此，我们需要使用 `services.SingleOrDefault(d => d.ServiceType
    == typeof(DbContextOptions<InvoiceDbContext>))` 来找到默认的数据库上下文，并将其从服务集合中移除。然后，我们添加一个新的数据库上下文，它使用测试数据库。这种方法允许我们为集成测试使用单独的数据库。我们还需要在初始化测试固定实例时创建测试数据库并播种一些测试数据。
- en: 'You can also add more customizations to the test web host in the `ConfigureWebHost()`
    method. For example, you can configure the test web host to use a different configuration
    file, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `ConfigureWebHost()` 方法中添加更多对测试 Web 主机的自定义设置。例如，你可以配置测试 Web 主机使用不同的配置文件，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The default environment for the test web host of the SUT is `Development`.
    If you want to use a different environment, you can use the `UseEnvironment()`
    method, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SUT 的测试 Web 主机的默认环境是 `Development`。如果你想使用不同的环境，可以使用 `UseEnvironment()` 方法，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need a way to create the test database and seed some test data. Create
    a static class named `Utilities` and add the following code to the class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来创建测试数据库并播种一些测试数据。创建一个名为 `Utilities` 的静态类，并将以下代码添加到类中：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Utilities` class contains a few static methods that help us manage the
    test database. We need to initialize the test database before we run the tests
    and clean up the test database after we run the tests that change the data in
    the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Utilities` 类包含一些静态方法，帮助我们管理测试数据库。在运行测试之前，我们需要初始化测试数据库，在运行更改数据库中数据的测试之后，我们需要清理测试数据库。'
- en: 'When should we initialize the test database? We learned that the instance of
    the class fixture is created before the test class is initialized and is shared
    among all test methods in the test class. So, we can initialize the test database
    in the class fixture. Update the following code in the `ConfigureWebHost()` method
    of the `CustomIntegrationTestsFixture` class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在什么时候初始化测试数据库？我们了解到，类固定实例是在测试类初始化之前创建的，并且在整个测试类中的所有测试方法之间共享。因此，我们可以在类固定实例中初始化测试数据库。更新
    `CustomIntegrationTestsFixture` 类中的 `ConfigureWebHost()` 方法中的以下代码：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the test web host of SUT is created, we replace the default database context
    with a test database context, and also initialize the test database, so that all
    the test methods in the test class can use the same test database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SUT 的测试 Web 主机被创建时，我们用测试数据库上下文替换默认的数据库上下文，并初始化测试数据库，这样测试类中的所有测试方法都可以使用相同的测试数据库。
- en: 'Next, we can create a new test class named `InvoicesApiTests`, which is used
    to test the `/api/invoices` endpoint. Add the following code to the class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个新的测试类，命名为 `InvoicesApiTests`，用于测试 `/api/invoices` 端点。将以下代码添加到类中：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `InvoicesApiTests` test class will be initialized with an instance of the
    `CustomIntegrationTestsFixture` class. Then we can create some test methods to
    test the `/api/invoices` endpoint. A test method to test the `GET /api/invoices`
    endpoint might look as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoicesApiTests` 测试类将使用 `CustomIntegrationTestsFixture` 类的实例进行初始化。然后我们可以创建一些测试方法来测试
    `/api/invoices` 端点。一个测试 `GET /api/invoices` 端点的方法可能如下所示：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As this request to the `GET /api/invoices` endpoint does not change the database,
    the test method is straightforward.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对 `GET /api/invoices` 端点的请求没有更改数据库，测试方法很简单。
- en: 'Next, let''s see how to test the `POST /api/invoices` endpoint, which changes
    the database. A test method to test this endpoint might look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何测试更改数据库的 `POST /api/invoices` 端点。一个测试此端点的方法可能如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As this request to the `POST /api/invoices` endpoint changes the database, we
    need to clean up the database after we run the test. To get the current instance
    of the database context, we need to create a new scope and get the database context
    from the scope. Then we can use the `Cleanup` method of the `Utilities` class
    to clean up the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个请求到`POST /api/invoices`端点会更改数据库，我们在运行测试后需要清理数据库。要获取数据库上下文的当前实例，我们需要创建一个新的作用域并从作用域中获取数据库上下文。然后我们可以使用`Utilities`类的`Cleanup`方法来清理数据库。
- en: 'A test for the sad path of the `POST /api/invoices` endpoint might look as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对`POST /api/invoices`端点的悲伤路径的测试可能看起来如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can try to add more integration tests per your needs. Note that we need
    to manage the test database carefully. If you have multiple test classes that
    change the database, you may need to follow the same pattern (using a lock or
    collection fixture) as that in the unit tests we introduced in the *Creating a
    test fixture* section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371), to ensure
    the test database is clean before each test class runs and clean up the test database
    after each test class runs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需要添加更多集成测试。请注意，我们需要仔细管理测试数据库。如果你有多个更改数据库的测试类，你可能需要遵循我们在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中介绍的[*创建测试固定装置*]部分中使用的相同模式（使用锁或集合固定装置），以确保在每次测试类运行之前测试数据库是干净的，并在每次测试类运行后清理测试数据库。
- en: For example, if we have another `ContactsApiTests` class that also uses `CustomIntegrationTestsFixture`,
    xUnit will run `InvoicesApiTests` and `ContactsApiTests` in parallel. This may
    cause issues because both test classes try to initialize the test database at
    the same time. To avoid this issue, we can run these test classes in one collection
    to ensure that they run sequentially.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们还有一个使用`CustomIntegrationTestsFixture`的`ContactsApiTests`类，xUnit将并行运行`InvoicesApiTests`和`ContactsApiTests`。这可能会导致问题，因为这两个测试类会同时尝试初始化测试数据库。为了避免这个问题，我们可以将这些测试类放在一个集合中运行，以确保它们按顺序执行。
- en: 'We can demonstrate this by creating a test collection named `CustomIntegrationTests`
    and adding the `CollectionDefinition` attribute to the `CustomIntegrationTestsCollection`
    class. This attribute will enable us to define the collection and its associated
    tests, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个名为`CustomIntegrationTests`的测试集合，并将`CollectionDefinition`属性添加到`CustomIntegrationTestsCollection`类中来演示这一点。此属性将使我们能够定义集合及其关联的测试，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can add the `Collection` attribute to the `InvoicesApiTestsWithCollection`
    and `ContactsApiTestsWithCollection` classes. For example, the `InvoicesApiTestsWithCollection`
    class might look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`Collection`属性添加到`InvoicesApiTestsWithCollection`和`ContactsApiTestsWithCollection`类中。例如，`InvoicesApiTestsWithCollection`类可能看起来如下所示：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can find the complete source code in the sample repo. Note that the normal
    integration test class, `InvoicesApiTests`, does not have the `Collection` attribute,
    so xUnit will run it in parallel with the `CustomIntegrationTests` collection.
    To avoid conflicts, we can skip the test methods in the `InvoicesApiTests` class,
    as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在示例仓库中找到完整的源代码。请注意，正常的集成测试类`InvoicesApiTests`没有`Collection`属性，因此xUnit会将其与`CustomIntegrationTests`集合并行运行。为了避免冲突，我们可以跳过`InvoicesApiTests`类中的测试方法，如下所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you run the tests in the sample repo, please add or comment out the `Skip`
    attributes per your needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在示例仓库中运行测试时，请根据需要添加或注释掉`Skip`属性。
- en: Testing with mock services
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟服务进行测试
- en: As we explained in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371), unit tests
    should focus on isolated units of code. So, unit tests often use mock or stub
    services to isolate the code under test from other services. Integration tests,
    on the other hand, should test the integration between different components. So,
    technically, integration tests should use real services instead of mock services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中解释的，单元测试应该专注于独立的代码单元。因此，单元测试通常使用模拟或存根服务来隔离被测试的代码与其他服务。另一方面，集成测试应该测试不同组件之间的集成。因此，从技术上讲，集成测试应该使用真实服务而不是模拟服务。
- en: 'However, in some cases, using mock dependencies in integration tests can be
    helpful. For example, in the sample invoice application, we need to call a third-party
    service to send emails. If we use the real email service in the integration tests,
    it may have the following issues:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，在集成测试中使用模拟依赖项可能会有所帮助。例如，在示例发票应用程序中，我们需要调用第三方服务来发送电子邮件。如果我们使用真实的电子邮件服务进行集成测试，它可能存在以下问题：
- en: The actual email service may not be available in the test environment. For example,
    the email service may be hosted in a different environment, and the test environment
    may not be able to access the email service.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的电子邮件服务可能在测试环境中不可用。例如，电子邮件服务可能托管在不同的环境中，而测试环境可能无法访问电子邮件服务。
- en: The email service may have rate limits, strict network policies, or other restrictions
    that may cause issues in the integration tests or slow down the test execution.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件服务可能有速率限制、严格的网络策略或其他可能引起集成测试问题或减慢测试执行速度的限制。
- en: The email service may cause unnecessary costs in the test environment, especially
    if the service has usage-based pricing or requires a paid subscription. If we
    run the integration tests frequently, it may incur high costs.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件服务可能在测试环境中造成不必要的成本，尤其是如果该服务基于使用量定价或需要付费订阅。如果我们频繁运行集成测试，可能会产生高额费用。
- en: The test may impact production and cause issues for real users.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可能会影响生产环境，并为真实用户造成问题。
- en: In this case, using a mock email service in the integration can help us avoid
    these issues so that we can run the tests faster and more efficiently, avoid impacting
    production, and save costs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在集成测试中使用模拟电子邮件服务可以帮助我们避免这些问题，从而使我们能够更快、更有效地运行测试，避免影响生产，并节省成本。
- en: 'Let''s see how to use a mock email service in the integration tests. The service
    we use to send email is the `IEmailSender` interface. We can inject a mock service
    that implements the `IEmailSender` interface in the integration tests. Create
    a new test method in the test class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在集成测试中使用模拟电子邮件服务。我们用来发送电子邮件的服务是`IEmailSender`接口。我们可以在集成测试中注入一个实现`IEmailSender`接口的模拟服务。在测试类中创建一个新的测试方法：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we created a mock email sender service using the `Moq`
    library. The test web host of SUT provides a `WithWebHostBuilder()` method to
    configure the web host builder. In this method, we can configure the service collection
    of the web host using the `ConfigureTestServices()` method. Similar to the mock
    database context we introduced in the *Testing with a database context* section,
    we find the registered `IEmailSender` service and remove it from the service collection,
    then add the mock service to the service collection. Finally, we create the HTTP
    client and send the request to the API endpoint. If the mock service is used correctly,
    the test should pass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`Moq`库创建了一个模拟电子邮件发送服务。SUT的测试Web宿主提供了一个`WithWebHostBuilder()`方法来配置Web宿主构建器。在这个方法中，我们可以使用`ConfigureTestServices()`方法配置Web宿主的服务集合。类似于我们在[*使用数据库上下文进行测试*]部分中引入的模拟数据库上下文，我们找到已注册的`IEmailSender`服务并将其从服务集合中移除，然后添加模拟服务到服务集合中。最后，我们创建HTTP客户端并向API端点发送请求。如果正确使用了模拟服务，测试应该通过。
- en: In summary, whether to use mock services in integration tests or not should
    be decided on a case-by-case basis and depends on the specific requirements and
    objectives of the tests. Mocks can be useful in certain scenarios, but they should
    not be overused, otherwise, the integration tests may not be able to reflect the
    real-world scenarios.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，是否在集成测试中使用模拟服务应根据具体情况决定，并取决于测试的具体要求和目标。在某些场景下，模拟可能很有用，但不应过度使用，否则集成测试可能无法反映真实世界的场景。
- en: If your web API project runs in a microservice architecture, you may need to
    call other microservices in the integration tests. In this case, you can use the
    same approach to mock the HTTP client and the HTTP responses. The integration
    tests may be more complicated. We will stop here and explore more when we discuss
    the microservice architecture in the next chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Web API项目运行在微服务架构中，你可能需要在集成测试中调用其他微服务。在这种情况下，你可以使用相同的方法来模拟HTTP客户端和HTTP响应。集成测试可能会更复杂。我们在这里停止，并在下一章讨论微服务架构时再进一步探讨。
- en: Testing with authentication and authorization
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用身份验证和授权进行测试
- en: A common scenario in web APIs is that some API endpoints require authentication
    and authorization. We introduced how to implement authentication and authorization
    in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307). In this section, we will discuss
    how to test the API endpoints that require authentication and authorization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web API中，一个常见的场景是某些API端点需要身份验证和授权。我们在[*第8章*](B18971_08.xhtml#_idTextAnchor307)中介绍了如何实现身份验证和授权。在本节中，我们将讨论如何测试需要身份验证和授权的API端点。
- en: Preparing the sample application
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备示例应用程序
- en: To demonstrate testing with authentication and authorization, we will use the
    sample application we created in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307).
    You can find the source code in the `chapter10\AuthTestsDemo\start\` folder of
    the sample repo. This sample application uses claims-based authentication and
    authorization. You can recap the implementation details in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示带有身份验证和授权的测试，我们将使用我们在[*第8章*](B18971_08.xhtml#_idTextAnchor307)中创建的示例应用程序。您可以在示例仓库的
    `chapter10\AuthTestsDemo\start\` 文件夹中找到源代码。这个示例应用程序使用基于声明的身份验证和授权。您可以在[*第8章*](B18971_08.xhtml#_idTextAnchor307)中回顾实现细节。
- en: In `WeatherForecastController`, there are several methods that require authentication
    and authorization. (Forgive the naming – we just use the default template of ASP.NET
    Core web APIs.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WeatherForecastController` 中，有几个需要身份验证和授权的方法。（请原谅命名方式——我们只是使用了 ASP.NET Core
    Web API 的默认模板。）
- en: 'Create a new integration test project as described in the *Setting up the integration
    test project* section. You need to ensure that the integration test project has
    the following NuGet packages installed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按照在“设置集成测试项目”部分所述创建一个新的集成测试项目。您需要确保集成测试项目已安装以下 NuGet 包：
- en: '`Microsoft.AspNetCore.Mvc.Testing`: This is the test web host of SUT'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.Testing`：这是 SUT 的测试 Web 主机'
- en: '`xUnit`: This is the test framework'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xUnit`：这是一个测试框架'
- en: '`Moq`: This is the mocking library'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Moq`：这是一个模拟库'
- en: '`FluentAssertions`: This is the assertion library (optional)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FluentAssertions`：这是一个断言库（可选）'
- en: If you want to run the tests in VS 2022, you also need to install `xunit.runner.visualstudio`,
    the test runner for VS 2022.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 VS 2022 中运行测试，您还需要安装 `xunit.runner.visualstudio`，这是 VS 2022 的测试运行器。
- en: Also add the reference to the sample application project. For simplicity, we
    will only focus on the integration tests for authentication and authorization.
    So, this demo does not involve the database context and the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还需将示例应用程序项目添加为引用。为了简单起见，我们将只关注身份验证和授权的集成测试。因此，这个演示不涉及数据库上下文和数据库。
- en: 'Another thing you need to do is make the `Program` class public. Just add the
    following code at the end of the `Program` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将 `Program` 类设置为公共。只需在 `Program` 文件末尾添加以下代码：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we can start to write the integration tests for the API endpoints that
    require authentication and authorization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始编写需要身份验证和授权的 API 端点的集成测试。
- en: Creating a test fixture
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试夹具
- en: 'As we explained in the *Creating a test fixture* section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371),
    we can create a test fixture to share the common code among the tests. Create
    a new class named `IntegrationTestsFixture` and add the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中“创建测试夹具”部分所解释的，我们可以创建一个测试夹具来在测试之间共享通用代码。创建一个名为
    `IntegrationTestsFixture` 的新类，并添加以下代码：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a simple test fixture that inherits from the `WebApplicationFactory<Program>`
    class. Because we do not need to set up any services in this demo, there is no
    custom code in the `ConfigureWebHost` method. If you need to set up services,
    you can do it in this method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的测试夹具，继承自 `WebApplicationFactory<Program>` 类。由于我们在这个演示中不需要设置任何服务，因此在 `ConfigureWebHost`
    方法中没有自定义代码。如果您需要设置服务，可以在该方法中完成。
- en: Creating the test class
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试类
- en: 'Next, we can create the test class. Create a new class named `AuthTests` and
    add the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建测试类。创建一个名为 `AuthTests` 的新类，并添加以下代码：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is similar to the test class we created in the *Using the test fixture*
    section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371). It inherits from the
    `IClassFixture<IntegrationTestsFixture>` interface and has a constructor that
    accepts an `IntegrationTestsFixture` instance. So, the test class can use the
    `IntegrationTestsFixture` instance to access the test web host of SUT. So far,
    there is no special code in the test class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中“使用测试夹具”部分创建的测试类类似。它继承自 `IClassFixture<IntegrationTestsFixture>`
    接口，并有一个接受 `IntegrationTestsFixture` 实例的构造函数。因此，测试类可以使用 `IntegrationTestsFixture`
    实例来访问 SUT 的测试 Web 主机。到目前为止，测试类中还没有特殊的代码。
- en: Testing the anonymous API endpoints
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试匿名 API 端点
- en: 'Next, let us test the API endpoints that do not require authentication and
    authorization. In the `WeatherForecastController` class, copy the `Get()` method
    and paste it below the `Get()` method. Rename the new method `GetAnonymous()`
    and add the `AllowAnonymous` attribute. The new method should look like the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试不需要身份验证和授权的 API 端点。在 `WeatherForecastController` 类中，复制 `Get()` 方法并将其粘贴到
    `Get()` 方法下方。将新方法重命名为 `GetAnonymous()` 并添加 `AllowAnonymous` 属性。新方法应如下所示：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have a new API endpoint that does not require authentication and authorization.
    Create a new test method in the test class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个新的 API 端点，它不需要身份验证和授权。在测试类中创建一个新的测试方法：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are not many differences between this test method and the test method
    we created in the *Using the test fixture* section in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
    When we use the `CreateClient()` method, there is no special code to set up `HttpClient`.
    So, the test method can send the request to the API endpoint without any authentication
    and authorization. Because this endpoint allows anonymous access, the test should
    pass.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试方法与我们之前在 [*第 9 章*](B18971_09.xhtml#_idTextAnchor371) 的 *使用测试用例* 部分中创建的测试方法没有太大区别。当我们使用
    `CreateClient()` 方法时，没有特殊的代码来设置 `HttpClient`。因此，测试方法可以发送请求到 API 端点，而不需要任何身份验证和授权。因为这个端点允许匿名访问，所以测试应该通过。
- en: Testing the authorized API endpoints
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试授权的 API 端点
- en: 'The `WeatherForecastController` class has an `Authorize` attribute. So, the
    API endpoints that do not have the `AllowAnonymous` attribute require authentication
    and authorization. Let''s test the sad path for the `Get()` method. Create a new
    test method in the test class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherForecastController` 类有一个 `Authorize` 属性。因此，没有 `AllowAnonymous` 属性的
    API 端点需要身份验证和授权。让我们测试 `Get()` 方法的悲伤路径。在测试类中创建一个新的测试方法：'
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test method is similar to the previous `GetAnonymousWeatherForecast_ShouldReturnOk()`
    method, but we expect the status code to be `401 Unauthorized` because the API
    endpoint requires authentication and authorization. This test should pass as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试方法与之前的 `GetAnonymousWeatherForecast_ShouldReturnOk()` 方法类似，但我们期望状态码为 `401
    Unauthorized`，因为 API 端点需要身份验证和授权。这个测试也应该通过。
- en: 'Next, we need to set up the authentication and authorization in the test. There
    are several ways to do this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在测试中设置身份验证和授权。有几种方法可以做到这一点：
- en: In the test, call the authentication endpoint to get the access token. Then
    add the access token to the `Authorization` header of the HTTP request. However,
    this approach is not recommended because it needs additional effort to maintain
    the credentials, such as the username, password, client ID, client secret, and
    so on. Also, the tests may not be able to access the authentication endpoint in
    the test environment. If the tests depend on the authentication endpoint, it increases
    the complexity of the tests.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中，调用身份验证端点以获取访问令牌。然后将访问令牌添加到 HTTP 请求的 `Authorization` 头部。然而，这种方法不推荐，因为它需要额外的努力来维护凭证，如用户名、密码、客户端
    ID、客户端密钥等。此外，测试可能无法在测试环境中访问身份验证端点。如果测试依赖于身份验证端点，它会增加测试的复杂性。
- en: Create a helper method to generate the access token. Then add the access token
    to the `Authorization` header of the HTTP request. This approach does not need
    to call the authentication endpoint in the test. However, it means that we need
    to know how to generate the access token. If the authentication logic is provided
    by a third-party provider, we may not be able to make the same implementation
    in the test. So, it is only available if we have full control of the authentication
    logic.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个辅助方法来生成访问令牌。然后将访问令牌添加到 HTTP 请求的 `Authorization` 头部。这种方法不需要在测试中调用身份验证端点。然而，这意味着我们需要知道如何生成访问令牌。如果身份验证逻辑由第三方提供者提供，我们可能无法在测试中实现相同的实现。因此，只有在我们对身份验证逻辑有完全控制权的情况下，它才可用。
- en: Use `WebApplicationFactory` to set up the authentication and authorization and
    create a custom `AuthenticationHandler` to simulate the authentication and authorization
    process. This approach is more practical because it does not need to call the
    authentication endpoint in the test. Also, it does not need to duplicate the authentication
    logic in the test project.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WebApplicationFactory` 来设置身份验证和授权，并创建一个自定义的 `AuthenticationHandler` 来模拟身份验证和授权过程。这种方法更实用，因为它不需要在测试中调用身份验证端点。此外，它不需要在测试项目中重复身份验证逻辑。
- en: As we have the source code of the sample application, which includes the authentication
    logic, we can demonstrate how to use the second approach, and then we will show
    you how to use the third approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有包含认证逻辑的示例应用程序的源代码，我们可以演示如何使用第二种方法，然后我们将向您展示如何使用第三种方法。
- en: Generating the access token in the test
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在测试中生成访问令牌
- en: 'The code we use to generate the access token is from the `AccountController`
    class, which is the authentication endpoint. We can find a `GenerateToken` method
    in the `AccountController` class. This method is invoked when the user successfully
    logs in. Create a new method in the `IntegrationTestsFixture` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来生成访问令牌的代码来自`AccountController`类，这是认证端点。我们可以在`AccountController`类中找到一个名为`GenerateToken`的方法。当用户成功登录时，会调用此方法。在`IntegrationTestsFixture`类中创建一个新的方法：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding method, we use the `IConfiguration` service to get the secret,
    issuer, and audience from the configuration. Then we copy the code from the `GenerateToken()`
    method in the `AccountController` class to generate the access token. Note that
    the configuration comes from the `appsettings.json` file in the main web API project.
    As we did not change the configuration of the test web host, the configuration
    is the same as that in the main web API project. But if you need to use a different
    configuration for the tests, please add proper code to the `ConfigureWebHost`
    method in the `IntegrationTestsFixture` class to apply any changes, as we introduced
    in the *Creating a test* *fixture* section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用`IConfiguration`服务从配置中获取密钥、发行者和受众。然后，我们将`AccountController`类中的`GenerateToken()`方法的代码复制过来以生成访问令牌。请注意，配置来自主Web
    API项目中的`appsettings.json`文件。由于我们没有更改测试Web宿主的配置，因此配置与主Web API项目中的配置相同。但如果你需要为测试使用不同的配置，请在`IntegrationTestsFixture`类中的`ConfigureWebHost`方法中添加适当的代码以应用任何更改，正如我们在*创建测试*
    *fixture*部分中介绍的那样。
- en: 'Next, we can use the `GenerateToken` method in the `AuthTest` class. Create
    a new test method in the test class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`AuthTest`类中的`GenerateToken`方法。在测试类中创建一个新的测试方法：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this test method, we call the `GenerateToken()` method to generate an access
    token, and then add the access token to the `Authorization` header of the HTTP
    request. Because the logic we use to generate the token is the same as the authentication
    endpoint, the test should pass.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们调用`GenerateToken()`方法生成访问令牌，然后将访问令牌添加到HTTP请求的`Authorization`头中。因为生成令牌的逻辑与认证端点相同，所以测试应该通过。
- en: Using a custom authentication handler
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义认证处理器
- en: Another way to test the authorized API endpoints is to use a custom authentication
    handler. A custom authentication handler can simulate the authentication and authorization
    process. So, we can use it to test the authorized API endpoints without calling
    the authentication endpoint. This is the recommended approach to test the authorized
    API endpoints because it does not need any other dependencies, nor does it need
    to duplicate the authentication logic in the test project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试授权的API端点另一种方法是使用自定义认证处理器。自定义认证处理器可以模拟认证和授权过程。因此，我们可以用它来测试授权的API端点而不调用认证端点。这是测试授权API端点的推荐方法，因为它不需要任何其他依赖项，也不需要在测试项目中重复认证逻辑。
- en: In the actual authentication process, we need to generate a JWT token that includes
    the claims of the authenticated user and add it to the `Authorization` header
    of the HTTP request. If we use a custom authentication handler, we can skip the
    process of generating the JWT token, but we still need to find a way to define
    the claims that we need and pass them to the custom authentication handler. We
    can simply add the claims in the request headers and then read the values in the
    custom authentication handler to create the `ClaimsPrincipal` object. Let us demonstrate
    how to do this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的认证过程中，我们需要生成一个包含已认证用户声明的JWT令牌，并将其添加到HTTP请求的`Authorization`头中。如果我们使用自定义认证处理器，我们可以跳过生成JWT令牌的过程，但我们需要找到一种方法来定义所需的声明并将它们传递给自定义认证处理器。我们可以在请求头中简单地添加声明，然后在自定义认证处理器中读取这些值以创建`ClaimsPrincipal`对象。让我们演示如何做到这一点。
- en: 'To use a custom authentication handler, first create a new class named `TestAuthHandler`,
    which inherits from the `AuthenticationHandler` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义认证处理器，首先创建一个名为`TestAuthHandler`的新类，它继承自`AuthenticationHandler`类：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we define the authentication scheme name as `TestScheme`,
    which is an alternative name to the actual scheme name, `Bearer`. You can find
    the definition in the `Program` class. Also, we define a few names for HTTP headers,
    which we will use to pass the claims to the custom authentication handler. The
    `HandleAuthenticateAsync()` method is the method that we need to override to implement
    the authentication logic. We will implement it in the following code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了身份验证方案名称为`TestScheme`，这是实际方案名称`Bearer`的一个替代名称。您可以在`Program`类中找到其定义。我们还定义了一些HTTP头名称，我们将使用它们将声明传递给自定义身份验证处理程序。`HandleAuthenticateAsync()`是我们需要重写以实现身份验证逻辑的方法。我们将在以下代码中实现它。
- en: 'The idea is that when we create the request in the test, we simply add the
    claims to the request headers. So that the custom authentication handler can read
    the values from the request headers, update the `HandleAuthenticateAsync()` method
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是在测试中创建请求时，我们只需简单地将声明添加到请求头中。这样，自定义身份验证处理程序就可以从请求头中读取值，并将`HandleAuthenticateAsync()`方法更新如下：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Instead of getting claims from the JWT token, we get the claims from the request
    headers. If the values exist, we add them to the `ClaimsIdentity` object. Then
    we create the `ClaimsPrincipal` object and the `AuthenticationTicket` object.
    Finally, we return the `AuthenticateResult` object with the `Success` status.
    This method simulates the authentication process, which avoids the need to generate
    the JWT token, but it still creates the `ClaimsPrincipal` object that we need
    to test the authorized API endpoints.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是从JWT令牌中获取声明，而是从请求头中获取声明。如果值存在，我们将它们添加到`ClaimsIdentity`对象中。然后我们创建`ClaimsPrincipal`对象和`AuthenticationTicket`对象。最后，我们返回带有`Success`状态的`AuthenticateResult`对象。此方法模拟了身份验证过程，避免了生成JWT令牌的需要，但它仍然创建了我们需要测试授权API端点的`ClaimsPrincipal`对象。
- en: 'Next, we can test the authorized API endpoints by using the custom authentication
    handler. In the `WeatherForecastController` class, we can find a `GetDrivingLicense`
    method, which is an authorized API endpoint that needs the `DrivingLicenseNumber`
    claim. We can create a new test method in the `AuthTest` class as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过使用自定义身份验证处理程序来测试授权的API端点。在`WeatherForecastController`类中，我们可以找到一个`GetDrivingLicense`方法，这是一个需要`DrivingLicenseNumber`声明的授权API端点。我们可以在`AuthTest`类中创建一个新的测试方法，如下所示：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this test method, we specify the test web host of SUT with the `WithWebHostBuilder`
    method and then call the `AddAuthentication` method to specify the authentication
    scheme. Then we call the `AddScheme` method to apply the `TestAuthHandler` authentication
    handler to the authentication service. With this customized test web host, we
    can create a new HTTP client. Before we send the request using this HTTP client,
    we need to add the `Authorization` header that specifies the authentication scheme.
    We also add the claims to the request headers for simplicity, so that the custom
    authentication handler can read the values from the request headers and create
    the `ClaimsPrincipal` object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们使用`WithWebHostBuilder`方法指定SUT的测试Web宿主，然后调用`AddAuthentication`方法指定身份验证方案。然后我们调用`AddScheme`方法将`TestAuthHandler`身份验证处理程序应用到身份验证服务上。有了这个定制的测试Web宿主，我们可以创建一个新的HTTP客户端。在我们使用这个HTTP客户端发送请求之前，我们需要添加指定身份验证方案的`Authorization`头。我们还为了简便起见将声明添加到请求头中，这样自定义身份验证处理程序就可以从请求头中读取值并创建`ClaimsPrincipal`对象。
- en: Then we can call the `GetAsync` method to send the HTTP request to the API endpoint.
    Finally, we can verify the response status code and the response content type
    to ensure the request was successful.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`GetAsync`方法向API端点发送HTTP请求。最后，我们可以验证响应状态码和响应内容类型，以确保请求成功。
- en: 'The preceding test method is for a happy path. To test the unauthorized scenario,
    we can create a new test method that does not add the `DrivingLicenseNumberHeader`
    header to the request, and verify that the response status code is `401 Unauthorized`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试方法是针对正常路径的。为了测试未授权场景，我们可以创建一个新的测试方法，该方法不向请求添加`DrivingLicenseNumberHeader`头，并验证响应状态码为`401
    Unauthorized`：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding test method, we do not add the `DrivingLicenseNumberHeader`
    header to the request. So, the custom authentication handler cannot find the `DrivingLicenseNumber`
    claim, and it will return the `Forbidden` status code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试方法中，我们没有向请求添加`DrivingLicenseNumberHeader`头。因此，自定义身份验证处理程序找不到`DrivingLicenseNumber`声明，并将返回`Forbidden`状态码。
- en: 'Now, we found that there is some duplicated code in the preceding test methods.
    If we need to set up the test web host and create the HTTP client for each test
    method, we can move the code to the `IntegrationTestsFixture` class. Create a
    method called `CreateClientWithAuth` in the `IntegrationTestsFixture` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们发现前述测试方法中存在一些重复的代码。如果我们需要为每个测试方法设置测试Web主机并创建HTTP客户端，我们可以将这些代码移动到`IntegrationTestsFixture`类中。在`IntegrationTestsFixture`类中创建一个名为`CreateClientWithAuth`的方法：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `CreateClientWithAuth()` method accepts the claims as parameters and then
    creates the `HttpClient` with the customized test web host. In this way, we can
    easily control the claims for each test method. Then we can update the test methods
    to use this method. For example, the test methods for the `GetCountry` endpoint
    can be updated as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateClientWithAuth()`方法接受声明作为参数，然后使用定制的测试Web主机创建`HttpClient`。这样，我们可以轻松控制每个测试方法的声明。然后我们可以更新测试方法以使用此方法。例如，`GetCountry`端点的测试方法可以更新如下：'
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we can verify that the test methods are still working as expected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以验证测试方法是否仍然按预期工作。
- en: '![Figure 10.1 – The test methods pass as expected in VS 2022](img/B18971_10_1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 在VS 2022中测试方法按预期通过](img/B18971_10_1.jpg)'
- en: Figure 10.1 – The test methods pass as expected in VS 2022
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 在VS 2022中测试方法按预期通过
- en: 'Note that you can also customize the `AuthenticationSchemeOptions` class if
    you need to. For example, you can define a `TestAuthHandlerOptions` class that
    inherits from the `AuthenticationSchemeOptions` class, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你需要，你也可以自定义`AuthenticationSchemeOptions`类。例如，你可以定义一个继承自`AuthenticationSchemeOptions`类的`TestAuthHandlerOptions`类，如下所示：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can then configure `TestAuthHandlerOptions` in the `ConfigureTestServices`
    method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`ConfigureTestServices`方法中配置`TestAuthHandlerOptions`：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `TestAuthHandler` class should now be updated as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestAuthHandler`类现在应该更新如下：'
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `TestAuthHandler` class can now get the username from the `TestAuthHandlerOptions`
    class. You can also define other properties in the `TestAuthHandlerOptions` class,
    and then use them in the `TestAuthHandler` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestAuthHandler`类现在可以从`TestAuthHandlerOptions`类中获取用户名。你还可以在`TestAuthHandlerOptions`类中定义其他属性，然后在使用`TestAuthHandler`类时使用它们。'
- en: 'If your project does not use claim-based authorization, you can also define
    a custom authorization handler to implement the authorization logic. Please check
    the official document for more information: [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目不使用基于声明的授权，你也可以定义一个自定义授权处理程序来实现授权逻辑。请查阅官方文档以获取更多信息：[https://learn.microsoft.com/en-us/aspnet/core/security/authentication/](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/)。
- en: Code coverage
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Now we have covered the unit tests and integration tests in ASP.NET Core. In
    this section, we will discuss **code coverage**, which is a metric that measures
    the extent to which the source code of the application is covered by the test
    suite during testing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了ASP.NET Core中的单元测试和集成测试。在本节中，我们将讨论**代码覆盖率**，这是一个衡量在测试过程中测试套件覆盖应用程序源代码程度的指标。
- en: Code coverage is a very important metric for software quality. If the code coverage
    is low, it means that there are many parts of the code that are not covered by
    the tests. In this case, we are not confident that the code is working as expected.
    Also, when we make changes or refactor the code, we are not sure whether the changes
    will break the existing code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是衡量软件质量的重要指标。如果代码覆盖率低，这意味着代码中有许多部分没有被测试覆盖。在这种情况下，我们无法确信代码按预期工作。此外，当我们对代码进行更改或重构时，我们不确定这些更改是否会破坏现有代码。
- en: Code coverage provides insights into which parts of the code are covered (or
    not covered) by the tests. It can help us identify areas that may require additional
    testing and ensure that the code is tested thoroughly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率可以提供关于哪些代码部分被测试（或未被测试）的见解。它可以帮助我们识别可能需要额外测试的区域，并确保代码得到彻底测试。
- en: Code coverage plays a vital role in assessing the effectiveness and reliability
    of the testing process. By analyzing code coverage, we can gain confidence in
    the quality of the code and identify potential areas of weakness or untested code.
    Adequate code coverage is essential to improve the quality of the code and reduce
    the risks of bugs and defects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率在评估测试过程的有效性和可靠性方面起着至关重要的作用。通过分析代码覆盖率，我们可以对代码的质量有信心，并识别潜在的薄弱环节或未测试的代码。足够的代码覆盖率对于提高代码质量和降低错误和缺陷的风险至关重要。
- en: It is important to note that code coverage is not the sole indicator of code
    quality. While high code coverage is desirable, achieving 100% code coverage does
    not guarantee that the code is bug-free. Code coverage should be accompanied by
    other factors such as effective test design, code reviews, static analysis, manual
    testing, and so on. Additionally, factors such as code design, architecture, and
    development practices also play a role in the quality of the code. We need to
    find a balance between code coverage and other factors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，代码覆盖率不是代码质量的唯一指标。虽然高代码覆盖率是可取的，但达到100%的代码覆盖率并不能保证代码没有错误。代码覆盖率应与其他因素相结合，如有效的测试设计、代码审查、静态分析、手动测试等。此外，代码设计、架构和开发实践等因素也会影响代码质量。我们需要在代码覆盖率和其他因素之间找到平衡。
- en: 'To analyze the code coverage, we have two steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 分析代码覆盖率，我们有两个步骤：
- en: '**Collecting test data**: The data collector can monitor the test execution
    and collect the code coverage data during test runs. It can report code coverage
    data in different formats, such as XML or JSON.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集测试数据**：数据收集器可以在测试运行期间监控测试执行并收集代码覆盖率数据。它可以以不同的格式报告代码覆盖率数据，如XML或JSON。'
- en: '**Generating the report**: The report generator can read the collected data
    and generate the code coverage report, often in HTML format.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成报告**：报告生成器可以读取收集的数据并生成代码覆盖率报告，通常以HTML格式。'
- en: Let us see how to use the data collector and report generator. We will use the
    `InvoiceApp` project as an example. You can find the sample project in the `chapter10\IntegrationTestsDemo\IntegrationTest-v1`
    folder.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用数据收集器和报告生成器。我们将使用`InvoiceApp`项目作为示例。您可以在`chapter10\IntegrationTestsDemo\IntegrationTest-v1`文件夹中找到示例项目。
- en: Using data collectors
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据收集器
- en: 'To use data collectors, we can use **Coverlet**. Coverlet is a cross-platform
    code coverage framework for .NET, with support for line, branch, and method coverage.
    It can be used either as a .NET Core global tool or a NuGet package. For more
    information, please check the Coverlet repo on GitHub: [https://github.com/coverlet-coverage/coverlet](https://github.com/coverlet-coverage/coverlet).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用数据收集器，我们可以使用**Coverlet**。Coverlet是一个跨平台的.NET代码覆盖率框架，支持行、分支和方法覆盖率。它可以作为.NET
    Core全局工具或NuGet包使用。更多信息，请查看GitHub上的Coverlet仓库：[https://github.com/coverlet-coverage/coverlet](https://github.com/coverlet-coverage/coverlet)。
- en: 'The xUnit project template already includes the Coverlet package. If your test
    project does not include the Coverlet package, you can install it by running the
    following command in the Package Manager Console:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit项目模板已经包含了Coverlet包。如果您的测试项目没有包含Coverlet包，您可以通过在包管理控制台运行以下命令来安装它：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To get coverage data, navigate to the test project folder, and run the following
    command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取覆盖率数据，导航到测试项目文件夹，并运行以下命令：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `--collect:"XPlat Code Coverage"` option tells the `dotnet test` command
    to collect the code coverage data. The `XPlat Code Coverage` parameter is a friendly
    name for the collector. You can use any name you like but note that it is case
    insensitive. The code coverage data will be saved in the `TestResults` folder.
    You can find the code coverage data in the `coverage.cobertura.xml` file. The
    folder structure is `/TestResults/{GUID}/coverage.cobertura.xml`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`--collect:"XPlat Code Coverage"`选项告诉`dotnet test`命令收集代码覆盖率数据。"XPlat Code Coverage"参数是收集器的友好名称。您可以使用任何喜欢的名称，但请注意，它不区分大小写。代码覆盖率数据将保存在`TestResults`文件夹中。您可以在`coverage.cobertura.xml`文件中找到代码覆盖率数据。文件夹结构是`/TestResults/{GUID}/coverage.cobertura.xml`。'
- en: 'Here is a sample of the `coverage.cobertura.xml` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`coverage.cobertura.xml`文件的示例：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code, we can see the following information:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以看到以下信息：
- en: '`line-rate`: This is the percentage of lines covered by tests'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line-rate`：这是被测试覆盖的行数的百分比'
- en: '`branch-rate`: This is the percentage of branches covered by tests'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branch-rate`：这是被测试覆盖的分支的百分比'
- en: '`lines-covered`: This is the number of lines covered by tests'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lines-covered`：这是被测试覆盖的行数'
- en: '`lines-valid`: This is the number of lines in the source code'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lines-valid`：这是源代码中的行数'
- en: '`branches-covered`: This is the number of branches covered by tests'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branches-covered`：这是被测试覆盖的分支数'
- en: '`branches-valid`: This is the number of branches in the source code'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branches-valid`：这是源代码中的分支数'
- en: 'You can also use Coverlet as a .NET global tool. To do this, you can run the
    following command to install Coverlet as a .NET global tool:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将Coverlet用作.NET全局工具。为此，你可以运行以下命令来安装Coverlet作为.NET全局工具：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then you can use it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以这样使用它：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Please update the paths in the preceding command to match your project structure.
    The `--no-build` option is used to skip building the test project, which is useful
    if you have already built the test project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请更新前面命令中的路径以匹配你的项目结构。`--no-build`选项用于跳过构建测试项目，这在已经构建了测试项目时很有用。
- en: Now we have the code coverage data. However, the `coverage.cobertura.xml` file
    is not human-readable. So, we must generate a human-readable report, which we
    will introduce in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了代码覆盖率数据。然而，`coverage.cobertura.xml`文件不是人类可读的。因此，我们必须生成一个人类可读的报告，我们将在下一节介绍。
- en: Generating a code coverage report
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成代码覆盖率报告
- en: To better understand the coverage data, we can generate a code coverage report.
    To do this, we can use the `ReportGenerator` NuGet package. **ReportGenerator**
    is a tool that can convert coverage data generated by Coverlet into human-readable
    reports. It also supports other coverage formats, such as **OpenCover**, **dotCover**,
    **NCover**, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解覆盖率数据，我们可以生成一个代码覆盖率报告。为此，我们可以使用`ReportGenerator` NuGet包。**ReportGenerator**是一个可以将Coverlet生成的覆盖率数据转换为人类可读报告的工具。它还支持其他覆盖率格式，如**OpenCover**、**dotCover**、**NCover**等。
- en: 'To install ReportGenerator, we can run the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装ReportGenerator，我们可以运行以下命令：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we can run the following command to generate a code coverage report:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行以下命令来生成代码覆盖率报告：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please update the paths in the preceding command to match your project structure.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请更新前面命令中的路径以匹配你的项目结构。
- en: 'If the command runs successfully, you will see the generated HTML report in
    the `coveragereport` folder. You can open the `index.html` file in the browser
    to view the report. The report looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令运行成功，你将在`coveragereport`文件夹中看到生成的HTML报告。你可以在浏览器中打开`index.html`文件来查看报告。报告看起来像这样：
- en: '![Figure 10.2 – Code coverage report](img/B18971_10_2.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 代码覆盖率报告](img/B18971_10_2.jpg)'
- en: Figure 10.2 – Overview of the code coverage report
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 代码覆盖率报告概述
- en: 'You can check each class to see the code coverage details, as shown in *Figure
    10**.3*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查每个类以查看代码覆盖率详情，如图*10.3*所示：
- en: '![Figure 10.3 – Code coverage details](img/B18971_10_3.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 代码覆盖率详情](img/B18971_10_3.jpg)'
- en: Figure 10.3 – Overview of the code coverage details
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 代码覆盖率详情概述
- en: 'In *Figure 10**.4*, we can see that some lines are not covered by tests:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.4*中，我们可以看到一些行没有被测试覆盖：
- en: '![Figure 10.4 – Lines not covered by tests highlighted in red](img/B18971_10_4.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 用红色突出显示的未通过测试的行](img/B18971_10_4.jpg)'
- en: Figure 10.4 – Overview of the lines not covered by tests highlighted in red
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 用红色突出显示的未通过测试的行概述
- en: Sadly, the code coverage in our sample project is awful. But luckily, it is
    just a sample project. In real-world projects, we should try our best to improve
    the code coverage!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我们样本项目的代码覆盖率很糟糕。但幸运的是，它只是一个样本项目。在实际项目中，我们应该尽力提高代码覆盖率！
- en: In this section, we have learned how to use Coverlet and ReportGenerator to
    generate code coverage data and reports. Code coverage is an essential aspect
    of effective software testing. By leveraging these reports, developers and quality
    assurance teams can gain insights into the quality of their tests and the quality
    of their code, which can ultimately enhance the reliability and stability of the
    application and also help us confidently refactor code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用Coverlet和ReportGenerator生成代码覆盖率数据和报告。代码覆盖率是有效软件测试的一个重要方面。通过利用这些报告，开发人员和质量保证团队能够深入了解他们的测试质量和代码质量，这最终可以增强应用程序的可靠性和稳定性，并帮助我们自信地重构代码。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to write integration tests for ASP.NET Core
    web API applications. We learned how to create a test fixture to set up the test
    web host, and how to use the test fixture in the test class. We also learned how
    to test authorized endpoints and generate code coverage data and reports.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何为ASP.NET Core网络API应用程序编写集成测试。我们学习了如何创建测试固定装置来设置测试网络主机，以及如何在测试类中使用测试固定装置。我们还学习了如何测试授权端点并生成代码覆盖率数据和报告。
- en: As a good developer, it is important to write tests for your code. Writing tests
    is not only a beneficial practice but also a beneficial habit to form. You may
    find that you spend more time writing tests than writing features, but the effort
    is worth it. To ensure your ASP.NET web API applications are functioning correctly,
    make sure to write both unit tests and integration tests. Doing so will help to
    ensure your code is reliable and secure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名优秀的开发者，为你的代码编写测试非常重要。编写测试不仅是一种有益的实践，而且是一种有益的习惯。你可能发现你在编写测试上花费的时间比编写功能还要多，但这份努力是值得的。为了确保你的ASP.NET网络API应用程序能够正确运行，请确保编写单元测试和集成测试。这样做将有助于确保你的代码是可靠和安全的。
- en: 'In the next chapter, we will explore another aspect of web APIs: gRPC, which
    is a high-performance, open-source, universal RPC framework.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨网络API的另一个方面：gRPC，这是一个高性能、开源的通用RPC框架。
