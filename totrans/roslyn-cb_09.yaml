- en: Design and Implement a New C# Language Feature
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和实现一个新的C#语言特性
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Designing syntax and grammar for a new C# language feature
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个新C#语言特性的语法和语法规则
- en: Implementing parser support for a new C# language feature
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对新C#语言特性的解析器支持
- en: Implementing binding/semantic analysis support for a new C# language feature
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对新C#语言特性的绑定/语义分析支持
- en: Implementing lowering/code generation support for a new C# language feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对新C#语言特性的降低/代码生成支持
- en: Writing unit tests for C# parsing, binding, and codegen phases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写C#解析、绑定和代码生成阶段的单元测试
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This chapter enables developers to design a new C# language feature and implement
    various compiler phases for this language feature. On a high level, the C# compiler
    has following important phases:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使开发者能够设计一个新的C#语言特性，并实现该语言特性的各种编译器阶段。从高层次来看，C#编译器有以下重要阶段：
- en: '![](img/f8321116-8694-43b3-9228-c3657aada528.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8321116-8694-43b3-9228-c3657aada528.png)'
- en: '**Lexical Analysis** ([https://en.wikipedia.org/wiki/Lexical_analysis](https://en.wikipedia.org/wiki/Lexical_analysis)):
    This transforms the sequence of characters in a source file to into tokens such
    as keywords, identifiers, operators, and so on. `Lexer.Lex` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/Lexer.cs,5ad0cc36317d33e7](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/Lexer.cs,5ad0cc36317d33e7))
    is the primary entry point into the C# lexer that fetches the next token and increments
    the current position within the source text. For example, consider the following
    source code:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**词法分析** ([https://en.wikipedia.org/wiki/Lexical_analysis](https://en.wikipedia.org/wiki/Lexical_analysis)):
    这将源文件中的字符序列转换成诸如关键字、标识符、运算符等标记。`Lexer.Lex` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/Lexer.cs,5ad0cc36317d33e7](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/Lexer.cs,5ad0cc36317d33e7))
    是进入C#词法分析器的主要入口点，它获取下一个标记并增加源文本中的当前位置。例如，考虑以下源代码：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gets transformed into the following sequence of tokens during lexical
    analysis (white space and newline trivia excluded for brevity):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在词法分析过程中，这被转换成以下标记序列（为了简洁，省略了空白和换行杂项）：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Syntax Analysis** ([https://en.wikipedia.org/wiki/Parsing](https://en.wikipedia.org/wiki/Parsing)):
    This transforms the sequence of tokens generated from the lexical analysis phase
    into a syntax tree with nodes, tokens, and trivia. It also verifies that the syntax
    conforms to the C# language specification and generates syntax diagnostics. `SyntaxFactory.ParseCompilationUnit`
    ([http://source.roslyn.io/#q=SyntaxFactory.ParseCompilationUnit](http://source.roslyn.io/#q=SyntaxFactory.ParseCompilationUnit))
    is the primary entry point into the C# language parser that generates a `CompilationUnitSyntax`
    node, which is then used to create a `SyntaxTree` rooted at this node (see `CSharpSyntaxTree.Create`
    ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,d40da3b7b4e39486](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,d40da3b7b4e39486))).
    For the preceding example source code and lexical tokens, we get the following
    syntax tree:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法分析** ([https://en.wikipedia.org/wiki/Parsing](https://en.wikipedia.org/wiki/Parsing)):
    这将词法分析阶段生成的标记序列转换成一个具有节点、标记和杂项的语法树。它还验证语法是否符合C#语言规范，并生成语法诊断。`SyntaxFactory.ParseCompilationUnit`
    ([http://source.roslyn.io/#q=SyntaxFactory.ParseCompilationUnit](http://source.roslyn.io/#q=SyntaxFactory.ParseCompilationUnit))
    是进入C#语言解析器的主要入口点，该解析器生成一个 `CompilationUnitSyntax` 节点，然后使用该节点创建一个以该节点为根的 `SyntaxTree`（参见
    `CSharpSyntaxTree.Create` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,d40da3b7b4e39486](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,d40da3b7b4e39486))))。对于前面的示例源代码和词法标记，我们得到以下语法树：'
- en: '![](img/8011f62c-a48f-4348-b206-feff2e00f4a5.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8011f62c-a48f-4348-b206-feff2e00f4a5.png)'
- en: '**Semantic Analysis or Binding** ([https://en.wikipedia.org/wiki/Semantic_analysis_(compilers)](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers))):
    Transforms the syntax tree generated from the parsing phase into a bound tree
    with `BoundNodes`. A bound tree is essentially an abstract syntax tree with rich
    semantic information associated with each node in the tree. All the semantic information
    provided by the `SemanticModel` APIs at the CodeAnalysis layer is from the bound
    nodes associated with the syntax. This phase analyzes the semantics of source
    code, such as type checking, method overload resolution, conversions, and so on,
    and generates semantic diagnostics. The primary entry points for binding statements
    and expressions are `Binder.BindStatement` ([http://source.roslyn.io/#q=Binder.BindStatement](http://source.roslyn.io/#q=Binder.BindStatement))
    and `Binder.BindExpression` ([http://source.roslyn.io/#q=Binder.BindExpression](http://source.roslyn.io/#q=Binder.BindExpression)),
    respectively. For the preceding example, the following bound tree is generated
    for the method body for `Method`:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语义分析或绑定** ([https://en.wikipedia.org/wiki/Semantic_analysis_(compilers)](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers))):
    将解析阶段生成的语法树转换为带有 `BoundNodes` 的绑定树。绑定树本质上是一个具有与树中每个节点相关联的丰富语义信息的抽象语法树。在 CodeAnalysis
    层提供的所有语义信息都来自与语法相关的绑定节点。此阶段分析源代码的语义，例如类型检查、方法重载解析、转换等，并生成语义诊断。绑定语句和表达式的入口点分别是
    `Binder.BindStatement` ([http://source.roslyn.io/#q=Binder.BindStatement](http://source.roslyn.io/#q=Binder.BindStatement))
    和 `Binder.BindExpression` ([http://source.roslyn.io/#q=Binder.BindExpression](http://source.roslyn.io/#q=Binder.BindExpression))。对于前面的示例，为
    `Method` 的方法体生成了以下绑定树：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Lowering**: This transforms the bound tree generated from the binding phase
    into a simplified bound tree. For example, a bound *for* loop node gets rewritten
    into a bound block with labels and conditional jumps (see `LocalRewriter.RewriteForStatement`
    ([http://source.roslyn.io/#q=RewriteForStatement](http://source.roslyn.io/#q=RewriteForStatement))).
    `LocalRewriter.Rewrite` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Lowering/LocalRewriter/LocalRewriter.cs,c30511823bc3c19f](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Lowering/LocalRewriter/LocalRewriter.cs,c30511823bc3c19f))
    is the primary entry point to lower each method block in the compilation.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低复杂度**: 这将绑定阶段生成的绑定树转换为简化后的绑定树。例如，一个绑定 *for* 循环节点会被重写为一个带有标签和条件跳转的绑定块（参见
    `LocalRewriter.RewriteForStatement` ([http://source.roslyn.io/#q=RewriteForStatement](http://source.roslyn.io/#q=RewriteForStatement))).
    `LocalRewriter.Rewrite` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Lowering/LocalRewriter/LocalRewriter.cs,c30511823bc3c19f](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Lowering/LocalRewriter/LocalRewriter.cs,c30511823bc3c19f))
    是编译中每个方法块降低的主要入口点。'
- en: '**Flow analysis** ([https://en.wikipedia.org/wiki/Data-flow_analysis](https://en.wikipedia.org/wiki/Data-flow_analysis)):
    This phase performs basic data flow and control flow analysis of the lowered bound
    tree to generate unreachable code and uninitialized variable diagnostics. `FlowAnalysisPass.Rewrite`
    ([http://source.roslyn.io/#q=FlowAnalysisPass.Rewrite](http://source.roslyn.io/#q=FlowAnalysisPass.Rewrite))
    is the primary entry point into the flow analysis phase.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流分析** ([https://en.wikipedia.org/wiki/Data-flow_analysis](https://en.wikipedia.org/wiki/Data-flow_analysis)):
    此阶段对降低后的绑定树进行基本的数据流和控制流分析，以生成不可达代码和未初始化变量诊断。`FlowAnalysisPass.Rewrite` ([http://source.roslyn.io/#q=FlowAnalysisPass.Rewrite](http://source.roslyn.io/#q=FlowAnalysisPass.Rewrite))
    是流分析阶段的主要入口点。'
- en: '**Code generation** ([https://en.wikipedia.org/wiki/Code_generation_(compiler)](https://en.wikipedia.org/wiki/Code_generation_(compiler))):
    This transforms lowered bound tree into MSIL represented with a sequence of bytes
    that gets emitted into a .NET assembly. `CodeGenerator.Generate` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,c28190700f8e314c](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,c28190700f8e314c))
    is the primary entry point into the code generator. For the preceding code example,
    the C# compiler generates the following MSIL for `Method`:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成** ([https://en.wikipedia.org/wiki/Code_generation_(compiler)](https://en.wikipedia.org/wiki/Code_generation_(compiler))):
    这将降低后的绑定树转换为以字节序列表示的 MSIL，并将其输出到 .NET 程序集。`CodeGenerator.Generate` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,c28190700f8e314c](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,c28190700f8e314c))
    是代码生成的主要入口点。对于前面的代码示例，C# 编译器为 `Method` 生成了以下 MSIL：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can read a more detailed overview of Roslyn at [https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview](https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview](https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview)上阅读关于Roslyn的更详细概述。
- en: 'New language feature: Switch Operator (?::)'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新语言特性：Switch运算符(?::)
- en: 'In this chapter, we will design a new C# langauge feature that we call *Switch
    operator (?::)*. This feature is derived from two existing C# language constructs:
    switch statement ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch))
    and conditional operator `(?:)` ([https://docs.microsoft.com/en-us/cpp/cpp/conditional-operator-q](https://docs.microsoft.com/en-us/cpp/cpp/conditional-operator-q)).
    It allows writing conditional expressions that can switch on multiple values of
    the expression and return a corresponding value or a default value. For example,
    consider the following switch statement that computes a string representation
    for an integral expression:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设计一个新的C#语言特性，我们称之为*Switch运算符(?::)*。这个特性来源于两个现有的C#语言结构：switch语句([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch))和条件运算符`(?:)`([https://docs.microsoft.com/en-us/cpp/cpp/conditional-operator-q](https://docs.microsoft.com/en-us/cpp/cpp/conditional-operator-q))。它允许编写可以在多个表达式的值上切换的条件表达式，并返回相应的值或默认值。例如，考虑以下计算整型表达式字符串表示的switch语句：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code basically switches on different possible values of the *expression*
    and returns a descriptive string for its runtime value. The underlying intent
    of the user is to just return a mapped expression for different possible values
    of *expression*, with some default value. The switch operator designed in this
    chapter will allow you to rewrite the preceding code using a single expression:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上是在不同的可能值上切换*表达式*，并返回其运行时值的描述性字符串。用户的潜在意图只是为*表达式*的不同可能值返回一个映射的表达式，并带有一些默认值。本章设计的switch运算符将允许您使用单个表达式重写前面的代码：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Designing syntax and grammar for a new C# language feature
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计新C#语言特性的语法和语法
- en: '**Syntax** and **Grammar** are the core elements for implementing a new language
    feature. This section will enable you to define the syntax (nodes and tokens)
    and grammar for a new C# language feature: Switch operator `(?::)`. For details
    on the intended functionality of this operator, read the section *New language
    feature:* *Switch Operator (?::)* at the start of this chapter.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**和**语法**是实现新语言特性的核心元素。本节将使您能够定义新C#语言特性的语法（节点和标记）和语法：Switch运算符`(?::)`。有关此运算符预期功能的详细信息，请参阅本章开头关于*新语言特性:*
    *Switch运算符(?::)*的部分。'
- en: Getting Started
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You need to ensure that you have enlisted and built Roslyn sources with *VS2017*
    tag on your machine. For further guidance, refer to the recipe, *Setting up Roslyn
    enlistment* in
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保您已在您的机器上注册并构建了带有*VS2017*标签的Roslyn源。有关进一步指导，请参阅食谱，*设置Roslyn注册*。
- en: '[Chapter 8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml), *Contribute Simple
    Functionality to Roslyn C# Compiler Open Source Code*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml)，*向Roslyn C#编译器开源代码贡献简单功能*。'
- en: For the steps in the recipe that mention *Define ... in the C# language specification*,
    the reader should create a new GitHub issue on ([https://github.com/dotnet/roslyn/issues/new](https://github.com/dotnet/roslyn/issues/new))
    with labels Language-C# and Area-Language Design and get the specification reviewed
    by the language team. If approved, the reviewers will ensure that it gets added
    to the C# language specification.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提到*在C#语言规范中定义...*的食谱步骤，读者应在([https://github.com/dotnet/roslyn/issues/new](https://github.com/dotnet/roslyn/issues/new))上创建一个新的GitHub问题，并添加标签Language-C#和Area-Language
    Design，让语言团队审查规范。如果获得批准，审阅者将确保将其添加到C#语言规范中。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define the grammar for the new ternary operator `?::` in the C# language specification
    :'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#语言规范中定义新三元运算符`?::`的语法：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define the compile time semantics associated with the new operator and the
    switch expression in C# language specification:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#语言规范中定义与新运算符和switch表达式相关的编译时语义：
- en: 'A switch expression of the form `expr ?: [label1, label2, ..., labeln] : [val1,
    val2, ..., valn, valn+1]` has the following compile time semantics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '形式为`expr ?: [label1, label2, ..., labeln] : [val1, val2, ..., valn, valn+1]`的switch表达式具有以下编译时语义：'
- en: The governing type of the switch expression is established by the same set of
    rules as the governing type of a switch statement.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: switch 表达式的控制类型由与 switch 语句控制类型相同的规则集确定。
- en: The first bracketed argument list `[label1, label2, ..., labeln]` must contain
    expressions labeli with a constant value that is implicitly convertible to the
    switch governing type. A compile-time error occurs if two or more `labeli` in
    the same switch expression specify the same constant value.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个括号参数列表 `[label1, label2, ..., labeln]` 必须包含具有隐式可转换为 switch 控制类型的常量值的表达式 labeli。如果同一个
    switch 表达式中的两个或多个 `labeli` 指定相同的常量值，则编译时将发生错误。
- en: 'The second bracketed argument list `[val1, val2, ..., valn, valn+1]` controls
    the type of the switch expression resultant value. Applying the following checks
    to each pair vali and valj in the list must yield the same value for type Z; otherwise,
    a compile time error occurs:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个括号参数列表 `[val1, val2, ..., valn, valn+1]` 控制 switch 表达式的结果值类型。对列表中的每个 vali
    和 valj 对执行以下检查必须得到类型 Z 的相同值；否则，将发生编译时错误：
- en: 'If `vali` has type X and `valj` has type Y then:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `vali` 的类型为 X，而 `valj` 的类型为 Y，则：
- en: If an implicit conversion exists from X to Y, but not from Y to X, then Y is
    the type of the expression (Z = Y).
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在从 X 到 Y 的隐式转换，但不存在从 Y 到 X 的转换，则 Y 是表达式的类型（Z = Y）。
- en: If an implicit conversion exists from Y to X, but not from X to Y, then X is
    the type of the expression (Z = X).
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在从 Y 到 X 的隐式转换，但不存在从 X 到 Y 的转换，则 X 是表达式的类型（Z = X）。
- en: Otherwise, no expression type can be determined, and a compile-time error occurs.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，无法确定表达式类型，编译时将发生错误。
- en: If only one of `vali` and `valj` has a type, and both `vali` and `valj` are
    implicitly convertible to a type Z, then that is the type of the expression.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有 `vali` 或 `valj` 中的一个有类型，并且 `vali` 和 `valj` 都可以隐式转换为类型 Z，则该类型是表达式的类型。
- en: Otherwise, no expression type can be determined, and a compile-time error occurs.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，无法确定表达式类型，编译时将发生错误。
- en: 'Define the associativity and precedence for the new operator in the C# language
    specification:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C# 语言规范中定义新操作符的关联性和优先级：
- en: The switch operator is right-associative, meaning that operations are grouped
    from right to left.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: switch 操作符是右结合的，这意味着操作是从右到左分组的。
- en: The switch operator has the same precedence as other ternary operators (such
    as conditional operator `?:`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: switch 操作符与其他三元操作符（如条件操作符 `?:`）具有相同的优先级。
- en: 'Define the runtime execution semantics of the switch expression in the C# language
    specification:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C# 语言规范中定义 switch 表达式的运行时执行语义：
- en: 'A switch expression is evaluated as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: switch 表达式的评估如下：
- en: The expression expr is evaluated and converted to the governing type.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估表达式 `expr` 并将其转换为控制类型。
- en: If one of the n constants, say `labeli`, specified in the first bracketed list
    in the same switch expression is equal to the value of the expression `expr`,
    then expression `vali` in the second bracketed list is evaluated and converted
    to type Z and becomes the resultant value of the expression.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在同一个 switch 表达式中第一个括号列表指定的 n 个常量之一，例如 `labeli`，等于表达式 `expr` 的值，则评估第二个括号列表中的表达式
    `vali` 并将其转换为类型 Z，并成为表达式的结果值。
- en: If none of the n constants specified in the first bracketed list in the same
    switch expression is equal to the value of the expression `expr`, then the last
    expression `valn+1` in the second bracketed list is evaluated and converted to
    type Z and becomes the resultant value of the expression.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在同一个 switch 表达式中第一个括号列表指定的 n 个常量中没有与表达式 `expr` 的值相等的，则评估第二个括号列表中的最后一个表达式 `valn+1`
    并将其转换为类型 Z，并成为表达式的结果值。
- en: 'Open `Roslyn.sln` in Visual Studio 2017 and open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKind.cs`.
    Add new `SyntaxKinds` for the `QuestionColonToken` and `SwitchExpression` at lines
    77 and 334, respectively:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中打开 `Roslyn.sln` 并打开源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKind.cs`。在
    77 行和 334 行分别添加新的 `SyntaxKinds` 以支持 `QuestionColonToken` 和 `SwitchExpression`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\Syntax.xml`
    and add XML definition for the new syntax node `SwitchExpressionSyntax` with fields
    `Expression`*,* `QuestionColonToken`*,* `Labels`*,* `ColonToken`*,* and `Values`
    at line 686:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\Syntax.xml` 中添加新的语法节点
    `SwitchExpressionSyntax` 的 XML 定义，包含字段 `Expression`、`QuestionColonToken`、`Labels`、`ColonToken`
    和 `Values`，在 686 行：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Build the project `CSharpCodeAnalysis` to auto generate the source code for
    the new `SwitchExpressionSyntax` node added earlier. Note that the build will
    fail with a bunch of *RS0016* errors as we haven't added the new public types
    to the public API surface.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`CSharpCodeAnalysis`以自动生成之前添加的新`SwitchExpressionSyntax`节点生成的源代码。请注意，由于我们尚未将新的公共类型添加到公共API表面，构建将因一系列*RS0016*错误而失败。
- en: 'Switch back to source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKind.cs`
    and invoke the code fix at line 334 defining the `SwitchExpression` using *Ctrl*
    + *.* and apply Fix all occurrences in Project to fix all *RS0016* diagnostics:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回源文件`%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKind.cs`，并在第334行使用*Ctrl*
    + *.*调用代码修复，以定义`SwitchExpression`，并应用项目中的所有出现以修复所有*RS0016*诊断：
- en: '![](img/9ec078ac-f9b2-451c-ac85-92366274d38c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ec078ac-f9b2-451c-ac85-92366274d38c.png)'
- en: Build the project again and verify it succeeds this time.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建项目并验证这次是否成功。
- en: You can view all the source changes made in this recipe at [https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)查看此配方中做出的所有源代码更改。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first half of this recipe, we walked through the steps to define the
    grammar, compile time, and runtime semantics, associativity and precedence of
    the new switch expression/operator. In the second half, we defined the new syntax
    kinds and syntax node in the compiler.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方的前半部分，我们介绍了定义新switch表达式/运算符的语法、编译时和运行时语义、结合性和优先级的步骤。在下半部分，我们在编译器中定义了新的语法类型和语法节点。
- en: The grammar, associativity, and precedence for the new switch expression is
    identical to the grammar for the existing conditional ternary expression.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新的switch表达式/运算符的语法、结合性和优先级与现有条件三元表达式的语法相同。
- en: 'As both the ternary operators come just after the null coalescing operator
    (??) in the precedence order, the grammar specifies:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于三元运算符在优先级顺序中紧接在空合并运算符（??）之后，语法指定：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The grammar specifies the labels and the values for the switch expression to
    be a comma separated argument list within square brackets, for example, `[ arg1[,]
    arg[2], ..., arg[n] ]`. Some examples of expressions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 语法指定switch表达式的标签和值为一个逗号分隔的参数列表，位于方括号内，例如，`[ arg1[,] arg[2], ..., arg[n] ]`。以下是一些表达式的示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compile time semantics enforce that the type of the expression being switched
    on has the same semantic requirements as the switch governing type for a switch
    statement:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时语义强制要求被切换的表达式的类型与switch语句的switch控制类型具有相同的语义要求：
- en: 'The governing type of a switch statement is established by the switch expression.
    If the type of the switch expression is sbyte, byte, short, ushort, int, uint,
    long, ulong, char, string, or an enum-type, then that is the governing type of
    the switch statement. Otherwise, exactly one user-defined implicit conversion
    (Section 6.4) must exist from the type of the switch expression to one of the
    following possible governing types: sbyte, byte, short, ushort, int, uint, long,
    ulong, char, string. If no such implicit conversion exists, or if more than one
    such implicit conversion exists, a compile-time error occurs.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句的控制类型由switch表达式确定。如果switch表达式的类型是sbyte、byte、short、ushort、int、uint、long、ulong、char、string或枚举类型，那么这就是switch语句的控制类型。否则，必须存在从switch表达式类型到以下可能控制类型之一的确切用户定义的隐式转换（第6.4节）：sbyte、byte、short、ushort、int、uint、long、ulong、char、string。如果不存在此类隐式转换，或者存在多个此类隐式转换，则编译时将发生错误。
- en: 'Compile time semantics also enforce that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时语义还强制要求：
- en: The first bracketed argument list be all constant labels, such that there is
    an implicit conversion to the switch governing type
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个括号内的参数列表必须是所有常量标签，这样就有隐式转换为switch控制类型的转换
- en: The second argument list be of length one greater than the first list and all
    arguments be expressions, such that they are convertible to a common type `Z`
    with implicit conversions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数列表的长度必须比第一个列表长一个，并且所有参数都必须是表达式，这样它们可以转换为具有隐式转换的公共类型`Z`
- en: 'The following are some examples of semantically valid and invalid switch expressions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些语义有效和无效的switch表达式的示例：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Runtime semantics of the switch expression are identical to the switch statement.
    The expression on which we switch is first evaluated, and its value compared against
    each label in the first argument list. For a match, we evaluate the corresponding
    expression in the second list and convert it to type `Z` and that becomes the
    result of the expression. If there is no match, the last expression in the second
    argument list is evaluated and converted to type `Z` and becomes the default result
    of the expression:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Switch 表达式的运行时语义与 switch 语句相同。首先评估我们切换的表达式，并将其值与第一个参数列表中的每个标签进行比较。对于匹配项，我们评估第二个列表中的相应表达式并将其转换为类型
    `Z`，这成为表达式的结果。如果没有匹配项，则评估第二个参数列表中的最后一个表达式并将其转换为类型 `Z`，这成为表达式的默认结果：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementing parser support for a new C# language feature
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对新的 C# 语言功能的解析器支持
- en: '**Lexical analysis** and **Syntax analysis** (**Parsing**) are initial phases
    of the C# compiler that transform the input source text into a syntax tree with
    nodes and tokens and reports syntax diagnostics. This section will enable you
    to add the lexer and parser support for a new C# language feature: *Switch operator
    (?::)*. For details on the intended functionality of this operator, read the section
    *New language feature: Switch Operator (?::)* at the start of this chapter. For
    details on the grammar and syntax definitions for this operator, read the previous
    recipe.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**词法分析** 和 **语法分析**（**解析**）是 C# 编译器的初始阶段，将输入源文本转换为具有节点和标记的语法树，并报告语法诊断。本节将使您能够为新的
    C# 语言功能添加词法分析和解析器支持：*Switch 操作符 (?::)*。有关此操作符预期功能的信息，请参阅本章开头的 *新语言功能：Switch 操作符
    (?::)* 部分。有关此操作符的语法和语法定义的详细信息，请参阅前面的配方。'
- en: Getting Started
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You need to ensure that you have enlisted and built Roslyn sources with *VS2017*
    tag on your machine. For further guidance, refer to the recipe, *Setting up Roslyn*,
    *enlistment* in [Chapter 8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml), *Contribute
    Simple Functionality to Roslyn C# Compiler Open Source Code*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保在您的机器上已 enlist 并使用 *VS2017* 标签构建了 Roslyn 源代码。有关进一步指导，请参阅配方，*设置 Roslyn*，*enlistment*
    在 [第 8 章](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml)，*向 Roslyn C# 编译器开源代码贡献简单功能*。
- en: Additionally, git commit [https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)
    on your enlistment to get the syntax definitions and build `CSharpCodeAnalysis`
    project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在您的 enlistment 上 git commit [https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)
    以获取语法定义并构建 `CSharpCodeAnalysis` 项目。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open `Roslyn.sln` in Visual Studio 2017
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中打开 `Roslyn.sln`
- en: Open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Parser\Lexer.cs`
    and add the highlighted `else if` statement at line 565 in the method `ScanSyntaxToken`*:*
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Parser\Lexer.cs` 并在方法 `ScanSyntaxToken`
    的第 565 行添加高亮的 `else if` 语句：*
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs`
    and add the highlighted `else if` statement at line 9426 in the method `ParseSubExpressionCore`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs` 并在方法
    `ParseSubExpressionCore` 的第 9426 行添加高亮显示的 `else if` 语句：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Go to line 10552 in the same file (method `CanFollowCast`*)* add the highlighted
    case clause:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件（方法 `CanFollowCast`*）的第 10552 行添加高亮显示的 case 子句：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKindFacts.cs`
    and add the highlighted case clause at line 1278 in the method `GetText`*:*
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKindFacts.cs`
    并在方法 `GetText` 的第 1278 行添加高亮显示的 case 子句：*
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Set `Roslyn.csproj` as the startup project.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Roslyn.csproj` 设置为启动项目。
- en: Change the solution configuration from Debug to Release (to avoid asserts in
    the binder) and rebuild the solution.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解决方案配置从调试更改为发布（以避免绑定器中的断言）并重新构建解决方案。
- en: Hit *Ctrl* + *F5* to start new instance of VS from the `RoslynDev` hive with
    our local changes.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *F5* 以从 `RoslynDev` hive 启动 VS 的新实例并应用我们的本地更改。
- en: 'In the new instance of VS, create a new C# class library project and add the
    following code, which uses the new switch operator:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 VS 实例中，创建一个新的 C# 类库项目并添加以下代码，该代码使用新的 switch 操作符：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the Roslyn syntax visualizer from View | Other Windows | Syntax Visualizer
    and select the switch expression in the editor to view the parsed syntax nodes
    and tokens for the expression. For guidance on the syntax visualizer, refer to
    the recipe, *Using Roslyn syntax visualizer to view Roslyn syntax tokens and nodes
    for a source file* in [Chapter 8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml),
    *Contribute Simple Functionality to Roslyn C# Compiler Open Source Code.*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“查看”菜单中选择“其他窗口”中的“Roslyn语法可视化器”，然后在编辑器中选择 switch 表达式，以查看表达式的解析语法节点和标记。有关语法可视化器的指导，请参考食谱，“使用
    Roslyn 语法可视化器查看源文件的 Roslyn 语法标记和节点”在[第 8 章](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml)，“向
    Roslyn C# 编译器开源代码贡献简单功能”。
- en: '![](img/82e46abf-99ba-4048-8bb6-f028d93192ac.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82e46abf-99ba-4048-8bb6-f028d93192ac.png)'
- en: 'Verify that there are no squiggles or intellisense errors in the error list:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证错误列表中没有波浪线或智能感知错误：
- en: '![](img/0aa474cb-ee17-4fef-9386-9796ee60a144.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0aa474cb-ee17-4fef-9386-9796ee60a144.png)'
- en: 'Remove the colon token and the second bracketed argument list, that is, `:
    ["One", "Two", "Three", "More than three"]`, and verify you get syntax errors
    for missing tokens in the switch expression:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '删除冒号标记和第二个括号内的参数列表，即 `: ["One", "Two", "Three", "More than three"]`，并验证你会在
    switch 表达式中因为缺少标记而得到语法错误：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Revert step 11 and try to build the project and verify it fails with `CSC :
    error CS7038: Failed to emit module ''ClassLibrary''` as we have not implemented
    any binding or code generation for the new construct.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '撤销步骤 11，然后尝试构建项目并验证它因为 `CSC : error CS7038: Failed to emit module ''ClassLibrary''`
    而失败，因为我们尚未为新的结构实现任何绑定或代码生成。'
- en: You can view all the source changes made in this recipe at [https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)查看在这个食谱中做出的所有源代码更改。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In this recipe, we added basic lexer and parser support for the switch operator
    (?:). Lexer is primarily responsible for scanning the text and generating tokens.
    LanguageParser is responsible for parsing the lexed tokens and generate syntax
    tree with nodes and tokens.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们为 switch 运算符（?:）添加了基本的词法分析和解析器支持。词法分析器主要负责扫描文本并生成标记。LanguageParser
    负责解析词法标记并生成带有节点和标记的语法树。
- en: 'Let''s walk through our code changes in this recipe. We added the following
    highlighted code to the lexer:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历这个食谱中的代码更改。我们向词法分析器中添加了以下高亮代码：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the original code, when we were scanning the text and identify a `'?'` character,
    we peeked at the next character to identify it is another `'?'` character (the
    ?? null coalescing operator) or a whitespace (the `?` token for the conditional
    operator). Our new code adds an additional check for whether the next character
    is `':'` (the `?:` token for the switch operator). If so, it advances the current
    character in the text window and sets the syntax kind for the current token to
    `SyntaxKind.QuestionColonToken`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始代码中，当我们扫描文本并识别到 `'?'` 字符时，我们会查看下一个字符以识别它是否是另一个 `'?'` 字符（?? 空合并运算符）或空白（条件运算符的
    `?` 标记）。我们新的代码添加了一个额外的检查，以确定下一个字符是否是 `':'`（switch 运算符的 `?:` 标记）。如果是这样，它将文本窗口中的当前字符向前移动，并将当前标记的语法类型设置为
    `SyntaxKind.QuestionColonToken`。
- en: 'We added the following highlighted code to the parser:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向解析器中添加了以下高亮代码：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We extended the original code that parsed the `QuestionToken` in the parser
    to also check for the `QuestionColonToken` and ternary precedence. If so, we eat
    the next token as the `questionColonToken`. Then, we attempt to parse the `labels`
    as a bracketed argument list by invoking `ParseBracketedArgumentList` (this code
    already exists in the language parser for parsing the bracketed argument list
    for a dictionary initializer). This is followed by parsing the colon token by
    invoking `EatToken` with the expected syntax kind for the colon token. This method
    handles both the valid and invalid token cases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了原始代码，该代码在解析器中解析 `QuestionToken` 时，也检查了 `QuestionColonToken` 和三元运算符的优先级。如果是这样，我们将下一个标记作为
    `questionColonToken` 消费。然后，我们通过调用 `EatToken` 并传递冒号标记的预期语法类型来解析冒号标记。此方法处理有效和无效标记的情况：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For a valid token of the expected kind, it moves to the next token and returns
    the current colon token. If the next token is not of the expected kind, it generates
    a missing token and also reports a syntax diagnostic for the missing token:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于期望类型的有效标记，它移动到下一个标记并返回当前冒号标记。如果下一个标记不是期望的类型，它将生成一个缺失的标记，并报告缺失标记的语法诊断：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we parse the *values* as another bracketed argument list. We invoke
    the newly auto generated syntax factory helper `SwitchExpression` to generate
    a `SwitchExpressionSyntax` node with the parsed tokens.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 *值* 作为另一个括号参数列表进行解析。我们调用新自动生成的语法工厂辅助程序 `SwitchExpression` 来生成带有解析标记的
    `SwitchExpressionSyntax` 节点。
- en: Implementing binding/semantic analysis support for a new C# language feature
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对新的 C# 语言特性的绑定/语义分析支持
- en: '**Semantic analysis** (**Binding)** is the intermediate phase of the C# compiler
    that transforms syntax trees into C# bound trees and reports semantic diagnostics.
    This section will enable you to add the binding support for a new C# language
    feature: `Switch operator (?::)`. For details on the intended functionality of
    this operator, read the section, *New language feature: Switch Operator (?::)*
    at the start of this chapter. For details on the grammar and syntax definitions
    for this operator, read the first recipe of this chapter, *Designing syntax and
    grammar for a new C# language feature*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义分析**（**绑定**）是 C# 编译器的中间阶段，将语法树转换为 C# 绑定树并报告语义诊断。本节将使你能够为新的 C# 语言特性添加绑定支持：`Switch
    操作符 (?::)`。有关此操作符预期功能的信息，请参阅本章开头部分，*新语言特性：Switch 操作符 (?::)*。有关此操作符的语法和语法定义的详细信息，请参阅本章第一道菜谱，*为新的
    C# 语言特性设计语法和语法*。'
- en: Getting Started
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You need to ensure that you have enlisted and built Roslyn sources with *VS2017*
    tag on your machine. For further guidance, refer to the recipe, *Setting up Roslyn
    enlistment* in [Chapter 8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml), *Contribute
    Simple Functionality to Roslyn C# Compiler Open Source Code*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保你在机器上已经使用带有 *VS2017* 标签的 enlistment 并构建了 Roslyn 源代码。有关进一步指导，请参阅菜谱，*设置 Roslyn
    enlistment* 在 [第 8 章](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml)，*向 Roslyn C#
    编译器开源代码贡献简单功能*。
- en: 'Additionally, the following two git commits on your enlistment to get the syntax
    definitions and parser support, respectively, and build `CSharpCodeAnalysis` project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在你的 enlistment 上进行以下两个 git 提交以获取语法定义和解析器支持，分别构建 `CSharpCodeAnalysis` 项目：
- en: '[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)'
- en: '[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)'
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open `Roslyn.sln` in Visual Studio 2017
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中打开 `Roslyn.sln`
- en: Open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\BoundTree\BoundNodes.xml`
    and add the following `BoundSwitchOperator` definition at line 437*:*
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\BoundTree\BoundNodes.xml` 并在第
    437 行添加以下 `BoundSwitchOperator` 定义：*
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Binder\Binder_Expression.cs`
    and add the `switch` section at line 535 in the method `BindExpressionInternal`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Binder\Binder_Expression.cs`
    并在 `BindExpressionInternal` 方法中的第 535 行添加 `switch` 部分：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Copy the method implementations for `BindSwitchOperator` and `BindSwitchOperatorArguments`
    from the attached code sample source file `CSharpCodeAnalysis\Binder_Operators.cs`
    and paste them into source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Binder\Binder_Operators.cs`
    at line 3521.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从附加的代码示例源文件 `CSharpCodeAnalysis\Binder_Operators.cs` 复制 `BindSwitchOperator`
    和 `BindSwitchOperatorArguments` 方法的实现，并将其粘贴到源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Binder\Binder_Operators.cs`
    的第 3521 行。
- en: Copy the partial type definition for `BoundSwitchOperator` from the attached
    code sample source file `CSharpCodeAnalysis\Expression.cs` and paste it into source
    file `%REPO_ROOT%\src\Compilers\CSharp\Portable\BoundTree\Expression.cs` at line
    1221.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从附加的代码示例源文件 `CSharpCodeAnalysis\Expression.cs` 复制 `BoundSwitchOperator` 的部分类型定义，并将其粘贴到源文件
    `%REPO_ROOT%\src\Compilers\CSharp\Portable\BoundTree\Expression.cs` 的第 1221 行。
- en: 'Add a new source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_SwitchOperator.cs`
    to the project `CSharpCodeAnalysis` with a stub implementation of the lowering
    for the switch operator copied from `CSharpCodeAnalysis\LocalRewriter_SwitchOperator.cs`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_SwitchOperator.cs`
    添加到项目 `CSharpCodeAnalysis` 中，并使用从 `CSharpCodeAnalysis\LocalRewriter_SwitchOperator.cs`
    复制的 switch 运算符降级实现作为占位符：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add stub flow analysis implementation for the switch operator to `%REPO_ROOT%\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass_Switch.cs`
    at line 260:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `%REPO_ROOT%\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass_Switch.cs`
    文件的第 260 行添加 switch 运算符的占位符流分析实现：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Build project `csc.csproj` to generate `%REPO_ROOT%\Binaries\Debug\Exes\csc\csc.exe`
    with our local changes.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的本地更改构建项目 `csc.csproj` 以生成 `%REPO_ROOT%\Binaries\Debug\Exes\csc\csc.exe`。
- en: 'Create a new source file, say `test.cs`, with the following source code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的源文件，例如 `test.cs`，并包含以下源代码：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compile this source file with locally built `csc.exe` and verify that the build
    succeeds.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本地构建的 `csc.exe` 编译此源文件，并验证构建是否成功。
- en: 'Run the generated executable `test.exe` and verify it runs fine, but the output
    is still not the expected result due to a stub codegen implementation for the
    switch operator:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行生成的可执行文件 `test.exe` 并验证其运行良好，但由于 switch 运算符的占位符代码生成实现，输出仍然不是预期的结果：
- en: '![](img/2f6edcd0-fffb-4765-9b60-8f661c836e6d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f6edcd0-fffb-4765-9b60-8f661c836e6d.png)'
- en: You can view all the source changes made in this recipe at [https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236](https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236](https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236)
    查看在此配方中做出的所有源代码更改。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we added basic binding/semantic analysis support for the switch
    operator `(?:)`, which enabled us to compile and execute source code with this
    new operator. Note that this is not a comprehensive implementation of the binding
    phase for this operator, and requires further work such as enhanced error reporting.
    See the next section, *There's more...*, in this recipe for further details.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们为 switch 运算符 `(?:)` 添加了基本的绑定/语义分析支持，这使得我们能够使用此新运算符编译和执行源代码。请注意，这并不是此运算符绑定阶段的全面实现，需要进一步的工作，例如增强错误报告。请参阅本配方中的下一节，*还有更多...*，以获取更多详细信息。
- en: The C# binder is responsible for semantic analysis of the syntax tree produced
    by the parser. It transforms the syntax tree into a bound tree with `BoundNodes`,
    which is essentially an abstract syntax tree with rich semantic information associated
    with each node in the tree.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C# 绑定器负责对解析器生成的语法树进行语义分析。它将语法树转换为带有 `BoundNodes` 的绑定树，这本质上是一个与树中每个节点相关联的丰富语义信息的抽象语法树。
- en: 'We first added a new BoundNode definition for the switch operator, `BoundSwitchOperator`**,**
    into a template file `BoundNodes.xml`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在模板文件 `BoundNodes.xml` 中添加了一个新的 BoundNode 定义，`BoundSwitchOperator`**，**：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note the difference between syntax nodes and bound nodes for the switch operator.
    We no longer store any purely syntactic information, such as the question colon
    token or the brackets around the argument list. The expression on which the switch
    operates is expected to bind to a `BoundExpression`, and labels and values are
    also expected be a list of bound expressions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 switch 运算符的语法节点和绑定节点之间的区别。我们不再存储任何纯语法信息，例如问题冒号标记或参数列表周围的括号。switch 运算符所操作的表达式预期绑定到
    `BoundExpression`，标签和值也预期是一个绑定表达式的列表。
- en: Building the project `CSharpCodeAnalysis` runs a generator tool over BoundNodes.xml
    file as a pre-build step to auto-generate `BoundNodes.generated.cs` file with
    the source definitions for the bound nodes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 `CSharpCodeAnalysis` 项目作为预构建步骤运行生成器工具对 BoundNodes.xml 文件进行处理，以自动生成包含绑定节点源定义的
    `BoundNodes.generated.cs` 文件。
- en: '`BoundNodes.generated.cs` is no longer automatically generated during the build
    of `CSharpCodeAnalysis` project in the latest Roslyn master branch, which was
    a post *VS2017* change. On the latest sources, you must explicitly run the following
    script to auto-generate this code: [https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd](https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的 Roslyn 主分支中，`CSharpCodeAnalysis` 项目的构建过程中不再自动生成 `BoundNodes.generated.cs`，这是一个在
    *VS2017* 之后的变化。在最新的源代码中，您必须显式运行以下脚本来自动生成此代码：[https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd](https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd)。
- en: The core binding support involved appending the switch case in `BindExpressionInternal`
    to handle the syntax node of `SyntaxKind.SwitchExpression` and invoke `BindSwitchOperator`
    method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 核心绑定支持涉及在 `BindExpressionInternal` 中追加切换情况，以处理 `SyntaxKind.SwitchExpression`
    的语法节点并调用 `BindSwitchOperator` 方法。
- en: 'We added the new method `BindSwitchOperator` to the binder to handle top level
    binding of the `SwitchExpressionSyntax` node:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向绑定器添加了新的方法 `BindSwitchOperator` 来处理 `SwitchExpressionSyntax` 节点的顶级绑定：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We bind the expression of the switch operator as a value using `BindValue`
    ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder_Expressions.cs,608d49de0066ede1,references](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder_Expressions.cs,608d49de0066ede1,references))
    invocation. This guarantees that we have an actual expression with a value, rather
    than a type, as the node''s expression. For example, we get the following semantic
    error when this is violated:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `BindValue` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder_Expressions.cs,608d49de0066ede1,references](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder_Expressions.cs,608d49de0066ede1,references))
    调用来绑定切换操作符的表达式作为值。这保证了节点表达式是一个实际的具有值的表达式，而不是类型。例如，当违反此规则时，我们会得到以下语义错误：
- en: '![](img/d78108e5-7438-4828-8deb-afeeeba71ede.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d78108e5-7438-4828-8deb-afeeeba71ede.png)'
- en: 'We added the new method, `BindSwitchOperatorArguments`, to bind the `Labels`
    and `Values` of the switch operator:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了新的方法 `BindSwitchOperatorArguments` 来绑定切换操作符的 `Labels` 和 `Values`：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method invokes the existing binder method, `BindArgumentsAndNames` ([http://source.roslyn.io/#q=BindArgumentsAndNames](http://source.roslyn.io/#q=BindArgumentsAndNames)),
    to bind the argument list and then build arguments for error recovery.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用现有的绑定器方法 `BindArgumentsAndNames` ([http://source.roslyn.io/#q=BindArgumentsAndNames](http://source.roslyn.io/#q=BindArgumentsAndNames))
    来绑定参数列表，然后构建错误恢复的参数。
- en: 'We also added a stub partial type implementation for `BoundSwitchOperator`
    for implementing `IOperation` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperation.cs,7743f66521e66763](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperation.cs,7743f66521e66763))
    APIs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 `BoundSwitchOperator` 的存根部分类型实现，以实现 `IOperation` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperation.cs,7743f66521e66763](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperation.cs,7743f66521e66763))
    API：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`IOperation` is a new experimental feature that is currently being implemented
    in the compiler layers to expose the semantics associated with the compiler bound
    nodes as a publically supported API. The API is not released or publically supported
    as of VS2017, which may or may not change in a future release.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOperation` 是一个正在编译器层中实现的新实验性功能，旨在将与编译器绑定节点相关的语义作为公开支持的 API 公开。截至 VS2017，该
    API 未经发布或公开支持，未来版本可能会有所变化。'
- en: 'Additionally, we added stub implementations for flow analysis and lowering
    to enable us to build source code with the switch operator, though the generated
    MSIL or the output of the compiled executable is not the same as the expected
    final outcome. More specifically, the lowering implementation just replaced the
    entire `BoundSwitchOperator` node with a bound string literal stating that codegen
    is not yet implemented for the new switch operator:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了流程分析和降级的存根实现，以便我们能够构建带有切换操作符的源代码，尽管生成的 MSIL 或编译可执行文件的结果与预期的最终结果不同。更具体地说，降级实现只是将整个
    `BoundSwitchOperator` 节点替换为一个绑定的字符串字面量，表明尚未为新的切换操作符实现代码生成：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Refer to the next recipe in this chapter for implementing lowering support for
    the operator.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章下一节了解如何实现操作符降级支持。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The current binder implementation of the switch operator has a bunch of pending
    work items, primarily related to more comprehensive semantic validation and error
    generation. The validation items to be implemented are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当前switch操作符的绑定实现有一系列待办工作项，主要与更全面的语义验证和错误生成相关。要实现验证的项目包括：
- en: Add semantic validation that the expression of the switch operator has a type
    as per the requirements of a switch governing type; otherwise, generate a compile
    time error.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对switch操作符表达式的类型进行语义验证，以确保其类型符合switch控制类型的需要；否则，生成编译时错误。
- en: 'Add new compiler diagnostics for argument list validations. For example:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为参数列表验证添加新的编译器诊断。例如：
- en: Ensure that the number of expressions in values is one greater than the number
    of expression in labels; otherwise, generate a compile time error.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保values中的表达式数量比labels中的表达式数量多一个；否则，生成编译时错误。
- en: Ensure that the labels are all compile time constants with implicit conversions
    to the switch governing type. If not, generate required compile time errors.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有标签都是编译时常量，并且可以隐式转换为控制switch的类型。如果不是这样，将生成所需的编译时错误。
- en: Validate that the types of the expressions in Values are implicitly convertible
    to a common type Z, which is the type of the expression.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证Values中的表达式类型是否可以隐式转换为表达式类型的公共类型Z。
- en: These items are left as an exercise for the reader. For further guidance on
    implementing a new semantic error in the compiler code base, refer to recipe,
    *Implementing a new semantic error in the C# compiler code base,* in [Chapter
    8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml), *Contribute Simple Functionality
    to Roslyn C# Compiler Open Source Code.*
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容留作读者练习。关于在编译器代码库中实现新的语义错误的进一步指导，请参阅[第8章](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml)中的食谱，“在C#编译器代码库中实现新的语义错误”，在“向Roslyn
    C#编译器开源代码贡献简单功能”一书中。
- en: 'We also added basic stub implementations for the following pieces, which need
    further enhancements:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了以下部分的基本存根实现，需要进一步改进：
- en: '`IOperation` support the switch operator: This will involve creating a new
    `OperationKind` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperationKind.cs,bf7324631c03b2e7](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperationKind.cs,bf7324631c03b2e7))
    for the switch expression, adding a new interface, say `ISwitchChoiceExpression`,
    with the following API shape and then implementing this interface on the `BoundSwitchOperator`.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IOperation`支持switch操作符：这涉及到为switch表达式创建一个新的`OperationKind`（[http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperationKind.cs,bf7324631c03b2e7](http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperationKind.cs,bf7324631c03b2e7)），添加一个新的接口，例如`ISwitchChoiceExpression`，具有以下API形状，然后在`BoundSwitchOperator`上实现此接口。'
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add lowering support for the switch operator: This is covered in the next recipe.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对switch操作符的lowering支持：这将在下一道食谱中介绍。
- en: 'Add flow analysis support for the switch operator: This is not covered in this
    book, but should be implemented to ensure we report proper flow analysis diagnostics
    in code involving the switch operator.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对switch操作符的流分析支持：这在本书中没有介绍，但应该实现以确保在涉及switch操作符的代码中报告正确的流分析诊断。
- en: Implementing lowering/code generation support for a new C# language feature
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对新C#语言特性的lowering/代码生成支持
- en: '**Lowering** is an intermediate phase that executes after binding and transforms
    high level bound trees into simplified bound trees. These simplified bound trees
    are provided to the **Code Generation** phase and converted into MSIL and emitted
    into a .NET assembly. This section will enable you to add the lowering support
    for a new C# language feature: Switch operator `(?::)`. This will enable you to
    write, compile, and correctly execute C# programs with the new operator. For details
    on the intended functionality of this operator, read the section, *New language
    feature: Switch Operator (?::)* at the start of this chapter. For details on the
    grammar and syntax definitions for this operator, read the first recipe of this
    chapter, *Designing syntax and grammar for a new C# language feature*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lowering**是一个中间阶段，在绑定之后执行，将高级绑定树转换为简化绑定树。这些简化绑定树被提供给**代码生成**阶段，并转换为MSIL并输出到.NET程序集。本节将使您能够添加对新C#语言特性的lowering支持：Switch操作符`(?::)`。这将使您能够编写、编译并正确执行使用新操作符的C#程序。关于此操作符预期功能的具体信息，请参阅本章开头的部分，“新语言特性：Switch操作符(?::)”。关于此操作符的语法和语法定义的详细信息，请参阅本章的第一道食谱，“为新的C#语言特性设计语法和语法”。'
- en: Getting Started
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You need to ensure that you have enlisted and built Roslyn sources with *VS2017*
    tag on your machine. For further guidance, refer to the recipe *Setting up Roslyn
    enlistment* in [Chapter 8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml), *Contribute
    Simple Functionality to Roslyn C# Compiler Open Source Code*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保在您的机器上已注册并构建了带有 *VS2017* 标签的 Roslyn 源代码。有关进一步指导，请参阅[第 8 章](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml)中的配方
    *设置 Roslyn 注册*，*向 Roslyn C# 编译器开源代码贡献简单功能*。
- en: 'Additionally, the following three git commits on your enlistment to get the
    syntax definitions, parser support and binder support, respectively, and build
    `CSharpCodeAnalysis` project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在您的注册中执行以下三个 git 提交以获取语法定义、解析器支持和绑定支持，分别，并构建 `CSharpCodeAnalysis` 项目：
- en: '[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)'
- en: '[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)'
- en: '[https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236](https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236](https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236)'
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open `Roslyn.sln` in Visual Studio 2017
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中打开 `Roslyn.sln`。
- en: Copy the method implementations for `VisitSwitchOperator` and `RewriteSwitchOperator`
    from the attached code sample source file `CSharpCodeAnalysis\LocalRewriter_SwitchOperator.cs`
    and paste them into source file `%REPO_ROOT%\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_SwitchOperator.cs`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从附件中的代码示例源文件 `CSharpCodeAnalysis\LocalRewriter_SwitchOperator.cs` 复制 `VisitSwitchOperator`
    和 `RewriteSwitchOperator` 的方法实现，并将它们粘贴到源文件 `%REPO_ROOT%\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_SwitchOperator.cs`
    中。
- en: Build project `csc.csproj` to generate `%REPO_ROOT%\Binaries\Debug\Exes\csc\csc.exe`
    with our local changes.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本地更改构建项目 `csc.csproj` 以生成 `%REPO_ROOT%\Binaries\Debug\Exes\csc\csc.exe`。
- en: 'Create a new source file, say `test.cs`, with the following source code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的源代码文件，例如 `test.cs`，包含以下源代码：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile this source file with locally built `csc.exe` and verify that the build
    succeeds.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本地构建的 `csc.exe` 编译此源代码文件并验证构建是否成功。
- en: Run the generated executable `test.exe` with a different number of arguments
    and verify the corresponding outputs are as expected from the switch operator.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同数量的参数运行生成的可执行文件 `test.exe` 并验证相应的输出是否符合预期的开关操作符。
- en: '![](img/4585ef22-787d-4ff1-827a-33444ef00026.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4585ef22-787d-4ff1-827a-33444ef00026.png)'
- en: 'Execute the `ildasm.exe test.exe` command and verify the MSIL for the generated
    executable contains sequential checks of the switch expression against the list
    of labels and conditional branches to the corresponding values:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `ildasm.exe test.exe` 命令并验证生成的可执行文件的 MSIL 包含对开关表达式与标签列表的顺序检查以及对相应值的条件分支。
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can view all the source changes made in this recipe at [https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da](https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da](https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da)查看此配方中进行的所有源代码更改。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we added basic lowering support for the switch operator `(?:`),
    which enabled us to compile and execute source code with this new operator and
    give expected runtime results. Note that this is not an optimal implementation
    of the lowering/code generation phase for this operator, and requires further
    work to generate optimized MSIL. This is left as an exercise for the reader.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们为开关操作符 `(?:)` 添加了基本降级支持，这使得我们能够编译和执行带有此新操作符的源代码，并给出预期的运行时结果。请注意，这不是此操作符降级/代码生成阶段的最佳实现，需要进一步工作以生成优化的
    MSIL。这留给读者作为练习。
- en: The C# lowering phase is responsible for transforming the initial bound tree
    from the binder into a simpler bound tree that can be operated by the code generation
    phase. The code generation phase operates on the lowered bound tree and transforms
    it into MSIL. In this recipe, we added lowering support for the switch operator
    that rewrites a switch operator into nested conditional branches.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C#降低阶段负责将绑定器中的初始绑定树转换为更简单的绑定树，以便代码生成阶段可以操作。代码生成阶段在降低的绑定树上操作，并将其转换为MSIL。在本配方中，我们添加了对开关操作符的降低支持，将开关操作符重写为嵌套条件分支。
- en: 'Let''s take an example to clarify the lowering algorithm. Consider the switch
    expression used in our recipe:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来澄清降低算法。考虑我们配方中使用的开关表达式：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This operator gets rewritten into following lowered (pseudo)code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作符被重写为以下降低（伪）代码：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We walk through each constant and compare the value of the expression against
    this constant. If it succeeds, we jump to a label and evaluate the corresponding
    switch operator value, load it into the result, and jump to the exit label. If
    the check fails, then we recursively operate on the remaining labels and values,
    until the expression doesn't match any constant and we evaluate the last (default)
    value.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历每个常量，并将表达式的值与该常量进行比较。如果成功，则跳转到标签并评估相应的开关操作符值，将其加载到结果中，并跳转到退出标签。如果检查失败，则递归地对剩余的标签和值进行操作，直到表达式不匹配任何常量，然后评估最后一个（默认）值。
- en: 'Let''s now walk through the details of the code added in the lowering phase
    that implements the preceding algorithm. `LocalRewriter` type implements the bound
    tree lowering/rewrite. This type is essentially an implementation of `BoundTreeRewriter`
    ([http://source.roslyn.io/#q=BoundTreeRewriter](http://source.roslyn.io/#q=BoundTreeRewriter)),
    which uses a visitor pattern to visit the entire bound tree. It has an overridable
    *VisitXXX* method for every bound node to convert it into a simpler rewritten
    bound node and return the rewritten node. We override the `VisitSwitchOperator`
    method as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细说明在降低阶段添加的代码，该代码实现了前面的算法。`LocalRewriter`类型实现了绑定树降低/重写。此类型本质上是对`BoundTreeRewriter`（[http://source.roslyn.io/#q=BoundTreeRewriter](http://source.roslyn.io/#q=BoundTreeRewriter)）的实现，它使用访问者模式遍历整个绑定树。它为每个绑定节点提供了一个可重写的`*VisitXXX*`方法，将其转换为更简单的重写绑定节点并返回该节点。我们按照以下方式重写`VisitSwitchOperator`方法：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A general requirement and pattern of bound tree rewriter is to first visit
    each of the child nodes of the bound node and use the rewritten child nodes for
    the core rewrite functionality. We first rewrite the switch expression, then the
    labels, values, and the expression type. We also fetch the well-known System.Boolean
    type to be used in the rewrite helper. We pass all these values into the core
    rewrite method, `RewriteSwitchOperator`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定树重写器的一般要求和模式是首先访问绑定节点的每个子节点，并使用重写的子节点进行核心重写功能。我们首先重写开关表达式，然后是标签、值和表达式类型。我们还获取众所周知的System.Boolean类型，用于重写辅助器。我们将所有这些值传递到核心重写方法`RewriteSwitchOperator`：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The rewrite method first validates that we are operating on a switch operator
    with one or more labels, and the count of values is one more than the count of
    the values (otherwise we would have generated a binding error and the lowering
    phase wouldn't have executed).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重写方法首先验证我们正在操作一个具有一个或多个标签的开关操作符，并且值的数量比值的数量多一个（否则我们会生成一个绑定错误，降低阶段就不会执行）。
- en: This method uses a recursive approach to rewrite the switch operator. We first
    generate a `BoundBinaryOperator` with the `==` operator. The `rewrittenExpression`
    is the left of the operator, and the first label in the `rewrittenLabels` is the
    right. This forms our `condition` bound node. The first value in `rewrittenValues`
    list is the `consequence`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用递归方法重写开关操作符。我们首先生成一个具有`==`操作符的`BoundBinaryOperator`。`rewrittenExpression`是操作符的左侧，`rewrittenLabels`中的第一个标签是右侧。这形成了我们的`condition`绑定节点。`rewrittenValues`列表中的第一个值是`consequence`。
- en: If we have more than one `rewrittenLabels`, then we recursively invoke `RewriteSwitchOperator`
    using only the remaining `rewrittenLabels` and `rewrittenValues` except the first
    ones in each list, and this becomes the `alternative`. Otherwise, the second label
    in the current `rewrittenValues` list becomes the alternative.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个`rewrittenLabels`，则递归地使用除了每个列表中的第一个之外的所有剩余`rewrittenLabels`和`rewrittenValues`调用`RewriteSwitchOperator`，这成为`alternative`。否则，当前`rewrittenValues`列表中的第二个标签成为替代品。
- en: 'Finally, we use the preceding `condition` (`BoundBinaryOperator`), `consequence`
    (first rewritten value) and `alternative` (recursive rewrite of rest the of the
    expression) to create a `BoundConditionalOperator` `condition ? consequence :
    alternative` and return that as the final rewritten node*.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们使用前面的 `condition` (`BoundBinaryOperator`)、`consequence`（首先重写的值）和 `alternative`（表达式其余部分的递归重写）来创建
    `BoundConditionalOperator` `condition ? consequence : alternative` 并将其作为最终重写的节点返回*。'
- en: As the lowered bound tree has no new bound node kind, we did not require the
    adding of any new codegen support (it already handled conditional branches). Refer
    to the `CodeGenerator` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,8838d807a9a1d615](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,8838d807a9a1d615))
    type for any implementation details of the code generator.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于降低的边界树没有新的边界节点类型，我们不需要添加任何新的代码生成支持（它已经处理了条件分支）。有关代码生成器的实现细节，请参阅 `CodeGenerator`
    ([http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,8838d807a9a1d615](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,8838d807a9a1d615))
    类型。
- en: Writing unit tests for C# parsing, binding, and codegen phases
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 C# 解析、绑定和代码生成阶段编写单元测试
- en: 'This section will enable you to add unit tests for a new C# language feature:
    Switch operator `(?::)`. For details on the intended functionality of this operator,
    read the section, *New language feature: Switch Operator (?::)*, at the start
    of this chapter.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导你为新的 C# 语言特性添加单元测试：Switch 操作符 `(?::)`。有关此操作符预期功能的信息，请参阅本章开头的部分，*新语言特性：Switch
    操作符 (?::)*。
- en: 'C# compiler has the following set of unit test projects in Roslyn.sln:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: C# 编译器在 Roslyn.sln 中有以下一系列单元测试项目：
- en: '`CSharpCompilerSyntaxTest`: This unit tests for parsing and syntax errors.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpCompilerSyntaxTest`: 这项单元测试用于解析和语法错误。'
- en: '`CSharpCompilerSemanticTest`: This unit tests for semantic errors and semantic
    model APIs.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpCompilerSemanticTest`: 这项单元测试用于语义错误和语义模型 API。'
- en: '`CSharpCompilerSymbolTest`: This unit tests for symbols defined in the compiler
    layer.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpCompilerSymbolTest`: 这项单元测试用于编译器层定义的符号。'
- en: '`CSharpCommandLineTest`: This unit tests for the compiler''s command line options.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpCommandLineTest`: 这项单元测试用于检查编译器的命令行选项。'
- en: '`CSharpCompilerEmitTest`: This unit tests for the code generation phase that
    verifies the generated MSIL.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpCompilerEmitTest`: 这项单元测试用于代码生成阶段，该阶段验证生成的 MSIL。'
- en: In this section, we will add unit tests to `CSharpCompilerSyntaxTest`**,** `CSharpCompilerSemanticTest`
    and `CSharpCompilerEmitTest` for parsing, binding, and codegen support, respectively.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为 `CSharpCompilerSyntaxTest`、`CSharpCompilerSemanticTest` 和 `CSharpCompilerEmitTest`
    分别添加单元测试，用于解析、绑定和代码生成支持。
- en: Getting Started
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: You need to ensure that you have enlisted and built Roslyn sources with *VS2017*
    tag on your machine. For further guidance, refer to the recipe, *Setting up Roslyn
    enlistment* in [Chapter 8](a7277d51-330b-45f3-aa10-5a9453afe569.xhtml), *Contribute
    Simple Functionality to Roslyn C# Compiler Open Source Code*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保在你的机器上已经列出了带有 *VS2017* 标签的 Roslyn 源代码，并已构建。有关进一步指导，请参阅第 8 章，*设置 Roslyn
    列表*，中的配方。
- en: 'Additionally, the following four git commits on your enlistment to get the
    syntax definitions, parser support, binder support, and lowering support for the
    new operator and build `CSharpCodeAnalysis` project:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在你的列表中还需要以下四个 git 提交以获取新操作符的语法定义、解析器支持、绑定器支持和降低支持，并构建 `CSharpCodeAnalysis`
    项目：
- en: '[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5](https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5)'
- en: '[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569](https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569)'
- en: '[https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236](https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236](https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236)'
- en: '[https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da](https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da](https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da)'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open `Roslyn.sln` in Visual Studio 2017.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2017中打开`Roslyn.sln`。
- en: Open source file `<%REPO_ROOT%>\src\Compilers\CSharp\Test\Syntax\Parsing\ExpressionParsingTests.cs`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件`<%REPO_ROOT%>\src\Compilers\CSharp\Test\Syntax\Parsing\ExpressionParsingTests.cs`。
- en: '[Parsing Test] Add the following new unit test at the end of the source file:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[解析测试] 在源文件末尾添加以下新的单元测试：'
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Build the test project `CSharpCompilerSyntaxTest` and execute the unit test
    on a command-line console using the command line copied from the project''s `Debug`
    property page and appending `-method` switch for the newly added unit test:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建测试项目`CSharpCompilerSyntaxTest`，并在命令行控制台使用从项目的`Debug`属性页复制的命令行执行单元测试，并为新添加的单元测试添加`-method`开关：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Verify the unit test passes successfully:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证单元测试成功通过：
- en: '![](img/322e1701-d411-41a3-9893-3ec9bc11616c.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/322e1701-d411-41a3-9893-3ec9bc11616c.png)'
- en: 'If you get a `DirectoryNotFoundException`, ensure that the test results directory
    exists on the machine: `<%REPO_ROOT%>\Binaries\Debug\UnitTests\CSharpCompilerSyntaxTest\xUnitResults`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到`DirectoryNotFoundException`，请确保测试结果目录存在于机器上：`<%REPO_ROOT%>\Binaries\Debug\UnitTests\CSharpCompilerSyntaxTest\xUnitResults`。
- en: '[Binding Test] Open source file `<%REPO_ROOT%>\src\Compilers\CSharp\Test\Semantic\Semantics\BindingTests.cs`'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[绑定测试] 打开源文件`<%REPO_ROOT%>\src\Compilers\CSharp\Test\Semantic\Semantics\BindingTests.cs`'
- en: 'Add the following new unit test to the source file:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下新的单元测试添加到源文件中：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Build the test project `CSharpCompilerSemanticTest` and execute the unit test
    on a command line console by using the command line copied from the project''s
    `Debug` property page and appending `-method` switch for the newly added unit
    test:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建测试项目`CSharpCompilerSemanticTest`，并在命令行控制台使用从项目的`Debug`属性页复制的命令行执行单元测试，并为新添加的单元测试添加`-method`开关：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Verify the unit test passes successfully.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证单元测试成功通过。
- en: '[CodeGen Test] Open source file `<%REPO_ROOT%>\src\Compilers\CSharp\Test\Emit\CodeGen\CodeGenTests.cs`.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[代码生成测试] 打开源文件`<%REPO_ROOT%>\src\Compilers\CSharp\Test\Emit\CodeGen\CodeGenTests.cs`。'
- en: 'Add the following new unit test to the source file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下新的单元测试添加到源文件中：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Build the test project `CSharpCompilerEmitTest` and execute the unit test on
    a command-line console by using the command line copied from the project''s `Debug`
    property page and appending `-method` switch for the newly added unit test:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建测试项目`CSharpCompilerEmitTest`，并在命令行控制台使用从项目的`Debug`属性页复制的命令行执行单元测试，并为新添加的单元测试添加`-method`开关：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Verify the unit test passes successfully.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证单元测试成功通过。
- en: You can also execute the unit tests inside Visual Studio using the Test Explorer
    window, but the test discovery for *Roslyn.sln* is quite slow due to thousands
    of unit tests across the solution. Hence, you might have to wait for a few minutes
    before you can execute the first unit test.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Visual Studio中的测试资源管理器窗口执行单元测试，但由于解决方案中包含数千个单元测试，因此对`*Roslyn.sln*`的测试发现相当慢。因此，您可能需要等待几分钟才能执行第一个单元测试。
- en: You can view all the source changes made in this recipe at [https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f](https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f](https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f)查看此配方中做出的所有源代码更改。
