- en: 17 Getting Started with Vertical Slice Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file111.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces Vertical Slice Architecture, an effective way to organize
    our ASP.NET Core applications. Vertical Slice Architecture moves elements from
    multiple layers to a feature-oriented design, helping us maintain a clean, simple,
    cohesive, loosely-coupled, and manageable codebase.Vertical Slice Architecture
    flips our architectural perspective toward simplified architecture. Historically,
    we divided the logic of a feature across various layers like UI, business logic,
    and data access. However, we create independent slices of functionality with Vertical
    Slice Architecture instead. Think of your application as a cake; instead of cutting
    it horizontally (layers), we're cutting vertically (features), with each slice
    being fully functional on its own.This style changes how we design and organize
    our project, testing strategies, and coding approach. We don't have to worry about
    bloated controllers or overly complicated "God objects"; instead, making changes
    becomes more manageable because of the loose coupling between features.This chapter
    guides you through applying Vertical Slice Architecture to your ASP.NET Core applications,
    detailing how to handle commands, queries, validation, and entity mapping using
    CQS, MVC, MediatR, AutoMapper, and FluentValidation, which we explored in the
    previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have to use those tools to apply the architectural style and can replace
    those libraries with others or even code the whole stack ourselves.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will understand Vertical Slice Architecture
    and its benefits, and should have the confidence to apply this style to your next
    project. In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Anti-pattern – Big Ball of Mud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical Slice Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuing your journey: A few tips and tricks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's journey through the vertical slices and piece the architecture together,
    one slice at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-pattern – Big Ball of Mud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with an anti-pattern. The **Big Ball of Mud** anti-pattern describes
    a system that ended badly or was never properly designed. Sometimes a system starts
    great but evolves into a Big Ball of Mud due to pressure, volatile requirements,
    impossible deadlines, bad practices, or other reasons. We often refer to the Big
    Ball of Mud as **spaghetti code**, which means the same thing.This anti-pattern
    means a very hard-to-maintain codebase, poorly written code that is difficult
    to read, lots of unwanted tight coupling, low cohesion, or worse: all that in
    the same codebase.Applying the techniques covered in this book should help you
    avoid this anti-pattern. Aim at small, well-designed components that are testable.
    Enforce that using automated testing. Refactor and improve your codebase whenever
    you can, iteratively (continuous improvement). Apply the SOLID principles. Define
    your application pattern before starting. Think of the best way to implement each
    component and feature; do research, and make one or more proof of concept or experiments
    if unsure of the best approach. Ensure you understand the business requirements
    of the program you are building (this is probably the best advice). Those tips
    should help you avoid creating a Big Ball of Mud.Building feature-oriented applications
    is one of the best ways to avoid creating a Big Ball of Mud. Let’s get started!'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical Slice Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of separating an application horizontally (layers), a vertical slice
    groups all horizontal concerns together to encapsulate a feature. Here is a diagram
    that illustrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1: Diagram representing a vertical slice crossing all layers](img/file112.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: Diagram representing a vertical slice crossing all layers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jimmy Bogard, who is a pioneer of this type of architecture, wrote the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[The goal is to] minimize coupling between slices and maximize coupling within
    a slice.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What does that mean? Let’s split that sentence into two distinct points:'
  prefs: []
  type: TYPE_NORMAL
- en: “minimize coupling between slices” (improved maintainability, loose coupling)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “maximize coupling within a slice” (cohesion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could see the former as one vertical slice should not depend on another,
    so when you modify a vertical slice, you don’t have to worry about the impact
    on the other slices because the coupling is minimal.We could see the latter as:
    instead of spreading code around multiple layers, with potentially superfluous
    abstractions along the way, let’s regroup and simplify that code. That helps keep
    the tight coupling inside a vertical slice to create a cohesive unit of code that
    serves a single purpose: handling the feature end to end.Then we could wrap that
    to create software around the business problem we are trying to solve instead
    of the developer’s concerns, which your customers have no interest in (such as
    data access).Now, what is a slice in more generic terms? I see slices as composite
    hierarchies. For example, a shipping manager program has a multistep creation
    workflow, a list, and a details page. Each step of the creation flow would be
    a slice responsible for handling its respective logic. When put together, they
    compose the “create slice”, which is responsible for creating a shipment (a bigger
    slice). The list and details pages are two other slices. Then, all of those slices
    become another bigger slice, leading to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2: A diagram displaying a top-down coupling structure where smaller
    parts (top) depend on bigger parts (middle) of complex features (bottom) based
    on their cohesion with one another (vertically)](img/file113.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: A diagram displaying a top-down coupling structure where smaller
    parts (top) depend on bigger parts (middle) of complex features (bottom) based
    on their cohesion with one another (vertically)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is strong coupling inside **Step 1**, with limited coupling between the
    other steps; they share some creation code as part of the **Create** slice. **Create**,
    **List**, and **Details** also share some code, but in a limited way; they are
    all part of the **Shipments** slice and access or manipulate the same entity:
    one or more shipments. Finally, the **Shipments** slice shares no code (or very
    little) with **Other features**.'
  prefs: []
  type: TYPE_NORMAL
- en: Following the pattern I just described, we have limited coupling and maximum
    cohesion. The downside is that you must continuously design and refactor the application,
    which requires stronger design skills than a layered approach. Moreover, you must
    know how to build the feature end to end, limiting the division of tasks between
    people and centralizing them on each team member instead; each member becomes
    a full-stack developer. We revisit this example in the *Continuing your journey*
    section near the end of the chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We explore the advantages and disadvantages next.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages and disadvantages?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore some advantages and disadvantages of Vertical Slice Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On the upside, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We reduce coupling between features, making working on such a project more manageable.
    We only need to think about a single vertical slice, not *N* layers, improving
    **maintainability** by centralizing the code around a shared concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can choose how each vertical slice interacts with the external resources
    they require without considering the other slices. That adds **flexibility** since
    one slice can use T-SQL while another uses EF Core, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can start small with a few lines of code (described as **Transaction Scripts**
    in *Patterns of Enterprise Application Architecture,* by Martin Fowler) without
    extravagant design or over-engineering. Then we can refactor our way to a better
    design when the need arises and patterns emerge, leading to a **faster time to
    market**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each vertical slice should contain precisely the right amount of code needed
    to be correct—not more, not less. That leads to a **more robust** codebase (less
    code means less extraneous code and less code to maintain).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier for newcomers to find their way around an existing system since
    each feature is near-independent, leading to a **faster onboarding time**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All patterns and techniques you learned in previous chapters still apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From my experience, features tend to start small and grow over time. The users
    often find out what they need while using the software, changing the requirements
    over time, which leads to changes in the software. After the fact, I wish many
    projects I worked on were built using Vertical Slice Architecture instead of layering.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, nothing is perfect, so here are some downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: It may take time to wrap your head around Vertical Slice Architecture if you’re
    used to layering, leading to an adaptation period to learn a new way to think
    about your software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a “newer” type of architecture, and people don’t like change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another thing that I learned the hard way is to embrace change. I don’t think
    I’ve seen one project end as it was supposed to. Everyone identifies the missing
    pieces of the business processes while using the software. That leads to the following
    advice: release the software as fast as possible and have your customers use the
    software as soon as possible. That advice can be easier to achieve with Vertical
    Slice Architecture because you build value for your customers instead of more
    or less valuable abstractions and layers. Having a customer try staged software
    is very hard; no customer has time to do such a thing; they are busy running their
    business. However, releasing production-ready slices may lead to faster adoption
    and feedback.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the beginning of my career, I was frustrated when specifications changed,
    and I thought that better planning would have fixed that. Sometimes better planning
    would have helped, but sometimes, the customer just did not know how to express
    their business processes or needs and had to try the application to figure it
    out. My advice here is don’t be frustrated when the specs change, even if that
    means rewriting a part of the software that took you days or more to code in the
    first place; that will happen all the time. Learn to accept that instead, and
    find ways to make this process easier and faster. If you are in contact with the
    customers, find ways to help them figure out their needs and reduce the number
    of changes.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Downside or Upsides?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following points are downsides that we can tame as upsides:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are used to working in silos (such as the DBAs doing the data stuff).
    In that case, assigning tasks that touch the whole feature may be more challenging,
    but this can become an advantage since everyone in your team works more closely
    together, leading to more learning and collaboration and possibly a new cross-functional
    team—which is excellent. Having a data expert on the team is great; no one is
    an expert in all areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refactoring: strong refactoring skills will go a long way. Over time, most
    systems need some refactoring, which is even more true for Vertical Slice Architecture.
    That can be caused by changes in the requirements or due to technical debt. No
    matter the reason, you may end up with a **Big Ball of Mud** if you don''t. First,
    writing isolated code and then refactoring to patterns is a crucial part of Vertical
    Slice Architecture. That’s one of the best ways to keep cohesion high inside a
    slice and coupling as low as possible between slices. This tip applies to all
    types of architecture and is made easier with a robust test suite that validates
    your changes automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to start refactoring that business logic would be to push the logic into
    the **domain model**, creating a **rich domain model**. You can also use other
    design patterns and techniques to fine-tune the code and make it more maintainable,
    such as creating services or layers. A layer does not have to cross all vertical
    slices; it can cross only a subset of them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compared to other application-level patterns, such as layering, fewer rules
    lead to more choices (Vertical Slice Architecture). *You can use all design patterns,
    principles, and best practices inside a vertical slice without exporting those
    choices application-wide.*
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you organize a project into Vertical Slice Architecture? Unfortunately,
    there is no definitive answer to that, and it depends on the engineers working
    on the project. We explore one way in the next project, but you can organize your
    project as you see fit. Then we dig deeper into refactoring and organization.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Vertical Slice Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Context**: We are getting tired of layering, and we got asked to rebuild
    our small demo shop using Vertical Slice Architecture.Here is an updated diagram
    that shows how we conceptually organized the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3: Diagram representing the organization of the demo shop project](img/file114.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Diagram representing the organization of the demo shop project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each vertical box is a use case (or slice), while each horizontal box is a
    crosscutting concern or a shared component. This is a small project, so we share
    the data access code (`DbContext`) and the `Product` model between the three use
    cases. This sharing is unrelated to Vertical Slice Architecture, but splitting
    it more in a small project like this is hard and pointless.In this project, I
    decided to go with web API controllers instead of minimal APIs and an anemic product
    model instead of a rich one. We could have used minimal APIs, a rich model, or
    any combination. I chose this so you have a glimpse of using controllers, as this
    is something you might very well end up using. We go back to minimal APIs in the
    next chapter.Here are the actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductsController` is the REST API to manage products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StocksController` is the REST API to manage the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddStocks`, `RemoveStocks`, and `ListAllProducts` are the same use cases we
    have copied in our project since *Chapter 14*, *Layering and Clean Architecture*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The persistence “layer” consists of an EF Core `DbContext` that persists the
    `Product` model to an in-memory database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could add other crosscutting concerns on top of our vertical slices, such
    as authorization, error management, and logging, to name a few.Next, let’s look
    at how we organized the project.
  prefs: []
  type: TYPE_NORMAL
- en: Project organization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is how we organized the project:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Data` directory contains EF Core-related classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Features` directory contains the features. Each subfolder contains its
    underlying features (vertical slices), including controllers, exceptions, and
    other support classes required to implement the feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each use case is self-contained and exposes the following classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command` or `Query` representing the MediatR request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Result` is the return value of that request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MapperProfile` instructs AutoMapper on how to map the use case-related objects
    (if any).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Validator` contains the validation rules to validate the `Command` or `Query`
    objects (if any).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Handler` contains the use case logic: how to handle the request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Models` directory contains the domain model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 17.4: Solution Explorer view of the file organization](img/file115.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Solution Explorer view of the file organization'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we support request validation using **FluentValidation**, a
    third-party NuGet package. We can also use `System.ComponentModel.DataAnnotations`
    or any other validation library that we want.
  prefs: []
  type: TYPE_NORMAL
- en: With FluentValidation, I find it easy to keep the validation within our vertical
    slice but outside the class we want to validate. The out-of-the-box .NET validation
    framework, `DataAnnotations`, does the opposite, forcing us to include the validation
    as metadata on the entities themselves. Both have pros and cons, but FluentValidation
    is easier to test and extend.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code is the `Program.cs` file. The highlighted lines represent
    registering FluentValidation and scanning the assembly to find validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds the bindings we explored in previous chapters, FluentValidation,
    and the other pieces required to run the application. The highlighted lines register
    FluentValidation and scan the `currentAssembly` for validator classes. The validators
    themselves are part of each vertical slice. Now that we covered the organization
    of the project, let’s look at features.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the RemoveStock feature
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this subsection, we explore the `RemoveStocks` feature with the same logic
    as in previous samples but organized differently (a.k.a. the difference between
    architectural styles). Since we use an anemic product model, we moved the add
    and remove stocks logic from the `Product` class to the `Handler` class. Let’s
    look at the code next. I describe each nested class along the way.The sample starts
    with the `RemoveStocks` class that contains the feature’s nested classes. That
    helps organize the feature and saves us some headaches about naming collision.
  prefs: []
  type: TYPE_NORMAL
- en: We could use namespaces instead, but tools like Visual Studio recommend adding
    a `using` statement and removing the inline namespace. Nowadays, it often automatically
    adds the using statement, like when pasting code, which is great for many scenarios
    but inconvenient for this specific one. So using nested classes fixes this.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is the `RemoveStocks` class skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code showcases that the `RemoveStocks` class contains all the
    required elements it needs for its specific use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Command` is the input DTO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Result` is the output DTO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapperProfile` is the AutoMapper profile that maps feature-specific classes
    to non-feature-specific classes and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Validator` validates the input before an instance hits the `Handler` class
    (the `Command` class).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Handler` encapsulates the use case logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we explore those nested classes, starting with the `Command` class, which
    is the **input of the use case** (the request):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding request contains everything it needs to remove stocks from the
    inventory and fulfill the operation. The `IRequest<TResult>` interface tells MediatR
    that the `Command` class is a request and should be routed to its handler. The
    `Result` class is the return value of that handler and represents the **output
    of the use case**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapper profile is optional and allows encapsulating AutoMapper *maps* related
    to the use case. The following `MapperProfile` class registers the mapping from
    a `Product` instance to a `Result` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validator` class is also optional and allows validating the input (`Command`)
    before it hits the handler; in this case, it ensures the `Amount` value is greater
    than zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the most important piece is the `Handler` class, which implements
    the use case logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Handler` class implements the `IRequestHandler<Command, Result>` interface,
    which links the `Command`, the `Handler`, and the `Result` classes. The `Handle`
    method implements the same logic as the previous implementations from *Chapter
    14*, *Layering* *and Clean Architecture*, onward.Now that we have a fully functional
    use case, let’s look at the skeleton of the `StocksController` class that translates
    the HTTP requests to the MediatR pipeline so our use case gets executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the controller, we inject an `IMediator` into the constructor. We used constructor
    injection because all actions of this controller use the `IMediator` interface.
    We have two actions, add and remove stocks.The following code represents the remove
    stocks action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we read the content of the `RemoveStocks.Command` instance
    from the body, the action sets the `ProductId` property from the route value,
    and it sends the `command` object into the MediatR pipeline. From there, MediatR
    routes the request to its handler before returning the result of that operation
    with an HTTP `200 OK` status code. One of the differences between the preceding
    code and previous implementations is that we moved the DTOs to the vertical slice
    itself. Each vertical slice defines the input, the logic, and the output of its
    feature, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5: Diagram representing the three primary pieces of a vertical
    slice](img/file116.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Diagram representing the three primary pieces of a vertical slice'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add input validation, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6: Diagram representing the three primary pieces of a vertical
    slice, with added validation](img/file117.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Diagram representing the three primary pieces of a vertical slice,
    with added validation'
  prefs: []
  type: TYPE_NORMAL
- en: The controller is a tiny layer between HTTP and our domain, guiding the HTTP
    requests to the MediatR pipeline and the responses back to HTTP. That thin piece
    represents the presentation of the API and allows access to the domain logic;
    the features. When controllers grow, it is often a sign that part of the feature
    logic is in the wrong place, most likely leading to code that is harder to test
    because the HTTP and other logic become intertwined.
  prefs: []
  type: TYPE_NORMAL
- en: We still have the extra line for the `productId` and `try/catch` blocks in the
    controller’s code, but we could eliminate these using custom model binders and
    exception filters. I left additional resources at the end of the chapter, and
    we dig deeper into this in the next chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With that in place, it is now straightforward to add new features to the project.
    Visually, we end up with the following vertical slices (bold), possible vertical
    expansions (normal), and shared classes (italics):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7: Diagram representing the project and possible extensions related
    to product management](img/file118.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Diagram representing the project and possible extensions related
    to product management'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows the grouping of the two main areas, products, and stocks.
    On the products side, I included an expansion that depicts a CRUD-like feature
    group.In our tiny application, it is tough to divide the data access part into
    more than one `DbContext`, so `ProductContext` is used by all slices, creating
    a shared data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, create multiple `DbContext` when possible. This has nothing
    to do with Vertical Slice Archvaliitecture but is a good practice to divide your
    domain into smaller bounded contexts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about grouping features when they are cohesive and fit under the same
    part of the domain.Next, let’s test our application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this project, I wrote one integration test per use case outcome, which
    lowers the number of unit tests required while increasing the level of confidence
    in the system at the same time. Why? Because we are testing the features themselves
    instead of many abstracted parts independently. This is grey-box testing.We can
    also add as many unit tests as we need. This approach helps us write fewer but
    better feature-oriented tests, diminishing the need for mock-heavy unit tests.
    Unit tests are practical for validating complex use cases and algorithms faster
    than integration tests.Let’s look at the `StocksTest` class skeleton first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SeedAsync` method removes all products and inserts two new ones in the
    in-memory test database so the test methods can run using a predictable data set.
    The `AddStocksTest` and `RemoveStocksTest` classes contain the test methods for
    their respective use case. `StocksControllerTest` tests the MVC part. Let’s explore
    the happy path of the `AddStocksTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the *Arrange* section of the preceding test case, we create an instance of
    the application, create a scope to simulate an HTTP request, access the EF Core
    `DbContext`, and then get an `IMediator` instance to act on.In the *Act* block,
    we send a valid `AddStocks.Command` through the MediatR pipeline.We create a new
    scope in the *Assert* block then and get a `ProductContext` out of the container.
    With that `DbContext`, we find the product, ensure it’s not null, and validate
    that the quantity in stock is what we expect. Using a new `ProductContext` ensures
    we are not dealing with any cached items from the previous operations and the
    transaction has been saved as expected.With that test case, we know that if a
    valid command is issued to the mediator, that handler gets executed and successfully
    increments the stock property by the specified amount.
  prefs: []
  type: TYPE_NORMAL
- en: The `VerticalAppApplication` class inherits from `WebApplicationFactory<TEntryPoint>`,
    creates a new `DbContextOptionsBuilder<ProductContext>` instance that has a configurable
    database name, implements a `SeedAsync` method that allows seeding the database,
    and allows altering the application services. I omitted the code for brevity reasons,
    but you can consult the complete source code in the GitHub repository ([https://adpg.link/mWep](https://adpg.link/mWep)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, we can test the MVC part to ensure the controller is configured correctly.
    In the `StocksControllerTest` class, the `AddAsync` class contains the following
    test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code of the preceding test case *Arrange* block mocks the `IMediator`
    and saves what is passed to the `Send` method in the `addStocksCommand` variable.
    We are using that value in the highlighted code of the *Assert* block. When creating
    the `VerticalAppApplication` instance, we register the mock with the container
    to use it instead of the MediatR one, which bypasses the default behavior. We
    then create an `HttpClient` connected to our in-process application and craft
    a valid HTTP request to add the stocks we POST in the *Act* section.The *Assert*
    block code ensures the request was successful, verifies the mock method was hit
    once, and ensures `AddStocks.Command` was configured correctly.From the first
    test, we know the MediatR piece works. With this second test in place, we know
    the HTTP piece works. We are now almost certain that a valid add stocks request
    will hit the database with those two tests.
  prefs: []
  type: TYPE_NORMAL
- en: I say “almost certain” because our tests run against an in-memory database,
    which is different from a real database engine (for example, it has no relational
    integrity and the like). In case of more complex database operations that affect
    more than one table or to ensure the correctness of the feature, you can run the
    tests against a database closer to the production database. For example, we can
    run the tests against a SQL Server container to spawn and tear down the databases
    in our CI/CD pipeline easily.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the test project, I added more tests covering the remove stocks and listing
    all products’ features, and ensuring AutoMapper configuration correctness. Feel
    free to browse the code. I omitted them here as they become redundant. The objective
    is to explore testing a feature almost end to end with very few tests (two for
    the happy path in this case), and I think we covered that.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The vertical slice project shows how we can remove abstractions while keeping
    the objects loosely coupled. We also organized the project into features (verticals)
    instead of layers (horizontals). We leveraged CQS, Mediator, and MVC patterns.
    Conceptually, the layers are still there; for example, the controllers are part
    of the presentation layer, but they are not organized that way, making them part
    of the feature. The sole dependency that crosses all our features is the `ProductContext`
    class, which makes sense since our model comprises a single class (`Product`).
    We could, for example, add a new feature that leverages minimal APIs instead of
    a controller, which would be okay because each slice is independent.We can significantly
    reduce the number of mocks required by testing each vertical slice with integration
    tests. That can also significantly lower the number of unit tests, testing features
    instead of mocked units of code. We should focus on producing features and business
    value, not the details behind querying the infrastructure or the code itself.
    We should not neglect the technical aspects either; performance and maintainability
    are also important characteristics, but reducing the number of abstractions can
    also make the application easier to maintain and for sure easier to understand.Overall,
    we explored a modern way to design an application that aligns well with Agile
    and helps generate value for our customers.Before moving to the summary, let’s
    see how Vertical Slice Architecture can help us follow the **SOLID** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Each vertical slice (feature) becomes a cohesive unit that changes as
    a whole, leading to the segregation of responsibilities per feature. Based on
    a CQS-inspired approach, each feature splits the application’s complexity into
    commands and queries, leading to multiple small pieces. Each piece handles a part
    of the process. For example, we can define an input, a validator, a mapper profile,
    a handler, a result, an HTTP bridge (controller or endpoint), and as many more
    pieces as we need to craft the slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: We can enhance the system globally by extending the ASP.NET Core, MVC,
    or MediatR pipelines. We can design the features as we see fit, including respecting
    the OCP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: By organizing features by units of domain-centric use cases, we create
    many client-specific components instead of general-purpose elements, like layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: The slice pieces depend on interfaces and are tied together using dependency
    injection. Furthermore, by cutting the less useful abstractions out of the system,
    we simplify it, making it more maintainable and concise. Having that many pieces
    of a feature living close to each other makes the system easier to maintain and
    improves its discoverability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we look at a few tricks and processes to get started with a bigger application.
    These are ways that I found work for me and will hopefully work for you too. Take
    what works for you and leave the rest; we are all different and work differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing your journey: A few tips and tricks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous project was tiny. It had a shared model that served as the data
    layer because it was composed of a single class. When building real-world applications,
    you have more than one class, so I’ll give you a good starting point to tackle
    bigger apps. The idea is to create slices as small as possible, limit interactions
    with other slices as much as possible, and refactor that code into better code.
    We cannot remove coupling, so we need to organize it instead, and the key is to
    centralize that coupling inside a feature.Here is a workflow inspired by TDD,
    yet less rigid:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the contracts that cover your feature (input and output).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write one or more integration tests covering your feature, using those contracts;
    the `Query` or `Command` class (`IRequest`) as input and the `Result` class as
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement your `Handler`, `Validator`, `MapperProfile`, and any other bit that
    needs to be coded. At this point, the code could be a giant `Handler`; it does
    not matter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your integration tests pass, refactor that code by breaking down your giant
    `Handle` method as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your tests still pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During *step 2*, you may also test the validation rules with unit tests. It
    is way easier and faster to test multiple combinations and scenarios from unit
    tests, and you don’t need to access a database for that. The same also applies
    to any other parts of your system that are not tied to an external resource.During
    *step 4*, you may find duplicated logic between features. If that’s the case,
    it is time to encapsulate that logic elsewhere, in a shared place. That could
    be creating a method in the model, a service class, or any other pattern and technique
    you know might solve your duplication of logic problem. Working from isolated
    features and extracting shared logic will help you design the application. You
    want to push that shared logic outside of a handler, not the other way around
    (well, once you have that shared logic, you can use it as needed). Here, I want
    to emphasize *shared logic*, which means a business rule. When a business rule
    changes, all consumers of that business rule must also change their behavior.
    Avoid sharing *similar code* but do share business rules. Remember the DRY principle.What
    is very important when designing software is to focus on the functional needs,
    not the technical ones. Your customers and users don’t care about the technical
    stuff; they want results, new features, bug fixes, and improvements. Simultaneously,
    beware of the technical debt, so don’t skip the refactoring step, or your project
    may get in trouble. This advice applies to all types of architecture.Another advice
    is to keep all the code that makes a vertical slice as close as possible. You
    don’t have to keep all use case classes in a single file, but I find this helps.
    Partial classes are a way to split classes into multiple files. If named correctly,
    Visual Studio will nest them under the primary file. For example, Visual Studio
    will nest the `MyFeature.Hander.cs` file under the `MyFeature.cs` file, and so
    on.You can also create a folder hierarchy where the deeper levels share the previous
    levels. For example, the creation process of a workflow I implemented in an MVC
    application related to shipments had multiple steps. So I ended up with a hierarchy
    that looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.12: The organizational hierarchy of directories and elements](img/file119.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.12: The organizational hierarchy of directories and elements'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, I coded all the handlers individually. Then I saw patterns emerge,
    so I encapsulated that shared logic into shared classes. Then I reused some upper-level
    exceptions, so I moved those up from the `Features/Shipments/Create` folder to
    the `Features/Shipments` folder. I also extracted a service class to manage shared
    logic between multiple use cases. Ultimately, I have only the code I need, no
    duplicated logic, and the collaborators (classes, interfaces) are as close as
    possible. The coupling between features was minimal, while parts of the system
    work in synergy (cohesion). Moreover, there is very little to no coupling with
    other parts of the system. If we compare that result to another type of architecture,
    such as layering, I would most likely have needed more abstractions, such as repositories,
    services, and whatnot; the result with Vertical Slice Architecture was cleaner
    and simpler.The key point here is to code your handlers independently, organize
    them the best you can, keep an eye open for shared logic and emerging patterns,
    extract and encapsulate that logic, and try to limit interactions between use
    cases and slices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter overviewed Vertical Slice Architecture, which flips layers by 90°.
    Vertical Slice Architecture is about writing minimal code to generate maximum
    value by getting superfluous abstractions and rules out of the equation by relying
    on the developers’ skills and judgment instead.Refactoring is critical in a Vertical
    Slice Architecture project; success or failure will most likely depend on it.
    We can also use any patterns with Vertical Slice Architecture. It has lots of
    advantages over layering with only a few disadvantages. Teams who work in silos
    (horizontal teams) may need to rethink switching to Vertical Slice Architecture
    and first create or aim at creating multi-functional teams instead (vertical teams).We
    replaced the low-value abstraction with commands and queries (CQS-inspired). Those
    are then routed to their respective `Handler` using the Mediator pattern (helped
    by MediatR). That allows encapsulating the business logic and decoupling it from
    its callers. Those commands and queries ensure that each bit of domain logic is
    centralized in a single location.Of course, if you start with a strong analysis
    of your problem, you will most likely have a head start, like with any project.
    Nothing stops you from building and using a robust domain model in your slices.
    The more requirements you have, the easier the initial project organization will
    be. To reiterate, all engineering practices that you know still apply.The next
    chapter simplifies the concept of Vertical Slice Architecture even more by exploring
    the Request-EndPoint-Response (REPR) pattern using Minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What design patterns can we use in a vertical slice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using Vertical Slice Architecture, is it true that you must pick a single
    ORM and stick with it, such as a data layer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will likely happen if you don’t refactor your code and pay the technical
    debt in the long run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does cohesion mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does tight coupling mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few links to build upon what we learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For UI implementations, you can look at how Jimmy Bogard upgraded ContosoUniversity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ContosoUniversity on ASP.NET Core with .NET Core: [https://adpg.link/UXnr](https://adpg.link/UXnr)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ContosoUniversity on ASP.NET Core with .NET Core and Razor Pages: [https://adpg.link/6Lbo](https://adpg.link/6Lbo)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'FluentValidation: [https://adpg.link/xXgp](https://adpg.link/xXgp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AutoMapper: [https://adpg.link/5AUZ](https://adpg.link/5AUZ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MediatR: [https://adpg.link/ZQap](https://adpg.link/ZQap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any pattern and technique you know that can help you implement your feature.
    That’s the beauty of Vertical Slice Architecture; you are limited only by yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, you can pick the best tool for the job inside each vertical slice; you don’t
    even need layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application will most likely become a Big Ball of Mud and be very hard to
    maintain, which is not good for your stress level, the product quality, time to
    market of changes, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cohesion means elements that should work together as a united whole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tight coupling describes elements that cannot change independently; that directly
    depend on one another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
