<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-32" class="chapter-number"><a id="_idTextAnchor031"/>2</h1>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Minimal APIs – Creating REST Services</h1>
			<p>Since .NET 6, minimal APIs are the new way to create REST APIs. With later .NET versions, more and more enhancements have been made available, which makes them the preferred way to create REST services <span class="No-Break">with .NET.</span></p>
			<p>In this chapter, you’ll learn how to create a data representation of the game with model types, use these types in a service to implement the game functionality, create a minimal API project to create games, update games by setting game moves, and return information <span class="No-Break">about games.</span></p>
			<p>You’ll implement functionality to offer an OpenAPI description for developers accessing the service to get information about the service, and an easy way to create a <span class="No-Break">client application.</span></p>
			<p>In this chapter, you’ll be exploring <span class="No-Break">these topics:</span></p>
			<ul>
				<li>Creating models for <span class="No-Break">the game</span></li>
				<li>Implementing an in-memory <span class="No-Break">game repository</span></li>
				<li>Implementing the REST service of the game using <span class="No-Break">minimal APIs</span></li>
				<li>Using OpenAPI to describe <span class="No-Break">the service</span></li>
				<li>Testing the service using <span class="No-Break">HTTP files</span></li>
				<li>Enabling .<span class="No-Break">NET Aspire</span></li>
			</ul>
			<p>By the end of this chapter, you’ll have a running service implementing the Codebreaker Games API with an in-memory games store, accessible using <span class="No-Break">HTTP requests.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the following GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>. The <strong class="source-inline">ch02</strong> source code folder contains the code samples for this chapter. You’ll find the code for <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.GamesAPIs</strong> – The Web <span class="No-Break">API project</span></li>
				<li><strong class="source-inline">Codebreaker.GamesAPIs.Models</strong> – A library for the <span class="No-Break">data models</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs.Analyzers</strong> – A library containing game move analyzers for <span class="No-Break">the game</span></li>
				<li><strong class="source-inline">Codebreaker.GamesAPIs.Analyzers.Tests</strong> – Unit tests for the game <span class="No-Break">move analyzers</span></li>
				<li><strong class="source-inline">Codebreaker.AppHost</strong> – The host project for .<span class="No-Break">NET Aspire</span></li>
				<li><strong class="source-inline">Codebreaker.ServiceDefaults</strong> – A library used by the .NET <span class="No-Break">Aspire configuration</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You don’t implement the game move analyzers of the game in this chapter. The <strong class="source-inline">Analyzers</strong> project is just for reference purposes, but you can simply use a NuGet package for the analyzers (<strong class="source-inline">CNinnovation.Codebreaker.Analyzers</strong>) that has been made available for you to build <span class="No-Break">the service.</span></p>
			<p>For the installation of Visual Studio, Visual Studio Code, and .NET Aspire, check the README file for this chapter in <span class="No-Break">the repository.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>The game models</h1>
			<p>Before <a id="_idIndexMarker042"/>creating the REST API project, we start with a library that contains the models to represent the game along with a move of the game. This model will contain the main data part of the Codebreaker Game API service solution, which will be used to read and write to the database (in <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>), while the model also serves as an implementation of the main functionality of <span class="No-Break">the game.</span></p>
			<p>The <a id="_idIndexMarker043"/>major types in a simplified version are shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em>. The <strong class="source-inline">Game</strong> class implements the <strong class="source-inline">IGame</strong> interface. The <strong class="source-inline">IGame</strong> interface is used by the <strong class="source-inline">Analyzers</strong> package. A game contains a list of moves. A single game move is represented by the <span class="No-Break"><strong class="source-inline">Move</strong></span><span class="No-Break"> class.</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B21217_02_01.jpg" alt="Figure 2.1 – The game model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The game model</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Exploring the game analyzers library</h2>
			<p>As the<a id="_idIndexMarker044"/> focus of this book is not implementing the game rules with .NET, you can use the existing project, <strong class="source-inline">Codebreaker.GameAPIs.Analyzers</strong>, or just reference the NuGet package that has been made available on the NuGet server. This library contains game move analyzers for these <span class="No-Break">game types:</span></p>
			<ul>
				<li><strong class="source-inline">Game6x4</strong> – Six colors with four codes <span class="No-Break">to guess</span></li>
				<li><strong class="source-inline">Game8x5</strong> – Eight colors with <span class="No-Break">five codes</span></li>
				<li><strong class="source-inline">Game6x4Mini</strong> – Six colors with four codes with a <em class="italic">small </em><span class="No-Break"><em class="italic">children</em></span><span class="No-Break"> mode</span></li>
				<li><strong class="source-inline">Game5x5x4</strong> – Five colors and five shapes with <span class="No-Break">four codes</span></li>
			</ul>
			<p>The analyzers <a id="_idIndexMarker045"/>work using the generic <strong class="source-inline">IGame</strong> interface, which you need to implement with the game <span class="No-Break">models library.</span></p>
			<p>The <strong class="source-inline">IGame</strong> interface specifies some common functionalities for the <strong class="source-inline">Codebreaker</strong> games, as you can see in the following code snippet. Check the repository for the complete <span class="No-Break">interface definition:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers/Contracts/IGame.cs</p>
			<pre class="source-code">
namespace Codebreaker.GameAPIs.Contracts;
public interface IGame
{
  Guid Id { get; }
  string GameType { get; }
  int NumberCodes { get; }
  int MaxMoves { get; }
  DateTime StartTime { get; }
  // code removed for brevity
  IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; FieldValues { get; }
  string[] Codes { get; }
}</pre>
			<p>The <strong class="source-inline">IGame</strong> interface defines game members used by the analyzers, such as the number of codes that must be set and the maximum number of moves allowed, which are used by the analyzer to verify correct input data. The <strong class="source-inline">FieldValues</strong> property of the <strong class="source-inline">IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;</strong> type defines the possible values to select from. With the color game types, this will be a list of colors. With the shape game type, this will be a list of colors and a list of shapes. The <strong class="source-inline">Codes</strong> property contains an <a id="_idIndexMarker046"/>array of strings. How the string looks is different based on the game type. The string array contains the correct solution for a <span class="No-Break">game run.</span></p>
			<p>The <strong class="source-inline">analyzers</strong> library also contains record types that are supported by the analyzers implementation that you can use for the generic parameters of your <span class="No-Break">game types.</span></p>
			<p>One example of such a type used for the generic parameters <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">ColorField</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers/Fields/ColorField.cs</p>
			<pre class="source-code">
public partial record class ColorField(string Color)
{
  public override string ToString() =&gt; Color;
  public static implicit operator ColorField(string color) =&gt; 
    new(color);
}</pre>
			<p>The <strong class="source-inline">ColorField</strong> record class just contains a <strong class="source-inline">color</strong> string. This field type is used with all game types with the exception of the <strong class="source-inline">Game5x5x4</strong> game type, which uses the <span class="No-Break"><strong class="source-inline">ShapeAndColorField</strong></span><span class="No-Break"> record.</span></p>
			<p>To specify the results of a game move, three different types are available: <strong class="source-inline">ColorResult</strong>, <strong class="source-inline">SimpleColorResult</strong>, and <strong class="source-inline">ShapeAndColorResult</strong>. <strong class="source-inline">SimpleColorResult</strong> adds information for small children (which position has a correct color), whereas the <strong class="source-inline">ColorResult</strong> record struct just contains information on the number of colors placed in a correct hole, and the number of colors placed in an <span class="No-Break">incorrect hole.</span></p>
			<p>The following code snippet shows the <strong class="source-inline">ColorResult</strong> <span class="No-Break">record struct:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers/Results/ColorResult.cs</p>
			<pre class="source-code">
public readonly partial record struct ColorResult(int Correct, 
  int WrongPosition)
{
  private const char Separator = ':';
}</pre>
			<p>This<a id="_idIndexMarker047"/> record is implemented partially, separating parts of the implementation to simplify the source code. The other parts are defined in other source files and implement the <strong class="source-inline">IParsable</strong> and <strong class="source-inline">IFormattable</strong> interfaces. The <strong class="source-inline">const</strong> member called <strong class="source-inline">Separator</strong> is used with the other parts of the <span class="No-Break"><strong class="source-inline">ColorResult</strong></span><span class="No-Break"> type.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">ColorField</strong>, <strong class="source-inline">ColorResult</strong>, and the other classes representing a field and results are just used to analyze moves and return results. The <strong class="source-inline">Game</strong> and <strong class="source-inline">Move</strong> classes that you’ll implement in this chapter are just data holders and don’t contain any logic. The field guesses and results are all represented using strings, which makes them flexible for every game type available and easier to use with JSON serialization and database access. Converting the specific field and result types to and from strings is done using the <strong class="source-inline">IParsable</strong>, <strong class="source-inline">ISpanParsable</strong>, and <strong class="source-inline">IFormattable</strong> interfaces. The parsable interfaces are new since .NET 7 and are based on a C# 11 feature that allows static members with interfaces. These types are important in case you want to create your own game types and <span class="No-Break">game analyzers.</span></p>
			<p class="callout">You can read the article at <a href="https://csharp.christiannagel.com/2023/04/14/iparsable/">https://csharp.christiannagel.com/2023/04/14/iparsable/</a> for more information about <span class="No-Break">parsable interfaces.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Exploring game analyzers</h2>
			<p>The <a id="_idIndexMarker048"/>implementation of the game analyzers is done within the <strong class="source-inline">GameGuessAnalyzer</strong> base class and the <strong class="source-inline">ColorGameGuessAnalyzer</strong>, <strong class="source-inline">SimpleGameGuessAnalyzer</strong>, and <strong class="source-inline">ShapeGameGuessAnalyzer</strong> derived classes. The implementation of these analyzers is disconnected from the game model types. All these analyzers implement the <strong class="source-inline">GetResult</strong> method specified with the <strong class="source-inline">IGameGuessAnalyzer&lt;Tresult&gt;</strong> interface. After creating an instance of the analyzer passing the game, the guesses, and the move number, just the <strong class="source-inline">GetResult</strong> method needs to be invoked to calculate the result of <span class="No-Break">the move.</span></p>
			<p>If you are<a id="_idIndexMarker049"/> interested in checking the analyzers, dive into the <strong class="source-inline">Codebreaker.GameAPIs.Analyzers</strong> project within the book’s source code repository. Working through the following steps, instead of referencing this project, you can add the <strong class="source-inline">CNinnovation.Codebreaker.Analyzers</strong> NuGet package. Just make sure to use the latest 3.x version of this package, as 4.x and newer versions might contain <span class="No-Break">breaking changes.</span></p>
			<p>If you choose to, you can create an analyzer on your own and also add more game types. Make sure to read the information on the game rules in <a href="B21217_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Creating a .NET library</h2>
			<p>The <a id="_idIndexMarker050"/>model types are added to the <strong class="source-inline">Codebreaker.GameAPIs.Models</strong> .NET library. Having a library allows the creation of different data access libraries (in <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>) to offer a flexible data store choice for hosting <span class="No-Break">the service.</span></p>
			<p>You can use the .NET CLI as shown to create the class library, or use Visual Studio to create a <span class="No-Break">class library:</span></p>
			<pre class="console">
dotnet new classlib --framework net8.0 -o Codebreaker.GameAPIs.Models</pre>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Implementing classes for the model types</h2>
			<p>The <strong class="source-inline">Game</strong> class <a id="_idIndexMarker051"/>holding all the data needed by a game is shown here (check the GitHub repository for the <span class="No-Break">complete implementation):</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Game.cs</p>
			<pre class="source-code">
public class Game(
  Guid id,
  string gameType,
  string playerName,
  DateTime startTime,
  int numberCodes,
  int maxMoves) : IGame
{
  public Guid Id { get; } = id;
  public string GameType { get; } = gameType;
  public string PlayerName { get; } = playerName;
  public DateTime StartTime { get; } = startTime;
  // code removed for brevity
  public ICollection&lt;Move&gt; Moves { get; } = []
  public override string ToString() =&gt;   
    $"{Id}:{GameType} – {StartTime}";
}</pre>
			<p>This<a id="_idIndexMarker052"/> class implements the <strong class="source-inline">IGame</strong> interface to support the analyzer to check the correctness of a move and to set some game state. In addition to the members of the interface, the <strong class="source-inline">Game</strong> class also contains a collection of <strong class="source-inline">Move</strong> objects. Primary constructor syntax is used to reduce the number of needed <span class="No-Break">code lines.</span></p>
			<p class="callout-heading">Primary constructors</p>
			<p class="callout">Several classes created in this book make use of primary constructors. Primary constructors have been in use with records since C# 9. With C# 12, primary constructors can be used with normal classes and structs. However, while primary constructors with records create properties, with classes, these are just parameters. The parameters can be assigned to fields and properties, or just be used <span class="No-Break">within members.</span></p>
			<p>The <strong class="source-inline">Move</strong> class is simpler as it just represents the move of a player within a game along with <span class="No-Break">its result:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Move.cs</p>
			<pre class="source-code">
public class Move(Guid id, int moveNumber)
{
  public Guid Id { get; private set; } = id;
  public int MoveNumber { get; private set; } = moveNumber;
  public required string[] GuessPegs { get; init; }
  public required string[] KeyPegs { get; init; }
  public override string ToString() =&gt; 
    $"{MoveNumber}. {string. Join(':', GuessPegs)}";
}</pre>
			<p>The <strong class="source-inline">Move</strong> class <a id="_idIndexMarker053"/>contains string arrays for the guesses (<strong class="source-inline">GuessPegs</strong>) and the results (<strong class="source-inline">KeyPegs</strong>). String arrays can be used for every <span class="No-Break">game type.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Defining the game repository contract</h2>
			<p>To be <a id="_idIndexMarker054"/>independent of the data store, the <strong class="source-inline">IGamesRepository</strong> interface defines all the members needed from a data store when playing a game. The <strong class="source-inline">AddGameAsync</strong> method is invoked when a new game is started. Setting a move, the game needs to be updated invoking the <strong class="source-inline">UpdateGameAsync</strong> method. The <strong class="source-inline">GetGameAsync</strong> and <strong class="source-inline">GetGamesAsync</strong> methods are specified by the interface to <span class="No-Break">retrieve games:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Models/Data/IGamesRepository.cs</p>
			<pre class="source-code">
public interface IGamesRepository
{
  Task AddGameAsync(Game game, 
        CancellationToken cancellationToken = default);
     Task AddMoveAsync(Game game, Move move, 
       CancellationToken cancellationToken = default);
     Task&lt;bool&gt; DeleteGameAsync(Guid id, 
       CancellationToken cancellationToken = default);
     Task&lt;Game?&gt; GetGameAsync(Guid id, 
       CancellationToken cancellationToken = default);
     Task&lt;IEnumerable&lt;Game&gt;&gt; GetGamesAsync(GamesQuery gamesQuery, 
       CancellationToken cancellationToken = default);
     Task&lt;Game&gt; UpdateGameAsync(Game game, 
       CancellationToken cancellationToken = default);
}</pre>
			<p>This <a id="_idIndexMarker055"/>interface specifies asynchronous methods. This wouldn’t be required with the implementation in this chapter. The next chapter will add asynchronous implementations, thus the contract should be ready <span class="No-Break">for this.</span></p>
			<p>Specifying asynchronous methods, it’s a good practice to allow passing a <strong class="source-inline">CancellationToken</strong>. This allows canceling long-running operations even across <span class="No-Break">network boundaries.</span></p>
			<p>The <strong class="source-inline">IGamesRepository</strong> interface is specified in the <strong class="source-inline">Codebreaker.GameAPIs.Models</strong> library. This makes it possible to reference this interface from all the data store libraries that will be implemented later on. In this chapter, just an in-memory collection will be implemented as part of the <span class="No-Break">next step.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>The minimal APIs project</h1>
			<p>After having<a id="_idIndexMarker056"/> the models and the repository contract in place, we can move over to creating the project hosting the <span class="No-Break">REST API.</span></p>
			<p>Here, we’ll use ASP.NET Core with minimal APIs to create a REST API, and store games and moves in an in-memory repository. To create the running games API, we need to do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create a Web <span class="No-Break">API project.</span></li>
				<li>Implement the <span class="No-Break">games repository.</span></li>
				<li>Create a <span class="No-Break">games factory.</span></li>
				<li>Create data <span class="No-Break">transfer objects.</span></li>
				<li>Create endpoints to run the game via <span class="No-Break">HTTP requests.</span></li>
				<li>Configure the <span class="No-Break">JSON serializer.</span></li>
				<li>Add <span class="No-Break">endpoint filters.</span></li>
			</ol>
			<p>To better<a id="_idIndexMarker057"/> understand how the different classes interact in creating the game and setting a move, the flow of the functionality we need to implement is shown in the next <span class="No-Break">two figures.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em> shows the sequence when a new game is created.  On invoking the API call, <strong class="source-inline">GamesService</strong> is invoked to start the game. This service class uses <strong class="source-inline">GamesFactory</strong> to create a new game based on the parameters received and returns random code values. For persistence, <strong class="source-inline">GameMemoryRepository</strong> is invoked from <strong class="source-inline">GamesService</strong> to add the game before the game <span class="No-Break">is returned.</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B21217_02_02.jpg" alt="Figure 2.2 – Creating a game"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Creating a game</p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.3</em> shows the sequence when a game move is set. Because the client does not have the complete state of the game, <strong class="source-inline">GamesService</strong> retrieves the game from the repository. Then, <strong class="source-inline">GamesFactory</strong> is used again to select an analyzer based on the game type, and the analyzer is invoked to find the results of the game move. After the results are available with <strong class="source-inline">GamesService</strong>, the game is updated with the new move, and the results are<a id="_idIndexMarker058"/> returned to the <span class="No-Break">game endpoint.</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B21217_02_03.jpg" alt="Figure 2.3 – Setting a game move"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Setting a game move</p>
			<p>Let’s implement this functionality with <span class="No-Break">the API.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Creating the Web API project</h2>
			<p>To <a id="_idIndexMarker059"/>create the Web API project, you can use the .NET CLI as shown or use the Web API project template from <span class="No-Break">Visual Studio:</span></p>
			<pre class="console">
dotnet new webapi --use-minimal-apis --framework net8.0 -o Codebreaker.GameAPIs</pre>
			<p>The <strong class="source-inline">--</strong><strong class="source-inline">use-minimal-apis</strong> option is used to create minimal APIs instead of the traditional controllers. Because the API will be hosted behind an Ingress server, the Ingress server will offer HTTPS, while HTTP is okay in the backend. To allow but not require HTTPS remove the codeline <strong class="source-inline">app.UseHttpsRedirection();</strong> from <span class="No-Break">the code.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Exploring WebApplicationBuilder and WebApplication</h2>
			<p>With the created project, <strong class="source-inline">Program.cs</strong> is created and contains the configuration for the dependency injection container with the <strong class="source-inline">WebApplicationBuilder</strong> class and the configuration of middleware with the <strong class="source-inline">WebApplication</strong> class. The project template creates a random weather service. However, as weather information is not needed with the games service, some of the created code can <span class="No-Break">be removed.</span></p>
			<p>The part of the code that remains is shown in the next <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
  app.UseSwagger();
  app.UseSwaggerUI();
}
app.Run();</pre>
			<p><strong class="source-inline">WebApplication.CreateBuilder</strong> returns <strong class="source-inline">WebApplicationBuilder</strong> and configures the dependency injection container, the default configuration, and default logging. The <strong class="source-inline">AddEndpointsApiExplorer</strong> and <strong class="source-inline">AddSwaggerGen</strong> methods add services to the dependency injection container. The services registered by these two methods are needed for the <strong class="source-inline">OpenAPI</strong> description of <span class="No-Break">the services.</span></p>
			<p>Invoking the <strong class="source-inline">Build</strong> method returns a <strong class="source-inline">WebApplication</strong> instance. This instance is then used to configure the middleware. Middleware is invoked with every request to the service. The <strong class="source-inline">UseSwagger</strong> method registers the Swagger middleware to create an <strong class="source-inline">OpenAPI</strong> description of the service. The <strong class="source-inline">UseSwaggerUI</strong> method registers the <strong class="source-inline">SwaggerUI</strong> middleware to show a web page where the API is described and can be tested. As an API is not yet implemented, a description will not be <span class="No-Break">generated yet.</span></p>
			<p class="callout-heading">What is the relationship between Swagger and OpenAPI?</p>
			<p class="callout">The Swagger specification was created to describe HTTP APIs. In 2015, SmartBear Software acquired the Swagger API specification and started to form a new organization in 2016 together with<a id="_idIndexMarker060"/> Google, IBM, Microsoft, PayPal, and others under the sponsorship of the Linux Foundation – the <strong class="bold">OpenAPI Initiative</strong>. New versions of this specification are defined <span class="No-Break">with OpenAPI.</span></p>
			<p class="callout">The <strong class="source-inline">SwaggerXX</strong> method names originate from the original specification and haven’t been changed since. These methods are defined within the <strong class="source-inline">Swashbuckle.AspNetCore</strong> NuGet package that’s referenced with the Web API <span class="No-Break">project template.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Implementing the repository</h2>
			<p>In the <a id="_idIndexMarker061"/>earlier <em class="italic">Defining the game repository contract</em> section, we created the <strong class="source-inline">IGamesRepository</strong> interface to specify the methods that need to be implemented by every data store used with the Games API. We can implement this contract now. The <strong class="source-inline">GamesMemoryRepository</strong> class implements the <span class="No-Break"><strong class="source-inline">IGamesRepository</strong></span><span class="No-Break"> interface:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Data/GamesMemoryRepository.cs</p>
			<pre class="source-code">
namespace Codebreaker.GameAPIs.Data.InMemory;
public class GamesMemoryRepository(ILogger&lt;GamesMemoryRepository&gt; 
   logger) : IGamesRepository
{
  private readonly ConcurrentDictionary&lt;Guid, Game&gt; _games = new();
  private readonly ILogger _logger = logger;
  public Task AddGameAsync(Game game, 
    CancellationToken cancellationToken = default)
  {
    if (!_games.TryAdd(game.Id, game))
    {
      _logger.LogWarning("id {Id} already exists", game.Id);
    }
    return Task.CompletedTask;
  }
  // code removed for brevity
  public Task AddMoveAsync(Game game, Move move, 
    CancellationToken cancellationToken = default)
  {
    _games[game.Id] = game;
    return Task.CompletedTask;
  }
}</pre>
			<p>With the <a id="_idIndexMarker062"/>implementation, the <strong class="source-inline">ConcurrentDictionary</strong> class is used for a thread-safe collection when multiple clients access the service concurrently. With the implemented <strong class="source-inline">AddGameAsync</strong>, <strong class="source-inline">GetGameAsync</strong>, and similar methods, games are added, updated, and removed from the dictionary. Here, all the games are just kept <span class="No-Break">in memory.</span></p>
			<p class="callout-heading">Persistent state and multiple server instances</p>
			<p class="callout">This chapter’s implementation of the repository does not persist the state and also does not allow multiple server instances to run, as the state is only stored within the memory of the process. In the next chapter, other implementations of this interface will be used to store the games in <span class="No-Break">a database.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Creating game objects initialized with random values</h2>
			<p>The <strong class="source-inline">GamesFactory</strong> class <a id="_idIndexMarker063"/>creates games with random values. The following code snippet shows creating a game with six colors and four holes; you can extend this to other game types <span class="No-Break">as well:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesFactory.cs</p>
			<pre class="source-code">
public static class GamesFactory
{
  private static readonly string[] s_colors6 =
    [ Colors.Red, Colors.Green, Colors.Blue, Colors.Yellow, 
    Colors. Purple, Colors.Orange ];
  // code removed for brevity
  public static Game CreateGame(string gameType, string playerName)
  {
    Game Create6x4Game() =&gt;
      new(Guid.NewGuid(), gameType, playerName, DateTime.Now, 4, 12)
      {
        FieldValues = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;()
        {
          { FieldCategories.Colors, s_colors6 }
        },
        Codes = Random.Shared.GetItems(s_colors6, 4)
      };
    // code removed for brevity
    return gameType switch
    {
      GameTypes.Game6x4Mini =&gt; Create6x4SimpleGame(),
      GameTypes.Game6x4 =&gt; Create6x4Game(),
      GameTypes.Game8x5 =&gt; Create8x5Game(),
      GameTypes.Game5x5x4 =&gt; Create5x5x4Game(),
      _ =&gt; throw new CodebreakerException("
      Invalid game type") { Code = CodebreakerExceptionCodes.
      InvalidGameType }
    };
  }
}</pre>
			<p>With the code, pattern <a id="_idIndexMarker064"/>matching is used. For every game type, a local function such as <strong class="source-inline">Create6x4Game</strong> is defined, which specifies the available colors or shapes, the random code, and the maximum number <span class="No-Break">of moves.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Creating data transfer objects</h2>
			<p><strong class="bold">Data transfer objects</strong> (<strong class="bold">DTOs</strong>) are <a id="_idIndexMarker065"/>objects <a id="_idIndexMarker066"/>used for communication to define the data that should be transferred. When you create a microservice for creating, returning, updating, and deleting simple resources, there’s no need to create DTOs that are just used for communication. For example, there’s no need to have a <strong class="source-inline">BookData</strong> class to write information to the database and a <strong class="source-inline">BookDTO</strong> class for communication, implementing the same properties. With such a design in place, a change to the book would result in changing <strong class="source-inline">BookData</strong> and <strong class="source-inline">BookDTO</strong>, as well as the implementation to transform these objects. Using the same <strong class="source-inline">Book</strong> class with every of these scenarios reduces the programming effort, and also reduces the memory and CPU usage <span class="No-Break">during runtime.</span></p>
			<p>A reason to use different types for data access and communication is the requirements for the data mapping to the database and the requirements of the serializer used with communication. Nowadays, both EF Core and the <strong class="source-inline">System.Text.Json</strong> serializer support constructors with parameters, which might fill <span class="No-Break">the requirements.</span></p>
			<p>If there are<a id="_idIndexMarker067"/> other requirements, DTOs can become important. With the games API, different data should be used with the communication than used internally with the service. In creating a game, not all the data for the game is coming from the client. Much of this data, such as the list of available fields as well as the code, is generated on the server. When sending a move from the client to the server, a game gets updated on the server, but there’s only a subset of a move needed that’s sent from the client to the server. When returning information from the server to the client, again, only a subset of data is required. This makes creating <span class="No-Break">DTOs important.</span></p>
			<p>With the games API, to start a new game, we implement the <strong class="source-inline">CreateGameRequest</strong> and <strong class="source-inline">CreateGameResponse</strong> class <span class="No-Break">record types:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Models/GameAPIModels.cs</p>
			<pre class="source-code">
public enum GameType
{
  Game6x4,
  Game6x4Mini,
  Game8x5,
  Game5x5x4
}
public record class CreateGameRequest(GameType GameType, 
  string PlayerName);
public record class CreateGameResponse(Guid id, GameType GameType, 
  string PlayerName, int NumberCodes, int MaxMoves)
{
  public required IDictionary&lt;string, IEnumerable&lt;string&gt;&gt; 
    FieldValues { get; init; }
}</pre>
			<p>In creating <a id="_idIndexMarker068"/>a game, the client just needs to send the game type and the player’s name. This is all that’s needed from the client. In the backend, just a string is used for the game type. Using a string allows for easy enhancements of other game types. The API using an <strong class="source-inline">enum</strong> type allows showing the available game types with the OpenAPI description, as you’ll see in the section <span class="No-Break">about OpenAPI.</span></p>
			<p>After the game is created, the client just needs to have the identifier of the game. For convenience, the game type and player name are also returned. The client should also know the possible fields that can be selected. This is specified by the <span class="No-Break"><strong class="source-inline">FieldValues</strong></span><span class="No-Break"> dictionary.</span></p>
			<p>To set a game move, we implement the <strong class="source-inline">UpdateGameRequest</strong> and <strong class="source-inline">UpdateGameResponse</strong> class <span class="No-Break">record types:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Models/GameAPIModels.cs</p>
			<pre class="source-code">
public record class UpdateGameRequest(Guid Id, GameType GameType, string PlayerName, int MoveNumber, bool End = false)
{
  public string[]? GuessPegs { get; set; }
}
public record class UpdateGameResponse(
  Guid Id,
  GameType GameType,
  int MoveNumber,
  bool Ended,
  bool IsVictory,
  string[]? Results);</pre>
			<p>When<a id="_idIndexMarker069"/> sending a move, the client needs to send the list of guess pegs. With the API service, guess pegs and key pegs are represented with strings, such as the <strong class="source-inline">GuessPegs</strong> property. This makes it independent of any game type. With the analyzers, different types for every game type are implemented. The <strong class="source-inline">IParsable</strong> interface is used to convert <span class="No-Break">string values.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Implementing the games service</h2>
			<p>To<a id="_idIndexMarker070"/> simplify the implementation of the endpoints, we create the <strong class="source-inline">GamesService</strong> class, which will be injected into <span class="No-Break">the endpoints:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public class GamesService(IGamesRepository dataRepository) : IGamesService
{
  public async Task&lt;Game&gt; StartGameAsync(string gameType, 
    string playerName, CancellationToken cancellationToken = default)
  {
    Game game = GamesFactory.CreateGame(gameType, playerName);
    await dataRepository.AddGameAsync(game, cancellationToken);
    return game;
  }
// code removed for brevity</pre>
			<p><strong class="source-inline">StartGameAsync</strong> just invokes the <strong class="source-inline">AddGameAsync</strong> method with <strong class="source-inline">IGamesRepository</strong>. Such a simple implementation is the case with many other methods of <strong class="source-inline">GamesService</strong>. This will change in the next chapter when data will be cached in memory before accessing the database. When using the in-memory repository, this is <span class="No-Break">not necessary.</span></p>
			<p>Implementing <strong class="source-inline">SetMoveAsync</strong> is more complex, as here we have to decide to use one of the <a id="_idIndexMarker071"/>game analyzers to calculate the game. For the game type selection and the calculation, the <strong class="source-inline">ApplyMove</strong> method is defined as an extension method for the <strong class="source-inline">Game</strong> type within the <span class="No-Break"><strong class="source-inline">GamesFactory</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesFactory.cs</p>
			<pre class="source-code">
public static Move ApplyMove(this Game game, string[] guesses, int moveNumber)
{
  static TField[] GetGuesses&lt;TField&gt;(IEnumerable&lt;string&gt; guesses)
    where TField: IParsable&lt;TField&gt; =&gt; guesses
      .Select(g =&gt; TField.Parse(g, default))
      .ToArray();
  string[] GetColorGameGuessAnalyzerResult()
  {
    ColorGameGuessAnalyzer analyzer = 
      new (game, GetGuesses&lt;ColorField&gt;(guesses), moveNumber);
    return analyzer.GetResult().ToStringResults();
  }
  // code removed for brevity
  string[] results = game.GameType switch
  {
    GameTypes.Game6x4 =&gt; GetColorGameGuessAnalyzerResult(),
    GameTypes.Game8x5 =&gt; GetColorGameAnalyzerResult(),
    // code removed for brevity
  };
  Move move = new(Guid.NewGuid(), moveNumber)
  {
    GuessPegs = guesses,
    KeyPegs = results
  }
  game.Moves.Add(move);
  return move;
}</pre>
			<p>The<a id="_idIndexMarker072"/> implementation of this method uses pattern matching with the <strong class="source-inline">switch</strong> expression to invoke the correct analyzer class to get the result of the <span class="No-Break">game move.</span></p>
			<p>Having this <strong class="source-inline">Game</strong> extension method in place let’s us switch back to the implementation of the <strong class="source-inline">SetMoveAsync</strong> method of the <span class="No-Break"><strong class="source-inline">GamesService</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
public async Task&lt;(Game game, string Result)&gt; SetMoveAsync(
  Guid id, string[] guesses, int moveNumber, 
    CancellationToken cancellationToken = default)
{
  Game? game = await dataRepository.GetGameAsync(id, cancellationToken);
  CodebreakerException.ThrowIfNull(game);
  CodebreakerException.ThrowIfEnded(game);
  Move move = game.ApplyMove(guesses, moveNumber);
  await dataRepository.AddMoveAsync(game, move, cancellationToken);
  return (game, move);
}</pre>
			<p>The <strong class="source-inline">SetMoveAsync</strong> method<a id="_idIndexMarker073"/> retrieves the game from the repository before invoking the <strong class="source-inline">ApplyMove</strong> method to do <span class="No-Break">the calculation.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Converting transfer objects to and from the object model</h2>
			<p>In <a id="_idIndexMarker074"/>receiving a <strong class="source-inline">CreateGameRequest</strong> to create a new game, there’s no need for a conversion. The members of <strong class="source-inline">CreateGameRequest</strong> can directly be used when using <strong class="source-inline">GamesService</strong>. We need to create a conversion from a <strong class="source-inline">Game</strong> type to <strong class="source-inline">CreateGameResponse</strong>. This is done as an extension method for the <span class="No-Break"><strong class="source-inline">Game</strong></span><span class="No-Break"> type:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Extensions/ApiModelExtensions.cs</p>
			<pre class="source-code">
public static partial class ApiModelExtensions
{
  public static CreateGameResponse ToCreateGameResponse(
    this Game game) =&gt;
    new(game.Id, Enum.Parse&lt;GameType&gt;(game.GameType), game.PlayerName)
    {
      FieldValues = game.FieldValues;
    };
    // code removed for brevity</pre>
			<p>With the implementation, the needed data from the <strong class="source-inline">Game</strong> type is transferred to the <span class="No-Break"><strong class="source-inline">CreateGameResponse</strong></span><span class="No-Break"> type.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Creating endpoints for the Games API service</h2>
			<p>Before<a id="_idIndexMarker075"/> creating the endpoints, the services we created need to be registered with the dependency injection container to inject them within <span class="No-Break">the endpoint:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
builder.Services.AddSingleton&lt;IGamesRepository, GamesMemoryRepository&gt;();
builder.Services.AddScoped&lt;IGamesService, GamesService&gt;();</pre>
			<p><strong class="source-inline">GamesMemoryRepository</strong> was created to store game objects in memory. This is registered as a singleton for creating a single instance that’s injected into the endpoints. Games should be kept as long as the server keeps running. <strong class="source-inline">GamesMemoryRepository</strong> implements <strong class="source-inline">IGamesRepository</strong>. In the next chapter, an EF Core context will be created to implement the same interface, which will allow changing<a id="_idIndexMarker076"/> the <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) configuration to use the database instead of the in-memory repository. The <strong class="source-inline">GamesService</strong> class implements the <strong class="source-inline">IGamesService</strong> interface. This service class is registered scoped; thus one instance is created with every <span class="No-Break">HTTP request.</span></p>
			<p>With the middleware, we invoke one extension method that defines all the games <span class="No-Break">API endpoints:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
<strong class="bold">app.MapGameEndpoints();</strong>
app.Run();</pre>
			<p>The <strong class="source-inline">MapGameEndpoints</strong> method is an extension method for the <strong class="source-inline">IEndpointRouteBuilder</strong> interface and is <span class="No-Break">implemented next.</span></p>
			<p>In creating a REST API, different HTTP verbs are used to read and <span class="No-Break">write resources:</span></p>
			<ul>
				<li><strong class="source-inline">GET</strong> – With an HTTP <strong class="source-inline">GET</strong> request, resources are returned from <span class="No-Break">the service</span></li>
				<li><strong class="source-inline">POST</strong> – The HTTP <strong class="source-inline">POST</strong> request creates a <span class="No-Break">new resource</span></li>
				<li><strong class="source-inline">PUT</strong> – <strong class="source-inline">PUT</strong> is usually used to update a <span class="No-Break">complete resource</span></li>
				<li><strong class="source-inline">PATCH</strong> – With <strong class="source-inline">PATCH</strong>, a partial resource can be sent for <span class="No-Break">an update</span></li>
				<li><strong class="source-inline">DELETE</strong> – The HTTP <strong class="source-inline">DELETE</strong> request deletes <span class="No-Break">a resource</span></li>
			</ul>
			<h3>Creating games with HTTP POST</h3>
			<p>Let’s start <a id="_idIndexMarker077"/>with the endpoint to create a new game by mapping an HTTP <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs</p>
			<pre class="source-code">
namespace Codebreaker.GameAPIs.Endpoints;
public static class GameEndpoints
{
<strong class="bold">  public static void MapGameEndpoints(</strong>
    <strong class="bold">this IEndpointRouteBuilder routes)</strong>
  {
<strong class="bold">    </strong><strong class="bold">var group = routes.MapGroup("/games");</strong>
<strong class="bold">    group.MapPost("/", async (</strong>
<strong class="bold">      CreateGameRequest request,</strong>
<strong class="bold">      IGamesService gameService,</strong>
<strong class="bold">      HttpContext context,</strong>
<strong class="bold">      CancellationToken cancellationToken)</strong> =&gt;
    {
      Game game;
      try
      {
        game = await gameService.StartGameAsync(request.
          GameType.ToString(), request.PlayerName, cancellationToken);
      }
      catch (CodebreakerException) when (
        ex.Code == CodebreakerExceptionCodes.InvalidGameType)
      {
        GameError error = new(ErrorCodes.InvalidGameType,
          $"Game type {request.GameType} does not exist",
          context.Request.GetDisplayUrl(),
          Enum.GetNames&lt;GameType&gt;());
        return Results.BadRequest(error);
    }
    return Results.Created($"/games/{game.Id}", 
      game.ToCreateGameResponse());
  });</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">In the source code repository, you will find the <strong class="source-inline">GameEndpoints.cs</strong> and <strong class="source-inline">GameEndPoints1.cs</strong> files. The current state of the endpoints is in the <strong class="source-inline">GameEndpoints1.cs</strong> file, but this will be changed later on when OpenAPI information is added. The file that gets compiled as defined in the project file is <strong class="source-inline">GameEndpoints.cs</strong>. If you want to compile the project from the repository with the current version, change the settings of the C# file in the <span class="No-Break">project file.</span></p>
			<p>The <strong class="source-inline">MapGameEndpoints</strong> method is – as previously mentioned – an extension method for the <strong class="source-inline">IEndpointRouteBuilder</strong> interface. The first method invoked is <strong class="source-inline">MapGroup</strong> to define common functionality for the endpoints, which, in turn, uses the returned group variable (a <strong class="source-inline">RouteGroupBuilder</strong> object). With this code, the common functionality is the <strong class="source-inline">/games</strong> URI, which will be prefixed. You can use this for common authorization needs or common logging, which will be shown in later chapters of this book. Common functionality for OpenAPI will be shown later in this chapter in the section <span class="No-Break">on OpenAPI.</span></p>
			<p>The<a id="_idIndexMarker078"/> created group is used with the <strong class="source-inline">MapPost</strong> method. The <strong class="source-inline">MapPost</strong> method will be invoked on an HTTP <strong class="source-inline">POST</strong> request. Similarly, <strong class="source-inline">MapGet</strong>, <strong class="source-inline">MapPut</strong>, and <strong class="source-inline">MapDelete</strong> are available as well. All these methods offer two overloads, where the overload with a pattern and the <strong class="source-inline">Delegate</strong> parameter are used. The <strong class="source-inline">Delegate</strong> parameter allows passing a lambda expression with any parameters and any return types – this is what minimal APIs take <span class="No-Break">advantage of.</span></p>
			<p>The parameter types specified with the <strong class="source-inline">MapPost</strong> method are <span class="No-Break">listed here:</span></p>
			<ul>
				<li><strong class="source-inline">CreateGameRequest</strong> – This comes from the <span class="No-Break">HTTP body.</span></li>
				<li><strong class="source-inline">IGamesService</strong> – The value is injected from the <span class="No-Break">DI container.</span></li>
				<li><strong class="source-inline">HttpContext</strong> and <strong class="source-inline">CancellationToken</strong> – These are special types bound with minimal APIs. Another special one is <strong class="source-inline">ClaimsPrincipal</strong>, which is used <span class="No-Break">with authentication.</span></li>
			</ul>
			<p>Other binding sources that can be used are route values, query strings, headers, and HTML form values. You can also add custom binding to map a route, query, or header binding to <span class="No-Break">custom types.</span></p>
			<p>You can add attributes such as <strong class="source-inline">FromBody</strong>, <strong class="source-inline">FromRoute</strong>, <strong class="source-inline">FromServices</strong>, and others, which can help with readability and also resolve issues if there’s <span class="No-Break">a conflict.</span></p>
			<p>With the implementation of the lambda expression with the <strong class="source-inline">MapPost</strong> method, the injected <strong class="source-inline">gameService</strong> variable is used to start a game. Starting the game successfully, a <strong class="source-inline">Game</strong>-derived object is returned, which is converted to <strong class="source-inline">CreateGameResponse</strong> with the <strong class="source-inline">ToCreateGameResponse</strong> extension method. The method returns either <strong class="source-inline">HTTP 201 Created</strong> on success, or <strong class="source-inline">HTTP 400 Bad Request</strong> using the <strong class="source-inline">Results</strong> factory class. <strong class="source-inline">Results</strong> offers methods to return the different HTTP <span class="No-Break">status codes.</span></p>
			<p>Using <strong class="source-inline">Results.Created</strong>, a URI is assigned to the first parameter of the method, and the second parameter receives the created object. The <strong class="source-inline">201 Created</strong> status code is used to <a id="_idIndexMarker079"/>return the HTTP location header with a link that can be remembered by the client to retrieve the same resource at a later time. The link that’s returned here can be used with an HTTP <strong class="source-inline">GET</strong> request to retrieve the game at a <span class="No-Break">later time.</span></p>
			<h3>Defining an error object</h3>
			<p>In case of an<a id="_idIndexMarker080"/> error, the <strong class="source-inline">MapPost</strong> method returns <strong class="source-inline">Results.BadRequest</strong>. Here, we can define an object to return detailed error information to <span class="No-Break">the client.</span></p>
			<p>The following code snippet shows the <span class="No-Break"><strong class="source-inline">GameError</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Errors/GameError.cs</p>
			<pre class="source-code">
public record class GameError(string Code, string Message, 
  string Target, string[]? Details = default);
public class ErrorCodes
{
  public const string InvalidGameType = nameof(InvalidGameType);
  // code removed for brevity
}</pre>
			<p>The <strong class="source-inline">GameError</strong> class defines the <strong class="source-inline">Code</strong>, <strong class="source-inline">Message</strong>, <strong class="source-inline">Target</strong>, and <strong class="source-inline">Details</strong> properties. With the <strong class="source-inline">MapPost</strong> method, in the case of requesting an invalid game type, the valid game types are returned with <span class="No-Break">the details.</span></p>
			<h3>Returning games with HTTP GET</h3>
			<p>To fulfill a<a id="_idIndexMarker081"/> request to a single game, we use the <span class="No-Break"><strong class="source-inline">MapGet</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs</p>
			<pre class="source-code">
group.<strong class="bold">MapGet</strong>("/{id:guid}", async (
  Guid id,
  IGamesService gameService,
  CancellationToken cancellationToken
) =&gt;
{
  Game? game = await gameService.GetGameAsync(id, cancellationToken);
  if (game is null)
  {
    return Results.NotFound();
  }
  return Results.Ok(game);
});</pre>
			<p>With<a id="_idIndexMarker082"/> the lambda parameters, here, the <strong class="source-inline">Guid</strong> is received from the route parameter. Within curly braces, the same variable name is used that matches the variable of <strong class="source-inline">Guid</strong>. The implementation simply returns the game with the status code of <strong class="source-inline">OK</strong>, or <strong class="source-inline">not found</strong> if the game ID is not found within <span class="No-Break">the repository.</span></p>
			<h3>Updating games by setting a move with HTTP PATCH</h3>
			<p>To set a<a id="_idIndexMarker083"/> move, a game is updated with a move without sending the complete game. That’s a partial update, thus we use the HTTP <strong class="source-inline">PATCH</strong> verb to invoke the <span class="No-Break"><strong class="source-inline">MapPatch</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs</p>
			<pre class="source-code">
group.MapPatch("/{id:guid} ", async (
  Guid id,
  UpdateGameRequest request,
  IGamesService gameService,
  HttpContext context,
  CancellationToken cancellationToken) =&gt;
{
  try
  {
    (Game game, string result) = await gameService.SetMoveAsync(
       id, request.GuessPegs, request.MoveNumber, cancellationToken);
    return Results.Ok(game.AsUpdateGameResponse(result));
  }
  catch (CodebreakerException ex) when (
    ex.Code == CodebreakerExceptionCodes.GameNotFound)
  {
    return Results.NotFound();
  }
  // code removed for brevity
});</pre>
			<p>The complete <a id="_idIndexMarker084"/>route for this request is <strong class="source-inline">games/{id}</strong> – prefixed with the pattern specified by the group. The <strong class="source-inline">SetMoveAsync</strong> method of <strong class="source-inline">GamesService</strong> does the main work. On success, the method returns  <strong class="source-inline">UpdateGameResponse</strong>, which is created from the <strong class="source-inline">Game</strong> object and the <span class="No-Break">result string.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Configuring JSON serialization</h2>
			<p>To successfully<a id="_idIndexMarker085"/> run the application, the JSON serialization needs to be configured. The .NET JSON serializer has many configuration options – including polymorphic serialization (returning a hierarchy of objects). But with all these features supported from serialization and with ASP.NET Core, you need to pay attention to the client technologies you use, if the same support is available there. With the data types we transfer here, there’s not a lot <span class="No-Break">to do.</span></p>
			<p>Just to serialize the enumeration value of game types, we prefer to use strings instead of just numbers, which would be returned by default. To return string values, the JSON options <span class="No-Break">are configured:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Models/GameAPIModels.cs</p>
			<pre class="source-code">
<strong class="bold">[JsonConverter(typeof(JsonStringEnumConverter&lt;GameType&gt;))]</strong>
public enum GameType
{
    Game6x4,
    Game6x4Mini,
    Game8x5,
    Game5x5x4
}</pre>
			<p>The generic version of the <strong class="source-inline">JsonStringEnumConverter</strong> class is new since .NET 8 to support Native AOT. The non-generic version of this type uses reflection, which is incompatible with <span class="No-Break">Native AOT.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of using the attribute with the type, you can also configure the JSON serialization behavior with the dependency injection container. The <strong class="source-inline">ConfigureHttpJsonOptions</strong> extension method with <strong class="source-inline">JsonOptions</strong> from the <strong class="source-inline">Microsoft.AspNetCore.Http.Json</strong> namespace can be used to configure the JSON serialization for minimal APIs. Be aware that the OpenAPI generation still uses the MVC serializer configuration, thus, here, you need to use the <strong class="source-inline">Configure</strong> method with <strong class="source-inline">Microsoft.AspNetCore.Mvc.JsonOptions</strong> as a <span class="No-Break">generic parameter.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Creating endpoint filters</h2>
			<p>To simplify<a id="_idIndexMarker086"/> the code for endpoints, as you’ve seen, endpoints don’t need to be specified within top-level statements. You can create multiple classes with extension methods to group endpoints together. Within one extension method, you can also group endpoints with common behaviors using the <strong class="source-inline">MapGroup</strong> method. We also used dependency injection to have the main functionality outside of the endpoint implementation in the <span class="No-Break"><strong class="source-inline">GameService</strong></span><span class="No-Break"> class.</span></p>
			<p>There’s another way to simplify the implementation of the endpoints – by using custom endpoint filters. Endpoint filters offer similar functionality as ASP.NET Core middleware, just with a different scope. By adding an endpoint filter to an endpoint, the filter code is invoked every time the endpoint is accessed. Adding multiple endpoint filters, the order of adding these is important: one filter is invoked after the other. You can also add an endpoint filter to a group; thus the filter is invoked with every endpoint specified with <span class="No-Break">this group.</span></p>
			<p>With <strong class="source-inline">ValidatePlayernameEndpointFilter</strong>, we create a filter to validate the minimum length of the <span class="No-Break">player’s name:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/ValidatePlayernameEndpointFilter.cs</p>
			<pre class="source-code">
public class ValidatePlayernameEndpointFilter : <strong class="bold">IEndpointFilter</strong>
{
  <strong class="bold">public async ValueTask&lt;object?&gt; </strong>
    <strong class="bold">InvokeAsync(EndpointFilterInvocationContext context, </strong>
    <strong class="bold">EndpointFilterDelegate next)</strong>
  {
    CreateGameRequest request = 
      context.GetArgument&lt;CreateGameRequest&gt;(0);
    if (request.PlayerName.Length &lt; 4)
    {
       return Results.BadRequest("
         Player name must be at least 4 characters long");
    }
    return <strong class="bold">await next(context);</strong>
  }
}</pre>
			<p>An endpoint filter implements the <strong class="source-inline">IEndpointFilter</strong> interface. This interface defines the <strong class="source-inline">InvokeAsync</strong> method with <strong class="source-inline">EndpointFilterInvocationContext</strong> and <strong class="source-inline">EndpointFilterDelegate</strong> parameters. By using <strong class="source-inline">EndpointFilterInvocationContext</strong>, you can access <strong class="source-inline">HttpContext</strong> to access all the<a id="_idIndexMarker087"/> information about the request and also add responses, as well as the parameters passed to the endpoint. With the implementation of <strong class="source-inline">ValidatePlayernameEndpointFilter</strong>, the player’s name is validated by accessing the first parameter of the endpoints lambda expression, accessing the <strong class="source-inline">CreateGameRequest</strong> object, and accessing the <strong class="source-inline">PlayerName</strong> property. An HTTP status code of <strong class="source-inline">400 Bad Request</strong> is returned in the case that this does not succeed. To access the different parameters, the index of the parameter is needed. With a successful validation, the next endpoint is invoked using the <strong class="source-inline">next</strong> variable received with the <span class="No-Break">second parameter.</span></p>
			<p>Using an endpoint filter, you can also remove the exception handling code and create code with the filter that’s invoked before and after the next filter or the endpoint code is invoked. We implement this functionality <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">CreateGameExceptionEndointFilter</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/CreateGameExceptionEndpointFilter.cs</p>
			<pre class="source-code">
public class CreateGameExceptionEndpointFilter : IEndpointFilter
{
  private readonly ILogger _logger;
  public CreateGameExceptionEndpointFilter
    (ILogger&lt;CreateGameExceptionEndpointFilter&gt; logger)
  {
    _logger = logger;
  }
  public async ValueTask&lt;object?&gt; 
    InvokeAsync(EndpointFilterInvocationContext context, 
    EndpointFilterDelegate next)
  {
    CreateGameRequest request = 
      context.GetArgument&lt;CreateGameRequest&gt;(1);
    try
    {
<strong class="bold">      return await next(context);</strong>
    }
    catch (CodebreakerException ex) when (
      ex.Code == CodebreakerExceptionCodes.InvalidGameType)
    {
<strong class="bold">      _logger.LogWarning("game type {gametype} not found", </strong>
        <strong class="bold">request.GameType);</strong>
<strong class="bold">      return Results.BadRequest("Gametype does not exist");</strong>
    }
  }
}</pre>
			<p>The <strong class="source-inline">CreateGameExceptionEndpointFilter</strong> endpoint filter defines a constructor<a id="_idIndexMarker088"/> to inject the <strong class="source-inline">ILogger</strong> interface. Everything registered with the dependency injection container can be injected with an endpoint filter. With this filter, the invocation of the next filter – or the endpoint itself, in this case – is surrounded by a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block. Thus, <strong class="source-inline">CodebreakerException</strong> is caught with the endpoint invocation, logged, and a result returned. This way, the exception-handling code can be removed from the endpoint itself. The <a id="_idIndexMarker089"/>following code snippet shows the new code for the endpoint implementation with the <span class="No-Break">configured filters:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints2.cs</p>
			<pre class="source-code">
group.MapPost("/", async (
  CreateGameRequest request,
  IGamesService gameService,
  CancellationToken cancellationToken) =&gt;
{
  Game game = await gameService.StartGameAsync(request.
    GameType.ToString(), request.PlayerName, cancellationToken);
  return Results.Created($"/games/{game.Id}", 
    game.ToCreateGameResponse());
        })<strong class="bold">.AddEndpointFilter&lt;ValidatePlayernameEndpointFilter&gt;()</strong>
          <strong class="bold">.AddEndpointFilter&lt;CreateGameExceptionEndpointFilter&gt;();</strong></pre>
			<p>With this implementation, the important main functionality of this endpoint is easily visible. Validation and error handling is moved outside of the endpoint implementation. Calculating all the code together, the code is not becoming smaller, just the main functionality of the endpoint is <span class="No-Break">becoming easier.</span></p>
			<p>The real power of endpoint filters comes with shared functionality between different endpoints. In <a href="B21217_11.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Logging and Monitoring</em>, we will create an endpoint filter that logs information for every endpoint that is configured with <span class="No-Break">this filter.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Running the service</h2>
			<p>With the<a id="_idIndexMarker090"/> endpoints implemented, you can run and test the application and see the Open API user interface, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21217_02_04.jpg" alt="Figure 2.4 – OpenAPI UI without extra configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – OpenAPI UI without extra configuration</p>
			<p>You can now run the application sending a <strong class="source-inline">POST</strong> request from the Swagger page. After getting the game information returned, copy the unique ID from the game, and send a <strong class="source-inline">PATCH</strong> request to set <span class="No-Break">a move.</span></p>
			<p>While the application is running, OpenAPI now lacks some information. The returned HTTP results are not listed, more description details should be shown, and the schema for return types is not available. This is solved in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>OpenAPI information</h1>
			<p>Since there are many .NET versions, the <a id="_idIndexMarker091"/>Web API templates reference the <strong class="source-inline">Swashbuckle.AspNetCore</strong> NuGet package to create an OpenAPI description. Over the years, with later .NET versions, more and more functionality from OpenAPI has been added to ASP.NET Core itself, such as the <strong class="source-inline">OpenApiInfo</strong> class, which is now part of the <strong class="source-inline">Microsoft.OpenApis.Models</strong> namespace. Swashbuckle was<a id="_idIndexMarker092"/> changed to use the new classes and was also changed to be based on the <strong class="source-inline">System.Text.Json</strong> serializer instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Newtonsoft.Json</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Adding OpenAPI documentation</h2>
			<p>Next, let’s make use<a id="_idIndexMarker093"/> of classes from the <strong class="source-inline">Microsoft.OpenApis.Models</strong> namespace together with Swashbuckle to configure the <span class="No-Break">OpenAPI documentation:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
builder.Services.AddEndpointsApiExplorer();
<strong class="bold">builder.Services.AddSwaggerGen</strong>(options =&gt;
{
<strong class="bold">  options.SwaggerDoc</strong>("v3", new OpenApiInfo
  {
    Version = "v3",
    Title = "Codebreaker Games API",
    Description = 
      "An ASP.NET Core minimal APIs to play Codebreaker games",
    TermsOfService = new Uri("https://www.cninnovation.com/terms"),
    Contact = new OpenApiContact
    {
      Name = "Christian Nagel",
      Url = new Uri("https://csharp.christiannagel.com")
    },
    License = new OpenApiLicense
    {
      Name="API usage license",
      Url= new Uri("https://www.cninnovation.com/apiusage")
    }
  });
});</pre>
			<p>The Codebreaker Games API is <a id="_idIndexMarker094"/>already in its third major version. With the Swagger configuration of the dependency <a id="_idIndexMarker095"/>injection container, the <strong class="source-inline">AddSwaggerGen</strong> method supports receiving configuration options. The <strong class="source-inline">SwaggerDoc</strong> method of the <strong class="source-inline">SwaggerGenOptions</strong> options parameter allows specifying different document values, such as the version number, title, description, terms of service, contact, and license information, as shown in the code snippet. The <strong class="source-inline">OpenApiInfo</strong>, <strong class="source-inline">OpenApiContact</strong>, and <strong class="source-inline">OpenApiLicense</strong> classes are part of the <strong class="source-inline">Microsoft.OpenApi.Models</strong> namespace. All this configured information will show up in the generated <span class="No-Break">OpenAPI documentation.</span></p>
			<p>The middleware configuration needs to be updated <span class="No-Break">as well:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Program.cs</p>
			<pre class="source-code">
app.UseSwagger();
<strong class="bold">app.UseSwaggerUI(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">  options.SwaggerEndpoint("/swagger/v3/swagger.json", "v3");</strong>
});</pre>
			<p>Here, the version number is included with the OpenAPI endpoint invoking the <strong class="source-inline">SwaggerEndpoint</strong> method using the <strong class="source-inline">SwaggerUIOptions</strong> parameter. In case you prefer a different look for the generated document, you can create your own style sheet, and pass the style sheet file by invoking the <span class="No-Break"><strong class="source-inline">options.InjectStylesheet</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Documentation for the endpoints</h2>
			<p>Several <a id="_idIndexMarker096"/>extension methods are available to add OpenAPI documentation to the endpoints, as we’ll do within the <span class="No-Break"><strong class="source-inline">MapGameEndpoints</strong></span><span class="No-Break"> implementation:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
public static void MapGameEndpoints(this IEndpointRouteBuilder routes)
{
  var group = routes.MapGroup("/games")
<strong class="bold">    .WithTags</strong>("Games API");</pre>
			<p>The <strong class="source-inline">WithTags</strong> method could be added to every endpoint or, as shown here, to the endpoint group. <strong class="source-inline">WithTags</strong> adds a category name – or multiple names if the API should show up with multiple categories. With this, for the documentation for every tag name, a heading is used to show all the endpoints together that belong to the same category. If you don’t supply a tag name, the project name is used, and all the endpoints are listed in <span class="No-Break">this category.</span></p>
			<p>Next, using <strong class="source-inline">RouteHandlerBuilder</strong> extension methods, documentation is added to <span class="No-Break">every endpoint:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
group.MapPost("/", async Task&lt;Results&lt;Created&lt;CreateGameResponse&gt;, BadRequest&lt;GameError&gt;&gt;&gt; (
// code removed for brevity
})
.<strong class="bold">WithName</strong>("CreateGame")
.<strong class="bold">WithSummary</strong>("Creates and starts a game")
.<strong class="bold">WithOpenApi</strong>(op =&gt;
{
  op.RequestBody.Description = "
     The game type and the player name of the game to create";
  return op;
});</pre>
			<p>Using<a id="_idIndexMarker097"/> the <strong class="source-inline">WithName</strong>, <strong class="source-inline">WithSummary</strong>, and <strong class="source-inline">WithOpenApi</strong> methods, a name and description of the API – including a description of every parameter – can <span class="No-Break">be added.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Adding return type information to OpenAPI</h2>
			<p>The <strong class="source-inline">Produces</strong> extension <a id="_idIndexMarker098"/>method could be used to define what types are returned from endpoints that need to be described. Since .NET 7, there’s a better option: using the <strong class="source-inline">TypedResults</strong> class instead of the <strong class="source-inline">Results</strong> class that was used earlier in implementing the endpoints. <strong class="source-inline">TypedResults</strong> adds the class specified to the OpenAPI documentation. However, if there is more than one type returned, we need to specify this with the return types of the endpoint <span class="No-Break">lambda expression.</span></p>
			<p>The first method to be changed to <strong class="source-inline">TypedResults</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">MapDelete</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs</p>
			<pre class="source-code">
group.MapDelete("/{id:guid}", async (
  Guid id,
  IGamesService gameService,
  CancellationToken cancellationToken
) =&gt;
{
  await gameService.DeleteGameAsync(id, cancellationToken);
<strong class="bold">  </strong><strong class="bold">return TypedResults.NoContent();</strong>
})
// code removed for brevity</pre>
			<p>The<a id="_idIndexMarker099"/> implementation of the lambda expression for the <strong class="source-inline">MapDelete</strong> method just returns the HTTP status code <strong class="source-inline">204</strong> and doesn’t require a return type for the <span class="No-Break">lambda expression.</span></p>
			<p>This is different with the <span class="No-Break"><strong class="source-inline">MapPatch</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="source-code">
group.MapPatch("/{id:guid}/moves", async <strong class="bold">Task&lt;Results&lt;Ok&lt;UpdateGameResponse&gt;, NotFound, BadRequest&lt;GameError&gt;&gt;&gt;</strong> (
  Guid id,
  UpdateGameRequest request,
  IGamesService gameService,
  HttpContext context,
  CancellationToken cancellationToken) =&gt;
{
  try
  {
    (Game game, string result) = await gameService.SetMoveAsync(id, 
     request.GuessPegs, request.MoveNumber, cancellationToken);
    return <strong class="bold">TypedResults.Ok</strong>(game.AsUpdateGameResponse(result));
  }
  catch (ArgumentException ex) when (ex.HResult &gt;= 4200 &amp;&amp; 
    ex.HResult &lt;= 4500)
  {
    string url = context.Request.GetDisplayUrl();
    return ex.HResult switch
    {
      4200 =&gt; <strong class="bold">TypedResults.BadRequest</strong>(new GameError(
        ErrorCodes.InvalidGuessNumber, "Invalid number of guesses 
        received", url)),
      4300 =&gt; <strong class="bold">TypedResults.BadRequest</strong>(new GameError(
        ErrorCodes.InvalidMoveNumber, "Invalid move number received", 
        url)),
  // code removed for brevity
    };
  }
  catch (GameNotFoundException)
  {
    return <strong class="bold">TypedResults.NotFound</strong>();
  }
})
// code removed for brevity</pre>
			<p>The<a id="_idIndexMarker100"/> implementation of the lambda expression contains several invocations of the <strong class="source-inline">TypedResults</strong> factory class. The <strong class="source-inline">BadRequest</strong>, <strong class="source-inline">NotFound</strong>, and <strong class="source-inline">Ok</strong> methods are invoked. With <strong class="source-inline">BadRequest</strong>, an object of the <strong class="source-inline">GameError</strong> type is returned. This is just a simple record class with a <strong class="source-inline">Message</strong> and other properties to return useful information for the clients. The <strong class="source-inline">Ok</strong> method returns an object of the <strong class="source-inline">UpdateGameResponse</strong> class. With two or more typed results returned, the lambda expression needs a return type. To specify the return type with the lambda expression, .NET 7 added generic <strong class="source-inline">Results</strong> types – for example, the type with two generic parameters: <strong class="source-inline">Results&lt;TResult1, TResult2&gt;</strong>. The generic types specify the constraint to require the <strong class="source-inline">IResult</strong> interface. The <strong class="source-inline">Microsoft.AspNetCore.Http.HttpResults</strong> namespace contains generic <strong class="source-inline">Results</strong> types from two to six generic parameters. By using <strong class="source-inline">Results&lt;Ok&lt;UpdateGameResponse&gt;, NotFound, BadRequest&lt;InvalidGameMoveError&gt;&gt;</strong>, it’s defined that the method either returns an <strong class="source-inline">Ok</strong> result with a <strong class="source-inline">SetMoveError</strong> object, <strong class="source-inline">NotFound</strong>, or <strong class="source-inline">BadRequest</strong> with an <strong class="source-inline">InvalidGameMoveError</strong> object. Because the lambda expression makes use of the <strong class="source-inline">async</strong> keyword, the complete result is put into a task: <strong class="source-inline">Task&lt;Results&lt;Ok&lt;UpdateGameResponse&gt;, </strong><span class="No-Break"><strong class="source-inline">NotFound, BadRequest&lt;InvalidGameMoveError&gt;&gt;&gt;</strong></span><span class="No-Break">.</span></p>
			<p>With all this <a id="_idIndexMarker101"/>OpenAPI configuration in place, we can start the service, generate the documentation to describe the API, and use it from a web interface, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21217_02_05.jpg" alt="Figure 2.5 – OpenAPI documentation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – OpenAPI documentation</p>
			<p>Opening an endpoint, you can see the different HTTP results returned and all the <span class="No-Break">schemas created.</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Testing the service</h1>
			<p>To run the<a id="_idIndexMarker102"/> service, the OpenAPI test page can be used. However, there’s a better way without leaving Visual Studio or Visual Studio Code. Visual Studio offers the <strong class="bold">Endpoints Explorer</strong> window to show all the API endpoints in your solution, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.6</em>. Open this window using <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <span class="No-Break"><strong class="bold">Endpoints Explorer</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21217_02_06.jpg" alt="Figure 2.6 – Endpoints Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Endpoints Explorer</p>
			<p>By selecting an endpoint and opening the context menu, you can generate a request. This creates an HTTP file that you can use to send HTTP requests, including the body, and see the returned results <span class="No-Break">beside it.</span></p>
			<p class="callout-heading">Using HTTP files with Visual Studio Code</p>
			<p class="callout">If you use Visual Studio Code, install the <strong class="source-inline">REST Client</strong> extension from <span class="No-Break">Huachao Mao.</span></p>
			<p>First, we start a game by sending a <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Codebreaker.GameAPIs.http</p>
			<pre class="source-code">
@HostAddress = http://localhost:9400
@ContentType = application/json
### Create a game
POST {{HostAddress}}/games/
Content-Type: {{ContentType}}
{
  "gameType": "Game6x4",
  "playerName": "test"
}</pre>
			<p>The first two<a id="_idIndexMarker103"/> lines in the HTTP file specify variables that are referenced later surrounded by two curly braces. Every request specified needs to be separated by three hash characters, <strong class="source-inline">###</strong>. With this, using Visual Studio or the Visual Studio Code extension, you can see a green arrow that, when clicked, sends the request. To separate the HTTP header from the body, a blank line is required. The body to create a game contains the <strong class="source-inline">gameType</strong> and <strong class="source-inline">playerName</strong> <span class="No-Break">JSON elements.</span></p>
			<p>After sending the request to create a game, you can set <span class="No-Break">a move:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Codebreaker.GameAPIs.http</p>
			<pre class="source-code">
### Set a move
@id = 1eae1e79-a7fb-41a6-9be8-39f83537b7f3
PATCH {{HostAddress}}/games/{{id}}/moves
Content-Type: {{ContentType}}
{
  "gameType": "Game6x4",
  "playerName": "test",
  "moveNumber": 1,
  "guessPegs": [
    "Red",
    "Green",
    "Blue",
    "Yellow"
  ]
}</pre>
			<p>Before<a id="_idIndexMarker104"/> sending the move, get the ID that was returned on creation of the game, and paste it into the <strong class="source-inline">id</strong> variable used with the HTTP file. There’s no need to save this file; just clicking on the link will send the <strong class="source-inline">PATCH</strong> request. Remember to update the move number with <span class="No-Break">every move.</span></p>
			<p>To get information about the game, send a <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> request:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Codebreaker.GameAPIs.http</p>
			<pre class="source-code">
### Get game information
GET {{HostAddress}}/games/{{id}}</pre>
			<p>When sending the <strong class="source-inline">GET</strong> request, a body is not supplied. This request gives complete information about the game, including its moves, and the <span class="No-Break">result code.</span></p>
			<p>By using HTTP files, you can easily debug the APIs without leaving Visual Studio. In case you’re in a debug session, you might need to change the <strong class="bold">Request timeout</strong> setting in <strong class="bold">Text Editor</strong> | <strong class="bold">Rest</strong> | <strong class="bold">Advanced settings</strong>. The HTTP files also serve as good documentation as part of <span class="No-Break">the project.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Enabling .NET Aspire</h1>
			<p>Let’s<a id="_idIndexMarker105"/> add .NET Aspire to this solution. Using Visual Studio, you can select the Games API project in <strong class="bold">Solution explorer</strong> and use the context menu to select <strong class="bold">Add</strong> | <strong class="bold">.NET Aspire </strong><span class="No-Break"><strong class="bold">Orchestrator Support…</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of using Visual Studio, you can use the dotnet CLI to create a .NET Aspire project: <strong class="source-inline">dotnet new aspire</strong>. With the two projects created, you can connect the Games API project using the explanations from <span class="No-Break">this section.</span></p>
			<p>This creates two projects (<strong class="source-inline">{solution}.AppHost</strong> and <strong class="source-inline">{solution}.ServiceDefaults</strong>) and makes small changes to the Games API project. The <strong class="source-inline">AppHost</strong> project is a web application that runs a dashboard to monitor all the configured services. <strong class="source-inline">ServiceDefaults</strong> is a library to specify default configurations. This library is referenced by the Games API. Let’s look into the <span class="No-Break">details next.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Exploring the Aspire host</h2>
			<p>The source<a id="_idIndexMarker106"/> code of the startup code of the Aspire host is <span class="No-Break">shown here:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = <strong class="bold">DistributedApplication.CreateBuilder(args);</strong>
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis");</strong>
builder.Build().Run();</pre>
			<p>This Aspire host runs a web application that’s only used during development time. Here, the <strong class="source-inline">DistributedApplication</strong> class is used with the app builder pattern. The <strong class="source-inline">CreateBuilder</strong> method returns the <strong class="source-inline">IDistributedApplicationBuilder</strong> interface, which allows the configuration of all the services that should be orchestrated by the distributed application. Using this interface, similar to <strong class="source-inline">WebApplicationBuilder</strong>, the configuration and DI container can be configured. Contrary to <strong class="source-inline">WebApplicationBuilder</strong>, resources can be added that are orchestrated by the <span class="No-Break">app host.</span></p>
			<p>A project <a id="_idIndexMarker107"/>resource is added to the resources of the builder by invoking the <strong class="source-inline">AddProject</strong> extension method. Adding a project reference to the <strong class="source-inline">Codebreaker.GameAPIs</strong> project creates the <strong class="source-inline">Codebreaker_GameAPIs</strong> class in the <strong class="source-inline">Projects</strong> namespace. The name passed with the parameter – <strong class="source-inline">gameapis</strong> – can be used when one service references another one. Currently, we only have one service in the <strong class="source-inline">Codebreaker</strong> solution, but this will change going forward with the chapters of <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Exploring the ServiceDefaults library</h2>
			<p>The <strong class="source-inline">Codebreaker.ServiceDefaults</strong> project is here to be referenced by all service projects <a id="_idIndexMarker108"/>making use of .NET Aspire functionality. This project adds references to NuGet packages for HTTP resiliency, service discovery, and several OpenTelemetry packages used for logging, metrics, and <span class="No-Break">distributed tracing.</span></p>
			<p>This is the configuration defined by the <span class="No-Break"><strong class="source-inline">Extensions</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static IHostApplicationBuilder AddServiceDefaults(this IHostApplicationBuilder builder)
{
  builder.ConfigureOpenTelemetry();
  builder.AddDefaultHealthChecks();
  builder.Services.AddServiceDiscovery();
  builder.Services.ConfigureHttpClientDefaults(http =&gt;
  {
    http.AddStandardResilienceHandler();
    http.AddServiceDiscovery();
  });
  return builder;
}</pre>
			<p>The <strong class="source-inline">AddServiceDefaults</strong> method configures the DI container with OpenTelemetry for logging, default health checks, and service discovery, and configures the <strong class="source-inline">HttpClient</strong> class <span class="No-Break">with resiliency.</span></p>
			<p>This<a id="_idIndexMarker109"/> complete configuration can be used from the Codebreaker Games API by invoking the <strong class="source-inline">AddServiceDefaults</strong> method with the application builder. This invocation is added from the Visual Studio .NET Aspire integration when adding Aspire orchestration. If you created the .NET Aspire projects from the command line, you need to add the invocation to the <strong class="source-inline">AddServiceDefaults</strong> method when configuring the <span class="No-Break">DI container.</span></p>
			<p>Another extension method defined by the service defaults library <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">MapDefaultEndpoints</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static WebApplication MapDefaultEndpoints(this WebApplication app)
{
  app.MapHealthChecks("/health");
  app.MapHealthChecks("/alive", new HealthCheckOptions
  {
    Predicate = r =&gt; r.Tags.Contains("live")
  });
  return app;
}</pre>
			<p>This is <a id="_idIndexMarker110"/>an extension method to configure the ASP.NET Core middleware with health checks. The <strong class="source-inline">MapDefaultEndpoints</strong> method needs to be invoked with the middleware configuration of the <span class="No-Break">Games API.</span></p>
			<p>All the functionality mentioned here will be discussed in detail in the following chapters. Now, you can already start the Aspire host project, which, in turn, starts up the <span class="No-Break">Games API.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Running the .NET Aspire host</h2>
			<p>When<a id="_idIndexMarker111"/> running the .NET Aspire host, a dashboard is shown that shows the <strong class="source-inline">codebreaker.gameapis</strong> project with the resources where you can access endpoints, check environment variables, and open log information, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21217_02_07.jpg" alt="Figure 2.7 – Resources in the .NET Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Resources in the .NET Aspire dashboard</p>
			<p>While the Aspire host is running, you can play games using the HTTP files created earlier, and now monitor the logs, metrics information, and traces (shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B21217_02_08.jpg" alt="Figure 2.8 – Traces in the .NET Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Traces in the .NET Aspire dashboard</p>
			<p>Details on<a id="_idIndexMarker112"/> logging, metrics, tracing, and adding custom information are covered in <a href="B21217_11.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Logging </em><span class="No-Break"><em class="italic">and Monitoring</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Summary</h1>
			<p>In this chapter, we created a Web API using ASP.NET Core minimal APIs. We covered creating services and an in-memory repository, configured them with the dependency injection container, created models, and used game analyzer classes to <span class="No-Break">calculate moves.</span></p>
			<p>We created endpoints to create, read, and update games, specified information to show up with the OpenAPI documentation, tested the service using HTTP files, and finally, added .NET Aspire for hosting and <span class="No-Break">a dashboard.</span></p>
			<p>After working through this chapter, you deserve a break to play a game. Use the HTTP files to create a game and set moves until the answer returned shows that you won. Don’t cheat by making <strong class="source-inline">GET</strong> requests to the game before you find <span class="No-Break">the answer!</span></p>
			<p>In the next chapter, we’ll replace the repository by using Entity Framework Core with SQL Server and Azure Cosmos DB to have a persistent <span class="No-Break">games store.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">Primary </em><span class="No-Break"><em class="italic">constructors</em></span><span class="No-Break">: </span><a href="https://csharp.christiannagel.com/2023/03/28/primaryctors/"><span class="No-Break">https://csharp.christiannagel.com/2023/03/28/primaryctors/</span></a></li>
				<li><em class="italic">Microsoft REST API </em><span class="No-Break"><em class="italic">Guidelines</em></span><span class="No-Break">: </span><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md"><span class="No-Break">https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md</span></a></li>
				<li><em class="italic">The OpenAPI </em><span class="No-Break"><em class="italic">Initiative</em></span><span class="No-Break">: </span><a href="https://www.openapis.org/"><span class="No-Break">https://www.openapis.org/</span></a></li>
				<li><em class="italic">Minimal APIs parameter </em><span class="No-Break"><em class="italic">binding</em></span><span class="No-Break">: </span><span class="No-Break">https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/parameter-binding</span></li>
				<li><em class="italic">JSON serialization </em><span class="No-Break"><em class="italic">customization</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/standard/serialization/</span></a></li>
				<li>The <strong class="source-inline">Swashbuckle.AspNetCore</strong> GitHub <span class="No-Break">repo: </span><span class="No-Break">https://github.com/domaindrivendev/Swashbuckle.AspNetCore</span></li>
				<li>.NET Aspire <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/</span></a></li>
			</ul>
		</div>
	</body></html>