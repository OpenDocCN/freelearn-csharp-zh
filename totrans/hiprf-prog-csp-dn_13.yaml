- en: '*Chapter 11*: Benchmarking Relational Data Access Frameworks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：基准测试关系型数据访问框架'
- en: Data is extensively used in all aspects of our daily lives. In today's world
    of big data, the volumes of data being collected and stored for all kinds of analysis
    are phenomenal. When working with data, performance can slow down exponentially
    as the size of your data grows. Depending upon how much data you have to process,
    the time factor is often critical.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在我们的日常生活各个方面都得到了广泛的应用。在当今的大数据时代，收集和存储用于各种分析的数据量是惊人的。当处理数据时，随着数据量的增长，性能会呈指数级下降。根据您需要处理的数据量，时间因素往往是关键的。
- en: In a professional development environment, computer programmers don't always
    have access to the database server. Database server access is usually restricted
    for use by database developers and database administrators. With that in mind,
    this chapter is about benchmarking what code performs a database insert, update,
    read, and delete in the shortest possible time. In the *Further reading* section,
    there are links to documentation on database server performance that will help
    you to further improve the performance that you gain from working through this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业开发环境中，程序员并不总是能够访问数据库服务器。数据库服务器的访问通常仅限于数据库开发人员和数据库管理员使用。考虑到这一点，本章是关于基准测试代码以最短时间执行数据库插入、更新、读取和删除操作。在
    *进一步阅读* 部分中，有一些链接到数据库服务器性能文档的链接，这将帮助您进一步提高通过本章获得的效果。
- en: In this chapter, we will be benchmarking three different ways of manipulating
    SQL Server database data. We will be performing a side-by-side comparison of Entity
    Framework, ADO.NET, and Dapper. After running the benchmarks for each of these
    data access and object mappers, you will be able to make an educated judgment
    call on the best form of data access and object mapping for your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基准测试三种不同的操作 SQL Server 数据库数据的方法。我们将对 Entity Framework、ADO.NET 和 Dapper
    进行并行比较。在运行这些数据访问和对象映射器的基准测试后，您将能够对您项目的最佳数据访问和对象映射形式做出明智的判断。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Benchmarking data insertion methods**: In this section, we write the benchmarks
    for inserting data with ADO.NET, Entity Framework Core, and Dapper.NET with and
    without using stored procedures.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试数据插入方法**：在本节中，我们编写了使用 ADO.NET、Entity Framework Core 和 Dapper.NET 插入数据的基准测试，包括使用和不使用存储过程的情况。'
- en: '**Benchmarking data selection methods**: In this section, we write the benchmarks
    for selecting data with ADO.NET, Entity Framework Core, and Dapper.NET with and
    without using stored procedures.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试数据选择方法**：在本节中，我们编写了使用 ADO.NET、Entity Framework Core 和 Dapper.NET 选择数据的基准测试，包括使用和不使用存储过程的情况。'
- en: '**Benchmarking data editing methods**: In this section, we write the benchmarks
    for applying updates to data with ADO.NET, Entity Framework Core, and Dapper.NET
    with and without using stored procedures.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试数据编辑方法**：在本节中，我们编写了使用 ADO.NET、Entity Framework Core 和 Dapper.NET 应用数据更新的基准测试，包括使用和不使用存储过程的情况。'
- en: '**Benchmarking data deletion methods**: In this section, we write the benchmarks
    for deleting data with ADO.NET, Entity Framework Core, and Dapper.NET with and
    without using stored procedures.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试数据删除方法**：在本节中，我们编写了使用 ADO.NET、Entity Framework Core 和 Dapper.NET 删除数据的基准测试，包括使用和不使用存储过程的情况。'
- en: '**The benchmarking results and their analysis**: In this section, we run the
    benchmarks that we wrote in the previous sections. We then analyze the results
    of our benchmark results to conclude the best way to perform various efficient
    data access and manipulation tasks.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基准测试结果及其分析**：在本节中，我们运行了之前章节中编写的基准测试。然后，我们分析基准测试结果，以得出执行各种高效数据访问和操作任务的最佳方式。'
- en: After working through this chapter, you will have the skills needed to access
    and manipulate data with ADO.NET, Entity Framework, and Dapper.NET. You'll also
    be able to form your own judgment on which method of data access to use for your
    own projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，您将具备使用 ADO.NET、Entity Framework 和 Dapper.NET 访问和操作数据的技能。您还将能够对您自己的项目选择合适的数据访问方法。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter mainly involves you following along with writing a lot of code
    in preparation for running our data access benchmark methods in the last section.
    If you don't want to bother writing the code and just want to see the results,
    then jump to the last section of this chapter on the benchmarking results and
    their analysis. You can then jump to the areas of this chapter that are of most
    interest to you in helping you form your own opinions on the best data access
    methods for your needs. The source code is also available on GitHub to study for
    yourself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要涉及你跟随编写大量代码，为在最后一节运行我们的数据访问基准方法做准备。如果你不想编写代码，只想查看结果，那么请跳转到本章的最后一节，查看基准测试结果及其分析。你还可以跳转到本章中对你最有兴趣的领域，帮助你形成自己关于最适合你需求的数据访问方法的观点。源代码也已在GitHub上提供，供你自己研究。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To master the skills presented in this chapter, it will be useful to have access
    to the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要掌握本章中介绍的技能，获取以下内容将非常有用：
- en: Visual Studio 2022 or higher
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 或更高版本
- en: SQL Server 2019 or higher
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 2019 或更高版本
- en: SQL Server Management Student 2019 or higher
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server Management Student 2019 或更高版本
- en: 'The book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10)
- en: Benchmarking data insertion methods
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试数据插入方法
- en: In this section, we will be following on from the work we did in [*Chapter 10*](B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189),
    *Setting Up Our Database Project*, by writing methods that will benchmark the
    performance of insert methods using ADO.NET, Entity Framework Core, and Dapper.NET.
    So, if you have not read [*Chapter 10*](B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189)*,*
    or looked at the source code, now would be a good time to do that.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们将继续我们在 [*第10章*](B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189)，*设置我们的数据库项目*，所做的工作，通过编写将使用
    ADO.NET、Entity Framework Core 和 Dapper.NET 对插入方法性能进行基准测试的方法。所以，如果你还没有阅读 [*第10章*](B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189)*，或者查看源代码，现在是一个很好的时机去做这些。 '
- en: 'The benchmarks written in this chapter will be run and the results will be
    analyzed in the last section. To save space due to chapter and page constraints,
    I will be leaving out references to `using` statements. Therefore, you will need
    to use Visual Studio''s quick tips for adding missing `using` statements. Follow
    these steps to write our insertion method benchmarks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章编写的基准测试将在最后一节运行，并分析结果。由于章节和页面的限制，我将省略对 `using` 语句的引用。因此，你需要使用 Visual Studio
    的快速提示来添加缺失的 `using` 语句。按照以下步骤编写我们的插入方法基准测试：
- en: Add the `BenchmarkDotNet` NuGet package.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `BenchmarkDotNet` NuGet 包。
- en: 'Open the `BenchmarkTests` class and modify it as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BenchmarkTests` 类，并按以下方式修改：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have set our class up to execute benchmarks and summarize them in the order
    that they are declared, as well as diagnosing the memory usage and providing a
    performance ranking of the benchmarking methods. Then, we provided `GlobalSetup`,
    which is run before the benchmarks. This is to provide our benchmarks with data
    to select, update, and delete.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了类来执行基准测试，并按声明的顺序总结它们，同时诊断内存使用情况，并提供基准测试方法的性能排名。然后，我们提供了 `GlobalSetup`，它在基准测试之前运行。这是为了为我们的基准测试提供选择、更新和删除的数据。
- en: 'Add the `InsertProductADN` method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `InsertProductADN` 方法：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method obtains the connection string from the secrets file and creates
    a new `AdoDotNetData` instance by passing the connection string into its constructor.
    It then calls the `ExecuteNonQuery` method, passing into the method a raw SQL
    insert method. Once the query is run, the instance is disposed of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并通过将连接字符串传递给其构造函数来创建一个新的 `AdoDotNetData` 实例。然后，它调用 `ExecuteNonQuery`
    方法，将原始 SQL 插入方法传递给该方法。一旦查询运行，实例将被释放。
- en: 'Add the `InsertProductADNSP` method:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `InsertProductADNSP` 方法：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method obtains the connection string from the secrets file and passes the
    string into the constructor of the `AdoDotNetData` class. It then creates a new
    `SqlCommandModel` that builds the properties for a stored procedure insert operation
    on the products table. It then calls the `ExecuteNonQuery` method, passing in
    the model that will be used to generate and execute the stored procedure call.
    The `AdoDotNetData` class is then disposed of.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并将字符串传递给 `AdoDotNetData` 类的构造函数。然后，它创建一个新的 `SqlCommandModel`，用于在产品表上构建存储过程插入操作的属性。接着，它调用
    `ExecuteNonQuery` 方法，传入用于生成和执行存储过程调用的模型。然后，`AdoDotNetData` 类被释放。
- en: 'Add the `InsertProductEF` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `InsertProductEF` 方法：
- en: 'Add the `InsertProductEF` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `InsertProductEF` 方法：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method obtains the connection string from the secrets file and passes it
    into the constructor of the `EntityFrameworkCoreData` class. It then creates a
    new product and adds that product to the `Products` collection. The changes are
    then saved, and the `EntityFrameworkCoreData` class is disposed of.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并将其传递给 `EntityFrameworkCoreData` 类的构造函数。然后，它创建一个新的产品并将其添加到
    `Products` 集合中。然后保存更改，并释放 `EntityFrameworkCoreData` 类。
- en: 'Now, add the `InsertProductEFSP` method:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `InsertProductEFSP` 方法：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method obtains the connection string from the secrets file and creates
    a new instance of the `EntityFrameworkCoreData` class. It then builds up the properties
    needed for the stored procedure insert via `SqlCommandModel`. Then, it executes
    the `ExecuteNonQuerySP` model, passing in the model that executes the insert stored
    procedure, and then disposes of the `EntityFrameworkCoreData` class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并创建 `EntityFrameworkCoreData` 类的新实例。然后，它通过 `SqlCommandModel`
    构建存储过程插入所需的属性。接着，它执行 `ExecuteNonQuerySP` 模型，传入执行插入存储过程的模型，然后释放 `EntityFrameworkCoreData`
    类。
- en: 'Add the `InsertProductDDN` method:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `InsertProductDDN` 方法：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method obtains the connection string from the secrets file, creates a new
    instance of the `DapperDotNet` class, and executes a raw SQL insert statement
    by calling the `ExecuteNonQuery` method. It then disposes of the `DapperDotNet`
    class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，创建 `DapperDotNet` 类的新实例，并通过调用 `ExecuteNonQuery` 方法执行原始 SQL
    插入语句。然后，它释放 `DapperDotNet` 类。
- en: 'Add the `InsertProductDDNSP` method:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `InsertProductDDNSP` 方法：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method gets the connection string from the secrets file and creates a new
    `DapperDotNet` class. It then builds the `SqlCommandModel` properties required
    to execute the product insert stored procedure. Then, it calls the `ExecuteNonQuery`
    procedure, passing in the model that will execute the stored procedure. It then
    disposes of the `DapperDotNet` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并创建一个新的 `DapperDotNet` 类。然后，它构建执行产品插入存储过程所需的 `SqlCommandModel`
    属性。接着，它调用 `ExecuteNonQuery` 过程，传入将执行存储过程的模型。然后，它释放 `DapperDotNet` 类。
- en: That concludes our look at insert benchmarking methods. Now, we will start writing
    our selection benchmarking methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对插入基准测试方法的探讨。现在，我们将开始编写我们的选择基准测试方法。
- en: Benchmarking data selection methods
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据选择方法基准测试
- en: 'In this section, we will be writing our benchmarking methods that will test
    the performance of various data selection methods. These benchmarks will be run
    and analyzed in the last section of this chapter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写我们的基准测试方法，以测试各种数据选择方法的性能。这些基准测试将在本章的最后部分运行和分析：
- en: 'Add the `ReadScalarProductADN` method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadScalarProductADN` 方法：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method obtains the connection from the `secrets` file, creates a new `AdoDotNetData`
    class, and executes the `ExecuteScalar` method, passing in a raw SQL statement
    that returns a string. It then disposes of the `AdoDotNet` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从 `secrets` 文件中获取连接，创建一个新的 `AdoDotNetData` 类，并执行 `ExecuteScalar` 方法，传入一个返回字符串的原始
    SQL 语句。然后，它释放 `AdoDotNet` 类。
- en: 'Add the `ReadScalarADNSP` method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadScalarADNSP` 方法：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method obtains the connection string from the secrets file and creates
    a new instance of the `AdoDotNetData` class. It then builds `SqlCommandModel`
    up that contains the necessary properties to execute the scalar stored procedure.
    Then, it calls the `ExecuteScalar` method, passing in the model that executes
    the stored procedure, and returns the product name. It then disposes of the `AdoDotNetData`
    class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `AdoDotNetData` 类的新实例。然后，它构建 `SqlCommandModel`，其中包含执行标量存储过程的必要属性。然后，它调用
    `ExecuteScalar` 方法，传入执行存储过程的模型，并返回产品名称。然后，它释放 `AdoDotNetData` 类。
- en: 'Add the `ReadFilteredProductADN` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadFilteredProductADN` 方法：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `AdoDotNetData` class. It then executes the `ExecuteReader` method,
    which takes a raw SQL statement and returns an enumerator of the `Product` type,
    and then disposes of the `AdoDotNetData` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `AdoDotNetData` 类的新实例。然后，它执行 `ExecuteReader` 方法，该方法接受一个原始
    SQL 语句并返回 `Product` 类型的枚举器，然后释放 `AdoDotNetData` 类。
- en: 'Add the `ReadFilteredProductADNSP` method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadFilteredProductADNSP` 方法：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `AdoDotNetData` class. It then builds up `SqlCommandModel` that
    contains the properties that are required to execute the read stored procedure.
    Then, it executes the `ExecuteReader` method, which returns an enumerator, and
    then disposes of the `AdoDotNetData` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `AdoDotNetData` 类的新实例。然后，它构建包含执行读取存储过程所需属性的 `SqlCommandModel`。然后，它执行返回枚举器的
    `ExecuteReader` 方法，然后释放 `AdoDotNetData` 类。
- en: 'Add the `ReadScalarProductEF` method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadScalarProductEF` 方法：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `EntityFrameworkCore` method. It then gets the first item in the
    `Product` collection that matches the filter and assigns `ProductName`. Then,
    it disposes of the `EntityFrameworkCore` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `EntityFrameworkCore` 类的新实例。然后，它获取与过滤器匹配的 `Product` 集合中的第一个项目并分配
    `ProductName`。然后，它释放 `EntityFrameworkCore` 类。
- en: 'Add `ReadScalarProductEFSP`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadScalarProductEFSP`：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method gets the connection string from the secrets file and then creates
    a new instance of the `EntityFrameworkCoreData` class. Then, it calls the `ExecuteScalarSP`
    method, passing in the name of the filter, returning the first `ProductName` that
    matches the filter, and then disposes of the `EntityFrameworkCoreData` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `EntityFrameworkCoreData` 类的新实例。然后，它调用 `ExecuteScalarSP`
    方法，传入过滤器的名称，返回匹配过滤器的第一个 `ProductName`，然后释放 `EntityFrameworkCoreData` 类。
- en: 'Add the `ReadFilteredProductsEF` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadFilteredProductsEF` 方法：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method gets the connection string from the secrets file and then creates
    an instance of the `EntityFrameworkCoreData` class. It then filters the products
    and returns an enumerator of products. Then, the method disposes of the `EntityFrameworkCoreData`
    class and the enumerator.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `EntityFrameworkCoreData` 类的新实例。然后，它过滤产品并返回产品的枚举器。然后，该方法释放
    `EntityFrameworkCoreData` 类和枚举器。
- en: 'Add the `ReadFilteredProductsEFSP` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadFilteredProductsEFSP` 方法：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method gets the secret from the secrets file and creates a new instance
    of the `EntityFrameworkCoreData` class. It then calls the `ExecuteReaderSP` method,
    which executes a stored procedure that returns an enumerator of the `Products`
    type. Then, the method disposes of the `EntityFrameworkCoreData` class and the
    enumerator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取密钥并创建 `EntityFrameworkCoreData` 类的新实例。然后，它调用 `ExecuteReaderSP` 方法，该方法执行返回
    `Products` 类型枚举器的存储过程。然后，该方法释放 `EntityFrameworkCoreData` 类和枚举器。
- en: 'Add the `ReadScalarProductDDN` method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadScalarProductDDN` 方法：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. It then executes the `ExecuteScalar` method,
    passing in a raw SQL statement that returns the top `ProductName` that matches
    the filter. Then, it disposes of the `DapperDotNet` class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `DapperDotNet` 类的新实例。然后，它执行 `ExecuteScalar` 方法，传入一个返回匹配过滤器的顶级
    `ProductName` 的原始 SQL 语句。然后，它释放 `DapperDotNet` 类。
- en: 'Add the `ReadScalarProductDDNSP` method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadScalarProductDDNSP` 方法：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. Then, the method builds `SqlCommandModel`
    that contains the properties necessary to execute a stored procedure. It then
    calls the `ExecuteScalarSP` method, passing in the model. The `ProductName` of
    the first matching product is returned. The method then disposes of the `DapperDotNet`
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并创建 `DapperDotNet` 类的新实例。然后构建包含执行存储过程所需属性的 `SqlCommandModel`。然后调用
    `ExecuteScalarSP` 方法，传入模型。返回第一个匹配产品的 `ProductName`。然后释放 `DapperDotNet` 类。
- en: 'Add the `ReadFilteredProductsDDN` class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadFilteredProductsDDN` 类：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method gets the connection string from the `secrets` file and then creates
    a new instance of the `DapperDotNet` class. It then calls the `ExecuteReader`
    method, passing in a raw SQL statement. An enumerator of the `Product` type is
    returned. `DapperDotNet` and the enumerator are then disposed of.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从 `secrets` 文件中获取连接字符串，然后创建 `DapperDotNet` 类的新实例。然后调用 `ExecuteReader` 方法，传入一个原始
    SQL 语句。返回 `Product` 类型的枚举器。然后释放 `DapperDotNet` 和枚举器。
- en: 'Add the `ReadFilteredProductsDDNSP` method:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ReadFilteredProductsDDNSP` 方法：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method gets the connection string from the secrets file and then creates
    an instance of the `DapperDotNet` class. It then builds up a `SqlCommandModel`
    that has the properties needed to execute a stored procedure. It then calls `ExcuteReaderSP`,
    passing in the model that returns an enumerator of the `Product` type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，然后创建 `DapperDotNet` 类的实例。接着构建一个 `SqlCommandModel`，其中包含执行存储过程所需的属性。然后调用
    `ExcuteReaderSP` 方法，传入返回 `Product` 类型枚举器的模型。
- en: We have now finished writing our selection benchmarks. Now, we'll move on to
    writing our update benchmarks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了选择基准的编写。接下来，我们将继续编写更新基准。
- en: Benchmarking data editing methods
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试数据编辑方法
- en: 'In this section, we will be writing our benchmarks that test the performance
    of various update statements. These benchmarks will be run and analyzed in the
    final section of this chapter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写测试各种更新语句性能的基准。这些基准将在本章的最后部分运行和分析：
- en: 'Add the `UpdateProductADN` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UpdateProductADN` 方法：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method obtains the `connection` string from the `secrets` file and then
    creates a new instance of the `AdoDotNetData` class. It then calls the `ExecuteNonQuery`
    product, passing in a raw SQL statement, then returns the number of records affected
    and disposes of the `AdoDotNetData` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从 `secrets` 文件中获取 `connection` 字符串，然后创建 `AdoDotNetData` 类的新实例。然后调用 `ExecuteNonQuery`
    产品，传入一个原始 SQL 语句，然后返回受影响的记录数，并释放 `AdoDotNetData` 类。
- en: 'Add the `UpdateProductADNSP` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UpdateProductADNSP` 方法：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `AdoDotNetData` class. `SqlCommandModel` is then built up with
    the properties needed to execute the update stored procedure. `ExecuteNonQuery`
    is then called with the model being passed in, and the stored procedure that performs
    the update is executed. The `AdoDotNetData` class is then disposed of.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并创建 `AdoDotNetData` 类的新实例。然后构建 `SqlCommandModel`，其中包含执行更新存储过程所需的属性。然后使用传入的模型调用
    `ExecuteNonQuery`，并执行执行更新的存储过程。然后释放 `AdoDotNetData` 类。
- en: 'Add the `UpdateProductEF` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UpdateProductEF` 方法：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `EntityFrameworkCoreData` class. It then declares and assigns
    a queryable collection of products. This collection is then iterated with the
    name of each product updated. The `UpdateRange` method is then called on the `Products`
    collection, and the updated collection is passed in. The modifications are then
    saved, and the `EntityFrameworkCoreData` class is disposed of.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，并创建 `EntityFrameworkCoreData` 类的新实例。然后声明并分配一个产品查询集合。然后遍历每个产品的名称进行更新。然后在
    `Products` 集合上调用 `UpdateRange` 方法，并将更新后的集合传入。然后保存修改，并释放 `EntityFrameworkCoreData`
    类。
- en: 'Add the `UpdateProductEFSP` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UpdateProductEFSP` 方法：
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method gets the connection string from the `secrets` file and creates an
    instance of the `EntityFrameworkCoreData` class. It then builds up the `SqlCommandModel`
    that contains the properties needed to generate the call to the update stored
    procedure. The method then calls the `ExecuteNonQuerySP` procedure, which executes
    the stored procedure, passing in the model, and then disposes of the `EntityFrameworkCoreData`
    method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从`secrets`文件中获取连接字符串并创建`EntityFrameworkCoreData`类的实例。然后构建包含生成更新存储过程调用所需属性的`SqlCommandModel`。该方法随后调用`ExecuteNonQuerySP`过程，执行存储过程，传入模型，然后释放`EntityFrameworkCoreData`方法。
- en: 'Add the `UpdateProductDDN` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`UpdateProductDDN`方法：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. It then calls the `ExecuteNonQuery` method,
    passing in a raw SQL update statement. The number of records affected is returned,
    and the `DapperDotNet` class is disposed of.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建`DapperDotNet`类的新实例。然后调用`ExecuteNonQuery`方法，传入一个原始的SQL更新语句。返回受影响的记录数，并释放`DapperDotNet`类。
- en: 'Add the `UpdateProductDDNSP` method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`UpdateProductDDNSP`方法：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. It then builds an `SQLCommandModel` in preparation
    for executing a stored procedure. It calls the `ExecuteNonQuery` method, passing
    in the model. The stored procedure is executed, and the method disposes of the
    `DapperDotNet` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建`DapperDotNet`类的新实例。然后构建一个`SQLCommandModel`以准备执行存储过程。它调用`ExecuteNonQuery`方法，传入模型。执行存储过程，然后释放`DapperDotNet`类。
- en: This is the end of our look at the update benchmarks. Now for our final set
    of benchmark methods. In the next section, we will write our deletion benchmarks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对更新基准测试的总结。现在，让我们来看最终的基准测试方法集。在下一节中，我们将编写我们的删除基准测试。
- en: Benchmarking data deletion methods
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试删除数据方法
- en: 'In this section, we write our benchmarks for measuring the performance of our
    deletion methods. These benchmarks will be run and analyzed in the next section:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们编写了测量我们删除方法性能的基准测试。这些基准测试将在下一节中进行运行和分析：
- en: 'Add the `DeleteProductADN` method:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`DeleteProductADN`方法：
- en: '[PRE25]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method gets the connection string from the secrets file. It then creates
    an instance of the `AdoDotNetData` class. Then, the method calls the `ExecuteNonQuery`
    method, passing into it a raw SQL delete statement. It then disposes of the `AdoDotNetData`
    class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串。然后创建`AdoDotNetData`类的实例。然后，该方法调用`ExecuteNonQuery`方法，向其中传递一个原始的SQL删除语句。然后释放`AdoDotNetData`类。
- en: 'Add the `DeleteProductADNSP` method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`DeleteProductADNSP`方法：
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method gets the connection string from the secrets file, and then it creates
    an instance of the `AdoDotNetData` class. `SqlCommandModel` is built up with the
    properties required for the delete stored procedure execution. The model is then
    passed into the `ExecuteNonQuery` model, which executes the stored procedure,
    and the `AdoDotNetData` class is then disposed of.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，然后创建`AdoDotNetData`类的实例。使用执行删除存储过程所需的属性构建`SqlCommandModel`。然后，将模型传递给`ExecuteNonQuery`模型，执行存储过程，并释放`AdoDotNetData`类。
- en: 'Add the `DeleteProductEF` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`DeleteProductEF`方法：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method gets the connection string from the secrets file and then creates
    an instance of the `EntityFrameworkCoreData` class. A queryable collection of
    products is then returned, matching the deletion criteria. This collection is
    then passed into the `RemoveRange` method of the `Products` collection, and the
    modification is saved with those items removed from the database. The method then
    disposes of the `EntityFrameworkCoreData` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串，然后创建`EntityFrameworkCoreData`类的实例。然后返回一个可查询的产品集合，匹配删除标准。然后将此集合传递给`Products`集合的`RemoveRange`方法，并保存修改，从数据库中删除这些项目。然后释放`EntityFrameworkCoreData`类。
- en: 'Add the `DeleteProductEFSP` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`DeleteProductEFSP`方法：
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method gets the connection string from the secrets file and creates an
    instance of the `EntityFrameworkCoreData` class. It then builds up a `SqlCommandModel`
    that contains the properties of the deletion stored procedure. The `ExecuteNonQuerySP`
    method is called with the model that is passed in, the deletion stored procedure
    is executed, and the `EntityFrameworkCoreData` class is disposed of.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `EntityFrameworkCoreData` 类的实例。然后构建一个包含删除存储过程属性的 `SqlCommandModel`。使用传入的模型调用
    `ExecuteNonQuerySP` 方法，执行删除存储过程，并释放 `EntityFrameworkCoreData` 类。
- en: 'Add the `DeleteProductDDN` method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DeleteProductDDN` 方法：
- en: '[PRE29]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method gets the connection string from the secrets file and creates an
    instance of the `DapperDotNet` class. It then calls the `ExecuteNonQuery` method,
    passing into that method a raw SQL delete statement. The deletion is carried out
    and the number of records affected is returned. The `DapperDotNet` class is then
    disposed of.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `DapperDotNet` 类的实例。然后调用 `ExecuteNonQuery` 方法，向该方法传递一个原始
    SQL 删除语句。执行删除操作并返回受影响的记录数。然后释放 `DapperDotNet` 类。
- en: 'Add the `DeleteProductDDNSP` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DeleteProductDDNSP` 方法：
- en: '[PRE30]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method gets the connection string from the secrets file and creates an
    instance of the `DapperDotNet` class. It then builds up the `SqlCommandModel`,
    containing stored procedure properties. This model is then passed into the `ExecuteNonQuery`
    method, which executes the stored procedure, and the `DapperDotNet` class is disposed
    of.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从密钥文件中获取连接字符串并创建 `DapperDotNet` 类的实例。然后构建包含存储过程属性的 `SqlCommandModel`。此模型随后传递给
    `ExecuteNonQuery` 方法，执行存储过程，并释放 `DapperDotNet` 类。
- en: 'That was the last of our benchmarking methods. There is just one more job to
    do before we are able to run our benchmarks. Update the `Program` class as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的基准测试方法的最后一种。在我们能够运行基准测试之前，还有一项工作要做。按照以下方式更新 `Program` 类：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Main` method executes the `BenchmarkTests` class. You can now do a release
    build to run the benchmarks. The program will take a while to execute, so you
    will need to be patient. In the next section, we will analyze the results of our
    various benchmarks to find out the most performant ways of performing inserts,
    selections, updates, and deletions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法执行 `BenchmarkTests` 类。你现在可以执行发布构建来运行基准测试。程序将需要一段时间来执行，所以你需要耐心等待。在下一节中，我们将分析我们各种基准测试的结果，以找出执行插入、选择、更新和删除操作的最有效方式。'
- en: The benchmarking results and their analysis
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试结果及其分析
- en: Before we analyze the results, it is worth noting some big data statistics from
    2020\. Google gets more than 40,000 queries per second. This equates to 3,456,000,000
    queries per day. There are 65,000,000,000 WhatsApp business app messages sent
    per day. In the course of 24 hours, there are 1,440 minutes, which is 86,400 seconds,
    which is 86,400,000 milliseconds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分析结果之前，值得注意一些 2020 年的大数据统计信息。谷歌每秒有超过 40,000 个查询。这相当于每天 345,600,000 个查询。每天发送
    650,000,000,000 条 WhatsApp 商务应用消息。在 24 小时内，有 1,440 分钟，即 86,400 秒，即 86,400,000
    毫秒。
- en: 'Here is our benchmark summary report:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的基准摘要报告：
- en: '![Figure 11.1 – Data access benchmark summary'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 数据访问基准摘要'
- en: '](img/B16617_11_01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_11_01.jpg)'
- en: Figure 11.1 – Data access benchmark summary
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 数据访问基准摘要
- en: 'Let''s discuss the insert statements first. The results are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论插入语句。结果如下：
- en: '`InsertProductDDNSP` = 1.841 ms'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertProductDDNSP` = 1.841 毫秒'
- en: '`InsertProductADNSP` = 1.894 ms'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertProductADNSP` = 1.894 毫秒'
- en: '`InsertProductDDN` = 2.058 ms'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertProductDDN` = 2.058 毫秒'
- en: '`InsertProductADN` = 2.092 ms'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertProductADN` = 2.092 毫秒'
- en: '`InsertProductEF` = 2.196 ms'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertProductEF` = 2.196 毫秒'
- en: '`InsertProductEFSP` = 396.509 ms'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertProductEFSP` = 396.509 毫秒'
- en: From the summary, we can see that the best-performing insert statement is the
    Dapper.NET stored procedure insert, taking approximately 1.841 ms to execute,
    followed by `InsertProductADNSP`, which takes approximately 1.894 ms to execute.
    By far the worst performer is the `InsertProductEFSP` method, which takes 396.509
    ms to execute. As we can see from these methods, even though we have six different
    ways of inserting data, they all perform at different speeds. When performance
    is a serious issue, your best option is to use Dapper.NET stored procedure execution
    or ADO.NET stored procedure execution when inserting data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从总结中我们可以看出，执行速度最快的插入语句是 Dapper.NET 存储过程插入，大约需要 1.841 毫秒来执行，其次是 `InsertProductADNSP`，大约需要
    1.894 毫秒来执行。迄今为止，表现最差的是 `InsertProductEFSP` 方法，需要 396.509 毫秒来执行。从这些方法中我们可以看出，尽管我们有六种不同的数据插入方式，但它们的执行速度各不相同。当性能成为一个严重问题时，您最好的选择是在插入数据时使用
    Dapper.NET 存储过程执行或 ADO.NET 存储过程执行。
- en: 'We will now look at scalar operations, starting with an ordered list of method
    performance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看标量操作，首先是一个方法性能的有序列表：
- en: '`ReadScalarProductDDN` = 1.403 ms'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadScalarProductDDN` = 1.403 毫秒'
- en: '`ReadScalarProductADN` = 1.407 ms'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadScalarProductADN` = 1.407 毫秒'
- en: '`ReadScalarProductADNSP` = 1.433 ms'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadScalarProductADNSP` = 1.433 毫秒'
- en: '`ReadScalarProductDDNSP` = 1.514 ms'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadScalarProductDDNSP` = 1.514 毫秒'
- en: '`ReadScalarProductEFSP` = 53.235 ms'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadScalarProductEFSP` = 53.235 毫秒'
- en: '`ReadScalarProductEF` = 396.509 ms'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadScalarProductEF` = 396.509 毫秒'
- en: Looking at these results, the Dapper.NET raw SQL execution takes approximately
    1.403 ms, followed by the ADO.NET raw SQL execution at 1.407 ms. Both the Entity
    Framework Core methods perform much more slowly. So, when performance matters,
    you are best off using Dapper.NET or ADO.NET raw SQL queries to obtain scalar
    values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这些结果，Dapper.NET 原生 SQL 执行大约需要 1.403 毫秒，其次是 ADO.NET 原生 SQL 执行，需要 1.407 毫秒。两个
    Entity Framework Core 方法执行速度要慢得多。因此，当性能很重要时，您最好使用 Dapper.NET 或 ADO.NET 原生 SQL
    查询来获取标量值。
- en: 'Next are the filtered list queries. Here is an ordered list of the results:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是过滤列表查询。以下是结果列表：
- en: '`ReadFilteredProductsADNSP` = 1.078 ms'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFilteredProductsADNSP` = 1.078 毫秒'
- en: '`ReadFilteredProductsADN` = 1.084 ms'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFilteredProductsADN` = 1.084 毫秒'
- en: '`ReadFilteredProductsEFSP` = 1.187 ms'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFilteredProductsEFSP` = 1.187 毫秒'
- en: '`ReadFilteredProductsEF` = 1.305 ms'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFilteredProductsEF` = 1.305 毫秒'
- en: '`ReadFilteredProductsDDNSP` = 1.529 ms'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFilteredProductsDDNSP` = 1.529 毫秒'
- en: '`ReadFilteredProductsDDN` = 199.910 ms'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFilteredProductsDDN` = 199.910 毫秒'
- en: As we can see from these results, ADO.NET raw SQL and stored procedure access
    perform the best at 1.078 ms and 1.084 ms, respectively. Surprisingly, this time
    it is Dapper.NET that performs the worst when it comes to raw SQL and stored procedure
    access. So, when performance matters for performing queries that return multiple
    records, you are best off using ADO.NET.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果中我们可以看出，ADO.NET 原生 SQL 和存储过程访问表现最佳，分别为 1.078 毫秒和 1.084 毫秒。令人惊讶的是，这次在原生
    SQL 和存储过程访问方面表现最差的是 Dapper.NET。因此，当执行返回多个记录的查询时，性能很重要，您最好使用 ADO.NET。
- en: 'Now, we turn our attention to performing updates. Here is an ordered list of
    our results:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向执行更新操作。以下是我们的结果列表：
- en: '`UpdateProductADNSP` = 1.562 ms'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateProductADNSP` = 1.562 毫秒'
- en: '`UpdateProductEFSP` = 1.964 ms'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateProductEFSP` = 1.964 毫秒'
- en: '`UpdateProductDDNSP` = 1.891 ms'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateProductDDNSP` = 1.891 毫秒'
- en: '`UpdateProductDDN` = 2.297 ms'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateProductDDN` = 2.297 毫秒'
- en: '`UpdateProductADN` = 3.583 ms'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateProductADN` = 3.583 毫秒'
- en: '`UpdateProductEF` = 5,304.279 ms'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateProductEF` = 5,304.279 毫秒'
- en: From these results, **the clear winner is the ADO.NET stored procedure access
    at** **1.562 ms**. The worst performer is the Entity Framework Core update method.
    When performance matters, use ADO.NET stored procedures to update database records.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果中，**明显的胜者是 ADO.NET 存储过程访问，其时间为 1.562 毫秒**。表现最差的是 Entity Framework Core
    更新方法。当性能很重要时，使用 ADO.NET 存储过程来更新数据库记录。
- en: 'Finally, we''ll look at our deletion benchmarks. Here is an ordered list of
    our results:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看我们的删除基准测试结果。以下是结果列表：
- en: '`DeleteProductADNSP` = 1.760 ms'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteProductADNSP` = 1.760 毫秒'
- en: '`DeleteProductDDNSP` = 1.863 ms'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteProductDDNSP` = 1.863 毫秒'
- en: '`DeleteProductEFSP` = 2.012 ms'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteProductEFSP` = 2.012 毫秒'
- en: '`DeleteProductDDN` = 2.522 ms'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteProductDDN` = 2.522 毫秒'
- en: '`DeleteProductADN` = 6.263 ms'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteProductADN` = 6.263 毫秒'
- en: '`DeleteProductEF` = 386.716 ms'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteProductEF` = 386.716 毫秒'
- en: It can be seen that the worst performer is the Entity Framework Core method,
    taking about 386.716 ms to execute. On the other hand, the best performer is the
    ADO.NET stored procedure method, which takes only 1.760 ms, with the Dapper.NET
    stored procedure next, taking 1.863 ms. So, when performance matters, your best
    deletion strategy is to use ADO.NET stored procedures.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，表现最差的是 Entity Framework Core 方法，执行时间约为 386.716 毫秒。另一方面，表现最佳的是 ADO.NET 存储过程方法，它只需
    1.760 毫秒，其次是 Dapper.NET 存储过程，耗时 1.863 毫秒。因此，当性能很重要时，您最佳的删除策略是使用 ADO.NET 存储过程。
- en: What can we summarize from these results?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能从这些结果中总结出什么？
- en: Dapper.NET and ADO.NET come out on top when performing insert, read, update,
    and delete operations. The performance varies between raw SQL and stored procedure
    execution. When performance is critical, it would seem that the best strategy
    is rather than choosing just one framework and using only that one for all your
    data operations, to use a hybrid approach.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行插入、读取、更新和删除操作时，Dapper.NET 和 ADO.NET 表现最佳。性能在原始 SQL 和存储过程执行之间有所不同。当性能至关重要时，似乎最好的策略不是只选择一个框架，并仅使用该框架进行所有数据操作，而是采用混合方法。
- en: With a hybrid approach to data access, you will use a combination of data access
    frameworks. From each framework, you will decide on the best performer and use
    that for your data operation. In the case of our benchmarks, we would use two
    frameworks. The frameworks chosen are ADO.NET and Dapper.NET. This way, we could
    find the best performance possible for each type of data operation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 采用数据访问的混合方法，您将使用数据访问框架的组合。从每个框架中，您将决定最佳性能者并使用它进行数据操作。在我们的基准测试中，我们会使用两个框架。选择的框架是
    ADO.NET 和 Dapper.NET。这样，我们就能为每种类型的数据操作找到最佳性能。
- en: But given that these times only have millisecond differences, why does such
    performance matter?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，鉴于这些时间只有毫秒级的差异，为什么这样的性能很重要？
- en: 'Well, remember at the beginning of this section how we mentioned the big data
    statistics for 2020? The following table shows the performance of these methods
    when put into the context of big data search queries and app message storage:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，记得在本节开头我们提到了 2020 年的大数据统计吗？以下表格显示了这些方法在大数据搜索查询和应用程序消息存储中的应用性能：
- en: '![Table 10.1 – Big data operation durations if SQL Server were used to store
    and read data'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 10.1 – 如果使用 SQL Server 存储和读取数据的大数据操作持续时间'
- en: '](img/Table_10.1.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_10.1.jpg)'
- en: Table 10.1 – Big data operation durations if SQL Server were used to store and
    read data
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 – 如果使用 SQL Server 存储和读取数据的大数据操作持续时间
- en: These benchmarks were run on an HP laptop with an Intel Core i5-6300U CPU 2.40
    GHz (Skylake) processor. This is one CPU with four logical cores and two physical
    cores. I have 8 GB of RAM and a 256 GB SSD.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准测试是在一台配备 Intel Core i5-6300U CPU 2.40 GHz（Skylake）处理器的 HP 笔记本电脑上运行的。这是一台具有四个逻辑核心和两个物理核心的
    CPU。我有 8 GB 的 RAM 和 256 GB 的 SSD。
- en: If the SQL Server on my laptop were used and I had the space available (which
    I don't) to store the WhatsApp business app message data, depending upon which
    method I used to insert the data, it would take between 1,385.01157 and 298,299.595
    processing days on my laptop. If my laptop were used to retrieve Google search
    results from my SQL Server, then it would take between 43.12 and 7,996.4 processing
    days to retrieve those results.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我的笔记本电脑上使用 SQL Server，并且我有足够的空间（我没有）来存储 WhatsApp 商务应用的消息数据，那么根据我使用的方法插入数据，它将在我笔记本电脑上需要
    1,385.01157 到 298,299.595 天的处理时间。如果我的笔记本电脑用于从 SQL Server 获取 Google 搜索结果，那么检索这些结果将需要
    43.12 到 7,996.4 天的处理时间。
- en: This real-life application of the benchmarks to actual big data volumes based
    on the big data statistics of 2020 shows the importance of computer infrastructure
    and the type of investment that would be needed to make these searches and message
    sending and receiving instantaneous. It was important to have peak performance
    when working with such large datasets.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准测试在 2020 年大数据统计的基础上，将实际的大数据量应用于实际的大数据，显示了计算机基础设施和所需的投资类型的重要性，以便使这些搜索、消息发送和接收即时。在处理如此大的数据集时，达到峰值性能非常重要。
- en: Tweaking large datasets through code can only go so far. That is why server
    computers have many more processors and disks, along with more memory, than your
    normal day-to-day workstations and home computers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代码调整大数据集只能走这么远。这就是为什么服务器计算机比您正常的日常工作站和家庭计算机拥有更多的处理器、磁盘，以及更多的内存。
- en: The key thing to take away from this chapter is that whenever you are deciding
    on a way forward to maximize performance, experiment and benchmark. Along with
    that, take the time to choose your physical infrastructure carefully.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中要吸取的关键点是，无论何时你在决定前进的方式以最大化性能时，都要进行实验和基准测试。同时，花时间仔细选择你的物理基础设施。
- en: Another thing to bear in mind when using a cloud host is the cost per data execution
    and cost per hour when running virtual machines. Then, there is the cost of data
    throughput and data storage saving and retrieval. With figures of apps such as
    Google and WhatsApp being in the billions, if you were to be that successful,
    could you imagine the running costs involved? That is why performance in today's
    competitive market is also so important. The quicker a piece of code executes
    in the cloud, the cheaper the price. The longer a piece of code takes to run,
    the more expensive it becomes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用云主机时，还需要记住的是，运行虚拟机时的每数据执行成本和每小时成本。然后，还有数据吞吐量和数据存储节省及检索的成本。考虑到像谷歌和WhatsApp这样的应用程序的数字以亿计，如果你能取得那样的成功，你能想象涉及的运行成本吗？这就是为什么在今天的竞争市场中，性能也是如此重要的原因。代码在云中执行得越快，价格就越便宜。代码运行时间越长，成本就越高。
- en: As an example, if you have an Azure function that performs your data operations
    that are located in the West US region on the Consumption tier using a memory
    size of 128 with an execution time of 1.078 ms and 65,000,000,000 executions per
    month, then your bill for the month would be US$13,133.54\. But if your execution
    time was 396.509 ms, then your bill for the month would be US$64,539.57\. So,
    doing the same code action can mean a difference of 64,539.57 – 12,133.54 = US$52,406.03
    per month on cloud expenditure operations. I am sure you would not want to spend
    that much money on such outgoings, and that does not even include the cost of
    the SQL Server instances!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个Azure函数，它在西美国区域消费层上执行你的数据操作，使用128MB的内存大小，执行时间为1.078毫秒，每月执行65,000,000,000次，那么你一个月的账单将是13,133.54美元。但如果你的执行时间是396.509毫秒，那么你一个月的账单将是64,539.57美元。所以，执行相同的代码操作可以在云支出操作上每月产生64,539.57
    - 12,133.54 = 52,406.03美元的差异。我敢肯定你不会愿意在这样的大额支出上花费这么多钱，而且这还不包括SQL Server实例的成本！
- en: That concludes this rather long chapter, and so we will now summarize what we
    have learned.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这个相当长的章节，因此我们现在将总结我们所学的知识。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to perform inserts, selections, updates, and
    deletes in SQL Server. We learned how to perform these operations in different
    ways using pure ADO.NET, Entity Framework Core, and Dapper.NET. The different
    data operations were performed using raw SQL and stored procedures.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在SQL Server中执行插入、选择、更新和删除操作。我们学习了如何使用纯ADO.NET、Entity Framework Core和Dapper.NET以不同的方式执行这些操作。不同的数据操作是通过原始SQL和存储过程来执行的。
- en: To understand the performance of each of these data access methods of the different
    data access frameworks, in this chapter, we benchmarked their runtime performance
    using `BenchmarkDotNet`. We saw that both Dapper.NET and ADO.NET performed better
    than Entity Framework Core in most cases and that even with these two frameworks,
    the performance varied considerably.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解不同数据访问框架的每种数据访问方法的性能，在本章中，我们使用`BenchmarkDotNet`对它们的运行时性能进行了基准测试。我们发现，在大多数情况下，Dapper.NET和ADO.NET的性能优于Entity
    Framework Core，即使在这两个框架中，性能也有很大的差异。
- en: We concluded that rather than just adopting a single data access technology,
    in some situations where performance really matters, it could be beneficial to
    employ a hybrid approach to data access. With a hybrid approach, you use the best
    framework and method within that framework for the data access task in question.
    That way, you maximize your overall performance. This can also be critical in
    terms of keeping your infrastructure expenses down, especially when the infrastructure
    you are employing is a third-party cloud provider with your monthly bill being
    in the thousands of dollars.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，与其仅仅采用单一的数据访问技术，在某些性能至关重要的场合，采用混合数据访问方法可能更有益。采用混合方法，你将使用针对特定数据访问任务的最佳框架和该框架内的最佳方法。这样，你可以最大化整体性能。这在降低基础设施费用方面也可能至关重要，尤其是在你使用的是第三方云提供商，并且你的月度账单达到数千美元的情况下。
- en: But apart from computer code performance enhancements, we also studied big data
    volumes and calculated the number of processing days it would take to perform
    query and data insert operations when the volumes involved are in the billions.
    So, apart from code performance, we also came to understand that it is necessary
    to choose the right kind of infrastructure, which also comes at a price when using
    cloud services.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了计算机代码性能提升之外，我们还研究了大数据量，并计算了当涉及的数据量达到数十亿时，执行查询和数据插入操作所需的天数。因此，除了代码性能之外，我们还认识到选择正确的基础设施也是必要的，这在使用云服务时也会带来一定的成本。
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Whatever you are doing, whenever performance is a critical business requirement,
    you are strongly advised to experiment and provide your own benchmarks. Based
    on your results, you can then choose your own methods of data access that you
    feel are most beneficial for your needs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做什么，只要性能是关键的商业需求，强烈建议你进行实验并提供自己的基准测试。根据你的结果，你可以选择你认为最适合你需求的数据访问方法。
- en: In the next chapter, we will be looking at improving the performance of SQL
    Server and Cosmos DB. But before we do, have a go at the following questions to
    see how well you have retained the information contained in this chapter. Also,
    there are very useful articles in the *Further reading* section that expand upon
    what has been covered in this chapter. This chapter purely focused on identifying
    the best data access methods in code using three different frameworks. But in
    the *Further reading* section, you will find topics that are specific to improving
    database performance that are well worth reading about.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨提高 SQL Server 和 Cosmos DB 的性能。但在我们这样做之前，先尝试回答以下问题，看看你对本章包含的信息掌握得如何。此外，*进一步阅读*部分有一些非常有用的文章，可以扩展本章所涵盖的内容。本章纯粹关注使用三个不同的框架在代码中识别最佳数据访问方法。但在*进一步阅读*部分，你会发现一些专门针对提高数据库性能的主题，这些主题非常值得一读。
- en: Questions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which data access method was fastest when inserting data?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入数据时哪种数据访问方法最快？
- en: Which data access method was fastest when selecting a scalar value?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择标量值时哪种数据访问方法最快？
- en: Which data access method was fastest when selecting multiple records?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择多个记录时哪种数据访问方法最快？
- en: Which data access method was fastest when updating data?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据时哪种数据访问方法最快？
- en: Which data access method was fastest when deleting data?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除数据时哪种数据访问方法最快？
- en: Should you use one framework for all data access operations and why?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否应该使用一个框架来完成所有数据访问操作，以及为什么？
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Dapper vs Entity Framework vs ADO.NET Performance Benchmarking*: [https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/](https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dapper 与 Entity Framework 与 ADO.NET 性能基准测试*: [https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/](https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/)'
- en: )
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Dapper tutorial: [https://dapper-tutorial.net/dapper](https://dapper-tutorial.net/dapper'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapper 教程：[https://dapper-tutorial.net/dapper](https://dapper-tutorial.net/dapper)
- en: )
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*ADO.NET Tutorial for Beginners and Professionals*: [https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/](https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ADO.NET 初学者和专业人士教程*: [https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/](https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/)'
- en: )
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*SQL Server Database Performance Tuning*: [https://www.brentozar.com/sql/sql-server-performance-tuning/](https://www.brentozar.com/sql/sql-server-performance-tuning/'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQL Server 数据库性能调优*: [https://www.brentozar.com/sql/sql-server-performance-tuning/](https://www.brentozar.com/sql/sql-server-performance-tuning/)'
- en: )
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Book – *High Performance SQL Server: Consistent Response for Mission-Critical
    Applications* by Benjamin Nevarez: [https://amzn.to/3gnUbe7](https://amzn.to/3gnUbe7'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '书籍 – Benjamin Nevarez 著的 *高性能 SQL Server：关键任务应用的一致响应*: [https://amzn.to/3gnUbe7](https://amzn.to/3gnUbe7)'
- en: )
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Performance tips for Azure Cosmos DB and .NET*: [https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql](https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure Cosmos DB 和 .NET 的性能技巧*: [https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql](https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql)'
- en: )
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*A technique for building high-performance databases with EF Core*: [https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/](https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 EF Core 构建高性能数据库的技术*: [https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/](https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/)'
- en: )
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*How to improve SQL Server query performance in .NET*: [https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net](https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在 .NET 中提高 SQL Server 查询性能*: [https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net](https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net)'
- en: '*Using Dapper and SQLKata in .NET Core for High-Performance Application*: [https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210](https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 .NET Core 中使用 Dapper 和 SQLKata 构建高性能应用程序*: [https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210](https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210)'
- en: )
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*What are the best databases for a small .NET application?*: [https://www.slant.co/topics/274/~best-databases-for-a-small-net-application](https://www.slant.co/topics/274/~best-databases-for-a-small-net-application'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对于小型 .NET 应用程序，最好的数据库是什么？*: [https://www.slant.co/topics/274/~best-databases-for-a-small-net-application](https://www.slant.co/topics/274/~best-databases-for-a-small-net-application)'
- en: )
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Point to Remember
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要记住的要点
- en: Reading about performance in a book is all very good. But you should always
    do your own experimentation and benchmarking if performance is very important
    to you. Different hardware architecture and different programming styles will
    yield very different results, and this point is well worth remembering. Network
    usage, security software, and data volumes, along with file input and output,
    can all have an effect on the performance of your application.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在书中阅读关于性能的内容非常好。但如果你非常重视性能，你应该始终进行自己的实验和基准测试。不同的硬件架构和不同的编程风格会产生非常不同的结果，这一点值得牢记。网络使用、安全软件、数据量，以及文件输入和输出，都可能影响你应用程序的性能。
