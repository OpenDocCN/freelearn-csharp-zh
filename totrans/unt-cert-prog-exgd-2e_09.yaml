- en: '*Chapter 9*: Creating a 2D Shop Interface and In-Game HUD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be paying attention to our shop interface and how we
    can improve it visually, as well as its functionality. The current shop works
    well, but we could make it support multiple screen ratios. We could also introduce
    Unity's Event system and Button components, as well as a few other new functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other area we will be visiting in this chapter is the in-game **Heads-Up
    Display** (**HUD**). This is fairly common in games where we have the game''s
    information displayed at a particular location on the screen. We will be displaying
    our player''s lives and score and a mini-map to show where our enemies are. This
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Our in-game HUD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.01_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Our in-game HUD
  prefs: []
  type: TYPE_NORMAL
- en: 'The other half of this chapter will be about improving the 2D visuals of our
    shop scene so that there are choices in terms of the upgrades we can buy and so
    that we can also expand the size of the shop dynamically. Also, your shop scene
    will support any landscape ratio, unlike what it did previously. The following
    screenshot shows what our shop looks like in different ratio sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The left side displays all buttons; the right side cuts off
    the button edges'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.02_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – The left side displays all buttons; the right side cuts off the
    button edges
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous screenshot, notice that the **3:2** screen ratio cuts off some
    of the screen (you will especially notice this from each screen''s selection grid
    spacing) compared to our **1920 x 1080 (16:9)** screen ratio. By the end of this
    chapter, our shop scene will look like the one shown in the following screenshot,
    no matter what landscape ratio our game is in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Our in-game shop with a flexible UI display (no cutoff)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Our in-game shop with a flexible UI display (no cutoff)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our HUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our `shop` scene support alternative screen ratios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying and modifying our `shop` scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by reviewing the core exam skills that will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Core exam skills covered in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the core exam skills that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Working in the art pipeline*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand materials, textures, and shaders, and write scripts that interact
    with Unity's rendering API.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Developing application systems*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpret scripts for application interface flow such as menu systems, UI navigation,
    and application settings.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpret scripts for user-controlled customization such as character creators,
    inventories, storefronts, and in-app purchases.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze scripts for user progression features such as scoring, leveling, and
    in-game economies utilizing technologies such as Unity Analytics and PlayerPrefs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze scripts for 2D overlays, such as HUDs, minimaps, and advertisements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify scripts for saving and retrieving application and user data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Programming for scene and environment design*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify methods for implementing Game Object instantiation, destruction, and
    management.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Optimizing for performance and platforms*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify optimizations to address requirements for specific build platforms
    and/or hardware configurations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine common UI affordances and optimizations for XR platforms.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working in professional software development teams*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_09](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_09)
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: All the content for this chapter is held in this chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3LsxDWC](https://bit.ly/3LsxDWC).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With side-scrolling shooter games, it is common for us to have some form of
    recording of how many lives the player has, what their score is, a time limit,
    power-ups, and more. We are going to apply a typical HUD to show a similar set
    of information. Knowing about HUDs is a requirement of the Unity Programmer Exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, we will have created a HUD for our game that will
    consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Lives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini-map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we add our HUD, we need to decide where it will sit on top of our game
    screen. As an example, we will pick a game so that we can briefly study how its
    HUD information is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be looking at a game called **Super R-Type**, which can be found at
    [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_09/superRtype.jpg](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_09/superRtype.jpg).
    Here, at the bottom of the screen, we can see that its HUD is made up of four
    parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Skill level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behind these details is a black background so that the scene doesn't interfere
    when it comes to reading the HUD.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this section, we''ll start by declaring the HUD space and giving it
    a dark background. To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor, navigate to `Assets/Scene` in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `level1` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `level1` loaded, go to the `Canvas` game object, and select **UI** | **Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A game object called `Image` will appear in the `Canvas` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the previous chapter, we should know that a game object containing an `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Image` game object and select `background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we have created a game object that holds an **Image** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on and scale this game object into its correct placeplace
    so that it can be used as a background for our HUD. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `background` game object still selected, alter the **Rect Transform**
    settings in the **Inspector** window to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: t
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – background Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.04_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – background Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `background` game object should be scaled to the same proportions and centered
    as a white bar at the bottom of the screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Game window showing the placement of our background game object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Game window showing the placement of our background game object
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's darken this `background` game object so that it blends in with our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `background` game object still selected, in the `12`, `13`, `13`,
    `210`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – background color and alpha values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.06_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – background color and alpha values
  prefs: []
  type: TYPE_NORMAL
- en: The `background` game object has changed color from its default white to a dark,
    slightly transparent color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The area for our HUD has been set. The following subsections will go through
    each segment of our HUD and explain how to create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameManager` script. Each life will be grouped neatly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display score**: The script already keeps track of the player''s score, so
    all we need to do is use a **Text** component to keep the information up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mini-map**: The mini-map will work visually similar to a radar, where the
    player will be able to see the wave of enemy opponents approaching them. This
    mini-map will be made using a second camera at a wider angle and will only display
    colored dots instead of the actual ships themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can begin filling the HUD with data that we have already made in our
    script, starting with the player's lives.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the player's lives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player starts the game with three lives. The two typical ways of displaying
    the number of lives to the player are by displaying a number count or showing
    a little icon for each life they have. Let's go for the latter as we can use a
    couple of Unity components we haven't used before.
  prefs: []
  type: TYPE_NORMAL
- en: This section will also include some extra code that will be put into our `GameManager`
    script. This code will run a check to see how many lives the player has. With
    each life that's found, a game object will be created that holds an image.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Horizontal Layout Group component to our game object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All game object lives that will be created will be stored in a game object
    called `lives`. Let''s continue working on the HUD and add the `lives` game object:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Canvas` game object and select **Create empty** from the drop-down list.
    A new empty game object will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the new game object and select `lives`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, position the `lives` game object by adding the **Rect Transform** properties
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – lives Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.07_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – lives Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do to the `lives` game object is to give it a **Horizontal
    Layout Group** component. This component will make it so that when we create an
    image to represent each life the player has, we'll display a spaceship image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Horizontal Layout Group** component will put each spaceship image in
    a stacked order. To add this component, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `lives` game object still selected, click the **Add Component** button
    in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Horizontal Layout Group` until you see it on the list. When you do, select
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 9.8* shows the `lives` game object. We will need to alter some values
    of each `life` image so that they aren''t too large.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the **Horizontal Layout Group** property values to the ones shown in
    the following screenshot (you may need to click the arrow next to **Padding**
    to expand its content):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Horizontal Layout Group property values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.08_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Horizontal Layout Group property values
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created a game object called `lives` that will store and automatically
    order each player's ship image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we are going to create a game object that will house each
    player''s ship image. As an example of what''s to come in the next two sections,
    the following screenshot demonstrates our `lives` game object holding each `life`
    game object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Three lives spaced and in correct proportion'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.09_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Three lives spaced and in correct proportion
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to making a game object called `life` that will store a spaceship
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: Creating images to represent our life count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to create a game object that will hold an **Image**
    component that will be a symbol of the player ship. We will also be sizing it
    specifically so that it's uniform with the other lives it sits with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a game object that holds an **Image** component:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Canvas` game object and select **UI** and then **Image** from the drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the game object, right-click it, and select **Rename** from the drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the newly created game object `life`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an image and color to the **Image** component, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Click the remote button to access which source image is used
    for the Image component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Click the remote button to access which source image is used for
    the Image component
  prefs: []
  type: TYPE_NORMAL
- en: To add a source image to the `life` game object, click the **remote** button
    to the side of **Source Image** (denoted by an arrow in the previous screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the drop-down list, start typing `life` until you see it appear, and then
    click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our ship icon should look like the one shown in the following screenshot. If
    it doesn''t, it may have a **Default** texture type and will need to be changed
    to a **Sprite**. We covered how to change this in [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107),
    *Creating a Shop Scene for Our Game*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Our ship sprite life'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Our ship sprite life
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to change the color of the icon slightly as it's possibly a bit too
    distracting for the player.
  prefs: []
  type: TYPE_NORMAL
- en: With the `life` game object still selected, click the `153`, `177`, `177`, `255`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to tick the **Preserve Aspect** box in the **Image** component so
    our life doesn't lose its proportions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's our `life` game object created. The final thing we need to do to it is
    to turn it into a prefab. As a reminder, the benefits of a prefab are that we
    have a game object with its components, preferences, and settings all stored.
    The prefab will allow us to create as many clones as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn this `life` game object into a prefab, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `life` game object from the `Prefab` folder. That's our prefab
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now delete the `life` game object in the **Hierarchy** window as we will
    be creating this game object with code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Coding our UI life counter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to revisit the `GameManager` script, taking the
    information about the player's life count and displaying it in the form of our
    UI system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a section of the `level1` scene''s `Canvas`
    game object. Within `Canvas` is the HUD `background` game object at the top, followed
    by the `lives` game object. Finally, with our code (which we will write shortly),
    we have created three `life` game objects within our `lives` game object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Our Hierarchy containing a lives game object and its life children'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Our Hierarchy containing a lives game object and its life children
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate the `life` game objects so that they show the same amount as
    our player''s lives, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the file to open `GameManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameManager` script already has an `Awake()` function, which is the first
    thing the script tries to activate once the script becomes active. What we don't
    currently have is a `Start()` function that gets called after `Awake()`.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a `Start()` function in `GameManager` and make it call a method
    that we are going to make shortly, called `SetLivesDisplay`, and send it our `playerLives`
    variable, which is the count of the player's lives.
  prefs: []
  type: TYPE_NORMAL
- en: Like any function, we can place it anywhere within the class, as long as it's
    not inside another method/function. I typically keep my `Awake()` and `Start()`
    functions near the top of the `GameManager` class. To call the custom method in
    the `Start()` function, do the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the `GameManager` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we'll fill in the content for the `SetLivesDisplay` method.
  prefs: []
  type: TYPE_NORMAL
- en: I have put my `SetLivesDisplay` near the bottom of the `GameManager` script,
    but like the `Start` and `Awake` functions, you can put them wherever you wish
    in the `GameManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is set to `public` because our `ScenesManager` script will need
    to access it to load whatever level the player is on. We have our `SetLivesDisplay`
    method set to `void` as we aren't returning anything while in the method. As I
    mentioned previously, we take in the `playerLives` integer but we will refer to
    it as `players` while in the method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by adding some code inside the `SetLivesDisplay` method. This
    is where we will be checking, adding, and visually removing lives if the player
    dies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code inside the `SetLivesDisplay` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code, we ran a check to find a game object called `lives`. If
    we find the game object, we store its reference in a game object called `lives`.
    We then ran a check to see `if` our `lives` game object is holding any game objects.
    If `lives` isn't holding any game objects, we are assuming this is the beginning
    of the level and that we need to create some lives. Inside the `if` statement,
    we ran a `for` loop with a limit of `5` counts. Inside this `for` loop, we `instantiate`
    our `life` prefab and let it sit inside the `lives` game object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue writing inside the `SetLivesDisplay` method, which is where we manage
    the count of each `life` prefab, and make it show the actual amount of lives the
    player has:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are two main parts to the code we just wrote. The first `for` loop is
    set by the count of how many game objects sit under the `lives` game object. Each
    game object under `lives` gets scaled to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The second `for` loop takes the count of game objects under `lives` and subtracts
    it against the player's `int` variable that is brought into the parameters of
    this method. Inside this second `for` loop – depending on how big the player's
    `int` variable is – each `life` prefab is shrunk to 0\. Scaling the `life` prefab
    to 0 doesn't affect the `lives` counter to not fluctuate based on the number of
    lives shown.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameManager` is now capable of creating a life meter at the bottom of the
    `level1` scene. We now need to add some functionality so that `ScenesManager`
    loads the number of lives when the level is loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the `ScenesManager` script to load the player''s lives when a level
    starts or when the player dies, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ScenesManager` script, `Assets/Script`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `ScenesManager` script to be able to start coding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ScenesManager` script, we will add a `Start()` function that will contain
    a known Unity delegate, `sceneLoaded`, which is called from Unity's own `SceneManager`.
    This delegate will subscribe to when our game scene changes. For more information
    about the `sceneLoaded` delegate, go to [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager-sceneLoaded.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager-sceneLoaded.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `ScenesManager` script, enter the `Start` function, along with the
    name of the function we are hooking into the delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Still in the `ScenesManager` script, we will add the Unity-recognized function,
    which will automatically take `Scene` and `LoadSceneMode` types, even if we aren't
    going to do anything with them.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, we are calling the `GameManager` script's `SetLivesDisplay`,
    along with the number of lives the player has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code we just discussed inside `ScenesManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s check what we have made:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back into the Unity Editor while still being in the scene we are working
    on (`level1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Play** – three lives should be displayed. If the player dies, the life
    count will drop to two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the game being played, alongside the player''s
    lives in the bottom left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Screenshot of our game currently with its lives counter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Screenshot of our game currently with its lives counter
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have hooked up the player's lives so that they can be displayed
    in the bottom-left corner of the HUD. We have applied components such as **Horizontal
    Layout Group** and **Layout Element** to set the player's lives images in uniform
    order and size. We also made the code apply and update the player's lives whenever
    the scene loads up.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus on the other side of the HUD and display the player's score.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the player's score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be applying the player's score on the right-hand side
    of the HUD, which we are currently filling up with information about the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue to work in the `Canvas` game object and add another game object
    called `score`. Here, we will add a `ScenesManager` code to load the score display.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: While still in the `level1` scene, right-click the `Canvas` game object in the
    **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down list, select **UI** | **Text**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the new `Text` game object and select **Rename** from the drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the game object `score`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `score` game object renamed and located inside the `Canvas` game object,
    the next thing we need to do is to size and move the `score` game object into
    position.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `score` game object still selected, alter its **Rect Transform** properties
    in the **Inspector** window so that they look like the ones shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – score Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – score Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: With the `score` game object in the correct position and scale, we can now customize
    its **Text** component settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `score` game object still selected, make the following changes to
    its **Text** component in the **Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `00000000`. The number of zeros in the **Text** field will help us
    specify the size of the board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the following screenshot, we have selected the same custom text
    we used for the game's level scene titles. Click the **remote** button to the
    right of the **Font** field and select **ethnocentric rg it** from the drop-down
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Alignment** buttons to **Align Right** and **Middle Center**. This
    will position the text and minimize any space on its right-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have `score` text font size will set itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `0` and `60`. This will set the limits for the **Best Fit** text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last property to change is the **Color** property of the text. We will set
    this to the same color as our player's lives.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `153`, `177`, `178`, `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what our **Text** component properties have
    been set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – score Text Component property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.15_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – score Text Component property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the **Game** window, we should see that the score in the right-hand
    corner is a good size, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Our In-Game HUD now holding the score'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.16_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – Our In-Game HUD now holding the score
  prefs: []
  type: TYPE_NORMAL
- en: The final phase for our `score` game object is to update our `ScenesManager`
    script by adding an `if` statement to check whether the `score` game object is
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the `ScenesManager` script so that it supports our new score game
    object, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `ScenesManager` script and scroll down to where we entered
    the `OnSceneLoaded` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `OnSceneLoaded` function, enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As briefly mentioned in the newly added piece of code, we are checking whether
    the `score` game object is in the scene. If `score` is present in the scene, then
    we grab its `Text` component and apply the player's score integer to it from the
    `ScoreManager` script. Also make sure you have the `using UnityEngine.UI` at the
    top of the script to access the `Text` component.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Speaking of the `ScoreManager` script, we need to load this script back up
    so that its `ResetMethod` resets the `score` UI at the start/end of each game.
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ScoreManager` script located in `Assets/Script` and open the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the script, we need to bring in the `UnityEngine.UI` library so that
    we can make changes to our game's visual score.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very top of the `ScoreManager` script, enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `ResetScore` method, add an `if` statement that checks that the
    `score` UI game object is in the scene and updates. The following code shows the
    complete `ResetScore` method in the `ScoreManager` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to apply the `UpdateScore` method to our `SetScore` function.
    Go ahead and apply it as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to move our `UpdateScore` method within the `ScoreManager` script.
    To do that, add the following new method to update our score whenever it is set
    or reset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back into the Unity Editor and click the `level1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `score` game object will now update when we destroy the enemies, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Screen of our game with the score totaling up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.17_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – Screen of our game with the score totaling up
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took the existing `ScoreManager` code that was originally
    displaying the player's score and made it into a `score` variable to the new HUD
    score in the `level1` scene, which will update when an enemy is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The final piece we need to create for the HUD is the mini-map, which will give
    us a visual of the enemies in our level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mini-map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to fit a mini-map inside the HUD display to show
    a larger scope of the level. This will display the player, along with the enemies
    nearby, in a radar style. The following screenshot shows a radar in the middle
    of the HUD that represents the player, along with the enemies around them and
    other enemies that are due to enter the player''s screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Screenshot of our game displaying a mini-map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.18_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Screenshot of our game displaying a mini-map
  prefs: []
  type: TYPE_NORMAL
- en: 'We will break down the mini-map into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Radar Camera**: The second camera in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layers**: This makes the second camera recognize only a particular set of
    game objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Render Texture**: This displays the final results in an animated image on
    the HUD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating an extra layer so that we can expose certain game objects
    to our radar camera.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and adding layers to our player and enemy game objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will add an extra game object to our player and enemy game
    objects so that our second camera will only see the attached sprites. These will
    look like blips on a radar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our radar blips to the game objects, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top right of the Unity Editor, click the **Layers** button, followed
    by **Edit Layers...**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Edit Layers… will allow us to add another layer to our game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.19_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – Edit Layers… will allow us to add another layer to our game
  prefs: []
  type: TYPE_NORMAL
- en: The **Inspector** window will change and show the **Tags & Layers** properties.
    From here, we can click to expand the **Layers** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on one of the available layers near the top and enter `Radar`, as shown
    in the following screenshot:![Figure 9.20 – Expanding our Layers list and adding
    a new layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.20_B18381.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.20 – Expanding our Layers list and adding a new layer
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a radar point to the player and enemies. Let''s make a start
    by bringing the player into the scene and updating its prefab so that it will
    be recognized by the radar camera. To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Prefab/Player` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop `player_ship` into the **Hierarchy** window at the bottom, in
    an open space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `player_ship`, select **Create Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the game object and select **Rename** from the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the game object to `radarPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `radarPoint` still selected, click the `Sprite Renderer` until it appears
    in the component drop down. Next,click its layer on top of the **Inspector** window
    and select **Radar** from the drop-down list, as shown in the following screenshot.
    We can also set our **Transform** property to match the ones in the following
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21 – radarPoint game object with its Radar layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.21_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – radarPoint game object with its Radar layer
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Transform** properties set, we can now drop the radar dot sprite
    into the **Sprite** field and change its color:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **remote** button to the right of the **Sprite** field in the **Sprite
    Renderer** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start typing `knob` in the drop-down list until you can see it and select it,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Accessing and selecting the default knob sprite'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.22_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.22 – Accessing and selecting the default knob sprite
  prefs: []
  type: TYPE_NORMAL
- en: We can now change the color of the sprite by clicking the `0`, `245`, `255`,
    `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `player_ship` in the `player_ship` game object's prefab settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `player_ship` game object in the **Hierarchy** window and press *Delete*
    on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set the player ship so that it's ready to be detected by the radar
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to do is repeat the same methodology for the enemies, which are
    located in `Assets/Prefab/Enemies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going through the same instructions, the following screenshot shows
    our enemies'' `radarPoint` game object with a bright red color value (`255`, `0`,
    `0`, `0`). If you get stuck, just follow the same steps as for the player ship''s
    `radarPoint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – radarPoint properties setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.23_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – radarPoint properties setup
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In the **Inspector** window, click on **Overrides | Apply All** once you have
    finished making changes to your prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished making our changes and applied them to the prefab, we
    no longer need the `enemy_wave` game object as we have saved its details in the
    prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Delete `enemy_wave` from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have effectively created a tracker (`radarPoint`) and attached it to the
    player and enemies for our level.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add a **Render** **Texture**, which will work with a second
    camera in our scene. The feed from the second camera will be fed into a **Render
    Texture**. This **Render Texture** will then be placed at the bottom middle of
    the screen and display our player and enemy location.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing our Render Texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Render Texture** is typically used to hold moving images while in **Play
    Mode** (at runtime). We are going to use this **Render Texture** to hold the second
    camera''s feed. This will work like a little TV screen in the center of our HUD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and customize **Render Texture**, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Texture` folder, that is, `Assets/Texture`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click in an open space area and from the drop-down list, select **Create**,
    then **Render Texture**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Creating a Render Texture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.24_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – Creating a Render Texture
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have an open space to right-click, as *step 2* suggests, you can
    change the size of the icons to gain space.
  prefs: []
  type: TYPE_NORMAL
- en: Change your icon size with the slider in the bottom-right corner of the **Project**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Click the name of the file slowly twice and rename it `radar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `radar` **Render Texture** selected, we will need to change its size
    to one that will fit the HUD and, ideally, make it less blurry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `256`, `256` to `236`, `46`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **Filter Mode** from **Bilinear** to **Point**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last part of setting up **Render Texture** is to place it into the HUD.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Still in the `level1` scene, right-click the `Canvas` game object in the **Hierarchy**
    window and select **Create Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new empty game object in the **Hierarchy** window, right-click it,
    and select **Rename** from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the game object `radar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `radar` game object will work as housing for anything related to the game
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This game object will now need to be positioned and sized in the HUD. To do
    that, change the `radar` game object''s **Rect Transform** properties in the **Inspector**
    window to the ones shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25 – radar Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.25_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – radar Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving and resizing the `radar` game object will give us a letterbox window
    for **Render Texture** to sit inside, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – The placement of our radar game object in the Game window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.26_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.26 – The placement of our radar game object in the Game window
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add another game object that will be a child of the `radar` game
    object we''ve just made. This game object will store **Render Texture**:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `radar` game object in the **Hierarchy** window. From the drop-down
    list, select **UI** and then **Raw Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the new game object called `radarImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `radarImage` game object still selected, change its **Rect Transform**
    settings to the ones shown in the **Inspector** window in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.27 – radarImage Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.27_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.27 – radarImage Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to apply **radar Render Texture** to the **Raw Image** **Texture**
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: With `radarImage` still selected in the **Hierarchy** window, click the **remote**
    button next to the **Texture** field in the **Raw Image** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `radar` in the search bar at the top of the new window until **radar**
    **Render Texture** appears and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's our **Render Texture** made and set. Now, we can pass this into the second
    camera. But before we do that, we need to add the camera!
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing our second camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will be adding a second camera so that we can only see the
    `radarPoint` game objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting up a second camera in our `level1` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, right-click in an open space and from the dropdown,
    select **Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the newly created `RadarCam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `RadarCam` still selected, change its **Transform** settings in the **Inspector**
    window to the ones shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.28 – radarCam Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.28_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.28 – radarCam Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `RadarCam` selected, we need to change its **Camera** component
    settings to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear Flags**: **Solid Color**. We don''t require anything in the background
    for the second camera, so something basic such as a solid color would work fine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`255`, `0`, `0`, `50`. This will give our radar a red tint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Culling Mask**: Click the parameter field labeled **Everything**. Do the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Nothing** from the drop-down list to remove all layers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select the field again and select **Radar** (shown in the following screenshot).
    By doing this, all our camera will see is the game objects that relate to that
    layer:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Select Radar from Culling Mask'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.29_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.29 – Select Radar from Culling Mask
  prefs: []
  type: TYPE_NORMAL
- en: '**Projection**: **Orthographic**. The radar camera is 2D, so there is no need
    to have a perspective view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`150`. The size of our camera view will be larger than the main view the player
    is in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadarCam` to the radar''s **Render Texture**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `RadarCam`) won't need to see the **Radar** layer. Select **Main Camera**
    from the **Hierarchy** window and deselect the **Radar** layer from its **Culling
    Mask**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, with `RadarCam` still selected, click the three dots next to its **Audio
    Listener** component and remove it. We already have one camera that listens for
    audio in our scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to make it so that `RadarCam` is a child of `RadarCam` into
    **Main Camera** in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Overrides | Apply All** in the **Inspector** window to update the **Main
    Camera** prefab and save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if we click **Play** in the Unity Editor, we will see the radar in the
    HUD with its red tint showing red dots for enemies and a neon blue for the player,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.30 – Our mini-map detecting the player and its enemies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.30_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.30 – Our mini-map detecting the player and its enemies
  prefs: []
  type: TYPE_NORMAL
- en: 'This mini-map was created without any code and made use of two new components:
    **Render Texture**, which will hold the second camera''s feed, and a **Raw Image**
    component, which will display the final output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we created a functioning HUD that has three main segments:
    the player''s lives, a mini-map, and the player''s score. We used the two fundamental
    UI tools that Unity offers to create a UI display. However, we also introduced
    three new components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horizontal Group Layout**: Spaces the player''s lives equally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Render Texture**: Transfers the second camera''s feed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw Image**: Displays the feed from the render texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the final HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.31 – Our HUD is complete'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.31_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.31 – Our HUD is complete
  prefs: []
  type: TYPE_NORMAL
- en: Because we have updated our `level1` scene, we need to update `level2` and `level3`.
    The quickest way to do this would be to delete `level2` and `level3` and duplicate
    `level1`, as we did before, which leaves us with updating the level number in
    the `Text` component. We did this in the previous chapter, right at the end, so
    please check that if you need some guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will move on and improve the existing `shop` scene by removing the pre-made
    polygons for UI components. This will also introduce us to using UI event triggers
    and making our code smaller and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Making our shop scene support alternative screen ratios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to take our current `shop` scene and make it compatible
    with various screen ratios. Currently, our shop visuals are made out of polygons,
    which look fine, but, for example, our selection grid of buttons at the bottom
    of the screen has the risk of being clipped off at the edges. We can also change
    the way we select our buttons by using Unity's **Button** component, which works
    within the **Canvas**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.32 – There is a wide range of ratios in what a game is displayed
    in'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.32_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.32 – There is a wide range of ratios in what a game is displayed in
  prefs: []
  type: TYPE_NORMAL
- en: Because of these UI changes, this will cut our code down and make it more efficient
    as we will be relying on click events. We will cover these later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a start by replacing the selection grid at the bottom of our `shop`
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading our shop selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to remove all of the shop buttons and replace
    them with a `button` that has its own raycast system. This raycast system will
    give us an easier way of adding and customizing our buttons when it comes to adding
    or extracting buttons to/from the selection grid.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will support this change by removing our 3D assets so
    that we can replace them with Unity's own 2D buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our shop scene to go 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by removing the old selection grid at the bottom and our `BUY
    ?` button as that follows the same suit from our `shop` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't loaded the `shop` scene already, locate it in the `Assets/Scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click `shop` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** window, hold *Ctrl* (*command* on Mac) on the keyboard
    and select all of the game objects shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Select these game objects from the shop scene Hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.33_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.33 – Select these game objects from the shop scene Hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Press *Delete* on the keyboard if you are presented with a window to open the
    prefab. Open it and repeat the process. Once deleted, press the back button in
    the top left corner of the `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `Canvas` with its own background, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the lower part of the **Hierarchy** window, right-click and from the drop-down
    list, select **UI**, followed by **Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Canvas` game object in the **Hierarchy** window and from the
    drop-down list, select **UI**, followed by **Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the new game object called `Image` and select **Rename** from the
    drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `Image` to `backGround`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `backGround` game object still selected, change its **Rect Transform**
    properties to the ones shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.34 – backGround Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.34_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.34 – backGround Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: We can now give `backGround` some color. With the `backGround` game object still
    selected, click the `255`, `0`, `0`, `63`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `backGround` game object positioned and
    scaled with a red tint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – backGround in our Game window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.35_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.35 – backGround in our Game window
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next section, where we will add three game objects
    that will control the position and scale of the button game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding layout group components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will add game objects that will support the spacing of
    the buttons we add to the grid. The benefit of this is that we can control the
    properties of each section of the buttons, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.36 – Our shop scene button layout as planned'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.36_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.36 – Our shop scene button layout as planned
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will make an empty game object and add a **Horizontal Layout Group**
    to it, which will keep our top row buttons in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Canvas` game object and from the drop-down list, select **Create
    Empty**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new game object `gridTop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `gridTop` still selected, change its **Rect Transform** settings to the
    ones shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.37 – gridTop Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.37_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.37 – gridTop Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `gridTop` is positioned correctly, we can add a **Horizontal Layout
    Group** to it:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `gridTop` game object still selected, click the `Horizontal Layout
    Group` into the search bar at the top of the drop-down list until you see **Horizontal
    Layout Group**. When this group appears in the list, select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give **Horizontal Layout Group** the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.38 – Horizontal Layout Group property values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.38_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.38 – Horizontal Layout Group property values
  prefs: []
  type: TYPE_NORMAL
- en: '`gridTop` will now automatically order the top row of upgrade buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to repeat the process for the bottom row, without repeating the
    entire procedure. Follow the same steps for `gridTop` but make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the next game object in `gridBottom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the game object the following **Rect Transform** settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.39 – gridBottom Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.39_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.39 – gridBottom Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: Then, like before, we need to add a `gridTop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then repeat this process but this time, for our "AD" and "START" buttons,
    we will be adding a **Vertical Layout Group** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like before, create an empty game object and store it in the `Canvas` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a new game object called `gridOther`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give `gridOther`''s **Rect Transform** the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.40 – gridOther Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.40_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.40 – gridOther Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, we will add a `gridOther` game object and give it
    the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.41 – Vertical Layout Group property values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.41_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.41 – Vertical Layout Group property values
  prefs: []
  type: TYPE_NORMAL
- en: Our new, reworked selection grid now supports the creation of multiple self-scaling
    buttons. In the next section, we will demonstrate how to create multiple buttons
    that scale themselves to fit in the selection grid.
  prefs: []
  type: TYPE_NORMAL
- en: Adding UI buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to create a button that won't need any sizing
    changes to be made to it as the layout groups we placed in the previous section
    will take care of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `gridTop` game object in the **Hierarchy** window and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the drop-down list, select **UI** and then **Button**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the newly created `Button` game object and name it `00`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will get a button that will be stretched and out of place, but don't worry
    – this is normal. Later, when we add more buttons to this and the other rows,
    the buttons will snap into place and scale in size automatically.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the button comes with an **Image** component with rounded-off edges.
    For cosmetic purposes, this doesn't suit our scene. We can remove this by doing
    the following:.
  prefs: []
  type: TYPE_NORMAL
- en: Click the three-dots icon to the top right of the **Image** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down list, select **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button no longer has any color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to fill this game object with five game objects. In brief,
    their names and properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`outline`: Adds a border to the button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backPanel`: The color of the button when it''s not selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection`: The color of the button when it is selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`powerUpimage`: The picture on the button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemText`: The cost or sold out message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows all of these game objects combined to create
    our new shop button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.42 – A shop button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.42_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.42 – A shop button
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The other way of changing a button's condition is by using Unity's `Button`
    script, check out [https://docs.unity3d.com/2017.3/Documentation/Manual/script-Button.html](https://docs.unity3d.com/2017.3/Documentation/Manual/script-Button.html).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the outline game object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s start by adding an `outline` game object for our new shop button:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `00` game object in the **Hierarchy** window and from the dropdown,
    select **UI** | **Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Image` game object, right-click it in the `outline`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `outline` still selected in the **Hierarchy** window, update its **Rect
    Transform** and **Image** **Color** fields to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.43 – outline Rect Transform property settings and Image component
    color and alpha values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.43_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.43 – outline Rect Transform property settings and Image component color
    and alpha values
  prefs: []
  type: TYPE_NORMAL
- en: The shop button will now have a colored `outline`. Now, let's move on and look
    at the button's `backPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the backPanel game object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s add `backPanel` to the `00` game object:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `00` game object and from the dropdown, select **UI** | **Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the newly created `Image` game object and name it `backPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `backPanel` still selected, in the **Inspector** window, change its **Rect
    Transform** so that it has the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.44 – backPanel Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.44_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.44 – backPanel Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: With the `backPanel` game object still selected, we can change the `backPanel`
    game object's settings to `40`, `39`, `36`, `255`. That's the second game object
    that we've applied that gives us our default color.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add the `selection` game object to the `00` game object next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the selection game object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create the `selection` button, follow the same steps provided in the previous
    section. However, note that there are three differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Name this game object `selection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the `144`, `0`, `0`, `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and apply a `Selection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We covered creating and applying tags back in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048),
    *Adding and Manipulating Objects*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows our `selection` game object''s **Tag** and **Rect
    Transform** property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.45 – selection Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.45_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.45 – selection Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: That's the third game object that we've applied to our `00` game object. Our
    buttons will light up and stay red until a purchase is made or a different button
    is pressed. We'll add the `powerUpImage` game object to our `00` game object next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the powerUpImage game object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create the `powerUpImage` button, follow the same steps provided in the
    previous section, but make three changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Name this game object `powerUpImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `powerup` sprite into the **Source Image** field of the **Image**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Preserve Aspect** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's our fourth game object that displays each button's icon.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add the `itemText` game object to the `00` game object next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the itemText game object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To add the `itemText` game object to our `00` game object, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `00` game object and from the drop-down list, select **UI**, followed
    by **Text**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the newly created `Text` game object and name it `itemText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `itemText` still selected, in the `Inspector` window, change its **Rect
    Transform** and **Text** components so that they have the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.46 – itemText Rect Transform property settings and Text Component
    values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.46_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.46 – itemText Rect Transform property settings and Text Component values
  prefs: []
  type: TYPE_NORMAL
- en: That's the fifth and final game object we need to add to our weapon upgrade
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `00` game object should be in the order shown in the following screenshot.
    If the order isn''t the same, simply click and drag either one into position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.47 – 00 game object and its children in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.47_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.47 – 00 game object and its children in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we stripped out the old `shop` scene setup where we were selecting
    items in the shop with a raycast system. We replaced the old selection grid with
    a 2D interface with **Button** components. These buttons were grouped with Unity's
    Horizontal and **Vertical Layout Group** components. The benefit of these two
    groups is that if we add more or fewer buttons to the grid, the buttons will reorganize
    their position and scale automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make a slight modification to the `ShopPiece` script that was originally
    attached to each game object button.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have applied and modified the script, we will check what the buttons
    look like in the new selection grid.
  prefs: []
  type: TYPE_NORMAL
- en: Applying and modifying our shop script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's briefly recall the purpose of the `ShopPiece` script. Each button in the
    selection grid will be given information from a scriptable object that will customize
    the button's name, description, value, and image. Because the buttons have changed
    from being 3D assets to 2D ones, we need to alter and add some more code to make
    this work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify `ShopPiece` so that it''s compatible with our new 2D button, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `ShopPiece` script to open the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first line of code will allow our new code support to grab references from
    the `00` game object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following piece of code at the top of the `ShopPiece` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second modification to make will be to replace the content of the `Awake`
    function. The original code accessed `SpriteRenderer`, which was used for accessing
    the sprite on each polygon button. The other piece of code we are replacing applied
    changes to the `TextMesh` component, which displays 3D text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update our `Awake` function, select the code within the `Awake()` function
    and delete it. Our `Awake()` function should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now enter the first `if` statement, which applies our scriptable object
    icon image to our button's image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `Awake()` function, add the following `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `if` statement grabs a reference from the second child in the `00` button
    and checks to see whether it has an **Image** component. If it does (and it should),
    we apply the scriptable object icon to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other `if` statement updates the text of the button. Within the `Awake()`
    function, just after the first `if` statement, add the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `if` statement makes sure the `00` button has `itemText` (it should). When
    the `itemText` game object is found, its **Text** component receives the scriptable
    object price of the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in the Unity Editor, select the `00` game object in the **Hierarchy** and
    click the **Add Component** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `ShopPiece` in the drop-down list until you see it. When you do,
    select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `00` game object still selected, in the `ShopPiece` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select any weapon upgrade scriptable object from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `ShopPiece` script with a scriptable object
    applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.48 – ShopPiece script, holding in its Shop Selection field the Shot_PowerUp
    Scriptable Object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.48_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.48 – ShopPiece script, holding in its Shop Selection field the Shot_PowerUp
    Scriptable Object
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position to check what our button looks like with the four game
    objects we've applied and with its modified `ShopPiece` script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we are going to duplicate a series of the new shop
    buttons. These shop buttons will automatically fit in the allocated game object
    space we have put them in. Then, we will clear up any of the old UI and replace
    it with our new interface. Finally, we will comment out the old raycast system
    from our code and add our new interface code.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the button's results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be reviewing the new `00` button in the `gridTop`
    game object. The button is too big and spreads across the majority of the **Canvas**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.49 – 00 game object currently sitting in the gridTop game object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.49_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.49 – 00 game object currently sitting in the gridTop game object
  prefs: []
  type: TYPE_NORMAL
- en: 'But if I select the `00` game object in the **Hierarchy** window and press
    *Ctrl* (*command* on Mac) and *D* to duplicate the game object a few times, the
    button will divide equally, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.50 – Three 00 game objects looking less stretched'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.50_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.50 – Three 00 game objects looking less stretched
  prefs: []
  type: TYPE_NORMAL
- en: 'The button divides well and can be duplicated several times (not in **Play
    Mode**) to fill the top and bottom grids. To fill up and name the grids, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `00` game object and press *Ctrl* (*command* on a Mac) and *D* three
    times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the three new duplicate game objects `01`, `02`, and `03` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `01` in the `ShopPiece` component in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a different scriptable object from the list to change the weapon upgrade.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select game object `02` and select a different weapon in the `ShopPiece` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to fill up the bottom row with buttons. To do that, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and drag the `03` game object from the `gridBottom` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `03` still selected, press *Ctrl* (*command* on a Mac) and *D* twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename our newly created game objects `04` and `05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the top and bottom rows filled up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.51 – Six shop buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.51_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.51 – Six shop buttons
  prefs: []
  type: TYPE_NORMAL
- en: Because we don't have any more items to sell in our shop, the bottom three buttons
    look odd, so let's replace these with some sold-out signs. This can easily be
    achieved with our scriptable object assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a sold-out sign for our bottom row in our shop, we need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/ScriptableObject`, right-click in an open space, and select **Create**
    | **Create Shop Piece**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Create Shop Piece` file `SoldOut`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `SoldOut` and give it the following property values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.52 – SoldOut Scriptable Object and its values entered along with
    a soldOut sprite'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.52_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.52 – SoldOut Scriptable Object and its values entered along with a
    soldOut sprite
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, apply the `SoldOut` file to game objects `03`, `04`, and `05` in the
    `Shop Piece` component field's **Shop Selection** in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to repeat a similar process for our advert and start buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the advert and start buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To recreate the advert button, select either one of the buttons we duplicated
    in the **Hierarchy** window and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* (*command* on a Mac) and *D* to duplicate another button and drag
    it into the `gridOther` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the duplicate game object `AD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the `AD` game object doesn't need `powerUpImage`, we can delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `AD` game object by clicking the arrow to the left of its name in
    the `itemText` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apply the following settings to the **Text** component in the **Inspector**
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.53 – itemText Rect Transform property settings and Text component
    values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.53_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.53 – itemText Rect Transform property settings and Text component values
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat a similar process for the `itemText` and `selection` game object components
    (`selection` hex color: `FFC300FF`), as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.54 – itemText Text component values and selection Image component
    property values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.54_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.54 – itemText Text component values and selection Image component property
    values
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `gridOther` game object and its content,
    including the two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.55 – gridOther game object holding AD and START buttons with their
    children in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.55_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.55 – gridOther game object holding AD and START buttons with their
    children in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: Now that our selection grid visuals are completed, we can move on to the description
    panel and partially convert it from 3D into 2D.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the BUY? button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add the 2D `BUY?` button to the description panel, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Canvas` game object in the **Hierarchy** panel and select **UI**,
    followed by **Button**, from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the newly created `Button` game object and select **Rename** from
    the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Button` game object `BUY?`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `BUY?` button still selected in the **Hierarchy** window, set its
    **Rect Transform** properties to the ones shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.56 – BUY? Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.56_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.56 – BUY? Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `BUY?` button is in place and scaled correctly, we can alter the
    aesthetics for the **Image** and **Button** components. In the **Image** component,
    select the **remote** button for the **Source Image** field and select **None**
    from the list to remove the curved edges for the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will make it so that the `BUY?` button changes colors when it''s highlighted
    and pressed in the **Button** component. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `255`, `0`, `0`, `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `255`, `195`, `0`, `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the cursor moves over the `BUY?` button, it will turn yellow and when pressed,
    it will turn red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, for the `BUY?` button, we need to alter its **Text** component, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BUY?` button to expand it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the `BUY?` game object's child, called `Text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following values for the `Text` game object''s **Text** component
    in the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.57 – BUY? game object''s Text component property values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.57_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.57 – BUY? game object's Text component property values
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our **BUY ?** button positioned and styled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.58 – The BUY? game object should now look like the one in this screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.58_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.58 – The BUY? game object should now look like the one in this screenshot
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we applied Unity's different state settings for our button
    without adding any extra code. Next, we will add a simple rectangle image to replace
    the polygon quad.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing our textBoxPanel game object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we changed our `BUY ?` button so that it is 2D and
    part of the `BUY ?` button will now be moved, scaled, and adjusted to the ratio
    of the screen instead of remaining static. Because of this, we have the risk of
    our `BUY ?` button moving outside of the static `textBoxPanel` it sits in, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.59 – Fixing the issue with the textBoxPanel game object alignment
    with the BUY ? button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.59_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.59 – Fixing the issue with the textBoxPanel game object alignment with
    the BUY ? button
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `PlayerShipBuild` script has a reference to `textBoxPanel`, so we
    can't delete the game object without altering our code. To fix this dilemma, we
    can remove the 3D components of `textBoxPanel`, leaving it as an empty game object
    to house other game objects within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the components from the `textBoxPanel` game object, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `textBoxPanel` in the search bar until it appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `textBoxPanel` and remove the two components in the **Inspector** window
    for **Quad (Mesh Filter)** and **Mesh Renderer** by selecting and clicking the
    three dots and selecting **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To bring back our full game object content in the **Hierarchy** window, click
    the cross at the top of its window, to the right of the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the locations of both three-dot icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.60 – Remote button locations for the Quad and Mesh Renderer components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.60_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.60 – Remote button locations for the Quad and Mesh Renderer components
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create the 2D panel game object to replace the `textBoxPanel` game
    object''s visuals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Canvas` game object and select **UI**, followed by **Image**, from the
    drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the newly created game object, right-click it, and select **Rename**
    from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the game object `panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the `BUY?` game object below the panel game object in the `BUY?` button
    sits on top of `panel` in the **Scene** window. The following screenshot shows
    the order of the two game objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.61 – BUY? game object placement in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.61_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.61 – BUY? game object placement in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `panel` game object still selected, give its **Rect Transform** the
    following values in the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.62 – panel Rect Transform property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.62_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.62 – panel Rect Transform property settings
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the color of our `panel` game object by clicking its **Color**
    field within its **Image** component in the **Inspector** window and giving it
    the values highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.63 – Change the panel game object Image component color values to
    those in this screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.63_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.63 – Change the panel game object Image component color values to those
    in this screenshot
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can amend our `textBoxPanel` and `bank` balance fonts so that they
    fit in with the shop buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To amend our bank balance, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `bankText` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `bankText` selected, update its **Text Mesh** component in the **Inspector**
    window so that the **Font** field takes our new **ethnocentric rg it** font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `255`, `0`, `0`, `255`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a few digits in the **Text** field to check the results, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.64 – bank game object font updated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.64_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.64 – bank game object font updated
  prefs: []
  type: TYPE_NORMAL
- en: 'To change our `textBoxPanel`, we need to do something similar. Here, we will
    select its two child game objects in the `name` and `desc`, and update their **Text
    Mesh** components to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `name` and `desc` game object's **Text Mesh** **Font** fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give them a white **Color**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `name` game object''s **Text Mesh** **Text** field, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the same changes to the `desc` game object but add the following text
    to the **Text** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows a section of the **Game** window and its updated
    font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.65 – Our textBoxPanel game object and its content updated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.65_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.65 – Our textBoxPanel game object and its content updated
  prefs: []
  type: TYPE_NORMAL
- en: Now, all of our shop's visuals have been amended and will support various screen
    ratios. By doing this, we also introduced Unity's own **Button** component.
  prefs: []
  type: TYPE_NORMAL
- en: We have now reached the point where we can open a template script of `PlayerShipBuild`
    from our chapter's project files folder. This script will be a replica of the
    current `PlayerShipBuild` script we have been making but with highlighted code
    we will add to the project to support our `shop` scene's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the PlayerShipBuild script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to replace the current `PlayerShipBuild` script
    with the one from this chapter's project files folder. The replacement script
    will contain the same code as your current script but with code to show what we
    will be adding and removing step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rename our current `PlayerShipBuild` script to something else before
    we begin working on our new replacement script. To rename the current `PlayerShipBuild`
    script, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `PlayerShipBuild` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `PlayerShipBuild` script open, rename the class name near the top of
    the script from `PlayerShipBuild` to `PlayerShipBuild_OLD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script and return to the `Assets/Script` folder in the **Project**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `PlayerShipBuild` script slowly twice so that you're provided with
    the option to rename the filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the filename to `PlayerShipBuild_OLD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to disconnect the `PlayerShipBuild_OLD` script from the `shop`
    game object.
  prefs: []
  type: TYPE_NORMAL
- en: In the `shop` into the search bar until you see the `shop` game object. When
    you do, select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `shop` game object selected, click the three dots in the `PlayerShipBuild_OLD`
    component (not **Transform**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Remove Component** from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we have renamed and detached the script from the scene. Now, we can
    bring in the new replica `PlayerShipBuild` script from this chapter's project
    files folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hook up the new replica `PlayerShipBuild` script from our project files
    folder, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `PlayerShipBuild_NEW.txt` script inside the folder and drag it to
    the `Assets/Script` folder. Rename it and its file format from `.txt` to `.cs`.
    This will replace some of our old raycast scripts with the same name, `PlayerShipBuild.cs`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.66 – Update the PlayerShipBuild script from the Chapter 9 folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.66_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.66 – Rename and move PlayerShipBuild_NEW to the project's Assets/Script
    folder
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now apply this replica script to the `shop` game object in the scene.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `shop` game object in the **Hierarchy** window, as we did before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `PlayerShipBuild`. When you see the `PlayerShipBuild` script, select
    it from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `shop` game object still selected, we can now configure the attached
    `PlayerShipBuild` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To configure the script, set `3`, click each **remote** button to the right
    of each field, and add the following highlighted, from the **Hierarchy** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.67 – Add the following three game objects to the PlayerShipBuild
    script''s fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.67_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.67 – Add the following three game objects to the PlayerShipBuild script's
    fields
  prefs: []
  type: TYPE_NORMAL
- en: Our new `PlayerShipBuild` script is now in place. This means we can now open
    the script and check through and reveal new sections of the code while explaining
    the fundamental parts of the old code's removal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the following **Removing the old…** subsections will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**//REMOVE(number)**: Refer to what part of the code we are talking about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerShipBuild` script its code has been removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replacement**: What the previous code has been replaced with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the old shop scene's code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we are going to go through the newly installed `PlayerShipBuild`
    script and review parts of the code I have commented out so that it won't be acknowledged
    when it's compiled and executed in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We will be turning off the ability to raycast a 3D object, which we coded in
    [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107), *Creating a Shop Scene for
    Our Game*. Because we have swapped the interactable game objects from 3D to 2D,
    we are no longer required to shoot and identify game objects as Unity will take
    care of this with its own **Button** component.
  prefs: []
  type: TYPE_NORMAL
- en: To review the code we have commented out, go to the `PlayerShipBuild` script
    located where we left it (`Assets/Script`).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: '`Commenting`, `Comments`, and `UnComment` are words that refer to when a piece
    of code has two forward slashes in front of it. These will be ignored when our
    code is read by the compiler (when we run our code).'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to review each piece of code in separate sections so that it's
    clear when the changes we are going to make in `PlayerShipBuild` will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing code – REMOVED 01
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each main chunk of code begins with `//REMOVED`, followed by a number. Here
    are the reasons why we have removed the particular piece of code for `//REMOVED
    01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//REMOVED 01`: This piece of code creates a raycast and returns a game object
    called `target`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason for removal**: We no longer need to rely on getting references for
    each game object we shoot a ray at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnClick` event, which is typically used to load a method when it''s selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    02`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing code – REMOVED 02
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    02`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//REMOVED 02`: This piece of code will take a reference from a raycast-selected
    game object and turn on that `selection` game object to show that a selection
    has been made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason for removal**: The game object served no benefit apart from serving
    a cosmetic purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection` game object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    03`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing code – REMOVED 03
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//REMOVED 03`: This part of the code checks for the player pressing the fire
    button; if they do, the code will shoot out a raycast to check whether it made
    contact with a collider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnClick` event system holds a reference to what game object is selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    04`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing code – REMOVED 04
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    04`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//REMOVED 04`: This script checks what the name of the raycast game object
    is. Once it''s identified through a series of `if` statements, it runs the method
    applicable to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason for removal**: This section of the code would have checked for specific
    names our raycast would have made contact with. We no longer use the raycast system
    now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replacement**: Each button has its own event trigger that runs its own method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue scrolling down the `PlayerShipBuild` script until we get to `//REMOVED
    05`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing code – REMOVED 05
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we are going to review what we have commented out in `//REMOVED
    05`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//REMOVED 05`: At every frame, it checks whether the player has made a selection
    in the shop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replacement**: The event trigger system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous sections, we reviewed and amended the way we interacted with
    the old shop scene's raycast system.
  prefs: []
  type: TYPE_NORMAL
- en: The next phase is to apply methods that can be called directly via an event
    when a button is pressed in the `shop` scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to our PlayerShipBuild script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to build two main parts so that we can set up
    our script for 2D UI selection. Thankfully, we have done most of the work for
    this chapter and all that remains is to make parts of the script `public` so that
    our code can be accessed from other sources, that is, our event trigger (`OnClick()`).
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we are going to do is make our `AttemptSelection` method receive
    the game object button so that it will replace the previous `target` game object.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm this, the `target` game object was originally used to store ray hits
    from our raycast system. If you would like to know more about raycast systems,
    check out [*Chapter 5*](B18381_05_Epub.xhtml#_idTextAnchor107), *Creating a Shop
    Scene for Our Game*, if this sounds hazy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by making the `PlayerShipBuild` script''s methods accessible to
    other classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the accessibility levels for our methods/functions and classes
    are set to private unless stated otherwise. For more information about accessibility
    levels, check out the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PlayerShipBuild` script and add `public` to the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`void WatchAdvert()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void BuyItem()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void StartGame()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods are now open to other scripts and the Unity Editor via the `AttemptSelection`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '`AttemptSelection` will be given the same treatment with regard to being a
    `public` method, but it will now also take a game object in parameters, which
    will be the button our script is attached to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to the `AttemptSelection` method and add a `public` accessibility level,
    including a game object with the reference name `buttonName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside this `AttemptSelection` method, we check `buttonName` instead of what
    we did before by checking `target`. We then follow the same procedure of turning
    off any buttons highlighted, then apply the `buttonName` game object reference
    to another game object called `tmpSelection`, which was originally set in the
    `Select` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `AttemptSelection` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continuing with the next line of code inside our method, we set the button''s
    child `selection` game object to active (switch it on). The following screenshot
    shows the child number of the `selection` game object in the **Hierarchy** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.68 – Hierarchy order of game object 00''s children'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.68_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.68 – Hierarchy order of game object 00's children
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `AttemptSelection` method, we now need to change the old `target`
    game object''s name to the new `buttonName` game object. The code in bold in the
    following snippet shows where you need to change the names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and re-enter your Game IDs in the **Inspector** window for the
    shop game object. (**Edit | Project Settings | Services | Ads** )
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that if you get stuck with this part, you can always check the `Complete`
    folder for this chapter, where you'll have access to the completed files.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have removed multiple chunks of code and replaced them with a minimal
    amount that now supports the event triggers from the Unity Editor. This will help
    with performance and improve the readability of our code. In the next section,
    we are going to let each of the UI buttons know what methods to run when a selection
    is made.
  prefs: []
  type: TYPE_NORMAL
- en: Applying trigger events to call methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this final section, we are going to make it so that when the player presses
    a button in the shop, they will get access to it immediately, instead of our script
    shooting a ray and checking whether and what collider it has made contact with
    to get access to its method. We will be doing this using Unity's Event system
    to run methods directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a button run a method directly, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Unity Editor, select the first `shop` scene button in the selection
    grid called `00` in the **Hierarchy** window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.69 – Select the 00 game object in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.69_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.69 – Select the 00 game object in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: 'With `00` selected, scroll down the **Inspector** window until you come across
    the **Button** component. Within the **On Click ()** panel, click the **+** icon,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.70 – In the Button component click the + button to add an On Click
    () event'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.70_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.70 – In the Button component click the + button to add an On Click
    () event
  prefs: []
  type: TYPE_NORMAL
- en: The `shop` game object to the field that currently says **None (Object)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag the `shop` game object from the **Hierarchy** window into the
    **None (Object)** field, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.71 – Drag the shop game object from the Hierarchy into the 00 game
    object Button''s On Click () field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.71_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.71 – Drag the shop game object from the Hierarchy into the 00 game
    object Button's On Click () field
  prefs: []
  type: TYPE_NORMAL
- en: The `00` game object. Now, we need to direct what function from `00` it should
    load.
  prefs: []
  type: TYPE_NORMAL
- en: We will call the `AttemptSelection` method by making a request when we tap/click
    one of the `shop` scene's buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `00` button load the `AttemptSelection` method, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `PlayerShipBuild` script and the `AttemptSelection(GameObject)` public
    method, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.72 – With the shop game object in the field, select the PlayerShipBuild
    script and then the AttemptSelection function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.72_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.72 – With the shop game object in the field, select the PlayerShipBuild
    script and then the AttemptSelection function
  prefs: []
  type: TYPE_NORMAL
- en: The last field to add within the `AttemptSelection`.
  prefs: []
  type: TYPE_NORMAL
- en: Click the remote button on the far right and type the game object we have selected,
    that is, `00`. When you see it in the list, click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, when the player presses the `00` button, our `PlayerShipBuild` script from
    the `shop` game object. Then, it will run the `AttemptSelection` method, taking
    the `00` game object as a reference in parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the `01` and `02`. Once completed, each **On Click()** panel will look
    as follows for all three game objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.73 – Each game object (00, 01, 02) and their Button component On
    Click () event property settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.73_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.73 – Each game object (00, 01, 02) and their Button component On Click
    () event property settings
  prefs: []
  type: TYPE_NORMAL
- en: Things are slightly different for our `START` and `AD` game object buttons (sat
    in the **Hierarchy** window).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `AD` and `START` game object buttons work in the game, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the `shop` game object to the `AD` game object's `OnClick` event in the
    **Inspector** window, as we did with the last few game object buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the `START` game object button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update each of the `START` and `AD` game object''s `OnClick` events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayerShipBuild`, followed by the `WatchAdvert` method.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerShipBuild`, followed by the `StartGame` method. Remember, if you can''t
    see it in the list, make sure it is made `public` in the `PlayerShipBuild` script.
    You know how to do this now. If not, check the `Complete` folder.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.74 – AD and START game object Button On Click () event property
    values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.74_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.74 – AD and START game object Button On Click () event property values
  prefs: []
  type: TYPE_NORMAL
- en: 'The very last button to change is the `BUY?` game object button in the **Hierarchy**
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the usual `shop` game object to its **On Click()** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the script to `PlayerShipBuild`, followed by `BuyItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we don't apply event listeners to our bottom row of buttons (Sold
    Out) as there is no reason to press these buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Our shop scene is now ready to test. Save the scene and press **Play** in the
    Unity Editor to try out our new shop buttons. It would also be worth testing different
    landscape views in the **Game** window to see the UI buttons pop into shape when
    a landscape ratio is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the steps you have to follow to change the ratio.
    Do this by clicking the **Game** tab in the Unity Editor, followed by making a
    selection from two fairly common ratios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.75 – This screenshot shows two common ratios marked'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.75_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.75 – This screenshot shows two common ratios marked
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reevaluated our code and took out the old raycast system,
    which involved selecting 3D game objects to run methods. We replaced this with
    Unity's Event System, complete with **Button** components that were dynamically
    organized with the **Horizontal and Vertical Layout Group** components.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the UI is more robust since it supports different screen ratios. This will
    make our game more compatible with a variety of mobile and tablet screens that
    are old and current, as well as portable devices that haven't been released yet.
    This helps future-proof our application without any embarrassing ratio issues
    occurring.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked into two different parts of our game: the in-game
    HUD and rebuilding our shop scene. Both of these used Unity''s UI components but
    in different ways.'
  prefs: []
  type: TYPE_NORMAL
- en: In the in-game HUD section, we read up about what a HUD is and how we can incorporate
    one into our game. By doing this, we learned how to use **Horizontal Layout Group**
    to order images correctly, **Render Texture** to take a feed from a second camera,
    and **Raw Image** to display a feed from **Render Texture**.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, as required by the Unity Programmer Exam, you need to understand
    what a HUD is and how to build elements into it, such as a mini-map.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we reviewed our current shop scene's interface
    and code. We took it apart and rebuilt its interface as a Unity Event system that
    ran methods directly instead of casting a ray to call a method. We also made the
    interface support multiple ratios.
  prefs: []
  type: TYPE_NORMAL
- en: With the skills covered in this chapter, you should feel more confident in reviewing
    and understanding code that could be made more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue working on our in-game level so that we
    can pause the game, add and change the volume of our music and sound effects manually,
    and more.
  prefs: []
  type: TYPE_NORMAL
