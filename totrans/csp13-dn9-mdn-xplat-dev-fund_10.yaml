- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Data Using Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about reading from and writing to relational data stores, such
    as SQLite and SQL Server, by using the object-to-data store mapping technology
    named **Entity Framework Core** (**EF Core**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up EF Core in a .NET project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining EF Core models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying EF Core models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding modern databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the most common places to store data are in a **relational database management
    system** (**RDBMS**), such as SQL Server, PostgreSQL, MySQL, and SQLite, or a
    **NoSQL** database, such as Azure Cosmos DB, Redis, MongoDB, and Apache Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases were invented in the 1970s. They are queried with **Structured
    Query Language** (**SQL**). At the time, data storage costs were high, so they
    reduced data duplication as much as possible. Data is stored in tabular structures
    with rows and columns that are tricky to refactor once in production. They can
    be difficult and expensive to scale.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases do not just mean “no SQL”; they can also mean “not only SQL.”
    They were invented in the 2000s, after the internet and the web had become popular,
    and adopted many of the learnings from that era of software. They are designed
    for massive scalability, high performance, and making programming easier by providing
    maximum flexibility and allowing schema changes at any time because they do not
    enforce a structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know nothing about relational databases, then you should read the database
    primer that I wrote at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-database-primer.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-database-primer.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding legacy Entity Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Entity Framework** (**EF**) was first released as part of .NET Framework
    3.5 with Service Pack 1 back in late 2008\. Since then, EF has evolved, as Microsoft
    has observed how programmers use **object-relational mapping** (**ORM**) tools
    in the real world.'
  prefs: []
  type: TYPE_NORMAL
- en: ORMs use a mapping definition to associate columns in tables with properties
    in classes. Then, a programmer can interact with objects of different types in
    a way that they are familiar with, instead of having to deal with knowing how
    to store the values in a relational table or another structure provided by a NoSQL
    data store.
  prefs: []
  type: TYPE_NORMAL
- en: The version of EF included with .NET Framework is **Entity Framework 6** (**EF6**).
    It is mature and stable and supports an EDMX (XML file) way of defining the model,
    as well as complex inheritance models and a few other advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: EF 6.3 and later versions have been extracted from .NET Framework as a separate
    package, so they can be supported on .NET Core 3 and later. This enables existing
    projects like web applications and services to be ported and run cross-platform.
    However, EF6 should be considered legacy technology because it has some limitations
    when running cross-platform and no new features will be added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the legacy Entity Framework 6.3 or later
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the legacy Entity Framework in a .NET Core 3 or later project, you must
    add a package reference to it in your project file, as shown in the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Only use legacy EF6 if you must; for example, you might
    use it to migrate a **Windows Presentation Foundation** (**WPF**) app that uses
    EF6 on .NET Framework to modern .NET. This book is about modern cross-platform
    development, so in the rest of this chapter, I will only cover the modern EF Core.
    You will not need to reference the legacy EF6 package as shown above in the projects
    for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Entity Framework Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The truly cross-platform version, **EF Core**, is different from the legacy
    Entity Framework. Although EF Core has a similar name, you should be aware of
    how it varies from EF6\. The latest EF Core is version 9, to match .NET 9.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core 9 targets .NET 8 or later because the EF Core team wants as many developers
    as possible to benefit from new features in future releases even if you must target
    only long-term support releases of .NET. This means that you can use all the new
    features of EF Core 9 with either .NET 8 or .NET 9\. But when EF Core 10 is released
    in November 2025, your projects will need to target .NET 10 to use it.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core 3 and later only work with platforms that support .NET Standard 2.1,
    meaning .NET Core 3 and later. EF Core 3 and later do not support .NET Standard
    2.0 platforms like .NET Framework 4.8.
  prefs: []
  type: TYPE_NORMAL
- en: As well as traditional RDBMSs, EF Core supports modern cloud-based, non-relational,
    schema-less data stores, such as Azure Cosmos DB and MongoDB, sometimes with third-party
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'EF Core has so many improvements in each release that this chapter cannot cover
    them all. In this chapter, I will focus on the fundamentals that all .NET developers
    should know and some of the most useful new features. You can learn more about
    EF Core and how to use it with SQL Server in my companion book, *Apps and Services
    with .NET 8*, or by reading the official documentation, found at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/ef/core/](https://learn.microsoft.com/en-us/ef/core/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can keep up with the latest EF Core news at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aka.ms/efnews](https://aka.ms/efnews)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Database First and Code First
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two approaches to working with EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database First**: A database already exists, so you build a model that matches
    its structure and features. This is the most common scenario in real life. You
    will see an example of this throughout this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code First**: No database exists, so you build a model and then use EF Core
    to create a database that matches its structure and features. You will see an
    example of this if you complete the online-only section linked to in one of the
    exercises at the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance improvements in EF Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The EF Core team continues to work hard on improving the performance of EF Core.
    For example, if EF Core identifies that only a single statement will be executed
    against the database when `SaveChanges` is called, then it does not create an
    explicit transaction as earlier versions do. That gives a 25% performance improvement
    to a common scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is too much information about all the recent performance improvements
    to cover in this chapter, and you get all the benefits without needing to know
    how they work anyway. If you are interested (and it is fascinating what they looked
    at and how they took advantage of some cool SQL Server features in particular),
    then I recommend that you read the following posts from the EF Core team:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Announcing Entity Framework Core 7 Preview 6: Performance Edition: [https://devblogs.microsoft.com/dotnet/announcing-ef-core-7-preview6-performance-optimizations/](https://devblogs.microsoft.com/dotnet/announcing-ef-core-7-preview6-performance-optimizations/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Announcing Entity Framework Core 6.0 Preview 4: Performance Edition: [https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-4-performance-edition/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a sample relational database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn how to manage an RDBMS using .NET, it would be useful to have a sample
    one so that you can practice on one that has a medium complexity and a decent
    number of sample records. Microsoft offers several sample databases, most of which
    are too complex for our needs, so instead, we will use a database that was first
    created in the early 1990s known as `Northwind`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a minute to look at a diagram of the `Northwind` database. You can
    use the diagram in *Figure 10.1* to refer to as we write code and queries throughout
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The Northwind database tables and relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will write code to work with the `Categories` and `Products` tables later
    in this chapter, and other tables in later chapters. But before we do, note the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each category has a unique identifier, name, description, and picture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product has a unique identifier, name, unit price, units in stock, and
    other fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product is associated with a category by storing the category’s unique
    identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between `Categories` and `Products` is one-to-many, meaning
    each category can have zero or more products. This is indicated in *Figure 10.1*
    by an infinity symbol at one end (meaning many) and a yellow key at the other
    end (meaning one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is a small, fast, cross-platform, self-contained RDBMS that is available
    in the public domain. It’s the most common RDBMS for mobile platforms such as
    iOS (iPhone and iPad) and Android. SQLite is the most used database engine in
    the world and there are more than one trillion SQLite databases in active use.
    You can read more about this at [https://www.sqlite.org/mostdeployed.html](https://www.sqlite.org/mostdeployed.html).
  prefs: []
  type: TYPE_NORMAL
- en: I decided to demonstrate databases using SQLite in this book since its important
    themes are cross-platform development and fundamental skills that only need basic
    database capabilities. I recommend that you initially complete the book code tasks
    using SQLite. If you also want to try the code tasks using SQL Server, then I
    provide documentation to do so in the online-only sections in the GitHub repository
    for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using SQL Server or other SQL systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enterprises that standardize on Windows tend to also use SQL Server as their
    database. If you would prefer to use SQL Server, please see the online instructions
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md)'
  prefs: []
  type: TYPE_NORMAL
- en: If you would prefer to use a different SQL system, then the SQL scripts that
    I provide should work with most SQL systems, for example, PostgreSQL or MySQL.
    However, I have not written step-by-step instructions for them and I make no guarantees
    they will work.
  prefs: []
  type: TYPE_NORMAL
- en: My recommendation is to complete this book using SQLite, so you focus on learning
    what’s taught in the book about EF Core rather than adding the complication of
    trying to use a different database system. Learning is hard enough; don’t bite
    off more than you can chew, and don’t make it harder on yourself. Once you’ve
    learned what’s in the book, you can always repeat it with a different database
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLite CLI tools for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Windows, we need to download SQLite CLI tools and add the folder for SQLite
    to the system path so it will be found when we enter commands at a command prompt
    or terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your favorite browser and navigate to [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the page to the **Precompiled Binaries for Windows** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **sqlite-tools-win32-x86-3460100.zip** (the file might have a higher
    version number), as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Downloading SQLite for Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the ZIP file into a folder named `C:\Sqlite\`. Make sure that the three
    extracted files, including `sqlite3.exe`, are directly inside the `C:\SQLite`
    folder or the executable will not be found later when you try to use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Windows **Start** menu, navigate to **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `environment` and choose **Edit the system environment variables**.
    On non-English versions of Windows, please search for the equivalent word in your
    local language to find the setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Environment Variables** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **System variables**, select **Path** in the list, and then click **Edit…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `C:\SQLite` is not already in the path, then click **New**, enter `C:\Sqlite`,
    and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**, then **OK**, then **OK** again, and then close **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To confirm that the path to SQLite has been configured correctly, at any command
    prompt or terminal, enter the following command to start SQLite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To exit the SQLite command prompt, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, press *Ctrl* + *C* twice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, press *Ctrl* + *D*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up SQLite for macOS and Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On macOS, SQLite is included in the `/usr/bin/` directory as a command-line
    application named `sqlite3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, you can get set up with SQLite using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLite can be downloaded and installed for other OSs from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up EF Core in a .NET project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a database system set up, we can create a database and .NET
    project that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a console app for working with EF Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create a console app project for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithEFCore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Northwind sample database for SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can create the `Northwind` sample database for SQLite using an SQL script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not previously cloned or downloaded the ZIP for the GitHub repository
    for this book, then do so now using the following link: [https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the script to create the `Northwind` database for SQLite from the following
    path in your local Git repository or where you extracted the ZIP: `/scripts/sql-scripts/Northwind4SQLite.sql`
    into the `WorkingWithEFCore` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a command prompt or terminal in the `WorkingWithEFCore` project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, start **File Explorer**, right-click the `WorkingWithEFCore` folder,
    and select **New Command Prompt at Folder** or **Open in Windows Terminal**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, start **Finder**, right-click the `WorkingWithEFCore` folder, and
    select **New Terminal at Folder**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter the command to execute the SQL script using SQLite to create the `Northwind.db`
    database, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually, you will see the SQLite command prompt, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To exit the SQLite command prompt, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, press *Ctrl* + *C* twice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS or Linux, press *Ctrl* + *D*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can leave the command prompt or terminal window open because you will use
    it again soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using VS Code and the `dotnet run` command, the compiled application
    executes in the `WorkingWithEFCore` folder, allowing it to locate the database
    file stored therein. But if you are using Visual Studio or Rider, then the compiled
    application executes in the `WorkingWithEFCore\bin\Debug\net9.0` folder, so it
    will not find the database file because it is not in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s tell Visual Studio to copy the database file to the directory that it
    runs the code in so that it can find the file, but only if the database file is
    newer or is missing so it will not overwrite any database changes we make during
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer**, right-click the `Northwind.db` file and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Properties**, set **Copy to Output Directory** to **Copy if newer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `WorkingWithEFCore.csproj`, note the new elements, as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you prefer to overwrite the data changes every time you start the project,
    then set **CopyToOutputDirectory** to **Always**.
  prefs: []
  type: TYPE_NORMAL
- en: You could make the preceding changes to the project file manually instead of
    using the **Properties** window. In fact, any change made to the project file
    by any tool can also be made manually just by editing the XML. Tools like the
    **Properties** window just read the files in a project and show an alternative
    view. This is why in *Chapter 1*, I stressed using multiple code editors when
    learning .NET. The danger is that if you only use Visual Studio, then you may
    start to think that Visual Studio *is* .NET development. It is not.
  prefs: []
  type: TYPE_NORMAL
- en: The real .NET development is the contents of the source code files, like `.cs`,
    and the project file `.csproj`, which are then compiled by the command-line interface
    `dotnet`. Any other tool you use is just an additional layer on top of that.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, a future feature in .NET that Microsoft is actively looking at
    is “implicit project files.” This would mean having a folder that contains only
    one or more `.cs` files and the `.csproj` file would not need to exist because
    its content could be implied using defaults. For example, it might default to
    the current SDK and its target .NET version, and so on. But it gets complicated,
    so we will have to wait and see if this ever happens.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Northwind sample database with SQLiteStudio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use a cross-platform graphical database manager named **SQLiteStudio**
    to easily manage SQLite databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://sqlitestudio.pl](https://sqlitestudio.pl), and then download
    and install the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start **SQLiteStudio**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Database** | **Add a database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Database** dialog, in the **File** section, click on the yellow folder
    button to browse for an existing database file on the local computer, select the
    `Northwind.db` file in the `WorkingWithEFCore` project folder, and then click
    **OK**, as shown in *Figure 10.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Adding the Northwind.db database file to SQLiteStudio'
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot see the database, then navigate to **View** | **Databases**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Databases** window, right-click on the `Northwind` database and choose
    **Connect to the database** (or just double-click `Northwind`). You will see the
    10 tables that were created by the script. (The script for SQLite is simpler than
    the one for SQL Server; it does not create as many tables or other database objects.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Products** table and choose **Edit the table**, or just
    double-click the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the table editor window, note the structure of the `Products` table, including
    column names, data types, keys, and constraints, as shown in *Figure 10.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The table editor in SQLiteStudio showing the structure of the
    Products table'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table editor window, click the **Data** tab, and you will see 77 products,
    as shown in *Figure 10.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: The Data tab showing the 77 rows in the Products table'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Database** window, right-click `Northwind` and select **Disconnect
    from the database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quit SQLiteStudio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the lightweight ADO.NET database providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Entity Framework, there was **ADO.NET**. Compared to EF, this is a simpler
    and more efficient API for working with databases. It provides abstract classes
    like `DbConnection`, `DbCommand`, and `DbReader`, and provider-specific implementations
    of them like `SqlConnection` and `SqlCommand`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, if you choose to use SQL Server, then you should use the `SqlConnectionStringBuilder`
    class to help write a valid connection string. This is because it has properties
    for all possible parts of a database connection string that you set individually
    and then it returns the complete string. You should also get sensitive secrets
    like passwords from an environment variable or a secret management system instead
    of writing them in your source code.
  prefs: []
  type: TYPE_NORMAL
- en: For SQLite, the connection string is so simple that you do not need to use the
    `SqliteConnectionStringBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: The EF Core database providers for SQLite and SQL Server are built on top of
    the ADO.NET libraries, so EF Core is always inherently slower than ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use native **ahead-of-time** (**AOT**) publishing, be aware that
    EF Core does not yet support it. This means you can only use the ADO.NET libraries
    if you plan to compile to native code. The EF Core team is investigating how they
    can support native AOT, but it is challenging so it has not happened with EF Core
    9 this year. Hopefully, it will happen for EF Core 10 in 2025.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from `SqlConnectionStringBuilder`, this book does not cover using the
    ADO.NET library, but I do cover examples of how to publish native AOT minimal
    API web services using the ADO.NET for SQL Server library in the companion book,
    *Apps and Services with .NET 8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the ADO.NET for SQLite library at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/](https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the ADO.NET for SQL Server library at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/sql/connect/ado-net/microsoft-ado-net-sql-server](https://learn.microsoft.com/en-us/sql/connect/ado-net/microsoft-ado-net-sql-server)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** All `System.Data.SqlClient` users are encouraged to transition
    to `Microsoft.Data.SqlClient`. You can read the announcement about how `System.Data.SqlClient`
    package is now deprecated at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://techcommunity.microsoft.com/t5/sql-server-blog/announcement-system-data-sqlclient-package-is-now-deprecated/ba-p/4227205](https://techcommunity.microsoft.com/t5/sql-server-blog/announcement-system-data-sqlclient-package-is-now-deprecated/ba-p/4227205)'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an EF Core database provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the practicalities of managing data using EF Core, let’s
    briefly talk about choosing between EF Core database providers. To manage data
    in a specific database, we need classes that know how to efficiently talk to that
    database.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core database providers are sets of classes that are optimized for a specific
    data store. There is even a provider for storing the data in the memory of the
    current process, which can be useful for high-performance unit testing since it
    avoids hitting an external system.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are distributed as NuGet packages, as shown in *Table 10.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **To manage this data store** | **Reference this NuGet package** |'
  prefs: []
  type: TYPE_TB
- en: '| SQL Server 2012 or later | `Microsoft.EntityFrameworkCore.SqlServer` |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite 3.7 or later | `Microsoft.EntityFrameworkCore.SQLite` |'
  prefs: []
  type: TYPE_TB
- en: '| In-memory | `Microsoft.EntityFrameworkCore.InMemory` |'
  prefs: []
  type: TYPE_TB
- en: '| Azure Cosmos DB SQL API | `Microsoft.EntityFrameworkCore.Cosmos` |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL | `MySQL.EntityFrameworkCore` |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle DB 11.2 | `Oracle.EntityFrameworkCore` |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | `Npgsql.EntityFrameworkCore.PostgreSQL` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.1: NuGet packages for common EF Core database providers'
  prefs: []
  type: TYPE_NORMAL
- en: You can reference as many EF Core database providers in the same project as
    you need. Each package includes the common shared types, as well as provider-specific
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a named SQLite database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect to an SQLite database, we just need to know the database path and
    filename, set using the legacy parameter `Filename` or the modern equivalent,
    `Data Source`. The path can be relative to the current directory or an absolute
    path. We specify this information in a **connection string**.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Northwind database context class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class named `Northwind` will be used to represent the database. To use EF
    Core, the class must inherit from `DbContext`. The `DbContext` class understands
    how to communicate with databases and dynamically generate SQL statements to query
    and manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: Your `DbContext`-derived class should have an overridden method named `OnConfiguring`,
    which will set the database connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a project that uses SQLite, but feel free to use SQL Server
    or some other database system if you feel comfortable doing so instead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithEFCore` project, add a package reference to the EF Core
    provider for SQLite and globally and statically import the `System.Console` class
    for all C# files, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WorkingWithEFCore` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After February 2025, you will be able to try out previews of EF Core 10 by specifying
    version `10.0-*`, so you must also install a preview of .NET 10 SDK. The target
    framework for your project must be `net10.0`. By using a wildcard, you will automatically
    download the latest monthly preview when you restore the packages for the project.
    Once the EF Core 10 GA version is released in November 2025, change the package
    version to `10.0.0`. After February 2026, you will be able to do the same with
    EF Core 11 and that will continue to require a project targeting `net10.0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the project folder, add a new class file named `NorthwindDb.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `NorthwindDb.cs`, import the main namespace for EF Core, define a class
    named `NorthwindDb`, and make the class inherit from `DbContext`. Then, in an
    `OnConfiguring` method, configure the options builder to use SQLite with an appropriate
    database connection string, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Some code editors like Visual Studio will automatically
    add a call to the base class member when you override a member. Although this
    is generally good practice, it is unnecessary in this case because the base implementation
    does nothing. To decide if you need to keep the call or not, view the tooltip
    or definition of the member. If you hover over the `OnConfiguring` method name,
    its tooltip tells you “The base implementation does nothing.” If you **Go To Definition**
    (*F12*) of the method, you will see that it does nothing, as shown in the following
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method only exists in the base class so that subclasses can override it
    and then EF Core can call your code when it needs to configure the data context.
    It would be a waste for your overridden method implementation to call the base
    implementation. If your code editor adds the call to the base class automatically,
    then you should delete the statement to make your code match the code in the book.
    The same applies later in the book when you override the `OnModelCreating` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements. Then, import the `Northwind.EntityModels`
    namespace and output the database provider, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the output showing the database connection string
    and which database provider you are using, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now know how to connect to a database by defining the EF Core data context.
    Next, we need to define a model that represents the tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Defining EF Core models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core uses a combination of **conventions**, **annotation attributes**, and
    **Fluent API** statements to build an **entity model** at runtime, which enables
    any actions performed on the classes to later be automatically translated into
    actions performed on the actual database. An **entity class** represents the structure
    of a table, and an instance of the class represents a row in that table.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will review the three ways to define a model, with code examples,
    and then we will create some classes that implement those techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core conventions to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we will write will use the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a table is assumed to match the name of a `DbSet<T>` property in
    the `DbContext` class, for example, `Products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of the columns are assumed to match the names of properties in the
    entity model class, for example, `ProductId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` .NET type is assumed to be a `nvarchar` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `int` .NET type is assumed to be an `int` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key is assumed to be a property that is named `Id` or `ID`, or when
    the entity model class is named `Product`, then the property can be named `ProductId`
    or `ProductID`. If this property is an integer type or the `Guid` type, then it
    is also assumed to be an `IDENTITY` column (a column type that automatically assigns
    a value when inserting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: There are many other conventions that you should know, and
    you can even define your own, but that is beyond the scope of this book. You can
    read about them at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/ef/core/modeling/](https://learn.microsoft.com/en-us/ef/core/modeling/)'
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core annotation attributes to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conventions often aren’t enough to completely map the classes to the database
    objects. A simple way of making your model smarter is to apply annotation attributes.
    Some common attributes recognized by EF Core are shown in *Table 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[Required]` | This ensures the value is not null. In .NET 8, it has a `DisallowAllDefaultValues`
    parameter to prevent value types from having their default value. For example,
    an `int` cannot be `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[StringLength(50)]` | This ensures the value is up to 50 characters in length.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | This specifies the column
    type and column name used in the table. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.2: Common EF Core annotation attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** `[StringLength]` is not honored by all EF Core data providers.
    For example, although SQL Server honors it, SQLite does not. For SQLite, use `[Column(TypeName
    = "text(50)")]` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional attributes that can be used to validate entities and are recognized
    by platforms like ASP.NET Core and Blazor for validation are shown in *Table 10.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[RegularExpression(expression)]` | This ensures the value matches the specified
    regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `[EmailAddress]` | This ensures the value contains one `@` symbol, but not
    as the first or last character. It does not use a regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `[Range(1, 10)]` | This ensures a `double`, `int`, or `string` value within
    a specified range. New in .NET 8 are the parameters `MinimumIsExclusive` and `MaximumIsExclusive`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[Length(10, 20)]` | This ensures a string or collection is within a specified
    length range, for example, a minimum of 10 characters or items, and a a maximum
    of 20 characters or items. |'
  prefs: []
  type: TYPE_TB
- en: '| `[Base64String]` | This ensures the value is a well-formed Base64 string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[AllowedValues]` | This ensures the value is one of the items in the `params`
    array of objects. For example, `"alpha"`, `"beta"`, `"gamma"`, or `1`, `2`, `3`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[DeniedValues]` | Ensures value is not one of the items in the `params`
    array of objects. For example, `"alpha"`, `"beta"`, `"gamma"`, or `1`, `2`, `3`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.3: Validation annotation attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does the `EmailAddress` attribute seem so basic? According to a comment
    by ajcvickers, who also closed the GitHub issue, “*The check is intentionally
    naive because doing something infallible is very hard. The email really should
    be validated in some other way, such as through an email confirmation flow where
    an email is actually sent. The validation attribute is designed only to catch
    egregiously wrong values such as for a U.I.*” You can read the debate at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/runtime/issues/27592](https://github.com/dotnet/runtime/issues/27592)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the database, the maximum length of a product name is 40, and
    the value cannot be null, as shown highlighted in the following **data definition
    language** (**DDL**) code from the `Northwind4SQLite.sql` script file, which defines
    how to create a table named `Products` with its columns, data types, keys, and
    other constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In a `Product` class, we could apply attributes to specify this, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When there isn’t an obvious map between .NET types and database types, an attribute
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the database, the column type of `UnitPrice` for the `Products`
    table is `money`. .NET does not have a `money` type, so it should use `decimal`
    instead, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the EF Core Fluent API to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last way that the model can be defined is by using the Fluent API. This
    API can be used instead of attributes, as well as in addition to them. For example,
    to define the `ProductName` property, instead of decorating the property with
    two attributes, an equivalent Fluent API statement could be written in the `OnModelCreating`
    method of the database context class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This keeps the entity model class simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data seeding with the Fluent API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another benefit of the Fluent API is to provide initial data to populate a database.
    EF Core automatically works out which insert, update, or delete operations must
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to make sure that a new database had at least one
    row in the `Products` table, then we would call the `HasData` method, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Calls to `HasData` take effect either during a data migration executed by the
    command `dotnet ef database update` or when you call the `Database.EnsureCreated`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Our model will map to an existing database that is already populated with data,
    so we will not need to use this technique in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Building EF Core models for the Northwind tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned about the ways to define EF Core models, let’s build
    models to represent two of the tables in the `Northwind` database. For reuse,
    we will do this in a separate class library project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two entity classes will refer to each other, so to avoid compiler errors,
    we will create the classes without any members first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project template**: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project file and folder**: `Northwind.EntityModels`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution file and folder**: `Chapter10`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Northwind.EntityModels` project, delete the file named `Class1.cs` and
    then add two class files named `Category.cs` and `Product.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Category.cs`, define a class named `Category`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Product.cs`, define a class named `Product`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `WorkingWithEFCore` project, add a project reference to the `Northwind.EntityModels`
    project, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The project reference path and filename must all go on one line.
  prefs: []
  type: TYPE_NORMAL
- en: Build the `WorkingWithEFCore` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the Category and Product entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Category` class, also known as an entity model, will be used to represent
    a row in the `Categories` table. This table has four columns, as shown in the
    following DDL taken from the `Northwind4SQLite.sql` script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use conventions to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Three of the four properties (we will not map the `Picture` column)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one-to-many relationship to the `Products` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To map the `Description` column to the correct database type, we will need to
    decorate the `string` property with the `Column` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will use the Fluent API to define that `CategoryName`
    cannot be null and is limited to a maximum of 15 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.EntityModels` project, modify the `Category` entity model
    class, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Category` class will be in the `Northwind.EntityModels` namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CategoryId` property follows the primary key naming convention, so it will
    be mapped to a column marked as the primary key with an index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CategoryName` property maps to a column that does not allow database NULL
    values, so it is a non-nullable string. To disable nullability warnings, we have
    assigned the null-forgiving operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Description` property maps to a column with the `ntext` data type instead
    of the default mapping for `string` values to `nvarchar`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We initialize the collection of `Product` objects to a new, empty `HashSet`.
    A hash set is more efficient than a list because it is unordered. If you do not
    initialize `Products`, then it will be null and if you try to get its `Count`,
    then you will get an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modify the `Product` class, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Product` class will be used to represent a row in the `Products` table,
    which has 10 columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You do not need to include all columns from a table as properties of a class.
    We will only map six properties: `ProductId`, `ProductName`, `UnitPrice`, `UnitsInStock`,
    `Discontinued`, and `CategoryId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columns that are not mapped to properties cannot be read or set using the class
    instances. If you use the class to create a new object, then the new row in the
    table will have `NULL` or some other default value for the unmapped column values
    in that row. You must make sure that those missing columns are optional or have
    default values set by the database, or else an exception will be thrown at runtime.
    In this scenario, the rows already have data values and I have decided that I
    do not need to read those values in this application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can rename a column by defining a property with a different name, like `Cost`,
    and then decorating the property with the `[Column]` attribute and specifying
    its column name, like `UnitPrice`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final property, `CategoryId`, is associated with a `Category` property that
    will be used to map each product to its parent category.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two properties that relate to the two entities, `Category.Products` and
    `Product.Category`, are both marked as `virtual`. This allows EF Core to inherit
    and override the properties to provide extra features, such as lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tables to the Northwind database context class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside your `DbContext`-derived class, you must define at least one property
    of the `DbSet<T>` type. These properties represent the tables. To tell EF Core
    what columns each table has, the `DbSet<T>` properties use generics to specify
    a class that represents a row in the table. That entity model class has properties
    that represent its columns.
  prefs: []
  type: TYPE_NORMAL
- en: The `DbContext`-derived class can optionally have an overridden method named
    `OnModelCreating`. This is where you can write Fluent API statements as an alternative
    to decorating your entity classes with attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithEFCore` project, modify the `NorthwindDb` class to add statements
    to define two properties for the two tables and an `OnModelCreating` method, as
    shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `decimal` type is not supported by the SQLite database provider for sorting
    and other operations. We can fix this by telling the model that `decimal` values
    can be treated as `double` values when using the SQLite database provider. This
    does not actually perform any conversion at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen some examples of defining an entity model manually, let’s
    look at a tool that can do some of the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the dotnet-ef tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET CLI tool named `dotnet` can be extended with capabilities useful for
    working with EF Core. It can perform design-time tasks like creating and applying
    migrations from an older model to a newer model and generating code for a model
    from an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dotnet-ef` command-line tool is not automatically installed. You must
    install this package as either a **global** or **local tool**. If you have already
    installed an older version of the tool, then you should update it to the latest
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, check if you have already installed `dotnet-ef`
    as a global tool, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check in the list if an older version of the tool has been installed, like
    the one for .NET 7, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If an old version is already installed, then update the tool, as shown in the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If it is not already installed, then install the latest version, as shown in
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If necessary, follow any OS-specific instructions to add the `dotnet tools`
    directory to your `PATH` environment variable, as described in the output of installing
    the `dotnet-ef` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the latest GA release of .NET will be used to install the tool.
    To explicitly set a version, for example, to use a preview, add the `--version`
    switch. As another example, to update to the latest .NET 9 preview version available
    from February 2024 to October 2024, use the following command with a version wildcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once the .NET 9 GA release happens in November 2024, you can just use the command
    without the `--version` switch to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also remove the tool, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Scaffolding models using an existing database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scaffolding is the process of using a tool to create classes that represent
    the model of an existing database using reverse engineering. A good scaffolding
    tool allows you to extend the automatically generated classes because they are
    `partial` and then regenerate those classes without losing your `partial` classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that you will never regenerate the classes using the tool, then
    feel free to change the code for the automatically generated classes as much as
    you want. The code generated by the tool is just the best approximation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not be afraid to overrule a tool when you know better.'
  prefs: []
  type: TYPE_NORMAL
- en: The instructions in this section apply to any data provider, not just SQLite.
    Whatever data provider you use, you will need to add a reference to the `Microsoft.EntityFrameworkCore.Design`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if the tool generates the same model as we did manually:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the latest version of the `Microsoft.EntityFrameworkCore.Design` package
    to the `WorkingWithEFCore` project, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: If you are unfamiliar with how packages like `Microsoft.EntityFrameworkCore.Design`
    can manage their assets, then you can learn more at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `WorkingWithEFCore` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a command prompt or terminal in the `WorkingWithEFCore` project folder.
    Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio, in **Solution Explorer**, right-click the `WorkingWithEFCore`
    project and select **Open in Terminal**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, start **File Explorer**, right-click the `WorkingWithEFCore` folder,
    and select **New Command Prompt at Folder** or **Open in Windows Terminal**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, start **Finder**, right-click the `WorkingWithEFCore` folder, and
    select **New Terminal at Folder**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Rider, in **Solution Explorer**, right-click the `WorkingWithEFCore`
    project and select **Open In** | **Terminal**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** When I say the `WorkingWithEFCore` project folder, I mean the
    folder that contains the `WorkingWithEFCore.csproj` project file. If you enter
    the command in a folder that does not contain a project file, then you will see
    the following error: `No project was found. Change the current working directory
    or use the --project option`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You are about to enter a long command. I recommend that
    you type from the print book or copy and paste long commands like this from the
    eBook into a plain text editor like Notepad. Then make sure that the whole command
    is properly formatted as a single line with correct spacing. Only then should
    you copy and paste it into the command prompt or terminal. Copying and pasting
    directly from the eBook is likely to include newline characters and missing spaces
    that break the command if you aren’t careful. Also, remember that all commands
    are available to copy at [https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md](https://github.com/markjprice/cs13net9/blob/main/docs/command-lines.md).
    **Warning!** If you copy from a PDF, double-dashes in a command link are sometimes
    lost, so be careful!'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, use the `dotnet-ef` tool to generate a model
    for the `Categories` and `Products` tables in a new folder named `AutoGenModels`,
    as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command action: `dbcontext scaffold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The connection string: `"Data Source=Northwind.db"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tables to generate models for: `--table Categories --table Products`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output folder: `--output-dir AutoGenModels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace: `--namespace WorkingWithEFCore.AutoGen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To rename the context from `[database_name]Context`: `--context NorthwindDb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you prefer to use SQL Server, then the equivalent command is found at the
    following link:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#scaffolding-models-using-an-existing-database](https://github.com/markjprice/cs13net9/blob/main/docs/sql-server/README.md#scaffolding-models-using-an-existing-database)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note the build messages and warnings, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reviewing the scaffolded code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s review the scaffolded code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AutoGenModels` folder, note the three class files that were automatically
    generated: `Category.cs`, `NorthwindDb.cs`, and `Product.cs`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AutoGenModels` folder, in `Category.cs`, note the differences compared
    to the one you created manually. I have not included namespace imports to save
    space, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It decorates the entity class with the `[Index]` attribute, which was introduced
    in EF Core 5\. This indicates properties that should have an index when using
    the Code First approach to generate a database at runtime. Since we are using
    Database First with an existing database, this is not needed. But if we wanted
    to recreate a new, empty database from our code, then this information would be
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table name in the database is `Categories` but the `dotnet-ef` tool uses
    the **Humanizer** third-party library to automatically singularize the class name
    to `Category`, which is a more natural name when creating a single entity that
    represents a row in the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entity class is declared using the `partial` keyword so that you can create
    a matching `partial` class for adding additional code. This allows you to rerun
    the tool and regenerate the entity class without losing that extra code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CategoryId` property is decorated with the `[Key]` attribute to indicate
    that it is the primary key for this entity. The data type for this property is
    `int` for SQLite and `long` for SQL Server. We did not need to decorate the property
    in our code because we followed the naming primary key convention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CategoryName` property is decorated with the `[Column(TypeName = "nvarchar
    (15)")]` attribute, which is only needed if you want to generate a database from
    the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We chose not to include the `Picture` column as a property because this is a
    binary object that we will not use in our console app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Products` property uses the `[InverseProperty]` attribute to define the
    foreign key relationship to the `Category` property on the `Product` entity class,
    and it initializes the collection to a new empty list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `AutoGenModels` folder, in `Product.cs`, note the differences compared
    to the one you created manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AutoGenModels` folder, in `NorthwindDb.cs`, note the differences compared
    to the one you created manually, as shown in the following edited-for-space code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `NorthwindDb` data context class is `partial` to allow you to extend it
    and regenerate it in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has two constructors: a default parameter-less one and one that allows options
    to be passed in. This is useful in apps where you want to specify the connection
    string at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnConfiguring` method, if options have not been specified in the constructor,
    then it defaults to using a connection string that looks for the database file
    in the current folder. It has a compiler warning to remind you that you should
    not hardcode security information in this connection string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnModelCreating` method, the Fluent API is used to configure the two
    entity classes, and then a `partial` method named `OnModelCreatingPartial` is
    invoked. This allows you to implement that `partial` method in your own `partial`
    `Northwind` class to add your own Fluent API configuration that will not be lost
    if you regenerate the model classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the automatically generated class files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customizing the reverse engineering templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the features introduced with EF Core 7 was the ability to customize the
    code that is automatically generated by the `dotnet-ef` scaffolding tool. This
    is an advanced technique, so I do not cover it in this book. Usually, it is easier
    to just modify the code that is generated by default anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to learn how to modify the T4 templates used by the `dotnet-ef`
    scaffolding tool, then you can find that information at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/templates](https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/templates)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring preconvention models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with support for the `DateOnly` and `TimeOnly` types for use with the
    SQLite database provider, one of the features introduced with EF Core 6 was configuring
    preconvention models.
  prefs: []
  type: TYPE_NORMAL
- en: As models become more complex, relying on conventions to discover entity types
    and their properties and successfully map them to tables and columns becomes harder.
    It would be useful if you could configure the conventions themselves before they
    are used to analyze and build a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to define a convention to say that all `string`
    properties should have a maximum length of 50 characters as a default, or any
    property types that implement a custom interface should not be mapped, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the rest of this chapter, we will use the classes that you manually created.
  prefs: []
  type: TYPE_NORMAL
- en: Querying EF Core models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a model that maps to the `Northwind` database and two of its
    tables, we can write some simple **Language-Integrated Query** (**LINQ**) queries
    to fetch data. You will learn much more about writing LINQ queries in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*.
  prefs: []
  type: TYPE_NORMAL
- en: '**LINQ to Entities** (a.k.a. **LINQ to EF Core**) is a LINQ provider that converts
    a LINQ query into SQL to execute against the database. You can write a LINQ query
    built up over many C# statements.'
  prefs: []
  type: TYPE_NORMAL
- en: You can discover the equivalent SQL statement without executing the query against
    the database by calling `ToQueryString`. This is known as deferred execution.
    Only when the query is enumerated using `foreach`, or when you call a method like
    `ToArray` or `ToList` on the LINQ query, will you trigger the execution of the
    query against the database and the results are returned to your code. This is
    known as **materialization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, just write the code and view the results:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WorkingWithEFCore` project, add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with some methods, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class file named `Program.Queries.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Queries.cs`, define a partial `Program` class with a `QueryingCategories`
    method, and add statements to do these tasks, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database. Database
    context instances are designed for short lifetimes in a unit of work. They should
    be disposed of as soon as possible. So, we will wrap our instance in a `using`
    statement. In *Chapter 13*, *Building Websites Using ASP.NET Core*, you will learn
    how to get database context using dependency injection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for all categories that include their related products. `Include`
    is an extension method that requires you to import the `Microsoft.EntityFrameworkCore`
    namespace.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate through the categories, outputting the name and number of products
    for each one:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that the order of the clauses in the `if` statement is important. We must
    check that `categories` is `null` first. If this is `true`, then the code will
    never execute the second clause and, therefore, won’t throw a `NullReferenceException`
    when accessing the `Any()` member.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the two statements that create a `Northwind` instance
    and output the database provider name, and then call the `ConfigureConsole` and
    `QueryingCategories` methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** If you see the following exception, the most likely problem is
    that the `Northwind.db` file is not being copied to the output directory: `Unhandled
    exception. Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1:
    ''no such table: Categories''`. Make sure that **Copy to Output Directory** is
    set, but even when it is, some code editors do not always copy the file when they
    should. You might need to manually copy the `Northwind.db` file to the appropriate
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering included entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EF Core 5 introduced **filtered includes**, which means you can specify a lambda
    expression in the `Include` method call to filter which entities are returned
    in the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Queries.cs`, define a `FilteredIncludes` method and add statements
    to do these tasks, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt the user to enter a minimum value for units in stock.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for categories that have products with that minimum number of
    units in stock.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate through the categories and products, outputting the name and units
    in stock for each one:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, call the `FilteredIncludes` method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter a minimum value for units in stock, like `100`, and view
    the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Unicode characters in the Windows console**: There is a limitation with the
    console provided by Microsoft on versions of Windows before the Windows 10 Fall
    Creators Update. By default, the console cannot display Unicode characters, for
    example, the ones in the name Rhönbräu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have this issue, then you can temporarily change the code page (also
    known as the character set) in a console to Unicode UTF-8 by entering the following
    command at the prompt before running the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Filtering and sorting products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore a more complex query that will filter and sort data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Queries.cs`, define a `QueryingProducts` method, and add statements
    to do the following, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt the user for a price for products.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for products that cost more than the price using LINQ.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop through the results, outputting the ID, name, cost (formatted in US dollars),
    and number of units in stock:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, call the `QueryingProducts` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter `50` when prompted to enter a product price, view the result,
    and note the descending order by cost, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `500` when prompted to enter a product price, and view
    the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting the generated SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be wondering how well written the SQL statements are that are generated
    from the C# queries we write. EF Core 5 introduced a quick and easy way to see
    the SQL generated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `QueryingProducts` method, before using the `foreach` statement to enumerate
    the query, add a statement to output the generated SQL, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The `ToQueryString` method can only work on objects that implement
    `IQueryable`. This means that if you write a LINQ query using deferred methods
    like `Where`, `GroupBy`, `Select`, `OrderBy`, `Join`, `Take`, `Skip`, `Reverse`,
    and so on, then `ToQueryString` can show you the SQL before you run the query.
    But methods that return a non-`IQueryable` value and immediately execute the query,
    like a single scalar result like `Count()` or `First()`, do not support `ToQueryString`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter a minimum value for units in stock, like `95`, and view
    the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the SQL parameter named `@__stock_0` has been set to a minimum stock
    value of `95`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you used SQL Server, the generated SQL will be slightly different. For example,
    it uses square brackets instead of double quotes around object names, as shown
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Logging EF Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To monitor the interaction between EF Core and the database, we can enable logging.
    Logging could be to the console, to `Debug` or `Trace`, or to a file. Enabling
    logging for EF Core shows all of the SQL commands that are actually executed against
    the database. `ToQueryString` does not execute against the database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: By default, EF Core logging will exclude any data that is
    sensitive. You can include this data by calling the `EnableSensitiveDataLogging`
    method, especially during development. You should disable it before deploying
    to production. You can also call `EnableDetailedErrors`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NorthwindDb.cs`, at the bottom of the `OnConfiguring` method, add statements
    to log to the console and to include sensitive data like parameter values for
    commands being sent to the database if we compile the debug configuration, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LogTo` requires an `Action<string>` delegate. EF Core will call this delegate,
    passing a `string` value for each log message. Passing the `Console` class `WriteLine`
    method, therefore, tells the logger to write each method to the console.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that when the solution configuration is **Debug**, the calls to the `EnableSensitiveDataLogging`
    and `EnableDetailedErrors` methods are included in the compilation, but if you
    change the solution configuration to **Release**, the method calls are grayed
    out to indicate that they are not compiled, as shown in *Figure 10.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Including SQL parameters in logging for debug configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the log messages, which are shown in the following partial
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your logs might vary from those shown above based on your chosen database provider
    and code editor, as well as future improvements to EF Core. For now, note that
    different events, like opening a connection or executing a command, have different
    event IDs, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`20000` `RelationalEventId.ConnectionOpening`: Includes the database file path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`20001` `RelationalEventId.ConnectionOpened`: Includes the database file path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`20100` `RelationalEventId.CommandExecuting`: Includes the SQL statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering logs by provider-specific values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The event ID values and what they mean will be specific to the EF Core provider.
    If we want to know how the LINQ query has been translated into SQL statements
    and is executing, then the event ID to output has an `Id` value of `20100`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `NorthwindDb.cs`, import the namespace for working for EF Core
    diagnostics, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `LogTo` method call to only output events with an `Id` of `20100`,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the following SQL statements that were logged, as shown
    in the following output, which has been edited for space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Logging with query tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When logging LINQ queries, it can be tricky to correlate log messages in complex
    scenarios. EF Core 2.2 introduced the query tags feature to help by allowing you
    to add SQL comments to the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can annotate a LINQ query using the `TagWith` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add an SQL comment to the log, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Getting a single entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two LINQ methods to get a single entity: `First` and `Single`. It
    is important to understand the difference between them when using an EF Core database
    provider. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Queries.cs`, define a `GettingOneProduct` method, and add statements
    to do the following, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt the user for a product ID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for products with that product ID using the `First` and `Single`
    methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write an SQL statement for each query to the console:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: LINQ methods that fetch a single entity (`First`, `FirstOrDefault`, `Single`,
    `SingleOrDefault`, `ElementAt`, and `ElementAtOrDefault`) or return a single scalar
    value or entity like the aggregate methods (`Count`, `Sum`, `Max`, `Min`, `Average`,
    `All`, `Any`, and so on) are not deferred. When using the LINQ to Entities provider,
    any LINQ query that ends with a call to one of these methods is immediately converted
    to an SQL statement and executed against the database.
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs`, call the `GettingOneProduct` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter `1` when prompted to enter a product ID, view the result,
    and note the SQL statements used by `First` and `Single`, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that both methods execute the same SQL statement except for the `LIMIT`
    clauses highlighted in the preceding code. For `First`, it sets `LIMIT 1` but
    for `Single`, it sets `LIMIT 2`. Why?
  prefs: []
  type: TYPE_NORMAL
- en: For `First`, the query can match one or more entities and only the first will
    be returned. If there are no matches, an exception is thrown, but you can call
    `FirstOrDefault` to return `null` if there are no matches.
  prefs: []
  type: TYPE_NORMAL
- en: For `Single`, the query must match only one entity and it will be returned.
    If there is more than one match, an exception must be thrown. But the only way
    for EF Core to know if there is more than one match is to request more than one
    and check. So, it has to set `LIMIT 2` and check if there is a second entity match.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you do not need to make sure that only one entity matches,
    use `First` instead of `Single` to avoid retrieving two records.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with Like
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EF Core supports common SQL statements, including `Like` for pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Queries.cs`, add a method named `QueryingWithLike`, as shown in
    the following code, and note the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have enabled logging.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We prompt the user to enter part of a product name and then use the `EF.Functions.Like`
    method to search anywhere in the `ProductName` property.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each matching product, we output its name, stock, and if it is discontinued:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment out the existing methods and call `QueryingWithLike`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter a partial product name, such as `che`, and view the result,
    as shown in the following edited output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: You can learn more about wildcards with `Like` at [https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/like-entity-sql](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/like-entity-sql).'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a random number in queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EF Core 6 introduced a useful function, `EF.Functions.Random`, that maps to
    a database function returning a pseudo-random real number between `0.0` and `1.0`,
    exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you’re developing a quiz or survey app that needs to display
    questions in a random order each time a user takes it. You can use `EF.Functions.Random()`
    to fetch a random selection of questions directly from the database, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'During the development and testing phase, generating random data can be useful
    for simulating various scenarios. For example, creating randomized datasets for
    performance testing or generating random sets of rows for unit tests by selecting
    about half of the products randomly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Defining global filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Northwind` products can be discontinued, so it might be useful to ensure that
    discontinued products are never returned in results, even if the programmer does
    not use `Where` to filter them out in their queries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NorthwindDb.cs`, at the bottom of the `OnModelCreating` method, add a global
    filter to remove discontinued products, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, uncomment the call to `QueryingWithLike`, and comment out all
    the other method calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter the partial product name `che`, view the result, and note
    that `Chef Anton''s Gumbo Mix` is now missing. This is because the SQL statement
    generated includes a filter for the `Discontinued` column, as shown highlighted
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: SQL SELECT queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, you can express all the queries you need to using LINQ. But for times
    when you cannot, you can use `FromSql` and its related methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`FromSql` was introduced with EF Core 7\. If you need to execute raw SQL with
    EF Core 6 or earlier, then you must use the `FromSqlInterpolated` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The `FromSql` method allows you to execute raw SQL queries against the database
    and map the results to your entity classes. `FromSql` can be used to perform `SELECT`
    queries that return entity types or types that are not part of the EF Core model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FromSql` method is particularly useful in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to run complex SQL queries that might not be feasible with LINQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, raw SQL can be more performant than LINQ for certain types of queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are working with a legacy system where specific SQL queries need to be
    executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can execute stored procedures that return entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter to `FromSql` must be a `FormattableString`, not just a regular
    `string` value. This is to enforce safe parameterization. Pass parameter values
    using the interpolated `string` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Queries.cs`, add a method named `GetProductUsingSql`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, add a call to `GetProductUsingSql`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FromSql` can only be called on a `DbSet<T>`, not on a LINQ query.'
  prefs: []
  type: TYPE_NORMAL
- en: You can make the SQL even more dynamic for scenarios that need it. For example,
    if the name of a column might change, as well as the value, then you can use `FromSqlRaw`.
    But beware! You are responsible for ensuring this `string` value is secure, especially
    if it originates from an untrusted source. This involves identifying special characters
    like semicolons, comments, and other SQL constructs, and then properly escaping
    or rejecting these inputs to prevent potential security risks.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about dynamic SQL and parameters at
    [https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters](https://learn.microsoft.com/en-us/ef/core/querying/sql-queries#dynamic-sql-and-parameters).'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now seen many common ways to query data using EF Core. In some online
    sections, you can look at how data is loaded and tracked and why you might want
    to control how EF Core does that.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.1 – online materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online materials can be extra content written by me for this book, or they can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and tracking patterns with EF Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learn how data is loaded and tracked with EF Core at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-loading-tracking.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-loading-tracking.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying data with EF Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learn how data can be modified with EF Core at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-modifying.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-modifying.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add transactions to the modification code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-transactions.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-transactions.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Code First EF Core model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Work through an example of a Code First model that generates an empty database,
    seeds it with sample data, and then queries the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-code-first.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-code-first.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring app secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When connecting to a database, you often need to include sensitive secret values
    like a username or password. These values should never be stored in source code
    or even in a separate file that might be added to a code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secrets should be stored locally during development and in secure systems for
    production. You can use **Secret Manager** during local development and **Azure
    Key Vault** for cloud production systems. To learn more about app secrets, I have
    written an online-only section that you can read at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch10-app-secrets.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch10-app-secrets.md)'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter focused on RDBMSs such as SQL Server and SQLite. If you wish to
    learn more about NoSQL databases, such as Cosmos DB and MongoDB, and how to use
    them with EF Core, then I recommend the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Welcome to Azure Cosmos DB**: [https://learn.microsoft.com/en-us/azure/cosmos-db/introduction](https://learn.microsoft.com/en-us/azure/cosmos-db/introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use NoSQL databases as a persistence infrastructure**: [https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure](https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document database providers for Entity Framework Core**: [https://github.com/BlueshiftSoftware/EntityFrameworkCore](https://github.com/BlueshiftSoftware/EntityFrameworkCore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 10.2 – practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting data using different serialization formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `Chapter10` solution, create a console app named `Exercise_DataSerialization`
    that queries the `Northwind` database for all the categories and products, and
    then serializes the data using at least three formats of serialization available
    to .NET. Which format of serialization uses the least number of bytes?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.3 – test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What type would you use for the property that represents a table, for example,
    the `Products` property of a database context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type would you use for a property that represents a one-to-many relationship,
    for example, the `Products` property of a `Category` entity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the EF Core convention for primary keys?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When might you use an annotation attribute in an entity class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might you choose the Fluent API in preference to annotation attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a transaction isolation level of `Serializable` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `DbContext.SaveChanges()` method return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between eager loading and explicit loading?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you define an EF Core entity class to match the following table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What benefit do you get from declaring entity navigation properties as `virtual`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 10.4 – explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use this link to learn more about the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-10---working-with-data-using-entity-framework-core](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-10---working-with-data-using-entity-framework-core)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to and build entity data models for an existing database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a simple LINQ query and process the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use filtered includes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute SQL queries directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to write more advanced LINQ queries
    to select, filter, sort, join, and group.
  prefs: []
  type: TYPE_NORMAL
