- en: Web Service Stack in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes how to deal with controllers and actions in a web service
    stack. Controllers are a fundamental part of ASP.NET Core; they are the entry
    point of the HTTP requests. In this chapter, we will look closely at the mechanics
    of the controller classes and how they can transfer information to the client
    using the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a controller?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling requests using controllers and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with DTO objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, the reader will have a general overview of the web
    stack provided by ASP.NET Core and will know how to deal with incoming HTTP requests
    using controllers and actions.
  prefs: []
  type: TYPE_NORMAL
- en: What is a controller?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers are the *C* part of the MVC pattern. They are a set of actions that
    usually handle requests from a client. You should bear in mind that what we are
    discussing in this chapter refers to the MVC stack that's defined by ASP.NET Core.
    Furthermore, if we take as reference the incoming requests, remember that they
    have already passed through the others middleware in the middleware pipeline and
    that they have already hit the *MVC middleware*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how a request is typically handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9541b7-bc49-4440-94c6-19cea945cfe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we discussed in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml),
    *REST 101 and Getting Started with ASP.NET Core*, the incoming request is usually
    generated by a client: the browser, another API, or an external system. The request
    is composed of an *HTTP verb,* a *URI*, *body payload*, and other additional information*.*
    The **Routing engine** handles the request and passes it to an *action method*
    inside one of our *controllers.* The **Action** methods usually proceed by providing
    a response. Furthermore, controllers usually interact with third-party systems
    through other classes, such as databases or other services. Finally, they serve
    the result in a specific format. In the case of MVC applications, they usually
    return a view, while in the case of the web API, they return the result in a format
    such as **JSON/XML**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73cd4cb1-2e15-40a0-ac07-5c22eab039de.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the flow of an incoming request through the model-controller
    stack. As you can see, the flow is omitting the views part of the MVC stack since
    it is not useful for the purpose of building web services. The next part focuses
    on controllers and explains how to identify a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers and actions are usually decorated with attributes and filters in
    a sort of meta-programming style, which allows developers to understand the purpose
    of the implemented code. ASP.NET Core follows a set of criteria to find the controllers
    in our project, usually by using a filesystem convention. Controllers are generally
    stored in the `Controllers` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be identified by the routing system, a controller class needs to
    be compliant with one of the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The class is suffixed with `Controller`, or it inherits from a class that has
    the `Controller` suffix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class is decorated with the `[Controller]` or the `[ApiController]` attribute,
    which identifies it as a controller class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 4](54bd7784-d757-4cbc-91d4-5362ca3a60de.xhtml),
    *Dependency Injection*, it is recommended to define controller dependencies using
    the constructor or action injection explicitly. The dependency injection approach
    improves the testability and maintainability of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how a widespread concept like inheritance can be applied to the
    controllers in order to extend their functionalities, and how ASP.NET Core provides
    some of the bases attributes to the controller classes using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Extending controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already mentioned, controllers are classes, therefore they can extend other
    types, including other controllers. This technique can be applied so that we can
    reuse a particular implementation or feature. In general, the controllers extend
    the `Controller` or `ControllerBase` classes, which are part of the ASP.NET Core
    framework. These base classes provide some utilities to manage requests and responses
    on behalf of the controller. First of all, let''s analyze the difference between
    the `Controller` and `ControllerBase` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ControllerBase` represents a base class for an MVC controller without view
    support. It provides some essential attributes to child classes, such as the `HttpContext`,
    `Request`, and `Response` attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Controller` class extends the `ControllerBase` class, but it also adds
    some properties and methods for managing views, such as the `ViewData` attribute
    and the `View()` and `PartialView()` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we deal with RESTful APIs and with web services in general, the `ControllerBase`
    class provides sufficient utilities. If we are dealing with views, however, we
    should extend the `Controller` class.
  prefs: []
  type: TYPE_NORMAL
- en: The ApiController attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From version 2.1, ASP.NET Core introduced a new attribute, that is, the `ApiController`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ApiController` attribute is commonly coupled with the `ControllerBase`
    class to enable REST-specific behavior for controllers, and it allows us to build
    HTTP APIs. First of all, it provides *implicit model state validation*, which
    means that we do not need to explicitly check the `ModelState.IsValid` attribute
    in each action. Secondly, it also implicitly defines the model binding attributes,
    which means that we do not need to specify the `[FromBody]`, `[FromForm]`, `[FromHeader]`,
    `[FromQuery]`, or `[FromRoute]` attributes for each parameter. ASP.NET Core will
    define these for us using the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[FromBody]` is used for complex type parameters, such as custom classes or
    built-in objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromForm]` is inferred for action parameters of the `IFormFile` or `IFormFileCollection`
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromRoute]` is inferred for any action parameter whose name matches a setting
    in the route template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromQuery]` is inferred for any other action parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s examine the following generic action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the application of the `ApiController` attribute, the action method can
    be minimized, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[FromBody]` attribute is implicitly specified because of the `ValueRequest`
    complex type. In the same way, the `ModelState.IsValid` check is also implicit:
    if the client passes a model that is not valid for the action, it will return
    `400 bad requests`. In the next section, we will look into the implementation
    of a simple controller that can handle and perform some logic using a repository
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests using controllers and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of action methods is to handle and respond to incoming requests.
    The example described in this section will show you how to deal with HTTP requests
    using controllers. We will apply some of the concepts we have looked at in previous
    chapters, such as dependency injection. The following example will use the same
    project structure we created in *Setting up an ASP.NET Core project* section of
    [Chapter 2](6127f023-703b-42e3-a76e-b70a7b110b90.xhtml), *Overview of ASP.NET
    Core.*
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this section is available on GitHub at [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection introduces a plain in-memory repository that will be used
    to store some data and retrieve it through our controller stack. The purpose of
    this type of repository is to set up a quick storage system without introducing
    any additional application complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an in-memory repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to create an *in-memory* repository is to define a singleton
    class with a private attribute, which represents a collection of elements. The
    repository will be initialized as a *singleton type*; therefore, this specific
    life cycle guarantees that data will be persistent until the application is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we don't need to use a repository with a real data source because
    we only need to focus on the HTTP part of our example and not how the data is
    stored. Later on in this book, we will take a look closer at the data access part.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a model that represents the data we want to store using
    our repository. Let''s create a new folder, called `Models`, and create a new
    class named `Order.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define a new interface called `IOrderRepository`. The interface
    represents our order repository, and it will be located in a new folder called
    `Repositories`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our interface is implemented by the `MemoryOrderRepository` class, which provides
    the concrete logic of our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `MemoryOrderRepository` class initializes a private list of the `Order`
    type. Furthermore, it also defines some operations that we can use to manipulate
    the list of orders, that are, the `Get`, `Add`, `Update`, and `Delete` methods.
    These methods use the LINQ syntax to act on the list elements. Furthermore, the
    main collection that's represented by the `_orders` attribute is declared as private
    in order to prevent any external access.
  prefs: []
  type: TYPE_NORMAL
- en: Note that each namespace path reflects the structure of the filesystem. For
    example, the `SampleAPI.Repositories` namespace reflects the `Sample.API/Repositories`
    filesystem path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can proceed by initializing the `MemoryOrderRepository` implementation
    as *a singleton.* To do that, we need to modify the `Startup` class and add our
    service to the *services collection* using the `AddSingleton` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The following example uses the `IOrderRepository` interface for demonstration
    and learning purposes. I strongly suggest that you avoid using singleton instances
    to store data in memory since singleton instances are not persistent storage,
    and this also causes performance degradation in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we now have an `Order` class that describes a single order. The
    `IOrderRepository` interface allows us to store and read the data, and it has
    an in-memory implementation provided by the `MemoryOrderRepository` type, which
    uses the memory as a data store. Now, we have all the necessary components so
    that we can deal with the data and we can proceed by handling the client request
    through our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Handling client requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time we implement a class, we should always bear the *single* *responsibility*
    *principle* in mind.Therefore*,* the action methods inside our controllers should
    be simple handlers that call methods that act as data. The controllers in an ASP.NET
    Core service usually behave as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They make calls other classes in order to obtain or update data held in, for
    example, a repository class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They handle exceptions. The action methods typically wrap the calls of other
    objects to catch exceptions. These are then presented to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enhance the returned data using the required HTTP conventions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s proceed and build our controller class by creating a new `OrderController`
    type inside the `Controllers` folder. This bit of code includes the `ApiController`
    attribute and the extension to the `ControllerBase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'ASP.NET Core provides two ways to deal with routing:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorating controllers with attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the default routing system (for example, using the `MapRoute` method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defining routes using attributes covers a lot of cases and is suitable for
    a range of business requirements. It is also more straightforward in regard to
    the maintainability and readability of our code. The `[Route("api/order")]` attribute
    maps a specific controller to one particular route. In this case, the `OrderController`
    will respond at the `//hostname/api/order` URI. In addition, the ASP.NET Core
    framework also provides two placeholders: `[controller]` and `[action]`. They
    can be used to refer to the current controller or to the immediate action. For
    example, the previous snippet can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I strongly suggest avoiding the use of the `[controller]` and `[action]` placeholders.
    If you refactor the name of your controllers or actions, you also change the routing
    of your service without throwing any errors. Therefore, it can cause problems
    in systems with interdependent services.
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed by initializing and resolving the dependencies of the `OrderController`
    class. Furthermore, we will see how we can inject and initialize the `IOrderRepository`
    interface into the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP methods using actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the `OrderController` definition and the `IOrderRepository`
    interface has been registered through the dependency injection engine, we can
    proceed by defining the explicit dependencies using *constructor injection*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderController` class depends on the `IOrderRepository` class, and it
    uses constructor injection to resolve the dependency. This dependency is clearly
    visible if we check the constructor signature of the controller. In most cases,
    you can get an idea of the level of complexity of a class by counting the number
    of dependencies that have been injected into the *constructor*. Therefore, as
    a general rule, when you see a class with a lot of dependencies injected into
    it, it is probably not compliant with the *single responsibility principle.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller classes usually group a set of action methods. As we discussed
    in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml), *REST 101 and Getting
    Started with ASP.NET Core*, HTTP verbs are essential in web APIs and REST services.
    They are used to indicate a specific operation on our data. For example, an HTTP
    GET corresponds to a read operation, while an HTTP POST corresponds to a creation
    action. Let''s continue with the implementation of the HTTP GET actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation describes two actions, which means there are two different
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Http verb** | **URI** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `hostname/api/order` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `GET` | `hostname/api/order/<guid>` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, ASP.NET Core handles incoming requests and maps
    them to actions using the routing middleware. Routes are defined both in the startup
    code and in the attributes. Each HTTP verb has its corresponding attribute: `HttpGet`
    corresponds to the `GET` method, `HttpPost` corresponds to the `POST` method,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, HTTP verb attributes have a signature that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The *template* is a stringparameter that represents the URL of a specific action.
    It may also accept some *routing constraints.* For example, `[HttpGet("{id:guid}")]`
    will receive a GUID identifier in the form of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will look at routing constraints in more detail in [Chapter 6](88a48d0b-32c6-4adb-b907-ecd8365a3659.xhtml),
    *Routing System*.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to bear in mind that routing constraints are not meant to be
    a validation system. If we have an invalid route, our service will return `404
    Not Found` and not `400 Bad Request`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Name` parameter of the attribute indicates the route name that identifies
    that action method. In general, it doesn''t have any impact on the routing system.
    Besides, it is used to refer to the routing rule during the generation of the
    URL, and it must be unique in the entire code base. By following the preceding
    specifications, it is easy to implement the other CRUD operations in our controller.
    The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve had a quick look at the implementation controller, let''s have
    a closer look at the actions that are defined by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **URI** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `hostname/api/order` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `GET` | `hostname/api/order/<guid>` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `POST` | `hostname/api/order` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `PUT` | `hostname/api/order/<guid>` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `DELETE` | `hostname/api/order/<guid>` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: We should also notice that the controller does not implement any validation
    on the input data. Furthermore, the `[ApiController]` attribute, when applied
    on top of a class, provides the *out-of-the-box validation* and model binding
    of ASP.NET Core. Therefore, all the associated objects, such as the `Order request`
    parameter, must be passed from the body of the request in case they are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the ASP.NET Core api, we should run our application by executing `dotnet
    run` inside the project folder and perform an HTTP request using `curl` or whatever
    client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command executes a GET request on the `/api/order` URL, using
    the `Content-Type: application/json`. Since ASP.NET Core provides HTTPS out-of-box
    we can ignore the certificate validation using the `-k` flag. Later in the book,
    we will see how to install the certificate locally.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For Windows users, starting from Windows 10, build 17063 ([https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/](https://devblogs.microsoft.com/commandline/tar-and-curl-come-to-windows/)),
    the OS ships with a copy of `curl` already set up and ready to use. However, it
    is possible to download and install `curl` from [https://curl.haxx.se/](https://curl.haxx.se/).
    Another option is to install `curl` using the Chocolatey package manager by executing
    `choco install curl` on your command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Futhermore, if we try to perform a `curl` command with an empty payload as
    follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have passed an empty body payload using the `-d` empty flag.
    Therefore, the out-of-the-box model validation returns the error message in the
    request's response, and it returns an HTTP `400 Bad request` message.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, this kind of validation is not enough. It is usually
    replaced by some custom validations, such as *data annotation* or *fluent validation.*
    We will look at these techniques in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a controller that is able to handle our requests, we should
    focus on the response part. Looking at the `OrderController` from the response
    point of view, we may notice that it is not compliant with REST specifications.
    None of the action methods considers any failure states. What should happen if
    our data source is down? What should happen if the requested order is not present
    in our repository?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by checking what happens when we ask for an order that doesn''t
    exist. To proceed with this check, all we need to do is make a `curl` request
    with a GUID that doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command-line instruction will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the response, ASP.NET Core automatically handles the empty
    result, and it returns the HTTP status `204 No Content`. It is important to note
    that all these behaviors came out of the box. Besides, it is also possible to
    override the default components and add our own custom validation implementation
    and response handling.
  prefs: []
  type: TYPE_NORMAL
- en: CreateAt response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Post` action method is responsible for creating resources. Another principal
    responsibility of the `Post` action method is to tell the client where the resource
    is created and how to access it. This responsibility is usually implemented within
    the action method. ASP.NET Core provides two methods that can give this information
    to the client, which are `CreatedAtAction` and `CreatedAtRoute`. The following
    example shows how to use the `CreatedAtAction` method in our `Post` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the response to the below `POST` request will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the response contains the `201 Created` header. It also provides
    the `Location` of the resource. This kind of information is useful for the client
    so that we can get more information about the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateAtAction` method accepts three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actionName` represents the name of the action that''s used for generating
    the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routeValues` is an object that contains all the parameters of the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is an object that represents the content of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative to `CreateAtAction` is `CreateAtRoute`, which takes the `routeName`
    and generates the same result as `CreateAtAction`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Put` action handles how resources are updated. We should bear in mind that
    the `PUT` verb is intended as a total replacement of the specific resource. Therefore,
    when we call an API using a `PUT` verb, all the resource fields will be replaced
    with the *body payload.* As we will see later in this chapter, for a more precise
    update for some of the specific fields of our entity, it is better to use the
    `PATCH` verb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another critical thing to keep in mind when we implement a `Put` action is
    that we need to handle Ids that don''t exist. APIs usually manage non-existent
    IDs in `Put` actions using two different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: When the client makes an update request on a non-existent ID, the API creates
    a new record with that resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the client makes an update request on a non-existent ID, the API informs
    the client that the resource doesn't exist with a `404 Not Found` error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm not a massive supporter of `CreateOrUpdate` methods. I prefer to keep the
    `Put` action compliant with the *single* *responsibility* *principle.* Therefore,
    separate the *create* and *update* operations into two different action methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can implement our `Put` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to check whether the order with the corresponding `id` exists.
    If it doesn't exist, the application returns a `404 Not Found` error. Otherwise,
    it performs the update operation and returns `200 Ok`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `NotFound` result also contains a message. In real-world applications,
    this message is usually associated with a piece of code, that is, a custom error,
    and it is serialized into JSON or XML format.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also significant to consider what should happen when the request contains
    `null` in `itemsIds`. It is essential to understand the difference between a `null`
    request object and an empty request object. In the first case, the client may
    accidentally call our APIs without passing any value. In the second case, the
    client explicitly requests our resource to be replaced with an empty value. Let''s
    modify our code to avoid `null` request values by adding the following guard as
    the first statement of our `Put` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `if` statement returns a `BadRequest` message if the `ItemsIds`
    field is `null`. Therefore, the client that sent the request will now the source
    of the issue. In the next section, we will discover another widespread update
    technique implemented in RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Partial updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Put` actions are used to replace a resource with another one. Therefore, the
    client must add the whole entity in the *body payload* of the request. If our
    entity is a complex object, keeping the entire entity in memory may cause performance
    issues. It is possible to avoid these problems by implementing a `Patch` action
    instead. The `Patch` action usually modifies an existing resource without replacing
    it, therefore you are able to specify only one the field you want to update. Let''s
    see how we can perform this kind of action in ASP.NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s add a new field to our `Order.cs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `Order` class contains an additional field that represents the currency
    of our orders. Let''s create a `Patch` action in our `OrderController`. The code
    we are going to implement uses two NuGet packages that provide the support for
    the PATCH method and all the types that help us to perform the operations related
    to that type of HTTP verb. We can add the package to our project by running the
    following instructions in the `SampleAPI` project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first NuGet package provides the `JsonPatchDocument` class type, the second
    package enables the `NewtonsoftJson` serializer needed by the PATCH operation
    support. In addition, we should also enable the NewtonsoftJson serializer into
    the application by adding the following extension method in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, it is possible to implement the `Patch` action method in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned code has three key points:'
  prefs: []
  type: TYPE_NORMAL
- en: The action method reacts to the `HttpPatch` verb requests. Just like the `Put`
    action, it accepts a `Guid` as the input parameter, which identifies the target
    resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action method also accepts a `JsonPatchDocument` as the payload of the body.
    The `JsonPatchDocument` class is a generic class that is part of the ASP.NET Core
    Framework. More specifically, our action uses the `JsonPatchDocument<Order>` type
    to implement operations on our `Order` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action method applies the `JsonPatchDocument` class using the `ApplyTo`
    method, which merges the changes in the request to our target resource. Finally,
    it updates the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `JsonPatchDocument` class accepts a specific request schema. For example,
    the following `curl` operation performs a partial update through the `PATCH` verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the body payload is a JSON array of objects: every object is
    composed of an `op` field, a `path`, and a `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `op` field describes the operation to perform on our target, `path` refers
    to the name of our field, and `value` is the replacement for our target. In this
    case, the request will replace the `itemsIds` field with the value `[1,2]`. Furthermore,
    the `op` field accepts a bunch of operations on data, including `add` and `remove`.
    As we saw previously, the syntax is almost the same as it was in the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`JsonPatchDocument` is compliant with the specification of the **Internet Engineering
    Task Force** (**IETF**), an organization that promotes internet standards. You
    can find out more information about the `Patch` document syntax in the declaration
    of the standard at the following link: [https://tools.ietf.org/html/rfc5789](https://tools.ietf.org/html/rfc5789).
    All the other specifications about the HTTP method that we''ve discussed in this
    chapter can also be found here.'
  prefs: []
  type: TYPE_NORMAL
- en: You should pay attention when using the `JsonPatchDocument` object. The client
    may request to update a read-only field or a non-existent field. Furthermore,
    the `JsonPatchDocument` type requires a **validation step**. This problem is usually
    solved by creating a custom **data transfer object** (**DTO**) model for this
    kind of request.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next subsection, which describes the deleting process for
    the resources and how to implement the resulting action method in the controller
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Delete` action method is marked with the `HttpDelete` attribute. It usually
    accepts the identifier of the resource to remove.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, `Delete` action methods do not perform physical
    delete operation on the database. They actually carry out update operations. Real-world
    applications and web services typically perform soft deletes instead of physical
    deletes because it is essential to keep track of historical data and information
    that's stored by our services. If we think about an e-commerce application, for
    example, it would be crucial to keep track of orders that have been dispatched
    by our system. *Soft deletes* are usually implemented using an `isDeleted` flag
    or an object that represents the status of our resource. All the other routes
    that are implemented in our APIs should implement logic to filter out all the
    resources in a deleted state. For example, a `Get` route should exclude all the
    deleted resources before presenting them to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are going to implement a real delete operation on our `IOrderRepository`.
    The `Delete` action methods usually return a `204 No Content` error to confirm
    the deletion or a `404 Not Found` error if the client passes a non-existent identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The implementation fetches the resource with the corresponding `id` from the
    `IOrderRepository` interface. It proceeds by checking whether the resource is
    `null`, and in this case, it will produce a not found error. If the order entity
    is present in the data source, it continues with the deletion process, and it
    returns a no content result. Now, let's proceed by having a look at the asynchronous
    process using a web service.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing and acceptance status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the operations on our resources are not applied immediately. Consider
    an order on an e-commerce website: it takes time to be dispatched and sent to
    our storage system. Therefore, data placed into a queue or something similar and
    handled as soon as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of asynchronous processing structures may also be present in a web
    service. We also need to represent them and communicate with the client when these
    kinds of processes start.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, these kinds of processes have the following workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fab174c8-cb4d-40a5-9b40-4a7d3680c1fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous schema shows how the client interacts with an asynchronous process:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a `POST` request to our services. The `POST` request triggers
    an asynchronous operation, which updates and adds the order to our storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The action method receives the request from the client and, if the request structure
    is as expected, triggers the asynchronous process and returns `202 Accepted` to
    the client. Otherwise, it returns `403 Bad Request`. The `202 Accept` code indicates
    that the asynchronous operation is running, but that it hasn't finished yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client doesn't know precisely when the asynchronous process will end, but
    it is up to it to recall our service once the information has been updated. The
    `202 Accepted` message it is usually combined with a JSON message that contains
    some information, such as the estimated time, or the code of the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that all the example URIs present in this book doesn't contain *verbs*.
    For example, the previous implementation describes a process for generating new
    order. As you can see, the URI is `<hostname>/api/orderrequest`*,* and the only
    element that contains a verb is the HTTP method, which is `POST`*.* We shouldn't
    use *verbs* in URIs because they are used to identify resources and must, therefore,
    be nouns.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our web service stack journey is to see how we can decouple
    the requests and the response object from the core entities that are used by our
    application. This approach becomes really useful when a web service's complexity
    increases.
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we looked at how to manage HTTP requests and responses
    using controllers. In this section, we will look at how to manage complex objects
    in our requests and responses. This section is more focused on the *M* part of
    the MVC pattern. First of all, let''s distinguish between three different types
    of model that are usually present in web services:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Domain model**describes the entities and the resources in our web services.
    It often reflects the schema of our data source, and it is very close to the lower
    level and the business logic of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Request model**is the representation of the model of the request. Each
    action method in our controller usually has its own **Request model**. As we will
    see later in this chapter, this is also the model that's associated with the validation
    of the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The**Response model**is the view model, or the presentation model, of the web
    service. It represents the response of the request, and there is usually one **Response
    model** per action method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following workflow schema shows how the models in our application are laid
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ab39100-1893-475e-bb5e-170a75b4296d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the **Request model** is the front part of our service; it represents
    the request. The **Domain model** is used to describe our stored data. Finally,
    the *response model* presents the data to the client. The request and response
    model are also defined as **data transfer objects** (**DTOs**)*.* These are not
    model classes at all; they transport information between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing request models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at the implementation of some DTOs in practice. The `Order`
    entity describes some actions that accept `List<string>` as input. Let''s suppose
    that the implementation is getting more complex and our service needs to store
    additional information about our orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The *domain model* is a critical part of our application. It is essential to
    keep it separated from the *request/response model*. Therefore, we should avoid
    having the *domain model* tightly coupled with the *request* and the *response*
    models. Let''s start by implementing the `OrderRequest` class, which will be a
    representation of the *create request model*. It will be used by the `Post` action
    method to create a new entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OrderRequest` class contains the same fields as the `Order` *domain model*,
    apart from the `Id` field. This is because the client of the API should not insert
    the `Id` information. The request model makes our filesystem in a separate folder.
    In this case, as you can see from the namespace, `OrderRequest` is stored in the
    `Requests` folder. Our `OrderController` can use `OrderRequest` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Post` action method accepts a parameter of the `OrderRequest` type, which
    is the representation of the order request that we want to create. To link incoming
    data with the domain model, we should create a `Map` method that initializes a
    new domain model that''s populated with the request model. Furthermore, we should
    also create a new instance of the `Order` object with the requested data and combine
    it with `IOrderRepository`. The same concept can be applied to the `Put` action
    method of our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we create a new `Map` method, which takes two parameters as input:
    the `OrderRequest` and the `Order`, and we can proceed by assigning each property
    of the request object to the order.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing response models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, another critical part of our APIs is the response
    model. The response model classes act as filters between the *domain model* and
    the *client.* For example, let's think about a particular field in our domain
    model that, for whatever reason, must not be part of our response. Response models
    help us deal with cases such as these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we need to implement a *soft-delete* in our APIs. As we
    mentioned earlier, a *soft-delete* is a way to mark a record for the deletion
    or to temporarily prevent it from being selected. To perform a soft-delete on
    `MemoryOrderRepository`, we should add an `IsInactive` flag, which marks the target
    record as deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `IsInactive` flag indicates whether `Order` is inactive or not. To complete
    the *soft-delete* implementation, we should change the `MemoryOrderRepository`.
    It should now cancel orders using the `IsInactive` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `Get` method inside the repository should filter all the records
    by excluding inactive orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'These changes eliminate inactive orders from the responses of our APIs. Since
    the `IsInactive` flag is implicit in the response of our APIs, we don''t need
    to serialize the `IsInactive` flag in the response JSON. Consequently, we can
    decouple the response of the `Get` action method from our domain model by adding
    a new response class called `OrderResponse`. It can be defined in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `OrderResponse` class model exposes all the fields except
    for the `IsInactive` flag. At this point, we can proceed by editing the `OrderController`
    class so that it maps the `Order` entity with the `OrderResponse` model in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows us to decouple the domain model from the response of our
    API. The `Map` method is the point at which we can decide which fields we should
    show.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing validation of requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now create dedicated types to represent our requests, but we should
    also consider adding validation. Validation is important if we wish to prevent
    messy data and possible exceptions in our web service. ASP.NET Core provides an
    out of the box way for us to implement validation in our controllers and services:
    `System.ComponentModel.DataAnnotations`. The namespace provides a set of attributes
    that can be used to describe the validation of model fields. For example, consider
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `[Required]` attribute specifies that both the `ItemsIds`
    and `Currency` attributes should not be `null` or empty; otherwise, the APIs will
    return the following validation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply reading through the model allows us to understand the constraints that
    were defined for the model, so this approach improves the readability and maintainability
    of our code. Furthermore, ASP.NET Core provides several popular built-in validation
    attributes: `[EmailAddress]`, `[StringLength]`, `[Url]`, `[CreditCard]`, and `[RegularExpression]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Currency` field, we may add a constraint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Currency` attribute will contain a currency code, such as
    EUR or USD. We can add a restriction on the maximum length of the field so that
    it is limited to three characters.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a way for us to create custom validations for our requests
    by extending `ValidationAttribute`, which means we can create custom validators
    for our types. Let''s create a more appropriate validation for our `Currency`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation matches the request model currency with the list
    of `_acceptedCurrencyCodes`. If the match is successful, it returns `ValidationResult.Success`;
    otherwise, it returns a new validation result with a validation message. The `MemberName`
    attribute provides the name of the property that is associated with the custom
    validation attribute. Creating a custom validation attribute can be useful when
    we implement a more complex validation that involves third-party services or aggregate
    operations on the subject of the validation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can build a web service stack using ASP.NET
    Core. We also looked at how to implement CRUD operations on a repository and how
    to deal with data transfer objects and validation. This chapter has provided a
    starting point and the knowledge we need to build a very simple web service using
    ASP.NET Core, including how to handle requests, how to use model binding, and
    how to validate requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the routing system of ASP.NET Core in more
    detail by exploring how it can be extended and customized.
  prefs: []
  type: TYPE_NORMAL
