- en: Native Libraries in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about ncurses native libraries and how
    to extend console capabilities in .NET Core on Linux. We will also learn how to
    Interop with existing native code. This chapter will introduce the ncurses native
    library and Interop with existing native and Mono libraries. We will build a sample
    native library in C++ and we will also learn how to create an application that
    implements the new library and ncurses. The purpose of this chapter is to get
    an understanding of Interop with existing libraries, and the ability to extend
    console capabilities through implementing ncurses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ncurses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interop with existing native and Mono libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a sample native library (C++)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample application to implement the new library and ncurses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to ncurses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**New curses** (**ncurses**) is an openly distributable library of functions
    that deals with an application''s **user interface** (**UI**) in text mode. It
    creates a wrapper over terminal abilities. ncurses is a free software, it is not
    an open source. It provides functions to make imaginary screen windows for logical
    calculations, print windows, and so on. Libraries for panels, menus, and forms
    use the ncurses library and extend the basic functionality of ncurses as required.
    We can make applications that contain numerous windows, menus, panels, and forms;
    windows can be overseen autonomously, can give scrollability, and can even be
    covered up.'
  prefs: []
  type: TYPE_NORMAL
- en: Menus give the client a simple order determination choice, forms permit the
    formation of easy−to−use information sections and show windows, and panels stretch
    out the abilities of ncurses to manage covering and stacked windows. These are
    a portion of the essential things we can do with ncurses. As we progress, we will
    see how to build a native library using C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'ncurses comes with the Visual Studio Code installation and we can download `ncurses-6.0.tar.gz`,
    from [http://ftp.gnu.org/pub/gnu/ncurses/](http://ftp.gnu.org/pub/gnu/ncurses/).
    After downloading, unzip and install ncurses 6.0 (the latest version at the time
    of writing this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3c379ea-c508-4e74-8fca-3099a47b75fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Terminal from the folder, `ncurses-6.0`, and run the following commands
    to install ncurses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./configure`: Configure the build according to your environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make`: Make it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`su root`: Become root'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make install`: Install it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a simple application, `"Welcome to .NET Core 2.0"`, to understand
    how to start, use, alter, and close ncurses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a function called `WelcomeMessage()` which returns void, and call it
    from `main,` as shown in the example. Let''s try to understand each function that
    we called inside the `WelcomeMessage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Initscr()`: This function initiates the Terminal in curses mode. It is typically
    the main curses method to call while introducing a program. A couple of uncommon
    methods, once in a while, should be called before it; these are `slk_init()`,
    `channel()`, `ripoffline()`, and `use_env()`. For different Terminal applications,
    `newterm()` might be called before `initscr()`. The `initscr()` code decides the
    Terminal sort and instates all curses data structures. `initscr()` likewise makes
    the main call, `refresh(),` to clear the screen. On the off chance that errors
    arise, `initscr()` composes an error message to standard error and exits; otherwise,
    a pointer comes back to stdscr. A program that yields to more than one Terminal
    should utilize the `newterm()` routine for every Terminal, rather than `initscr()`.
    The method `newterm()` ought to be called once for every Terminal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printw("Welcome to .NET Core 2.0")`: This prints `" Welcome to .NET Core 2.0"`
    on the screen. `printw()` is a class of functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`printw()`**: This function works similar to `printf()` with the exception
    that it prints the information on a window called stdscr and with the added capability
    of printing at any position on the screen at the current (*y, x*) coordinates.
    If the cursor is at coordinates (0,0), the string is printed at the left corner
    of the window.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mvprintw()`: This function can be used to move the cursor to a position and
    then print. If you want to move the cursor first and then print using the `printw()`
    function, use `move()` first and then use `printw()`. I think instead of using
    `move()` and `printw()`, using `mvprintw()` is better, because you get the flexibility
    to manipulate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`wprintw()`** and **`mvwprintw()`**:These two functions are similar to the
    preceding two functions, except that they print in the corresponding window given
    as an argument.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vwprintw()`: This function is similar to `vprintf()`. This can be used when
    a variable number of arguments are to be printed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The earlier program demonstrates how easy it is to use `printw`. You just feed
    the message to be shown on the screen, then it does what you want. When we call `printw`,
    the information is really composed for an imaginary window, which isn't refreshed
    on the screen yet. The activity of `printw` is to refresh a couple of banners
    and information structures and compose the information to a support as compare
    to `stdscr()`. With a specific end goal of demonstrating it on the screen, we
    have to call `refresh()`, and advise the curses framework to dump the substance
    on the screen. The logic behind this is to enable the software engineer to do
    different updates on the imaginary screen or windows, and do a revive once all
    his/her screen refresh is finished.
  prefs: []
  type: TYPE_NORMAL
- en: All these functions take the *y* coordinate first and after that, *x* in their
    arguments. A typical slip up by beginners is to pass *x*,*y* in a specific order.
    In the event that you are doing an excess amount of manipulations of (*y*, *x*)
    coordinates, consider isolating the screen into windows and control every one
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: '`Move(row,col)`: The function `move()` moves the cursor to the desired position
    by passing row and column values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`Addch(ch | A_attribute)`:** This function is utilized to print a character
    at the current cursor position on the stdscr window. We can pass attributes to
    print characters based on the attribute, for instance, `addch(ch |A_Bold |A_underline)` will
    print characters in bold and underlined. The following specified attributes characterized
    in `<ncurses.h>` can be passed to functions `attron()`, `attroff()`, and the `attrset()`
    , `attron()` functions turn on the attribute, and correspondingly `attoff()` turns
    off the attribute. To set the quality for a window, we should utilize `attrset(),`
    for instance, in the event that we compose `attrset(A_NORMAL)`, it sets a typical
    show with no feature for a window, and it turns off all attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use multiple attributes at the same time using `OR` `(|)` with the characters
    passed to `addch()`. They are as shown in the following table:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| **Sr. No.** | **Attribute name** | **Attribute use** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | `A_NORMAL` | Normal display (no highlight) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | `A_UNDERLINE` | Underlining |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 | `A_BOLD` | Extra bright or bold |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 | `A_PROTECT` | Protected mode |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 | `A_INVIS` | Invisible or blank mode |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 | `A_ALTCHARSET` | Alternate character set |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 | `A_CHARTEXT` | Bit-mask to extract a character |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8 | `A_DIM` | Half bright |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 | `A_BLINK` | Blinking |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 | `A_REVERSE` | Reverse video |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 | `A_STANDOUT` | Best highlighting mode of the Terminal |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 | `COLOR_PAIR(n)` | Color-pair number *n* |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'If we want to print a character in a specific location or cursor position,
    we can use the following functions, instead of using the `move()` and `addch()` functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mvaddch()`: This function is used to print characters at the desired location
    by passing the cursor location, for example, `` `mvaddch(row,col,ch)` ``'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waddch()`: This function is useful for printing characters at the present
    cursor location in a specified window'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mvwaddch()`: This function is used to print characters at a definite cursor
    location in a specific window by passing row, column, character, and window'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh()`: This function checks the window and updates only the bit which
    has been changed. This improves execution and offers more significant flexibility.
    A beginners'' common error is to not call `refresh()` after they did some refreshing
    through the `printw()` class of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`getch()`:** This function sits tight for the client to press a key, unless
    you stipulated a timeout, and when the client presses a key, the matching integer
    number gets returned. At that point, we can check that the value came back with
    the constants characterized in `curses.h`, to compare against the keys you need.
    On the off chance that it is a normal character, the integer number value will
    be equal to the character, otherwise it restores a number which can be coordinated
    with the constants characterized in `curses.h`. For instance, if the client presses
    *F1*, the number returned is `265`. This can be checked utilizing the full scale
    `KEY_F()`, characterized in `curses.h`. This makes reading keys convenient and
    simple to oversee.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endwin()`: This function ends the curses mode, else our Terminal may behave unusually
    after the program stops. `endwin()` frees up the memory taken by the curses subsystem
    and its data structures, and puts the Terminal in normal mode. This function must
    be called when we are finished with the curses mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A program should reliably call `endwin()` before quickly leaving or closing
    curses mode. This function restores `tty` modes, moves the cursor to the lower
    left-hand corner of the screen, and resets the Terminal into the best non-visual
    mode. Calling `revive()` or `doupdate()` after a short escape, makes the program
    go to visual mode. The `isendwin()` routine returns `TRUE` if `endwin()` has been
    called with no subsequent calls to `wrefresh()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run this program in Ubuntu, ncurses should be installed on the system, otherwise
    during compilation, we will get an error stating `ncurses.h:no such file or directory` and
    compilation will terminate. Use the following command to install ncurses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the latest version of the ncurses library onto
    the system. Once installation is done, open Visual Studio Code, go to File, and click
    on New File—it opens up a new untitled page. Write code as in the earlier example
    and save it at your desired location. Rename the file and give it an extension
    of `.c` or whatever suits your requirements. In this example, we created a file
    called `IntoToNcurses.c`. Run the following command to execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a program, we use the following command syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b037ef46-6dba-4c53-bd93-403e5e7f6ec8.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we are passing our C program with the extension `.c`.
    After the `-o` command, we pass the output, or rather the compiled filename. Here,
    we can give it any name we want, as we did with `ExampleOfNcurses` in this example.
    To include the ncurses library, we have to link it during compilation using `-lncurses,`
    otherwise the compilation will fail with the error `undefined reference to functions`,
    as those functions are ncurses functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once compilation is successful, it creates an output file, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/257ab9c4-5ba4-4ebc-bb17-0e90e7e41d14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can run our program after the compilation is successful and the output file
    is created in the same folder. On the Terminal, pass the output filename as `./hello`
    to execute the program, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2b053c-8ba4-45c0-8dd6-54a28ec32d60.png)'
  prefs: []
  type: TYPE_IMG
- en: Interop with existing native and Mono libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code reusability is one of the key principles in programming. For example, in
    an application we may use a certain functionality multiple times, so we keep it
    in a useful place and refer it from that place, whenever we need it in our application.
    Now, suppose our application implemented some common functionality which we can
    use in other applications, in this case, instead of writing the same logic again,
    we can create a library. It is easily distributable and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Asp.NET Core supports cross-platform programming, so any Linux user who has
    built many reusable libraries, API-like console support, and filesystem access,
    and wants to use them while writing code in ASP.NET Core, can access them. In
    this section, we will see how to access these native libraries (`.dll`) and Mono
    libraries (`.so`) in the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Language Infrastructure** (**CLI**) helps to interoperate with existing
    code. We need to handle three basic problems to get things to work. First, where
    and how to specify the library, second, determining which function we want to
    invoke, and third, passing parameters. **Common Language Runtime** (**CLR**) provides
    Platform Invocation services—we call it P/Invoke. It enables managed code to call
    C, C++ functions in native libraries (DLLs). Let''s discuss what Platform Invoke
    is and how to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Platform Invoke (P/Invoke)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: P/Invoke allows us to access structures and functions of unmanaged libraries
    from our managed code ASP.NET Core 2.0\. To use P/Invoke API, we use the `System.Runtime.InteropServices`
    namespace. This namespace allows us to access attributes the way we want, to use
    them with native components. The `DllImport` attribute is used for the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dig more into the details, online resources are available at: [http://www.pinvoke.net](http://www.pinvoke.net/) .
    It has all the functions which are widely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: `AllowSetForegroundWindow (user32)`—this enables the mentioned
    process to set the foreground window by utilizing the `SetForegroundWindow` method;
    the only condition is that the calling process should be able to set the foreground
    window. In C# code, we will write it as: `[DllImport("user32.dll")]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`static extern bool AllowSetForegroundWindow(int dwProcessId);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates where Interop stands between native and
    managed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f12b02b9-a90e-4bb3-b0ec-de0e6266c45e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, if we want to use the `AnyPopup()` method of `user32.dll`, we
    use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we used the `DllImport` attribute which calls the **dynamic-link
    library** (**DLL**), and we can use all these methods inside this DLL which is
    decorated with the `_declspec(dllexport)` keyword or `extern "c"`. We will discuss
    more about the import and export of methods from the library in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: DLLImport attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The attribute, `[DllImport()]`, falls under the `DllImportAttribute` class.
    It provides the information required to call a function exported from an unmanaged
    DLL. The minimum prerequisite is that we should pass the name of the DLL which
    contains the entry point. We can apply this attribute straightforwardly to C#
    and C++ function definitions. Let''s check what the `DllImport` attribute has
    inside it. In the code window, click on `DllImport` and press the *F12* key (referred
    to as the go-to definition). This key is bound to the de-compile command in Visual
    Studio and will de-compile the selected type, if it can. Upon de-compilation,
    Visual Studio will display the de-compiled code in a new window. In the de-compiled
    code of `DllImport`, we can see each and every parameter. The code is very well
    commented and self-explanatory, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can characterize the following attributes with the DLL name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ThrowOnUnmappableChar`: This field is `False` by default, which means the `ThrowOnUnmappableChar` field
    is disabled. Best-fit mapping empowers the Interop marshaler to give a nearby
    coordinating character when no correct match exists, every time the Interop marshaler
    changes over an unmappable character. For example, the marshaler changes over
    the Unicode character into `c` for unmanaged techniques that acknowledge ANSI
    characters. A few characters do not have a best-fit portrayal; these are called
    unmappable characters. These unmappable characters are typically changed over
    to the default `?` ANSI character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetLastError`: By default, `SetLastError` is set to false, but in Visual Basic
    it is set to true by default. `GetLastError` is called by runtime marshaler and
    it caches the return value so it is not overwritten by other API calls. You can
    recover the error code by calling `GetLastWin32Error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExactSpelling`: The `ExactSpelling` field, as the name suggests, impacts the
    behavior of the `CharSet` field to figure out the exact entry point name to invoke.
    If the `ExactSpelling` field is set to `False`, Platform Invoke looks for the
    unmangled alias first; if the unmangled alias is not found, then it will look
    for the mangled name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BestFitMapping`: By default, the `BestFitMapping` field is true. On the off
    chance that this field is true, it overrides any level settings for `System.Runtime.InteropServices.BestFitMappingAttribute`.
    Best-fit mapping empowers the Interop marshaler to give a nearby matching character
    when no correct match exists. For instance, the marshaler changes over the Unicode
    copyright character to `c` for unmanaged functions that acknowledge ANSI characters.
    A few characters do not have a best-fit representation, and these characters are
    called unmappable. Unmappable characters are generally changed over to the default
    `?` ANSI character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CallingConvention`: Specifies the calling convention required to call methods
    implemented in unmanaged code. It is defined as an enumeration. The values of
    this enumeration are used to specify the calling conventions. This determines
    how a function is called, for example, the argument passing order behaviour is
    set to right to left, or stack maintenance responsibility such as the Calling
    function pops the arguments from the stack, and so on. There are fundamentally
    five calling convention fields: `Cdecl`, `StdCall`, `FastCall`, `ThisCall`, and
    `Winapi`. The default is `StdCall` for unmanaged functions with P/Invoke. More
    about this can be read at: [https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.callingconvention(v=vs.110).aspx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StdCall`: The callee cleans the stack. To call unmanaged functions with Platform
    Invoke, this is the default convention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cdecl`: This empowers calling functions with variable `args`, which means
    it is good to use for functions that use a variable number of parameters, for
    example, on the Windows platform, the `System.Runtime.InteropServices.CallingConvention.Cdecl`
    convention will act as: Argument-passing order | right to left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Winapi`: This part isn''t really a calling convention, rather it utilizes
    the default platform calling convention. For instance, in Windows, the default
    is `StdCall`, and on Windows CE .NET, it is `Cdecl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThisCall`:The primary parameter is the pointer and is put away in register
    ECX. Other parameters are pushed on the stack. This calling convention is utilized
    to call functions on classes exported from an unmanaged DLL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharSet`: It determines the marshaling conduct of string parameters and is
    useful for indicating which entry point name to invoke (the correct name given
    or a name finishing with `net` or `As`). The default list part for C# is `CharSet.Ansi`
    and the default count part for C++ is `CharSet`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entrypoint`: You can determine the entry point name by providing a string
    showing the name of the DLL containing the entry point, or you can recognize the
    entry point by its ordinal. Ordinals are prefixed with the `#` sign. We can utilize
    the `DllImportAttribute.EntryPoint` field to indicate a DLL function by name or
    ordinal. On the off chance that the name of the function in your function definition
    is the same as the entry point in the DLL, you don''t need to expressly recognize
    the function with the `EntryPoint` field. Utilize syntax to demonstrate a name
    or ordinal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you should prefix an ordinal with the pound sign (`#`). To know
    the entry point of DLL, we can use `DUMPBIN.exe` also. Just open the Developer
    Command Prompt and go to the DLL location and type the command, `DUMPBIN /EXPORTS
    ExampleDLL.dll`. Running this command returns information about the entry point
    and functions of DLL, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad8257f3-195f-4b89-9120-cab4079bb6c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It gives all the information about DLL such as:'
  prefs: []
  type: TYPE_NORMAL
- en: It has one ordinal base
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: It has three functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of functions and their ordinal value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many commands which we can use to get information about DLL. To find
    out all the commands, enter the following command, `Dumpbin.exe`. It gives us
    a list of commands that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Certain Unicode characters are changed over to risky characters, for example,
    the oblique punctuation line `\` character, which can unintentionally change a
    way. By setting the `ThrowOnUnmappableChar` field to genuine, you can flag the
    nearness of an unmappable character to the guest by tossing a special case.
  prefs: []
  type: TYPE_NORMAL
- en: You can't change the default values given by the `BestFitMapping` and `ThrowOnUnmappableChar`
    fields when passing a managed array whose components are ANSI characters or LPSTRs
    to an unmanaged safe exhibit. Best-fit mapping is constantly empowered and no
    special case is tossed. Know that this blend can trade-off your security information.
  prefs: []
  type: TYPE_NORMAL
- en: Interop with existing native libraries with example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create DLL and create a header file (`.h`) inside it using C++, and we
    will see how we can consume it in our .NET Core application. In the following
    example, we created a DLL project for example, calling it `ExampleDLL`. Create
    a source `.cpp` file and a header file. Open the header file and write the following
    code, which returns the sum of two values. To consume public data and functions
    in class, we have to add the keyword `_declspec(dllexport)` before the public
    member which we want to consume from outside. While creating a DLL, we usually
    add the header file which contains the function or class prototype and we can
    export this using the `__declspec(dllexport)` keyword, while doing a declaration
    in the header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The named header file is `Calculate`, and the method name is `Sum` which takes
    two variables, integer `a` and integer `b`. Build this solution and open the project
    location. We can find DLL inside the debug folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the preceding code in the `Calculate.h` file, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dce40fb-ed0c-4507-9eab-4db64ceb5352.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This DLL is created inside the debug folder of the `ExampleDLL` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/389d5c6e-5080-4021-9a4e-cc334ac57841.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have our C++ DLL ready to be consumed from C# code. For example, I am
    creating a C# console application and we just need three lines of code to consume
    C++ DLL:'
  prefs: []
  type: TYPE_NORMAL
- en: Add namespace using `System.Runtime.InteropServices;`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add attribute using `[DllImport(@"<DLL Location>")]`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `static extern` functions with a compatible signature in your C# code, `public
    static extern int Sum(int a, int b);`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The C# script for the same is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/916def90-ccea-4a10-a8f0-c75c82d9b46f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding section, we saw how to consume native libraries in a DLL. In
    this section, let's take the example of a Mono library. We will create a `.so`
    file in Ubuntu and will consume it from .NET Core. We will see the backward compatibility
    of .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Mono is an open source development platform in light of the .NET Framework;
    it enables engineers to fabricate cross-platform applications with enhanced designer
    efficiency. Mono's .NET execution depends on the **Ecma** (**Ecma International—European
    association for standardizing information and communication systems**) norms for C# and
    the Common Language Infrastructure. Mono incorporates both engineer devices and
    the foundation expected to run .NET customer and server applications. Mono works
    cross platform, and runs on Linux, Microsoft Windows, and many others. All Mono
    dialects take advantage from many highlights of the runtime, similar to programmed
    memory administration, reflection, generics, and threading. Its highlights enable
    us to focus on composing your application, as opposed to composing framework foundation
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are creating a simple library which displays an integer
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command in the Terminal to create the `.so` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `-shared -o` creates an (`.o`) object file and from
    the object file creates a `.so` file. `-fPIC` is used to declare a flag for the
    position independent code.`-fPIC` generates position-independent code which can
    be loaded from any memory location at runtime, so we can access static or global
    variables and methods at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21d4bd6a-44e1-4271-9abe-e8fa39fb7967.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we will see how to consume this `.so` file in C# code. We created a C# file
    and added the namespace, `system.Runtime.InteropServices`, and gave the path of
    the `.so` file inside the `DLLImport` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we are done with the code and `DLLImport`, let''s discuss Mono, which
    we will use to create our executable and run this application. Mono is an open
    source tool which is created by the Microsoft subsidiary, Xamarin. It is a tool
    which makes the Linux developer''s life easy if they want to run Microsoft .NET
    applications on Linux or on any other cross platform. The latest version at the
    time of writing this book is Mono 5.4.0, which was released in October 2017\.
    This version supports the Core API of .NET Framework and also C# 7.0\. Mono provides
    several command line utilities, a few of the main useful commands are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mono**: It is a **just-in-time** (**JIT**) compiler and it supports both
    32-bit and 64-bit types of systems. It also supports multiple platforms such as
    Microsoft Windows, Sun Solaris, Android, Apple iOS, macOS, Linux, Sony PlayStation,
    and so on. Mono runtime offers Code Execution, Garbage Collection, Code Generation,
    Exception Handling, OS interface, Thread management, Console access, and Security
    System, Program isolation using AppDomain. It allows a project to be extended
    in C# by reusing all existing C, C++ code libraries. As we said earlier, it is
    a JIT compiler. Since we have `ngen.exe` in Microsoft.NET to generate a pre-compiled
    code, which reduces the start up time, we use the following command with Mono
    to compile assemblies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `-O=all` instructs to enable all optimizations, then
    the Mono command tells Mono to compile the code to native code, `--aot` for a
    precompiled image
  prefs: []
  type: TYPE_NORMAL
- en: '**MCS:** It''s a C# compiler. Though many versions of compiler are available
    which are specific to the version, for example, `gmcs` compiler targets 2.0 mscorelib,
    `smcs` targets 2.1 mscorelib and moonlight applications (Silverlight implementation
    for mainly Linux), while `dmcs` targets 4.0 mscorlib. Now, the new compiler version
    MCS is present which takes the latest version by default. We can also specify
    which version we want to use. MCS runs with Mono runtime on a Linux machine, and
    with both .NET and Mono runtime on a Windows machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Assembly Cache tool (Gacutil)**:This tool is used for maintaining
    versions of assemblies in a system''s global assembly cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XSP**:The web service and web application server of Mono.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mono-config**: The format configuration of Mono runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install Mono using the following command. When we use `mcs`, it will install
    the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile this C# program in Visual Studio Code using the following command;
    it creates an `.exe` file at the same location from where we opened the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to run and check if it is displaying the value `15`, which
    we have passed in our `.so` file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8483ac96-68eb-4044-bbf8-f0dbb761914d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To run `helloNative.exe`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When not to use P/Invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Utilizing P/Invoke isn''t fitting for all C-style methods in DLLs. Let''s take
    an example where we create a string in a C++ program and display it in a C# application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using P/Invoke, pass the library in the `DllImport` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The trouble here is that we can't erase the memory for the unmanaged string
    returned by `msg`. Different methods called through P/Invoke restore a pointer
    and do not need to be deallocated by the client. For this situation, utilizing
    the marsheling is a more suitable approach.
  prefs: []
  type: TYPE_NORMAL
- en: Building a sample native library (C++)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we learned about cross-platform implementation, and
    how to Interop with existing native and Mono libraries. To demonstrate interoperability,
    we created small sample applications. Let''s start with building our first native
    library in C++. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio and select Windows Desktop under Visual C++ and select the
    project type Dynamic-Link Library (DLL). In this example, we name the project
    `ExampleDLL` and provide the location where we want to create the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7233f757-5e61-4390-93cf-684fba40b11f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the header files folder and create a new header file. In this
    example, we named it `Calculate.h`. The `Calculate` header file contains mathematical
    operations such as the summation of two integer numbers, multiplication, and division:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined a header called `Calculate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`extern "C"` is used to instruct that the compiler will use the C function
    naming convention, not C++. Most code uses this directive because C function names
    are clearer to understand than C++. `__declspec(dllexport)` is utilized for export.
    In Microsoft''s new versions of compiler, we can export data, functions, classes,
    or class member functions from a DLL utilizing this keyword, `__declspec(dllexport),`
    the export directive to the object file, so we don''t have to utilize a `.def`
    record. This accommodation is most obvious when endeavoring to export decorated
    C++ function names. Since there is no standard specification for name decoration,
    the name of an exported function may change between compiler versions. To export
    functions, the `__declspec(dllexport)` keyword must appear to the left side of
    the calling-convention keyword, if a keyword is indicated, for instance: `` `__declspec(dllexport)int
    Sum(int a, int b).` ``'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To export all public data members and functions in a class, the keyword must
    appear to the left side of the class name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Class __declspec(dllexport)int Calculations : public CPPObj { Class definition};`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When building your DLL, we normally make a header file that contains the function
    models, as well as classes we are trading, and include `__declspec(dllexport)`
    to the announcements in the header file. To make our code more intelligible, we
    can define a macro for `__declspec(dllexport)` and use the macro with each symbol
    we are sending out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`# define DLLExplort __declspec(dllexport)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f169b8a-4b47-4e95-a204-d5c040fea205.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we created a sample native library, and now we will
    see how we can access it. In the preceding code, we used `__declspec(dllexport)`;
    to acccess this DLL, we will use `DllImport`. Click on Add | New Project; under
    C#, select .NET Core Console Application. In this example, we called it `InteropWithCS`.
    Open the solution and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using `ExampleDLL` and doing our calculations, taking
    input for `number1` and `number2` values. The user can select an operation—sum,
    multiply, or divide by pressing the corresponding number. On option number input,
    we check the user option, use switch case, and display the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06576ed6-91ce-4006-9ac1-05013bf779ae.png)'
  prefs: []
  type: TYPE_IMG
- en: This simple application gives us an understanding of how to create our own native
    library in C or C++, and how to set functions which can be exported and accessed
    from other languages, such as C#. The intention of making it simple and using
    small functions, such as sum, and multiplication, for example, is to make you
    aware of the functionality, so that the user won't get distracted with the heavy
    logic of functions.
  prefs: []
  type: TYPE_NORMAL
- en: A sample application to implement new library and ncurses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the fundamentals, let's start building a sample application
    which implements ncurses. We will create a C# application which imports a C library
    or we can say `.so` file. This library has implemented ncurses functions. P/Invoke
    allows us to use those ncurses functions in our C# application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a C program which implements ncurses functions using
    an ncurses header. Let''s create an application which takes an input character;
    this character will be printed in a window, based on the number of rows and columns
    the user enters from the application where we will import this library. The function
    `drawCharOnWindow()` prints the character, based on the number of rows and columns
    present in the window; it takes character, row, and column as input parameters.
    We get the size of the window using the ncurses function, `getmaxyx(),` and if
    the user enters `q`, it quits the printing of the character. Open Visual Studio
    Code and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a library using the following command. It will create a `.so` file at
    the location from where the Terminal is open, and we run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use this library from the C# program using Mono. The following
    example application takes input from the user for the character we will print
    and its location, row, and column value. To use the library which implemented
    ncurses and to use it in C# , we need to use the namespace, `System.Runtime.InteropServices`
    and import DLL, using the `DllImport` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `.exe` file, use the following Mono command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the program in Mono, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We learned how to create an executable using Mono and run it; now, we will
    see how to create a .NET Core 2.0 console application. Open Visual Studio Code
    and set the location on the Terminal where we want to create the application,
    and run the following command for the console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After the creation of the application, use the preceding code. Run this code
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take the input parameter, the character to print, row, and column location,
    and it will print that character in the window at the specified location, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54a52beb-b049-4595-886e-52542d4f95fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After passing this detail, it prints the character at the specified row and
    column on the screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7ef9286-dc44-4944-9dec-ddf1b0c9bb73.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the ncurses library and how to use this library
    in C or C++ programs. Also, we learned about how to reuse libraries created in
    Ubuntu or on a Linux machine which implemented ncurses in a .NET Core 2.0 application,
    using P/Invoke. We have seen how Mono works efficiently with a Linux machine and
    makes programming easy in .NET Core 2.0, using C# for Linux user. The next chapter
    will be very interesting, and it will be where we will build our first game, Tic-Tac-Toe,
    using .NET Core and we will learn about its compilation, building, and testing.
  prefs: []
  type: TYPE_NORMAL
