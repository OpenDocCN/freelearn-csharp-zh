- en: '*Chapter 1*: Introducing C# 10.0 and .NET 6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：介绍C# 10.0和.NET 6'
- en: Microsoft .NET 6 and C# 10.0 are the latest incarnations of the .NET platform
    and C# programming language. They bring many performance enhancements to the C#
    and .NET programmer community. We will start this book with an overview of the
    new versions of C# and .NET.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft .NET 6和C# 10.0是.NET平台和C#编程语言的最新版本。它们为C#和.NET程序员社区带来了许多性能提升。我们将从对C#和.NET新版本的概述开始这本书。
- en: In this chapter, you will start by downloading, restoring, building, and testing
    the latest version of the .NET compiler called **Roslyn**. Then, you will review
    what's new in .NET 6, including the areas where performance has been greatly enhanced.
    Then, you will review what's new in C# 10.0 by looking at some code examples that
    demonstrate these features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先下载、还原、构建和测试.NET编译器**Roslyn**的最新版本。然后，你将回顾.NET 6的新特性，包括性能得到极大提升的领域。然后，你将通过查看一些演示这些功能的代码示例来回顾C#
    10.0的新特性。
- en: In the *Native compilation* section, you will build a project and run it as
    an MSIL project with multiple binaries, then compile and run it as a single native
    binary. Finally, you will learn how to improve the performance of Windows Store
    applications and ASP.NET websites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在*原生编译*部分，你将构建一个项目，并以多个二进制文件的形式作为MSIL项目运行它，然后将其编译并作为单个本地二进制文件运行。最后，你将学习如何提高Windows
    Store应用程序和ASP.NET网站的性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Overview of .NET 6**: In this section, we will cover, at a high level, what''s
    new in .NET 6\. You will learn about the various performance improvements that
    will be part of .NET 6.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 6概述**：在本节中，我们将从高层次上介绍.NET 6的新特性。你将了解将成为.NET 6一部分的各种性能提升。'
- en: '**Overview of C# 10.0**: Having learned how to obtain the latest Roslyn code
    in the *Technical requirements* section, in this section, you will learn about
    the various features that will be part of C# 10.0\. This will include code examples.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 10.0概述**：在*技术要求*部分学习了如何获取最新的Roslyn代码后，在本节中，你将了解将成为C# 10.0一部分的各种功能。这包括代码示例。'
- en: '**Native compilation**: In this section, you will learn how to compile a .NET
    Core application into a single native executable. You will write a simple console
    application that recursively converts audio files from one format into another.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生编译**：在本节中，你将学习如何将.NET Core应用程序编译成一个单一的本地可执行文件。你将编写一个简单的控制台应用程序，递归地将音频文件从一种格式转换为另一种格式。'
- en: '**Improving Windows Store performance**: This is a brief section that provides
    standard guidelines for improving the performance of applications that target
    the Windows Store.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高Windows Store性能**：这是一个简短的章节，提供了一些提高针对Windows Store的应用程序性能的标准指南。'
- en: '**Improving ASP.NET performance**: This is a brief section that provides some
    standard guidelines for improving ASP.NET applications.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高ASP.NET性能**：这是一个简短的章节，提供了一些提高ASP.NET应用程序的标准指南。'
- en: 'By the end of this chapter, you will have the following skills:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备以下技能：
- en: You will understand what's new in Microsoft .NET 6.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解Microsoft .NET 6的新特性。
- en: You will be able to apply the new C# 10.0 code features within your source code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够在源代码中应用新的C# 10.0代码功能。
- en: You will be able to compile your source code to native assemblies (also known
    as binaries).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够将源代码编译成原生程序集（也称为二进制文件）。
- en: You will know what, how, and where to look for information on improving the
    performance of applications that target the Windows Store.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解如何查找有关提高针对Windows Store的应用程序性能的信息，包括什么、如何以及在哪里查找。
- en: You will know what, how, and where to look for information on improving the
    performance of ASP.NET applications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解如何查找有关提高ASP.NET应用程序性能的信息，包括什么、如何以及在哪里查找。
- en: Let's begin this chapter by looking at Microsoft .NET 6.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解Microsoft .NET 6开始这一章。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following prerequisites to complete this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下先决条件来完成本章：
- en: The latest preview version of Visual Studio Community Edition or higher.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Community Edition的最新预览版本或更高版本。
- en: Microsoft .NET 6 SDK.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft .NET 6 SDK。
- en: 'This book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH01](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH01).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH01](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH01)。
- en: 'Optional: The latest Roslyn compiler built from source. The source code is
    available on GitHub at [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn).
    This should be automatically installed when you install the latest preview versions
    of Visual Studio.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：从源代码构建的最新 Roslyn 编译器。源代码可在 GitHub 上找到 [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)。在安装
    Visual Studio 的最新预览版本时，这应该会自动安装。
- en: Note
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the latest complete and up-to-date C# 10.0 feature set at [https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md).
    At the time of writing, C# 10.0 is still undergoing much development and change.
    So, the contents of this book may not work as expected. If this turns out to be
    the case, then please refer to the preceding URL for the most relevant information
    to help you start working.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)
    找到最新的完整和最新的 C# 10.0 功能集。在撰写本文时，C# 10.0 仍在经历许多发展和变化。因此，本书中的内容可能无法按预期工作。如果出现这种情况，请参阅前面的
    URL 获取最相关的信息，以帮助您开始工作。
- en: Obtaining and building the latest Roslyn compiler from the source code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码获取和构建最新的 Roslyn 编译器
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The build system of all .NET-related repositories has been in flux for several
    years now. We will provide the instructions for compiling Roslyn here; these were
    correct at the time of writing. For the latest instructions, please read the `README.md`
    file located at [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 .NET 相关存储库的构建系统已经变动了几年。我们将在此处提供编译 Roslyn 的说明；这些说明在撰写本文时是正确的。对于最新的说明，请阅读位于
    [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn) 的 `README.md`
    文件。
- en: 'The following instructions are for downloading and building the latest version
    of the Roslyn compiler source on Windows 10:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明是关于在 Windows 10 上下载和构建 Roslyn 编译器最新版本源代码的：
- en: 'In the root of the `C:\` drive, clone the Roslyn source code by using the following
    command in the Windows Command Prompt:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `C:\` 驱动的根目录下，使用以下命令在 Windows 命令提示符中克隆 Roslyn 源代码：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, run the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Restore the Roslyn dependencies by running the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令恢复 Roslyn 依赖项：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Build the Roslyn source code by running the following command:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建 Roslyn 源代码：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Test the Roslyn build by running the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令测试 Roslyn 构建：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once all the tests have finished running, check the versions of C# that are
    accessible to the new computer. Do this by opening a Command Prompt window and
    navigating to `C:\roslyn\artifacts\bin\csc\Debug\net472`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有测试都已完成，请检查新计算机可访问的 C# 版本。通过打开命令提示符窗口并导航到 `C:\roslyn\artifacts\bin\csc\Debug\net472`
    来执行此操作。
- en: 'Then, run the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: I always run my Command Prompt as an administrator. Hence, the screenshots will
    show Command Prompt in administrative mode. But running Command Prompt as an administrator
    is not necessary for this exercise. Where Command Prompt must be executed as an
    administrator, this will be made clear as needed.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我总是以管理员身份运行我的命令提示符。因此，截图将显示管理员模式的命令提示符。但运行命令提示符作为管理员对于这项练习不是必需的。当需要作为管理员执行命令提示符时，这将在需要时明确说明。
- en: 'You should see something equivalent to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下类似的内容：
- en: '![Figure 1.1 – The versions of the C# programming language supported by the
    compiler'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 编译器支持的 C# 编程语言版本](img/B16617_Figure_1.1.jpg)'
- en: '](img/B16617_Figure_1.1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 编译器支持的 C# 编程语言版本](img/B16617_Figure_1.1.jpg)'
- en: Figure 1.1 – The versions of the C# programming language supported by the compiler
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 编译器支持的 C# 编程语言版本
- en: As you can see, at the time of writing, version 10.0 of the C# language is available
    via the C# compiler. C# 10.0 is set as the default. The preview is still under
    development. The default version may be different on your computer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在撰写本文时，C# 语言的 10.0 版本可以通过 C# 编译器获得。C# 10.0 被设置为默认版本。预览版本仍在开发中。默认版本可能在您的计算机上不同。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The latest version of Visual Studio 2022 should allow you to use the latest
    available C# 10.0 code features. If it doesn't, then compile the latest source
    and overwrite the files located at `C:\Program Files (x86)\Microsoft Visual Studio\2022\Preview\MSBuild\Current\Bin\Roslyn`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 的最新版本应允许您使用最新的 C# 10.0 代码功能。如果不行，则编译最新的源代码并覆盖位于 `C:\Program
    Files (x86)\Microsoft Visual Studio\2022\Preview\MSBuild\Current\Bin\Roslyn` 的文件。
- en: 'The following three sets of instructions provide compiler help for compiling
    a program that targets a specific C# version and then runs the program. These
    commands are for demonstrative purposes only, and you do not have to run them
    now:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三组指令提供了针对特定 C# 版本编译程序并运行程序的编译器帮助。这些命令仅用于演示目的，您现在不需要运行它们：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you can build C# 10.0 from the command line and from within Visual
    Studio 2022, let's learn what kind of new development is taking place with Microsoft
    .NET 6.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以从命令行和 Visual Studio 2022 内部构建 C# 10.0，让我们了解在 Microsoft .NET 6 中正在进行的新开发。
- en: Overview of Microsoft .NET 6
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft .NET 6 概述
- en: Microsoft .NET 6 is the latest incarnation of .NET. You can access the downloads
    at [https://dotnet.microsoft.com/download/dotnet/6.0](https://dotnet.microsoft.com/download/dotnet/6.0).
    The downloads are available for Windows, macOS, and Linux users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft .NET 6 是 .NET 的最新版本。您可以在 [https://dotnet.microsoft.com/download/dotnet/6.0](https://dotnet.microsoft.com/download/dotnet/6.0)
    访问下载。下载适用于 Windows、macOS 和 Linux 用户。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: To get the most out of .NET 6 and C# 10.0, it is best that you have Visual Studio
    2022 or later installed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用 .NET 6 和 C# 10.0，最好您已安装 Visual Studio 2022 或更高版本。
- en: The .NET 6 API documentation is available at [https://docs.microsoft.com/dotnet/api/?view=net-6.0](https://docs.microsoft.com/dotnet/api/?view=net-6.0).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 API 文档可在 [https://docs.microsoft.com/dotnet/api/?view=net-6.0](https://docs.microsoft.com/dotnet/api/?view=net-6.0)
    获取。
- en: 'Microsoft .NET 5 and later will no longer carry the *Core or Framework suffix*,
    as per the following article: [https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx](https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx).
    Microsoft''s goal with version 5 and later of the .NET platform is to create a
    single platform for the .NET development of WinForms, WPF, Xamarin.Forms, ASP.NET
    Core, and all other forms of .NET development. Xamarin.Forms becomes Microsoft
    MAUI, with the main difference between versions being that the new Microsoft MAUI
    will only use a single project to target all operating systems and devices.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下文章，Microsoft .NET 5 及以后的版本将不再携带 *Core 或 Framework 后缀*：[https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx](https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx)。微软希望通过
    .NET 平台的 5 版本及以后的版本创建一个单一的平台，用于 WinForms、WPF、Xamarin.Forms、ASP.NET Core 以及所有其他形式的
    .NET 开发。Xamarin.Forms 变成了 Microsoft MAUI，版本之间的主要区别在于新的 Microsoft MAUI 将仅使用一个项目来针对所有操作系统和设备。
- en: Moving to one unified platform
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向一个统一平台
- en: The infrastructure for .NET 6 consists of runtime components, compilers, and
    languages. Microsoft .NET SDK will sit on top of this infrastructure. The tools
    that will be available include the command-line interface, Visual Studio Code,
    Visual Studio for Mac, and, of course, Visual Studio.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 的基础设施包括运行时组件、编译器和语言。Microsoft .NET SDK 将位于此基础设施之上。可用的工具包括命令行界面、Visual
    Studio Code、Visual Studio for Mac，以及当然，Visual Studio。
- en: With the unified platform, you can write desktop applications using WinForms,
    WPF, and UWP. Web applications can be written using ASP.NET. Cloud applications
    will target Microsoft Azure. Mobile applications will be written using Microsoft
    MAUI. Games, **virtual reality** (**VR**), and **augmented reality** (**AR**)
    applications will be developed in Unity, using Visual Studio 2022 or higher as
    the C# code editor. IoT will target ARM32 and ARM64 architectures. Finally, you
    will be able to develop **artificial intelligence** (**AI**) applications using
    ML.NET and .NET for Apache Spark.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用统一平台，您可以使用 WinForms、WPF 和 UWP 编写桌面应用程序。可以使用 ASP.NET 编写 Web 应用程序。云应用程序将针对 Microsoft
    Azure。移动应用程序将使用 Microsoft MAUI 编写。游戏、**虚拟现实**（**VR**）、**增强现实**（**AR**）应用程序将在 Unity
    中开发，使用 Visual Studio 2022 或更高版本作为 C# 代码编辑器。物联网将针对 ARM32 和 ARM64 架构。最后，您将能够使用 ML.NET
    和 .NET for Apache Spark 开发 **人工智能**（**AI**）应用程序。
- en: Microsoft is planning on producing a single .NET runtime and framework that
    is uniform in its developer experience and runtime behavior across applications
    and devices. This will be accomplished by building a single code base that combines
    the best elements of.NET Framework, .NET Core, Mono, and Xamarin.Forms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 微软计划生产一个单一的 .NET 运行时和框架，它在应用程序和设备之间的开发者体验和运行时行为上是一致的。这将通过构建一个单一的代码库来实现，该代码库结合了
    .NET Framework、.NET Core、Mono 和 Xamarin.Forms 的最佳元素。
- en: 'The main features of.NET 6 are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 的主要功能如下：
- en: Unified developer experiences, regardless of the applications being developed
    and the devices being targeted.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一的开发者体验，无论开发的应用程序和目标设备是什么。
- en: Unified runtime experiences across all devices and platforms.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有设备和平台之间提供统一的运行时体验。
- en: 'Java interoperability will be available on all platforms. This is stated in
    the Redmond Magazine article called *Coming in 2020: .NET 5, The Next Phase of
    Microsoft''s .NET Framework*: [https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx](https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 兼容性将在所有平台上可用。这在 Redmond Magazine 的文章《2020 年即将到来：.NET 5，微软 .NET 框架的下一阶段》中有说明：[https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx](https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx)。
- en: Multiple operating systems will be supported for Objective-C and Swift.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将支持 Objective-C 和 Swift 的多个操作系统。
- en: AOT will be supported by CoreFX to provide static .NET compilation, support
    multiple operating systems, and produce assemblies that are smaller in size.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreFX 将支持 AOT（Ahead-Of-Time）编译，以提供静态 .NET 编译，支持多个操作系统，并生成更小的程序集。
- en: Now, let's look at some of the new features of .NET 6 from a high-level viewpoint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从高层次的角度看看 .NET 6 的一些新特性。
- en: Garbage collection
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**垃圾回收**'
- en: The garbage collector's performance regarding marking and stealing has been
    improved. When a thread has finished its marking allotment, it can steal outstanding
    marking work from other threads. This speeds up the process of collecting items
    to be garbage collected. Reduced lock contentions on computers with higher core
    counts, improved de-committing, avoidance of costly memory resets, and vectorized
    sorting are just some of the new garbage collection performance improvements in
    .NET 6.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器在标记和窃取方面的性能得到了改进。当一个线程完成其标记配额后，它可以从其他线程那里窃取未完成的标记工作。这加快了收集要回收垃圾的项目的过程。在具有更多核心的计算机上减少了锁竞争，改进了取消提交，避免了昂贵的内存重置，以及向量排序，这些都是
    .NET 6 中新的垃圾回收性能改进的例子。
- en: Just-In-Time compiler
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**即时编译器**'
- en: In .NET 6, the **Just-In-Time** (**JIT**) compiler has also been improved. You
    can apply various optimizations to the JIT, and it has an unlimited amount of
    time to implement those optimizations. **Ahead-Of-Time** (**AOT**) is just one
    of the various techniques provided to the JIT so that it can compile as much code
    as it can before executing the application. The JIT now sees the length of an
    array as unsigned, which improves the performance of mathematical operations carried
    out on an array's length. There are still many changes being made.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中，**即时编译器**（**JIT**）也得到了改进。您可以对 JIT 应用各种优化，并且它有无限的时间来实现这些优化。**提前编译**（**AOT**）只是提供给
    JIT 的多种技术之一，以便它在执行应用程序之前尽可能多地编译代码。JIT 现在将数组长度视为无符号数，这提高了对数组长度执行数学运算的性能。还有很多变化正在进行中。
- en: Suffice to say that between the JIT and the GC, the performance improvements
    that have been made to JIT and GC concerning memory and compilation optimizations
    are just two reasons alone to migrate to .NET 6\.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅说，在 JIT 和 GC（垃圾回收器）之间，针对内存和编译优化所进行的性能改进，仅仅是迁移到 .NET 6 的两个原因之一。
- en: The JIT also recognizes more than a thousand new hardware intrinsic methods.
    These methods allow you to target various hardware instruction sets from C#. You
    are no longer tied to just x86_x64 hardware instruction sets.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 现在识别了超过一千种新的硬件内建方法。这些方法允许您从 C# 中针对各种硬件指令集进行操作。您不再仅限于 x86_x64 硬件指令集。
- en: Several runtime helper functions are available in the JIT. These helper functions
    enable the JIT compiler to manipulate the source code so that the code runs must
    faster. Generic lookups are much faster now, as they no longer need to employ
    slower lookup tables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JIT（Just-In-Time）编译器中提供了几个运行时辅助函数。这些辅助函数使 JIT 编译器能够操作源代码，从而使代码运行速度必须更快。现在，泛型查找速度更快，因为它们不再需要使用较慢的查找表。
- en: Text-based processing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于文本的处理
- en: Performance enhancements have also been made within the text-based processing
    elements of .NET 6\. These include (but are not limited to) processing whitespace
    in the `System.Char` class, which requires less branching and fewer arguments.
    Because this class is used in various text-processing objects and methods within
    .NET 6, the speed of processing text in .NET 6 will be generally improved. `DateTime`
    processing is also at least 30% faster due to optimizations in extracting the
    date and time components from the raw tick count. Performance improvements have
    also been made to string operations due to culture-aware modifications of `StartsWith`
    and `EndsWith`. By utilizing stack allocation and JIT devirtualization, the performance
    of data encoding, such as *UTF8* and *Latin1* encoding, has also been enhanced.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6的文本处理元素中也进行了性能提升。这包括（但不限于）在`System.Char`类中处理空白字符，这需要更少的分支和更少的参数。由于这个类在.NET
    6中的各种文本处理对象和方法中被使用，因此.NET 6处理文本的速度将普遍提高。`DateTime`处理也因为从原始滴答计数中提取日期和时间组件的优化而至少快了30%。由于对`StartsWith`和`EndsWith`的本地化修改，字符串操作的性能也得到了提升。通过利用堆分配和JIT去虚拟化，数据编码（如*UTF8*和*Latin1*编码）的性能也得到了增强。
- en: '`CharInClass` method is more intelligent in determining if characters appear
    within the specified character class. Character and digit comparisons use lookup
    tables and various method calls are inlined, providing improved RegEx processing.
    Generated code for various expressions has been improved. Searching for RegExes
    is carried out using span-based searching with vectorized methods. The need for
    backtracking has been eliminated as it analyzes RegExes during the node tree optimization
    phase and adds atomic groups that do not change the semantics but do prevent backtracking.
    These are only some of the improvements to RegEx performance. But there are many
    more.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharInClass`方法在确定字符是否出现在指定的字符类中时更加智能。字符和数字比较使用查找表，各种方法调用被内联，提供了改进的正则表达式处理。各种表达式的生成代码也得到了改进。正则表达式的搜索是通过基于span的搜索和向量化方法来执行的。在节点树优化阶段分析正则表达式时消除了回溯的需要，并添加了不改变语义但防止回溯的原子组。这些只是正则表达式性能改进的一部分。但还有更多。'
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more in-depth knowledge on .NET 5 performance improvements to RegExes,
    please read the following very detailed post by Stephen Toub: [https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于.NET 5对正则表达式性能改进的深入知识，请阅读Stephen Toub发布的以下非常详细的帖子：[https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/)。
- en: Threading and asynchronous operations
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和异步操作
- en: Threading and asynchronous operations have also received a performance boost
    in .NET 5 with the experimental addition of async `ValueTask` pooling. You can
    turn on pooling by setting `DOTNET_SYSTEM_THREADING_POOLASYNCVALUETASK` to `true`
    or `1`. Pooling creates state machine box objects that implement the interfaces,
    `IvalueTaskSource`, and `IValueTaskSource<TResult>`. The runtime adds these objects
    to the pool. Volatility has also received performance improvements in `ConcurrentDictionary`,
    with performance improving as much as 30% on some ARM architectures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 5中，线程和异步操作也因实验性地添加了`async ValueTask`池化而得到了性能提升。你可以通过将`DOTNET_SYSTEM_THREADING_POOLASYNCVALUETASK`设置为`true`或`1`来开启池化。池化会创建实现接口`IvalueTaskSource`和`IValueTaskSource<TResult>`的状态机框对象，并将这些对象添加到池中。在`ConcurrentDictionary`中，波动性也得到了性能提升，在某些ARM架构上性能提升了高达30%。
- en: Collections and LINQ
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合和LINQ
- en: The collections have also seen several performance enhancements, mainly to `Dictionary<TKey,
    TValue>`, `HashSet<T>`, `ConcurrentDictionary<TKey, TValue>`, and `System.Collections.Immutable`.
    The `HashSet<T>` collection's implementation has been rewritten and re-synchronized
    with `Dictionary<TKey`,the `TValue>` implementation, and moved further down the
    stack. The performance of `foreach` when iterating through an `ImmutableArray<T>`
    has been improved, and the generated code has been reduced in size by the addition
    of the `[MethodImpl(MethodImplOptions.AggressiveInlining)]` annotation to the
    `GetEnumerator` method of `ImmutableArray<T>`. Other elements of the .NET collections,
    such as `BitArray`, have also seen performance improvements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集合也看到了几个性能增强，主要是对`Dictionary<TKey, TValue>`、`HashSet<T>`、`ConcurrentDictionary<TKey,
    TValue>`和`System.Collections.Immutable`的改进。`HashSet<T>`集合的实现已被重写，并与`Dictionary<TKey,
    TValue>`实现重新同步，并进一步向下移动到堆栈。在迭代`ImmutableArray<T>`时，`foreach`的性能得到了改善，并且通过将`[MethodImpl(MethodImplOptions.AggressiveInlining)]`注解添加到`ImmutableArray<T>`的`GetEnumerator`方法，减少了生成的代码大小。.NET集合的其他元素，如`BitArray`，也看到了性能提升。
- en: In .NET 5, LINQ has also seen further performance improvements, including `OrderBy`,
    `Comparison<T>`, `Enumerable.SkipLast`, and by making implementing `Enumerable.Any`
    more consistent with `Enumerable.Count`. These are only a few performance improvements
    that have been to the collections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 5中，LINQ也看到了进一步的性能提升，包括`OrderBy`、`Comparison<T>`、`Enumerable.SkipLast`，以及通过使实现`Enumerable.Any`与`Enumerable.Count`更加一致。这些只是对集合进行的一些性能改进。
- en: Networking and Blazor
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络和Blazor
- en: Networking has received a lot of work on performance improvement, especially
    the `System.Uri` class (especially in its construction). The `System.Net.Sockets`
    and `System.Net.Http` namespaces have also seen performance improvements. Many
    improvements have been made to how JSON is processed with `JsonSerializer` in
    the `System.Text.Json` library for .NET.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 网络性能改进方面已经做了大量工作，特别是对`System.Uri`类（尤其是在其构造过程中）的改进。`System.Net.Sockets`和`System.Net.Http`命名空间也看到了性能的提升。在.NET的`System.Text.Json`库中，对JSON的处理方式通过`JsonSerializer`也进行了许多改进。
- en: As Blazor uses the .NET mono runtime and .NET 5 libraries, a linker has been
    added that trims code from the assembly that is not used down to the member level.
    The code to be trimmed is identified by *static code analysis*. User interface
    response times are also improved in Blazor Web Assembly applications, as the client-side
    code is downloaded before being executed, and behaves just like a desktop application
    – but from within the browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Blazor使用.NET mono运行时和.NET 5库，增加了一个链接器，它可以从程序集级别裁剪掉未使用的代码。要裁剪的代码通过*静态代码分析*来识别。在Blazor
    Web Assembly应用程序中，用户界面响应时间也得到了改善，因为客户端代码在执行之前被下载，并且表现得就像桌面应用程序一样——但这是在浏览器内部。
- en: Furthermore, general improvements that have gone into .NET 5 include faster
    assembly loading, faster mathematical operations, faster encryption and decryption,
    faster interoperability, faster reflection emitting, faster I/O, and various allocations
    in various libraries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，.NET 5中还包括了多项通用改进，包括更快的程序集加载、更快的数学运算、更快的加密和解密、更快的互操作性、更快的反射生成、更快的I/O以及各种库中的各种分配。
- en: New performance-based APIs and analyzers
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的性能相关API和分析器
- en: A few new performance-focused APIs have been added to .NET 5\. Internally, some
    of these APIs are already being used to reduce code size and improve the performance
    of .NET 5 itself. They focus on helping the programmer to concentrate on writing
    performant code and removing the complexity of tasks that have been previously
    hard to accomplish. These new APIs and improvements to existing APIs include `Decimal`,
    `GC`, `MemoryExtensions`, `StringSplitOptions`, `BinaryPrimitives`, `MailAddress`,
    `MemoryMarshall`, `SslStream`, `HttpClient`, and more.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5增加了一些新的以性能为重点的API。内部，一些这些API已经被用于减少代码大小并提高.NET 5本身的性能。它们专注于帮助程序员专注于编写高性能的代码，并移除之前难以完成的任务的复杂性。这些新的API和现有API的改进包括`Decimal`、`GC`、`MemoryExtensions`、`StringSplitOptions`、`BinaryPrimitives`、`MailAddress`、`MemoryMarshall`、`SslStream`、`HttpClient`等。
- en: The .NET 5 SDK has also seen the addition of some new performance-based analyzers.
    These analyzers can detect accidental allocations as a part of range indexing
    and offer ways to eliminate the allocation. Analyzers will detect the old overloads
    for the `Stream.Read`/`WriteAsync` methods and will offer fixes to enable automatic
    switching to the newer overload methods that prefer `Memory` overloads. In `StringBuilder`,
    it is more performant to use *typed overloads* to append non-string values such
    as `int` and `long` values. When situations are encountered by the analyzer where
    the programmer has called `ToString()` on a type that's being appended for which
    a typed overload exists, the fixer will detect these situations and automatically
    switch to using the correct typed overload. With LINQ, it is now more efficient
    to check if `(collection.Count != 0)` using the `(!collection.IsEmpty)` syntax.
    The old way will be detected by the analyzer and fixed to use the more performant
    new way. Finally, when you have worked to make your code faster, your code is
    made correct, as the analyzer flags cases that use loops to allocate memory from
    the stack using `stackalloc`. This helps prevent stack overflow exceptions from
    being raised.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5 SDK还增加了一些基于性能的分析器。这些分析器可以检测范围索引中的意外分配，并提供消除分配的方法。分析器将检测`Stream.Read`/`WriteAsync`方法的旧重载，并提供修复方案以启用自动切换到更新的重载方法，这些方法更倾向于使用`Memory`重载。在`StringBuilder`中，使用*类型重载*来追加非字符串值（如`int`和`long`值）更高效。当分析器遇到程序员对一个存在类型重载的、被追加的类型调用`ToString()`的情况时，修复器将检测这些情况并自动切换到使用正确的类型重载。使用LINQ，现在使用`(!collection.IsEmpty)`语法检查`(collection.Count
    != 0)`更高效。旧的方法将被分析器检测并修复为使用更高效的新的方法。最后，当您努力使代码更快时，代码也会变得正确，因为分析器会标记使用`stackalloc`从堆栈分配内存的循环使用情况。这有助于防止引发堆栈溢出异常。
- en: To see the road ahead in terms of .NET's new development, you can view the .NET
    Core roadmap located at [https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解.NET新开发的路线图，您可以查看位于[https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md)的.NET
    Core路线图。
- en: Now, let's look at C# 10.0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看C# 10.0。
- en: Overview of C# 10.0
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 10.0概述
- en: You can find the features that will become part of C# 10.0 on the Roslyn GitHub
    page at [https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Roslyn GitHub页面上找到将成为C# 10.0一部分的功能，该页面位于[https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)。
- en: Not all these features are available at the time of writing. However, we will
    look at some of the available features. With that, let's start with top-level
    programs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些功能在撰写本文时都可用。然而，我们将探讨一些可用的功能。让我们从顶层程序开始。
- en: Writing top-level programs
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写顶层程序
- en: 'Before C# 9.0, the `Program.cs`. In this file, you would have something akin
    to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 9.0之前，`Program.cs`文件是这样的。在这个文件中，您会有以下类似的内容：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, first, we import our `System` library. Then, we have a namespace
    definition followed by our class definition. Then, in the class definition, we
    have our `Main` method, in which we output the phrase `"Hello, World!"` to the
    console window.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，首先，我们导入我们的`System`库。然后，我们有一个命名空间定义，后面是我们的类定义。然后，在类定义中，我们有`Main`方法，在这个方法中，我们将短语`"Hello,
    World!"`输出到控制台窗口。
- en: 'In version 10.0 of the C# programming language, this can be simplified down
    to a single line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程语言的10.0版本中，这可以简化为单行：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have eradicated 10 lines of code. Running the program will output
    the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们删除了10行代码。运行程序将输出以下内容：
- en: '![Figure 1.2 – The console window showing the output "Hello World!"'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.2 – 控制台窗口显示输出"Hello World!"'
- en: '](img/B16617_Figure_1.2.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.2.jpg)'
- en: Figure 1.2 – The console window showing the output "Hello World!"
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.2 – 控制台窗口显示输出"Hello World!"
- en: 'If we open the generated DLL in IL DASM, we will see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开生成的DLL文件在ILDASM中，我们将看到以下内容：
- en: '![Figure 1.3 – ILDASM showing the internals of the hello world program'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – ILDASM显示hello world程序的内部结构'
- en: '](img/B16617_Figure_1.3.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.3.jpg)'
- en: Figure 1.3 – ILDASM showing the internals of the hello world program
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.3 – ILDASM显示hello world程序的内部结构
- en: You will see from the decompilation that the compiler adds the `Main` method
    at compile time. The next addition to C# 10.0 that we will look at is init-only
    properties.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从反编译中看到编译器在编译时添加了`Main`方法。我们将要查看的C# 10.0的下一个新增功能是只初始化属性。
- en: Using init-only properties
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用只初始化属性
- en: 'Init-only properties allow you to use object initializers with immutable fields.
    For our little demonstration, we will use a `Book` class that holds the name of
    a book and its author:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 只初始化属性允许您使用具有不可变字段的对象初始化器。在我们的简单演示中，我们将使用一个包含书籍名称及其作者的`Book`类：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The properties can be initialized when the book is created. But once created,
    they can only be read, not updated, making the `Book` type immutable. Now, let''s
    look at init-only properties. In the `Program` class, replace its contents with
    the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以在创建书籍时初始化。但一旦创建，它们只能读取，不能更新，使得`Book`类型不可变。现在，让我们看看只初始化属性。在`Program`类中，将其内容替换为以下内容：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we imported the `System` and `CH01_Books` namespaces. Then, we declared
    a new immutable variable of the `Book` type. After that, we output the contents
    of that `Book` type using an interpolated string. Run the program; you should
    see the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了`System`和`CH01_Books`命名空间。然后，我们声明了一个新的`Book`类型的不可变变量。之后，我们使用插值字符串输出了该`Book`类型的内容。运行程序；您应该看到以下输出：
- en: '![Figure 1.4 – The output of our init-only properties example'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 我们只初始化属性示例的输出]'
- en: '](img/B16617_Figure_1.4.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4](img/B16617_Figure_1.4.jpg)'
- en: Figure 1.4 – The output of our init-only properties example
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 我们只初始化属性示例的输出
- en: Now that we have been introduced to init-only properties, let's look at records.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了只初始化属性，让我们看看记录。
- en: Using records
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用记录
- en: When updating data, you do not want that data to be changed by another thread.
    So, in multi-threaded applications, you will want to use thread-safe objects when
    making updates. Records allow complete objects to be immutable and behave as values.
    The advantage of using records over structs is that they require less memory to
    be allocated to them. This reduction in memory allocation is accomplished by compiling
    records to reference types. They are then accessed via references and not as copies.
    Due to this, other than the original record allocation, no further memory allocation
    is required.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新数据时，您不希望数据被另一个线程更改。因此，在多线程应用程序中，您将希望在使用更新时使用线程安全的对象。记录允许完整的对象不可变，并作为值行为。使用记录而不是结构体的优点是它们需要的内存分配更少。这种内存分配的减少是通过将记录编译为引用类型来实现的。然后通过引用而不是副本来访问它们。因此，除了原始记录的分配之外，不需要进一步分配内存。
- en: Let's learn how to use records. Start a new console application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用记录。启动一个新的控制台应用程序。
- en: 'To demonstrate the use of records, we will use the following `Book` example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示记录的使用，我们将使用以下`Book`示例：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The only change to the `Book` class is that class has been replaced with `record`.
    Everything else remains the same. Now, let''s put the record to work:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Book`类的唯一更改是将类替换为`record`。其他一切保持不变。现在，让我们将记录投入使用：
- en: 'Replace the contents of the `Program` class with the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Program`类的内容替换为以下代码：
- en: '[PRE38]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we are creating immutable record types. We can create new immutable
    types from them and change any fields we like using the `with` expression. The
    original record is not mutated in any way. Run the code; you will see the following
    output:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们正在创建不可变的记录类型。我们可以从它们创建新的不可变类型，并使用`with`表达式更改任何我们喜欢的字段。原始记录不会被任何方式修改。运行代码；您将看到以下输出：
- en: '![Figure 1.5 – Init-only properties showing their immutability'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 显示其不可变性的只初始化属性]'
- en: '](img/B16617_Figure_1.5.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5](img/B16617_Figure_1.5.jpg)'
- en: Figure 1.5 – Init-only properties showing their immutability
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 显示其不可变性的只初始化属性
- en: Despite changing the title during the assignment, the original record has not
    been mutated at all.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在分配过程中更改了标题，但原始记录根本未发生任何修改。
- en: 'Records can also use *inheritance*. Let''s add a new record that contains the
    publisher''s name:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录也可以使用*继承*。让我们添加一个新的包含出版商名称的记录：
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s have our `Book` inherit this `Publisher` record:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们让我们的`Book`类继承这个`Publisher`记录：
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Book` will now include `PublisherName`. When we initialize a new book, we
    can now set its `PublisherName`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Book`现在将包括`PublisherName`。当我们初始化一本新书时，我们现在可以设置其`PublisherName`：'
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we have created a new `Book` that contains `Publisher.PublisherName`.
    Let''s print the publisher''s name. Add the following line to the end of the `Program`
    class:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个新的 `Book`，其中包含 `Publisher.PublisherName`。让我们打印出版者的名字。将以下行添加到 `Program`
    类的末尾：
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the code; you should see the following output:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码；你应该看到以下输出：
- en: '![Figure 1.6 – Init-only properties using inheritance'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 使用继承的仅初始化属性'
- en: '](img/B16617_Figure_1.6.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.6.jpg)'
- en: Figure 1.6 – Init-only properties using inheritance
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 使用继承的仅初始化属性
- en: As you can see, we never set the publisher's name for `bookTwo` to `bookSix`.
    However, the inheritance has followed through from when we set it for `bookOne`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们从未为 `bookTwo` 到 `bookSix` 设置出版者的名字。然而，继承是从我们为 `bookOne` 设置它的时候开始的。
- en: 'Now, let''s perform object equality checking. Add the following code to the
    end of the `Program` class:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们执行对象等式检查。将以下代码添加到 `Program` 类的末尾：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we created a new `Book` from `bookThree` and set the title to `Made Up
    Book`. Then, we performed an equality check and output the result to the console
    window. Run the code; you will see the following output:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们从一个 `bookThree` 创建了一个新的 `Book`，并将标题设置为 `Made Up Book`。然后，我们执行了等式检查，并将结果输出到控制台窗口。运行代码；你会看到以下输出：
- en: '![Figure 1.7 – Init-only properties showing the result of an equality check'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 仅初始化属性显示等式检查的结果'
- en: '](img/B16617_Figure_1.7.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.7.jpg)'
- en: Figure 1.7 – Init-only properties showing the result of an equality check
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 仅初始化属性显示等式检查的结果
- en: It is clear to see that the equality check works with both book instances being
    equal.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，等式检查在两个书实例相等时都起作用。
- en: 'Our final look at records considers positional records. Positional records
    set data via the constructor and extract data via the deconstructor. The best
    way to understand this is with code. Add a class called `Product` and replace
    the class with the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对记录的最终审视考虑了位置记录。位置记录通过构造函数设置数据，并通过解构函数提取数据。理解这一点最好的方式是代码。添加一个名为 `Product`
    的类，并用以下代码替换类：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we have an immutable record. The record has two private and `readonly`
    fields. They are set in the constructor. The `Deconstruct` method is used to return
    the data. Add the following code to the `Program` class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有一个不可变的记录。记录有两个私有和 `readonly` 字段。它们在构造函数中设置。`Deconstruct` 方法用于返回数据。将以下代码添加到
    `Program` 类中：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this code, we created a new product with parameters for the name and description.
    Then, we declared two fields called `product` and `description`. The fields are
    set by assigning the product. Then, we output the product and description to the
    console window, as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个新的产品，具有名称和描述的参数。然后，我们声明了两个名为 `product` 和 `description` 的字段。字段通过分配产品来设置。然后，我们将产品及其描述输出到控制台窗口，如下所示：
- en: '![Figure 1.8 – Init-only positional records'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 仅初始化位置记录'
- en: '](img/B16617_Figure_1.8.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.8.jpg)'
- en: Figure 1.8 – Init-only positional records
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 仅初始化位置记录
- en: Now that we have finished looking at records, let's look at the improved pattern
    matching capabilities of C# 10.0.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对记录的查看，让我们看看 C# 10.0 改进的模式匹配功能。
- en: Using the new pattern matching features
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新的模式匹配功能
- en: 'Now, let''s look at what''s new for pattern matching in C# 10.0, starting with
    simple patterns. With simple pattern matching, you no longer need the discard
    (`_`) operator to just declare the type. In our example, we will apply discounts
    to orders:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 C# 10.0 中模式匹配的新特性，从简单的模式开始。在简单的模式匹配中，你不再需要丢弃 (`_`) 操作符来仅声明类型。在我们的例子中，我们将对订单应用折扣：
- en: 'Add a new record called `Product` to a new file called `Product.cs` in a new
    console application and add the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的控制台应用程序中，向名为 `Product.cs` 的新文件中添加一个名为 `Product` 的新记录，并添加以下代码：
- en: '[PRE46]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our `Product` record has three init-only properties for `Name`, `Description`,
    and `UnitPrice`. Now, add the `OrderItem` record that inherits from `Product`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Product` 记录有三个仅初始化属性，用于 `Name`、`Description` 和 `UnitPrice`。现在，添加一个继承自 `Product`
    的 `OrderItem` 记录：
- en: '[PRE47]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our `OrderItem` record inherits the `Product` record and adds the `QuantityOrdered`
    init-only property. In the `Program` class, we will add three variables of the
    `OrderItem` type and initialize them. Here is the first `OrderItem`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `OrderItem` 记录继承了 `Product` 记录，并添加了 `QuantityOrdered` 仅初始化属性。在 `Program`
    类中，我们将添加三个 `OrderItem` 类型的变量并初始化它们。这是第一个 `OrderItem`：
- en: '[PRE48]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the quantity that's being ordered is `4`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，正在订购的数量是 `4`。
- en: Add `orderTwo` with the same values but with an `OrderQuantity` of `7`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`orderTwo`，具有相同的值，但`OrderQuantity`为`7`。
- en: 'Then, add `orderThree` with the same values, but with an `OrderQuantity` of
    `31`. We will demonstrate simple pattern matching in the `GetDiscount` method:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加`orderThree`，具有相同的值，但`OrderQuantity`为`31`。我们将在`GetDiscount`方法中演示简单模式匹配：
- en: '[PRE49]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our `GetDiscount` method receives an order. `QuantityOrdered` is then evaluated.
    Argument exceptions are thrown if the order quantity is `0` and if the object
    type that's been passed in is not of the `OrderItem` type. Otherwise, a discount
    of the `int` type is returned for the quantity ordered. Notice that we use the
    type without using the discard operator on the line for the 20% discount.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`GetDiscount`方法接收一个订单。然后评估`QuantityOrdered`。如果订单数量为`0`或者传入的对象类型不是`OrderItem`类型，则会抛出参数异常。否则，返回一个`int`类型的折扣，对于订单数量。注意，我们在20%折扣的行上没有使用丢弃运算符。
- en: 'Finally, we must add the following lines to the end of the `Program` class:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须将以下行添加到`Program`类的末尾：
- en: '[PRE50]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These lines print the discount received for each of the orders to the console
    window. Now, let''s modify our code so that it uses relational pattern matching.
    Add the following method to the `Program` class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些行将每个订单的折扣打印到控制台窗口。现在，让我们修改我们的代码，使其使用关系模式匹配。向`Program`类添加以下方法：
- en: '[PRE51]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using relational pattern matching, we have received the same outcome as with
    simple pattern matching, but with less code. It is also very readable, which makes
    it easy to maintain. Add the following three lines of code to the end of the `Program`
    class:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关系模式匹配，我们得到了与简单模式匹配相同的结果，但代码更少。它也非常易于阅读，这使得它很容易维护。将以下三行代码添加到`Program`类的末尾：
- en: '[PRE52]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In these three lines, we simply output the discount for each order to the console
    window. Run the program; you will see the following output:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这三行中，我们只是将每个订单的折扣输出到控制台窗口。运行程序；你会看到以下输出：
- en: '![Figure 1.9 – Simple and relational pattern matching output showing the same
    results'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 简单和关系模式匹配输出显示相同的结果'
- en: '](img/B16617_Figure_1.9.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 图 1.9 的图片](img/B16617_Figure_1.9.jpg)'
- en: Figure 1.9 – Simple and relational pattern matching output showing the same
    results
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 简单和关系模式匹配输出显示相同的结果
- en: From the preceding screenshot, you can see that the same outcome has been received
    for both discount methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，两种折扣方法都得到了相同的结果。
- en: 'The logical `AND`, `OR`, and `NOT` methods can be used in logical pattern matching.
    Let''s add the following method:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑`AND`、`OR`和`NOT`方法可用于逻辑模式匹配。让我们添加以下方法：
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `GetDiscountLogical` method, we employ the logical AND operator to check
    whether a value falls in that range. Add the following three lines to the end
    of the `Program` class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetDiscountLogical`方法中，我们使用逻辑AND运算符来检查一个值是否在该范围内。将以下三行添加到`Program`类的末尾：
- en: '[PRE54]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In those three lines of code, we output the discount value for the order to
    the console window. Run the code; you will see the following output:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这三行代码中，我们将订单的折扣值输出到控制台窗口。运行代码；你会看到以下输出：
- en: '![Figure 1.10 – Simple, relational, and logical pattern matching showing the
    same results'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 简单、关系和逻辑模式匹配显示相同的结果'
- en: '](img/B16617_Figure_1.10.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 简单、关系和逻辑模式匹配显示相同的结果'
- en: Figure 1.10 – Simple, relational, and logical pattern matching showing the same
    results
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 简单、关系和逻辑模式匹配显示相同的结果
- en: The output for the logical pattern matching is the same as for simple and relational
    pattern matching. Now, let's learn how to use new expressions with targeted types.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑模式匹配的输出与简单和关系模式匹配的输出相同。现在，让我们学习如何使用具有目标类型的新表达式。
- en: Using new expressions with targeted types
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用具有目标类型的新表达式
- en: 'You can omit the type of object being instantiated. But to do so, the declared
    type must be explicit and not use the `var` keyword. If you attempt to do this
    with the ternary operator, you will be greeted with an exception:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略正在实例化的对象的类型。但要做到这一点，声明的类型必须是明确的，并且不能使用`var`关键字。如果你尝试使用三元运算符这样做，你会遇到一个异常：
- en: 'Create a new console application and add the `Student` record:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序并添加`Student`记录：
- en: '[PRE55]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our `Student` record stores the first and last name values, which have been
    set via the constructor. These values are obtained via the `out` parameters of
    the `Deconstruct` method. Add the following code to the `Program` class:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Student`记录存储了通过构造函数设置的姓名值。这些值是通过`Deconstruct`方法的`out`参数获得的。将以下代码添加到`Program`类中：
- en: '[PRE56]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'First, we instantiate a new `Student` without declaring the type in the `new`
    statement. Then, we instantiate a new `List` and add new students to the list
    while omitting the `Student` type. The fields are then defined for `firstName`
    and `lastName` and assigned their values through the assignment of the named student.
    The student''s name is then printed out on the console window. Next, we take those
    fields and reassign them with the name of the last student on the list. Then,
    we output the student''s name to the console window. Run the program; you will
    see the following output:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`new`语句中没有声明类型，实例化一个新的`Student`对象。然后，我们实例化一个新的`List`对象，并向列表中添加新的学生，同时省略了`Student`类型。接着，定义了`firstName`和`lastName`字段，并通过命名学生的赋值来分配它们的值。然后，学生的姓名在控制台窗口中打印出来。接下来，我们将这些字段重新分配给列表中的最后一个学生的姓名。然后，我们将学生的姓名输出到控制台窗口。运行程序；你会看到以下输出：
- en: '![Figure 1.11 – Using targeted types with new expressions'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 – 使用目标类型与new表达式](img/B16617_Figure_1.11.jpg)'
- en: '](img/B16617_Figure_1.11.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 – 使用目标类型与new表达式](img/B16617_Figure_1.11.jpg)'
- en: Figure 1.11 – Using targeted types with new expressions
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 使用目标类型与new表达式
- en: From the preceding screenshot, you can see that we have the correct student
    names printed. Now, let's look at covariant returns.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，你可以看到我们正确地打印出了学生姓名。现在，让我们看看协变返回。
- en: Using covariant returns
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用协变返回
- en: 'With covariant returns, base class methods with less specific return types
    can be overridden with methods that return more specific types. Have a look at
    the following array declaration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协变返回，基类方法可以用返回更具体类型的函数覆盖。看看以下数组声明：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we declared an `object` array. Then, we assigned a `string` array to it.
    This is an example of covariance. The `object` array is the least specific array
    type, while the `string` array is the more specific array type.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`object`数组。然后，我们将一个`string`数组赋值给它。这是一个协变的例子。`object`数组是最不具体的数组类型，而`string`数组是更具体的数组类型。
- en: 'In this example, we will instantiate covariant types and pass them into a method
    that accepts less and more specific types. Add the following class and interface
    declarations to the `Program` class:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实例化协变类型，并将它们传递给接受更不具体和更具体类型的函数。将以下类和接口声明添加到`Program`类中：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we have a covariant class that implements a covariant interface. We declared
    a general type of `Person` that is inherited by the specific `Teacher` and `Student`
    types. Add `CovarianceClass`, as shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个实现了协变接口的协变类。我们声明了一个通用的`Person`类型，该类型被具体的`Teacher`和`Student`类型继承。添加`CovarianceClass`，如下所示：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the `CovarianceExample` class, we have a `CovariantMethod` with a parameter
    that can accept objects of the `ICovariant<Person>` type. Now, let''s put covariance
    to work by adding the `CovarianceAtWork` method to the `CovarianceExample` class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CovarianceExample`类中，我们有一个可以接受`ICovariant<Person>`类型对象的`CovariantMethod`参数。现在，让我们通过将`CovarianceAtWork`方法添加到`CovarianceExample`类中来使用协变：
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this method, we have the general `Person` type and the more specific `Teacher`
    and `Student` types. We must pass each into `CovariantMethod`. This method can
    take the less specific `Person` type and the more specific `Teacher` and `Student`
    types.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们有通用的`Person`类型和更具体的`Teacher`和`Student`类型。我们必须将每个类型传递给`CovariantMethod`。此方法可以接受更不具体的`Person`类型和更具体的`Teacher`和`Student`类型。
- en: 'To run the `CovarianceAtWork` method, place the following code after the `using`
    statement and before the `covariantArray` example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`CovarianceAtWork`方法，请在`using`语句之后和`covariantArray`示例之前放置以下代码：
- en: '[PRE81]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, let's look at native compilation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看本地编译。
- en: Native compilation
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地编译
- en: When .NET code is compiled, it is compiled into **Microsoft Intermediate Language**
    (**MSIL**). MSIL gets interpreted by a JIT compiler when it is needed. The JIT
    compiler then compiles the necessary MSIL code into native binary code. Subsequent
    calls to the same code call the binary version of the code, not the MSIL version
    of the code. This means that MSIL code is always slower than native code, as it
    is compiled to native on the first run.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET代码编译时，它被编译成**微软中间语言**（**MSIL**）。当需要时，JIT编译器会解释MSIL。然后，JIT编译器将必要的MSIL代码编译成本地二进制代码。随后的对同一代码的调用将调用代码的二进制版本，而不是MSIL版本。这意味着MSIL代码始终比本地代码慢，因为它在第一次运行时被编译成本地代码。
- en: JIT code has the advantage of being cross-platform code at the expense of longer
    startup times. The code of an MSIL assembly that runs is compiled to native code
    by the JIT compiler. The native code is optimized by the JIT compiler for the
    target hardware it is running on.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 代码的优点是跨平台代码，但代价是较长的启动时间。正在运行的 MSIL 程序集的代码由 JIT 编译器编译成本地代码。JIT 编译器针对其运行的硬件优化本地代码。
- en: By default, UWP applications are compiled to native code using .NET Native,
    while iOS applications are compiled to native code via Xamarin/Xamarin.Forms.
    Microsoft .NET Core can also be compiled into native code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，UWP 应用程序使用 .NET Native 编译成本地代码，而 iOS 应用程序通过 Xamarin/Xamarin.Forms 编译成本地代码。Microsoft
    .NET Core 也可以编译成本地代码。
- en: Performing native compilation of .NET Core applications
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 .NET Core 应用程序的本地编译
- en: When using `dotnet` to compile an assembly to native code, you will need to
    specify a t[arget framework. For a list of supported target frameworks](https://docs.microsoft.com/en-us/dotnet/standard/frameworks),
    please refer to [https://docs.microsoft.com/en-us/dotnet/standard/frameworks](https://docs.microsoft.com/en-us/dotnet/standard/frameworks).
    You will also need to spec[ify a **Runtime Identifier** (**RID**). For a list
    of supported](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog) RIDs,
    please refer to [https://docs.microsoft.com/en-us/dotnet/core/rid-catalog](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `dotnet` 编译程序集到本地代码时，您需要指定一个目标框架。有关支持的目标框架列表，请参阅 [https://docs.microsoft.com/en-us/dotnet/standard/frameworks](https://docs.microsoft.com/en-us/dotnet/standard/frameworks)。您还需要指定一个
    **运行时标识符**（**RID**）。有关支持 RID 的列表，请参阅 [https://docs.microsoft.com/en-us/dotnet/core/rid-catalog](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog)。
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, native compilation against .NET 5.0 does have its issues.
    So, to keep things simple, we will demonstrate native compilation into a single
    executable against netcoreapp3.1 and win10-x64.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，针对 .NET 5.0 的本地编译确实存在一些问题。因此，为了简化问题，我们将演示将本地编译成单个可执行文件的过程，针对 netcoreapp3.1
    和 win10-x64。
- en: 'To demonstrate the compilation of Microsoft .NET Core applications into natively
    compiled single executables, we will write a simple demonstration application
    that traverses a directory structure and converts audio files from one format
    into another:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示将 Microsoft .NET Core 应用程序编译成本地编译的单个可执行文件，我们将编写一个简单的演示应用程序，它遍历目录结构并将音频文件从一种格式转换成另一种格式：
- en: Start a new console application and target .NET 6.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的控制台应用程序，并针对 .NET 6。
- en: Visit [https://ffmpeg.org/download.html](https://ffmpeg.org/download.html) and
    download `ffmpeg` for your operating system. Mine is Windows 10.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://ffmpeg.org/download.html](https://ffmpeg.org/download.html) 并下载适用于您操作系统的
    `ffmpeg`。我的系统是 Windows 10。
- en: 'On Windows 10, extract the `ffmpeg` files into the `C:\Tools\ffmpeg` folder.
    Add the following `using` statements to the top of the `Program.cs` file:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 10 上，将 `ffmpeg` 文件解压到 `C:\Tools\ffmpeg` 文件夹。将以下 `using` 语句添加到 `Program.cs`
    文件的顶部：
- en: '[PRE82]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We will be batch processing audio files in a folder hierarchy on our local
    systems. Here, the `using` statements listed will help us debug our code and perform
    I/O on the filesystem. Now, at the top of the `Program` class, add the following
    three fields:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在本地系统上的文件夹层次结构中批量处理音频文件。在这里，列出的 `using` 语句将帮助我们调试代码并在文件系统上执行 I/O。现在，在 `Program`
    类的顶部添加以下三个字段：
- en: '[PRE83]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `BaseDirectory` member holds the starting directory that will be processed.
    `sourceExtension` holds the extension of the file type, such as `.wav`, we are
    after converting to, while `destinationExtension` holds the extension, such as
    `.ogg`, of the file type we are after converting to. Update your `Main` method
    so that it looks as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BaseDirectory` 成员保存将要处理的起始目录。`sourceExtension` 保存文件类型的扩展名，例如 `.wav`，我们希望将其转换成，而
    `destinationExtension` 保存我们希望转换成的文件类型的扩展名，例如 `.ogg`。更新您的 `Main` 方法，使其看起来如下所示：'
- en: '[PRE84]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In our `Main` method, we have requested that the user enters the source directory,
    source extension, and destination extension. Then, we set out member variables
    and called the `BatchConvert` method. Let''s add our `BatchConvert` method:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Main` 方法中，我们要求用户输入源目录、源扩展名和目标扩展名。然后，我们设置成员变量并调用 `BatchConvert` 方法。让我们添加我们的
    `BatchConvert` 方法：
- en: '[PRE85]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `BatchConvert` method creates a new `DirectoryInfo` object called `directory`
    and then passes the `directory` object into the `ProcessFolder` method. Let''s
    add this method now:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BatchConvert`方法创建一个新的名为`directory`的`DirectoryInfo`对象，然后将`directory`对象传递给`ProcessFolder`方法。现在让我们添加这个方法：'
- en: '[PRE86]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `ProcessFolder` method outputs a message to the screen so that the user
    knows what folder is being processed. Then, it obtains an enumeration of the `FileInfo`
    and `DirectoryInfo` objects from the `directoryInfo` parameter. After this, it
    converts all the files in that folder that have the required source file extension.
    Once all the files have been processed, each of the `DirectoryInfo` objects is
    processed by calling the `ProcessFolder` method recursively. Finally, let''s add
    our `ConvertFile` method:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProcessFolder`方法将消息输出到屏幕，以便用户知道正在处理哪个文件夹。然后，它从`directoryInfo`参数中获取`FileInfo`和`DirectoryInfo`对象的枚举。之后，它将具有所需源文件扩展名的该文件夹中的所有文件进行转换。一旦所有文件都处理完毕，每个`DirectoryInfo`对象将通过递归调用`ProcessFolder`方法进行处理。最后，让我们添加我们的`ConvertFile`方法：'
- en: '[PRE87]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Our `ConvertFile` method takes a `FileInfo` parameter. This parameter contains
    the file that is to undergo conversion. The remaining code will be added to this
    `ConvertFile` method. Add the following three variables:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`ConvertFile`方法接受一个`FileInfo`参数。该参数包含要转换的文件。剩余的代码将添加到这个`ConvertFile`方法中。添加以下三个变量：
- en: '[PRE88]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `timeout` variable is set to 10 seconds. This gives the process 10 seconds
    to process each file. The `source` variable contains the full name of the file
    to be converted, while the `destination` variable contains the full path of the
    newly converted file. Now, add the check to see if the converted file exists:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timeout`变量设置为10秒。这给每个文件的处理提供了10秒的时间。`source`变量包含要转换的文件的完整名称，而`destination`变量包含新转换文件的完整路径。现在，添加检查以查看转换文件是否存在：'
- en: '[PRE89]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If the `destination` file exists, then the conversion has already taken place,
    so we do not need to process the file. So, let''s output a message to the user
    to inform them that the file is unprocessed, and then return from the method.
    Let''s add the code to perform the conversion:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`destination`文件已存在，则转换已经发生，因此我们不需要处理该文件。所以，让我们向用户输出一条消息，通知他们该文件未处理，然后从方法中返回。让我们添加执行转换的代码：
- en: '[PRE90]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, we output a message to the window informing the user of the file being
    processed. Then, we instantiate a new process that executes `ffmpeg.exe` and converts
    an audio file from one format into another, as specified by the user. The converted
    file is then saved in the same directory as the original file.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们向窗口输出一条消息，通知用户正在处理的文件。然后，我们实例化一个新的进程，执行`ffmpeg.exe`并将音频文件从一种格式转换为用户指定的另一种格式。转换后的文件随后被保存在原始文件相同的目录中。
- en: With that, we have completed our sample project. So, let's see it running. On
    an external hard disk, I have some Ghosthack audio samples that I own. The files
    are in `.wav` file format. However, they need to be transformed into `.ogg` files
    to be used in an Android program that I use. You can use your own audio file or
    music folders.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们就完成了我们的示例项目。那么，让我们看看它运行的情况。在一个外置硬盘上，我有一些我拥有的Ghosthack音频样本。这些文件是`.wav`格式。但是，它们需要转换成`.ogg`文件，以便用于我使用的Android程序。你可以使用你自己的音频文件或音乐文件夹。
- en: Note
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t have any audio files to hand to test this small program, you
    can download some royalty-free sounds from [https://www.bensound.com](https://www.bensound.com).
    You can check the following page for links to various public music domains: [https://www.lifewire.com/public-domain-music-3482603](https://www.lifewire.com/public-domain-music-3482603).'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有音频文件来测试这个小程序，你可以从[https://www.bensound.com](https://www.bensound.com)下载一些免版税的声音。你可以查看以下页面以获取链接到各种公共音乐域：[https://www.lifewire.com/public-domain-music-3482603](https://www.lifewire.com/public-domain-music-3482603)。
- en: 'Fill out the questions and press *Enter*:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写问题并按*Enter*键：
- en: '![Figure 1.12 – Our file converter showing the directory and file conversion
    formats'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 – 我们的文件转换器显示目录和文件转换格式'
- en: '](img/B16617_Figure_1.12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.12.jpg)'
- en: Figure 1.12 – Our file converter showing the directory and file conversion formats
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – 我们的文件转换器显示目录和文件转换格式
- en: The program will now process all files and folders under the specified parent
    folder and process them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在将处理指定父文件夹下的所有文件和文件夹。
- en: 'The program is working as expected in its MSIL form. However, we can see the
    delay in performing the file conversions. Let''s compile our file converter into
    a single native executable, and then see if it is visibly any faster:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以MSIL形式运行正常。然而，我们可以看到文件转换过程中的延迟。让我们将我们的文件转换器编译成一个单一的本地可执行文件，然后看看它是否明显更快：
- en: 'Open the Visual Studio Developer Command Prompt as an administrator and navigate
    to the folder that contains your solution and project file. When publishing the
    file, it is worth noting that the `TargetFramework` property of the project should
    also be updated to netcoreapp3.1; otherwise, this may not work – that is, if it
    is set to `net5.0`. Type the following command and then press *Enter*:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员身份打开Visual Studio开发者命令提示符，并导航到包含您的解决方案和项目文件的文件夹。在发布文件时，请注意，项目中的`TargetFramework`属性也应更新为netcoreapp3.1；否则，这可能不起作用——也就是说，如果它设置为`net5.0`。输入以下命令，然后按*Enter*：
- en: '[PRE91]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When the command has finished running, your command window should look as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命令运行完成后，您的命令窗口应如下所示：
- en: '![Figure 1.13 – The Developer Command Prompt in administrative mode showing
    the native compilation output'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 – 以管理员模式显示原生编译输出的开发者命令提示符'
- en: '](img/B16617_Figure_1.13.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.13.jpg)'
- en: Figure 1.13 – The Developer Command Prompt in administrative mode showing the
    native compilation output
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 以管理员模式显示原生编译输出的开发者命令提示符
- en: 'If you navigate to the publish directory, you will see the following output:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您导航到发布目录，您将看到以下输出：
- en: '![Figure 1.14 – Windows Explorer displaying the output files resulting from
    native compilation'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14 – Windows资源管理器显示原生编译产生的输出文件'
- en: '](img/B16617_Figure_1.14.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_1.14.jpg)'
- en: Figure 1.14 – Windows Explorer displaying the output files resulting from native
    compilation
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – Windows资源管理器显示原生编译产生的输出文件
- en: Run the `CH01_NativeCompilation.exe` file. You will see that `.wav` files are
    processed into `.ogg` files much quicker.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`CH01_NativeCompilation.exe`文件。您将看到`.wav`文件被快速转换成`.ogg`文件。
- en: In this section, we learned how to write a console app. We compile the console
    app to MSIL and then compile the console app into a single native executable file.
    Visually, from the user's perspective, the file processes batch audio files much
    quicker in native form than in MSIL form.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何编写控制台应用程序。我们将控制台应用程序编译成MSIL，然后将控制台应用程序编译成一个单一的本地可执行文件。从用户的角度来看，文件以本地形式处理批处理音频文件比以MSIL形式快得多。
- en: Now, let's learn how to improve Windows Store applications.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何提高Windows Store应用程序的性能。
- en: Improving Windows Store performance
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升Windows Store性能
- en: 'Here are some basic tips for improving the performance of Windows Store applications:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提高Windows Store应用程序性能的基本技巧：
- en: '**Perform the Microsoft Store app performance assessment**: For information
    on how to do this, visit [https://docs.microsoft.com/en-us/windows-hardware/test/assessments/microsoft-store-app-performance](https://docs.microsoft.com/en-us/windows-hardware/test/assessments/microsoft-store-app-performance).'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行Microsoft Store应用程序性能评估**：有关如何执行此操作的更多信息，请访问[https://docs.microsoft.com/en-us/windows-hardware/test/assessments/microsoft-store-app-performance](https://docs.microsoft.com/en-us/windows-hardware/test/assessments/microsoft-store-app-performance)。'
- en: '**Understand the Microsoft Store app performance assessment''s Results**: To
    help you understand the results of the Windows Store App Performance Assessment,
    visit [https://docs.microsoft.com/en-us/windows-hardware/test/assessments/results-for-the-microsoft-store-app-performance-assessment](https://docs.microsoft.com/en-us/windows-hardware/test/assessments/results-for-the-microsoft-store-app-performance-assessment)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解Microsoft Store应用程序性能评估的结果**：为了帮助您理解Windows Store应用程序性能评估的结果，请访问[https://docs.microsoft.com/en-us/windows-hardware/test/assessments/results-for-the-microsoft-store-app-performance-assessment](https://docs.microsoft.com/en-us/windows-hardware/test/assessments/results-for-the-microsoft-store-app-performance-assessment)'
- en: '**Address the issues highlighted in the Microsoft Store app performance assessment
    results**: The main areas to focus on are any that have issues highlighted in
    dark purple, followed by issues marked in medium purple. The primary metrics will
    be on Launch:Warm, Launch:Cold, Post Launch, Idle, and Suspend. You also need
    to pay attention to processor and storage usage, as well as processor and storage
    I/O delays, registry flushes, time accounting, missing symbols, long-running **Deferred
    Procedure Calls** (**DPCs**), and **Interrupt Service Routines** (**ISRs**) that
    can be perceived by the end user as performance issues.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决Microsoft Store应用程序性能评估结果中突出的问题**：主要关注区域是任何在深紫色中突出显示的问题，其次是中等紫色标记的问题。主要指标将是启动：Warm、启动：Cold、启动后、空闲和挂起。您还需要注意处理器和存储使用情况，以及处理器和存储I/O延迟、注册表刷新、时间会计、缺失符号、长时间运行的**延迟过程调用**（**DPCs**）和**中断服务例程**（**ISRs**），这些可能会被最终用户感知为性能问题。'
- en: In the next section, we'll learn how to improve performance with ASP.NET.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用ASP.NET提高性能。
- en: Improving ASP.NET performance
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高ASP.NET性能
- en: 'Here are some basic tips for improving the performance of web applications
    and APIs:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提高Web应用程序和API性能的基本技巧：
- en: '**Perform baseline measurements**: Before making changes to the performance
    of your web application or API, take a baseline reading of your program''s performance.
    This way, you can measure any adjustments to see if they improve performance or
    slow things down.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行基准测量**：在更改您的Web应用程序或API的性能之前，先对程序的性能进行基准测试。这样，您可以测量任何调整，看看它们是否提高了性能或减慢了速度。'
- en: '**Begin by optimizing the code with the largest impact**: When you have completed
    your baseline measurements, start performance tuning on the piece of code that
    is the least performant and that has the biggest impact on your program''s performance.
    This will provide you with your biggest win.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从优化影响最大的代码开始**：当您完成基准测量后，开始对性能最差且对程序性能影响最大的代码片段进行性能调整。这将为您带来最大的收益。'
- en: '**Enable HTTP compression**: To reduce the size of transmitted files over HTTP/HTTPS
    and improve network performance, enable compression. There are two types of compression.
    GZIP compression has been around for many years and is the de facto compression
    mechanism; it can reduce a file''s size by one-third. An alternative compression
    mechanism is Brotli. Most major browsers have had support for this compression
    mechanism since 2016/2017.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用HTTP压缩**：为了减少通过HTTP/HTTPS传输的文件大小并提高网络性能，请启用压缩。有两种类型的压缩。GZIP压缩已经存在很多年了，是事实上的压缩机制；它可以减少文件大小的三分之一。另一种压缩机制是Brotli。自2016/2017年以来，大多数主要浏览器都支持这种压缩机制。'
- en: '**Reduce TCP/IP connection overheads**: Reducing HTTP requests seriously improves
    HTTP communication performance. Each request uses network and hardware resources.
    When a hardware and software-specific number of connections is established, performance
    will start to show signs of degrading. This can be mitigated by reducing the number
    of HTTP requests.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少TCP/IP连接开销**：减少HTTP请求严重提高了HTTP通信性能。每个请求都使用网络和硬件资源。当建立了特定于硬件和软件的连接数时，性能将开始显示出下降的迹象。这可以通过减少HTTP请求的数量来缓解。'
- en: '**Use HTTP/2 over SSL**: HTTP/2 over SSL provides various performance improvements
    of using HTTP. Multiplexed streams provide bi-directional sequences of text format
    frames. Server push enables a server to push cacheable data to the client in anticipation
    that the client may use it. Binary protocols have a lower overhead when it comes
    to parsing data and they are less prone to errors. Binary protocols offer more
    security and have better network utilization There are many more optimizations
    that you gain when you switch to HTTP/2 over SSL.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用SSL上的HTTP/2**：HTTP/2 over SSL提供了使用HTTP的各种性能改进。多路复用流提供了双向的文本格式帧序列。服务器推送允许服务器在预期客户端可能会使用它的情况下，将可缓存的推送到客户端。二进制协议在解析数据时具有更低的开销，并且它们更不容易出错。二进制协议提供了更多的安全性，并且有更好的网络利用率。当您切换到SSL上的HTTP/2时，您还可以获得许多其他优化。'
- en: '**Employ minification**: Minification is the process of eliminating whitespace
    and comments in an HTML, CSS, or JavaScript web file. By making the size of the
    file smaller and by enabling compression, you can seriously speed up the network
    transmission of files, especially over poor Wi-Fi.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用最小化技术**：最小化是消除HTML、CSS或JavaScript网页文件中的空白和注释的过程。通过减小文件大小并启用压缩，您可以大大加快文件的网络传输速度，尤其是在差的Wi-Fi环境下。'
- en: '**Place CSS in the head so that it loads first**: To efficiently render a web
    page, it is best to load the complete CSS before rendering to prevent reflows.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将CSS放在头部以便首先加载**：为了高效渲染网页，最好在渲染之前加载完整的CSS，以防止回流。'
- en: '`body` tag. For heavy framework-based applications, bootstrapping will be beneficial
    as only the JavaScript that is needed is loaded. An alternative is isomorphic
    JavaScript for rendering pages on both the client and the server. Isomorphic applications
    improve SEO, performance, and maintainability.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`标签。对于基于重框架的应用程序，引导将是有益的，因为只需加载所需的JavaScript。另一种选择是在客户端和服务器上渲染页面的同构JavaScript。同构应用程序可以提高SEO、性能和可维护性。'
- en: '**Reduce image size**: Images can vary greatly in size. Reduce the size of
    the images that are used on a page. When used with minification and compression,
    this technique can help fancy-looking web pages load fast.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少图像大小**：图像的大小可能相差很大。减少页面上使用的图像的大小。当与最小化和压缩一起使用时，这种技术可以帮助看起来华丽的网页快速加载。'
- en: You can find out more about other techniques for improving ASP.NET performance
    in the *Further reading* section. Now, let's summarize what we have learned in
    this chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*进一步阅读*部分了解更多关于提高ASP.NET性能的其他技术。现在，让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of this chapter, you downloaded the latest source for the C# programming
    language. Then, you restored it, built it, and ran various tests. After that,
    you built a Hello, World! program that demonstrated C# 9.0 features.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，你下载了C#编程语言的最新源代码。然后，你恢复了它，构建了它，并运行了各种测试。之后，你构建了一个演示C# 9.0特性的Hello, World!程序。
- en: Then, you learned what's new in .NET 5\. This section covered topics on garbage
    collection, JIT compilation, text-based processing, threading and asynchronous
    operations, collections, LINQ, networking, and Blazor. We also covered the new
    performance-based APIs and analyzers. From what was covered, you now have a high-level
    appreciation of the many performance improvements made by Microsoft and third
    parties to the new version of the .NET programming language. These performance
    improvements are a solid reason to move to .NET 5\. But another compelling reason
    is also the move to .NET for true cross-platform development from a single code
    base.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了.NET 5中的新内容。本节涵盖了垃圾回收、即时编译、基于文本的处理、线程和异步操作、集合、LINQ、网络和Blazor等主题。我们还介绍了基于性能的新API和分析器。从所涵盖的内容来看，你现在对微软和第三方为.NET编程语言新版本所做的众多性能改进有了高层次的认识。这些性能改进是迁移到.NET
    5的坚实理由。但另一个令人信服的理由也是从单一代码库迁移到.NET进行真正的跨平台开发。
- en: After reviewing the performance improvements and additions to .NET 5, we looked
    at the new C#10.0 features. You learned how to write a program with just one line
    of code using top-level statements. Then, you learned how to implement init-only
    properties, records, new pattern-matching features, new expressions with targeted
    types, and covariant returns. From reviewing the new additions to the C# 9.0 language,
    you learned how to compile and run code in MSIL, and then compile and run native
    code in a single executable file. Visually, the end user experience was shown
    to be better when using the native binary over the MSIL assembly. For the example,
    we used a simple audio file format converter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾.NET 5的性能改进和新增功能后，我们看到了新的C#10.0特性。你学习了如何使用顶层语句仅用一行代码编写程序。然后，你学习了如何实现只读属性、记录、新的模式匹配功能、具有目标类型的表达式和协变返回。通过回顾C#
    9.0语言的新增功能，你学习了如何在MSIL中编译和运行代码，然后在一个可执行文件中编译和运行原生代码。从视觉上看，当使用原生二进制而不是MSIL汇编时，最终用户体验更好。对于示例，我们使用了一个简单的音频文件格式转换器。
- en: You were then provided with some guidance on how to improve Windows Store app
    performance. Links to the official Microsoft documentation were presented to you
    to help you generate performance reports, along with how to understand the results
    of the performance assessment. This guidance also highlighted the main metrics
    to pay attention to. Finally, we considered some ways in which you can improve
    the performance of your ASP.NET websites and APIs. In the *Further reading* section,
    you will find a link to the official Microsoft ASP.NET documentation. This documentation
    will help you architect and build quality websites.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经获得了一些关于如何提高 Windows Store 应用程序性能的指导。向您展示了官方微软文档的链接，以帮助您生成性能报告，以及如何理解性能评估的结果。此指导还突出了需要注意的主要指标。最后，我们考虑了一些可以提高您的
    ASP.NET 网站和 API 性能的方法。在 *进一步阅读* 部分中，您可以找到指向官方微软 ASP.NET 文档的链接。此文档将帮助您设计和构建高质量的网站。
- en: Furthermore, in the *Further reading* section, you will find some links to documentation
    and the GitHub repository for .NET MAUI, which is due to be released in 2021 in
    concert with .NET 6\. This user interface technology is an evolution of Xamarin.Forms
    with evolutionary changes based on customer research. It does look rather promising.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 *进一步阅读* 部分中，您将找到一些指向文档和 .NET MAUI 的 GitHub 仓库的链接，该仓库预计将与 .NET 6 一起在 2021
    年发布。这种用户界面技术是 Xamarin.Forms 的发展，基于客户研究进行了进化性改变。它看起来相当有前景。
- en: In the next chapter, we will be looking at .NET interoperability. But before
    that, work through this chapter's questions to see how well everything has sunk
    in.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 .NET 互操作性。但在那之前，请完成本章的问题，看看一切是否已经深入人心。
- en: Questions and exercises
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和练习
- en: 'Answer the following questions regarding this chapter:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 回答本章的相关问题：
- en: What areas of .NET are being improved by .NET 6?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 6 正在改进 .NET 的哪些领域？
- en: What is new to C# 10.0?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 10.0 有哪些新特性？
- en: What tools are available for native compilation in .NET?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于 .NET 本地编译的工具有哪些？
- en: How can you improve the Windows Store app's performance?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何提高 Windows Store 应用程序的性能？
- en: How can you speed up ASP.NET?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何加速 ASP.NET？
- en: Investigate the state of .NET MAUI, the future of frontend desktop and mobile
    development that is still undergoing development.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查 .NET MAUI 的状态，这是仍在开发中的前端桌面和移动开发的未来。
- en: Write some console applications and practice using the new features of .NET
    6 and C# 10.0.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一些控制台应用程序，并练习使用 .NET 6 和 C# 10.0 的新特性。
- en: Use Benchmark.NET to benchmark one of your small applications, and then upgrade
    it to use .NET 6 and C# 10.0\. Measure its performance without making any changes
    if possible, and then measure its performance again. See if you notice any performance
    improvements by simply upgrading to C# 10.0 and .NET 6.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Benchmark.NET 对您的小型应用程序进行基准测试，然后升级到使用 .NET 6 和 C# 10.0。如果可能的话，在不做任何更改的情况下测量其性能，然后再次测量其性能。看看您是否通过仅升级到
    C# 10.0 和 .NET 6 就注意到了性能改进。
- en: Note
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The answers to questions 4 and 5 can be found in the external reference sources
    provided in their respective sections.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题 4 和 5 的答案可以在各自章节提供的外部参考源中找到。
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: 'Download .NET 6: [https://dotnet.microsoft.com/download/dotnet/6.0](https://dotnet.microsoft.com/download/dotnet/6.0).'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 .NET 6：[https://dotnet.microsoft.com/download/dotnet/6.0](https://dotnet.microsoft.com/download/dotnet/6.0).
- en: 'Download Visual Studio Preview: [https://visualstudio.microsoft.com/vs/preview/](https://visualstudio.microsoft.com/vs/preview/).'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 Visual Studio 预览版：[https://visualstudio.microsoft.com/vs/preview/](https://visualstudio.microsoft.com/vs/preview/).
- en: '*Introducing the .NET multi-platform app UI*: [https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/](https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/).'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍 .NET 多平台应用 UI*：[https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/](https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/).'
- en: '.NET MAUI GitHub page: [https://github.com/dotnet/maui](https://github.com/dotnet/maui).'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI GitHub 页面：[https://github.com/dotnet/maui](https://github.com/dotnet/maui).
- en: 'Learn from Microsoft how to build quality Windows 10 apps that reflect your
    brand: [https://docs.microsoft.com/en-us/windows-hardware/get-started/](https://docs.microsoft.com/en-us/windows-hardware/get-started/).'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从微软学习如何构建反映您品牌的优质 Windows 10 应用程序：[https://docs.microsoft.com/en-us/windows-hardware/get-started/](https://docs.microsoft.com/en-us/windows-hardware/get-started/).
- en: 'Learn from Microsoft how to architect and build quality websites using Microsoft
    technology: https://dotnet.microsoft.com/apps/aspnet.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从微软学习如何使用微软技术设计和构建高质量网站：https://dotnet.microsoft.com/apps/aspnet.
- en: 'C#9.0 early review: [https://medium.com/dev-genius/c-9-early-review-5bcd88296c54#:~:text=Relax%20ordering%20of%20ref%20and%20partial%20modifiers%20Currently%2C,is%20a%20ref%20struct%2C%20ref%20must%20appear%20](https://medium.com/dev-genius/c-9-early-review-5bcd88296c54#:~:text=Relax%20ordering%20of%20ref%20and%20partial%20modifiers%20Currently%2C,is%20a%20ref%20struct%2C%20ref%20must%20appear%20).'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#9.0早期回顾：[https://medium.com/dev-genius/c-9-early-review-5bcd88296c54#:~:text=Relax%20ordering%20of%20ref%20and%20partial%20modifiers%20Currently%2C,is%20a%20ref%20struct%2C%20ref%20must%20appear%20](https://medium.com/dev-genius/c-9-early-review-5bcd88296c54#:~:text=Relax%20ordering%20of%20ref%20and%20partial%20modifiers%20Currently%2C,is%20a%20ref%20struct%2C%20ref%20must%20appear%20).
- en: '*File I/O Improvements in .NET 6*: [https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/](https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/).'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET 6中的文件I/O改进*: [https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/](https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/).'
