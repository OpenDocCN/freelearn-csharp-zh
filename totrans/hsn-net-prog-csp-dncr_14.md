# 传输层 - TCP和UDP

在前面的章节中，我们研究了不同应用层协议的交互以及如何在.NET Core中编程这些交互。在本章中，我们将更接近硬件，开始研究传输层协议，即**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。我们将查看每个协议实现的基于连接和无连接通信模式，并查看每种方法固有的优点和缺点。此外，我们将研究如何编写和交互实现每个协议的软件客户端，并使用它来扩展我们的网络应用程序的功能，添加自定义行为。最后，我们将查看传输层协议的一些高级功能，例如多播，以同时与多个主机交互，从而提高我们网络软件的性能。

本章将涵盖以下主题：

+   哪些责任被委派给了传输层，以及这个层如何与应用层、HTTP/SMTP/FTP有意义的区别

+   基于连接和无连接协议之间的区别以及它们试图解决的问题

+   如何初始化TCP连接以及发送和接收TCP请求

+   如何在C#中建立并利用UDP通信

+   如何利用多播来提高我们的TCP客户端的性能

# 技术要求

我们将在这里使用书中GitHub仓库中可用的示例应用程序：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2011](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2011).

查看以下视频以查看代码的实际运行情况：[http://bit.ly/2HY61eo](http://bit.ly/2HY61eo)

我们还将继续使用我们在第8章中使用的工具，即[第8章](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml)，*套接字和端口*。具体来说，如果你还没有安装，我建议从以下链接安装Postman：[https://www.getpostman.com/apps](https://www.getpostman.com/apps) 或者你可以安装Insomnia REST客户端，可以在以下链接找到：[https://insomnia.rest/](https://insomnia.rest/)

# 传输层

当我们开始检查传输层的复杂性时，记住传输层协议与应用层协议之间最基本的一个区别是很重要的；具体来说，就是每一层所关心的交互类型。应用层的协议关注的是业务对象之间的通信。它们应该只处理你应用程序领域实体的高级表示，以及这些实体如何通过你的系统移动。

同时，在传输层协议中，关注的是**原子网络数据包**，这些数据包用于传输与上下文无关的数据包，以及建立和协商连接。

# 传输层的目标

在我们迄今为止所检查的所有应用层协议中，我们都能对所传输的网络请求做出一些宽泛的假设。我们只是假设，只要我们的**统一资源标识符**（**URI**）是正确的，并且远程主机是活跃的，我们就能与目标系统建立**连接**。此外，我们可以假设所建立的连接是**可靠的**，并且我们发送的任何请求都将完整地以可由远程主机监听应用程序读取的方式传递。我们可以舒适地假设，如果在传输过程中发生错误，我们会获得足够的信息来识别错误的性质并尝试**纠正**它。

让我们回顾一下，这些假设是否也可以应用于传输层。

# 建立连接

在传输层，我们不能对现有连接做出假设，因为这是连接最初建立的层。传输层协议是暴露本地机器上的特定端口并协商将数据包传递到远程机器指定端口的协议。如果该连接需要在交互期间保持会话，那么负责维护该会话状态的是传输层协议（我们将在探讨基于连接的通信时了解更多关于这一点）。

# 确保可靠性

当涉及到可靠性，即网络数据包的稳定和一致交付以及响应数据包的接受时，这是传输层的职责。如果一个会话由于两个主机之间通信链路的断裂而中断，传输层协议负责尝试重新建立连接并基于其先前状态恢复网络会话。保证数据包成功交付的传输协议必须承担与远程主机传输层通信的责任，以验证应用层数据是否成功接收。

这对于将开放连接视为串行数据流的软件层尤为重要。 incoming data being processed in order 的概念要求它可以按顺序读取。这意味着传输层必须有一些机制来确保网络数据包的可靠、顺序交付。

# 错误纠正

这种可靠性也是传输层另一个职责的关键：错误纠正。这包括能够修复由于交互中网络层的复杂或中断引起的数据接收差异。而且，不要误解，网络数据包内容受到干扰、操纵或丢失的机会有很多。传输层负责减轻这些可能性，并在数据损坏的情况下重新请求新的数据包。这种数据校正通常通过简单的`校验和`值来完成，它可以提供一个可靠的指标，表明正在对传输中的数据进行更改。

错误处理也应该存在，以确保数据包的可靠顺序。因为物理网络基础设施可以，并且经常这样做，将来自单个主机的多个请求通过多个可用的网络连接，以及通过多个不同的交换机路由到另一个主机，因此，在流中发送较晚的数据包先于较早发送的数据包到达并不罕见。传输层必须有一种方法来识别这种情况何时发生，并且能够重新请求丢失的数据包或重新排列接收到的数据包以恢复其正确的顺序。

# 管理流量

起初可能并不明显，但当我们谈论在给定的机器上可用的数千个端口用于监听时，这些数千个端口仅存在于虚拟上。显然，你的PC主板并没有插入65,536根线。这些端口只是你的（通常只有一个）网络适配器将流量路由到当前正在操作系统上运行的适当进程的一种方式。所有传入和传出的网络流量都必须通过这个单一的网络适配器。

虽然网络层软件负责管理直接流量控制，但它通常只通过为传输层提供在短暂的上时间段内访问物理连接的方式来这样做。传输层软件的职责是管理一个待处理的传入数据队列，以及一个传出请求队列，并在资源可用时将它们交付给网络层。这种使用有限、间歇性可用的资源的方法，如果做得好，可以大幅提升性能，如果实施不当，则可能成为性能瓶颈。

# 数据分段

正如我在[第3章](84e54d31-1726-477b-b753-4408a3ee6286.xhtml)“通信协议”中讨论这个主题时提到的，用于在应用层封装数据的庞大、连续的对象不适合在网络中传输。如果你试图在传输20 MB文件或13 GB文件期间阻塞你的网络适配器，那么对机器上任何其他依赖网络的软件性能的影响将是绝对不可接受的。这样做会阻塞任何传入或传出的请求，时间过长。

虽然应用层协议可以在所有请求中发送大量有效载荷并假设它们会被正确交付，但传输层的数据包却不能这么说。在传输层和网络适配器之间没有其他中介，因此传输层的责任是将大型请求有效载荷分解成更小、离散的网络数据包，以便在网络层传输。这意味着传输层协议还承担了应用层有效载荷分解数据包的附加责任，以便接收机器能够重建这些数据包，无论交付顺序如何，通常通过数据包头部完成。

在像C#这样的高级语言中，这通常不是你自己实现的内容，但了解幕后发生的事情将使得理解诸如数据包嗅探和网络跟踪等概念变得更加容易。

# 传输层协议的类别

尽管我们刚刚讨论了传输层协议可能承担的许多责任，但并非每个传输层的协议都实现了这些功能中的每一个。由于了解给定实现中可用的可选功能很重要，因此标准组织根据它们实现的特性定义了一个连接模式协议的分类系统。根据这个分类方案，存在五种不同的连接模式（或传输层）协议类别，每个类别实现传输协议可能实现的服务列表的不同组合。

定义传输协议不同实现类的分类方案实际上是标准组织的一项联合努力。**国际标准化组织**（**ISO**）和**国际电信联盟**（**ITU**）共同发布了X.224建议，用于此特定目的。

分类列表从零索引，从类`0`到类`4`，它们的描述如下。

# 简单类

这被描述为提供最简单的传输连接类型，具有足够的数据分段。标准中明确指出，它仅适用于具有可接受残余错误率和可接受信号错误率的网络连接。

# 基本恢复类

属于类 `1` 的协议被指定提供具有最小开销的基本传输连接。然而，将类 `1` 与类 `0` 区分开来的是，类 `1` 协议预计可以从信号错误中恢复，或立即可检测到的错误，例如网络断开或网络重置。此类协议适用于具有可接受残余错误率的网络，但信号错误率不可接受。

# 类 `2` – 复用类

类 `2` 协议的标志性特征是它们能够在单个网络连接上复用多个传输连接。它旨在与类 `0` 协议一样，在极其可靠的网络环境中工作。由于可能利用单个传输层协议上的多个网络连接，此类分类中的协议最终可能会利用显式的流量控制来优化网络层资源的利用。然而，这种显式的流量控制并不是类 `2` 协议的保证属性。实际上，在不需要复用的情况下可能会避免使用它，因为不显式管理流量控制可以减少传输中的数据包开销。

# 类 `3` – 错误恢复和复用类

复用类本质上是由类 `1` 和 `2` 组合而成的。类 `3` 的协议将类 `2` 复用功能（或数据包开销）的性能优势引入到具有足够错误恢复能力的协议中，适用于信号错误率较低且类 `1` 可能更受欢迎的网络。

# 类 `4` – 检测错误和恢复类

类 `4` 协议是所有协议中最稳健的。它们明确指出，适用于具有不可接受的残余错误率和信号错误率（即，基本上是任何具有高干扰或服务中断概率的大规模分布式网络）的网络。鉴于类 `4` 协议适用于在如此不可靠的网络中使用，因此预期类 `4` 协议能够检测并从网络错误中恢复。类 `4` 协议应提供恢复的错误包括但不限于以下内容：

+   数据包丢失

+   数据流中数据包的顺序错误

+   数据包重复

+   数据包损坏

类 `4` 的协议还预期提供对网络故障的最高程度弹性，以及通过改进的复用和分段提高的吞吐量。不用说，这也是在每次网络事务中引入每数据包开销最高的传输层协议类别。

有趣的是，协议的分类仅决定了你应该期望该协议实现的最低服务集。这并不排除该协议实现比其分类指定的更广泛的服务集。TCP 就是这种情况，它实际上提供了一些额外的服务，这些服务可能在网络堆栈更高层的软件中提供更严格的实现。

类 `4` 捕获了 TCP/IP，这被广泛认为是目前广泛使用的最稳健（或者至少是最复杂/复杂的）传输层协议，以及 UDP，它在广泛支持和采用方面是 TCP 的无连接对等。这些是你在使用 C# 工作时将直接交互的传输层协议类别。为此，让我们来看看 TCP 和 UDP 之间可能的最大区别：它们的基于连接和无连接通信模式。通过这样做，我们将对何时以及如何利用每个协议有一个更好的了解。

# 基于连接和无连接的通信

在 C# 中，我们将使用两种主要的传输层协议。第一个是 TCP。由于它在基于互联网的网络软件中的普遍使用以及与**互联网协议**（**IP**）的紧密耦合，通常被称为 TCP/IP，TCP 是我们迄今为止查看的所有应用层协议背后的传输层协议。我们将查看的第二种协议是 UDP。它作为 TCP 在传输层实现方面的替代方法，旨在在更严格的用例中提供更好的性能。

然而，这两种协议的主要区别在于，TCP 在所谓的**基于连接的通信模式**下运行，而 UDP 在所谓的**无连接通信模式**下运行。那么，这些通信模式究竟是什么？

# 基于连接的通信

初看之下，基于连接的通信可能看起来很明显。从其名称来看，你可能会得出结论，它只是利用两个主机之间连接的任何通信。但当我们说“连接”时，我们究竟指的是什么？它不能仅仅是两个主机之间的一些物理路径。毕竟，根据那个定义，两个主机如果不能以某种方式连接，它们如何进行通信？如果不在连接上，数据如何在两台机器之间传输？

当你考虑到无连接通信是一种有效的通信模式时，这种定义的不足之处变得更加明显。考虑到这一点，很明显，在这个上下文中，“连接”必须指的不仅仅是两个主机之间用于数据传输的简单通道。那么，究竟什么是连接？基于连接的通信模式是如何利用它的？

# 建立会话的连接

为了清晰和易于理解，我认为我们将连接视为一个会话会很有帮助。在面向连接的协议中，在执行任何有意义的操作之前，必须在两个主机之间建立会话。这个会话必须通过两个主机之间的握手来协商，并且应该协调待传输数据传输的性质。会话允许两个主机确定在请求的生命周期内，两台机器之间是否需要发生任何协调，以确保可靠地完成请求。

一旦建立了会话，就可以实现基于连接的通信机制的好处。这包括保证数据按顺序交付，以及可靠地重传丢失的数据包。这是因为会话上下文为两台机器提供了一个交互机制，允许它们在消息被发送和接收时进行通信。这种共享的、活跃的上下文对于我们理解基于连接的协议非常重要，所以让我们看看底层网络层是如何提供会话上下文的。

# 电路交换与分组交换连接

为想要建立连接的两个主机提供会话有两种方式。第一种是通过主机之间的直接硬件电路链路来建立会话。这就是所谓的**电路交换连接**。数据不需要在头部应用路由信息，因为它在两个设备之间的闭合电路中传输。这种物理电路连接是公共电话网络建立连接的方式。如果你曾经见过老照片中电话操作员使用四分之一英寸的电缆连接巨大电路板上的两个不同端口，你就已经看到了这种精确的路由机制在起作用（尽管是一种非常原始的实现）。

在两个主机之间建立专有的、直接的物理连接有很多好处。它保证了所有数据包将在恒定的时间内到达，因为没有中间路由器和交换机需要解析数据包的寻址信息，或者等待数据通道的空闲。它还保证了数据包的顺序，因为每个数据包将正好在下一个传输的数据包之前通过相同的通道传输。

当然，这种基于连接的通信方式的缺点是，其实施成本非常高。必须在网络上的每个可能交点处有一个机制，以建立任何两个其他连接之间的专用电路，而不会干扰可能通过该交点的其他连接。另外，在连接建立和关闭时，管理连接和断开特定电路所需的机械交换成本也非常高。因此，这类物理网络在几十年来都没有在计算网络中得到广泛应用。

另一种方法是所谓的**分组交换连接**。这些连接是通过在路由设备上使用硬件交换机和部署的软件来虚拟化电路交换连接的行为来建立的。在连接模式下，路由器和交换机设置一个内存中的电路，管理所有针对目标位置的入站请求队列。这些设备解析每个入站数据包的寻址信息，并相应地将其传递到队列中，然后一旦物理资源可用，就按顺序从队列中转发消息。通过这样做，保持了物理电路交换连接的行为预期。因此，对于任何编写以利用基于连接的通信方案的软件，电路交换连接和分组交换连接之间没有功能上的区别。

通过这种虚拟化，物理层面上实现电路交换连接功能的开销得到了缓解。当然，通过减轻电路交换设置的物理成本，我们在性能成本上做出了补偿。在分组交换连接中，每个连接都会增加额外的开销，因为每个数据包必须由两个主机之间网络路径上的每个交换机进行解析。此外，除非给定网络交换机上没有其他流量，否则每次将与此连接相关的数据包放入队列等待物理资源可用时，分组交换连接无疑将出现停机时间。然而，由于这些操作大多在固件级别实现，任何给定连接的总时间成本实际上相当小。这种分组交换网络的模型几乎描述了所有现代**广域网**（**WAN**），包括互联网。

# 作为面向连接的协议，TCP

建立连接是TCP实现为利用它的应用层软件提供的重要功能之一。当TCP层将请求分解成数据包并应用其头部信息时，它是基于假设这些数据包将通过分组交换网络发送的。

这意味着网络路径上的交换机和路由器必须为两个主机之间的每个有效载荷预先配置一个虚拟电路。这种确定性是通过两个主机之间多步骤握手来提供的。握手的具体细节稍微复杂一些，但可以简化为过程中每一步的三个基本事务：

1.  **SYN**：这代表**同步**，是客户端发送给服务器的请求，表明希望建立连接。同步发生是因为客户端生成一个随机整数，*n*，并将其作为序列号传输在SYN请求中，服务器使用这个序列号来确认接收到了适当的消息。

1.  **SYN-ACK**：这代表**同步和确认**，是服务器对初始SYN请求的响应。为了确认请求是以发送时的相同状态接收的，服务器增加并返回它从客户端接收到的随机同步整数，*n+1*，作为确认消息。它还发送它自己的随机整数，*m*，作为序列号。

1.  **ACK**：在这个时候，客户端确认其同步请求已被正确发送和接收，并通过发送一个设置序列号为从服务器接收到的确认值，*n+1*，然后增加并返回服务器的序列号作为它自己的确认值，*m+1*，来确认服务器的同步请求也被正确接收。

一旦这些三个信号已经发送并相应接收，连接就已经建立，数据传输可以相应进行。

在数据传输之前，两个主机之间达成这种协议是TCP能够实现其与UDP区别开来的弹性的原因。由于主机知道要期待一个有序的包序列，它可以在包到达后重新排列那些顺序错误的包，以确保它们以适当的顺序传递给期待它们的上层协议。此外，如果它没有收到它所期待的包，它可以基于缺失的序列号识别出缺失的包，并请求重新传输丢失的部分。最后，这种连接的初始化给了服务器一个机会来传达其处理能力和最大吞吐量的信息。通过告诉客户端在任何给定时间内可以处理多少数据，客户端可以调节自己的输出以最小化数据丢失和网络拥塞。

显然，这些步骤的缺点是，为了建立和利用连接解析数字序列、相应地重新排序数据流以及重新传输数据，这些步骤会为交互带来重大的时间成本。当这种可靠性是必要的（在大多数企业网络软件中，它确实是必要的）时，你别无选择，只能利用TCP或类似健壮的协议。然而，当你的软件或支持它的网络基础设施的性质可以支持更低的可靠性时，你有许多高性能的传输层协议替代方案。

# 无连接通信

正如我们之前所确定的，传输层通信中的连接可以被视为一个会话。因此，**无连接通信**是一种通信模式，其中数据在首先在主机之间建立相互会话之前被传输。相反，数据包会带有适当的寻址信息被发送出去，确保交付的责任完全落在网络堆栈的底层。这显然引入了交付失败未被检测到的风险：因为没有期望从服务器那里得到任何确认，客户端不会知道数据包交付失败并需要重传，而如果没有首先同步会话，服务器也不会知道期待一个传入的消息。那么，为什么这种机制会被使用，何时这种风险是可以接受的？

# 无状态协议

由于没有任何会话需要管理，无连接协议通常被描述为无状态的。没有状态需要管理，每个事务都发生在一个更广泛的上下文中，这个上下文不会告诉接收者单个数据包如何适合到更广泛的接收数据包流中。因此，几乎无法确定并确保数据包的正确顺序，以便接收者可以重新构建。没有这种能力，无连接协议通常用于数据包可以完全自包含，或者丢失的数据包中丢失的信息可以根据接收到的下一个数据包由接收应用程序重建的情况。

在后一种情况下，我们可以通过在我们的应用程序中实现状态管理来解释协议的无状态性。例如，想象一下你的服务器托管一个跟踪确定状态的应用程序。现在假设这个状态是由远程客户端更新的，并且这些更新通过无连接协议（如UDP）以最小延迟实时发送。由于应用程序的状态是确定的，如果丢失单个数据包，服务器仍然可以根据接收到的下一个数据包确定是哪个更新，前提是它自己的更新只能从丢失数据包中设置的具体状态到达。

使用这种架构，应用程序会因每次数据包丢失而产生时间成本，因为需要一些处理来推断丢失数据包的值并相应地更新其内部状态。然而，在网络足够可靠，数据包丢失是罕见事件的情况下，无连接通信模式的降低延迟可以远远弥补应用程序生命周期中偶尔丢失数据包的处理成本。因此，在足够可靠的连接上，这种权衡可能证明极其有价值。虽然这些协议在商业应用中不太常见，但它们在需要高吞吐量和低延迟的交互式应用中，如网络多人视频游戏，经常被利用。

# 在无连接通信中进行广播

这种缺乏在两个主机之间共享状态管理的优点之一是，无连接通信能够进行多播。通过这种方式，单个主机可以同时向多个接收者发送相同的数据包，因为出站端口不受与单个其他主机单一活跃连接的限制。这种多播或广播对于像实时视频流或数据源这样的服务特别有用，其中单个源服务器可以同时向任意数量的潜在消费者发送数据。由于无连接数据包传输的低开销，这可以允许向广泛的消费者提供高吞吐量的数据。

# 在无连接通信中建立连接

如果你像我一样，你可能注意到了我最初描述的基于连接的通信模式中存在一点鸡生蛋的问题。具体来说，在没有两个主机之间的会话的情况下，如何在这两个主机之间建立基于连接的会话？

显然，最初的答案是，通过初始的无连接通信请求来建立连接。TCP连接请求的初始SYN消息是通过无连接通信IP发送的。通过这种方式，可以说基于连接的通信建立在无连接通信的基础上。事实上，在TCP的情况下，基于连接的交互如此依赖于IP的无连接交互，以至于这两个通常被合并并标识为TCP/IP套件。

# UDP作为无连接通信协议

就像TCP是互联网上首选的基于连接的通信协议一样，UDP通常作为首选的无连接通信协议。UDP表现出所有预期无连接协议的特性，包括在数据传输之前没有任何握手或会话协商，以及最小化的错误检查和错误纠正技术。那么，UDP在哪些情况下是有用的呢？

对这种速度的需求以及可接受的间歇性数据包丢失，非常适合低级网络操作，用于发送通知或对网络中其他设备的基本查询。这就是为什么UDP是域名系统（**DNS**）查找和动态主机配置协议（**DHCP**）的首选协议。在这两种情况下，请求主机需要立即对单个简单查询做出响应。在DNS查找的情况下，请求是针对给定域名注册的每个IP地址。UDP数据包可以直接指向DNS服务器，并且只包含正在查找的资源域名。一旦收到这些信息，DNS服务器可以在自己的时间响应，相信请求IP地址的应用程序可能会监听响应。一旦客户端最初发送DNS查找请求，如果在给定超时期间没有收到响应，客户端将发送一个相同的包。这样，在数据包丢失的情况下，有一个错误恢复机制（超时期）；同时，在数据包成功传输的更可能的情况下，查询结果将比首先建立连接返回得更快。

这种相同的行为使得DHCP请求能够在近乎实时的情况下得到满足。当一个新网络设备从DHCP服务器请求IP地址时，它对自己的网络中其他设备没有任何具体信息。因此，它必须广播一个DHCP请求，并希望相邻的节点可以作为DHCP服务器并为该设备分配一个IP地址。这些需求，对于低延迟和广播数据包的需求，意味着DHCP请求是UDP等无连接协议的理想用例。

# 检测无连接协议中的错误

我已经详细讨论过，无连接传输层协议更容易出错，因为协议本身没有检测错误的机制。我已经讨论了如何从利用它的应用层检测和纠正无连接传输层协议中的错误。然而，至少在UDP中，每个数据包至少包含一个简单的错误检测机制，那就是**校验和**。

如果你之前从未听说过这个术语，校验和类似于哈希函数，其中每个输入都会提供一个截然不同的输出。在 UDP 数据包中，校验和输入基本上是数据包的整个头部和主体。这些字节通过一个标准的生成校验和的算法发送。然后，一旦数据包被接收，接收方将数据包的内容通过与客户端相同的校验和算法进行校验，并验证它接收到的响应与发送的是否相同。如果存在任何微小的差异，接收方可以确信在传输过程中某些数据被修改，并且发生了错误。

对此错误进行响应或纠正超出了 UDP 错误处理机制的范畴。通常情况下，如果数据包的值对于接收方系统的持续运行至关重要，该系统可能会请求重新传输数据包。然而，在大多数情况下，不匹配的校验和仅仅表明接收方数据包无效，可以从处理队列中丢弃。

# C# 中的 TCP

因此，现在我们已经深入探讨了各种传输层协议的目标、功能和限制，让我们看看我们如何在 C# 中与这些协议交互。我们将首先仔细研究 .NET Core 提供的类和功能，以便直接从我们的应用程序代码中实现 TCP 请求。我们将通过为我们的两个应用程序中的每一个写入标准输出，查看每个请求和响应的结果，以确认我们软件的预期行为。这两个应用程序就像我们在第 9 章 [HTTP in .NET](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml) 中所做的那样。其中一个应用程序将是我们的 TCP 客户端，另一个将是监听 TCP 服务器。我们将通过写入标准输出，查看每个请求和响应的结果，以确认我们软件的预期行为。

# 初始化 TCP 服务器

让我们先创建我们的 `TCP` 客户端，就像我们在之前每个应用程序中做的那样，通过为其创建一个目录，然后使用 CLI 创建一个控制台应用程序：

[PRE0]

然后，在同一个目录下，我们将使用相同的命令创建我们的 `TCP` 服务器应用程序：

[PRE1]

现在我们已经准备好开始设置我们的交互。当我们上一次直接与在 [第 8 章](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml) *套接字和端口* 中暴露端口的套接字交互时，我们使用 Postman 生成针对给定端点的 HTTP 请求。然而，现在，由于我们将直接在代码中编写自己的 TCP 消息，我们不会受到 Postman 生成的标准化 HTTP 头部的限制。我们可以定义主机之间交互的自己的机制。为了便于处理，我们将让我们的客户端和服务器仅使用简单的字符串消息进行交互。

要开始这些交互，我们需要设置一个监听服务器。我们需要这样做是为了知道客户端将连接到哪个端口。因此，导航到你的 `SampleTcpServer` 应用程序的 `Main()` 方法，我们首先定义我们的监听端口，然后启动 `TcpListener` 类的一个实例，如下所示：

[PRE2]

`TcpListener` 类是一个围绕裸 `Socket` 实例的定制包装器。通过构造函数，我们指定我们想要监听传入请求的端口和 IP。如果我们使用裸套接字，我们就必须处理并响应或丢弃针对我们指定的端口的每个传入网络请求。然而，通过 `TcpListener` 实例，我们不需要响应任何不是通过 TCP 发送的请求。一旦我们设置了客户端类，我们将会看到这一点，但当你在一个开放的端口上监听这种低级网络请求时，这非常有用。

我们使用的构造函数接受 `IPAddress` 类的实例以及任何指定有效端口的 `int`（所以没有负数，也没有超过 65,535 的数）。因此，对于这个项目，我们将使用端口 `54321` 来监听传入的 TCP 请求。对于我们的 `IPAddress` 实例，我们使用由类公开的 `Any` 静态 `IPAddress` 实例。通过这样做，我们将能够看到并响应任何目标主机 IP 地址或域名解析到我们的主机机器的 TCP 请求。如果我们没有这样做，而是指定了一个单独的 IP 地址，那么即使地址解析到同一台机器，我们也不会响应任何 IP 地址不与之完全匹配的请求。因此，我们会这样做：

[PRE3]

在这样做之后，我们可以向 `tcp://0.0.0.0:54321` 发送一个 TCP 请求，但你不会在我们的 `TcpListener` 实例上看到任何请求注册。你可能预期我们的请求会被检测到，因为 `0.0.0.0` 和 `127.0.0.1` 这两个 IP 地址都解析到同一台本地机器，但在这个例子中，我们指定我们的 `TcpListener` 只监听 `127.0.0.1` IP 地址的请求，这正是它所做的事情。同时，我们的 `0.0.0.0` 请求没有得到解决。因此，除非你为你的主机机器上持有的不同 IP 地址编写不同的监听器（或者你的应用程序可能部署的一系列主机机器），否则我建议尽可能使用 `IPAddress.Any`。

现在，我们必须设置我们的服务器以运行并监听对该端口的请求。首先，我们将启动服务器，然后我们将设置一个上下文，在那里我们无限期地监听传入的请求。这通常是通过一个故意无限循环来完成的。现在，如果你曾经意外地发现自己陷入了一个无限循环中，你知道这应该只在你真正打算这么做的时候才开始。然而，由于我们希望我们的应用程序无限期地监听，最简单且最可靠的方法是防止我们的`Main()`方法解析，通过将我们的主要业务逻辑封装在一个简单的无限循环中来做到这一点：

[PRE4]

如果你编译并构建到目前为止我们所写的代码，你将看到两个控制台语句打印到屏幕上，然后你的应用程序看起来就像挂了一段时间，这正是你所希望看到的。幕后发生的事情是，你已经通过调用`Start()`初始化了`TcpListener`实例。

这将导致实例在其指定的端口上接受传入的请求，直到你明确地在类上调用`Stop()`方法，或者它接收到的连接总数超过`SocketOptionName`枚举的`MaxConnections`属性（该属性设置为超过二十亿，因此在我们的小型本地TCP服务器中，这个限制不太可能达到）。

一旦我们的服务器开始监听，我们就启动我们的监听循环，并检查我们的套接字是否收到了任何挂起的请求。如果没有（并且自上次请求以来我们没有记录它），我们通过简单的控制台日志来表明这一点，然后继续，通过`while`循环继续，直到我们有东西要处理。目前，我们不应该看到任何挂起状态，所以让我们设置我们的客户端项目来改变这一点。

# 初始化TCP客户端

现在，我们需要以与我们的服务器相同的方式初始化我们的TCP客户端应用程序。不过，我们将使用`TcpClient`类而不是`TcpListener`类来与我们的服务器建立连接，这样我们就可以在我们的项目中写入和读取这些连接。在我们这个例子中，两者之间的区别在于，当我们创建一个`TcpListener`时，我们需要用它将监听的地址和端口来初始化它。没有默认构造函数，因为没有监听端口的类无法执行其最基本的功能。

然而，使用`TcpClient`实例，我们不需要用地址或端口规范来初始化它。客户端实例可以合理地用于连接到多个不同的远程进程（单个远程主机上的端口）或主机（完全不同的IP地址）。因此，当我们尝试建立连接时，我们只需要指定我们的连接目标。现在，让我们只是建立连接来确认我们的服务器能够适当地响应监听请求：

[PRE5]

在这里，我们指定了IP地址 `127.0.0.1`，但正如我之前所说的，我们本可以指定任何解析到我们本地机器的别名IP地址。一旦我们创建了客户端，我们就可以使用它来连接到我们在服务器应用程序上指定的监听端口。然后，为了确认连接已经建立，并且客户端知道这一点，我们写入一个简单的日志语句，让线程休眠`10`秒以观察控制台中的消息，然后终止程序。

为了看到这一成功，首先启动你的服务器应用程序，确保它已经启动并监听指定的端口。然后，一旦你在控制台窗口中看到消息表明服务器正在等待挂起请求，启动你的客户端应用程序。你应该在你的客户端窗口中看到“我们已连接...”消息，在你的服务器窗口中看到“挂起的TCP请求...”消息。一旦你看到这两条消息，你就知道你的连接正在建立，然后你可以终止这两个应用程序。

此外，让我们考虑一下为什么我们使用`loggedPending`标志。为什么我们使用`loggedNoRequest`标志来防止我们在收到传入请求之前每次遍历循环时打印日志消息应该是相当明显的。然而，我们必须在存在挂起请求时做同样的事情，因为服务器会保持`Pending`状态，直到其入站消息队列被读取并刷新。所以，由于我们的服务器在没有那个检查的情况下还没有读取并清空传入请求流，并且我们连接到了服务器，我们的控制台会很快因为挂起的TCP请求...消息而溢出。

# 无数据传输的连接信息

在我们开始在项目中构建和解析TCP请求之前，我想花一点时间来指出基于连接的方法的好处，以及.NET Core如何利用它来让工程师对他们的网络事务有精细的控制。请注意，一旦我们从客户端发送连接请求，服务器就会立即通知我们连接已经建立。实际上并没有发送消息，服务器也没有收到任何响应。事实上，即使服务器同步锁定并阻止主动传输任何内容，连接仍然保持打开。这是TCP的握手交互在起作用，并为我们提供了关于连接状态的大量信息，这些信息是在实际发送消息之前获得的。

对于应用程序开发者来说，特别令人高兴的是，连接的建立和管理是由`TcpClient`类本身完成的。只需调用一次`Connect(IPAddress, int)`方法，TcpClient库就会通知我们的服务器我们希望建立连接，等待确认，并最终确认服务器的响应以打开连接。这是.NET Core最伟大的优势之一；高级应用程序编程语言的易用性，以及访问和控制低级网络交互的能力。

# 在活动连接上传输数据

现在我们已经建立了连接，我们的服务器可以决定如何处理该连接以及通过它传输的请求。然而，在我们回到服务器之前，让我们首先生成一个客户端的消息供服务器处理。我们将使用一种突变测试来确认所有数据都被服务器相应地处理和返回。因此，在每一步，我们都会修改我们的初始消息并记录结果。每一步，我们的消息都应该与最后写入它的系统不同。

如果你从未听说过**突变测试**这个术语，它是一种简单的方法，用于跟踪对系统所做的更改是否被验证系统（测试）检测到。想法是在你的代码中某个地方进行更改或突变，并确认在下游某个地方，通常是在单元测试中，该更改产生了影响，通常是通过使之前通过的单位测试失败。

我们将从编写一个带有标题和有效负载的消息开始。这将是针对我们服务器的简单问候，以及我们期望服务器返回给我们的消息，作为其响应的一部分，且不改变。我们将使用简单的`|`分隔符将两个消息分开。然后我们将它转换为适合通过我们的连接传输的字节序列，并发送请求。所以，在我们继续到服务器之前，让我们设置一下：

[PRE6]

我们创建的`requestStream`变量是`NetworkStream`类的一个实例，用于在打开的套接字上写入和读取数据。有了这个，我们将能够发送我们的初始消息，然后，最终，从服务器读取响应。但是，在我们改变方向回到服务器之前，让我们看看如何使用我们的`TcpListener`实例来接受和解析传入的请求。

# 在服务器上接受传入的TCP请求

现在既然我们的客户端实际上正在发送一个可读的消息，让我们在我们的待处理连接上监听请求。为此，我们将直接从我们的监听器获取另一个`TcpClient`类的实例。这个类是用来与打开的连接交互的，所以一旦我们接受它，我们将以与我们的示例客户端程序相同的方式从该打开连接中读取和写入。首先，我们必须使用线程阻塞的`AcceptTcpClient()`调用接受待处理连接。由于我们现在正在响应我们的待处理请求，我们可以删除我们的日志消息并用我们的新代码替换它：

[PRE7]

启动我们的服务器后，我们应该在我们的服务器日志中看到它正在监听待处理的连接请求。然后，一旦我们运行我们的客户端，我们应该看到客户端的请求消息被记录到服务器的控制台，随后还有一个指示器表明服务器再次开始监听传入的请求。如果我们再次运行客户端，我们将看到相同的序列事件，直到我们最终关闭服务器。

# 服务器上的请求/响应模型

为了完成请求/响应交互，我们将生成一个新的消息，使用原始请求的有效负载，并将其返回给我们的客户端。随着这两个应用程序的完成，从现在开始，客户端将驱动与服务器之间的交互。因此，我们的服务器将保持运行状态，返回响应，这些响应会回显请求的有效负载，直到它收到一个指示它应该自行关闭的信号。同时，我们的客户端将发送带有新有效负载的间歇性请求，直到最终向我们的服务器发送终止信号。为了实现这个目的，我们将向我们的服务器应用程序添加以下行：

[PRE8]

我们将使用这个信号来表示我们应该停止监听请求并终止服务器。接下来，我们将添加以下条件代码到我们服务器的监听循环中：

[PRE9]

我们的响应传输代码将放在那个条件块中的`else`语句内，因此我们的循环将简单地继续记录请求消息，然后将有效负载附加到响应中，直到接收到终止信号，此时循环被打破，我们将关闭我们的服务器。所以，最后，我们将修改我们的`while`循环，检查`done`条件的值而不是运行无限循环：

[PRE10]

接下来，让我们解析消息以获取其有效负载，使用我们的分隔符来分隔消息的两个组件，然后将结果应用于服务器的响应：

[PRE11]

最后，在我们的监听循环的闭合花括号之后的一行，让我们关闭我们的服务器，如果你正在使用Visual Studio的调试模式运行应用程序，允许我们的程序在短暂的延迟后结束以检查日志结果：

[PRE12]

有了这些，我们的 `SampleTcpServer` 应用程序就完成了。它将保持活跃状态并监听请求，直到明确地指示它终止自己。在整个过程中，它将记录它接收到的每个请求并返回它自己的自定义响应。您可以使用本章 GitHub 仓库中的源代码来检查您的实现与我的实现是否一致，但就像往常一样，我鼓励您自己修改它并开始调查其他可用的方法。在这样做的时候，始终思考您如何在自己的自定义网络软件中使用此代码。

# 完成TCP客户端

我们的服务器被设计和编写成保持活跃并监听任何潜在的传入请求。另一方面，客户端应该只为单一目的而设置，执行该目的，然后关闭其连接，以便服务器可以为可能需要访问它的其他消费者释放资源。因此，我们不会编写任何持久的监听循环。相反，我们将在终止服务器并关闭我们自己的应用程序之前简单地处理几个请求/响应往返。然而，为了创建一个稍微更现实的模拟，多个客户端访问我们的 TCP 服务器，我们将为每个后续请求丢弃并重新创建我们的 `TcpClient` 实例，并在每个请求之间注入随机延迟。

然而，首要任务是接受来自我们服务器的响应。因此，在我们的 `SampleTcpClient` 应用程序中，我们将添加几行代码来创建一个新的字节数组，用作响应的消息缓冲区，然后将我们的 `requestStream` 读取到我们的缓冲区中进行处理和记录。所以，让我们添加这段代码，然后我们将看到我们如何扩展它来完成我们的模拟：

[PRE13]

我认为到目前为止，这一切都不足为奇。我们实际上执行的是与服务器完全相同的事情，但顺序相反。在服务器上，我们是读取流，然后写入流，而在客户端代码中，我们首先写入流，然后从流中读取。然而，从机械上讲，这是我们自从在第四章 [9d6266fb-4428-4044-b63b-44f1317f64e7.xhtml]*，数据包和流* 中首次查看如何与原始 C# Stream 对象交互以来所看到的相同类型的交互。希望到现在为止，您已经开始看到我们迄今为止在构建网络编程基础时采用的逐步、砖块式方法的价值（假设您还没有这样做）。

无论如何，让我们修改我们的客户端，在最终发送终止信号之前发送一些预定义的消息。为此，让我们构建一个包含我们将发送到服务器的消息的简短数组，这样我们就可以在我们的代码中轻松地遍历它们，在每个出站请求中发送不同的消息：

[PRE14]

接下来，让我们将请求/响应事务包裹在一个 `while` 循环中（不是像我们的服务器那样看到的活跃监听循环，而是一个简单的增量循环）。我们将使用一个迭代变量，从零开始，遍历我们的消息，将其值与我们的消息数组长度进行比较，以确定何时跳出循环并让我们的应用程序终止：

[PRE15]

由于我们的 `TcpClient` 实例是在 `while` 循环内的 `using` 语句中创建的，因此每次迭代变量都会超出作用域。因此，我们每次回到循环的开始时都会创建一个新的连接。接下来，我们必须更改构建我们的请求消息字节数组的代码，使其迭代 `messages` 字符串数组：

[PRE16]

最后，在 `while` 循环的末尾，我们将线程休眠一个介于 `2` 到 `10` 秒之间的随机时间，每次都记录 `sleepDuration`：

[PRE17]

最后，如果你在调试模式下运行，你可能会在 `while` 循环之后添加一个最后的 `Thread.Sleep()`，以确保在我们应用程序关闭之前有足够的时间检查我们请求的结果。

在完成客户端并运行这两个应用程序后，我的终端记录了我希望它们记录的确切消息：

![图片](img/50954a2a-67e4-4336-85d4-5f4c2da42e86.png)

并且，通过这种方式，我们已经编写了自己的自定义 TCP 服务器和客户端。虽然这个示例在功能上相当简单，但我希望你能看到这些 .NET 类为你提供的自定义 TCP 实现的高度灵活性。通过这两个示例应用程序，你拥有了编写自己的自定义应用层协议所需的全部工具，该协议由一个针对它优化的自定义 TCP 服务器支持。或者，你可以编写绕过应用层协议开销的网络的交互应用程序！你在个人或专业项目中遇到的问题将决定你如何选择使用这个工具集，但现在，希望你能准备好在需要时利用它。

# C# 中的 UDP

现在我们已经了解了如何在 C# 中实现 TCP，接下来让我们看看传输层协议套件中与之对应的无连接协议 UDP。根据其本质，我们将编写的示例客户端和服务器在设置代码方面将比 TCP 简单得多，但我们将使用之前章节中用于定义示例应用程序行为的相同模式。因此，我们将在客户端和服务器之间传输请求并接受和记录响应。

然而，这里的区别是客户端和服务器将以完全相同的方式进行实现。这是因为没有 `UdpListener` 类，因为 UDP 不主动监听连接。相反，UDP 服务器只是在设置好寻找新的数据包时接受传入的数据包。因此，我们将只查看客户端应用程序的实现，我将把服务器源代码留给你从 GitHub 上下载并使用来测试和验证客户端的行为。

# 初始化 UDP 客户端

我们将首先创建一个新的控制台应用程序，它将作为我们的 `UDP` 客户端：

[PRE18]

然后，在我们的项目中，我们首先想要做的是定义一个已知的 IP 端点，我们的客户端将与之交互。我们将再次使用 localhost，并暴露一个任意端口，就像我们在上一节关于 TCP 的部分中所做的那样。一旦我们定义了它，我们就可以准备开始生成请求。无连接协议的美丽之处在于我们不需要首先与我们的远程主机建立任何形式的交互。只要我们知道主机的地址，我们就可以简单地发送我们的数据报。

[PRE19]

就这样，如果你运行服务器应用程序，然后运行客户端，你将看到你的消息被记录在服务器的控制台上！那么，这里到底发生了什么，当我们初始化我们的 `UdpClient` 时我们在做什么呢？

我们首先用端口号初始化我们的 `UdpClient`。如果我们打算使用这个客户端来接收传入的 UDP 数据报（我们最终会这样做），它将在这个初始化时指定的端口上接受它们。因此，我们的客户端将监听端口 `34567`。接下来，我们花时间定义我们打算发送数据报的显式 `IPEndPoint`。

这在技术上不是必需的，因为你可以使用重载的方法签名，在 `SendAsync()` 方法中定义你的请求目标，包括它们的域名和端口。然而，由于我们将扩展这个方法以接受响应，在我们的目的中，在方法开始时显式定义 `IPEndPoint` 实例更容易。最后，我们像上一节那样构建我们的数据报，将其作为表示消息字符串字符的字节数组，并借助我们新初始化的 `UdpClient` 发送消息。

# 发送/接收范式

你可能已经注意到，与更健壮的`TcpClient`类相比，使用`UdpClient`时没有利用流。由于没有底层连接来表示流，以及UDP数据可能丢失或顺序错误的潜在可能性，UDP请求的行为与`Stream`实例提供的抽象之间没有直接关联。正因为如此，.NET Core提供的`UdpClient`类通过其`Send`和`Receive`方法实现了一个简单的请求/响应机制。这两个方法中的任何一个都不需要与远程主机进行先前的通信或交互即可执行。相反，它们更像是在网络上触发某些事件发生的“触发器”。

有趣的是，尽管如此，当你想利用`SendAsync()`方法时，这个方法不会阻塞你的应用程序线程，你可以选择首先与你的远程主机建立连接。但请记住，这并不完全等同于TCP中的建立连接。相反，这仅仅配置了你的`UdpClient`，使其尝试将所有发出的数据包发送到它连接的特定远程主机。

在这种情况下，连接仅是逻辑上的，并且它只存在于建立它的应用程序中。因此，虽然一个建立的TCP连接可以从我们的客户端和服务器应用程序同时检测到，但在我们的UDP应用程序中并非如此。当同时运行我们的UDP客户端和服务器时，服务器应用程序无法检测到客户端建立的连接。

一旦我们将`UdpClient`连接到特定的`IPEndPoint`，每个`SendAsync()`调用都假定是为连接的端点配置的。如果你想在`UdpClient`实例连接到不同端点时发送消息，你必须首先断开客户端的连接，或者明确地将新端点作为参数传递给`SendAsync()`调用。在我们的示例应用程序中，这不会成为问题，但在实际环境中，这个问题可能会很快出现，因此当你为特定应用程序定义发送/接收模式时，请记住这一点。

基于这种理解，让我们准备接收我们的UDP服务器应用程序的响应。首先，我们将修改我们的应用程序，使其一开始就连接到我们的远程端点。接下来，为了演示如何使用`UdpClient`实例建立连接，我们将从`SendAsync()`调用中移除端点参数。最后，我们将使用`ReceiveAsync()`监听消息。到那时，我们将像处理之前的每个字节数组缓冲区一样处理数据包的缓冲区对象：

[PRE20]

有了这些，我们已经将UDP客户端连接好，可以发送数据包并等待服务器的响应。

你可能已经从本章关于无连接通信的讨论中推断出了这一点，但无论何时你使用UDP（或任何其他无连接协议）发送消息，它本质上是非阻塞操作。这是由于服务器没有提供任何形式的确认。因此，从我们的应用程序角度来看，一旦UDP数据包到达我们的网络卡进行传输，其交付就不再在我们手中。

同时，UDP中的`Receive()`操作本质上是阻塞的*.* 由于没有建立连接或流缓冲区来存储传入的消息，直到我们的服务器或客户端准备好处理数据包，因此我们编写的任何必须接受和接收UDP数据包的软件都必须非常明确地说明在等待可能永远不会到达的数据包时，何时以及多长时间可以阻塞我们的执行。传输方法的异步版本提供了一些灵活性，但最终，这是协议的限制，我们无法规避。鉴于这一点，最好是从一开始就注意这个限制，并围绕它设计你的UDP软件。

# 多播数据包

使用无连接通信，例如UDP，最大的单一优势之一可能是能够在单次事务中向大量接收者发送数据包。这通常被称为**多播**，或**广播**，它使得从网络设备发现和主机注册到大多数通过互联网直播的电视或视频流都能实现。这是一个相对小众的功能，如果我要猜测的话，大多数阅读这篇文章的人可能永远不会找到一个很好的理由去利用它，但它确实值得理解。话虽如此，让我们看看如何在我们的.NET Core应用程序中启用此功能。

# .NET中的多播

在我们迄今为止查看的大多数数据包传输中，我们一直在针对特定机器上的特定端口进行操作，通过主机名或IP地址进行寻址。然而，如果我们目标是向尽可能多的可以监听它的IP地址发送相同的数据包，这显然不会满足我们的需求。如果我们试图发现网络上的设备，甚至不确定它们的IP地址，这肯定也不会起作用。相反，大多数网络设备将监听针对它们特定IP地址的请求，以及专门设计来捕获来自其网络上其他设备广播数据包的特殊IP地址范围（通常，该多播IP地址将是`255.255.255.255`，但不一定是）。

如果你希望从你的主机的一个端口中多播多个数据包，你可以通过配置你的`UdpClient`实例，使其通过`ExclusiveAddressUse`布尔属性允许多个客户端访问一个开放的端口来实现。通过将该属性设置为`false`，你可以使多个`UdpClient`同时利用相同的端口，从而让你的应用程序能够向配置了与之交互的客户端数量一样多的远程主机传输消息。

另外，如果你想监听多播数据包，你可以通过将适当的`MulticastGroupOptions`设置应用于你的客户端或套接字，将一个`UdpClient`设置为`MulticastGroup`的一部分。这样做会将你的客户端设置为与其他已注册的监听器一起监听单个发送主机正在多播的数据包。

正如我在本节开头所说，多播和监听多播数据包是一项非常专业的操作，你不太可能在日常工作中需要考虑它。因此，我不会在这个主题上花费更多的时间。然而，如果你对此感兴趣，我强烈建议你在线查阅相关的文档。不过，现在，我只是想确保你对这个概念至少有一些了解，并理解`UdpClient`类中提供了哪些功能，你可以利用这些功能来实现或监听多播数据传输。不过，现在，我认为是时候转向一个更广泛使用的传输层协议了。因此，让我们深入探讨互联网协议。现在是时候研究IP了。

# 摘要

本章为我们理解网络编程提供了一个重大的范式转变。我们研究了传输层的责任与应用层的责任完全不同，我们非常仔细地审视了传输层的具体责任。我们了解到，**互联网工程任务组**（**IETF**）根据协议可能支持的服务和功能，对传输层责任的各种方法进行了分类，并且我们学习了如何使用这些分类来确定使用特定传输层协议的最佳情况。

接下来，我们学习了如何使用TCP等基于连接的协议，在客户端和服务器之间进行初步握手，以在数据传输之前在两个主机之间建立活跃的连接或会话。我们看到了这些会话如何使基于连接的通信协议能够在主机之间提供可靠的交互，并具有大量的错误检测和错误纠正支持。然后我们考虑了无连接协议本身提供的一些优点，包括在足够可靠的网络上主机之间低开销和低延迟的交互。然后我们查看了一些无连接协议或其上层的应用层协议可以采用的策略，以减轻无连接通信的不可靠性。

最后，带着这种观点，我们能够一头扎进使用C#和.NET框架提供的某些极其简单的库来实现基于连接和无连接的客户端和服务器。我们使用了设计用来模拟TCP和UDP交互的客户端和服务器，并在这个过程中看到了.NET Core的设计者如何概念化每个协议的一些特性，并在代码中实现这些特性。现在，我们对这两种传输层协议都有了深入的了解，我们准备全面检查最普遍的传输层协议——**互联网协议**的复杂性和细微差别。这正是我们将在下一章中做的事情。

# 问题

1.  传输层协议的四种分类是什么？

1.  传输层协议的主要功能和职责是什么？

1.  在基于连接的通信模式中，“连接”是什么意思？

1.  TCP代表什么？为什么通常被称为TCP/IP？

1.  描述用于在TCP上建立连接的手动过程。

1.  UDP代表什么？UDP有哪些优点？

1.  无连接通信的最大缺点是什么？

1.  多播是什么？广播是什么，如何在UDP中启用？

# 进一步阅读

关于TCP、UDP和传输层的一般信息，我建议阅读Alena Kabelová和Libor Dostálek所著的《Understanding TCP/IP》，可在以下链接从Packt Publishing获取：

[https://www.packtpub.com/networking-and-servers/understanding-tcpip](https://www.packtpub.com/networking-and-servers/understanding-tcpip).
