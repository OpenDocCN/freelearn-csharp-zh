<html><head></head><body>
		<div><p><a id="_idTextAnchor180"/></p>
			<h1 id="_idParaDest-177"><em class="italic"><a id="_idTextAnchor181"/>Chapter 10</em>: Serialization System and Assets Management in Unity and Azure</h1>
			<p>In the last chapter, <a href="B17146_09_Final_ASB_ePub.xhtml#_idTextAnchor165"><em class="italic">Chapter 9</em></a>, <em class="italic">Using Data-Oriented Technology Stack in Unity</em>, we learned what the data-oriented technology stack is and how you can use this technology to take advantage of multicore processors to improve the performance of your game. In this chapter, we will cover some other important topics in Unity development, namely, <strong class="bold">serialization</strong> and <strong class="bold">asset management</strong> in Unity. Usually, a game not only has code but also consists of many different kinds of assets, such as models, textures, and audio. Hence, understanding what the serialization system in Unity is and what the assets workflow is can help you better develop games with Unity. </p>
			<p>In the last section of this chapter, we will also explore an interesting topic – how to use the <strong class="bold">Azure Cloud storage</strong> services to host the content of a Unity game and load the content from the Azure Cloud to the Unity game by using Unity's <strong class="bold">Addressable Assets system</strong>.</p>
			<p>The following key topics will be included in our learning path:</p>
			<ul>
				<li>Serialization system in Unity</li>
				<li>The Assets workflow in Unity</li>
				<li>Introducing the special folders in Unity</li>
				<li>Azure Blob storage with Unity's Addressable Assets system</li>
			</ul>
			<p>By the end of this chapter, you will not only understand the serialization system and assets management in Unity, but you will also be familiar with Azure Cloud storage services.</p>
			<p>Sounds exciting! </p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor182"/>Technical requirements</h1>
			<p>Since this chapter will be covering Azure's Storage account service, if you don't have an Azure account available, I recommend you set up a free Azure trial account first before starting this chapter. You can click the following link to create a free Azure trial account with $200 credit:</p>
			<p><a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a></p>
			<div><div><img src="img/Figure_10.01_B17146.jpg" alt="Figure 10.1 – Microsoft Azure page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 <a id="_idTextAnchor183"/>– Microsoft Azure page</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor184"/>Serialization system in Unity </h1>
			<p>When developing a game, adding a reliable content saving and loading feature is a critical part of the development process. If you're using a game engine editor, such as the Unity engine editor, you'll also need some common editor features, such as undo, saving editor settings, and more. All of this, whether the game saves or loads content at runtime, or whether the<a id="_idIndexMarker863"/> developer uses the editor to develop the game, is built on <strong class="bold">serialization</strong>. </p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor185"/>What is Unity's serialization system?</h2>
			<p>So, what is <code>deserialization</code>.</p>
			<p>In Unity, there are three <a id="_idIndexMarker865"/>serialization formats, namely the following:</p>
			<ul>
				<li>Binary serialization</li>
				<li><code>YAML</code> serialization</li>
				<li><code>JSON</code> serialization </li>
			</ul>
			<h3>YAML and binary serialization in Unity</h3>
			<p>Assets created by <a id="_idIndexMarker866"/>Unity, such as <code>Scenes</code> and <code>Prefabs</code>, will be<a id="_idIndexMarker867"/> saved in <code>YAML</code> format by default. For example, if we open the <a id="_idIndexMarker868"/>Scene of this chapter, namely, <code>Chapter10.unity</code>, in a text <a id="_idIndexMarker869"/>editor such as <code>OcclusionCullingSettings</code> and <code>RenderSettings</code>. If you scroll down, you can also find the GameObjects and components contained in this Scene.</p>
			<div><div><img src="img/Figure_10.02_B17146.jpg" alt="Figure 10.2 – The Scene in YAML format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – The Scene in YAML format</p>
			<p>As shown in <em class="italic">Figure 10.2</em>, there is no doubt that the YAML format is human-readable and makes it easy for the version control tools to work with. However, YAML is a text-based format, so you can also choose <a id="_idIndexMarker871"/>to use binary serialization for the more <a id="_idIndexMarker872"/>efficient use of space and increased security. Let's perform the following steps to set Unity's serialization mode:</p>
			<ol>
				<li>Open the <strong class="bold">Project Settings</strong> window by clicking the <strong class="bold">Edit | Project Settings...</strong> item in the Unity<a id="_idIndexMarker873"/> Editor toolbar, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_10.03_B17146.jpg" alt="Figure 10.3 – Opening the Project Settings window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Opening the Project Settings window</p>
			<ol>
				<li value="2">Next, click the <code> </code>settings panel, as shown in <em class="italic">Figure 10.4</em>: </li>
			</ol>
			<div><div><img src="img/Figure_10.04_B17146.jpg" alt="Figure 10.4 – The Editor settings panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – The Editor settings panel</p>
			<ol>
				<li value="3">In the <strong class="bold">Asset Serialization</strong> section, we can find that the <strong class="bold">Mode</strong> option is <strong class="bold">Force Text</strong> by default. In this mode, all the assets created by Unity will be serialized in YAML format. This is also the recommended setting if you use a version<a id="_idIndexMarker875"/> management tool such as Git, as using plain text serialization can often avoid unresolvable merge conflicts. As shown in <em class="italic">Figure 10.5</em>, in the drop-down window, we can select <strong class="bold">Force Binary</strong> mode to convert all the assets to binary format, and we can also choose the <strong class="bold">Mixed</strong> mode option to retain the serialization format of the current assets; that is, the assets that are serialized in binary format are still in binary format, and assets that are serialized using YAML format are still in YAML format. However, newly created assets will be serialized in binary format.</li>
			</ol>
			<div><div><img src="img/Figure_10.05_B17146.jpg" alt="Figure 10.5 – Asset Serialization mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Asset Serialization mode</p>
			<ol>
				<li value="4">Here, we can select <strong class="bold">Force Binary</strong> mode and check the same Scene file in our text editor again. The Scene file is converted to binary format, as shown in the following screenshot: </li>
			</ol>
			<div><div><img src="img/Figure_10.06_B17146.jpg" alt="Figure 10.6 – The Scene file in binary format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – The Scene file in binary format</p>
			<p>As we mentioned earlier, serialization is <a id="_idIndexMarker876"/>also an important part of implementing the Unity Editor. Not only are the assets created by Unity as used in the game, such as game Scenes, serialized by Unity, but the various settings in the Unity Editor are also serialized by Unity. </p>
			<p>In the project root directory, we can find the <code>ProjectSettings</code> folder, which is automatically created by the Unity Editor when the project is created, as shown in <em class="italic">Figure 10.7</em>:</p>
			<div><div><img src="img/Figure_10.07_B17146.jpg" alt="Figure 10.7 – The ProjectSettings folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – The ProjectSettings folder</p>
			<p>Double-click this folder to open it. We can find all the settings files of the current project here.</p>
			<div><div><img src="img/Figure_10.08_B17146.jpg" alt="Figure 10.8 – The settings files in the ProjectSettings folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – The settings files in the ProjectSettings folder</p>
			<p>Next, we still use the text editor<a id="_idIndexMarker877"/> to open a settings file, such as <code>GraphicsSettings.asset</code>, and serialize this file using Unity's binary serialization mode and text serialization mode, respectively. <em class="italic">Figure 10.9</em> shows the settings file serialized in binary format:</p>
			<div><div><img src="img/Figure_10.09_B17146.jpg" alt="Figure 10.9 – The settings file in binary format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – The settings file in binary format</p>
			<p>On the other hand, you can see the settings file serialized in YAML format in <em class="italic">Figure 10.10</em>: </p>
			<div><div><img src="img/Figure_10.10_B17146.jpg" alt="Figure 10.10 – The settings file in YAML format&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – The settings file in YAML format</p>
			<p>So far, we've discussed<a id="_idIndexMarker878"/> Unity's binary serialization and text-based YAML serialization, but we haven't covered the JSON serialization provided by Unity yet. Next, let's take a look at JSON serialization in Unity. </p>
			<h3>JsonUtility class and JSON serialization in Unity</h3>
			<p>If you have previous experience of developing .NET projects, you are probably familiar with <a id="_idIndexMarker879"/>JSON serialization. You can choose the solutions provided by .NET, such as <a id="_idIndexMarker880"/>using the <code>DataContractJsonSerializer</code> class defined in the <code>System.Runtime.Serialization.Json</code> namespace or using the <code>JsonSerializer</code> class defined in the <code>System.Text.Json</code> namespace, and there are also solutions from the open source community, such as <code>Newtonsoft.Json</code>, which is a very popular JSON framework for .NET. Unity also provides game developers with JSON serialization capabilities in Unity development, namely, the <code>JsonUtility</code> class. We can call <code>JsonUtility</code>'s <code>ToJson</code> method to serialize an object into a JSON string, and conversely, <code>JsonUtility</code>'s <code>FromJson</code> method can deserialize a JSON string into an object. Next, let's look at an example of how to use<a id="_idIndexMarker881"/> the <code>JsonUtility</code> class in Unity:</p>
			<ol>
				<li value="1">Create a new folder named <code>Scripts</code> by clicking the <strong class="bold">Create | Folder</strong> item in the <strong class="bold">Project</strong> window.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.11_B17146.jpg" alt="Figure 10.11 – Creating the Scripts folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – Creating the Scripts folder</p>
			<ol>
				<li value="2">Double-click on the <code>Scripts</code> folder to enter it, and then create a new C# script in this folder, name it <code>PlayerData</code>, and add the following to this script. The <code>PlayerData</code> struct is used to store the data of a player, and an object of it will be serialized to a<a id="_idIndexMarker882"/> JSON string later. And you should note that fields of the structs or classes should be <code>public</code>; otherwise, the Unity serializer will ignore these fields:<pre>public struct PlayerData
{
    <strong class="bold">public</strong> string Name;
    <strong class="bold">public</strong> int Age;
    <strong class="bold">public</strong> float HP;
    <strong class="bold">public</strong> float Attack;
    public PlayerData(string name, int age, float hp,
      float attack)
    {
        Name = name;
        Age = age;
        HP = hp;
        Attack = attack;
    }
}</pre></li>
				<li>Next, we also <a id="_idIndexMarker883"/>need to create another C# script in the same folder and name it <code>JSONSerializationSample</code>. The code in <code>JSONSerializationSample</code> is as follows. In the <code>Start</code> method, we create a new <code>PlayerData</code> object and assign values to its fields, and then call the <code>JsonUtility.ToJson</code> method to serialize this object into a JSON string and print the string to the <code>Console</code> window:<pre>using UnityEngine;
public class JSONSerializationSample : MonoBehaviour
{
    private void Start()
    {
        var playerData = new PlayerData("player1", 50,
          100, 100);
        var jsonString =
          <strong class="bold">JsonUtility.ToJson</strong>(playerData);
        Debug.Log(jsonString);
    }
}</pre></li>
				<li>Create a new <a id="_idIndexMarker884"/>GameObject in the Scene, attach the <code>JSONSerializationSample</code> script to it, and run the game in the editor. The JSON string, as shown in the following screenshot, will be printed:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.12_B17146.jpg" alt="Figure 10.12 – The JSON string&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – The JSON string</p>
			<ol>
				<li value="5">Deserializing a JSON string to an object is fairly straightforward; you just need to call <code>JsonUtility.FromJson&lt;T&gt;</code>, which is a generic method. If you don't know about generic methods in C#, generic methods are methods declared with type parameters. So, let's go back to <code>JSONSerializationSample</code> and update the code in the <code>Start</code> method. This code will deserialize the JSON string into a new object, and the object's <code>Name</code> field will be printed in the <strong class="bold">Console </strong>window:<pre>using UnityEngine;
public class JSONSerializationSample : MonoBehaviour
{
    private void Start()
    {
        var playerData = new PlayerData("player1", 50,
          100, 100);
        var jsonString =
          JsonUtility.ToJson(playerData);
        Debug.Log(jsonString);
        var deserializedObject =
         <strong class="bold">JsonUtility.FromJson&lt;PlayerData&gt;(jsonString);</strong>
        Debug.Log(deserializedObject.Name);
    }
}</pre></li>
				<li>Run the game<a id="_idIndexMarker885"/> in the editor. The name of this player is printed as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.13_B17146.jpg" alt="Figure 10.13 – Deserializing the JSON string&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.13 – Deserializing the JSON string</p>
			<ol>
				<li value="7">If you want <code>PlayerData</code> as a field of another class and you want to serialize this class, <code>PlayerData</code> needs to be marked with the <code>[System.Serializable]</code> attribute, otherwise, <code>PlayerData</code> as a field won't be serialized correctly. So, let's go back to <code>PlayerData</code> and update the code to add the <code>[System.Serializable]</code> attribute:<pre><strong class="bold">[System.Serializable]</strong>
public struct PlayerData
{
   //No Change
}</pre></li>
			</ol>
			<p>Now that you <a id="_idIndexMarker886"/>know how to use the <code>JsonUtility</code> class to serialize an object to a JSON string and deserialize a JSON string to an object in Unity, it's time to discuss the advantages and limitations of Unity's <code>JsonUtility</code> class.</p>
			<h4>Advantages and limitations of Unity's JsonUtility class</h4>
			<p>Let's start with the<a id="_idIndexMarker887"/> advantages of Unity's <code>JsonUtility</code> class. Using the <code>JsonUtility</code> class in Unity can achieve relatively high performance in terms of serializing and deserializing JSON. The <code>ToJson</code> method and the <code>FromJson</code> method of <code>JsonUtility</code> use the Unity serializer internally, and it has better support for some built-in types of Unity, such as <code>Vector2</code> and <code>Vector3</code>. In addition, since it is provided by the Unity game engine, there is no need to install additional packages. </p>
			<p>However, <code>JsonUtility</code> has limited functionality compared to other popular JSON frameworks such as <code>Newtonsoft.Json</code>. The two most obvious limitations are that <code>JsonUtility</code> does not support the serialization of dictionaries and that the root element must be an object, not an array or a list. Let's look at an example of the limitations of the <code>JsonUtility</code> class:</p>
			<ol>
				<li value="1">Create a new<a id="_idIndexMarker888"/> C# script in the <code>Scripts</code> folder, name it <code>TeamData</code>, and add the following to this script. As shown in the following code, this class has two fields, a <code>PlayerData</code> list and a dictionary:<pre>using System.Collections.Generic;
public class TeamData
{
    public <strong class="bold">List&lt;PlayerData&gt;</strong> Players;
    public <strong class="bold">Dictionary&lt;string, PlayerData&gt;</strong> Roles;
    public TeamData()
    {
        Players = new List&lt;PlayerData&gt;();
        Roles = new Dictionary&lt;string, PlayerData&gt;();
    }
}</pre></li>
				<li>Next, we also <a id="_idIndexMarker889"/>need to create another C# script in the same folder and name it <code>JsonUtilityLimitationsSample</code>. The code in <code>JsonUtilityLimitationsSample</code> is as follows. In the <code>Start</code> method, we create a new <code>TeamData</code> object, add an element to the <code>Players</code> list, and add a key and value to the <code>Roles</code> dictionary. Then, call the <code>JsonUtility.ToJson</code> method to serialize this object into a JSON string and print the string to the <strong class="bold">Console</strong> window:<pre>using UnityEngine;
public class JsonUtilityLimitationsSample :
  MonoBehaviour
{
    private void Start()
    {
        var playerData = new PlayerData("player1", 50,
          100, 100);
        var teamData = new TeamData();
        teamData.Players.Add(playerData);
        teamData.Roles.Add("leader", playerData);
        var jsonStringFromTeamData =
          JsonUtility.ToJson(teamData);
        Debug.Log(jsonStringFromTeamData);
    }
}</pre></li>
				<li>Run the game<a id="_idIndexMarker890"/> in the editor; you can find that only the <code>Players</code> list is serialized, but the <code>Roles</code> dictionary is not serialized as expected, as shown in the following screenshot. This is because <code>JsonUtility</code> does not support serializing dictionaries in Unity.</li>
			</ol>
			<div><div><img src="img/Figure_10.14_B17146.jpg" alt="Figure 10.14 – The Roles dictionary is not serialized&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14 – The Roles dictionary is not serialized</p>
			<ol>
				<li value="4">Then, let's go back to <code>JsonUtilityLimitationsSample</code> and update the code in the <code>Start</code> method to try to serialize the <code>Players</code> list individually:<pre>public class JsonUtilityLimitationsSample :
  MonoBehaviour
{
    private void Start()
    {
        // No Change
        var jsonStringFromList =
          JsonUtility.ToJson(<strong class="bold">teamData.Players</strong>);
        Debug.Log(jsonStringFromList);
    }
}</pre></li>
				<li>Run the <a id="_idIndexMarker891"/>game in the editor again and you will find that the <code>Players</code> list is not serialized this time, as shown in the following screenshot. This is because if using <code>JsonUtility</code> for serialization, the root element must be an object, not an array or list.</li>
			</ol>
			<div><div><img src="img/Figure_10.15_B17146.jpg" alt="Figure 10.15 – The Players list is not serialized&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – The Players list is not serialized</p>
			<h4>Newtonsoft.Json framework</h4>
			<p>It is a real headache to encounter the problems mentioned in the preceding example during development, so some other JSON frameworks may also be worth trying. Next, we will use <code>Newtonsoft.Json</code> to <a id="_idIndexMarker892"/>modify the preceding example so that the <code>Roles</code> dictionary in the <code>TeamData</code> class and the individual <code>Players</code> list can be serialized into JSON strings correctly: </p>
			<ol>
				<li value="1">First, if the <a id="_idIndexMarker893"/><code>Newtonsoft.Json</code> package is not installed in your project, you can install it through Unity's Package Manager. You can open it by clicking the <strong class="bold">Window | Package Manager</strong> item in the toolbar.</li>
			</ol>
			<div><div><img src="img/Figure_10.16_B17146.jpg" alt="Figure 10.16 – Opening Package Manager&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.16 – Opening Package Manager</p>
			<ol>
				<li value="2">Then, click the <strong class="bold">+</strong> in the upper-left corner to open the drop-down menu, and select the <strong class="bold">Add package from git URL…</strong> item in the drop-down menu.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.17_B17146.jpg" alt="Figure 10.17 – Add package from git URL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.17 – Add package from git URL</p>
			<ol>
				<li value="3">Enter <code>com.unity.nuget.newtonsoft-json</code> in the input box that appears, click the <strong class="bold">Add</strong> button, and wait for Package Manager to install this package.</li>
			</ol>
			<div><div><img src="img/Figure_10.18_B17146.jpg" alt="Figure 10.18 – Adding Newtonsoft.Json&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.18 – Adding Newtonsoft.Json</p>
			<ol>
				<li value="4">After installing the <a id="_idIndexMarker894"/>package in the project, we can use the <code>Newtonsoft.Json</code> framework in our C# script, so let's go back to <code>JsonUtilityLimitationsSample.cs</code> and update the code:<pre>using UnityEngine;
<strong class="bold">using Newtonsoft.Json;</strong>
public class JsonUtilityLimitationsSample :
  MonoBehaviour
{
    private void Start()
    {
      var playerData = new PlayerData("player1", 50,
        100, 100);
      var teamData = new TeamData();
      teamData.Players.Add(playerData);
      teamData.Roles.Add("leader", playerData);
      var jsonStringFromTeamData =
        <strong class="bold">JsonConvert.SerializeObject(teamData);</strong>
      Debug.Log(jsonStringFromTeamData);
      var jsonStringFromList =
        <strong class="bold">JsonConvert.SerializeObject(teamData.Players);</strong>
      Debug.Log(jsonStringFromList);
    }
}</pre></li>
			</ol>
			<p>Let's break down the code as follows:</p>
			<ul>
				<li>We add <a id="_idIndexMarker895"/>the <code>Newtonsoft.Json</code> namespace with the <code>using</code> keyword, which provides classes and methods for JSON serialization and deserialization.</li>
				<li>In the <code>Start</code> method, we replace the <code>JsonUtility.ToJson</code> method with the <code>JsonConvert.SerializeObject</code> method that is defined in the <code>Newtonsoft.Json</code> namespace.</li>
			</ul>
			<ol>
				<li value="5">Run the game. You will find that the <code>Roles</code> dictionary field of the <code>TeamData</code> object is serialized as expected, while the <code>Players</code> list as the root element is also serialized correctly.</li>
			</ol>
			<p class="figure-caption">   </p>
			<div><div><img src="img/Figure_10.19_B17146.jpg" alt="Figure 10.19 – Newtonsoft.Json works correctly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.19 – Newtonsoft.Json works correctly</p>
			<p>In this section, we have explained what Unity's serialization system is and how to use JSON serialization in your Unity project. Now I think you're ready to continue exploring how assets in your game project are managed by the Unity engine!</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor186"/>The assets workflow in Unity</h1>
			<p>Unity's assets<a id="_idIndexMarker896"/> workflow is another very interesting topic that is also very closely related to serialization. So, what is an <code>asset</code> in Unity? If you look at a Unity project, you will find that there is a folder called <code>Assets</code> in the root directory of this project, and an asset is a file stored in this folder. </p>
			<p>In Unity development, assets can be divided into the following two categories according to their sources: </p>
			<ul>
				<li>External assets that are imported into Unity; the most common in this case are <code>models,</code> <code>textures,</code> and <code>audio</code>. They are often created by third-party tools, such as <code>Maya,</code> <code>3Ds Max,</code> and <code>Photoshop</code>, and then imported into Unity for use. </li>
				<li>Assets created by Unity itself, such as <code>Prefab</code> and <code>Scene</code> files.</li>
			</ul>
			<p>Whether it's an imported asset or an asset created by Unity, Unity does the following three things with them:</p>
			<ol>
				<li value="1">Unity will assign a GUID to this asset.</li>
				<li>Then, a meta file will be created automatically by Unity to store some additional information about the asset, such as the GUID and the import settings of this asset. <em class="italic">Figure 10.20</em> shows an example of an automatically created meta file. When a PNG file named <code>SampleTexture</code> is imported into the Unity project, Unity automatically creates a meta file and names it <code>SampleTexture.PNG.meta</code>.</li>
			</ol>
			<div><div><img src="img/Figure_10.20_B17146.jpg" alt="Figure 10.20 – A meta file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.20 – A meta file</p>
			<ol>
				<li value="3">Finally, Unity will <a id="_idIndexMarker897"/>process the asset file, convert its content into an internal representation in Unity, and store the internal representation in the <code>Library</code> folder in the project root. We will cover this in detail when we introduce the <code>Library</code> folder later.</li>
			</ol>
			<div><div><img src="img/Figure_10.21_B17146.jpg" alt="Figure 10.21 – The Library folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.21 – The Library folder</p>
			<p>Armed with an understanding of Unity's assets workflow, let's introduce the three things involved in this workflow in more detail: GUID and File ID, meta files, and the <code>Libary</code> folder.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>GUID and File ID</h2>
			<p>GUID<a id="_idIndexMarker898"/> and File ID are obviously an important topic when we discuss Unity's asset workflow. This is<a id="_idIndexMarker899"/> because no matter whether we use Unity to create an asset or import an external asset, Unity has to uniquely identify this asset, and this unique value is the GUID. File ID is often used together with GUID; it is not used to identify an asset like GUID, but is used to identify a reference to another object within an object. </p>
			<p>Now that we have a brief understanding of GUID and File ID, it's time to move on to exploring GUID and File ID in more detail!</p>
			<h3>GUID</h3>
			<p>As we just mentioned, Unity assigns a GUID<a id="_idIndexMarker900"/> to each asset in the <code>Assets</code> folder as the asset's <a id="_idIndexMarker901"/>identifier. We can use a text editor to open the meta file associated with this asset to find the GUID of this asset within the Unity engine.</p>
			<p>Let's now perform the following steps to create a new C# script as an asset and check the <code>GUID</code> of this C# script in Unity:</p>
			<ol>
				<li value="1">Create a new C# script in the <code>Scripts</code> folder, name it <code>AssetSample</code>, and add the following to this script. As shown in the following code, this class has a <code>Texture</code> field:<pre>public class AssetSample : MonoBehaviour
{
    [SerializeField]
    private <strong class="bold">Texture _texture</strong>;
}</pre></li>
				<li>A meta file called <code>AssetSample.cs.meta</code> is created next to the C# script file in the file explorer, as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.22_B17146.jpg" alt="Figure 10.22 – The AssetSample.cs.meta file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.22 – The AssetSample.cs.meta file</p>
			<ol>
				<li value="3">Open <a id="_idIndexMarker902"/>the <code>AssetSample.cs.meta</code> file in a text editor, and you will discover that the <a id="_idIndexMarker903"/>GUID of this C# script asset in Unity is <code>e35f96b75211edd4bad6451a26675090</code>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_10.23_B17146.jpg" alt="Figure 10.23 – The GUID of this C# script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.23 – The GUID of this C# script</p>
			<p>After reading this, you should know how to find the GUID of an asset in Unity; however, where is the File ID stored, and how does Unity use it to create and maintain references between objects? So, let's continue our journey with another example.</p>
			<h3>File ID</h3>
			<p>We mentioned earlier that Unity<a id="_idIndexMarker904"/> uses a <code>File ID</code> to refer to another object within an <a id="_idIndexMarker905"/>object, which is the unique ID of the object referenced within that object. </p>
			<p>Now, let's take a look at an example to learn how to find the <code>File IDs</code> and how Unity uses the <code>File IDs</code> to maintain the reference relationship between objects. In this example, we will still use the <code>AssetSample</code> script we just created, so now let's get started!</p>
			<ol>
				<li value="1">First, create a new GameObject in the Scene and name it <code>AssetSampleGameObject</code>. You already know that a <code>Transform</code> component is automatically created and attached to this GameObject, as shown in <em class="italic">Figure 10.24</em>:</li>
			</ol>
			<div><div><img src="img/Figure_10.24_B17146.jpg" alt="Figure 10.24 – Creating an AssetSampleGameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.24 – Creating an AssetSampleGameObject</p>
			<ol>
				<li value="2">Attach an <code>AssetSample</code> component to <code>AssetSampleGameObject</code>, and then assign a texture from the <code>Texture</code> field of <code>AssetSample</code>. Then, attach another <code>AssetSample</code> component to the same GameObject; however, this time, we set the <code>AssetSample</code> to <strong class="bold">None</strong> and save the Scene.</li>
			</ol>
			<div><div><img src="img/Figure_10.25_B17146.jpg" alt="Figure 10.25 – Adding AssetSample components to the GameObject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.25 – Adding AssetSample components to the GameObject</p>
			<ol>
				<li value="3">Make sure your<a id="_idIndexMarker906"/> project's <strong class="bold">Asset Serialization</strong> mode <a id="_idIndexMarker907"/>is now <strong class="bold">Force Text</strong> (we covered this topic in the <em class="italic">YAML and binary serialization in Unity </em>section), and then use a text editor to open the Scene file from <strong class="bold">File Explorer</strong>. You will see a lot of content in the Scene file, as shown in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.26_B17146.jpg" alt="Figure 10.26 – Opening the Scene file in a text editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.26 – Opening the Scene file in a text editor</p>
			<p>This file gives us a lot of<a id="_idIndexMarker908"/> information, recording the GameObjects, components, and <a id="_idIndexMarker909"/>referenced assets in the Scene. So let's break it down:</p>
			<ul>
				<li>First of all, we can find the record of the GameObject called <code>AssetSampleGameObject</code> in the file. In the following screenshot, you can see that there are three components attached to this GameObject, with File IDs of <code>306521988</code>, <code>306521989</code>, and <code>306521990</code>, respectively:</li>
			</ul>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.27_B17146.jpg" alt="Figure 10.27 – The AssetSampleGameObject record&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.27 – The AssetSampleGameObject record</p>
			<ul>
				<li>If we search<a id="_idIndexMarker910"/> these three <code>File IDs</code>, we can find records for three<a id="_idIndexMarker911"/> components in this file – a <code>Transform</code> component, which is created and attached to this GameObject when the GameObject is created, and two <code>MonoBehaviour</code> components, which represent C# script components.</li>
			</ul>
			<div><div><img src="img/Figure_10.28_B17146.jpg" alt="Figure 10.28 – File IDs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.28 – File IDs</p>
			<ul>
				<li>So, what is the difference between File ID and GUID? If we focus on these two <code>MonoBehaviour</code> components, we can see that the <code>m_Script</code> field of both components references the same C# script with a GUID of <code>e35f96b75211edd4bad6451a26675090</code>.</li>
			</ul>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.29_B17146.jpg" alt="Figure 10.29 – The MonoBehaviour components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.29 – The MonoBehaviour components</p>
			<p>Therefore, we <a id="_idIndexMarker912"/>can find that although these two component objects <a id="_idIndexMarker913"/>refer to the same C# script, namely, <code>AssetSample</code>, they are two different instances of <code>AssetSample</code>; the file ID of the first <code>MonoBehaviour</code> component object is <code>306521989</code>, and the file ID of the second <code>MonoBehaviour</code> component object is <code>306521990</code>.</p>
			<p>Moreover, the <code>_texture</code> field of one instance refers to a texture asset, and the <code>_texture</code> field of the other instance does not refer to any texture asset. </p>
			<p>By reading this section, we learned that Unity uses GUID to identify an asset and File ID to identify a referenced object.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor188"/>Meta files</h2>
			<p>We already <a id="_idIndexMarker914"/>know that a meta <a id="_idIndexMarker915"/>file records the GUID of its associated asset in a Unity project, and that a meta file also records the import settings of this asset. In this section, we will talk about meta files that look inconspicuous but are actually very important.</p>
			<h3>Meta files and version management</h3>
			<p>A common mistake developers new to Unity make is not paying attention to these autogenerated meta files. One such example is ignoring meta files when using Git or other version control<a id="_idIndexMarker916"/> systems to manage the version of the Unity project. </p>
			<p>If you remember from the previous section, Unity assigns each asset a GUID, uses this GUID to identify the asset, and records this GUID in the meta file. </p>
			<p>So, if your version management system does not include meta files, your Unity development progress may be disrupted. </p>
			<p>To illustrate this, let's imagine a scenario where, when a Unity project that does not contain meta files is cloned from a remote repository to your colleague's local machine, the Unity Editor will reimport those assets and assign them new GUIDs and create meta files to store this information. As a result, references that previously existed between objects in your Unity project will <a id="_idIndexMarker917"/>no longer be valid.</p>
			<p>As an example, assuming that the <code>AssetSample.cs.meta</code> meta file of the <code>AssetSample</code> C# script we created earlier is not managed by the version management system, then you will encounter the <code>Script Missing</code> error, as shown in <em class="italic">Figure 10.30</em>, after cloning and opening the project on another computer:</p>
			<div><div><img src="img/Figure_10.30_B17146.jpg" alt="Figure 10.30 – The Script Missing error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.30 – The Script Missing error</p>
			<p>At this point, the script actually exists, but since its GUID has been regenerated, the previous reference relationship is invalid.</p>
			<p>Therefore, when developing a Unity project, please make sure that the meta files are managed by your version management tool.</p>
			<h3>Import settings in meta files</h3>
			<p>In addition to<a id="_idIndexMarker918"/> storing the GUID of an asset, a meta file also stores the import settings of this asset. Of course, the meta files that will be discussed in this subsection mainly refer to the meta files of assets created in third-party software and that are then imported into the Unity Editor, such as models, textures, and audio.</p>
			<p>Let's use a meta file of an audio asset as an example to see how the import settings of the asset are saved.</p>
			<p>The audio asset we are using here is from Unity's Asset Store and you can download it from here: <a href="https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047">https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047</a>.</p>
			<div><div><img src="img/Figure_10.31_B17146.jpg" alt="Figure 10.31 – Audio pack&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.31 – Audio pack</p>
			<p>After importing the <a id="_idIndexMarker919"/>audio into the Unity project, we can select the first audio file in the <code>Ultra SF Game Audio Weapons Pack v.1</code> folder to open the audio's Inspector window in the Unity Editor, which shows the asset's import settings. Then we use a text editor to open the meta file of the same audio asset in the folder explorer and, as shown in <em class="italic">Figure 10.32</em>, we can see that <code>AudioImporter</code> in the meta file corresponds to the import settings in the editor:</p>
			<div><div><img src="img/Figure_10.32_B17146.jpg" alt="Figure 10.32 – WPN_SCI-FI_FIRE_01 audio's import settings and meta file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.32 – WPN_SCI-FI_FIRE_01 audio's import settings and meta file</p>
			<p>The import settings of a texture asset and a model asset are also stored in their meta files. The following screenshot shows the import settings for a texture and a model:</p>
			<div><div><img src="img/Figure_10.33_B17146.jpg" alt="Figure 10.33 – Import settings of a texture (left) and the import settings of a model (right)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.33 – Import settings of a texture (left) and the import settings of a model (right)</p>
			<p>Since the meta file <a id="_idIndexMarker920"/>stores the import settings of the asset, once we modify the import settings of the asset in the Unity Editor, the corresponding meta file will be updated. </p>
			<p>The import settings often affect how Unity processes these assets, so it is important to ensure that the import settings can be managed according to the requirements of the project. For example, in many mobile game projects, we should check the <strong class="bold">Force To Mono</strong> option on the audio import settings to reduce the memory usage of this audio file.</p>
			<p>Next, let's take a look at how to manage import settings through a C# script in Unity.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor189"/>The AssetPostprocessor class and the import pipeline</h2>
			<p>Unity provides<a id="_idIndexMarker921"/> the <code>AssetPostprocessor</code> class for game developers to <a id="_idIndexMarker922"/>hook into the assets import pipeline in Unity. When importing an asset, we can manage the import pipeline according to the asset type.</p>
			<p>In the following example, we will create a new C# script to set the <strong class="bold">Force To Mono</strong> option enabled in the import settings of all audio files in the Unity projec:</p>
			<ol>
				<li value="1">Create a subfolder in the <code>Scripts</code> folder and name it <code>Editor</code>. This is because the C# class that we will create inherits from the <code>AssetPostprocessor</code> class, which is a class for the editor, so it needs to be placed in an <code>Editor</code> folder. </li>
			</ol>
			<div><div><img src="img/Figure_10.34_B17146.jpg" alt="Figure 10.34 – Creating an Editor folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.34 – Creating an Editor folder</p>
			<ol>
				<li value="2">Double-click on the <code>Editor</code> folder to enter it, create a new C# script in this folder, name<a id="_idIndexMarker923"/> it <code>AssetImporterSample</code>, and then add the following to this script:<pre>using <strong class="bold">UnityEditor</strong>;
public class AssetImporterSample : <strong class="bold">AssetPostprocessor</strong>
{
    private void <strong class="bold">OnPreprocessAudio</strong>()
    {
        var audioImporter =
          <strong class="bold">(AudioImporter)</strong>assetImporter;
        if(audioImporter == null)
        {
            return;
        }
        audioImporter.<strong class="bold">forceToMono</strong> = true;
        audioImporter.SaveAndReimport();
    }
}</pre></li>
			</ol>
			<p>Let's break down how this works:</p>
			<ul>
				<li>First, the code is using the <code>UnityEditor</code> namespace. This is because the <code>AssetPostprocessor</code> class is defined in this namespace, which also means <a id="_idIndexMarker924"/>that the <code>AssetImporterSample</code> C# script is used in the Unity Editor and not at runtime.</li>
				<li>The <code>AssetImporterSample</code> class inherits the <code>AssetPostprocessor</code> class and implements the <code>OnPreprocessAudio</code> method, which will be called before the audio asset is imported. We can also implement other similar methods to be called when other asset types will be imported. For example, the <code>OnPreprocessTexture</code> method will be called before the texture asset is imported, and the <code>OnPreprocessModel</code> method will be called before the model asset is imported.</li>
				<li>In the <code>OnPreprocessAudio</code> method, we can get an instance of <code>AudioImporter</code>, set the <code>forceToMono</code> option to <code>true</code>, and then save and re-import the asset to ensure that the new import settings for the asset take effect.</li>
			</ul>
			<ol>
				<li value="3">Save the C# script and the Unity Editor should modify the import settings of these audio assets in the project and then re-import them, as shown in <em class="italic">Figure 10.35</em>:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.35_B17146.jpg" alt="Figure 10.35 – Importing audio assets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.35 – Importing audio assets</p>
			<ol>
				<li value="4">Let's now select an audio file to check its import settings. As shown in <em class="italic">Figure 10.36</em>, the new import settings work as expected:</li>
			</ol>
			<div><div><img src="img/Figure_10.36_B17146.jpg" alt="Figure 10.36 – New import settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.36 – New import settings</p>
			<p>In this subsection, we introduced how to use C# code to manage the asset import pipeline. Next, let's explore another assets workflow topic in Unity – the <code>Library</code> folder. </p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor190"/>The Library folder</h2>
			<p>In a <a id="_idIndexMarker925"/>Unity project, Unity will process and convert the external assets into Unity internal format assets and save them in<a id="_idIndexMarker926"/> the <code>Library</code> folder. Because the data stored in the <code>Library</code> folder is cached data that can always be regenerated from the source asset files based on the import settings, the <code>Library</code> folder should generally not be included in a version management system.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In addition to the <code>Library</code> folder, there are some other Unity folders that need to be excluded from version management, including <code>Temp, Obj, </code>and <code>Logs</code>. If you are using Git as your version management tool, you can find the <code>.gitignore</code> file for Unity projects at this link: <a href="https://github.com/github/gitignore/blob/main/Unity.gitignore">https://github.com/github/gitignore/blob/main/Unity.gitignore</a>.</p>
			<p>You can find the <code>Library</code> folder in <a id="_idIndexMarker927"/>the root directory of your Unity project, as shown in <em class="italic">Figure 10.37</em>. If there is no <code>Libary</code> folder in the root directory of your Unity project, you need to open the project with the Unity Editor. The Unity Editor will import the assets in the <code>Assets</code> folder and generate the <code>Library</code> folder automatically.</p>
			<div><div><img src="img/Figure_10.37_B17146.jpg" alt="Figure 10.37 – The Library folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.37 – The Library folder</p>
			<p>Double-click the <code>Library</code> folder to enter it and you will see the <code>ScriptAssemblies</code> subfolder, which saves the assemblies of the C# code in the project, and you can also see the <code>PackageCache</code> subfolder, which saves the cache of Unity packages used by the project. In addition to these, you also can see the <code>Artifacts</code> subfolder, where the assets processed by Unity are saved.</p>
			<div><div><img src="img/Figure_10.38_B17146.jpg" alt="Figure 10.38 – The Artifacts folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.38 – The Artifacts folder</p>
			<p>In this section, we introduced Unity's assets workflow, covering topics such as GUIDs, File IDs, meta files, and the <code>Library</code> folder. Next, let's take a look at the special folders created and managed by developers related to assets management in Unity.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor191"/>Introducing the special folders in Unity</h1>
			<p>We already covered some of these special folders related to scripting in Unity in <a href="B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025"><em class="italic">Chapter 2</em></a>, <em class="italic">Scripting Concepts in Unity</em>. In this section, we will introduce the remaining special folders, which are related to asset management in Unity.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>Resources folder</h2>
			<p>First, let's take a look at<a id="_idIndexMarker928"/> the <code>Resources</code> folder in Unity. <code>Resources</code> is a special folder name in Unity, but Unity does not automatically create a <code>Resources</code> folder for you. If you want to use a <code>Resources</code> folder to manage assets, you need to create it yourself. It should be noted that there can be multiple <code>Resources</code> folders in the <code>Assets</code> directory in a Unity project.</p>
			<p>Unity provides the <code>Resources.Load</code> method to load assets in <code>Resources</code> folders. Next, we will use an example to learn how to use <code>Resources</code> folders to manage assets:</p>
			<ol>
				<li value="1">Create a new <a id="_idIndexMarker929"/>folder named <code>Resources</code> by clicking the <strong class="bold">Create | Folder</strong> item in the <strong class="bold">Project</strong> window.</li>
			</ol>
			<div><div><img src="img/Figure_10.39_B17146.jpg" alt="Figure 10.39 – Creating a Resources folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.39 – Creating a Resources folder</p>
			<ol>
				<li value="2">Create an empty GameObject, name it <code>SamplePrefab</code>, and drag it into the <code>Resources</code> folder to create a new prefab, as shown in <em class="italic">Figure 10.40</em>:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.40_B17146.jpg" alt="Figure 10.40 – SamplePrefab &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.40 – SamplePrefab </p>
			<ol>
				<li value="3">Create a new<a id="_idIndexMarker930"/> C# script in the <code>ResourcesLoadExample</code>, and add the following to this script:<pre>using UnityEngine;
public class ResourcesLoadExample : MonoBehaviour
{
    private GameObject _gameObjectInstance;
    private void Start()
    {
        var samplePrefab =
          <strong class="bold">Resources.Load&lt;GameObject&gt;("SamplePrefab");</strong>
        if(samplePrefab != null)
        {
            _gameObjectInstance =
              Instantiate(samplePrefab);
        }
    }
}</pre></li>
			</ol>
			<p>Let's break<a id="_idIndexMarker931"/> down how this works:</p>
			<ol>
				<li>In the <code>Start</code> method, we call the <code>Resources.Load</code> method and pass the path to the asset to load as an argument to this method, which is <code>SamplePrefab</code>.</li>
				<li>Then, if the prefab asset is loaded, we instantiate it to create a new GameObject in the game Scene.</li>
			</ol>
			<ol>
				<li value="4">Create a new GameObject and attach the <code>ResourcesLoadExample</code> script to it. Run the game in the Unity Editor by clicking the <strong class="bold">Play</strong> button. We can see that a new instance of the prefab is created as expected.</li>
			</ol>
			<div><div><img src="img/Figure_10.41_B17146.jpg" alt="Figure 10.41 – Loading assets from the Resources folders&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.41 – Loading assets from the Resources folders</p>
			<p>Through this example, we see that using <code>Resources</code> folders to manage assets is very convenient, especially when you need to develop a prototype quickly, but managing assets in a Unity project by using <code>Resources</code> folders is not recommended for the following reasons:</p>
			<ul>
				<li>When the <a id="_idIndexMarker932"/>Unity Editor builds the game, the assets in <code>Resources</code> folders will be included in the build, even if the assets are not used, so improper use of the <code>Resources</code> folder may cause the build game to be too large. In addition, it will also affect the game's startup speed.</li>
				<li>Using <code>Resources</code> folders will make incremental content upgrades to the game very difficult or impossible.</li>
			</ul>
			<p>Now that we have an understanding of the <code>Resources</code> folders, we know the situations in which they will be suitable, such as developing a rapid prototype, as well as its limitations.</p>
			<p>Next, we will continue to introduce another special folder in Unity, namely, <code>StreamingAssets</code></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor193"/>StreamingAssets folder</h2>
			<p>In Unity, <code>StreamingAssets</code> is also <a id="_idIndexMarker933"/>a special folder name. We actually already covered this in <a href="B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating Audio and Video in a Unity Project</em>. In this subsection, we will discuss it in more detail.</p>
			<p>We mentioned earlier that Unity will process assets in the <code>Assets</code> folder in a format that the Unity engine understands, but there is an exception. </p>
			<p>The assets in the <code>StreamingAssets</code> folder in the Unity project will still be in the original format and these assets will not be built into the game along with the other assets when Unity builds the game. Instead, all assets in the folder will be copied to a specific folder on the target device. </p>
			<p>Since the location of this special folder is different on different platforms, Unity provides the <code>Application.streamingAssetsPath</code> property so that we can access the correct path to this folder from C# code. </p>
			<p>The following code <a id="_idIndexMarker934"/>snippet is from the example used in <a href="B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating Audio and Video in a Unity Project</em>. We can see how to use <code>Application.streamingAssetsPath</code> in C# code:</p>
			<pre>    public void OnClickSetVideoURL()
    {
        _videoPlayer.url =
          Path.Combine(<strong class="bold">Application.streamingAssetsPath</strong>,
          _videoFileName);
    }</pre>
			<p>Similar<a id="_idIndexMarker935"/> to the <code>Resources</code> folder, Unity does not automatically create the <code>StreamingAssets</code> folder for you. If you wish to use it, you need to create it yourself, as shown in <em class="italic">Figure 10.42</em>:</p>
			<div><div><img src="img/Figure_10.42_B17146.jpg" alt="Figure 10.42 – Creating a StreamingAssets folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.42 – Creating a StreamingAssets folder</p>
			<p>Then we can place an audio WAV file in the <code>StreamingAssets</code> folder. As you can see from the following screenshot, the icon of this WAV file is not the same as the icon of an audio clip in Unity that we are already familiar with. This is because Unity does not process the WAV file; it still maintains its original format.</p>
			<div><div><img src="img/Figure_10.43_B17146.jpg" alt="Figure 10.43 – Placing a WAV file in the StreamingAssets folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.43 – Placing a WAV file in the StreamingAssets folder</p>
			<p>In this section, we explored the <code>Resources</code> folder and the <code>StreamingAssets</code> folder, which are special folders in Unity, and understood that what they do can help you better develop games with Unity. </p>
			<p>Next, we'll cover another interesting topic; how to use Azure Blob storage in the Azure Cloud with Unity's Addressable Asset system.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor194"/>Azure Blob storage with Unity's Addressable Asset system</h1>
			<p>In this section, we'll cover the Azure Blob storage service in Microsoft's Azure Cloud and how to use it with Unity's Addressable Asset system.</p>
			<p><strong class="bold">Azure Blob storage</strong> is a<a id="_idIndexMarker936"/> type of Azure Storage account in Azure. Other types of Azure Storage<a id="_idIndexMarker937"/> accounts include <strong class="bold">queues</strong>, <strong class="bold">file shares</strong>, and <strong class="bold">tables</strong>. Among them, Blob<a id="_idIndexMarker938"/> storage is very suitable for storing large amounts of <a id="_idIndexMarker939"/>unstructured data such as binary data.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find additional information and resources about the Azure Storage account<a id="_idIndexMarker940"/> in Microsoft's Azure Cloud at <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction">https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction</a>.</p>
			<p>Unity's Addressable Asset system, as the name suggests, provides a convenient method for loading specific assets, whether on the local or remote server, according to a specific address. When discussing the <code>Resources</code> folder in the previous section, we discussed various limitations when using it in terms of managing assets, and the Addressable Asset system can solve these problems very well; for example, the size of the game package can be well controlled, there is no need to include unnecessary assets in game builds, and assets can be hosted on remote servers, such as the Azure Cloud, to incrementally update assets within the game.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before the Addressable Asset system was introduced, developers could also use <code>AssetBundles</code> to manage<a id="_idIndexMarker941"/> assets; <code>AssetBundles</code> is beyond the scope of what we need here, but if you're interested, you can find out more at <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html">https://docs.unity3d.com/Manual/AssetBundlesIntro.html</a>.</p>
			<p>Well, now we have an understanding of Azure Blob storage and the Addressable Asset system. Next, we will explore how to use Azure Blob storage to host assets and use the Addressable Asset system to manage them.</p>
			<p>Let's start!</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor195"/>Setting up an Azure Blob storage service</h2>
			<p>First, make sure<a id="_idIndexMarker942"/> you have an available Azure subscription. You can apply for a free Azure trial account on the page introduced at the beginning of this chapter. </p>
			<p>If everything is ready, we can create our first resource in Azure, namely, an <strong class="bold">Azure resource group</strong>.</p>
			<h3>Creating a new resource group</h3>
			<p>Usually, a resource<a id="_idIndexMarker943"/> group is our first resource in the Azure Cloud. This is because a resource group is a container for holding other Azure resources.</p>
			<p>We can create a resource group in just a few steps:</p>
			<ol>
				<li value="1">Sign in to the Azure portal page with your account at <a href="https://portal.azure.com/">https://portal.azure.com/</a>.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.44_B17146.jpg" alt="Figure 10.44 – Azure portal page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.44 – Azure portal page</p>
			<ol>
				<li value="2">The <a id="_idIndexMarker944"/>Azure portal page does not display the portal menu by default. We can click the <strong class="bold">Show portal menu</strong> button in the upper-left corner of the page to open the portal menu.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.45_B17146.jpg" alt="Figure 10.45 – Show portal menu&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.45 – Show portal menu</p>
			<ol>
				<li value="3">Select <strong class="bold">Resource groups</strong> from the portal menu.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.46_B17146.jpg" alt="Figure 10.46 – Selecting the Resource groups service&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.46 – Selecting the Resource groups service</p>
			<ol>
				<li value="4">The <a id="_idIndexMarker945"/><strong class="bold">Resource groups</strong> page will then open. Click the <strong class="bold">Create</strong> button on this page, as shown in <em class="italic">Figure 10.47</em>:</li>
			</ol>
			<div><div><img src="img/Figure_10.47_B17146.jpg" alt="Figure 10.47 – Creating a resource group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.47 – Creating a resource group</p>
			<ol>
				<li value="5">Then, you will see the <code>rg-unitybook-dev-001</code>. Select the region of the resource group as <code>(Asia Pacific) Australia East</code> and then click on <strong class="bold">Review + create</strong> to verify the settings of this resource group and create it, as shown in <em class="italic">Figure 10.48</em>:</li>
			</ol>
			<div><div><img src="img/Figure_10.48_B17146.jpg" alt="Figure 10.48 – Creating a resource group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.48 – Creating a resource group</p>
			<p>We've <a id="_idIndexMarker946"/>created a resource group in Azure. Next, let's create an Azure Storage account resource.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find additional information about the naming convention in Microsoft's Azure Cloud at <a href="https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming">https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming</a>.</p>
			<h3>Creating a new Azure Storage account resource</h3>
			<p>In order to set up an <a id="_idIndexMarker947"/>Azure Blob storage service, we will need to create an Azure Storage account to provide a unique namespace in Azure for the assets that will be hosted first. </p>
			<p>We will perform the following steps:</p>
			<ol>
				<li value="1">Go back to the <a id="_idIndexMarker948"/>Azure portal page, repeat the steps introduced previously to open the portal menu, and then click <strong class="bold">Storage accounts</strong> this time, as shown in <em class="italic">Figure 10.49</em>:</li>
			</ol>
			<div><div><img src="img/Figure_10.49_B17146.jpg" alt="Figure 10.49 – Clicking Storage accounts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.49 – Clicking Storage accounts</p>
			<ol>
				<li value="2">The Storage accounts page will then open. Click the <strong class="bold">Create</strong> button on this page, as shown in <em class="italic">Figure 10.50</em>:</li>
			</ol>
			<p class="figure-caption"><code> </code></p>
			<div><div><img src="img/Figure_10.50_B17146.jpg" alt="Figure 10.50 – Creating a storage account&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.50 – Creating a storage account</p>
			<ol>
				<li value="3">Similar to creating a resource group, on the <code>unitybookchapter10</code> and <code>(Asia Pacific) Australia East</code>, respectively. The <a id="_idIndexMarker949"/>other settings can be left as their defaults, and then click the <strong class="bold">Review + create</strong> button to create the resource.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.51_B17146.jpg" alt="Figure 10.51 – Creating a storage account&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.51 – Creating a storage account</p>
			<ol>
				<li value="4">We can<a id="_idIndexMarker950"/> click the notifications button in the upper-right corner of the page to view the progress of the resource deployment. When the resource is deployed, we can click <strong class="bold">Go to resource</strong> to go to the resource page.</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_10.52_B17146.jpg" alt="Figure 10.52 – Notifications&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.52 – Notifications</p>
			<ol>
				<li value="5">As<a id="_idIndexMarker951"/> shown in <em class="italic">Figure 10.53</em>, a Storage account named <code>unitybookchapter10</code> is created:</li>
			</ol>
			<div><div><img src="img/Figure_10.53_B17146.jpg" alt="Figure 10.53 – The Storage account page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.53 – The Storage account page</p>
			<p>At this point, we have set up a Storage account resource in Azure. Next, let's set up Blob Storage.</p>
			<h3>Creating a container</h3>
			<p>As we mentioned at the beginning of this section, Blob Storage is a type of Azure Storage account, so we can find the settings for Blob Storage on the Storage account page we just opened. We can perform the <a id="_idIndexMarker952"/>following steps to set up Blob Storage:</p>
			<ol>
				<li value="1">First, we need to create a container, similar to a directory in the filesystem on our computers, to organize a group of files, and a container to organize a group of blobs on the Azure Cloud. Scroll down the menu on the left side of the Storage account page and, in the <strong class="bold">Data storage</strong> section, we can see four different storage types. Then, select <strong class="bold">Containers</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_10.54_B17146.jpg" alt="Figure 10.54 – Selecting containers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.54 – Selecting containers</p>
			<ol>
				<li value="2">Then, click the <strong class="bold">+ Container</strong> button, as shown in <em class="italic">Figure 10.55</em>:</li>
			</ol>
			<div><div><img src="img/Figure_10.55_B17146.jpg" alt="Figure 10.55 – Clicking the + Container button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.55 – Clicking the + Container button</p>
			<ol>
				<li value="3">In the <code>remotedata</code> as the name of the container, and for simplicity, we set <strong class="bold">Public access level</strong> to <strong class="bold">Blob</strong> to allow anonymous access to blobs inside the container.</li>
			</ol>
			<div><div><img src="img/Figure_10.56_B17146.jpg" alt="Figure 10.56 – Creating a new container&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.56 – Creating a new container</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For security purposes, you should try to manage access to blobs in a more secure way, for example, by using an <strong class="bold">access key</strong> for authorization, or by using a <strong class="bold">Shared Access Signature (SAS)</strong> to <a id="_idIndexMarker953"/>delegate access. If you're interested, you can find out more at <a href="https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal">https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal</a>.</p>
			<p>Now that we have set up Azure Blob storage, we also need to use the Addressable Assets system in Unity to create asset packages and deploy them to Azure.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor196"/>Installing the Addressable Assets system package</h2>
			<p>By default, the <a id="_idIndexMarker954"/>Addressable Asset system is not available in a Unity project. So, we need to install the <code>Addressables</code> package first.</p>
			<p>As shown in <em class="italic">Figure 10.57</em>, we can find this package in Unity's Package Manager and install it in our project.</p>
			<div><div><img src="img/Figure_10.57_B17146.jpg" alt="Figure 10.57 – Installing the Addressables package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.57 – Installing the Addressables package</p>
			<p>Once installed, you<a id="_idIndexMarker955"/> can find the <strong class="bold">Addressables</strong> item in the <strong class="bold">Window</strong> menu of the Unity Editor.</p>
			<div><div><img src="img/Figure_10.58_B17146.jpg" alt="Figure 10.58 – Addressables item&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.58 – Addressables item</p>
			<p>Next, let's build addressable content by using the Addressable Assets system.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor197"/>Building addressable content </h2>
			<p>Building addressable <a id="_idIndexMarker956"/>content that can be hosted on the Azure Cloud sounds complicated, but we can break this task down further into the following tasks: </p>
			<ol>
				<li value="1">First, mark an asset as addressable.</li>
				<li>Then, enable the remote catalog.</li>
				<li>And finally, build the content.</li>
			</ol>
			<p>Now, let's move on to explore the first task.</p>
			<h3>Marking addressable assets</h3>
			<p>In the Unity <a id="_idIndexMarker957"/>Editor, we can easily mark an asset as addressable. Before we mark an addressable asset, let's create a new asset first. We can create a new cube in the Scene, name it <code>SampleContentOnAzure</code>, and drag it into the <strong class="bold">Project</strong> window to create a new prefab asset.</p>
			<p>Then, select this new prefab to open its <strong class="bold">Inspector</strong> window and you can see the <strong class="bold">Addressable</strong> checkbox in the window, as shown in <em class="italic">Figure 10.59</em>:</p>
			<div><div><img src="img/Figure_10.59_B17146.jpg" alt="Figure 10.59 – Marking an addressable asset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.59 – Marking an addressable asset</p>
			<p>By checking this checkbox, we will mark the prefab asset as addressable.</p>
			<h3>Enabling the remote catalog</h3>
			<p>Before <a id="_idIndexMarker958"/>enabling the remote catalog in the <a id="_idIndexMarker959"/>Addressable Asset settings, we can first create a new profile that defines variables such as <code>RemoteLoadPath</code>.</p>
			<h4>Creating a profile</h4>
			<p>So, let's start by creating <a id="_idIndexMarker960"/>a profile using the following steps:</p>
			<ol>
				<li value="1">In the toolbar, click on <strong class="bold">Window | Asset Management | Addressables | Profiles</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_10.60_B17146.jpg" alt="Figure 10.60 – Opening the Profiles window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.60 – Opening the Profiles window</p>
			<ol>
				<li value="2">In the <strong class="bold">Addressables Profiles</strong> window, click the <strong class="bold">Create</strong> button and select <strong class="bold">Profile</strong> in the drop-down menu to create a new profile.</li>
			</ol>
			<div><div><img src="img/Figure_10.61_B17146.jpg" alt="Figure 10.61 – Creating a new profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.61 – Creating a new profile</p>
			<ol>
				<li value="3">Then, rename this new profile to <strong class="bold">AzureCloud</strong> and enter the URL of the Azure Blob container in relation to the <strong class="bold">RemoteLoadPath</strong> variable.</li>
			</ol>
			<div><div><img src="img/Figure_10.62_B17146.jpg" alt="Figure 10.62 – Setting up the new profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.62 – Setting up the new profile</p>
			<p>If you don't know the URL<a id="_idIndexMarker961"/> of the Azure Blob container, you can find it on the container's <strong class="bold">Properties</strong> page in Azure, as shown in the following screenshot: </p>
			<div><div><img src="img/Figure_10.63_B17146.jpg" alt="Figure 10.63 – Container Properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.63 – Container Properties</p>
			<h4>Creating a new addressables group</h4>
			<p>Next, we also need to<a id="_idIndexMarker962"/> create a new <strong class="bold">addressables group</strong>, which is a container for addressable assets and their data, and can determine whether the assets within the group will be hosted on a remote server or stored locally. We can then place assets that need to be hosted on a remote server in this new group without changing the local location configured in the default group.</p>
			<p>Let's perform the following steps:</p>
			<ol>
				<li value="1">In the toolbar, click<a id="_idIndexMarker963"/> on <strong class="bold">Window | Asset Management | Addressables | Groups</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_10.64_B17146.jpg" alt="Figure 10.64 – Opening the Groups window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.64 – Opening the Groups window</p>
			<ol>
				<li value="2">In the <strong class="bold">Addressables Groups</strong> window, click the <strong class="bold">Create</strong> button, then select<strong class="bold"> Group &gt; Packed Assets</strong> to create a new group. </li>
			</ol>
			<div><div><img src="img/Figure_10.65_B17146.jpg" alt="Figure 10.65 – Creating a new group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.65 – Creating a new group</p>
			<p>Rename it to <strong class="bold">Azure Remote Group</strong>.</p>
			<div><div><img src="img/Figure_10.66_B17146.jpg" alt="Figure 10.66 – Azure Remote Group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.66 – Azure Remote Group</p>
			<ol>
				<li value="3">Change the active <a id="_idIndexMarker964"/>profile from <strong class="bold">Default</strong> to <strong class="bold">AzureCloud</strong> so that the Addressable Assets system can access the variables in <strong class="bold">AzureCloud</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_10.67_B17146.jpg" alt="Figure 10.67 – Activating the AzureCloud profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.67 – Activating the AzureCloud profile</p>
			<ol>
				<li value="4">Select the Azure remote group in the <strong class="bold">Addressables Groups</strong> window to open its <strong class="bold">Inspector</strong> window and set <strong class="bold">Content Packing &amp; Loading</strong> using the remote path defined in the <strong class="bold">AzureCloud</strong> profile.</li>
			</ol>
			<div><div><img src="img/Figure_10.68_B17146.jpg" alt="Figure 10.68 – Setting up the addressables group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.68 – Setting up the addressables group</p>
			<ol>
				<li value="5">By default, the marked addressable asset will be under <strong class="bold">Default Local Group</strong>; we need to move it to the Azure remote group we just created. </li>
			</ol>
			<div><div><img src="img/Figure_10.69_B17146.jpg" alt="Figure 10.69 – Moving the asset to Azure Remote Group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.69 – Moving the asset to Azure Remote Group</p>
			<ol>
				<li value="6">Finally, we also need to set a label, <code>Addressables.LoadResourceLocationsAsync</code> method with this key in C# code.</li>
			</ol>
			<div><div><img src="img/Figure_10.70_B17146.jpg" alt="Figure 10.70 – Setting a label&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.70 – Setting a label</p>
			<p>Now that we've set up the <a id="_idIndexMarker965"/>addressables group, next, let's move on to enable the ability to build remote content.</p>
			<h4>Enabling the Build Remote Catalog checkbox</h4>
			<ol>
				<li value="1">Back to the<a id="_idIndexMarker966"/> toolbar, click on <strong class="bold">Window | Asset Management | Addressables | Settings</strong> to open the <strong class="bold">Addressable Asset Settings</strong> window.</li>
			</ol>
			<div><div><img src="img/Figure_10.71_B17146.jpg" alt="Figure 10.71 – Opening the Addressable Asset Settings window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.71 – Opening the Addressable Asset Settings window</p>
			<ol>
				<li value="2">Scroll down<a id="_idIndexMarker967"/> the window and you will find the <strong class="bold">Content Update</strong> section. Then, check the <strong class="bold">Build Remote Catalog</strong> checkbox and set the <strong class="bold">Build Path</strong> and <strong class="bold">Load Path</strong> fields, respectively. </li>
			</ol>
			<div><div><img src="img/Figure_10.72_B17146.jpg" alt="Figure 10.72 – The Build Remote Catalog settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.72 – The Build Remote Catalog settings</p>
			<p>Now that you know how to enable the remote catalog in the Addressable Asset system, I think you're ready and can't wait to learn how to build the content. Let's go!</p>
			<h3>Building the content</h3>
			<p>It's finally <a id="_idIndexMarker968"/>time to build the content with the help of the following steps:</p>
			<ol>
				<li value="1">Go back <a id="_idIndexMarker969"/>to the <strong class="bold">Addressables Groups</strong> window, click <strong class="bold">Play Mode Script</strong>, and select <strong class="bold">Use Existing Build (requires built groups)</strong> in the drop-down menu, as shown in <em class="italic">Figure 10.73</em>:</li>
			</ol>
			<div><div><img src="img/Figure_10.73_B17146.jpg" alt="Figure 10.73 – Setting up the Play mode scripts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.73 – Setting up the Play mode scripts</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Unity provides developers with three build scripts to create play mode data. Here, we are using <strong class="bold">Use Existing Build</strong> mode, which best matches the game build deployed. You can find more information about build scripts in the Addressable Asset system at <a href="mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html">https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html</a>.</p>
			<ol>
				<li value="2">Then, click <strong class="bold">Build | New Build | Default Build Script</strong> to build the content.</li>
			</ol>
			<div><div><img src="img/Figure_10.74_B17146.jpg" alt="Figure 10.74 – Building the content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.74 – Building the content</p>
			<ol>
				<li value="3">Wait for the<a id="_idIndexMarker970"/> build to complete and then you can find the build in the <code>ServerData</code> folder in your project root.</li>
			</ol>
			<div><div><img src="img/Figure_10.75_B17146.jpg" alt="Figure 10.75 – ServerData&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.75 – ServerData</p>
			<p>Now that you know how to build addressable content in the Addressable Asset system, next, let's move on to deploy the content to the Azure Cloud.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor198"/>Deploying content to the Azure Cloud</h2>
			<p>To deploy the <a id="_idIndexMarker971"/>addressable content we just <a id="_idIndexMarker972"/>built to the Azure Cloud, follow these steps:</p>
			<ol>
				<li value="1">Navigate to the <strong class="bold">remotedata</strong> container we created in Azure and then click the <strong class="bold">Upload</strong> button.</li>
			</ol>
			<div><div><img src="img/Figure_10.76_B17146.jpg" alt="Figure 10.76 – The remotedata container page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.76 – The remotedata container page</p>
			<ol>
				<li value="2">An <strong class="bold">Upload blob</strong> panel will then appear. Select the files you want to upload and click the <strong class="bold">Upload</strong> button. </li>
			</ol>
			<div><div><img src="img/Figure_10.77_B17146.jpg" alt="Figure 10.77 – Uploading the content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.77 – Uploading the content</p>
			<ol>
				<li value="3">Wait for<a id="_idIndexMarker973"/> the upload to finish and <a id="_idIndexMarker974"/>then we can see our addressable content in the blobs list in the <strong class="bold">remotedata</strong> container.</li>
			</ol>
			<div><div><img src="img/Figure_10.78_B17146.jpg" alt="Figure 10.78 – The addressable content in Azure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.78 – The addressable content in Azure</p>
			<p>Now that you know how to deploy addressable content to the Azure Cloud, next, let's move on to exploring how to load content into your game from Azure.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor199"/>Loading addressable content from the Azure Cloud</h2>
			<p>Since we<a id="_idIndexMarker975"/> are using the Addressable<a id="_idIndexMarker976"/> Asset system to manage assets, loading content from the Azure Cloud into the game also needs to use the methods provided by the Addressable Asset system.</p>
			<p>Let's get started!</p>
			<ol>
				<li value="1">Create a<a id="_idIndexMarker977"/> new C# script in the <code>Scripts</code> folder, name<a id="_idIndexMarker978"/> it <code>LoadAddressableContentFromAzureCloud</code>, and add the following to this script:<pre>using UnityEngine;
using UnityEngine.AddressableAssets;
public class LoadAddressableContentFromAzureCloud :
  MonoBehaviour
{
    [SerializeField]
    <strong class="bold">private string _assetKey</strong>;
    private void Start()
    {
        GetContentFromAzureCloud();
    }
    private async void GetContentFromAzureCloud()
    {
        var resourceLocations = await
<strong class="bold">          Addressables.LoadResourceLocationsAsync</strong>
<strong class="bold">          (_assetKey</strong>).Task;
        foreach (var resourceLocation in
          resourceLocations)
        {
            await <strong class="bold">Addressables.InstantiateAsync</strong>
<strong class="bold">              (resourceLocation).</strong>Task;
        }
    }
}</pre></li>
			</ol>
			<p>As you can see in the code, we first provide <code>_assetKey</code>, whose value is the label of the asset we set in the previous section. Then, we call the <code>Addressables.LoadResourceLocationsAsync</code> method to load content and <code>Addressables.InstantiateAsync</code> to instantiate a GameObject. </p>
			<ol>
				<li value="2">Create a new <a id="_idIndexMarker979"/>GameObject, attach the <code>LoadAddressableContentFromAzureCloud</code> script to it, set the<a id="_idIndexMarker980"/> value of <code>Asset Key</code> to <code>Azure</code>, and then run the game in the Unity Editor by clicking the <strong class="bold">Play</strong> button. We can see that a new instance of the prefab is created as expected.</li>
			</ol>
			<div><div><img src="img/Figure_10.79_B17146.jpg" alt="Figure 10.79 – Loading the addressable content from the Azure Cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.79 – Loading the addressable content from the Azure Cloud</p>
			<p>By reading this section, you learned what the Azure Blob storage service in the Microsoft Azure Cloud is and how to use it with Unity's Addressable Asset system to host and update game content. This section also brings us to the end of the chapter!</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor200"/>Summary</h1>
			<p>We've come a long way in this chapter. We started by introducing Unity's serialization system, discussing binary serialization, YAML serialization, and JSON serialization in Unity. Then we explored the assets workflow in Unity, covering important concepts such as GUIDs, File IDs, meta files, the <code>Library</code> folder, and how to manage the assets import pipeline from C# code. Next, we discussed the <code>Resources</code> folder and the <code>StreamingAssets</code> folder in detail, which are special folders in Unity, and understood that what they do can help you better develop games with Unity. Finally, we covered quite a bit about Azure Blob storage and Unity's Addressable Asset system, from how to create an Azure Blob storage service in the Azure Cloud to how to load the addressable content from Azure into a Unity project. It's been an amazing journey!</p>
			<p>The knowledge you have acquired in this chapter will help you choose the appropriate serialization mode in Unity according to your needs, manage assets reasonably, and use the Azure Cloud to achieve incremental updates of game content.</p>
			<p>In the next chapter, we will continue this wonderful journey to explore how to create games with Unity, Microsoft Game Dev, and the Azure Cloud.</p>
		</div>
	</body></html>