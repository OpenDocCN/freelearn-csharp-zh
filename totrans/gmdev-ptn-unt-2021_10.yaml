- en: Optimizing with the Object Pool Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象池模式进行优化
- en: In most video games, there are a lot of things happening on the screen. Bullets
    are flying around, enemies are spawning around the map, particles are popping
    up around the player, and these various objects are loaded and rendered on the
    screen in the blink of an eye. So, to avoid putting strain on the **Central Processing
    Unit** (**CPU**) while maintaining a consistent frame rate, it's a good practice
    to reserve some memory for our frequently spawned entities. So, instead of releasing
    recently destroyed enemies from memory, we add them to an object pool to recycle
    them for later use. With this technique, we avoid the initial initialization cost
    of loading a new instance of an entity. In addition, because we are not destroying
    reusable entities, the **Garbage Collector** (**GC**) won't waste cycles cleaning
    a set of regularly reinitialized objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数视频游戏中，屏幕上发生了很多事情。子弹在四处飞行，敌人正在地图周围生成，粒子在玩家周围弹出，这些各种对象在瞬间被加载和渲染到屏幕上。因此，为了避免在保持一致帧率的同时对**中央处理器**（**CPU**）造成压力，为我们的频繁生成的实体预留一些内存是一个好习惯。所以，我们不是从内存中释放最近被摧毁的敌人，而是将它们添加到对象池中以便以后重用。使用这种技术，我们避免了加载实体新实例的初始初始化成本。此外，因为我们没有摧毁可重用实体，所以**垃圾收集器**（**GC**）不会浪费周期清理一组定期重新初始化的对象。
- en: And this is what we are going to do in this chapter, but we are fortunate as,
    since Unity version 2021, object pooling has been natively integrated into the
    **Application Programming Interface** (**API**). Therefore, we will not need to
    implement the pattern by hand as we have done in previous chapters; instead, we
    will focus on learning how to use it and let the engine do all the work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中要做的，幸运的是，自从Unity版本2021以来，对象池已经原生集成到**应用程序编程接口**（**API**）中。因此，我们不需要像之前章节那样手动实现该模式；相反，我们将专注于学习如何使用它，并让引擎完成所有工作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Object Pool pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象池模式
- en: Implementing the Object Pool pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对象池模式
- en: Reviewing alternative solutions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查替代解决方案
- en: A GC functions as an automated memory manager and is an essential component
    of most modern object-oriented languages such as C#. It's not necessary to understand
    how it works to continue with this chapter, but if you are curious, you can get
    more information on the subject matter here: [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/.](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器（GC）作为一个自动的内存管理器，是大多数现代面向对象语言（如C#）的一个基本组件。为了继续本章的学习，不需要理解它是如何工作的，但如果您对此感兴趣，可以在此处获取更多相关信息：[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/)。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的，因此您需要对Unity和C#有一个基本的了解。
- en: The code files of this chapter can be found on GitHub, at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08.](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter08)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[https://bit.ly/3yTLcI7](https://bit.ly/3yTLcI7)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3yTLcI7](https://bit.ly/3yTLcI7)'
- en: It's important to note that the code example in the next section will not work
    in a version of Unity that's below 2021.1, as we are using recently added API
    features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，下一节中的代码示例在低于2021.1版本的Unity中无法工作，因为我们使用了最近添加的API功能。
- en: Understanding the Object Pool pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象池模式
- en: The core concept of this pattern is simple—a pool in the form of a container
    holds a collection of initialized objects in memory. Clients can request an Object
    Pool for an object instance of a specific type; if one is available, it will be
    removed from the pool and given to the client. If there are not enough pooled
    instances at a given time, new ones will be dynamically created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的核心概念很简单——以容器形式存在的池在内存中保存了一组初始化后的对象。客户端可以请求对象池为其提供特定类型的对象实例；如果可用，它将从池中移除并分配给客户端。如果在某个时间点池中实例不足，新的实例将被动态创建。
- en: Objects that exit the pool will attempt to return to it once they are not used
    anymore by the client. If the Object Pool has no more space, it will destroy instances
    of objects that attempt to return. Therefore, the pool constantly gets refilled,
    can only be temporarily drained, but never overflows. Hence, its memory usage
    is consistent.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 离开池的对象将在不再被客户端使用后尝试返回池中。如果对象池没有更多空间，它将销毁尝试返回的对象实例。因此，池会不断被填充，只能暂时排空，但永远不会溢出。因此，其内存使用是稳定的。
- en: 'The following diagram illustrates the back and forth between a client and an
    Object Pool:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了客户端与对象池之间的交互：
- en: '![](img/9355c03f-fadf-4748-af73-7b54075cd42c.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9355c03f-fadf-4748-af73-7b54075cd42c.png)'
- en: Figure 8.1 – Unified Modeling Language (UML) diagram of the Object Pool pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 对象池模式的统一建模语言（UML）图
- en: In the diagram, we can see that the Object Pool serves the client by offering
    it access to a pool of object instances of a specific type—so, for example, a
    client could be a spawner asking the Object Pool for instances of a particular
    enemy type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们可以看到对象池通过向客户端提供特定类型对象实例的池的访问来服务于客户端——例如，客户端可以是请求特定敌人类型实例的生成器。
- en: Benefits and drawbacks of the Object Pool pattern
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池模式的好处和缺点
- en: 'These are some of the benefits of the Object Pool pattern:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是对象池模式的一些好处：
- en: '**Predictable memory usage**: With the Object Pool, we can allocate in a predictable
    manner some memory to hold a specific amount of instances of certain type of object.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测的内存使用**：使用对象池，我们可以以可预测的方式分配一些内存来保存特定类型对象的一定数量的实例。'
- en: '**Performance boost**: By having objects already initialized in memory, you
    avoid the loading cost of initializing new ones.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：由于对象已经在内存中初始化，因此避免了初始化新对象时的加载成本。'
- en: 'These are some potential drawbacks of the Object Pool pattern:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是对象池模式的一些潜在缺点：
- en: '**Layering on already managed memory**: Some people criticize the Object Pool
    pattern as being unnecessary in most cases because modern managed programming
    languages such as C# already optimally control memory allocation. However, this
    statement might be true in some contexts but false in others.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在已管理的内存上增加层级**：有些人批评对象池模式在大多数情况下是不必要的，因为现代托管编程语言如C#已经最优地控制了内存分配。然而，这个说法在某些情况下可能是正确的，但在其他情况下可能是错误的。'
- en: '**Unpredictable object states**: A potential pitfall of the Object Pool pattern
    is that if it is incorrectly handled, objects can be returned to the pool in their
    current state instead of their initial one. This situation can be an issue when
    the pooled entity is damageable or destructible. For instance, if you have an
    enemy entity that just got killed by the player, if you return it to the pool
    without restoring its health, and when the Object Pool pulls it back out for a
    client, it will spawn back into the scene in an already damaged state.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可预测的对象状态**：对象池模式的一个潜在陷阱是，如果处理不当，对象可能会以当前状态而不是初始状态返回池中。当池中的实体可受损或可破坏时，这种情况可能成为问题。例如，如果你有一个被玩家击败的敌人实体，如果你在恢复其健康之前将其返回池中，当对象池将其拉回给客户端时，它将以已损坏的状态重新生成到场景中。'
- en: When to use the Object Pool pattern
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用对象池模式
- en: To better understand when to use the Object Pool pattern, let's review when
    not to use it. For instance, if you have entities that need to be spawned once
    on your map, such as a final boss, putting it in an Object Pool is a waste of
    memory that you could use for something more useful.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解何时使用对象池模式，让我们回顾一下何时不应使用它。例如，如果你在地图上需要一次性生成实体，比如最终Boss，将其放入对象池就是浪费内存，这些内存本可以用于更有用的地方。
- en: Also, we should keep in mind that an Object Pool is not a cache. It has a similar
    purpose—the reuse of objects. The core difference is that an Object Pool has a
    mechanism in which entities are automatically returned to the pool after being
    used, and an Object Pool, if well implemented, handles the creation and deletion
    of objects depending on the available size of the pool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该记住，对象池不是一个缓存。它有一个类似的目的——对象的复用。核心区别在于，对象池有一个机制，在实体使用后自动将其返回到池中，并且如果实现得当，对象池会根据池的可用大小来处理对象的创建和删除。
- en: But suppose we have entities such as bullets, particles, and enemy characters
    that are frequently spawned and destroyed during a gameplay sequence. In that
    case, the Object Pool can relieve some of the strain we are putting on the CPU
    by reducing repetitious lifespan calls such as create and destroy, thus the CPU
    will be able to reserve processing power for more critical tasks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们在游戏过程中经常生成和销毁子弹、粒子以及敌人角色等实体。在这种情况下，对象池可以减轻我们对CPU施加的压力，通过减少重复的生命周期调用，例如创建和销毁，因此CPU将能够为更关键的任务保留处理能力。
- en: In the next section, we are going to take the concepts just learned and translate
    them into code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把刚刚学到的概念转化为代码。
- en: Implementing the Object Pool pattern
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对象池模式
- en: 'Before starting this section, it would be a good idea to read the official
    API documentation for the `IObjectPool<T0>` class under the `UnityEngine.Pool`
    namespace at the following link:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，阅读以下链接下`UnityEngine.Pool`命名空间中`IObjectPool<T0>`类的官方API文档是个好主意：
- en: '[https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Pool.ObjectPool_1.html)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/2021.1/Documentation/ScriptReference/Pool.ObjectPool_1.html](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Pool.ObjectPool_1.html)'
- en: We will try to avoid getting bogged down by API specifications while implementing
    the following code example. Instead, we will focus on critical elements directly
    related to the core concepts of object pooling. Also, native object pooling is
    a relatively new Unity API feature, hence it might be subject to changes and updates.
    Thus, it would be wise to keep an eye on the documentation in the short term.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现以下代码示例时，我们将尽量避免陷入API规范中。相反，我们将专注于与对象池核心概念直接相关的关键元素。此外，原生对象池是Unity API的一个相对较新的功能，因此它可能会受到更改和更新的影响。因此，短期内关注文档是明智的。
- en: Steps for implementing the Object Pool pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现对象池模式的步骤
- en: 'This section''s code example should be relatively straightforward and we should
    be able to complete it in two steps, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码示例应该是相对直接的，我们应该能够分两步完成它，如下所示：
- en: 'Let''s start by implementing our drone, as this is the entity that we will
    pool. Because it is such a lengthy class, we are going to split it into two segments.
    You can see the first segment here:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现我们的无人机开始，因为这是我们将要池化的实体。由于这个类非常长，我们将将其分为两个部分。您可以看到第一部分如下：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's essential to observe that we call the `ResetDrone()` method in the `OnDisable()`
    event function in this class segment. We are doing this because we want to reset
    the drone back to its initial state before returning it to the pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类段中，我们调用`ResetDrone()`方法是在`OnDisable()`事件函数中。我们这样做是因为我们想在将无人机返回池之前将其重置到初始状态。
- en: And as we are going to see when we implement the Object Pool pattern, when a
    GameObject returns to the pool it gets disabled, including all its child components.
    Therefore, if we have any reinitialization code to execute, we can do this at
    the `OnDisable()` call.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并且正如我们将在实现对象池模式时看到的那样，当一个GameObject返回池中时，它会被禁用，包括所有其子组件。因此，如果我们有任何需要执行的重新初始化代码，我们可以在`OnDisable()`调用中执行。
- en: In the context of this chapter, we are keeping things simple; we are only restoring
    the health of the drone. But in an advanced implementation, we might have to reset
    visual markers, such as removing damaged decals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的上下文中，我们保持简单；我们只恢复无人机的健康。但在高级实现中，我们可能需要重置视觉标记，例如移除损坏的标记。
- en: 'In the final segment of our `Drone` class, we will implement the core behaviors,
    as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们`Drone`类的最后一段中，我们将实现核心行为，如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our drone has two key behaviors, outlined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无人机有两个关键行为，如下所述：
- en: '**Self-destruction**: Our drone has a short lifespan; when it''s enabled, the
    `SelfDestruct()` coroutine is called. After several seconds, the drone self-destructs
    by depleting its health meter and returning itself to the pool by calling the
    `ReturnToPool()` method.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我销毁**: 我们的无人机的寿命很短；当它被启用时，会调用 `SelfDestruct()` 协程。几秒钟后，无人机通过耗尽其生命值并通过调用
    `ReturnToPool()` 方法将自己返回池中而自我销毁。'
- en: '**Attack**: The logic inside the method is not implemented, for brevity reasons.
    But imagine that once the drone is spawned, it seeks and attacks the player.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击**: 方法内的逻辑尚未实现，为了简洁起见。但想象一下，一旦无人机被生成，它会寻找并攻击玩家。'
- en: 'Next up is our `ObjectPool` class, which has the responsibility of managing
    a pool of drone instances. Because it''s a lengthy class, we will review it in
    two segments, with the first segment available to view here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的 `ObjectPool` 类，它负责管理无人机实例的池。由于它是一个较长的类，我们将分两部分来审查它，第一部分在此处提供：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this first part of the script, we are setting a critical variable named `maxPoolSize`;
    as its name implies, this sets the maximum number of drone instances we will keep
    in the pool. The `stackDefaultCapacity` variable sets the default stack capacity;
    this is a property related to the stack data structure we are using to store our
    drone instance. We can ignore it for the moment as it's not critical to our implementation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的第一部分，我们设置了一个名为 `maxPoolSize` 的关键变量；正如其名称所暗示的，这设置了我们将保留在池中的无人机实例的最大数量。`stackDefaultCapacity`
    变量设置了默认的堆栈容量；这是我们用来存储无人机实例的堆栈数据结构的一个属性。我们可以暂时忽略它，因为它对我们实现不是关键的。
- en: 'In the following code snippet, we are initializing the object pool, which is
    the most crucial part of our class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们正在初始化对象池，这是我们类中最关键的部分：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's important to note that we are passing callback methods in the constructor
    of the `ObjectPool<T>` class, and it's in these callbacks that we will implement
    the logic that will drive our Object Pool.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们在 `ObjectPool<T>` 类的构造函数中传递了回调方法，并且在这些回调中我们将实现驱动我们的对象池的逻辑。
- en: 'In the last segment of the `DroneObjectPool` class, we will implement the callbacks
    we declared in the `ObjectPool<T>` constructor, as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DroneObjectPool` 类的最后一段，我们将实现我们在 `ObjectPool<T>` 构造函数中声明的回调，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s a short explanation of each callback that the `ObjectPool` class will
    call at specific times:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对 `ObjectPool` 类将在特定时间调用的每个回调的简要说明：
- en: '`CreatedPooledItem()`: In this callback, we are initializing our drone instances.
    In the context of this chapter, we are creating a GameObject from scratch for
    simplicity reasons, but in a more practical context, we would probably just load
    a prefab.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatedPooledItem()`: 在这个回调中，我们正在初始化我们的无人机实例。在本章的上下文中，为了简单起见，我们从头开始创建一个 GameObject，但在更实际的情况下，我们可能会只是加载一个预制体。'
- en: '`OnReturnedToPool()`: The name of the method implies its use. Notice we are
    not destroying the GameObject; we simply deactivate it to remove it from the scene.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnReturnedToPool()`: 方法的名称暗示了其用途。注意我们并没有销毁 GameObject；我们只是将其停用以从场景中移除。'
- en: '`OnTakeFromPool()`: This is called when the client requests an instance of
    the drone. The instance is not actually returned—the GameObject is enabled.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTakeFromPool()`: 当客户端请求无人机实例时，会调用此方法。实际上并没有返回实例——GameObject 被启用。'
- en: '`OnDestroyPoolObject()`: This an important method to understand. It''s called
    when there''s no more space in the pool. In that case, the returned instance is
    destroyed to free up memory.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroyPoolObject()`: 这是一个重要的方法，需要理解。当池中没有更多空间时，它会调用。在这种情况下，返回的实例会被销毁以释放内存。'
- en: Our `DroneObjectPool` class has taken on extra responsibilities and acts as
    a spawner, as we can see in the `Spawn()` method. When requested, it will get
    a `drone` instance from the pool and spawn it at a random location in the scene
    within a specific range.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `DroneObjectPool` 类承担了额外的责任，并充当生成器，正如我们在 `Spawn()` 方法中看到的。当请求时，它会从池中获取一个
    `drone` 实例，并在场景中的特定范围内随机位置生成它。
- en: Testing the Object Pool implementation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试对象池实现
- en: 'To test our implementation of the Object Pool in your own instance of Unity,
    you need to carry out the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您自己的 Unity 实例中测试我们的对象池实现，您需要执行以下步骤：
- en: Create a new empty Unity scene.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 Unity 场景。
- en: Copy all the scripts we just reviewed and save them in your project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚审查的所有脚本复制并保存在您的项目中。
- en: Add an empty GameObject to the scene.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个空的 GameObject。
- en: 'Attach the following client script to your empty GameObject:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下客户端脚本附加到您的空 GameObject 上：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you start your scene, you should see a **graphical user interface** (**GUI**)
    button named **Spawn Drones** in the top-left corner, as we can see in the following
    screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动场景，你应该在左上角看到一个名为**Spawn Drones**的**图形用户界面**（**GUI**）按钮，如下截图所示：
- en: '![](img/4c618be6-fbe6-4ccb-aef1-ba042b8f4195.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c618be6-fbe6-4ccb-aef1-ba042b8f4195.png)'
- en: Figure 8.2 – Screenshot of the code example in action
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 代码示例的实际截图
- en: By pressing the **Spawn Drones** button, you can now spawn drones at random
    positions in the scene. If you want to see the Object Pool mechanism in action,
    keep an eye on the scene hierarchy—you will be able to see Drone entities get
    enabled and disabled as they come in and out of the pool.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下 **Spawn Drones** 按钮，你现在可以在场景中的随机位置生成无人机。如果你想看到对象池机制的实际应用，请关注场景层次结构——你将能够看到无人机实体在进入和退出池时被启用和禁用。
- en: Reviewing the Object Pool implementation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查对象池实现
- en: By using the Object Pool pattern, we automated the process of creating, destroying,
    and pooling drone instances. We can now reserve an amount of memory to spawn waves
    of drones while avoiding burdening the CPU. We added optimization and scalability
    to our code by implementing this pattern without losing readability or adding
    complexity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用对象池模式，我们自动化了创建、销毁和池化无人机实例的过程。现在我们可以预留一定量的内存来生成无人机波次，同时避免给CPU带来负担。通过实现这个模式，我们在不牺牲可读性或增加复杂性的情况下，为我们的代码添加了优化和可扩展性。
- en: In the next section, we will review some alternative solutions to consider;
    it's always a good practice to consider other options before deciding on a specific
    pattern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些可以考虑的替代方案；在决定特定的模式之前考虑其他选项总是一个好习惯。
- en: Reviewing alternative solutions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查替代方案
- en: A close cousin of the Object Pool pattern is the **Prototype** pattern; both
    of these are considered creational patterns. With the Prototype pattern, you can
    avoid the inherent cost of creating new objects by using a cloning mechanism.
    Therefore, instead of initializing new objects, you clone them from a reference
    object called a prototype. But in the context of the use case presented in this
    chapter, object pooling offers better optimization benefits.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式的近亲是**原型**模式；这两个都被认为是创建型模式。使用原型模式，你可以通过使用克隆机制来避免创建新对象固有的成本。因此，而不是初始化新对象，你可以从称为原型的引用对象中克隆它们。但在本章所展示的使用案例的上下文中，对象池提供了更好的优化优势。
- en: Creational-type patterns are concerned with the mechanism of object creation.
    **Factory**, **Build**, **Singleton**, **Object Pool**, and **Prototype** are
    all creational design patterns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式关注对象创建的机制。**工厂**、**构建**、**单例**、**对象池**和**原型**都是创建型设计模式。
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have just added the Object Pool pattern to our toolkit—this is one of the
    most valuable patterns for Unity developers. As we saw in our code examples, we
    can easily recycle instances of frequently used objects. When dealing with a large
    set of entities that need to spawn quickly and repeatedly, this pattern can help
    us avoid CPU spikes and lags. These benefits can only help make our game better,
    as players do enjoy a game that runs smoothly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将对象池模式添加到我们的工具箱中——这是Unity开发者最有价值的模式之一。正如我们在代码示例中看到的，我们可以轻松地回收常用对象的实例。当处理需要快速且重复生成的大量实体时，这个模式可以帮助我们避免CPU峰值和延迟。这些好处只能帮助我们使游戏变得更好，因为玩家确实喜欢运行流畅的游戏。
- en: In the next chapter, we are going to decouple components from each other with
    the Observer pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用观察者模式将组件彼此解耦。
