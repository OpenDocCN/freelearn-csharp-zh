- en: Chapter 1.  Building a Gallery Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will walkthrough native development with Xamarin by building an
    iOS and Android application that will read from your local gallery files, and
    display them in a **UITableView** and **ListView.** The following topics will
    be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating iOS provision certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating keystores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an iOS project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a UIViewController and UITableView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing a cell's appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an XML interface and ListView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom row appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitmap functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ALAssetLibrary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the iOS photo screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Android photo screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an iOS project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our Xamarin journey; we will start by setting up our iOS project
    in Xamarin Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening Xamarin Studio and creating a new iOS project. To do so, we
    simply select **File** | **New** | **Solution** and select an **iOS Single View
    App**; we must also give it a name and add the bundle ID you want in order to
    run your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that for each project, a new bundle ID is created, along with
    a developer provisioning profile for each project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have created the iOS project, you will be taken to the following
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Create an iOS project](img/B05293_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Doesn't this look familiar? Yes, it is our `AppDelegate` file; notice the `.cs`
    on the end; because we are using C#, all our code files will have this extension
    (no more `.h` or `.m` files).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we go any further, spend a few minutes moving around the IDE, expanding
    the folders, and exploring the project structure; it is very similar to an iOS
    project created in XCode.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UIViewController and UITableView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our new iOS project, we are going to start by creating a `UIViewController`.
    Right-click on the project file, select **Add** | **New File**, and select **ViewController**
    from the **iOS** menu selection in the left-hand box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a UIViewController and UITableView](img/B05293_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice three files generated, a `.xib`, a `.cs`, and a `.designer.cs`
    file. We don't need to worry about the third file; this is automatically generated
    based upon the other two files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right-click on the project item and select **Reveal in Finder**,
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a UIViewController and UITableView](img/B05293_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will bring up the finder where you will double-click on the `GalleryCell.xib`
    file; this will bring up the user interface designer in XCode. You should see
    automated text inserted into the document to help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we must set our namespace accordingly, and import our libraries with
    using statements. In order to use the iOS user interface elements, we must import
    the `UIKit` and `CoreGraphics` libraries. Our class will inherit the `UIViewController`
    class in which we will override the `ViewDidLoad` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our first UI element created is `UITableView`. This will be used to insert into
    the `UIView` of the `UIViewController`, and we also retrieve width and height
    values of the `UIView` to stretch the `UITableView` to fit the entire bounds of
    the `UIViewController`. We must also call `Add` to insert the `UITableView` into
    the `UIView`. In order to fill the list with data, we need to create a `UITableSource`
    to contain the list of items to be displayed in the list. We will also need an
    object called `GalleryModel`; this will be the model of data to be displayed in
    each cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the previous process for adding two new `.cs` files; one will be used
    to create our `UITableSource` class and the other for the `GalleryModel` class.
    In `TableSource.cs`, first we must import the `Foundation` library with the `using`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the rest of our class. Remember, we have to override specific functions
    for our `UITableSource` to describe its behavior. It must also include a list
    for containing the item view-models that will be used for the data displayed in
    each cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We must override the `NumberOfSections` function; in our case, it will always
    be one because we are not having list sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine the number of list items, we return the count of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then we must add the `GetCell` function; this will be used to get the `UITableViewCell`
    to render for a particular row. But before we do this, we need to create a custom
    `UITableViewCell`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a cell's appearance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to design our cells that will appear for every model found
    in the `TableSource` class. Add a new `.cs` file for our custom `UITableViewCell`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not going to use a `.xib` and simply build the user interface directly
    in code using a single `.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our constructor must call the base constructor, as we need to initialize each
    cell with a cell style and cell identifier. We then add a `UIImageView` and two
    `UILabels` for each cell, one for the filename and one for the date. Finally,
    we add all three elements to the main content view of the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have our initializer, we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our first function, `UpdateCell`, simply adds the model data to the view, and
    our second function overrides the `LayoutSubViews` method of the `UITableViewCell`
    class (equivalent to the `ViewDidLoad` function of a `UIViewController`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our cell design, let''s create the properties required for
    the view-model. We only want to store data in our `GalleryItem` model, meaning
    we want to store images as byte arrays. Let''s create a property for the item
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now back to our `TableSource` class. The next step is to implement the `GetCell`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the cell reuse on the `if` statement; you should be familiar with this
    type of approach, it is a common pattern for reusing cell views and is the same
    as the Objective-C implementation (this is a very basic cell reuse implementation).
    We also call the `UpdateCell` method to pass in the required `GalleryItem` data
    to show in the cell. Let''s also set a constant height for all cells. Add the
    following to your `TableSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So what is next?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's stop development and have a look at what we have achieved so far. We have
    created our first `UIViewController`, `UITableView`, `UITableViewSource`, and
    `UITableViewCell`, and bound them all together. Fantastic!
  prefs: []
  type: TYPE_NORMAL
- en: We now need to access the local storage of the phone to pull out the required
    gallery items. But before we do this, we are going to create an Android project
    and replicate what we have done with iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first step is to create new general Android app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an Android project](img/B05293_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first screen you will land on is `MainActivity`. This is our starting activity,
    which will inflate the first user interface; take notice of the configuration
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainLauncher` flag indicates the starting activity; one activity must
    have this flag set to `true` so the application knows what activity to load first.
    The `icon` property is used to set the application icon, and the `Label` property
    is used to set the text of the application, which appears in the top left of the
    navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The formula for our activities is the same as Java; we must override the `OnCreate`
    method for each activity where we will inflate the first XML interface `Main.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an XML interface and ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our starting point is the `main.xml` sheet; this is where we will be creating
    the `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main.xml` file should already be in the **resource** | **layout** directory,
    so simply copy and paste the previous code into this file.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We now have our starting activity and interface, so now we have to
    create a `ListAdapter` for our `ListView`. An adapter works very much like a `UITableSource`,
    where we must override functions to determine cell data, row design, and the number
    of items in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xamarin Studio also has an Android GUI designer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the Android project and add a new empty class file for our adapter
    class. Our class must inherit the `BaseAdapter` class, and we are going to override
    the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go any further, we need to create a model for the objects used to
    contain the data to be presented in each row. In our iOS project, we created a
    `GalleryItem` to hold the byte array of image data used to create each `UIImage`.
    We have two approaches here: we could create another object to do the same as
    the `GalleryItem`, or even better, why don''t we reuse this object using a shared
    project?'
  prefs: []
  type: TYPE_NORMAL
- en: Shared projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to delve into our first technique for sharing code between different
    platforms. This is what Xamarin wants us to achieve, and reuse as much code as
    possible. The biggest disadvantage when developing natively is two different language,
    and we can't reuse anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first shared project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared projects](img/B05293_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our shared project will be used to contain the `GalleryItem` model, so whatever
    code we include in this shared project can be accessed by both the iOS and Android
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared projects](img/B05293_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, have a look at the **Solution** explorer, and notice
    how the shared project doesn't contain anything more than `.cs` code sheets. Shared
    projects do not have any references or components, just code that is shared by
    all platform projects. When our native projects reference these shared projects,
    any libraries being referenced via `using` statements come from the native projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must have the iOS and Android projects reference the shared project;
    right-click on the **References** folder and select **Edit References**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared projects](img/B05293_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the shared project you just created and we can now reference the `GalleryItem`
    object from both projects.
  prefs: []
  type: TYPE_NORMAL
- en: Custom row appearance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get back to the `ListAdapter` implementation and design our `ListView`
    row appearance. Open the **Resources** | **Layout** folder, create a new `.xml`
    file for the cell appearance, call it `CustomCell.xml`, and copy in the following
    XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating the same layout as the custom cell made for iOS, but in Android
    we will use the `ImageView` and `TextView` objects. Now that we have our custom
    cell, we can implement the the `GetView` function. The `GetView` function is exactly
    like the `GetCell` function in the preceding `UITableSource` implementation. Open
    up the `ListAdapter.cs` file and continue with the list adapter implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We override the `Count` property and functions `GetItemId` and `GetItem`, to
    return the number of gallery items in our list. These override functions are exactly
    the same as the overrides in Java for any `BaseAdapter` inherited class. Now for
    the `GetView` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the `GetView` function we are using the `CustomCell` layout for each
    row; we also have a `private` method for creating our bitmaps from each model's
    byte array.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a look at the current implementation, what do we notice here?
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a bitmap every time the cell requires this data again for the
    view; is this efficient? No, we should be reusing bitmaps and memory as much as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: This tends to be a common issue with Android `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: What is the most memory efficient way to reuse bitmaps across hundreds of items
    in a `ListView` while scrolling and staying smooth as we move down the list at
    various speeds? How can we tackle this problem? Let's have a look at how we can
    approach this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to implement an object called `ImageHandler`. This will contain
    the logic for retrieving byte arrays from all gallery images on an Android device.
    Create a new file, name it `ImageHandler`, and start importing these namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This class will include a function, `GetFiles`, which will create gallery items
    based upon the items pulled from any device''s gallery using the `ContentResolver`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ContentResolver` (used to access the content model), we resolve **URIs**
    to specific content providers. A content provider provides queries to content,
    in our case image files. We simply create an access query off the main context''s
    `ContentResolver` instance, and we provide an array of columns for the query to
    retrieve (for example, file titles, file data, file size, and so on). The first
    parameter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used for retrieving the URI to each piece of content returned from
    the query. Finally, we now have a cursor to iterate through, exactly like an `Enumerable`,
    which will loop to the end until there are no more items, and for each iteration
    we pull the data and URI columns and create a new `GalleryItem`. You will notice
    a little trick here with the `yield` keyword: if we call this function, it will
    actually return the entire `Enumerable` from start to finish. Calling the function
    starts *for each-ing* over the object; the function is called again until it *yields*.
    In the return from calling this function, we get an `Enumerable` of all the items
    retrieved from the query as gallery items with image information and local URI.'
  prefs: []
  type: TYPE_NORMAL
- en: Bitmap functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What about the byte data? First, let''s implement our `BitmapHelpers`; these
    will include two global functions to help with bitmap processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our first function will determine the best sample size by the requested width
    and height. This is a very good technique for reducing the resources required
    to load an image into memory. Our next function is used to create a bitmap for
    the `ImageView` that is passed in from the byte data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create this image data using the `private` method `createCompressedImageDataFromBitmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method will take the image URI and decode the bitmap options in order to
    sample the smallest possible size for the dimensions provided.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure that we flag `InJustDecodeBounds` so this bitmap is not
    loaded into memory while we are retrieving the options information. This approach
    is very useful for reducing images to the size we require, thus saving memory.
    We then compress the image by 80% into a JPEG and convert the stream into a byte
    array for our `GalleryItem` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go back to the `adapter` class and add this method to fill in the
    items of our `ListAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember we must have a reference in our list adapter to the main context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the final piece of the puzzle, connecting the adapter to our list view.
    Open up the `MainActivity.cs` file and update the code list like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And voila! Try running the application and watching the `ListView` update with
    the images in your device's **Gallery** folder. Congratulations! You have just
    developed your first `Xamarin.Android` application. Now we must replicate this
    approach for the iOS version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the challenge with context switching when jumping back and forth between
    Android and iOS; it can get confusing. Luckily, with Xamarin we keep to just one
    programming language, which helps reduce the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The ALAssetLibrary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jumping back into our iOS, we are going to use the `ALAssetsLibrary` class and
    call the Enumerate function by passing in the group type `ALAssetsGroupType.SavedPhoto`,
    the enumeration result delegate `GroupEnumerator`, and the error action that will
    be performed if an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding in a new `.cs` file for our iOS image handler:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not going to use a static class with this object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In our constructor, we create the new instance of the `ALAssetsLibrary` and
    call the `Enumerate` function; now let''s add the `GroupEnumerator` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the call to notify our event handler. This signals we have reached the
    end of the `asset` library, and we have retrieved all `ALAsset` in our gallery.
    We can now pull out a list of the file names, so we need to add another function
    that will pull out the `ALAsset` object synchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need a public function that will pull all the byte arrays and `NSURL`
    into an `Enumerable` of gallery items that we will use to populate the `UITableView`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this is only a demo, we are only going to take the first 100 items. If you
    would like another challenge, remove `Take(100)`, and see if you can adjust the
    code to load thousands of images more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look a bit more closely at this function. We use the `asset` library
    object to pull out all the filenames we have in our gallery, then for each filename
    we pull out the `ALAsset` object, and from this we create a `GalleryItem` object
    for each, which takes the image data as a byte array from the `ALAsset` and the
    `NSURL` of the asset. Now let''s create an instance of the `ImageHandler` inside
    our `TableSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Now we have our gallery items ready to display inside the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final piece of the iOS project, let''s go back to our `AppDelegate.cs`
    file. We still need to implement the `FinishedLaunching` method. Our root controller
    is going to be a `UINavigationController`, which will use the `MainController`
    as the starting `UIViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We also adjust the window bounds the main screen bounds and call the function
    on the window at the very end of `MakeKeyAndVisible`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the iOS photo screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our list page, we want to add another `UIViewController` for
    displaying selected photos. Let's add a new `UIViewController` and call it `PhotoController`.
    In `PhotoController`, we are going to build a screen that simply displays the
    same content in the `PhotoCell`, but a bit larger.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the navigation flow from `MainController` to `PhotoController`.
    We are going to be pushing a new `PhotoController` whenever a row is selected.
    Open up `TableSource.cs` and add the following; at the top, we need to add an
    `EventHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the row is selected we want to fire this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the row is selected, we want to fire this event and pass the gallery
    item for the index path row. Now we need to handle this event in the `MainController`
    class to push a new `PhotoController` on the navigation stack, but before we do
    this we need to implement `PhotoController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to our `GalleryCell` presentation, but this controller
    will stack the elements vertically and force the image to scale to fit, keeping
    the image''s correct ratio to avoid any warping. Now let''s add `ViewDidLoad`
    to lay out the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new here; we are simply adding the three elements and setting
    our layout constraints accordingly. We stretch all elements to the entire width
    of the view and stack elements down the pages with the image view on top and a
    dynamic size based upon the aspect size of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step is to add the event handler whenever a row is selected.
    We use `ImageHandler` to fetch `ALAsset` by the title (filename) in the gallery
    item, then pass this into the constructor of a new `PhotoController` and update
    the constructor of `MainController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Now run the application and try selecting a few items in the list;
    you will be navigated to a new `PhotoController` which will display the selected
    `ALAsset` image with its filename and date information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Android photo screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a photo view for cell selections is very similar, although with
    Android we will be using an intent to create a new activity, which in turn will
    inflate a new view to display the image and details. Let''s start by adding a
    new XML called `photo_view.xml`, and paste in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The layout is very much the same as the `custom_cell.xml` sheet, although we
    are going to stack items vertically and set the following two properties to keep
    the correct image aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure XML sheets do not contain the same IDs as any other XML sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our user interface for the `PhotoActivity`, let''s add the
    new activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at this new activity, what can we see? Notice the attributes at the
    top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is no `MainLauncher` tag because this is not our starting activity. We
    then add the `intent.GetExtras` for the image data and strings required to display
    on our `Photo` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make one addition to the `ListAdapter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When an item in the list is selected, we need to be able to access the selected
    `GalleryItem`. Our next step is to add the `ItemClick` delegate for the `ListView`.
    Open up the `MainActivity` class and add the following to the `OnCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Place this after we set the list adapter. When an item is clicked, we simply
    pull out the gallery item from our adapter by the position passed from the `ItemClickEventArgs`.
    Once we have the gallery item, we create the new `PhotoActivity` intent and pass
    the extras.
  prefs: []
  type: TYPE_NORMAL
- en: That is all; run the application and play around selecting cells to display
    the `PhotoActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a gallery application on both iOS and Android using
    native development with Xamarin. We learnt how to setup projects in Xamarin Studio
    and code using the native frameworks in C#. In the next chapter, we will build
    a text to speech service using `Xamarin.Forms`.
  prefs: []
  type: TYPE_NORMAL
- en: Try improving on this code and make this function asynchronous; the more background
    processing we have at this stage, the better. These are the small improvements
    we should take time with, as combining all these small additions can create a
    real difference to the speed of your application.
  prefs: []
  type: TYPE_NORMAL
- en: As this is only a demo, we are only going to take the first 100 items. If you would
    like another challenge, remove `Take(100)`, and see if you can adjust the code
    to load thousands of images more  efficiently.
  prefs: []
  type: TYPE_NORMAL
