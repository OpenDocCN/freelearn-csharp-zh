- en: Chapter 5. Producing Tabular Reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a library that will help application developers
    to create tabular reports using a custom **Document Object Model** (**DOM**),
    created for this purpose. The tree-structured document object model will be traversed
    to produce output in the Adobe® **Portable Document Format** (**PDF**) and HTML
    format. Support for new target formats would be seamless, with developers writing
    handlers for those. For PDF output, we plan to use the open source **iTextSharp**
    library. During the course of this chapter, as a reader, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining an object model for documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The composite pattern for modeling part/whole relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing PDF documents by leveraging the iTextSharp library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visitor pattern and composite object traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements for the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirements statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For a large class of business applications, we require tabular reports in various
    formats. The popular choice for output formats are PDF, HTML, SVG, and so on.
    We should create a library to produce tabular output in these formats. The library
    should define a unified programming model, and serve as an API for the developers.
    The contents of the documents and its tables should be separated from the processing
    layer to incorporate future output drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before writing the code, let us step back a bit to enumerate the details of
    the requirements. The library which we are planning to write should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for various output formats like HTML, PDF, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object model for storing the contents of the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unified programming model and API for developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate content and it's processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to write new pluggable output processors (drivers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start by creating a hierarchy of elements for storing document contents.
    A simple hierarchy which has been conceived is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solutions approach](img/B05691_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will encode our content in a tree-structured document model. For the sake
    of simplicity, we have reduced the number of document elements. In an industrial
    strength implementation of this library, we will have many more elements. We can
    create tables within tables in this scheme, as we allow nested tables. Before
    we get into the implementation of the aforementioned hierarchy, we will look into
    the specifics of the creation of a PDF document using an open source library.
  prefs: []
  type: TYPE_NORMAL
- en: iTextSharp for the PDF output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To produce the output of a document in the PDF format, we plan to use the .NET
    version of the open source iText library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library can be downloaded from the iTextSharp website at the following address: [https://www.nuget.org/packages/iTextSharp/](https://www.nuget.org/packages/iTextSharp/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple program, which produces a PDF document using the library, is given
    next to make the reader understand the programming model of this library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will produce a PDF document with the contents given to the
    iTextsharp library through the iTextSharp API. Now we will focus on the creation
    of a DOM for storing our contents.
  prefs: []
  type: TYPE_NORMAL
- en: Composite and visitor pattern - A quick primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we deal with hierarchies like W3C DOM, document formats, graphics
    database or **abstract syntax tree** (**AST**) of a compiler, we create part/whole
    relationship. The GoF composite pattern is natural choice for creating hierarchies.
    Building hierarchies and its processing can be separated using GoF visitor pattern.
    The visitor pattern visits each node in the hierarchy and perform some action
    on the node. In a compiler, the tree representation of a program will be processed
    for type checking, code generation, trans compilation (source to source transformation)
    and so on. Sometimes people would like to perform additional activities on the
    tree. It is not feasible to add methods for processing the nodes within a node.
    Whenever a programmer wants a new method, we are forced to change every node in
    the hierarchy. A mechanism is necessary for processing to be decoupled from the
    nodes in a hierarchy. When we use visitor pattern, the nodes within the hierarchy
    becomes a container for data alone. We will write an expression composite to model
    a four function calculator to demonstrate the composite and visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The hierarchy for an expression is
  prefs: []
  type: TYPE_NORMAL
- en: '`Expr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinaryExpr`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnaryExpr`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following class will store an IEEE 754 double precision floating point
    value. Our evaluator will handle only constants, as an expression evaluator which
    supports variables will take additional effort and won''t serve our primary purpose
    of demonstrating the composite and visitor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the `Number` node, we should create a node to compose
    values through a binary operator. The binary operators supported are `+`, `-`,
    `/`, `*` and the class has been named `BinaryExpr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following class implements unary expression node. We support unary operators
    `+` and `-`, in our evaluator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a expression hierarchy which can be composed to form arithmetical
    expressions of arbitrary complexity. Our nodes store only data and references
    to child nodes. The processing of nodes are decoupled from the node proper, using
    visitor pattern. Let us see couple of examples which we can use to compose arithmetical
    expression. As an example, let us see how we can store the expression *1+2* using
    our composites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression *2+3*4* can be encoded as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can compose expressions of arbitrary complexity using this method. Now, we
    will see how we can process these composites using the visitor pattern. As an
    example, we will write a visitor which generates **Reverse Polish Notation** (**RPN**)
    from our expression tree. RPN is also called postfix notation and are used in
    some calculators and Forth programming language. Read more about RPN from the
    Internet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The above class can be invoked as follows. We will show how one can convert
    the expression *2+3*4* to *2 3 4 * +*. Let us encode the expression using our
    expression hierarchy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression hierarchy composed above can be traversed by `ReversePolishEvaluator`
    to produce *2 3 4 * +* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole purpose of creating an expression tree to evaluate it. We will write
    a stack based expression evaluator to demonstrate the use of visitor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The above stack evaluator can be invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have finished our discussion on visitor and composite pattern. In the above
    example, we defined a small hierarchy to compose mathematical expressions and
    processed it using visitor classes which traversed the composite to produce RPN
    expression and evaluate it using a stack. This technique is widely used wherever
    one is supposed to process a hierarchy. Let us focus on how to create a document
    hierarchy and process it.
  prefs: []
  type: TYPE_NORMAL
- en: The composite pattern and document composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While representing part-whole hierarchies (tree-structured), the composite
    design pattern describes a group of objects to be treated in a uniform manner,
    as if the leaf node and interior nodes are instances of the same object. A document
    object can contain multiple tables, and we can nest tables as well. This is an
    instance of a part-whole hierarchy, and composite design pattern is a natural
    choice here. To create a composite, we need to declare a base class, and all objects
    should be derived from this base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TDocumentElement` class acts as a base class for all the classes in the
    object model. Please note the following two important things about the `TDocumentElement`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the `DocumentElements` property. Every `TDocumentElement` has
    a list of `TDocumentElement` to store its child objects. This means, we can insert
    a list of concrete objects which implements `TDcoumentElement` as a child. Using
    this technique, we can compose a document hierarchy of arbitrary complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second thing is the presence of an abstract method called `accept`. The
    `accept` method is a mechanism by which we will be able to separate the operations
    on node and the node data structure. We will learn more about the semantics of
    the `accept` method in a later section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topmost class in the hierarchy is `TDocument`, which acts as a container
    for a hierarchical collection of the `TDocumentElement` derived class. The class
    will store all the child contents (concrete classes of base type `TDocumentElement`)
    to be embedded inside the document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Application developers can leverage the `addObject` method available in the
    `TDocumentElement` class to add contents to `TDocument`. In our canned example,
    the most obvious choice is a list of tables. The `accept` method makes a call
    to the visitor's visit method with the `TDocument` instance (this) as a parameter.
    This will hit the `visit(TDocument)` method implemented in a class, which implements
    the `IDocumentVisitor` interface. More on visitor pattern and its implementation
    is available in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: The `TDocumentTable` models a table object, which can be embedded inside a document.
    Since the `TDocumentTable` object inherits from `TDocumentElement`, we can add
    any `TDocumentElement` derived class as a child. With this technique, we can embed
    objects of arbitrary complexity. But, for our library, an Instance of `TDocumentTable`
    is the natural choice as the first child of the `TDocument` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inside a table, we store data as a series of rows, and the class for storing
    information is appropriately named `TDocumentTableRow`. We can insert another
    table as a child as well. One can embed a table within a table. For the sake of
    brevity, we have not included that feature in the current implementation. If we
    need to support nested tables, we need to incorporate a data structure called
    scope tree. The listing of such an implementation cannot be conveniently included
    in a book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A row is a collection of cells, and inside each cell, we can store arbitrary
    text. It is possible to store an image as well, but, for the sake of brevity,
    we have limited the cell contents to text. The image or another content type can
    be incorporated very easily following the schema used for text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Every cell in the table contains a text item for our implementation. We model
    the text using the `TDocumentText` class. In this class, the `Text` property is
    used to store and load text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we have defined our DOM. You can see the UML representation of the composite
    pattern in action in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The composite pattern and document composition](img/B05691_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we need to create a mechanism to traverse the hierarchy to produce the output
    of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor pattern for document traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tree-structured DOM created by us needs to be traversed to produce the content
    in an output format like HTML, PDF, or SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The composite tree created by us can be traversed using the GoF visitor pattern.
    Wherever composite pattern is used for composing an hierarchy of objects, the
    visitor pattern is a natural choice for the traversal of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a visitor pattern implementation, every node in the composite tree will
    support a method called `accept`, which takes a visitor concrete class as a parameter.
    The job of the `accept` routine is to reflect the call to the appropriate visit
    method in the visitor concrete class. We declare an interface named `IDocumentVisitor`
    with methods for visiting each of the elements in our hierarchy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The traversal of the tree should start from the top node of the tree. In our
    case, we start the traversal from the `TDocument` node. For each node in the hierarchy,
    we will add an `accept` method, which takes an instance of `IDocumentVisitor`.
    The signature of this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element of the document node which derives from `TDocumentElement` needs
    to have an implementation of this method. For example, the body of the `TDocument`
    class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `TDocument` class, the `accept` method will reflect the call to the `IDocumentVisitor
    visit(TDocument)` method implemented by the `Visitor` class. In the `Visitor`
    class, for each node inserted as a child, a call to the `accept` method of the
    respective nodes will be triggered. Each time the call gets reflected back to
    the appropriate visit method of the `Visitor` class. In this manner, the accept/visit
    pair processes the whole hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traversal starts with the `TDocument accept` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ds` object is of type `TDocument`, and the `accept` method takes an instance
    of the `IDocumentVisitor` interface. In the document object, the call gets reflected
    to the `IDocumentVisitor visit(TDocument)` method.
  prefs: []
  type: TYPE_NORMAL
- en: PDFVisitor for PDF generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined our object hierarchy and an interface to traverse the hierarchy.
    Now we need to implement routines to traverse the tree. The `PDFVisitor` class
    implements the `IDocumentVisitor` interface, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `visit` method, which takes `TDocument` as a parameter, adds some metadata
    to the PDF document being created. After this operation, the method inspects all
    the child elements of `TDocument`, and issues an `accept` method call with the
    current visitor instance. This invokes the `accept` method of the concrete class
    of `TDocumentElement` embedded as a child object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TDocumentTable` object will be handled by the `visit` method in a similar
    fashion. Once we have worked with the node, all the children stored in `DocumentElements`
    will be processed by invoking the `accept` method of each of the node element
    embedded inside the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Mostly, an instance of `TDocumentTableRow` is included as a child of `TDocumentTable`.
    For our implementation, we will navigate to all the children of a row object,
    issuing accept calls to the respective nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A table is a collection of rows, and a row is a collection of cells. Each of
    the cells contains some text. We can add a collection of text inside a cell as
    well. Our implementation assumes that we will store only one text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To process `TDocumentTableCell`, we iterate through all the child elements
    of a cell, and these elements are instances `TDocumentText`. For the sake of brevity,
    we have included an attribute called `Text` to store the contents of a cell there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TDocumentText` class has a property by the name of `Text`, where an application
    developer can store some text. That will be added to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: HTMLVisitor for HTML generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `HTMLVisitor` class produces HTML output by traversing the DOM. The skeleton
    implementation of `HTMLVisitor` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HTMLVisitor` class can be leveraged as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The client program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple program which leverages the DOM is given next. We create a `TDocument`
    object as a top-level node, and add the rest of the document contents as child
    nodes to the respective classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a library for producing tabular reports in various
    formats. In the process, we learned about creating arbitrary hierarchies of objects
    in a tree-structured manner. We leveraged the composite pattern to implement our
    hierarchy. The composites were processed using the visitor pattern. We dealt with
    PDF and HTML output by writing `PDFVisitor` and `HTMLVisitor` classes. Incorporating
    a new output format is just a matter of writing a new visitor (say, `SVGVisitor`),
    where one needs to map the contents of the document to the appropriate SVG tags.
    In the next chapter, we will learn about the interpreter pattern and the observer
    pattern by implementing a library that will help us plot arbitrary expressions
    as graphs.
  prefs: []
  type: TYPE_NORMAL
