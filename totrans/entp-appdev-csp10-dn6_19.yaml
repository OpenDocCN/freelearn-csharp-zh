- en: '*Chapter 14*: Health and Diagnostics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern software applications have evolved to be complex and dynamic and are
    distributed in nature. There is a high demand for these applications to be able
    to work round the clock, anywhere, on any device. To achieve this, it is important
    to know that our application is available and responds to requests at all times.
    Customer experiences will play a big role in the future of service and the revenue
    of an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application is live, it is critical to monitor the application's health.
    Regular application health monitoring will help us to proactively detect any failures
    and address them before they cause more damage. Application monitoring has now
    become a part of day-to-day operations. To diagnose any failure on a live application,
    we need to have the right telemetry and diagnostic tools. The telemetry that we
    capture will also help us identify those problems not directly seen or reported
    by users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about application health monitoring and what is on offer in .NET
    6.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The health check API in ASP.NET Core 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the application with Application Insights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing remote debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a good grasp of building the health
    check API for .NET 6 apps and Azure Application Insights for capturing telemetry
    and diagnosing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following software to work through the tasks in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 Community Edition with the Azure development workload installed
    (certain sections require Enterprise Edition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of Microsoft .NET and how to create resources in Azure
    is expected.
  prefs: []
  type: TYPE_NORMAL
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing health checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A health check is a comprehensive review of an application that helps us to
    understand the current state of the application and use visible indicators to
    take corrective measures. Health checks are exposed as HTTP endpoints by applications.
    The health check endpoints are used as health probes for certain orchestrators
    and load balancers to route traffic away from a failing node. Health checks are
    used to monitor application dependencies, such as databases, external services,
    and cache services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about the support for building the health
    check API in ASP.NET Core 6.
  prefs: []
  type: TYPE_NORMAL
- en: The health check API in ASP.NET Core 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 6 has a built-in middleware (available via the `Microsoft.Extensions.Diagnostics.HealthChecks`
    NuGet package) to report the health status of the application components exposed
    as an HTTP endpoint. This middleware makes it so easy to integrate health checks
    for databases, external systems, and other dependencies. It is also extensible,
    so we can create our own custom health checks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add a health check endpoint to our `Ecommerce`
    portal.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a health check endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will add a health check endpoint to our `Packt.Ecommerce.Web`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add a health check endpoint, we need to first add the `Microsoft.Extensions.Diagnostics.HealthChecks`
    NuGet package reference to the `Packt.Ecommerce.Web` project, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – NuGet reference, Microsoft.Extensions.Diagnostics.HealthChecks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – NuGet reference, Microsoft.Extensions.Diagnostics.HealthChecks
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to register `HealthCheckService` with the dependency container.
    The `Microsoft.Extensions.Diagnostics.HealthChecks` package has the `AddHealthChecks`
    extension method defined to add `HealthCheckService` to the container. We can
    call the `AddHealthChecks` method from the `Program.cs` file to add the `DefaultHealthCheckService`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and configure the health check endpoint to our web application.
    Map the health endpoint using the `MapHealthChecks` method, as shown in the following
    code, in the `Program.cs` file. This will add the health check endpoint route
    to the application. This will internally configure the `HealthCheckResponseWriters.WriteMinimalPlainText`
    framework method to emit the response. `WriteMinimalPlainText` will just emit
    the overall status of the health check services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application and browse to the `<<Application URL>>/health` URL. You
    will see following the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Health check endpoint response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Health check endpoint response
  prefs: []
  type: TYPE_NORMAL
- en: The health endpoint we added provides basic information on service availability.
    In the next section, we will see how we can monitor the status of dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring dependent URIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An enterprise application depends on multiple other components, such as databases
    and Azure components including `KeyVault`, and other microservices (such as our
    `Ecommerce` website) depend on the Order service, Product service, and so on.
    These services can be owned by other teams within the same organization or, in
    some cases, they might be external services. It is often a good idea to monitor
    dependent services. We can leverage the `AspNetCore.HealthChecks.Uris` NuGet package
    to monitor the availability of dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and enhance our health endpoint to monitor the Product and
    Order services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the NuGet package reference to `AspNetCore.HealthChecks.Uris`. Now, modify
    the health check registration to register the Product and Order services, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The health check middleware also provides details about the status of individual
    health checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now modify our health check middleware to emit the details as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, the health check middleware is overwritten to write the details
    of the status, health check duration, component name, and a description as its
    response by providing `HealthCheckOptions` with `ResponseWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run the project and navigate to the health check API, we should
    see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Health check endpoint response with status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Health check endpoint response with status
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to customize the response of the health check endpoint and
    how to leverage a third-party library to monitor the status of dependent URIs.
    If you wish to integrate the check for a database used via Entity Framework Core,
    you can leverage the `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore`
    library. More information about using this library can be found at [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0#entity-framework-core-dbcontext-probe).
  prefs: []
  type: TYPE_NORMAL
- en: A wider collection of health check packages for different services can be found
    at [https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks).
    In the next section, we will learn how to build a custom health check.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom health check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The health check middleware in ASP.NET Core 6 is extensible, meaning that it
    allows us to extend and create a custom health check. We will learn how to build
    and use custom health checks by building a process monitor. In some scenarios,
    there might be a need to monitor a specific process running on the machine. If
    the process (for example, an anti-malware service) is not running, or if the license
    of a third-party SaaS offering is expiring/expired, we might flag them as health
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating the `ProcessMonitor` health check in the `Packt.Ecommerce.Common`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a project folder named `HealthCheck` to `Packt.Ecommerce.Common` and add
    two classes, `ProcessMonitor` and `ProcessMonitorHealthCheckBuilderExtensions`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Project structure after adding a custom health check'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Project structure after adding a custom health check
  prefs: []
  type: TYPE_NORMAL
- en: The custom `HealthCheck` middleware requires the NuGet reference to be `Microsoft.Extensions.Diagnostics.HealthChecks`.
  prefs: []
  type: TYPE_NORMAL
- en: The custom health check in ASP.NET Core 6 should implement the `IHealthCheck`
    interface. This interface defines the `CheckHealthAsync` method that will get
    called when the request comes to the health endpoint API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `ProcessMonitorHealthCheck` class as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `CheckHealthAsync` method, fetch the list of processes with the name
    specified in `processName`. If there is no such process, then return as health
    check failed, otherwise, return the state as failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the custom health check middleware, let''s add an extension
    method to register. Modify the `ProcessMonitorHealthCheckBuilderExtensions` class
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is an extension method to `IHealthCheckBuilder`. We can see that adding
    `ProcessMonitorHealthCheck` in the code snippet registers it with the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now make use of the custom health check that we have built. In the following
    code, we registered the `ProcessMonitorHealthCheck` health check for `notepad`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you run the application and navigate to the health check API, you
    will see the output shown in *Figure 14.5* if `notepad.exe` is running on your
    machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Response from health check endpoint ](img/Figure_14.5_B18507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Response from the health check endpoint
  prefs: []
  type: TYPE_NORMAL
- en: We can enable **cross-origin resource sharing** (**CORS**), authorization, and
    host restriction on our health check endpoints. For details, please refer to [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-6.0).
  prefs: []
  type: TYPE_NORMAL
- en: 'In some scenarios, the health check APIs are split into two types based on
    the state of the application that they probe. They are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readiness probes**: These indicate that the application is running normally
    but is not ready to take requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liveliness probes**: These indicate whether the application has crashed and
    must be restarted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both readiness and liveliness probes are used to control the health of the application.
    A failing readiness probe will stop the application from serving traffic, whereas
    a failing liveliness probe will restart the node. We use readiness and liveliness
    probes in hosting environments, such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about how to add the health check API to an ASP.NET Core 6 application.
    In the next section, we will learn about Azure Application Insights and how it
    helps to monitor an application.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the application with Application Insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring the application is key to providing end users with a top-class experience.
    Application monitoring is needed to drive business return on investment and retain
    a competitive advantage in the current era of super-fast digital markets. The
    parameters we should be focusing on are page/API performance, most-used pages/APIs,
    application errors, and system health, among others. There should be alerts set
    up for when there is an anomaly in the system so that we can correct it and minimize
    the impact on our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'You were already introduced to integrating Application Insights into an application
    and its key features in [*Chapter 7*](B18507_07_Epub.xhtml#_idTextAnchor596),
    *Logging in .NET 6*. Let''s open Application Insights in the Azure portal and
    understand its different offerings. On the overview dashboard, along with the
    Azure subscription, location, and instrumentation key, we see key metrics as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Application Insights dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – Application Insights dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The **Failed requests** graph shows the number of requests that failed in the
    selected duration. This is the key metric we should pay attention to; many failures
    represent instability in the system. **Server response time** represents the average
    response time of the server for the calls. If the response time is too high, more
    users will see a lag in the application responsiveness, which might lead to frustration
    and we could lose our users as a result.
  prefs: []
  type: TYPE_NORMAL
- en: The **Server requests** graph represents the total number of calls to the application;
    this will give us the patterns of the usage in the system. The **Availability**
    graph represents the uptime of the application. The availability tests that we
    will configure later in this chapter will show the **Availability** graph. By
    clicking on each graph, we can get more details pertaining to the respective metric,
    including requests and exception details. We can change the duration to view the
    graphs for the chosen interval.
  prefs: []
  type: TYPE_NORMAL
- en: The graphs on the overview dashboard show recent metrics. This can be useful
    in a situation where we wish to know the working of the system for a particular
    time in the past.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about some of the most important offerings
    from Application Insights, looking at Live Metrics, telemetry events, and remote
    debugging features.
  prefs: []
  type: TYPE_NORMAL
- en: Live Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Live Metrics is enabled by default. Live metrics are captured with a latency
    of 1 second, unlike the analytics metrics, which are aggregated over time. The
    data for Live Metrics is streamed only when the Live Metrics pane is open. The
    collected data only persists while it is on the chart. During Live Metrics monitoring,
    all the events are transmitted from the server and they won't be sampled. We can
    also filter the events by the server if the application is deployed in a web farm.
  prefs: []
  type: TYPE_NORMAL
- en: Live Metrics shows various charts, such as the incoming and outgoing requests,
    along with the overall health of the memory and CPU utilization. On the right-hand
    pane, we can see the captured telemetry, which will list the requests, dependency
    calls, and exceptions. Live Metrics is leveraged where we want to evaluate a fix
    that is released to production by watching the failure rates and performance.
    We will also monitor these while running a load test to see the effects of the
    load on the system.
  prefs: []
  type: TYPE_NORMAL
- en: For applications such as our `Ecommerce` app, it is important to know how users
    are using the application, the most-used features, and how users are traversing
    through the application. In the next section, we will learn about usage analysis
    in Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Usage analysis with Application Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228), *Creating an ASP.NET
    Core 6 Web Application*, you learned how to integrate Application Insights with
    views. When Application Insights is integrated with views, Application Insights
    helps us with powerful insights into how people are using an application. The
    **Users** blade under the **Usage** section of Application Insights provides details
    about the number of users using the application. The user is identified by using
    anonymous IDs stored in browser cookies. Please note that a single person using
    different browsers and machines is counted as more than one user. The **Sessions**
    and **Events** blades represent the sessions of user activity and how often certain
    pages or features are used respectively. You can also generate reports on users,
    sessions, and events based on custom events, which you learned about in [*Chapter
    7*](B18507_07_Epub.xhtml#_idTextAnchor596), *Logging in .NET 6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting tool available under usage analysis is **User Flows**.
    The **User Flows** tool visualizes how users navigate through different pages
    and features of an application. User flows provide the events that happened before
    and after the given event during the user session. *Figure 14.7* shows the user
    flows at a given time. This tells us that from the home page, users are mainly
    navigating to the **Product Details** page or the **Account Sign In** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – User flow in our Ecommerce application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.7_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.7 – User flow in our Ecommerce application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a couple of custom events and see what the user flow is like against
    those custom events. Add one custom event, as shown in the following code snippet,
    in the `Create` action method of `OrderController` in the `Packt.Ecommerce.Web`
    application. This will track a custom event when the user clicks on the **Place
    Order** button on the **Cart** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s add a custom event tracking when the user clicks on the **Add
    to Cart** button on the **Product Details** page. To do this, add the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After adding the custom events, the user flow will show the different activities
    of the application with respect to these events. User Flows is a handy tool to
    know how many users are navigating away from a page and what they click on a page.
    Please refer to the Azure Application Insights documentation provided in the *Further
    reading* section at the end of the chapter to learn more about the other interesting
    offerings for usage analysis, including cohorts, funnels, and retention.
  prefs: []
  type: TYPE_NORMAL
- en: When there are enough telemetry events, you can use an Application Insights
    feature called **Smart Detection**, which automatically detects anomalies in the
    system and alerts us to them. In the next section, we will learn about Smart Detection.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smart Detection does not need any configuration or code changes. It works on
    the telemetry data captured from the system. Alerts will be displayed under the
    **Smart Detection** blade in the system and these alerts will go to users with
    the **Monitoring Reader** and **Monitoring Contributor** roles. We can configure
    additional recipients for these alerts under the **Settings** option. Some of
    the Smart Detection rules include **Slow page load time**, **Slow server response
    time**, **Abnormal raise in daily data volume**, and **Degradation in dependency
    volume**.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important aspects we need to monitor for an application is availability.
    In the next section, we will learn how to leverage Application Insights to monitor
    application availability.
  prefs: []
  type: TYPE_NORMAL
- en: Application availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Application Insights, we can set up availability tests for any `http` or
    `https` endpoints accessible from the internet. This does not require any changes
    to our application code. We can configure the health check endpoint at `(<App
    Root URL>/health)` for an availability test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure an availability test, go to the Application Insights resource
    in the Azure portal and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Availability** under the **Investigate** menu, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Application Insights'' Availability section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.8_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.8 – Application Insights' Availability section
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add test** to add an availability test, as highlighted in the preceding
    screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Commerce availability test`), select `<<App root url>>/health`. Leave
    the other options at their default values and click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the test is configured, Application Insights will call the configured
    URL every 5 minutes from all the configured regions. We can see the availability
    test results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Availability test results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.9_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.9 – Availability test results
  prefs: []
  type: TYPE_NORMAL
- en: The default regions selected while creating the tests were **Brazil South**,
    **East Asia**, **Japan East**, **Southeast Asia**, and **UK South**. We can add
    or remove any of the regions on which the availability test will be run. It is
    recommended to configure at least five regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to add a new region at a later point in time, we can edit the availability
    test and select the new region (for example, **West Europe**) as shown in the
    following screenshot and then click on **Save**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Editing availability test regions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.10_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.10 – Editing availability test regions
  prefs: []
  type: TYPE_NORMAL
- en: We can also configure a multi-step web test as an availability test in Application
    Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following documentation to help you configure a multi-step
    web test: [https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep](https://docs.microsoft.com/en-us/azure/azure-monitor/app/availability-multistep).'
  prefs: []
  type: TYPE_NORMAL
- en: Application Insights provides a very good tool to query the telemetry events
    captured. In the next section, we will learn about the **Search** feature in Application
    Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Search** feature in Application Insights helps to explore telemetry events
    such as requests, page views, and exceptions. We can also query the traces that
    we have coded in the application. **Search** can be opened from the **Overview**
    tab or from the **Search** option of the **Investigate** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Search results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.11_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.11 – Search results
  prefs: []
  type: TYPE_NORMAL
- en: With the **Transaction Search** feature, we can filter the telemetry events
    displayed based on time and **Event Type**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also filter on their properties. By clicking on a specific event, we
    can view all the properties of the event along with the telemetry of the event.
    To view the requests with status code **500**, filter the events based on the
    response code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Filtering search results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.12_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.12 – Filtering search results
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we apply the filter, in the search results, we will only see requests
    with the response code 500, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13 – Filtered search results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.13_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.13 – Filtered search results
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about what caused the failure, click on the event. Clicking on
    the event will show the details of the related telemetry, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14 – End-to-end transaction details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.14_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.14 – End-to-end transaction details
  prefs: []
  type: TYPE_NORMAL
- en: We can even drill down more by clicking on the exception. This will show details
    such as the method name and the stack trace, which will help us identify the cause
    of the failure.
  prefs: []
  type: TYPE_NORMAL
- en: With Application Insights, we can write custom queries on the telemetry data
    that was captured to get more meaningful insights. In the next section, we will
    learn about writing queries.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write queries on the telemetry data that is captured, let''s navigate to
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **Application Insights** | **Monitoring** | **Logs**. This will show
    the **Logs** page with sample queries that we can run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Application Insights logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.15_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.15 – Application Insights logs
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Request count trend** in the suggested sample queries. This will generate
    a query for us and run it. Once the run is complete, we will see the results and
    the chart populated, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.16 – Log search results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.16_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.16 – Log search results
  prefs: []
  type: TYPE_NORMAL
- en: The telemetry that is captured in Application Insights goes into different tables
    covering requests, exceptions, dependencies, traces, and page views. The query
    generated here summarizes the telemetry data from the request table and renders
    a time chart where the time axis is split by 30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: We select the time range as per our requirements. We can even specify the time
    range in the query rather than selecting from the menu options. These queries
    created here can be saved and rerun at a later time. There is also an option to
    configure alerts here, which we learned about in [*Chapter 7*](B18507_07_Epub.xhtml#_idTextAnchor596),
    *Logging in .NET 6*. The language used here to write the queries is Kusto.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following documentation to learn about Kusto Query Language: [https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/concepts/).'
  prefs: []
  type: TYPE_NORMAL
- en: Kusto is based on relational database constructs. With Kusto Query Language,
    we can write complex analytical queries. Kusto supports group-by aggregation,
    computed columns, and join functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another example, where we want to identify the 95th percentile
    service response time for each client city. The query for this will be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding query, we are using the `percentile` function to identify the
    95th percentile and summarize it per region. The results are rendered as a bar
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the preceding query, we see the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17 – Kusto percentile summary results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.17_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.17 – Kusto percentile summary results
  prefs: []
  type: TYPE_NORMAL
- en: From the rendered graph, we can infer that the response time for a request coming
    from **Chennai** is faster than for requests from **Secunderabad**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s find any exceptions that caused a request failure and summarize
    them by request and exception type. To get the result for this, we will join the
    `requests` table with `exceptions` and summarize them based on request name and
    exception type, as shown in the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the query, we get the results summarized by the name of the request
    and the type of the exception, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18 – Kusto failing request exception'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.18_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.18 – Kusto failing request exception
  prefs: []
  type: TYPE_NORMAL
- en: Search is a powerful feature of Application Insights to diagnose and fix failures
    in a production site. It is recommended to click through the different features
    of Application Insights and explore them.
  prefs: []
  type: TYPE_NORMAL
- en: When you create an Application Insights resource, a **Log Analytics workspace**
    will be created that persists the telemetry captured through Application Insights.
    Using **Log Analytics** workspaces along with application metrics, we can also
    query and monitor the key metrics related to Azure resources such as RU/s consumed
    in Cosmos DB. All the queries we ran in this section were executed on the **Log
    Analytics** workspace. We can create a dashboard in the Azure portal and pin all
    the charts related to the key metrics we wanted to track for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the Azure documentation to learn more about Log Analytics: [https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to monitor the application deployed in Azure
    using Azure Monitor. To analyze and troubleshoot any production failures better,
    we might want to know the state of an application when a specific error occurred.
    In the next section, we will learn how the **Snapshot Debugger** feature of Application
    Insights enables us to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Snapshot Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Snapshot Debugger monitors the exception telemetry of our application. It
    automatically collects snapshots of the top exceptions that occurred in the application
    with the current state of the source code and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Snapshot Debugger feature is only available in the Enterprise version of
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go ahead and configure the Snapshot Debugger for our `Ecommerce`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Microsoft.ApplicationInsights.SnapshotCollector` NuGet package to the
    `Packt.Ecommerce.Web` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statement to `Startup.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a Snapshot Collector to your services by adding the following line to the
    `ConfigureServices` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To simulate a failure, add the following code to the `GetProductsAsync` method
    of the `EcommerceService` class. This code will throw an error if there are any
    products available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's go ahead and run the application. We see an error on the home page.
    Refresh the page again, as the debugging snapshot is for errors that occur at
    least twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the **Search** tab in Application Insights. Filter by the **Exception**
    event types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.19 – Exceptions telemetry'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.19_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.19 – Exceptions telemetry
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the exception to go to the details page. On the details page, we see
    that the debug snapshot has been created for the exception, as highlighted in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.20 – Debug snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.20_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.20 – Debug snapshot
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Debug Snapshot** icon. This will take us to the **Debug Snapshot**
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.21 – Debug Snapshot window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.21_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.21 – Debug Snapshot window
  prefs: []
  type: TYPE_NORMAL
- en: To view the debug snapshots, the **Application Insights Snapshot Debugger Role**
    is required. As the debug state might have sensitive information, this role is
    not added by default. Click on the **Add Application Insights Snapshot Debugger
    Role** button. This will add the role to the currently logged-in user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the role addition is complete, we can then see the debug snapshot details
    populated on the page, along with a button to download the snapshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.22 – Download debug snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.22_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.22 – Download debug snapshot
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `diagsession`. Open the downloaded `diagsession` file in Visual
    Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.23 – Debug snapshot view in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.23_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.23 – Debug snapshot view in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on `InvalidOperationException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.24 – Debugging snapshot in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.24_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.24 – Debugging snapshot in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: In this debug session, we may add a watch to the local variables and class variables
    to understand the state they are in, which will aid in debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following documentation to understand more about the Snapshot
    Debugger configurations: [https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm](https://docs.microsoft.com/en-us/azure/azure-monitor/app/snapshot-debugger-vm).'
  prefs: []
  type: TYPE_NORMAL
- en: As the application grows and is integrated with multiple other services, it
    will be challenging to troubleshoot and debug those issues that occur in production
    environments. In some cases, it is not possible to reproduce them in the pre-production
    environment. With the telemetry that we capture and the tools available with Application
    Insights, we will be able to analyze the problem and address the issue. The Snapshot
    Debugger is a powerful tool to troubleshoot critical issues. Application Insights
    collects telemetry data and sends it in batches via a background process. The
    impact of using Application Insights on our application is small.
  prefs: []
  type: TYPE_NORMAL
- en: There might be instances where we want to debug a live application. With Visual
    Studio, we are able to attach a debugger to a remotely running application to
    debug it. In the next section, we will learn how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Performing remote debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to attach a debugger to our deployed application
    in Azure App Service. Debugging a remote application is easy with the tooling
    provided by Visual Studio. Deploying an application in Azure App Service is covered
    in [*Chapter 16*](B18507_16_Epub.xhtml#_idTextAnchor1932), *Deploying the Application
    in Azure*. We can attach a debugger to an already-deployed service by performing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the **Publish** window by right-clicking on the **Packt.Ecommerce.Web**
    project and select **Publish** from the context menu. You can also launch the
    **Publish** window by setting the **Build** | Publish **Packt.Ecommerce.Web**
    menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Publish** profile to **Packt.Ecommerce.Web** by selecting the Azure
    App Service resource in the Publish Wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the **Publish** profile is created, you can attach the debugger to the
    application instance running in Azure App Service by selecting **Attach Debugger**
    from the **Hosting** options, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.25 – Visual Studio''s Publish window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.25_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.25 – Visual Studio's Publish window
  prefs: []
  type: TYPE_NORMAL
- en: Once the debugger is attached, the application will be opened in the browser
    from Azure App Service. We can add breakpoints in Visual Studio and debug the
    application as we would in a local development environment. To debug effectively,
    we need the debug version of the application deployed to Azure App Service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Though this is a powerful feature for debugging remotely deployed applications,
    we should be extra cautious when attaching the debugger to the production instance,
    as we will be seeing live customer data. We can attach the debugger to the staging
    slot of Azure App Service to debug and fix the issue, and from there, swap the
    staging slot to promote the fix to production. There are many more important features
    in Application Insights and Azure Monitor that are not covered in this chapter.
    It is strongly recommended to explore them further in the Azure documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the concepts of health checks and diagnosing
    problems with applications using Application Insights. We have learned how to
    build a health check API and add a health check module to our `Ecommerce` application,
    which will help us monitor the health of an application. This chapter also covered
    some of the key features of Azure Application Insights, which is a powerful tool
    to capture telemetry and diagnose problems.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how Application Insights detects anomalies and alerts with the
    Smart Detection feature. We have also learned about snapshots and remote debugging,
    which help to troubleshoot problems in live applications running in production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about different testing methodologies
    to ensure the quality of an application before deploying it to production.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading this chapter, we should be able to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Periodic monitoring of the application is not that important for an application
    once it is deployed to production. True or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. True
  prefs: []
  type: TYPE_NORMAL
- en: b. False
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the interface that a custom health check module should implement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `IHealth`
  prefs: []
  type: TYPE_NORMAL
- en: b. `IApplicationBuilder`
  prefs: []
  type: TYPE_NORMAL
- en: c.`IHealthCheck`
  prefs: []
  type: TYPE_NORMAL
- en: d. `IWebHostEnvironment`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the latency in displaying Live Metrics data in Application Insights?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. 1 minute
  prefs: []
  type: TYPE_NORMAL
- en: b. 1 second
  prefs: []
  type: TYPE_NORMAL
- en: c. 10 seconds
  prefs: []
  type: TYPE_NORMAL
- en: d. 5 seconds
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the query language used to write queries in Application Insights logs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. SQL
  prefs: []
  type: TYPE_NORMAL
- en: b. C#
  prefs: []
  type: TYPE_NORMAL
- en: c. JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: d. Kusto
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Application Insights documentation: [https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
