<html><head></head><body>
<div id="_idContainer143">
<h1 class="chapter-number" id="_idParaDest-221"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-222"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.2.1">Creating Your Own Conventions</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Correlation is one of the most important parts of observability. </span><span class="koboSpan" id="kobo.3.2">Distributed tracing bring correlation by propagating trace context, allowing us to follow individual operations, and consistent attributes enable correlation across traces and other </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">telemetry signals.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In </span><a href="B19423_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Best Practices</span></em><span class="koboSpan" id="kobo.9.1">, we talked about the importance of reusing standard attributes and following OpenTelemetry semantic conventions. </span><span class="koboSpan" id="kobo.9.2">Sometimes we need to go further and define our own conventions. </span><span class="koboSpan" id="kobo.9.3">Here, we’re going to explore how to define custom attributes and conventions and use them across </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">First, we’ll list properties that should be standardized across the system, and then we’ll explore how to populate them with shared code. </span><span class="koboSpan" id="kobo.11.2">Finally, we’ll look at OpenTelemetry’s semantic convention schema and see how it can simplify documenting and validating </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">custom conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, you’ll learn how to do </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Identify and document common attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and conventions</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Share instrumentation and custom conventions across </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the system</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Use OpenTelemetry tooling to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">create conventions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">With this, you should be able to create easy-to-use processes and tools to keep custom telemetry and attributes consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">and stable.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">The code for this chapter is available in the book’s repository on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">To run the examples and perform analysis, we’ll need the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.30.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">docker-compose</span></strong></span></li>
</ul>
<h1 id="_idParaDest-224"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.35.1">Defining custom conventions</span></h1>
<p><span class="koboSpan" id="kobo.36.1">There are multiple ways to express even the most basic things. </span><span class="koboSpan" id="kobo.36.2">If we take our meme application example from </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.38.1">, </span><em class="italic"><span class="koboSpan" id="kobo.39.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.40.1">, we enriched all spans with the </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.41.1">meme name attribute so that we can find when the meme was uploaded or how frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">it’s accessed.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">We chose that approach, but we could instead write a log with the meme name once, and then use slightly more complicated queries to find all traces related to that meme. </span><span class="koboSpan" id="kobo.43.2">We could come up with something else, but what’s important is to keep the approach consistent across </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">Even with a custom attribute added to each span, there are still plenty of things to consider when recording such </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">an attribute:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.47.1">Attribute name</span></strong><span class="koboSpan" id="kobo.48.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">meme_name</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">meme.name</span></strong><span class="koboSpan" id="kobo.52.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">memeName</span></strong><span class="koboSpan" id="kobo.54.1"> are different attributes. </span><span class="koboSpan" id="kobo.54.2">Unless we document </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.55.1">the exact name and define it as a constant somewhere, someone will eventually use the wrong variation </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">of it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Type</span></strong><span class="koboSpan" id="kobo.58.1">: The meme</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.59.1"> name is just a string. </span><span class="koboSpan" id="kobo.59.2">What if we wanted to capture the size or the image format? </span><span class="koboSpan" id="kobo.59.3">We need to document the type and maybe provide helper methods to record attributes so that it’s easier to set </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">them correctly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.61.1">Value</span></strong><span class="koboSpan" id="kobo.62.1">: We need to document what this </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.63.1">attribute represents. </span><span class="koboSpan" id="kobo.63.2">For example, if we add the image format, should it be represented with a MIME type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">image/png</span></strong><span class="koboSpan" id="kobo.65.1"> or as </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">an enumeration?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">When recording a meme name, we extract it from the uploaded filename, and we need to document what should be recorded on the attribute value (absolute or relative path, filename, with or without extension). </span><span class="koboSpan" id="kobo.67.2">If, when writing business logic, we sanitize or escape the meme name, or generate a unique one, we probably want to capture the one used by the business logic. </span><span class="koboSpan" id="kobo.67.3">We may also record the original name just once for debugging purposes.</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">When to populate the attribute</span></strong><span class="koboSpan" id="kobo.69.1">: Document on which metrics, spans, and logs the attribute should be recorded. </span><span class="koboSpan" id="kobo.69.2">For example, meme names have high cardinality and do not belong on metrics. </span><span class="koboSpan" id="kobo.69.3">The meme name attribute can be recorded on spans and logs, but which ones? </span><span class="koboSpan" id="kobo.69.4">In our example in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.70.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.71.1">, </span><em class="italic"><span class="koboSpan" id="kobo.72.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.73.1">, we recorded the meme name on all spans and a couple of specific </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">log records.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.75.1">There are other aspects</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.76.1"> you might want to document: relationships between spans, event names, whether to record exceptions on spans, attribute cardinality, stability, and </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">We’ll see how to formally define attributes in the </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Using OpenTelemetry schemas and tools</span></em><span class="koboSpan" id="kobo.80.1"> section of this chapter. </span><span class="koboSpan" id="kobo.80.2">Now, let’s focus </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">on naming.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.82.1">Naming attributes</span></h2>
<p><span class="koboSpan" id="kobo.83.1">Naming is known to be one of the</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.84.1"> hardest problems in </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">computer science.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">If we named the meme name attribute </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">document.id</span></strong><span class="koboSpan" id="kobo.88.1">, it might precisely match a property in the database schema. </span><span class="koboSpan" id="kobo.88.2">However, it would be very generic and have a high chance of collision with another similar concept in the system. </span><span class="koboSpan" id="kobo.88.3">People who are not familiar with the internals but analyze business data might have a hard time understanding what </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">document.id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1"> represents.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">meme_name</span></strong><span class="koboSpan" id="kobo.92.1"> seems to be intuitive, short, and descriptive, and the chances of a collision with something else are low. </span><span class="koboSpan" id="kobo.92.2">It seems fine, but we’ll probably have other attributes and should put them into an application-specific or </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">company-specific namespace.</span></span></p>
<h3><span class="koboSpan" id="kobo.94.1">Namespaces</span></h3>
<p><span class="koboSpan" id="kobo.95.1">Namespaces allow us to set </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.96.1">unique, specific, descriptive, and </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">consistent names.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Since we have called our system </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">memes</span></strong><span class="koboSpan" id="kobo.100.1">, let’s use it as the root namespace. </span><span class="koboSpan" id="kobo.100.2">This will help us understand that all attributes in this space come from our customizations and are not set by </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">some auto-instrumentation.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">This helps us navigate between telemetry and makes it possible to do filtering, redaction, and other post-processing in telemetry pipelines. </span><span class="koboSpan" id="kobo.102.2">For example, if we want to remove unknown attributes from logs, we can consider everything in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">memes</span></strong><span class="koboSpan" id="kobo.104.1"> namespace (http, </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">db</span></strong><span class="koboSpan" id="kobo.106.1">, and so on) to </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">be known.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">We can have nested namespaces. </span><span class="koboSpan" id="kobo.108.2">Since we’d like to record </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.109.1">other meme properties, such as size and type, we can end up with the following set of attributes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">memes.meme.name</span></strong><span class="koboSpan" id="kobo.111.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">memes.meme.size</span></strong><span class="koboSpan" id="kobo.113.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">memes.meme.type</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">We can easily add other properties as we see fit, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">memes.meme.author</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.117.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">memes.meme.description</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">memes.meme</span></strong><span class="koboSpan" id="kobo.122.1"> might look repetitive, it’ll start to make more sense once we add something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">memes.user.name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.124.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">memes.tag.description</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">The OpenTelemetry naming convention (available at </span><a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md"><span class="koboSpan" id="kobo.128.1">https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md</span></a><span class="koboSpan" id="kobo.129.1">) uses a dot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">.</span></strong><span class="koboSpan" id="kobo.131.1">) as a separator </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">between namespaces.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">For multi-word namespaces or attributes, OpenTelemetry recommends </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">snake_case</span></strong><span class="koboSpan" id="kobo.135.1">: for example, we could </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">introduce </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">memes.meme.creation_date</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Following this convention for our custom attributes allows us to stay consistent across all attributes. </span><span class="koboSpan" id="kobo.139.2">It will also reduce the chance of mistakes while </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">writing queries.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Having a schema defined and documented in some form is an essential step. </span><span class="koboSpan" id="kobo.141.2">But how can we keep it in sync with the code and ensure all services follow it? </span><span class="koboSpan" id="kobo.141.3">One way to do so is by capturing it in code and reusing it across </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">the system.</span></span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.143.1">Sharing common schema and code</span></h1>
<p><span class="koboSpan" id="kobo.144.1">Consistent telemetry reporting applies to </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.145.1">telemetry collection configuration. </span><span class="koboSpan" id="kobo.145.2">First, we need to enable a basic layer of instrumentation on all services, which should include resource utilization metrics, traces, and metrics for HTTP, gRPC, or any other RPC protocol used in </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">your system.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">We should also configure sampling and resource attributes, add enrichment processors, and set up </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">context propagators.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Individual services should be able to customize configuration to some extent: add more instrumentations, enable custom activity sources and meters, or control </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">log verbosity.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">The easiest way to unify configuration is to ship corresponding code as a common library (or a set of them) shared across all the services in your system. </span><span class="koboSpan" id="kobo.151.2">Such libraries would define configuration options, provide helper methods to enable telemetry collection, implement common</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.152.1"> enrichment processors, declare cross-service events, and so on. </span><span class="koboSpan" id="kobo.152.2">Let’s go ahead and implement such a </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">configuration helper.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.154.1">Sharing setup code</span></h2>
<p><span class="koboSpan" id="kobo.155.1">In </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.156.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.157.1">, </span><em class="italic"><span class="koboSpan" id="kobo.158.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.159.1">, and other chapters where we used meme application, we applied OpenTelemetry configuration individually in </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">each service.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">We’d never do this in production </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.162.1">code – it’s hard to keep our configurations, instrumentation options, OpenTelemetry package versions, and anything else </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">in sync.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">To fix this, we can start extracting common pieces of instrumentation code into a shared library. </span><span class="koboSpan" id="kobo.164.2">Since the configuration can slightly vary from service to service, we’ll need to define some </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">configuration options.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">We need are options that would help us to set the service name, specify the sampling rate or strategy, enable additional instrumentations, and more. </span><span class="koboSpan" id="kobo.166.2">You can find an example of such options in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">MemesTelemetryConfiguration</span></strong><span class="koboSpan" id="kobo.168.1"> class in the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">book’s repository.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Then we can declare a helper method that takes care of the OpenTelemetry configuration. </span><span class="koboSpan" id="kobo.170.2">Here’s an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this method:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">OpenTelemetryExtensions.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
public static void ConfigureTelemetry(
  this WebApplicationBuilder builder,
  MemesTelemetryConfiguration config)
{
  var resourceBuilder = GetResourceBuilder(config);
  var sampler = GetSampler(config.SamplingStrategy,
    config.SamplingProbability);
  builder.Services.AddOpenTelemetry()
    .WithTracing(builder =&gt; builder
      .SetSampler(sampler)
      .AddProcessor&lt;MemeNameEnrichingProcessor&gt;()
      .SetResourceBuilder(resourceBuilder)
      .AddHttpClientInstrumentation(o =&gt;
        o.ConfigureHttpClientCollection(
          config.RecordHttpExceptions))
      .AddAspNetCoreInstrumentation(o =&gt;
         o.ConfigureAspNetCoreCollection(
           config.RecordHttpExceptions,
           config.AspNetCoreRequestFilter))
      .AddCustomInstrumentations(config.ConfigureTracing)
      .AddOtlpExporter())
  ...
</span><span class="koboSpan" id="kobo.173.2">}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs"><span class="koboSpan" id="kobo.174.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs</span></a></p>
<p><span class="koboSpan" id="kobo.175.1">All services that use this method </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.176.1">will have the same basic level of instrumentation applied and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">enriched consistently.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Here’s an example of using this method in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.179.1">storage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> service:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">storage/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
var config = new MemesTelemetryConfiguration();
builder.Configuration.GetSection("Telemetry").Bind(config);
config.ConfigureTracing = o =&gt; o
  .AddEntityFrameworkCoreInstrumentation();
builder.ConfigureTelemetry(config);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs"><span class="koboSpan" id="kobo.183.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.184.1">Here, we read the telemetry </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.185.1">options from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Telemetry</span></strong><span class="koboSpan" id="kobo.187.1"> section of the ASP.NET Core configuration, which you can populate in any way that works </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Then, we add the Entity Framework instrumentation. </span><span class="koboSpan" id="kobo.189.2">Only the </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">storage</span></strong><span class="koboSpan" id="kobo.191.1"> service </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">needs it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.193.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.194.1">Having a central library that enables collection helps to reduce version hell. </span><span class="koboSpan" id="kobo.194.2">By having a dependency on it, individual service packages get a transitive dependency on OpenTelemetry packages and should never add them as direct dependencies. </span><span class="koboSpan" id="kobo.194.3">Services that need an uncommon instrumentation library would still need to install the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">NuGet package.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Now that we have a common setup, let’s see what we can do to help services follow our custom </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">semantic conventions.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.198.1">Codifying conventions</span></h2>
<p><span class="koboSpan" id="kobo.199.1">In the previous example, we started </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.200.1">recording the meme name attribute – we enabled </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">MemeNameEnrichingProcessor</span></strong><span class="koboSpan" id="kobo.202.1">, which sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">memes.meme.name</span></strong><span class="koboSpan" id="kobo.204.1"> attribute on each span. </span><span class="koboSpan" id="kobo.204.2">Individual services don’t need to do anything to enable it and cannot set the wrong </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">attribute name.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Still, we might need to use the attribute directly in some other parts (for example, on logs), so it’s important to declare the attribute name as a constant and never use a string literal in the code. </span><span class="koboSpan" id="kobo.206.2">Here’s an example demonstrating how attribute names can </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">be declared:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">SemanticConventions.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
public class SemanticConventions
{
    public const string MemeNameKey = "memes.meme.name";
    public const string MemeSizeKey = "memes.meme.size";
    public const string MemeTypeKey = "memes.meme.type";
    …
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs"><span class="koboSpan" id="kobo.210.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs</span></a></p>
<p><span class="koboSpan" id="kobo.211.1">OpenTelemetry also provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">OpenTelemetry.SemanticConventions</span></strong><span class="koboSpan" id="kobo.213.1"> NuGet package, which declares common attributes defined in the specification. </span><span class="koboSpan" id="kobo.213.2">It might make sense to add a dependency to it when reusing </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">common attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">So, we have now </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.216.1">defined constants for the attribute names, and we have a processor that populates the meme name. </span><span class="koboSpan" id="kobo.216.2">Can we </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">do more?</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">We can provide helpers to report common events in a performant and consistent manner. </span><span class="koboSpan" id="kobo.218.2">Let’s look at how we can use the high-performance logging we explored in </span><a href="B19423_08.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.219.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.220.1">, </span><em class="italic"><span class="koboSpan" id="kobo.221.1">Writing Structured and Correlated Logs</span></em><span class="koboSpan" id="kobo.222.1">, to populate </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">our attributes:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">EventService.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
private static readonly Action&lt;ILogger, string, string?,
  long?, string, string, Exception&gt; LogDownload =
    LoggerMessage.Define&lt;string, string?,
      long?, string, string&gt;(
    LogLevel.Information,
    new EventId(1),
    $"download {{{SemanticConventions.MemeNameKey}}}
    {{{SemanticConventions.MemeTypeKey}}}
    {{{SemanticConventions.MemeSizeKey}}}
    {{{SemanticConventions.EventNameKey}}}
    {{{SemanticConventions.EventDomainKey}}}");
  …
  public void DownloadMemeEvent(string memeName,
    MemeContentType type,
    long? </span><span class="koboSpan" id="kobo.225.2">memeSize) =&gt;
  LogDownload(_logger,
    memeName,
    ContentTypeToString(type),
    memeSize,
    SemanticConventions.DownloadMemeEventName,
    SemanticConventions.MemesEventDomain,
    default!);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs"><span class="koboSpan" id="kobo.226.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs</span></a></p>
<p><span class="koboSpan" id="kobo.227.1">Here, we have </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.228.1">some difficult-to-read code. </span><span class="koboSpan" id="kobo.228.2">It defines a log record representing the meme download event by following the OpenTelemetry conventions and our own conventions. </span><span class="koboSpan" id="kobo.228.3">We would not want to write this code every time we needed to </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">log something.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Implementing this event once in the common library and making it easy to reuse is the best way to record the event consistently and with a low </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">performance overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Now, anyone can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">DownloadMemeEvent</span></strong><span class="koboSpan" id="kobo.234.1"> method, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">following example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">StorageService.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
_events.DownloadMemeEvent(name, MemeContentType.PNG,
    response.Content.Headers.ContentLength);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs"><span class="koboSpan" id="kobo.238.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs</span></a></p>
<p><span class="koboSpan" id="kobo.239.1">This is easy to use and performant, and there is no need to worry about attributes, their types, or any conventions at all. </span><span class="koboSpan" id="kobo.239.2">If attributes are renamed, there is no need to update the service code – it’s all hidden in the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">shared library.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">If we follow this approach, we can define other events and add helper methods to populate attribute groups on metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">and traces.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">If we need any custom instrumentations, like we had for gRPC or messaging, we should put them into shared </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.244.1">libraries and apply all the attributes there instead of in the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">service code.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">Separating telemetry-related code from business logic makes them both easier to read and maintain. </span><span class="koboSpan" id="kobo.246.2">It also makes telemetry-related code testable and helps us to keep it in sync with documentation. </span><span class="koboSpan" id="kobo.246.3">It also becomes easy to enforce conventions with tests and notice during code review when shared code changes something controlled by semantic conventions and </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">breaks them.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">Defining semantic conventions in code is sufficient for some applications. </span><span class="koboSpan" id="kobo.248.2">Others, which may use different languages or have some other constraints, cannot rely on shared code alone. </span><span class="koboSpan" id="kobo.248.3">Either way, telemetry can be used by everyone in the company for business reporting and for any non-technical needs. </span><span class="koboSpan" id="kobo.248.4">So, it’s important to document it separately </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">from code.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Let’s see how we can do this using </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">OpenTelemetry tooling.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.252.1">Using OpenTelemetry schemas and tools</span></h1>
<p><span class="koboSpan" id="kobo.253.1">It does not really matter how we</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.254.1"> document custom semantic conventions. </span><span class="koboSpan" id="kobo.254.2">The goal is to have a consistent and specific convention that’s easy to read and follow. </span><span class="koboSpan" id="kobo.254.3">Let’s see how the OpenTelemetry semantic conventions schema may help </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">with this.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.256.1">Semantic conventions schema</span></h2>
<p><span class="koboSpan" id="kobo.257.1">So far, when we have talked about semantic conventions, we have referred to Markdown files such as </span><a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md"><span class="koboSpan" id="kobo.258.1">https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md</span></a><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">These files are the source of truth, but here, we’re</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.260.1"> going to take a look at the implementation details </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">behind them.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">The tables describing the attributes in these files are usually auto-generated. </span><span class="koboSpan" id="kobo.262.2">Attributes are defined in YAML files that follow OpenTelemetry’s semantic </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">convention schema.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">YAML files could be shared across different semantic conventions and signals and then consistently written to all Markdown files with </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">a script.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s see how our meme attributes can be defined in a YAML file to get an impression of </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the schema:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.268.1">memes-common.yaml</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
groups:
  - id: memes.meme
    type: attribute_group
    brief: "Describes memes attributes."
</span><span class="koboSpan" id="kobo.269.2">    </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">prefix: memes.meme</span></strong><span class="koboSpan" id="kobo.271.1">
    attributes:
      </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">- id: name</span></strong><span class="koboSpan" id="kobo.273.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">  type: string</span></strong><span class="koboSpan" id="kobo.275.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">  requirement_level: required</span></strong><span class="koboSpan" id="kobo.277.1">
        brief: 'Unique and sanitized meme name'
        examples: ["this is fine"]</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml"><span class="koboSpan" id="kobo.278.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml</span></a></p>
<p><span class="koboSpan" id="kobo.279.1">Here, we defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">name</span></strong><span class="koboSpan" id="kobo.281.1"> attribute with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">string</span></strong><span class="koboSpan" id="kobo.283.1"> type inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">memes.meme</span></strong><span class="koboSpan" id="kobo.285.1"> namespace (defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">prefix</span></strong><span class="koboSpan" id="kobo.287.1"> property). </span><span class="koboSpan" id="kobo.287.2">It’s a required attribute since, in </span><a href="B19423_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.288.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.289.1">, </span><em class="italic"><span class="koboSpan" id="kobo.290.1">Configuration and Control Plane</span></em><span class="koboSpan" id="kobo.291.1">, we decided to record the meme name attribute on all </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the spans.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">OpenTelemetry supports several </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">requirement levels:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">required</span></strong><span class="koboSpan" id="kobo.296.1">: Any telemetry item that follows this convention must set </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the attribute.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">conditionally_required</span></strong><span class="koboSpan" id="kobo.299.1">: The attribute must be populated when a condition is met. </span><span class="koboSpan" id="kobo.299.2">For example, http.route is only populated when routing is enabled and a route </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">is available.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">recommended</span></strong><span class="koboSpan" id="kobo.302.1">: The </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.303.1">attribute should be populated, but may be removed or disabled. </span><span class="koboSpan" id="kobo.303.2">Observability backends and tools should not rely on it being available. </span><span class="koboSpan" id="kobo.303.3">This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">default level.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">opt_in</span></strong><span class="koboSpan" id="kobo.306.1">: The attribute is not populated by default, but is known and documented, and it can be added when it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">explicitly enabled.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.308.1">Let’s see how we can define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">size</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1"> attribute:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.311.1">memes-common.yaml</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.312.1">- id: size</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.313.1">  type: int</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.314.1">  requirement_level: opt_in</span></strong><span class="koboSpan" id="kobo.315.1">
  brief: 'Meme size in bytes.'
</span><span class="koboSpan" id="kobo.315.2">  examples: [49335, 12345]</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml"><span class="koboSpan" id="kobo.316.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml</span></a></p>
<p><span class="koboSpan" id="kobo.317.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">size</span></strong><span class="koboSpan" id="kobo.319.1"> attribute has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">int</span></strong><span class="koboSpan" id="kobo.321.1"> type (and maps to </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">int64</span></strong><span class="koboSpan" id="kobo.323.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">long</span></strong><span class="koboSpan" id="kobo.325.1">) and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">opt-in</span></strong><span class="koboSpan" id="kobo.327.1"> level as we don’t want to record it on all telemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">Finally, we can define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> attribute:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">memes-common.yaml</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.333.1">- id: type</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.334.1">  type:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.335.1">  members:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.336.1">    - id: png</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.337.1">      value: "png"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.338.1">      brief: 'PNG image type.'</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.339.1">    - id: jpg</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.340.1">      value: "jpg"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.341.1">      brief: 'JPG image type.'</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.342.1">    - id: unknown</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.343.1">      value: "unknown"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.344.1">      brief: 'unknown type.'</span></strong><span class="koboSpan" id="kobo.345.1">
  requirement_level: opt_in
  brief: 'Meme image type.'
</span><span class="koboSpan" id="kobo.345.2">  examples: ['png', 'jpg']</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml"><span class="koboSpan" id="kobo.346.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml</span></a></p>
<p><span class="koboSpan" id="kobo.347.1">Here, we define </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">type</span></strong><span class="koboSpan" id="kobo.349.1"> as an enumeration. </span><span class="koboSpan" id="kobo.349.2">Instrumentation must use one of the values defined here or set </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">type</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.351.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">unknown</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">I hope your team won’t </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.355.1">spend too much time deciding between JPEG and JPG – either is fine. </span><span class="koboSpan" id="kobo.355.2">What’s important is to pick and document </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">one option.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">You can find the full schema definition in the OpenTelemetry build tools repository on GitHub (https://github.com/open-telemetry/build-tools/blob/main/semantic-conventions/syntax.md). </span><span class="koboSpan" id="kobo.357.2">It also contains the schema definition that your IDE may use to autocomplete and validate </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">schema files.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Now that we have defined a few attributes, let’s use another OpenTelemetry tool to validate the schema</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.360.1"> file and generate content in a </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">Markdown file.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">If you look at the raw </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">memes.md</span></strong><span class="koboSpan" id="kobo.364.1"> file in the book repository, it contains documentation with the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">following annotations:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">memes.md</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
&lt;!-- semconv memes.meme --&gt;
...
</span><span class="koboSpan" id="kobo.367.2">&lt;!-- endsemconv --&gt;</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md"><span class="koboSpan" id="kobo.368.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md</span></a></p>
<p><span class="koboSpan" id="kobo.369.1">Content in between these lines is auto-generated from the YAML group that has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">memes.meme</span></strong><span class="koboSpan" id="kobo.371.1"> identifier. </span><span class="koboSpan" id="kobo.371.2">We can regenerate this content with the following command (make sure to specify </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">the path):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.373.1">
chapter14$ docker run \
  -v /path/to/chapter14/semconv:/source \
  -v /path/to/chapter14/semconv:/destination \
  otel/semconvgen:latest \
  -f /source markdown -md /destination</span></pre>
<p><span class="koboSpan" id="kobo.374.1">Here, we use the Markdown generator from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">otel/semconvgen</span></strong><span class="koboSpan" id="kobo.376.1"> image. </span><span class="koboSpan" id="kobo.376.2">We mount the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">source</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">destination</span></strong><span class="koboSpan" id="kobo.380.1"> volumes. </span><span class="koboSpan" id="kobo.380.2">The generator recursively parses all YAML files found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">source</span></strong><span class="koboSpan" id="kobo.382.1"> folder and then generates attribute tables in Markdown files available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">destination</span></strong><span class="koboSpan" id="kobo.384.1"> folder based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">semconv</span></strong><span class="koboSpan" id="kobo.386.1"> annotations we </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">saw earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">The generation is the cherry on top of the cake, and you might not need it initially. </span><span class="koboSpan" id="kobo.388.2">Still, if you decide to use OpenTelemetry semantic convention schemas, make sure to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">otel/semconvgen</span></strong><span class="koboSpan" id="kobo.390.1"> tool to </span><em class="italic"><span class="koboSpan" id="kobo.391.1">validate</span></em><span class="koboSpan" id="kobo.392.1"> YAML files, which you can do as a part of your CI run; just add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">–md-check</span></strong><span class="koboSpan" id="kobo.394.1"> flag to the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">previous command.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">The tooling also supports generating attribute definitions in code using Jinja templates (https://jinja.palletsprojects.com). </span><span class="koboSpan" id="kobo.396.2">All we need is to create a Jinja template for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">SemanticConventions.cs</span></strong><span class="koboSpan" id="kobo.398.1"> file and run the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">otel/semconvgen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1"> generator.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">We can also define tracing, metrics, or </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.402.1">event-specific conventions. </span><span class="koboSpan" id="kobo.402.2">Let’s do it </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">for events.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.404.1">Defining event conventions</span></h2>
<p><span class="koboSpan" id="kobo.405.1">Meme upload and download </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.406.1">events are important for business reporting. </span><span class="koboSpan" id="kobo.406.2">We can’t really expose them as metrics – meme names have high cardinality and we’re interested in finding the most popular ones or measuring other </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">per-meme things.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">To avoid breaking business reporting, we need to make sure events are defined precisely enough and are well documented. </span><span class="koboSpan" id="kobo.408.2">To achieve this, we can declare an event in the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">following way:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.410.1">memes-events.yaml</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
- id: meme.download.event
  </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">type: event</span></strong><span class="koboSpan" id="kobo.413.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">prefix: download_meme</span></strong><span class="koboSpan" id="kobo.415.1">
  brief: "Describes meme download event."
</span><span class="koboSpan" id="kobo.415.2">  Attributes:
    - ref: memes.meme.name
    </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">- ref: memes.meme.size</span></strong><span class="koboSpan" id="kobo.417.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">  requirement_level: required</span></strong><span class="koboSpan" id="kobo.419.1">
    - ref: memes.meme.type
      requirement_level: required</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml"><span class="koboSpan" id="kobo.420.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml</span></a></p>
<p><span class="koboSpan" id="kobo.421.1">Here, we declare a group with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">event</span></strong><span class="koboSpan" id="kobo.423.1"> type (previously, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">attribute_group</span></strong><span class="koboSpan" id="kobo.425.1">, which is signal agnostic). </span><span class="koboSpan" id="kobo.425.2">We provided a prefix (</span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">download_name</span></strong><span class="koboSpan" id="kobo.427.1">) that documents the event name. </span><span class="koboSpan" id="kobo.427.2">We added references to attributes defined previously, but now require the presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">size</span></strong><span class="koboSpan" id="kobo.429.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">type</span></strong><span class="koboSpan" id="kobo.431.1"> attributes on these </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">events only.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">You might have noticed that the </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.434.1">event name does not contain a namespace – here, we follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">event</span></strong><span class="koboSpan" id="kobo.436.1"> semantic convention. </span><span class="koboSpan" id="kobo.436.2">If you look at the corresponding code snippet for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">EventService</span></strong><span class="koboSpan" id="kobo.438.1"> class, we also record the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">event.domain</span></strong><span class="koboSpan" id="kobo.440.1"> attribute, which serves as </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">a namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">With this approach, we can define spans or metric conventions that reuse the same </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">common attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">These schemas or corresponding Markdown files would define and document the contract between telemetry producers and consumers regardless of the language </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">they use.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.446.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.447.1">In this chapter, we talked about different ways to keep custom telemetry and attributes consistent across your system. </span><span class="koboSpan" id="kobo.447.2">We identified attribute properties to be documented and learned about attribute </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">naming conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Keeping telemetry consistent is a challenge. </span><span class="koboSpan" id="kobo.449.2">We explored how to make it easier by sharing common instrumentation code, including OpenTelemetry setup and utility methods that report attributes with the right names </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">and types.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">Finally, we learned about the OpenTelemetry semantic conventions schema and tooling, which may help you define, validate, and automate the documentation process for </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">custom conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Defining a common schema for telemetry during the early stages of a project is going to save your organization a lot of time down the road, and now you have the knowledge and tools to do it. </span><span class="koboSpan" id="kobo.453.2">In the next chapter, we’ll talk about brownfield systems, where new solutions coexist with legacy ones, and we’ll see how difficult it can be to align different standards </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">and conventions.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.455.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.456.1">It’s likely that alerts, dashboards, and usage reporting depend on custom telemetry and rely on conventions. </span><span class="koboSpan" id="kobo.456.2">How would you approach evolving conventions to prevent breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">something critical?</span></span></li>
<li><span class="koboSpan" id="kobo.458.1">Is it possible to validate that telemetry coming from some service follows defined </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">semantic conventions?</span></span></li>
</ol>
</div>
</body></html>