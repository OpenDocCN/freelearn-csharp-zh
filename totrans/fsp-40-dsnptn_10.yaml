- en: Chapter 10. Type Augmentation and Generic Computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To this point in the book, it was easy to notice the direct link between the
    use pattern and the correspondent language feature. For example, [Chapter 5](text00049.html#page
    "Chapter 5.  Algebraic Data Types") , *Algebraic Data Types* , clearly showed
    that the native F# algebraic types are substitutes for custom classes. Increased
    quality and speed of implementations based on algebraic data types reflect the
    payoff for the feature use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will consider a certain language features that do not make
    the payoff from their use obvious. Nevertheless, these features are ubiquitous
    in F#. I mean the ambivalent pair of code generalization against the code specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Code generalization techniques, or making the same functional code applicable
    to multiple function argument types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code specialization techniques, or making the functional code more specific
    than usually may be achieved by using standard features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the preceding patterns carries promises of certain benefits: improved
    performance, more succinctness, and better static type control. The goal of this
    chapter is to show you how to recognize the situations when these patterns are
    applicable and apply them, achieving the expected benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: Code generalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me begin by stating that F# **automatically generalizes** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d)
    ) arguments of functions where it is possible to deal with the multiplicity of
    types.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have mostly been dealing with the generalization of data collections.
    That is, a sequence is agnostic to the type of its elements. That's why we were
    able to write functions that operate on sequences of arbitrary generic type. And
    F# type inference spots and carries this property on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we proudly implement our own function of reversing a list as follows
    (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we may notice that the F# compiler infers the `reverse : ls:''a list
    -> ''alist` signature for it, where `''a` indicates that the function can be applied
    to any type of list elements. And if we decide to check out how exactly our `reverse`
    function would behave with different argument types, we may observe its behavior
    is consistent for the following arguments (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And even if we try to slightly abuse type system and mix different boxed types
    (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `reverse` function behaves as genuinely generic with regard to the type
    of argument list elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fine, now let''s do something seemingly similar and also utterly simple, such
    as shifting the argument to the left by a single bit (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All of a sudden, the F# compiler infers the very specific `twice : x:int ->
    int` function signature. What''s going on? Apparently, there are some types that
    allow this geeky way of making the value twice as big, for example, `int64` .
    Interestingly, let''s look at what happens when we follow the function definition
    by the usage, as following (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the F# compiler has seemingly changed its mind about the signature of the
    `twice`  function, this time inferring the argument and result types as `int64`
    . This action is irreversible, which means that trying to follow the preceding
    evaluation with `twice 10` will be now rejected with this diagnostics: *this expression
    was expected to have type* `int64`   *but it has type* `int`   *here* .'
  prefs: []
  type: TYPE_NORMAL
- en: What's going on? Why does the generalization seemingly fail?
  prefs: []
  type: TYPE_NORMAL
- en: Statically resolved type parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we just noticed, the F# compiler inferred a monomorphic type for the (`<<<`
    ) operator. A step toward polymorphism would assume the ability to express it
    somehow - while staying within the .NET type system that only such types are fine
    to be `twice` argument that work with the operator (`<<<` ). In other words, the
    compiler should deal with a **type constraint** .
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that this kind of constraint cannot be expressed within the F#
    compilation target language **MSIL** . That is, the latest **.NET CLI standard**
    ([http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf)
    ) in the *II.10.1.7 Generic Parameters* section constraints a type either by being
    a **value type** or a **reference type** for a concrete reference type that has
    the **default constructor** . This is the problem of the .NET type system rather
    than the F# language or compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**F# 4.0 Language Specification** ([http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf](http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf)
    ) hints at the observed compiler behavior in section *5.2.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Uses of overloaded operators do not result in generalized code unless definitions
    are marked as inline. For example, take a look at the function as shown here:*
    `let f x = x + x`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It results in an f function, which can be used only to add one type of value,
    such as int or float. The exact type is determined by later constraints* .'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fortunately, the F# compiler may enforce these (and some other) type of constraints
    at compile-time using the mechanism of **statically resolved type parameters**
    . This type parameter for our (`<<<` ) operator will have the special "hat" prefix
    `^a` , assuming that the type is statically known at the point of compilation
    (compared to `'a` , assuming that the type can be anything). As this kind of statically
    polymorphic function would require a specific manner of compilation depending
    on the concrete statically resolved type that is aligned with constraints, the
    F# compiler achieves this goal with the help of **inlining** , as the language
    specification has hinted.
  prefs: []
  type: TYPE_NORMAL
- en: Function inlining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let me apply the inlining mechanism to this failing `twice` function as shown
    here (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the automatically inferred signature of the inlined `twice''` function
    carries the **hat** type `^a` along with the sought-for constraint regarding the
    type parameter statically resolved at compile-time: type `^a` must have an operator
    (`<<<` ) with the `^a * int32 -> ^a` signature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, now `twice''` begins to look like a polymorphic function, allowing,
    for example, the following evaluations (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, it disallows the following evaluations (`Ch10_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compiler has provided all the above niceties after we merely added the `inline`
    qualifier to the function definition. But you should realize that the compiler
    literally injects the inlined function implementation into MSIL adjusting it for
    argument(s) having statically resolved concrete types. Inlining is the compilation
    method that allows to alleviate .NET CLR limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Static constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As it was inferred by the F# compiler for the `twice''` function earlier, the
    argument `x` can be any type `^a` as long as `^a : (static member (<<<) : ^a *
    int32 -> ^a).` This condition, either inferred by the F# compiler or, perhaps,
    intentionally imposed by the programmer is named a **static constraint** ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D)
    ). There are about a dozen of argument type constraint kinds. You may check the
    **documentation** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints)
    ) for their complete list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints can be combined together with the help of the `and` construction,
    as shown in the following code snippet (`Ch10_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two discriminated unions here: `Good` , which is **equitable** and
    **comparable** by default, and `Bad` , which is also normally equitable and comparable,
    but here it is decorated with `[<NoEquality; NoComparison>]` attributes. As the
    `constrained` function requires its generic `param` argument to be of both equitable
    and comparable types, `constrained Good` gets compiled, while `constrained Bad`
    does not.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit or inferred constraining?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few years ago, I was tinkering with creating F# generic code. At that time,
    my thinking was along these lines: if I need to create a generic function that
    can deal with a restricted handful of argument types, the right approach would
    be to appropriately and explicitly constrain the latter. I even asked on **StackOverflow**
    ([http://stackoverflow.com/q/16737675/917053](http://stackoverflow.com/q/16737675/917053)
    ) what the idiomatic approach would be. **One of the answers** ([http://stackoverflow.com/a/16738811/917053](http://stackoverflow.com/a/16738811/917053)
    ) I want to quote here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit constraints are a way of stating *what you want to do* . What could
    be better than *doing it* and having the compiler statically prove that the argument
    is valid for the operations?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enlightening observation, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, what if you still want to explicitly limit the list of generic
    functions'' valid argument types based on some external considerations? Then,
    you may use the following approach I was hinted at in **the other answer** ([http://stackoverflow.com/a/16739483/917053](http://stackoverflow.com/a/16739483/917053)
    ) to my StackOverflow question, which is based on overloading static methods of
    the auxiliary type (`Ch10_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three components in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The **private** function, `impl` , which performs a required action on a generic
    restricted argument of type `'a` ; in other words, upon an argument that's not
    constrained whatsoever
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The auxiliary type `Restricting` , which has a single discriminated union case,
    `Restrict` , augmented by the overloaded static member `$` upon the required set
    of types (`byte` , `sbyte` , `int` , `uint32` , `bigint` picked just for the sake
    of illustration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user-facing function `doit` , whose restricted argument has been statically
    constrained by the other two pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the workings of the preceding in the following script (`Ch10_2.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first five use cases matching the restricted types compile just fine; the
    last four do not compile with the same diagnostics as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '*no overloads match the `op_Dollar"` method*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The successful execution of the first five use cases is presented in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explicit or inferred constraining?](img/Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing explicitly constrained generic code
  prefs: []
  type: TYPE_NORMAL
- en: Inlining scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inlining in F# is not limited to just module-level functions. It is perfectly
    fine to use inlining for static and instance methods of F# types. For example,
    in the following snippet, where we have type `Bar` with a static method `doIt`
    and `type Foo` on any generic type `^T` that has static member `doIt` with the
    matching signature and the `inline` member `Invoke` calling the `doIt` method
    of `^T` as shown here (`Ch10_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: An intricate matter that the preceding sample illustrates is accessing static
    or instance `inline` methods from outside of F# using, for example, a plain C#
    -> F# interoperability scenario. Remember that normal MSIL cannot support such
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: To address this subtlety the compiled MSIL for `Invoke` method implementation
    above that C# may access just throws an exception. The actual inlined body of
    the function is kept accessible only from F# in its assembly's metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Inline optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The relationship between inlining and code optimization is quite subtle. Usually,
    it is difficult to predict what consequences of generalization via inlining would
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes, it is possible to achieve tremendous performance improvements
    via inlining. A notorious example is the F# handling of the `System.DateTime`
    equality, where the compilation of the `datetime1 = datetime2` expression involves
    boxing. Take a look at the following snippet (`Ch10_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, using just the `=` operator, we observe a certain garbage collection activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, suppose we just inline the redefined equality operator, `==` , as
    shown in the following snippet (`Ch10_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, we achieve no garbage collection activity whatsoever and an impressive
    *19(!)* times better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Writing generic code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I would like to wrap up the theme of writing generic code with just another
    example of a non-trivial generic function that I have implemented as a **sample
    for a "functional programming" interview** ([https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/](https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/)
    ): given an arbitrary positive number, find a next higher number consisting of
    the same digits. If that does not exist, then return the original number.'
  prefs: []
  type: TYPE_NORMAL
- en: We will approach the solution as a generic function, allowing the argument to
    be of any integral type, or anything consisting of just digits, be it `byte` ,
    `BigInteger` , or `nativeint` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The base line approach would be to split the number into a list of digits,
    making the list of all digit permutations, assembling digits back into numbers,
    sorting the list of numbers, and finally, picking the element next to the given
    argument. Apparently, the time and space complexities of this "solution" are awful,
    so let''s improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: The first useful observation of the optimized solution would be that the solution
    exists if a pair of adjacent digits exists in the given number, where the left-hand
    side is strictly less than the right-hand side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next useful observation would be that if we scan the list of digits of the
    given number from right to left by a sliding window of width 2, then the first
    pair that matches the first observation would be the place of change. Everything
    to the left of it (if any exists) must stay intact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final useful observation is to take the pair that matches the second observation.
    The sublist to the right including the right element of the pair is sorted from
    right to left. The digit that must substitute the left element of the pair must
    be the minimally greater digit from the sublist. The left element that we just
    substituted should be placed some place to the right, preserving the sublist order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if we concatenate (if nonempty) the sublist to the left of the changing
    digit, followed by the substituting digit, followed by the reversed sublist after
    accommodating the changing digit and convert the resulting digit list to the number,
    this would yield the solution with a surprisingly good time complexity of `O(n)`
    and a space complexity of `O(n)` , where n is the number of digits in the original
    number. The solution snippet is as follows (`Ch10_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this in action by running some usage cases via FSI as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing generic code](img/Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generic implementation of non-trivial function
  prefs: []
  type: TYPE_NORMAL
- en: Take into account the complexity of the static constraint expression that the
    F# compiler has inferred for `nextHigher` , as shown in the preceding screenshot.
    It would be really challenging to come up with an expression that complicated
    from the top of your head. Let the compiler do its job indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Type augmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The opposite of generalization is specialization, and it is associated with
    **type augmentation** in F#. It is worth noting that the official **F# 4.0 Language
    Specification** ([http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf](http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf)
    ) does not introduce this terminology using **type extension** instead. Nevertheless,
    the *type augmentation* expression is de-facto ubiquitous and used interchangeably
    with *type extension* . Personally, I believe that *augmentation* is free of the
    undesired connotation that *extension* carries as something that's *added* to
    an existing matter. Augmentation is a better synonym for the *specialization*
    of an existing matter by adding, customizing, or even removing features. So we
    will stick to it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows two flavors of type augmentation available in F#.
    Both use the same syntax but represent different use cases. Intrinsic augmentation
    customizes your own code, while optional augmentation may customize types outside
    of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type augmentation](img/Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: F# flavors of type augmentation
  prefs: []
  type: TYPE_NORMAL
- en: 'But why would you need to customize your own code in the first place? This
    is where certain F#-specific patterns of usage kick in. They can be spotted time
    and again both inside the F# core libraries and outside in third-party extensions.
    They explain how a bare type gets created first and then acquires an associated
    module that carries some helper functions and finally, how the type gets extended
    by some static methods. We can consider the **definition of complex type** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs)
    ) as a manifestation of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: On `complex.fs`   **source line 13** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L13](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L13)
    ), the bare type `Complex` is defined as having custom `equality` and `comparison`
    properties and being the value type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `complex.fs`   **source line 39** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L39](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L39)
    ), the module `Complex` is defined as carrying the entire slew of helper functions
    covering, in particular, all math operations in complex numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on `complex.fs`   **source line 99** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L99](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L99)
    ), type `Complex` is supplied by static operators for complex math numbers expressed
    via previously defined helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding definition may be considered as a very neat template of idiomatic
    intrinsic augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Let me walk you through some typical use cases of augmenting types.
  prefs: []
  type: TYPE_NORMAL
- en: Augment by removing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first glance, augment by removing may sound like an oxymoron. However, it
    is not; just bear with me. Take a look at the following code snippet (`Ch10_4.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, my intent was to hide the pattern matching behind properties of the discriminated
    union type `Outcome` . However, suddenly, this seemingly innocuous piece of code
    does not compile, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Augment by removing](img/Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: F# DU implementation detail leaks out
  prefs: []
  type: TYPE_NORMAL
- en: The F# compiler accompanies the red squiggle line under the `IsFailure` property
    name with a surprise message (refer to the preceding screenshot), prompting that
    the compiler also augments each `<Name>` use case of discriminated unions with
    the `Is<Name>` private property by default, and by defining the identically named
    property, we made this detail leak out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we effectively remove default compiler-generated augmentation from the
    `Outcome` definition? It so happens that we can do that using the .NET attribute
    especially designated for this purpose: **DefaultAugmentation** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: If we just decorate the `Outcome` type definition with the `[<DefaultAugmentation(false)>]`
    attribute, then everything gets back to the intuitively expected behavior, and
    the property name clash shown above vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: Augment by adding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let me do quite the opposite and augment types by adding features. I'm going
    to use a real (simplified, of course) case from Jet.com technology practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that Jet''s e-commerce platform supports the following transaction
    kinds (`Ch10_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we aggregate these transactions for payment or analytics purposes, it is
    highly desired that you operate upon collections that represent any mix of valid
    transactions. But we cannot mix different types in a typed collection, can we?
  prefs: []
  type: TYPE_NORMAL
- en: 'The naive brute-force approach might be exploiting the fact that any .NET type
    is a subtype of `System.Object.` So, the following collection might be perfectly
    OK (`Ch10_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this approach wipes out one of the major benefits of F#, namely static
    type safety, which means that unfortunately, having the following collection is
    also perfectly OK from the standpoint of the F# compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A hardcore OOP developer would continue to lean on inheritance, introducing
    something like the `Transaction` superclass as shown here (`Ch10_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is an acceptable approach, but it's not flexible from the standpoint of
    potential future extensions. Also it is awkward overall.
  prefs: []
  type: TYPE_NORMAL
- en: Any other ideas? Yes, type augmentation comes to the rescue! Well, in a sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me define a dummy **marker interface ** `ITransaction` , as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, unfortunately, F# does not allow you to add an interface to an already
    defined type later. But we can still define our transactions, augmenting the standard
    DU as following (`Ch10_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can use the idiomatic trick with F# supporting function contravariant
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can represent the sought-for collection as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Now `ll` is strongly typed `ITransaction` list, but it can
    carry any current (and future, if required) transaction kinds. Having the latter
    mixed together is not a big deal if a disassembly back to concrete transactions
    is needed, as following (`Ch10_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: (The cryptic turning off the compiler warning "25" in the beginning of the above
    script addresses the manner the matching by type works. The F# compiler assumes
    that it may be more types "implementing" `ITransaction` than are included into
    preceding `match` expression. I know that I covered all cases there, so the warning
    would be just a noise.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with this machinery, it is easy to perform, for example, an aggregation
    of a list of concrete transactions in a single payment (`Ch10_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding script in FSI will produce the results shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Augment by adding](img/Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Augmenting DU with the marker interface
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrated how to approach matters of code generalization and/or
    specialization in situations when such adjustments are appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will just scratch the surface of the advanced F# patterns,
    as their detailed coverage may require another book.
  prefs: []
  type: TYPE_NORMAL
