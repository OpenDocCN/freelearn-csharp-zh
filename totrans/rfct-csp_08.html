<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-174"><a id="_idTextAnchor173"/>8</h1>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Avoiding Code Anti-Patterns with SOLID</h1>
<p>The right design principles can keep your code from quickly going stale. While there are many right ways of writing code, there are anti-patterns and code smells that constitute the wrong way of writing code.</p>
<p>Additionally, the community has identified several principles to keep in mind when building software that can help your code resist accumulating technical debt for as long as possible. In this chapter, we’ll cover a number of these principles, including the famous SOLID acronym, and see how they can help you build software that actively resists the gradual decline toward legacy code.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Identifying anti-patterns in C# code</li>
<li>Writing SOLID code</li>
<li>Considering other architectural principles</li>
</ul>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Identifying anti-patterns in C# code</h1>
<p>I’ve often <a id="_idIndexMarker457"/>found myself telling new programmers that to build good software, you have to first build a lot of really bad software and learn from it.</p>
<p>While<a id="_idIndexMarker458"/> this statement is somewhat in jest, there is some truth to it: almost every developer can recognize code that’s written the wrong way and discover things that make it difficult to work with, and doing so helps you write better code the next time.</p>
<p>When your code is bad, there’s usually a part of you that knows it. You see little things that you don’t love: duplicated pieces of code, inconsistencies in naming or parameter ordering, passing too many parameters around, methods, or even classes that are just too big to manage effectively.</p>
<p>These symptoms are what we commonly refer to as <strong class="bold">code smells</strong>, and we’ll revisit them later in this section.</p>
<p>Beyond code<a id="_idIndexMarker459"/> smells are something called <strong class="bold">anti-patterns</strong>, which<a id="_idIndexMarker460"/> is code that significantly deviates from community recommendations. Unfortunately, not all anti-patterns are easy to notice or discover on your own, and some even seem like good ideas to individuals or teams until they’re fully explored.</p>
<p>A <a id="_idIndexMarker461"/>few common C# anti-patterns I see include throwing and catching an <code>Exception</code> error instead of a specific type of <code>Exception</code> error, not <a id="_idIndexMarker462"/>disposing of resources that implement <code>IDisposable</code>, and inefficient <strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>) statements. See the <em class="italic">Further reading</em> section of this chapter for more details on these anti-patterns.</p>
<p>There are far too many anti-patterns to cover in this book, and the established practices of .NET development evolve over time. Because of this constant change, Visual Studio offers code analysis tools to help spot and fix violations of community standards. These tools include code analysis rulesets and <a id="_idIndexMarker463"/>built-in <strong class="bold">Roslyn Analyzers</strong>, which we’ll cover at more length in <a href="B21324_12.xhtml#_idTextAnchor259"><em class="italic">Chapter 12</em></a>, <em class="italic">Code Analysis in </em><em class="italic">Visual Studio</em>.</p>
<p>Not all issues in code are specific to C# code. Many issues in code stem from how classes interact, pass data around to one another, manage variables, and are generally structured. These issues emerge even in code that you intended to be “well structured” as you start to see your systems scale up in size as new capabilities are added.</p>
<p>Thankfully, even new developers have an innate ability to spot code that is difficult to follow, requires more work to maintain and expand than it should, or involves excessive duplication. These types of issues in code are commonly referred to as <strong class="bold">code smells</strong>.</p>
<p class="callout-heading">What are code smells?</p>
<p class="callout">Code smells <a id="_idIndexMarker464"/>are prime indicators that your current architecture has some drawbacks and refactoring might be in order. Pay attention to these symptoms when you encounter them in systems, including the code you write yourself. Learning what makes code difficult to work with will help you write better code and refactor existing code into better forms.</p>
<p>For now, let’s move on to talk about writing <strong class="bold">SOLID code</strong>, which can help you avoid some common code smells and build robust, maintainable, and testable code.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Writing SOLID code</h1>
<p><strong class="bold">SOLID</strong> is an <a id="_idIndexMarker465"/>acronym introduced by Michael Feathers summarizing the words of Robert C. Martin. The intent of SOLID is to provide developers with a set of principles that will guide them toward more maintainable code that resists becoming technical debt.</p>
<p>The <a id="_idIndexMarker466"/>five principles of SOLID code are:</p>
<ul>
<li><strong class="bold">Single Responsibility </strong><strong class="bold">Principle</strong> (<strong class="bold">SRP</strong>)</li>
<li><strong class="bold">Open-Closed </strong><strong class="bold">Principle</strong> (<strong class="bold">OCP</strong>)</li>
<li><strong class="bold">Liskov Substitution </strong><strong class="bold">Principle</strong> (<strong class="bold">LSP</strong>)</li>
<li><strong class="bold">Interface Segregation </strong><strong class="bold">Principle</strong> (<strong class="bold">ISP</strong>)</li>
<li><strong class="bold">Dependency Inversion </strong><strong class="bold">Principle</strong> (<strong class="bold">DIP</strong>)</li>
</ul>
<p>In this section, we’ll cover all five of these principles.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Single Responsibility Principle</h2>
<p>The <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP)</strong> says<a id="_idIndexMarker467"/> that a class <a id="_idIndexMarker468"/>should be responsible for one thing and one thing only. Here are a few examples of classes that <a id="_idIndexMarker469"/>follow the SRP:</p>
<ul>
<li>A class responsible for saving application data to a specific file format</li>
<li>A database access class dedicated to executing queries against a database table or set of tables</li>
<li>An API controller providing REST methods to interact with flight data</li>
<li>A class representing the user interface in a specific part of your application</li>
</ul>
<p>Classes violate the SRP by trying to do more than one type of thing in the same class. More formally, if there’s ever more than one reason to modify a class, the class violates the SRP.</p>
<p>For <a id="_idIndexMarker470"/>example, if a class is responsible for tracking a set of items in a user interface, responding to button presses, parsing user input, and asynchronously fetching data, that class very likely violates the SRP.</p>
<p>Classes that<a id="_idIndexMarker471"/> violate the SRP tend to be frequently modified, grow in complexity over time, and be very large classes compared to other classes in the system. These classes can be hard to fully understand or adequately test and can become brittle and buggy as they grow in complexity.</p>
<p>One of the things that I do to help detect violations of the SRP is to have a class-level comment talking about what the class is responsible for. For example, the following XML comment describes the <code>FlightScheduler</code> class from <em class="italic">Part 1</em> of this book:</p>
<pre class="source-code">
<strong class="bold">/// &lt;summary&gt;</strong>
<strong class="bold">/// This class is responsible for tracking information</strong>
<strong class="bold">/// about current and pending flights</strong>
<strong class="bold">/// &lt;/summary&gt;</strong>
public class FlightScheduler {
  // Details omitted
}</pre>
<p>Here, the responsibility of <code>FlightScheduler</code> is clear: it exists to track active and pending flights within the system. Reasons for modifying this class should be related to the tracking of these flights and not related to other topics.</p>
<p>For this reason, I tend to put class-level comments in all classes whenever I define a new class to help that class stay focused on its mission over the course of its life.</p>
<p>But what if you have a class that already exists and violates the SRP?</p>
<p>When you have a class that’s responsible for multiple things, I like to look at everything the class is currently responsible for and group them into related groups of members. For example, if a class has 10 fields, 25 methods, and 6 properties, I might go through them and try to find common topics that those things address.</p>
<p>For example, if the <code>FlightScheduler</code> class violated the SRP, it might have members for <a id="_idIndexMarker472"/>the following:</p>
<ul>
<li>Scheduling and canceling flights</li>
<li>Assigning crew to flights</li>
<li>Booking flights for passengers</li>
<li>Changing seat assignments for passengers</li>
<li>Moving passengers to different flights</li>
<li>Generating flight-scheduling documentation for management</li>
</ul>
<p>This <a id="_idIndexMarker473"/>class, clearly, is responsible for more than one type of thing. In a production system, this class might be 2,000 lines long or more and be difficult to fully understand and adequately test. Additionally, changes to one area of the class might impact other areas in unexpected ways.</p>
<p>By looking at the groups of things a class addresses, you can usually identify a few key groups. I like to do this and then focus on the largest group of related responsibilities that are not clearly related to the core goal of the class. Once you identify these groupings, you can extract a new class to manage these aspects. Your original class can reference this class or store it as a field if needed, or the new class could operate completely independently of the old class.</p>
<p>In the case of <code>FlightScheduler</code>, I would say that scheduling and canceling flights is the core part of the class, and other aspects currently in the class might belong more elsewhere. Looking at those other areas, there are several things related to managing flight reservations for passengers, so in this case, a <code>FlightBookingManager</code> class might be introduced to contain these related pieces of logic.</p>
<p>By iteratively introducing new classes from functionality not related to the core responsibility of a class, you can shrink large classes down to manageable sizes and resist the complexity, quality, and testability issues found in classes that ignore the SRP.</p>
<p>The SRP doesn’t apply just to classes but can apply to methods as well. A method should have a single core task it is responsible for, and that purpose should be communicated by the name of the method. When a method is responsible for multiple things or starts getting too large, it’s a good sign that you might need to extract a method and pull some logic out of the original method to keep the size of the method maintainable.</p>
<p>Personally, if there<a id="_idIndexMarker474"/> were one programming principle I could impart to my younger self –or most early/intermediate developers out there, it would be the importance of the SRP in keeping your code easy to understand, test, expand, and maintain.</p>
<p>My personal guideline<a id="_idIndexMarker475"/> is to strive for classes under 200 lines of code long and methods under 20 lines of code long, but both can be challenging, and there are certainly exceptions to be made to these guidelines depending on the nature of the code you’re maintaining – remember that these are principles and guidelines, not firm rules or commandments.</p>
<p><em class="italic">If you only remember one part of SOLID, remember the SRP; it’s that important to the health of your application.</em> However, there are four more principles to explore.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Open-Closed Principle</h2>
<p>Classes <a id="_idIndexMarker476"/>are said<a id="_idIndexMarker477"/> to follow the <strong class="bold">Open-Closed Principle (OCP)</strong> when they are <em class="italic">open to extension</em> but <em class="italic">closed </em><em class="italic">to modification</em>.</p>
<p>This principle was originally written for C++ modules, and it doesn’t translate as cleanly to C# as some of the other SOLID principles, but this is essentially a principle about following <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) principles when designing your classes.</p>
<p>If you build something to follow the OCP, you are designing a class to have its behavior extended through other classes inheriting it, through customizable properties or parameters, or through composition where you compose your class of other objects that change how it behaves.</p>
<p>An example of using composition was covered in <a href="B21324_05.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a><em class="italic">: Object-oriented Refactoring</em> and involved providing different cargo items for a flight.</p>
<p>The rest of this section will focus on using inheritance to fulfill the OCP.</p>
<p>In C#, methods do not allow overriding by default. This means you’ll need to explicitly opt-in to allow others to override your methods by declaring them as <code>virtual</code>.</p>
<p class="callout-heading">Counterpoint</p>
<p class="callout">I’ve heard some developers argue that declaring methods as <code>virtual</code> without any classes overriding them is confusing, adds unnecessary keywords to your code, and even slightly harms the performance of your code at runtime. All these things can be true, but if you are in a scenario where you cannot predict how others will use your code and you know they won’t be able to modify your source code, marking key methods as <code>virtual</code> is usually a good idea. In these scenarios, <code>virtual</code> adds extra flexibility.</p>
<p class="callout">Remember that SOLID principles <em class="italic">are guidelines to keep in mind</em> while building software, not firm rules you need to always follow.</p>
<p>As a <a id="_idIndexMarker478"/>specific example of the OCP, let’s look at a sample <code>ItineraryManager</code> class representing information about a passenger’s flight <a id="_idIndexMarker479"/>itinerary as they travel via Cloudy Skies Airlines:</p>
<pre class="source-code">
public class ItineraryManager {
  public int MilesAccumulated {get; private set;}
  public FlightInfo? Flight {get; private set;}
  public virtual void FlightCompleted(FlightInfo? next) {
    if (Flight != null) {
      AccumulateMiles(Flight.Miles);
    }
    Flight = next;
  }
  public virtual void ChangeFlight(FlightInfo newFlight,
    bool isInvoluntary) =&gt;
    Flight = newFlight;
  public void AccumulateMiles(int miles) =&gt;
    MilesAccumulated += miles;
}</pre>
<p>Here, we have a class that tracks the total miles a passenger has accrued, as well as the next flight the passenger is scheduled to fly (which may be <code>null</code> when their trip is completed). The class has two <code>virtual</code> methods related to handling completed flights as well as canceled flights. Additionally, the class has a non-<code>virtual</code> method called <code>AccumulateMiles</code> that updates the miles the passenger has accumulated on this trip.</p>
<p>While this<a id="_idIndexMarker480"/> class meets the needs of the airline, let’s <a id="_idIndexMarker481"/>say that the airline wants to introduce a new logic for reward customers that gives them 100 extra miles for every flight they complete and rewards the scheduled mileage for a flight when the passenger is involuntarily moved to a new flight.</p>
<p>Under the OCP, we should be able to do this without having to modify our base class, assuming that the class is open to modification. It turns out we can do this with the following <code>RewardsItineraryManager</code> class:</p>
<pre class="source-code">
public class RewardsItineraryManager : ItineraryManager {
  private const int BonusMilesPerFlight = 100;
  public <strong class="bold">override</strong> void FlightCompleted(FlightInfo? next) {
    <strong class="bold">base</strong>.FlightCompleted(next);
    AccumulateMiles(BonusMilesPerFlight);
  }
  public <strong class="bold">override</strong> void ChangeFlight(FlightInfo newFlight,       bool isInvoluntary) {
    if (isInvoluntary &amp;&amp; Flight != null) {
       AccumulateMiles(Flight.Miles);
    }
    <strong class="bold">base</strong>.ChangeFlight(newFlight, isInvoluntary);
  }
}</pre>
<p>Without modifying our base class, we can extend the implementation of <code>ItineraryManager</code> with our new class that follows a slightly different logic. Thanks to the magic of polymorphism, we can use a <code>RewardsItineraryManager</code> class anywhere an <code>ItineraryManager</code> class is accepted, further supporting the closed-to-modification aspect of the OCP.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Liskov Substitution Principle</h2>
<p>The <strong class="bold">Liskov Substitution Principle </strong>(<strong class="bold">LSP</strong>) says <a id="_idIndexMarker482"/>that polymorphic code should not need to <a id="_idIndexMarker483"/>be aware of what specific types of objects it is working with.</p>
<p>That’s still a somewhat vague description, so let’s take another look at the <code>FlightCompleted</code> method from earlier:</p>
<pre class="source-code">
public virtual void FlightCompleted(<strong class="bold">FlightInfo? next</strong>) {
  if (Flight != null) {
    AccumulateMiles(<strong class="bold">Flight.Miles</strong>);
  }
  Flight = next;
}</pre>
<p>This method takes in a flight that it stores in the <code>Flight</code> property. If a prior flight was stored in that <code>Flight</code> property, the code will call the <code>AccumulateMiles</code> method with that flight’s <code>Miles</code> property.</p>
<p>The application has several classes that inherit from <code>FlightInfo</code>: <code>PassengerFlightInfo</code> and <code>CargoFlightInfo</code>. That means our <code>next</code> parameter may be any one of these three classes – or some other class that inherits from them.</p>
<p>The LSP says that <em class="italic">any</em> valid instance of <code>FlightInfo</code> should not error when you call its <code>Miles</code> property (or any other method). For example, this version of <code>CargoFlightInfo</code> would be a violation of the LSP because its <code>Miles</code> property errors when called:</p>
<pre class="source-code">
public class CargoFlightInfo : FlightInfo {
  public decimal TonsOfCargo { get; set; }
<strong class="bold">  public override int RewardMiles =&gt;</strong>
<strong class="bold">    throw new NotSupportedException();</strong>
}</pre>
<p>Essentially, when<a id="_idIndexMarker484"/> following the LSP, the method should not have any reason to need to know<a id="_idIndexMarker485"/> which subclass of <code>FlightInfo</code> it’s dealing with.</p>
<p>Because the LSP is focused on polymorphism, it applies to both class inheritance and interface implementations in .NET code.</p>
<p>Speaking of interfaces, let’s move on to the ISP.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Interface Segregation Principle</h2>
<p>The <strong class="bold">Interface Segregation Principle</strong> (<strong class="bold">ISP</strong>) is a<a id="_idIndexMarker486"/> fancy way of saying that you should prefer <a id="_idIndexMarker487"/>many smaller specialized interfaces focused on related capabilities over one large interface that encompasses everything your class does.</p>
<p>For example, imagine <a id="_idIndexMarker488"/>we had a <code>FlightRepository</code> class that managed database access to individual flights. In many systems, this class might implement an <code>IFlightRepository</code> interface that could be defined as follows with all public members of the class as part of the interface:</p>
<pre class="source-code">
public interface IFlightRepository {
  FlightInfo AddFlight(FlightInfo flight);
  FlightInfo UpdateFlight(FlightInfo flight);
  void CancelFlight(FlightInfo flight);
  FlightInfo? FindFlight(string id);
  IEnumerable&lt;FlightInfo&gt; GetActiveFlights();
  IEnumerable&lt;FlightInfo&gt; GetPendingFlights();
  IEnumerable&lt;FlightInfo&gt; GetCompletedFlights();
}</pre>
<p>As you can see, this manages common operations related to flights and provides some means of finding information about many flights. In a more real-world example, there would likely be many additional methods that would need to be added over the years to support new features.</p>
<p>In my <a id="_idIndexMarker489"/>experience with .NET code, it is very <a id="_idIndexMarker490"/>common to have a large interface per major class that includes all public methods in this class. This interface is usually named after the class it was based on and exists mostly to support testability through <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>), as<a id="_idIndexMarker491"/> we’ll touch on in the next chapter.</p>
<p>However, this approach is usually a violation of the ISP. Because our interfaces are designed around classes instead of discrete sets of capabilities, it becomes harder to introduce a new class that meets some of those capabilities but not all.</p>
<p>For example, let’s say that Cloudy Skies Airlines wants to integrate with another subsidiary airline’s systems. It doesn’t need to add, update, or delete flights, but it does want a way of searching for flights. Under the <code>IFlightRepository</code> interface, the <code>AddFlight</code>, <code>UpdateFlight</code>, and <code>CancelFlight</code> methods would either need to do nothing or throw a <code>NotSupportedException</code> error when called. By the way, throwing the exception on a not-supported method call as part of a larger interface would be a violation of the LSP mentioned earlier.</p>
<p>Instead of having one large interface per major type, the ISP advocates for small interfaces for tightly related capabilities. In the case of <code>FlightRepository</code>, it’s essentially doing two things:</p>
<ul>
<li>Adding, editing, and deleting flights</li>
<li>Searching for existing flights</li>
</ul>
<p>If we wanted to introduce interfaces, we could introduce interfaces for these separate sets of related capabilities, as shown here:</p>
<pre class="source-code">
public interface <strong class="bold">IFlightUpdater</strong> {
  FlightInfo AddFlight(FlightInfo flight);
  FlightInfo UpdateFlight(FlightInfo flight);
  void CancelFlight(FlightInfo flight);
}
public interface <strong class="bold">IFlightProvider</strong> {
  FlightInfo? FindFlight(string id);
  IEnumerable&lt;FlightInfo&gt; GetActiveFlights();
  IEnumerable&lt;FlightInfo&gt; GetPendingFlights();
  IEnumerable&lt;FlightInfo&gt; GetCompletedFlights();
}</pre>
<p>In this<a id="_idIndexMarker492"/> example, our <code>FlightRepository</code> class would implement both the <code>IFlightUpdater</code> interface and the <code>IFlightProvider</code> interface. If we wanted to integrate with another airline’s systems but didn’t have the ability to modify their flights, the <code>IFlightProvider</code> interface could<a id="_idIndexMarker493"/> be implemented without the <code>IFlightUpdater</code> interface.</p>
<p>By segmenting our interfaces into small interfaces that denote distinct sets of capabilities, we make it easier to provide alternative implementations of those capabilities as well as test our code later.</p>
<p>We’ve touched on DI a few times now; let’s explore that topic in more detail by covering the DIP and rounding out our SOLID principles.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Dependency Inversion Principle</h2>
<p>The <strong class="bold">Dependency Inversion Principle </strong>(<strong class="bold">DIP</strong>) states that<a id="_idIndexMarker494"/> your code should generally depend <a id="_idIndexMarker495"/>on abstractions instead of on specific implementations.</p>
<p>To illustrate<a id="_idIndexMarker496"/> this, let’s look at a <code>FlightBookingManager</code> class that helps passengers book flights. This class needs to register booking requests and send confirmation messages for the booking. Here’s its current code:</p>
<pre class="source-code">
public class FlightBookingManager {
  <strong class="bold">private readonly SpecificMailClient _email;</strong>
  public FlightBookingManager(<strong class="bold">string connectionString</strong>) {
    <strong class="bold">_email = new SpecificMailClient(connectionString);</strong>
  }
  public bool BookFlight(Passenger passenger,
    PassengerFlightInfo flight, string seat) {
    if (!flight.IsSeatAvailable(seat)) {
      return false;
    }
    flight.AssignSeat(passenger, seat);
    string message = "Your seat is confirmed";
    <strong class="bold">_email.SendMessage(passenger.Email, message);</strong>
    return true;
  }
}</pre>
<p>This code <a id="_idIndexMarker497"/>allows passengers to book a flight by checking if a seat is available, then reserving that seat and sending a message using the <code>_email</code> field. This field is set in the constructor to a new instance of <code>SpecificMailClient</code>, which is a made-up class representing some very specific implementation of an email client. The constructor needs to get a connection string to instantiate this class.</p>
<p>This code <a id="_idIndexMarker498"/>violates the DIP because our <code>FlightBookingManager</code> class is tightly coupled with a specific email client. If we ever wanted to write unit tests against this class, the class would always try to send messages to that email client, which usually isn’t what you want when testing.</p>
<p>Additionally, if the organization wanted to change email providers and you needed to switch to a different email client, the <code>FlightBookingManager</code> class would need to change along with anywhere else in the system where we were tightly coupled to use the <code>SpecificMailClient</code> class.</p>
<p>Dependency inversion flips this on its head by having our classes instead depend on abstractions of the specific things they depend on. This is usually done by depending on a base class such as <code>EmailClientBase</code> that is then inherited or through taking in an interface such as <code>IEmailClient</code> that specific clients can implement.</p>
<p>We typically <a id="_idIndexMarker499"/>take in these dependencies in the constructor as a constructor parameter. This version <a id="_idIndexMarker500"/>of our <code>FlightBookingManager</code> class would look like this:</p>
<pre class="source-code">
public class FlightBookingManager {
  <strong class="bold">private readonly IEmailClient _email;</strong>
  public FlightBookingManager(<strong class="bold">IEmailClient email</strong>) {
    <strong class="bold">_email = email;</strong>
  }
  public bool BookFlight(Passenger passenger,
    PassengerFlightInfo flight, string seat) {
    if (!flight.IsSeatAvailable(seat)) {
      return false;
    }
    flight.AssignSeat(passenger, seat);
    string message = "Your seat is confirmed";
    _email.SendMessage(passenger.Email, message);
    return true;
  }
}</pre>
<p>Here, instead of taking in a connection string, we now take in an <code>IEmailClient</code> class. This means our class doesn’t need to know which implementation it is dealing with or how to instantiate an instance of that class, doesn’t need a connection string, doesn’t need to change if the specific email provider ever changes, and can be tested easier by passing in a fake email client instead of a real one (we’ll talk more about this in the next chapter when discussing Moq).</p>
<p>This process of <a id="_idIndexMarker501"/>taking in a dependency from something else<a id="_idIndexMarker502"/> is called <strong class="bold">Dependency Inversion</strong> and is often an intimidating topic for new and intermediate developers, but at its core, Dependency Inversion is all about classes getting their dependencies passed into them instead of having to create specific instances themselves.</p>
<p>Following <a id="_idIndexMarker503"/>the DIP leads to more maintainable, flexible, and testable code.</p>
<p>This concludes the five principles in SOLID, but we still have a few more design principles to cover before closing out the chapter.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Considering other architectural principles</h1>
<p>Before we close out the chapter, let me share three brief principles that have helped me in my own journey toward good software.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/>Learning the DRY principle</h2>
<p><strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>) is an<a id="_idIndexMarker504"/> important tenant in software development. The DRY principle is<a id="_idIndexMarker505"/> oriented around making sure you don’t repeat the same patterns in code throughout your application. Code takes a while to write, read, and maintain, and bugs inevitably do occur at a certain rate per line of code. As a result, you want to strive to solve problems once in a centralized place and then reuse that solution.</p>
<p>Let’s look at some<a id="_idIndexMarker506"/> sample code that violates the DRY principle. This code takes in a <code>"CSA1234,CMH,ORD"</code> and translates it into a <code>FlightInfo</code> object:</p>
<pre class="source-code">
public FlightInfo ReadFlightFromCsv(string csvLine) {
  string[] parts = csvLine.Split(',');
  const string fallback = "Unknown";
  FlightInfo flight = new();
  if (parts.Length &gt; 0) {
    flight.Id = parts[0]?.Trim() ?? fallback;
  } else {
    flight.Id = fallback;
  }
  if (parts.Length &gt; 1) {
    flight.DepartureAirport = parts[1]?.Trim() ?? fallback;
  } else {
    flight.DepartureAirport = fallback;
  }
  if (parts.Length &gt; 2) {
    flight.ArrivalAirport = parts[2]?.Trim() ?? fallback;
  } else {
    flight.ArrivalAirport = fallback;
  }
  // Other parsing logic omitted
  return flight;
}</pre>
<p>Notice how the <a id="_idIndexMarker507"/>logic for parsing in each part of the CSV string is wrapped in checks against <code>null</code> values and the array of parts is empty. This code<a id="_idIndexMarker508"/> is very repetitive, and it’s easy to imagine that if a new field got added to the CSV data, the developer making the change would just copy and paste those five lines of code.</p>
<p>There are a few problems with repeating code patterns such as this:</p>
<ul>
<li>It encourages copying and pasting, which tends to produce poor code or results in bugs due to things that should have been changed on paste not being changed</li>
<li>If the logic for parsing an individual field needs to change (for example, to protect against empty strings), it now needs to be changed in many places</li>
</ul>
<p>We can fix<a id="_idIndexMarker509"/> this<a id="_idIndexMarker510"/> by extracting a method containing the logic for parsing fields:</p>
<pre class="source-code">
<strong class="bold">private string ReadFromCsv(string[] parts, int index,</strong>
<strong class="bold">  string fallback = "Unknown")</strong> {
  if (parts.Length &gt; index) {
    return parts[index]?.Trim() ?? fallback;
  } else {
    return fallback;
  }
}
public FlightInfo ReadFlightFromCsv(string csvLine) {
  string[] parts = csvLine.Split(',');
  FlightInfo flight = new();
<strong class="bold">  flight.Id = ReadFromCsv(parts, 0);</strong>
<strong class="bold">  flight.DepartureAirport = ReadFromCsv(parts, 1);</strong>
<strong class="bold">  flight.ArrivalAirport = ReadFromCsv(parts, 2);</strong>
  // Other parsing logic omitted
  return flight;
}</pre>
<p>Not only is this new version easier to maintain, but it also results in less code overall and helps focus your attention on parts of the logic that are different from section to section. This improves the readability of your code while also reducing your likelihood of making mistakes.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>KISS principle</h2>
<p>“<strong class="bold">Keep it simple, stupid</strong>” (abbreviated as <strong class="bold">KISS</strong> and sometimes called “<strong class="bold">Keep it simple, silly</strong>”) is a<a id="_idIndexMarker511"/> principle focused on the complexity of <a id="_idIndexMarker512"/>software systems. As software engineers, we sometimes overthink things and make things incredibly complex when they don’t need to be. KISS encourages you to keep your code and classes as simple as possible and expand the complexity only when truly necessary.</p>
<p>Typically, the more complexity you have in your systems, the longer it takes you to add new features, diagnose problems, onboard new team members, and resolve customer-facing issues. With more moving parts to your application, there are also more things that can break, meaning that complexity has a real chance of creating customer-facing issues—all for potential solutions to problems your organization won’t have for a few years.</p>
<p>Complexity tends to grow over time and rarely ever decreases (particularly in database schemas). Keep it simple until you see a pressing and compelling reason to add more complexity.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>Understanding high cohesion and low coupling</h2>
<p>Finally, let’s close the chapter out by reviewing two terms you’ll hear occasionally in software engineering: <strong class="bold">cohesion</strong> and <strong class="bold">coupling</strong>.</p>
<p>Cohesion <a id="_idIndexMarker513"/>has to do with how related different parts of<a id="_idIndexMarker514"/> the class are to the same thing. In a high-cohesion class, almost all parts of the class are oriented on the same types of capabilities. Let’s look again at the <code>IFlightUpdater</code> interface from earlier for an example:</p>
<pre class="source-code">
public interface IFlightUpdater {
  FlightInfo <strong class="bold">AddFlight</strong>(FlightInfo flight);
  FlightInfo <strong class="bold">UpdateFlight</strong>(FlightInfo flight);
  void <strong class="bold">CancelFlight</strong>(FlightInfo flight);
}</pre>
<p>A class that implemented everything in this interface and added no other members would be a good<a id="_idIndexMarker515"/> example of <em class="italic">high cohesion</em> because all members in this interface are related to working with the same type of item. A <em class="italic">low-cohesion</em> class<a id="_idIndexMarker516"/> would start with these methods but also add many methods related to booking flights, generating reports, searching data, or other capabilities.</p>
<p>Classes that have low cohesion usually also violate the SRP.</p>
<p>Coupling refers to how tightly paired together with other <a id="_idIndexMarker517"/>classes a single class is. The more classes an individual class needs to know about to do its job, the more tightly coupled it is. Classes with higher coupling are harder to test due to a larger number of dependencies and need to be modified more frequently as their related classes evolve over time.</p>
<p>The DIP provides a great way for classes to reduce their coupling.</p>
<p>So, when you <a id="_idIndexMarker518"/>hear people talk about wanting high cohesion and low coupling, they’re advocating for classes that are very tightly focused on a specific area and rely on as few other classes as possible to achieve that objective. When this combination is met, classes tend to be very focused and easy to maintain.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Summary</h1>
<p>In this chapter, we discussed code smells and anti-patterns. The right design principles can help keep your code focused and minimal and slow the rate at which it naturally accumulates complexity. This helps keep your code in good form and resist accumulating technical debt.</p>
<p>The most common maxim for quality programming is SOLID, following the Single Responsibility Principle (SRP), making code open for extension while being closed to modification, the Liskov Substitution Principle (LSP) advocating for low coupling with polymorphic code, the interface segregation principle focused on several smaller interfaces over one larger interface, and the Dependency Inversion Principle (DIP) which talks about reducing coupling by having classes take in the things they need from outside of the class.</p>
<p>Now that we’ve established how to write SOLID code, we’ll explore some advanced testing techniques that can help test code built using these principles.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Questions</h1>
<ol>
<li>How does the SRP affect cohesion?</li>
<li>Which areas of your code violate the SRP or DRY?</li>
<li>What are the advantages of DI? How does it affect coupling?</li>
</ol>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Further reading</h1>
<p>You can find more information about materials discussed in this chapter at these URLs:</p>
<ul>
<li><em class="italic">SOLID Principles in C# with </em><em class="italic">Examples</em>: <a href="https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/">https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/</a></li>
<li><em class="italic">15 of the Worst C# Anti-Patterns Developers Keep Using (And How to Avoid </em><em class="italic">Them)</em>:<em class="italic"> </em><a href="https://methodpoet.com/worst-anti-patterns/">https://methodpoet.com/worst-anti-patterns/</a></li>
<li><em class="italic">Top 10 Dotnet Exception Anti-Patterns in </em><em class="italic">C#</em>: <a href="https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/">https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/</a></li>
<li><em class="italic">Using objects that implement </em><em class="italic">IDisposable</em>: <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects">https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects</a></li>
<li><em class="italic">LINQ: Caveats and </em><em class="italic">pitfalls</em>: <a href="https://dev.to/samfieldscc/linq-37k3">https://dev.to/samfieldscc/linq-37k3</a></li>
</ul>
</div>
</body></html>