- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defensive Coding Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code is almost organic and evolves over its lifetime as new features are added,
    fixes are implemented, and refactorings occur at regular intervals. As code changes
    and developers enter and leave the project, there’s a chance that some of these
    changes may introduce bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 2* of this book, we discussed testing strategies for detecting these
    bugs before they reach production. In this chapter, we’ll talk about a few additional
    techniques that help developers catch and resolve bugs during development. Along
    the way, we’ll also explore a few newer features in C# and their roles in keeping
    your code stable and healthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting against null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving beyond classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced type usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter10/Ch10BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter talks to a REST API, which will require an active internet
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Cloudy Skies API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our fictitious sample organization, Cloudy Skies, has a pre-existing set of
    web services in the form of a public **REST API**. This API intends to allow interested
    organizations to pull information about Cloudy Skies flights through the API.
    However, a steady amount of support tickets has proven that organizations are
    having a hard time adopting the API and using it in approved ways.
  prefs: []
  type: TYPE_NORMAL
- en: In response, Cloudy Skies has built a .NET library to help others more easily
    use the API.
  prefs: []
  type: TYPE_NORMAL
- en: Early testing of this library is promising, but some developers are still encountering
    confusing errors that ultimately appear to be related to the data they’re passing
    the library.
  prefs: []
  type: TYPE_NORMAL
- en: The development team decided that validating parameters to public methods would
    help improve the adoption of their library by finding issues sooner. We’ll explore
    this change in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Validating inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Input validation** is the act of verifying that any inputs to your code,
    such as parameters or current property values, are correct before performing the
    requested work. We validate inputs to public methods to detect potential issues
    early on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the importance of this, let’s look at a method that doesn’t validate
    its inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `GetFlight` method takes in an `id` parameter indicating a flight number,
    such as “CSA1234,” whereas the `apiKey` parameter represents a token that must
    be supplied to interact with the API and get a response. Think of the token as
    something like a digital keycard that Cloudy Skies issues to interested organizations
    that want to interact with its APIs. Every request that goes to the Cloudy Skies
    API must include a token to authenticate and get a result.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` parameter is important because it is used to identify the flight that
    we’re interested in. This parameter gets added to the URL that the code makes
    an HTTP GET request to using the RestSharp library, which is one of many ways
    of interacting with web services in modern .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t panic!
  prefs: []
  type: TYPE_NORMAL
- en: If any of the web services code or handling of authentication tokens is beyond
    your comfort zone, don’t worry. While these are concepts you should learn as you
    grow, the actual mechanics of the web API are not important for this chapter.
    Instead, we’re focusing on parameter validation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established what this method is doing, let’s talk about how it
    could be better.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, any value for a string is valid here for both `id` and `apiKey`.
    This includes values such as null and empty or whitespace strings. While you might
    not think that a developer might try those values for those parameters, I can
    think of compelling reasons someone might try either one:'
  prefs: []
  type: TYPE_NORMAL
- en: Someone might try to pass null for the `id` parameter, thinking that it would
    get the next flight, all flights, or possibly even a random flight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A developer without an API key may think that API keys are only required for
    requests that modify data on the server or that you can interact with the API
    in low volumes without an API key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While both assumptions are incorrect for this API, I could see someone without
    knowledge of the system trying either one. In the case of Cloudy Skies, not providing
    a valid API key will result in a 401 unauthorized error coming back from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, not providing an `id` parameter results in a `NullReferenceException`
    error when the code tries to convert `id` into lowercase, as shown in *Figure
    10**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A NullReferenceException error due to id being null when ToLower
    was called](img/B21324_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A NullReferenceException error due to id being null when ToLower
    was called
  prefs: []
  type: TYPE_NORMAL
- en: Both of these errors are things that a developer trying to interact with this
    code could encounter, and neither one of these errors adequately tells the developer
    that they made a mistake in the parameters they passed in. Let’s fix this with
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of validation is to detect bad inputs early on and explicitly point
    out these issues before bad data gets deeper into our system. In building a library,
    this means that we want to validate parameters sent to our code as early as possible,
    preferably in the public methods other developers will interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a version of `GetFlight` that performs some additional validation steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check if `apiKey` or `id` are either null or empty strings. If that’s
    true, we throw an `ArgumentNullException` error to tell whoever called this method
    that they are not providing a valid value for a specific parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We also perform a check on `id` to determine whether it refers to a flight with
    a Cloudy Skies Airline prefix. If it doesn’t, this flight will never be found
    since it isn’t tracked by the system. In this case, it makes sense to alert the
    caller with an `ArgumentOutOfRangeException` error. This exception type is also
    commonly used with numbers or dates that are outside of acceptable ranges for
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: Should we really throw exceptions here?
  prefs: []
  type: TYPE_NORMAL
- en: Many new developers think that exceptions are bad. Most developers hate encountering
    exceptions, and throwing exceptions can indeed be relatively slow. Keeping these
    things in mind, when you get invalid values, sometimes, the best option is to
    throw a specific exception that highlights the issue. This helps catch mistakes
    quickly and prevents errors that can occur from letting invalid values deeper
    into a system.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the revised code has a lot of validation relative
    to the other logic in the method. There are a few ways of improving this, as we’ll
    see in the upcoming sections, but let’s work toward that goal incrementally. We’ll
    start by looking at a better way of referring to bad parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Using the nameof keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, the code validates parameters and throws exceptions with code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `"apiKey"` refers to the name of the parameter, which helps
    developers identify which parameter the exception is complaining about.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what happens if someone renames that parameter later to `apiToken`? This
    change wouldn’t cause any compiler errors and the exception could still be thrown.
    Unfortunately, the exception would reference the old `apiKey` parameter name that
    was no longer present, which would confuse the developer encountering the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, C# gives us the `nameof` keyword, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When your code is compiled, the `nameof` keyword evaluates the name of the parameter,
    method, or class it is used on. A string with the result of that `nameof` evaluation
    is then included in the compiled code. In other words, it’s identical to the code
    we had before – except that if the parameter is ever renamed, our code no longer
    compiles until the `nameof` keyword is updated to refer to the renamed parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to rely on the compiler to help ensure our parameter validation
    uses the correct parameter names, even if those parameters are renamed in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s introduce a more concise way of throwing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Validation with guard clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, our validation logic consists of an `if` statement followed by a
    conditional `throw` statement. This validation is so common and can take up many
    lines of code when validation is complex that .NET now gives us a more concise
    way of interacting with it in the form of **guard clauses**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take our validation down to a single line of code by calling `ArgumentException.ThrowIfNullOrEmpty`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method will check the value of the parameter it is passed in and will throw
    either an `ArgumentNullException` error if the value is null or an `ArgumentException`
    error if the value is an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t a lot of these validations built into .NET right now, but if you
    like the idea and want validations for things such as negative values or numeric
    or date ranges, you’ll love Steve Smith’s excellent **GuardClauses library**.
  prefs: []
  type: TYPE_NORMAL
- en: Guard clauses with the GuardClauses library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help augment the built-in guard clauses, Steve Smith created the **Ardalis.GuardClauses**
    library.
  prefs: []
  type: TYPE_NORMAL
- en: To use the GuardClauses library, install the latest version of Ardallis.GuardClauses
    via NuGet Package Manager, as we’ve done in prior chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add `using Ardalis.GuardClauses;` to the top of your `.``cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that’s been installed and referenced, you’ll be able to use guard syntax,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the GuardClauses library provides various static methods inside `Guard.Against`
    syntax that allow you to validate a great many things.
  prefs: []
  type: TYPE_NORMAL
- en: If a validation condition is met – for example, if `maxMiles` is `4` when `NegativeOrZero`
    is called – the program continues as normal. However, if the condition is not
    met, an `ArgumentException` error will be thrown containing the name of the parameter
    that violated the condition.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve found this library to be intuitive to write and read, and it also leads
    to efficient and effective guard clauses that require a minimal amount of effort.
  prefs: []
  type: TYPE_NORMAL
- en: The full extent of the GuardClauses library is well beyond the scope of this
    book, but you can install it and see the methods available or check out the documentation
    referenced in the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: But wait – there’s more!
  prefs: []
  type: TYPE_NORMAL
- en: This book’s wonderful technical reviewers rightly pointed out the popular **FluentValidation
    library**, which offers a rich set of validation rules that can be applied to
    your classes. You can learn more about this library in the *Further* *reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, I want to point out one aspect of the `Ardalis.GuardClauses`
    library that you might not have noticed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you call a guard clause with `Guard.Against.Null(apiKey);`.
  prefs: []
  type: TYPE_NORMAL
- en: If this validation rule fails it will throw an `ArgumentException` error. This
    exception will have a `ParamName` property with a value of `apiKey`. Additionally,
    the resulting message will mention the `apiKey` parameter by name, *even though
    you didn’t provide the name when you called the* *guard clause*.
  prefs: []
  type: TYPE_NORMAL
- en: This works due to the library’s use of the `CallerArgumentExpression` attribute,
    which we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Using CallerMemberInformation attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nameof` keyword proved so successful in eliminating strings referring to
    things that were later renamed that C# grew to accompany four separate attributes
    that can tell you things about any given method.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these attributes is applied to a method parameter. Like the `nameof`
    keyword, these attributes are evaluated at compile time and result in a `string`
    or `int` type being used in the final compiled code in their place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four available caller member attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CallerFilePath** contains a string with the name and path of the file of
    the code calling to the method on the machine compiling the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` type with the line number for the method call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CallerMemberName** contains the name of the method or property where the
    method call occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CallerArgumentExpression** converts the expression passed into the method
    into a string, before evaluating the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at `LogApiCall` for an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method takes in five parameters, where the first is a standard string parameter
    and the other four use the various caller member information attributes. Notice
    how these attributes all have a default value specified. When values are not specified
    for these parameters, the compiler will replace each parameter with values it
    detected during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice how when `LogApiCall` is invoked, only the string parameter is specified.
    The remaining parameters are provided values during compilation due to the attributes
    on each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the expression that was used to get that string is `request.Resource`.
    This expression is what `CallerArgumentExpression` uses to generate its string
    because the `CallerArgumentExpression` attribute requires the name of another
    parameter. In this case, we specified `[CallerArgumentExpression(nameof(url))]`
    to have it look at the expression that was passed into the `url` parameter – the
    first parameter the method takes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this code runs, we will see the following message logged in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it logged the full path to the file on my hard drive, as well
    as the line number of the `LogApiCall` method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression of `request.Resource` is the exact string of code that’s used
    to call that method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Caller member information attributes are very handy for certain types of things,
    such as logging and validation, or certain specialized scenarios such as raising
    `INotifyProperty` changed in **Windows Presentation Foundation** (**WPF**) applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve sufficiently explored working with parameters for our methods,
    let’s look at how modern C# lets us work safely with null values.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: British computer scientist, Tony Hoare, is generally credited as the inventor
    of the null reference in programming. In 2008, he famously apologized for it,
    calling it his “billion-dollar mistake.” This was due to the countless bugs and
    crashes that have occurred in various programming languages when code attempted
    to interact with variables currently holding null values. While I can’t fault
    Tony Hoare, nulls can certainly be dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, this comes in the form of a `NullReferenceException` error, as we saw
    earlier in this chapter. You get a `NullReferenceException` error any time you
    attempt to invoke a method or evaluate a property on a variable that currently
    holds a null value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C# 8, developers needed to be explicitly aware that any reference type
    could hold a null value and write conditional logic, such as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This pattern of checking for nullability and then conditionally acting became
    prevalent in C# because when it didn’t, developers encountered `NullReferenceException`
    errors. Unfortunately, this led to null checks occurring throughout the code,
    including in many places where nulls would never be encountered.
  prefs: []
  type: TYPE_NORMAL
- en: In C# 8, nullable reference types were introduced, which helped developers understand
    when and where they were likely to encounter null values so that they would have
    active reminders to guard against null values in those places. Additionally, these
    improvements made it easier to remove unnecessary null checks in places where
    nulls were not expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C# 8 and beyond, when nullability analysis is enabled, you can indicate
    that any reference type may be null by adding `?` after the type indicator, as
    shown here for `FlightInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, this indicates that the `GetFlight` method will return either
    a `FlightInfo` instance or a null value. Additionally, this indicates that the
    `id` and `apiKey` parameters will always have a string that is not null. If these
    accepted null values, they would be declared as `string? Id, string?` `apiKey`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Nullability analysis in C# does not prevent you from passing null to things
    that say they do not accept null values, nor does it prevent you from returning
    null values from methods that claim to return a non-null return type. Instead,
    nullability analysis flags these cases as warnings, which will help you address
    these issues. We’ll talk more about code analysis warnings in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to say that `GetFlight` could never return null, we would remove
    `?` from the `FlightInfo` return type and validate that the result from the API
    was not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The request to the API via `_client.Get` still might return a nullable value,
    so the code must now check for null and conditionally throw an exception if a
    null value is encountered. However, this guarantees that the code returns only
    a non-null value, which is what the return type of `FlightInfo` indicates with
    nullability analysis active.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to enable and disable nullability analysis in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling nullability analysis in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since .NET 6, nullable reference types are enabled by default in new projects
    going forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can enable nullable reference types in any project using C# 8
    or above by adding a `<Nullable>enable</Nullable>` node to your project’s `.``csproj`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can edit this file either in a text editor such as Notepad, or you can double-click
    on the project node in **Solution Explorer** to edit the file inside Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want nullability analysis enabled for your entire project, you
    can enable and disable nullability analysis with preprocessor statements such
    as `#nullable enable` and `#nullable disable`. For example, the following code
    temporarily disables nullability analysis for a class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I’d encourage you to use project-level nullability analysis and avoid using
    `#nullable` when possible. I’ve known many developers who get nauseated every
    time they see a preprocessor statement. My opinion is that `#nullable` should
    be reserved for when you are moving a larger project to use nullability analysis
    but are not yet ready to enable it for the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: Using nullability operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we talked about how `?` indicates that a type may contain a null value,
    but there are several other operators related to nullability you should be aware
    of in C#.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the non-null assertion operator of `!` tells C# that something
    is not going to be null and to ignore nullability warnings on that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common place I use this is when working with `Console.ReadLine()`. This
    method indicates it may return a null value, but in practice, it never does in
    normal operation. This can be suppressed using `!`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are taking `ReadLine`, which is defined as having a `string?` result
    and storing it in `string`. The `!` operator says that the `string?` result should
    be treated as if it was `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other nullability operators include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `?`), which conditionally calls methods only if the object they’re being
    invoked on is not null. For example, `_conn?.Dispose()` calls the `Dispose` method
    only if `_conn` is not null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `??`), which uses a backup value in case something is null. For example,
    `int miles = flight?.Miles ?? 0;` uses null-conditional and null coalescing operators
    to safely get `Miles` out of a flight or use `0` when no flight is present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `??=`) assigns a value to a variable only if the variable is null already.
    For example, `message ??= "An unexpected error has occurred";` will only set the
    new error message in `message` if `message` is null. This allows us to effectively
    replace null values with backup values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of nullability analysis and nullability operators helps us make
    intelligent decisions around null values in concise ways. This keeps our code
    efficient and focused while guiding us toward having a cohesive strategy around
    handling null values in code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a broader look at changes we can make at the class level to help
    design more robust applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C# 9 and beyond, Microsoft has made concerted efforts to give developers
    new options for working with classes through things such as record types, init-only
    properties, primary constructors, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore how these newer C# constructs can improve the
    design of your classes.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring immutable classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, immutable classes have become more and more popular. This immutability
    refers to the inability to change an object after it has been created.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that once an object exists, you cannot modify its state and
    instead are limited to creating new objects that are like the original. If you’re
    familiar with working with string and DateTime objects in .NET, you’ve seen this
    concept with methods such as `ToLower` on string and `AddDays` on DateTime returning
    a new object instead of modifying the original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a small class representing a boarding pass that is currently
    mutable (changeable) and then convert it into an immutable class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a “plain old C# object” with properties with getters and setters. Thinking
    about the class logically, there are several problems:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing preventing `Flight`, `Passenger`, or `Seat` from having a null
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a pass is created, properties such as `passenger`, `boarding group`, `seat`,
    and even `flight` can be changed. This doesn’t make sense in the context of an
    airline business where a new boarding pass would need to be issued to change these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can change this object so that it’s immutable and requires valid values
    for these parameters by removing their setters and adding a constructor with validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This constructor now requires that valid values are present for all properties
    on the object in object creation. Meanwhile, the removal of setters for the properties
    ensures that the class stays valid and cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: If we needed to, we could add new methods to the `BoardingPass` class that create
    and return a new `BoardingPass` object with similar characteristics to the original
    in a similar manner to how various string and DateTime methods work. However,
    `with expressions` give us a more interesting way of doing this, as we’ll see
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using immutability may seem more inconvenient than beneficial at first,
    there are a few key advantages of using immutable classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable classes can be validated during creation and ensured that they are
    in a valid state. Once created, this valid state cannot change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When objects can be modified anywhere in your code, this makes it harder to
    track down what changed an object when multiple other classes may have a reference
    to it. Immutable objects prevent this from occurring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some concepts just make more sense as immutable objects, such as a prior version
    of a document or a boarding pass for a passenger at an airport.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since immutable objects don’t change, they can be reliably worked with in multi-threaded
    applications. Without immutability, you’d need to rely on using `Interlocked`,
    the `lock` keyword, or thread-safe collections to avoid bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, having to specify all the properties of an object in its constructor
    can be cumbersome for classes with many properties. Additionally, not every class
    in your project needs to be immutable. For those classes that would benefit from
    immutability, C#’s required keyword and init-only properties help alleviate this
    burden.
  prefs: []
  type: TYPE_NORMAL
- en: Using required and init-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The downside of adding every property as a parameter to class constructors is
    that your constructors can start to become larger than you’d like. Additionally,
    creating objects that require many constructor parameters is tedious and error-prone
    and the creation of individual objects can be tedious and confusing, particularly
    when many constructor parameters are needed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, object initializers can be more readable, but until recently,
    they lacked a way of ensuring properties are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the two ways of creating a `BoardingPass` object and see which appears
    more readable to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The object initializer version used in `p2` is more readable and maintainable,
    particularly as the number of properties you might want to set in the class grows
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional downside of this approach was that a developer using the object
    initializer might forget to set important required properties. C# 11 introduced
    the `required` keyword, which will fail to compile if a required property is not
    explicitly initialized during object initialization or in the constructor when
    the `Passenger` property is omitted, as shown in *Figure 10**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A compiler error due to Passenger not being set](img/B21324_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A compiler error due to Passenger not being set
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we can add `required` to any property definitions on the class
    that we want to make sure they are explicitly set by the time the object-initializer
    completes. The following version of `BoardingPass` features required properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may have also noticed that this class definition defines these properties
    as `{get; init;}` instead of `{get;}` or `{get; set;}`. While the traditional
    `get; set;` combination allows a property to be changed at any time, this violates
    immutability. The `get;` version removes the ability to set the property anywhere
    but the constructor, which means properties defined as `get;` cannot be set in
    object initializers.
  prefs: []
  type: TYPE_NORMAL
- en: The newer `get; init;` combination that was added in C# 9 allows the property
    to be set in the constructor or initializer, but no longer allows setting after
    the object is initialized. This helps us support our immutable class design while
    not restricting the user to using constructors.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that object initializers are the future of .NET and nowadays tend
    to favor required properties with `get; init;` when designing classes for immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of the future, let’s look at a brand-new feature in C# 12: primary
    constructors for reference types.'
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Primary constructors** are constructors that must be called to initialize
    the class and provide a way of automatically creating fields in your class. We’ll
    talk more about what that “must be called” phrase entails in a moment, but let’s
    start by looking at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This version of `BoardingPass` has parentheses and a parameter list immediately
    following the class declaration. This is the primary constructor for the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any parameters declared in the primary constructor are available as if they
    were init-only properties. This makes a primary constructor roughly equivalent
    to the following C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of primary constructors is that they are very concise and do not
    require you to define a constructor or field definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primary constructors can work with other constructors, though any other constructor
    you declare must call the primary constructor using the `this` keyword, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, your primary constructor must always be called – either on its
    own or from another constructor via the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors are not unique to classes and exist for records starting
    in C# 9.
  prefs: []
  type: TYPE_NORMAL
- en: Converting classes into record classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, I’ve alluded to **record classes** several times without
    defining them or going into detail on why you’d want to use one.
  prefs: []
  type: TYPE_NORMAL
- en: To understand record classes, let’s talk briefly about equality in classes.
    By default, two objects are considered equal if they both live in the same memory
    address in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, by default, two separate objects with identical properties
    are not equal. For example, the following code would evaluate these two boarding
    passes as different from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can change this behavior by overriding `Equals` and `GetHashCode` on the
    `BoardingPass` class, as we did in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101).
    However, record types give us an easier way of managing this.
  prefs: []
  type: TYPE_NORMAL
- en: Record classes are like normal C# classes except equality works by comparing
    all properties to each other. In other words, record classes are like normal C#
    classes that have overridden `Equals` and `GetHashCode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s redeclare our boarding pass as a record class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can successfully compare two boarding passes using just their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These two classes are considered equal because they carry the same values. Note
    that the `Flight` property refers to a `FlightInfo` object, which is still a standard
    C# class and uses traditional reference equality. This means that boarding passes
    must point to the same `FlightInfo` object in memory; otherwise, they will not
    be considered equal. This can be changed by making `FlightInfo` a record class
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using record classes for small objects that you might want to compare
    to each other. They also might be helpful for classes that might be frequently
    instantiated, such as objects coming from the database or an external API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to talk about my favorite new way of creating objects: `with`
    expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning objects using with expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`with` expressions work very well with immutable records by allowing you to
    clone and slightly tweak the source record without making any modifications to
    the original record.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that Hamlet’s boarding pass for seat 2B on the flight needed to be
    changed. The system could instantiate a new boarding pass that was just like the
    original one except for seat 2C using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new boarding pass based on the original one but with one property
    slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to move Hamlet to have a new seat but an earlier boarding group,
    we could do that as well by listing an additional property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: I find `with` expressions to be one of the most exciting things about working
    with record classes in C# and I love the direction the language is going in to
    streamline the creation of objects.
  prefs: []
  type: TYPE_NORMAL
- en: This style of referring to property values is not unique to the `with` expression,
    as we’ll see in the next section with pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced type usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section of this chapter, we’ll see how new and old language features
    help you build better types.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that we can use the same style of syntax we used with expressions
    earlier to conditionally match different objects through **pattern matching**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain what I mean, let’s start with an example that loops over different
    boarding passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code loops over a collection of boarding passes and does one of three
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: If the flight is `Pending` and the passenger is in group 1, 2, or 3, we tell
    them to board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the flight is `Active` or `Completed`, we tell the passenger they missed
    their flight
  prefs: []
  type: TYPE_NORMAL
- en: If neither of these cases is true, the flight must be `Pending`, but the passenger’s
    group is not boarding, so we tell them to wait
  prefs: []
  type: TYPE_NORMAL
- en: The code is a little arbitrary, particularly in how it deals with the boarding
    group, but it illustrates some of the capabilities of pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Using pattern matching, you can evaluate one or more properties on an object
    in an `if` statement to concisely check multiple things at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can use pattern matching in `if` statements, they are also commonly
    used in switch expressions, as we saw in [*Chapter 3*](B21324_03.xhtml#_idTextAnchor045).
    We could rewrite our code from earlier into a switch expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the switch expressions concept combined with the power of pattern
    matching to set a string in the `message` variable. Note that the code uses `not
    FlightStatus.Pending` instead of `FlightStatus.Active or FlightStatus.Completed`
    for brevity and to illustrate the usage of the `not` keyword in negating or inverting
    pattern matching expressions.
  prefs: []
  type: TYPE_NORMAL
- en: While this code takes some adjustment to learn to read, there’s also very little
    “waste” in this syntax. Almost the entirety of every line of code is centered
    around either the conditions that must be true or the value to use when they are
    true. Additionally, this syntax can handle more complex scenarios such as or and
    not statements more easily than normal C# logic can.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as with any new C# language feature, if the readability cost is too
    high for you and your team, you are free to avoid switch expressions and pattern
    matching entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how pattern matching and switch expressions work together
    in the latest versions of C#, let’s look at one of C#’s earliest enhancements:
    generics.'
  prefs: []
  type: TYPE_NORMAL
- en: Using generics to reduce duplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Generics** are a concept that every .NET developer encounters and works with
    daily.'
  prefs: []
  type: TYPE_NORMAL
- en: When you work with `List<string>` (pronounced “list of strings”), you are working
    with a generic `List` object that can hold something of a specific type – in this
    case, strings.
  prefs: []
  type: TYPE_NORMAL
- en: Generics work by specifying at least one type parameter that goes into either
    a class or a method and allows the class or method to be structured around that
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the advantage of generics, let’s look at a very simple `FlightDictionary`
    class that stores `FlightInfo` objects by their identifiers using a dictionary
    and incorporates some light console logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This class is the beginning of a new collection class, like the `Dictionary`
    class provided by .NET. It allows external callers to add, retrieve, and check
    for `FlightInfo` by a string identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this code is very simple and missing several features I’d expect from
    a real collection class, it should serve to illustrate the need for generics by
    asking the following question: What happens if we like this class so much for
    `FlightInfo` objects that we want to use something like it for `BoardingPass`
    objects?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, this would result in someone copying and pasting the `FlightDictionary`
    class to create a new `BoardingPassDictionary`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between these two classes is the type of item being stored.
  prefs: []
  type: TYPE_NORMAL
- en: What generics let us do is declare a class that takes in parameters of the types
    it should use for different operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a more reusable version of this class that accepts generic
    type parameters for the type used as a key for each item, as well as the type
    used as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation of the class depends on two generic type arguments: `TKey`
    and `TValue`. These parameters can be whatever names you want them to be, but
    the convention is to use `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this class, a new `LoggingDictionary` can be created for any types you
    might want to support using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Generics are something that has been around since .NET Framework 2.0 but still
    offers value today in adding reusability to classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s close this chapter out with a brief look into a new C# 12 feature: **type
    aliases**.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing type aliases with the using directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you’re developing a system and you need to work with a set of data
    types you’re not certain about and may need to change in the future. Alternatively,
    you might have a routine need for some hideous-looking types, such as needing
    to deal with `List<string, Dictionary<Passenger, List<FlightInfo>>>` throughout
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: While one approach for the latter problem might be to introduce your class to
    hide away some of this complexity, a new option in C# 12 is to use `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at simplifying some of the code in `CloudySkiesFlightProvider.cs`
    to reduce the places where `IEnumerable<FlightInfo>` appears. We’ll use the `GetFlightsByMiles`
    method as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code isn’t bad, but imagine that you felt very strongly that you didn’t
    like looking at `IEnumerable<FlightInfo>` everywhere and you’d rather have a custom
    type defined for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using C# 12, you could add the following line to the `using` statements in
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With this one change, you can now change your method to use your new type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code doesn’t change that you’re dealing with `IEnumerable<FlightInfo>`
    in this method, but it does reduce the amount of code you have to type and simplifies
    the code for reading.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you ever wanted to change to a different type in these places,
    you now just need to modify the `using` statement to use a different type instead.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not sure if obscuring the underlying type offers more benefit than potential
    confusion, but I could see some places where it might be helpful, particularly
    in dealing with complex generic types or working with tuples (collections of multiple
    values).
  prefs: []
  type: TYPE_NORMAL
- en: Time will tell on the effectiveness of type aliases and the best places to use
    them, but I’m glad we now have the option.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a variety of ways of ensuring your classes are
    safe and reusable through means such as argument validation, caller member information,
    nullability analysis, and using modern C# features such as record classes, primary
    constructors, pattern matching, and enhanced properties with the `required` and
    `init` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: These language features help you detect issues earlier in development, work
    with objects more effectively, and write fewer lines of code overall.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes *Part 2* of this book. In *Part 3*, we’ll look at how AI and
    code analysis tools can help you and your team sustainably build better software.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answers the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can throwing exceptions be beneficial to your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the various ways you can declare a property in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the various ways you can instantiate an object in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between classes and record classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about features discussed in this chapter at these
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Guard Clauses* *library*: [https://github.com/ardalis/GuardClauses](https://github.com/ardalis/GuardClauses)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fluent Validation* *library*: [https://github.com/FluentValidation/FluentValidation](https://github.com/FluentValidation/FluentValidation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Caller Member* *Information*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Primary constructors and using* *aliases*: [https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/](https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Safer Nullability in Modern* *C#*: [https://newdevsguide.com/2023/02/25/csharp-nullability/](https://newdevsguide.com/2023/02/25/csharp-nullability/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Classes, structs, and records in* *C#*: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Choosing Between Exceptions or* *Validation:* [https://ardalis.com/guard-clauses-and-exceptions-or-validation/](https://ardalis.com/guard-clauses-and-exceptions-or-validation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Refactoring with AI and Code Analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third part of this book focuses on advanced refactoring techniques using
    artificial intelligence and modern code analysis capabilities built into Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces GitHub Copilot Chat as a way to refactor, generate,
    inspect, document, and test code.
  prefs: []
  type: TYPE_NORMAL
- en: We then extensively cover the code analysis capabilities of Visual Studio by
    introducing the code analysis tooling and rulesets as well as some third-party
    tools that can help catch additional issues. Finally, we explore how Visual Studio’s
    code analysis is based on Roslyn Analyzers by building and deploying our own Roslyn
    Analyzer as both a Visual Studio extension and as a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you a deep understanding of code analysis issues as well
    as new productivity tools to help detect and resolve issues in their code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21324_11.xhtml#_idTextAnchor236)*, AI-Assisted Refactoring
    with GitHub Copilot*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21324_12.xhtml#_idTextAnchor259)*, Code Analysis in Visual
    Studio*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21324_13.xhtml#_idTextAnchor275)*, Creating a Roslyn Analyzer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21324_14.xhtml#_idTextAnchor297)*, Refactoring Code with Roslyn
    Analyzers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
