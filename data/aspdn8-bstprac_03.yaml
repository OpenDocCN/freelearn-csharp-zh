- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Best Approaches for Middleware
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件的最佳方法
- en: Middleware is one of the most powerful concepts in ASP.NET Core. For legacy
    ASP.NET developers, *Middleware* is a relatively new term. Before middleware,
    there were HTTP handlers and modules, which required separate code to configure
    through a `web.config`. Middleware is now considered a first-class citizen in
    an ASP.NET application, making it easier to maintain in a single code base. First
    introduced in ASP.NET Core 1.0, the common request and response concepts are considered
    pipelines for your applications with the ability to control a request and response’s
    body. This opens up a number of possibilities to create amazing features for your
    ASP.NET Core web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是ASP.NET Core中最强大的概念之一。对于传统的ASP.NET开发者来说，*中间件*是一个相对较新的术语。在中间件之前，有HTTP处理程序和模块，它们需要通过`web.config`进行单独的代码配置。现在，中间件被认为是ASP.NET应用程序中的一等公民，使得在单个代码库中维护它变得更加容易。中间件首次在ASP.NET
    Core 1.0中引入，常见的请求和响应概念被认为是应用程序的管道，具有控制请求和响应体的能力。这为创建ASP.NET Core Web应用程序的惊人功能打开了众多可能性。
- en: At the beginning of this chapter, we’ll examine how to use Middleware and some
    common built-in Middleware components found in almost every ASP.NET Core application.
    Next, we’ll examine the three request delegates (`Run`, `Map`, and `Use`) and
    explain what each is used for in the pipeline. We’ll also cover some ways to clean
    up your middleware and, finally, apply those concepts to building a simple middleware
    example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们将探讨如何使用中间件以及几乎每个ASP.NET Core应用程序中都存在的常见内置中间件组件。接下来，我们将检查三个请求委托（`Run`、`Map`和`Use`）并解释在管道中每个委托的用途。我们还将介绍一些清理中间件的方法，最后将这些概念应用于构建一个简单的中间件示例。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using Middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件
- en: Common Practices for Middleware
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件的常见实践
- en: Creating an Emoji Middleware Component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个表情符号中间件组件
- en: By the end of this chapter, you’ll have learned how Middleware works, how to
    use request delegates and standards when writing your own Middleware, and understand
    how to create your own Middleware components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学习中间件的工作原理，如何编写自己的中间件时使用请求委托和标准，以及如何创建自己的中间件组件。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Since this is the first chapter (one of many to come since we’re in coding
    territory now) containing technical requirements, selecting your favorite editor
    that supports ASP.NET Core 7.0 or higher and C# code would be ideal. My top three
    editors are the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一章（我们现在是编码领域，所以将有许多章节），包含技术要求，选择支持ASP.NET Core 7.0或更高版本和C#代码的您最喜欢的编辑器将是理想的。我的前三款编辑器如下：
- en: Visual Studio (preferably 2022 or newer)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio（最好是2022或更新的版本）
- en: Visual Studio Code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: JetBrains Rider
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work for this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的编辑器是Visual Studio 2022 Enterprise，但任何版本（社区版或专业版）都适用于本章。
- en: 'The code for this chapter is located at Packt Publishing’s GitHub repository
    located here: [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于Packt Publishing的GitHub仓库中，链接如下：[https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)。
- en: Using Middleware
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件
- en: Middleware is software you configure at the beginning of your application when
    the application starts. It’s important to note that the Middleware you add should
    be based on your application’s requirements. It’s not necessary to add every single
    component. Streamlining your Middleware pipeline is important, which we’ll discuss
    shortly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是在应用程序启动时配置的软件。需要注意的是，您添加的中间件应基于您的应用程序需求。没有必要添加每个单独的组件。简化中间件管道非常重要，我们将在稍后讨论这一点。
- en: It’s been said that the difference between a library and a framework is that
    a library is the code you call from your application, whereas a framework is structured
    a certain way to call your code. This is what Middleware has evolved into from
    earlier versions of ASP.NET.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 据说，库和框架之间的区别在于，库是从您的应用程序中调用的代码，而框架是以某种方式结构化的，以便调用您的代码。这就是中间件从ASP.NET早期版本演变而来的。
- en: In this section, we’ll present the common flow of a Middleware pipeline and
    how to control what happens in a middleware component. By the end of this section,
    you’ll understand how a middleware pipeline works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍中间件管道的常见流程以及如何控制中间件组件中的操作。在本节结束时，你将了解中间件管道是如何工作的。
- en: Understanding the Middleware Pipeline
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解中间件管道
- en: When your web application starts, Middleware is called and constructed once
    per *application lifetime*. Once the Middleware components are registered, they
    execute in a certain order. This order is important throughout the pipeline since
    each middleware component can rely on previously registered components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的Web应用程序启动时，中间件会在每个**应用程序生命周期**中调用和构建一次。一旦中间件组件被注册，它们将按照一定的顺序执行。在整个管道中，这个顺序很重要，因为每个中间件组件都可以依赖于之前注册的组件。
- en: For example, the Authentication component is important to configure before the
    Authorization component since we need to know who someone is before we can determine
    what they can do.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在配置授权组件之前，认证组件非常重要，因为在我们确定某人能做什么之前，我们需要知道他们是谁。
- en: 'In *Figure 3**.1*, we can see what a standard Middleware pipeline consists
    of in a web application, which we’ll address next:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图3.1**中，我们可以看到标准中间件管道在Web应用程序中的组成，我们将在下一节中讨论：
- en: '![Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application](img/Figure_3.01_B19493.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – ASP.NET 8 Web应用程序的标准中间件管道](img/Figure_3.01_B19493.jpg)'
- en: Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – ASP.NET 8 Web应用程序的标准中间件管道
- en: Each one of these components is optional, but some Middleware components are
    dependent on others. When a URL is requested by the user, the first Middleware
    component is hit. In this case, it’s `ExceptionHandler`. Once `ExceptionHandler`
    is done, the pipeline moves on to the next component, which is the HSTS component.
    As we move through each Middleware component, we eventually reach the endpoint.
    Once the endpoint is processed, the response is sent back through the Middleware
    pipeline in reverse order.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件都是可选的，但某些中间件组件依赖于其他组件。当用户请求一个URL时，第一个中间件组件会被调用。在这种情况下，它是`ExceptionHandler`。一旦`ExceptionHandler`完成，管道将移动到下一个组件，即HSTS组件。随着我们通过每个中间件组件前进，我们最终会到达端点。一旦端点被处理，响应将通过中间件管道以相反的顺序发送回来。
- en: As mentioned at the start of this section, your Middleware depends on what your
    application requires when adding additional components. If your application is
    a **Single-Page Application** (**SPA**), the inclusion of the CORS, Static Files,
    and Routing Middleware would be important.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，你的中间件取决于在添加额外组件时你的应用程序需要什么。如果你的应用程序是一个**单页应用程序**（SPA），包含 CORS、静态文件和路由中间件将非常重要。
- en: Each middleware component is responsible for either passing information on to
    the next component in line based on your configuration or terminating the process.
    If they decide to terminate the pipeline, they are called *terminal Middleware*
    components. They purposefully stop the middleware from processing any other requests
    and exit the pipeline.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间件组件负责根据你的配置将信息传递给下一个组件，或者终止进程。如果他们决定终止管道，它们被称为**终端中间件**组件。它们故意停止中间件处理任何其他请求并退出管道。
- en: Using Request Delegates – Run, Use, and Map
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用请求代理 - 运行、使用和映射
- en: With everything we’ve discussed so far, you’re probably wondering how we create
    a pipeline.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了这么多，你可能想知道我们是如何创建管道的。
- en: The three request delegates available are the `Run`, `Use`, and `Map` extension
    methods. You’ve no doubt used them in your `Program.cs` code numerous times, but
    what’s the difference between the three of them?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的三个请求代理是`Run`、`Use`和`Map`扩展方法。你无疑在`Program.cs`代码中多次使用过它们，但三者之间有什么区别呢？
- en: Run
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行
- en: The `Run()` request delegate is strictly terminal middleware, meaning it will
    run and immediately quit the pipeline. It doesn’t contain a `next` parameter.
    It simply runs and immediately terminates the pipeline.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run()`请求代理是严格终端中间件，这意味着它将运行并立即退出管道。它不包含`next`参数。它只是运行并立即终止管道。'
- en: 'If we look at the following code, this will immediately terminate the pipeline
    from executing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看以下代码，这将立即终止管道的执行：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice there isn’t a `next` parameter introduced in the delegate. The preceding
    code will write the message `"This will terminate the web app."` to the browser
    and immediately terminate the pipeline.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在委托中没有引入`next`参数。前面的代码将消息`"This will terminate the web app."`写入浏览器，并立即终止管道。
- en: Use
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用
- en: The `Use()` request delegate is used to chain multiple request delegates together
    in the pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Use()`请求委托用于在管道中链接多个请求委托。'
- en: The key to implementing a proper `Use` request delegate is the use of `await
    next.Invoke()`. `next.Invoke()` will execute the next middleware component in
    sequential order. Anything before this line will be processed on the request,
    and anything after this line will be processed on the response back to the user.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现适当的`Use`请求委托的关键是使用`await next.Invoke()`。`next.Invoke()`将按顺序执行下一个中间件组件。在此行之前的内容将在请求上处理，在此行之后的内容将在响应用户时处理。
- en: 'Let’s look at a code sample of two anonymous Middleware components in the following
    code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段中两个匿名中间件组件的代码示例：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code creates the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下输出：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll notice anything before the `next.invoke()` line of code is executed and
    then the execution moves on to the next Middleware in the order. Once we get to
    the end of the Middleware pipeline, we make the return trip back, which executes
    all of the code *after* each Middleware’s `await` `next();` statement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在执行`next.invoke()`代码行之前的内容，然后执行顺序移动到下一个中间件。一旦我们到达中间件管道的末尾，我们就返回，这会执行每个中间件`await
    next();`语句之后的全部代码。
- en: After each Middleware component is executed, the application runs and then returns
    in reverse order.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个中间件组件执行之后，应用程序运行并按相反顺序返回。
- en: Map
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: The `Map()` request delegate is meant for branching the pipeline based on a
    certain request path or route. While this is for specific Middleware conditions,
    creating a new map is highly unlikely. It’s usually best to use pre-built Middleware
    components such as `.MapRazorPages()`, `.MapControllers()`, or any of the other
    `.MapXxxx()` methods. These methods already have pre-defined routes in place.
    Most routing occurs inside other extensions like the previously mentioned Middleware
    methods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map()`请求委托旨在根据特定的请求路径或路由分支管道。虽然这是针对特定的中间件条件，但创建一个新的映射几乎是不可能的。通常最好使用预构建的中间件组件，例如`.MapRazorPages()`、`.MapControllers()`或任何其他`.MapXxxx()`方法。这些方法已经设置了预定义的路由。大多数路由发生在其他扩展中，如之前提到的中间件方法。'
- en: 'There is also a `MapWhen()` extension method for conditional middleware branching
    based on the result of a given predicate. For example, if you want to create a
    controlled maintenance page for your site, you could use a simple Boolean called
    `underMaintenance` and use it to display a simple message until your site is available
    again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`MapWhen()`扩展方法，用于根据给定谓词的结果进行条件中间件分支。例如，如果你想为你的网站创建一个受控的维护页面，你可以使用一个简单的布尔值`underMaintenance`，并使用它来显示一条简单的消息，直到你的网站再次可用：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we add our `.MapWhen()` delegate to use a specific Boolean
    to identify whether we are under maintenance or not. Notice we’re using the `.Run`
    delegate because we don’t want to continue any further down the Middleware pipeline.
    This approach is just one example of Middleware’s flexibility.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了`.MapWhen()`委托来使用特定的布尔值来识别我们是否处于维护状态。注意我们使用`.Run`委托，因为我们不想继续中间件管道的任何进一步操作。这种方法只是中间件灵活性的一个示例。
- en: Using Built-in Middleware Components
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置中间件组件
- en: While you can create your own Middleware components, the best approach is to
    see whether a Middleware component exists from the large number of built-in components
    already available to you. The entire list is located at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware).
    This chart provides a description of each Middleware component and the location
    of where to place it in the Middleware pipeline. In addition to the built-in components,
    use NuGet to find innovative Middleware components as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以创建自己的中间件组件，但最好的方法是查看是否已经存在大量内置组件中的一个中间件组件。整个列表位于[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware)。此图表提供了每个中间件组件的描述以及在中间件管道中放置的位置。除了内置组件之外，还可以使用NuGet查找创新的中间件组件。
- en: In this section, we covered the middleware pipeline, learned how to use the
    request delegates and what each request delegate can do, and learned about all
    of the built-in middleware components available for ASP.NET web applications.
    In the next section, we’ll examine the common practices for using Middleware.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了中间件管道，学习了如何使用请求代理以及每个请求代理可以做什么，还了解了所有可用于ASP.NET Web应用程序的内置中间件组件。在下一节中，我们将检查使用中间件的常见做法。
- en: Common Practices for Middleware
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件的常见做法
- en: In this section, we’ll review a number of common practices when writing your
    own middleware to keep everything running optimally in your web application. Let’s
    get started!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾在编写自己的中间件时的一些常见做法，以确保你的Web应用程序中一切运行得尽可能优化。让我们开始吧！
- en: Defer to Asynchronous
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟异步操作
- en: When working with Middleware, we want to get the best performance possible so
    our users can begin working in the application. As more users continue to use
    the application, performance may suffer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当与中间件一起工作时，我们希望获得尽可能好的性能，以便我们的用户可以开始使用应用程序。随着更多用户继续使用应用程序，性能可能会受到影响。
- en: A synchronous operation is where code is executed and the application has to
    wait for it to finish, meaning it’s single-threaded and runs on the application’s
    main thread, but when an asynchronous operation is executed, it creates a new
    thread and lets the framework know what to call when it’s finished processing.
    This is signified through the `async`/`await` keywords.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同步操作是指代码执行，应用程序必须等待其完成，这意味着它是单线程的，在应用程序的主线程上运行，但当异步操作执行时，它会创建一个新的线程，并让框架知道在处理完成后调用什么。这通过`async`/`await`关键字表示。
- en: For the majority of Middleware operations, it’s best to use asynchronous calls
    when applicable. This will increase Middleware (and application) performance along
    with better scalability and responsiveness.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数中间件操作，当适用时最好使用异步调用。这将提高中间件（和应用程序）的性能，同时提供更好的可伸缩性和响应性。
- en: Prioritizing the Order
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级排序
- en: One of the more important points of setting up your Middleware is to confirm
    everything is in the right order.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的中间件时，一个非常重要的点是确认所有内容都处于正确的顺序。
- en: Compare your application’s requirements with the previous chart to identify
    what middleware components you need and what their correct order is for your web
    application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序需求与之前的图表进行比较，以确定你需要哪些中间件组件以及它们在Web应用程序中的正确顺序。
- en: For example, if you want to include a W3C Logging Middleware component (which
    is included in the built-in Middleware components from Microsoft), it has to be
    at the beginning of the pipeline to log any subsequent requests made throughout
    the application. Each component has its place in the pipeline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想包含一个W3C日志中间件组件（该组件包含在Microsoft提供的内置中间件组件中），它必须位于管道的起始位置，以便记录应用程序中发出的任何后续请求。每个组件在管道中都有其位置。
- en: Consolidating existing Middleware
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并现有的中间件
- en: When you create a new ASP.NET project, you’ll notice the collection of `app.UseXxx()`
    listed in `Program.cs`. While this is the “out-of-the-box” approach for preparing
    your pipeline, there are other ways to organize and register components for your
    application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的ASP.NET项目时，你会在`Program.cs`中注意到列出的`app.UseXxx()`集合。虽然这是准备你的管道的“开箱即用”方法，但还有其他方法可以组织和注册应用程序的组件。
- en: One approach is to use extension methods based on how you logically partition
    your uses into similar groupings while keeping the components in the same order.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是根据你逻辑上如何将使用情况划分为相似的分组，同时保持组件的相同顺序来使用扩展方法。
- en: 'One example would be to move all client Middleware into its own extension method
    called `.``UseClientOptions()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是将所有客户端中间件移动到其自己的扩展方法`.UseClientOptions()`中：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the code in your `Program.cs` file contains one line, and you know exactly
    what the extension method does:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的`Program.cs`文件中只包含一行代码，你确切地知道扩展方法的作用：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When using this approach, your `Program.cs` file is cleaner, well maintained,
    and contains fewer lines of code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种方法时，你的`Program.cs`文件会更加整洁、易于维护，并且包含更少的代码行。
- en: 'Other possible areas to partition are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能的分区区域如下：
- en: '`UseDataXxxxx()` – Centralized location for connection strings for your application'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseDataXxxxx()` – 应用连接字符串的集中位置'
- en: '`UseMapping()/UseRouting()` – Create a collection of routes for your application
    and APIs'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseMapping()/UseRouting()` – 为你的应用和API创建一组路由'
- en: '`RegisterDependencyInjection()` – Centralize the classes in a number of extension
    methods similar to this grouping approach, but partitioned by sections in your
    application – for example, `RegisterDIPayroll()` for registering classes pertaining
    to the Payroll section of the application'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterDependencyInjection()` – 将类集中到一系列类似于这种分组方法的扩展方法中，但按应用中的部分进行分区 – 例如，`RegisterDIPayroll()`用于注册与应用工资部分相关的类'
- en: While these are merely suggestions, the concept is to trim the size of the `Program.cs`
    file so other developers understand the approach with fewer lines of code, and
    it provides enough clarity for other developers to extend the technique further.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一些建议，但其概念是缩减`Program.cs`文件的大小，以便其他开发者能够通过更少的代码行数理解这种方法，并且为其他开发者提供足够的清晰度，以便进一步扩展技术。
- en: As a recommendation, include all of the important Middleware components upfront
    and confirm the application runs as expected, *then* perform your refactoring
    by creating your groups for consolidation. Remember, the order of Middleware components
    matters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为建议，首先包含所有重要的中间件组件，并确认应用按预期运行，然后通过创建你的合并组进行重构。记住，中间件组件的顺序很重要。
- en: Encapsulating your Middleware
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装你的中间件
- en: 'When creating your first middleware component, you may be tempted to create
    it and use it in this fashion:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建你的第一个中间件组件时，你可能会有这样的冲动：创建它并以这种方式使用：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One problem with this approach is the preceding code can make your `Program.cs`
    file look a little messy if you have a large number of custom middleware components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，如果有很多自定义中间件组件，前面的代码可能会使你的`Program.cs`文件看起来有些杂乱。
- en: 'Once you have your custom component working, it’s better to encapsulate it
    into its own class for increased reusability. If we use our previous example,
    our new class would look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的自定义组件开始工作，最好是将其封装到自己的类中以提高重用性。如果我们使用之前的例子，我们的新类将看起来像这样：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `MyFirstMiddleware` component is a simple class that can
    contain only one method of `Invoke` or `InvokeAsync`. As mentioned before, we’ll
    use the `InvokeAsync` asynchronous method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MyFirstMiddleware`组件是一个简单的类，它只能包含一个`Invoke`或`InvokeAsync`方法。如前所述，我们将使用`InvokeAsync`异步方法。
- en: If you’re wondering how `ILogger` is passed in, ASP.NET Core has a number of
    classes automatically registered with its out-of-the-box dependency injection
    library. `ILogger` is one of those classes, so we don’t need to worry about passing
    it through to our `MyFirstMiddleware` component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道`ILogger`是如何传递的，ASP.NET Core有一系列类自动注册到其开箱即用的依赖注入库中。`ILogger`就是其中之一，所以我们不需要担心将其传递到我们的`MyFirstMiddleware`组件中。
- en: 'We can use our class in our `Program.cs` file like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Program.cs`文件中使用我们的类，如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, since we’re good ASP.NET developers, we can definitely improve the
    code. Most middleware components have extension methods attached to them to make
    them easier to use (which we’ll add now with the following code):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们是优秀的ASP.NET开发者，我们当然可以改进代码。大多数中间件组件都有附加的扩展方法来简化它们的使用（我们现在将添加以下代码）：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `Program.cs` file is much simpler and cleaner now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`Program.cs`文件更加简单和整洁：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These simple practices make a developer’s life easier for reusability and encapsulation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的实践使得开发者在重用和封装方面的生活更加轻松。
- en: In this section, we covered a number of standard methods for writing maintainable
    and efficient Middleware by using asynchronous calls, prioritizing the order of
    your components, and consolidating the existing Middleware into extension methods.
    We also examined how to encapsulate components by creating classes and extension
    methods to make the code easier to read.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过使用异步调用、优先考虑组件的顺序以及将现有的中间件合并到扩展方法中，介绍了一系列编写可维护和高效中间件的标准方法。我们还探讨了如何通过创建类和扩展方法来封装组件，使代码更容易阅读。
- en: Creating an Emoji Middleware Component
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Emoji中间件组件
- en: With the rise of emoticons…sorry, emojis…in the 2000s, a number of legacy websites
    use the old-style of text-based emoticons instead of the more modern emojis. Legacy
    **Content Management Systems** (**CMSs**) must have a lot of these text-based
    characters in their content. To update a website’s content to replace all of these
    emoticons with proper emojis sounds extremely time-consuming.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着表情符号（对不起，是emoji）在2000年代的兴起，许多遗留网站使用老式的基于文本的表情符号而不是更现代的emoji。遗留的**内容管理系统**（**CMS**）在其内容中必须有很多这些基于文本的字符。要将网站的内容更新为用适当的emoji替换所有这些表情符号，听起来非常耗时。
- en: In this section, we’ll apply our standards in creating an emoji Middleware component
    where, if it detects a text-based emoticon, it’ll convert it to a more modern
    emoji.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用我们的标准来创建一个emoji中间件组件，其中如果检测到基于文本的表情符号，它将将其转换为更现代的emoji。
- en: Encapsulating the Middleware
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装中间件
- en: With this new Middleware component, we want to create it in its own class in
    `EmojiMiddleware.cs`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的中间件组件，我们希望在`EmojiMiddleware.cs`中创建它自己的类。
- en: 'Here is the first draft of our component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们组件的第一个草稿：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While this isn’t very exciting, this boilerplate meets all of the previously-mentioned
    standards for building Middleware components, which include the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不非常令人兴奋，但这个样板代码符合之前提到的构建中间件组件的所有标准，包括以下内容：
- en: An encapsulated Middleware component
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装的中间件组件
- en: Using Asynchronous methods (`InvokeAsync()`)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步方法（`InvokeAsync()`）
- en: An extension method for reuse and readability
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于重用和可读性的扩展方法
- en: We can now focus on the conversion process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以专注于转换过程。
- en: Examining the Component’s Pipeline
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查组件的管道
- en: 'In Middleware, there are two ways to process a request and response: by using
    either streams or pipelines. While pipelines are the better option for high performance,
    we’ll focus on streams for our `EmojiMiddleware`. We’ll examine pipelines in a
    later chapter.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件中，有两种处理请求和响应的方式：使用流或管道。虽然管道是高性能的更好选择，但我们将专注于我们的`EmojiMiddleware`流。我们将在后面的章节中探讨管道。
- en: Our middleware stream is located in `HttpContext` through `HttpRequest.Body`
    and `HttpResponse.Body`. In our `Invoke` method, we conveniently pass in an `HttpContext`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的中间件流位于`HttpContext`的`HttpRequest.Body`和`HttpResponse.Body`中。在我们的`Invoke`方法中，我们方便地传入一个`HttpContext`。
- en: Our first order of business is to create the `EmojiStream`. This will accept
    a simple response stream and read it into memory. Once we have our HTML, we can
    search and replace our emoticons. We need a map to identify the text-based characters
    and what image to replace them in our HTML.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是创建`EmojiStream`。这将接受一个简单的响应流并将其读入内存。一旦我们有了HTML，我们就可以搜索和替换我们的表情符号。我们需要一个映射来识别基于文本的字符以及在我们的HTML中用哪个图像来替换它们。
- en: 'To make our life a little easier, we’ll inherit from the `Stream` base class
    and simply override specific methods to fit our needs. The only implementation
    our `EmojiStream` class needs is our text-based emoticons-to-emojis mapping and
    the `.Write()` method, as shown with the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的工作更轻松一些，我们将继承自`Stream`基类，并简单地重写特定方法以满足我们的需求。我们的`EmojiStream`类只需要实现基于文本的表情符号到表情的映射和`.Write()`方法，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the beginning of the code, we create our map of emoticons to look for in
    the HTML. The `EmojiStream` class is fairly common, except for the `WriteAsync()`
    method. We’ll grab the HTML using the `GetString()` method and search for each
    emoticon in the response. If we find one, we’ll replace it with an image tag and,
    finally, write the bytes back into the stream.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始处，我们创建了一个映射，用于在HTML中查找表情符号。`EmojiStream`类相当常见，除了`WriteAsync()`方法。我们将使用`GetString()`方法获取HTML并搜索响应中的每个表情符号。如果我们找到它，我们将用图像标签替换它，最后将字节写回流中。
- en: Since we’re focused on using streams in the Middleware, we’ll pass a stream
    into the constructor instead of creating a new instance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们专注于在中间件中使用流，我们将流传递给构造函数而不是创建一个新的实例。
- en: 'With the middleware piece left, we can use the `EmojiStream` in our class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件部分完成后，我们可以在我们的类中使用 `EmojiStream`：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While our Middleware component takes a simple `RequestDelegate`, the majority
    of the component is in the `InvokeAsync()` method. First, we create a new stream
    for our response. Next, we replace the standard response with our own stream.
    When we are coming back from our endpoint, we create our `EmojiStream` instance
    and pass in our custom stream to the `Response.Body`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的中间件组件接受一个简单的 `RequestDelegate`，但组件的大部分代码都在 `InvokeAsync()` 方法中。首先，我们为我们的响应创建一个新的流。接下来，我们用我们自己的流替换标准响应。当我们从端点返回时，我们创建我们的
    `EmojiStream` 实例并将我们的自定义流传递给 `Response.Body`。
- en: Since `HttpContext` exposes `HttpRequest.Body` and `HttpResponse.Body` as streams,
    it’s easier to pass `HttpContext` into custom middleware components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `HttpContext` 将 `HttpRequest.Body` 和 `HttpResponse.Body` 作为流公开，因此将 `HttpContext`
    传递到自定义中间件组件中更容易。
- en: 'Of course, we can’t forget our extension method, which is shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不能忘记我们的扩展方法，它在这里显示：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This extension method is considered a façade to hide the details of what our
    `EmojiStream` is doing behind the scenes. While we could use the `builder.UseMiddleware<EmojiMiddleware>()`
    syntax in our `Program.cs` file, the extension method cleans it up a bit, giving
    it a professional look.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展方法被视为一个外观，用于隐藏我们的 `EmojiStream` 在幕后执行的具体细节。虽然我们可以在 `Program.cs` 文件中使用 `builder.UseMiddleware<EmojiMiddleware>()`
    语法，但扩展方法使其看起来更专业。
- en: 'The last thing required is to add the `EmojiMiddleware` to the pipeline in
    your `Program.cs` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要做的是将 `EmojiMiddleware` 添加到 `Program.cs` 文件中的管道：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After creating a brand new ASP.NET Core website, we’ll add the following HTML
    to the bottom of our Index page:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的 ASP.NET Core 网站之后，我们将在 Index 页面的底部添加以下 HTML：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run the application without our middleware component, we have the following
    output (*Figure 3**.2*):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序而不使用我们的中间件组件时，我们得到以下输出（**图 3.2**）：
- en: '![ Figure 3.2 – Before our EmojiMiddleware is added to the pipeline](img/Figure_3.02_B19493.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 在我们的 EmojiMiddleware 添加到管道之前](img/Figure_3.02_B19493.jpg)'
- en: Figure 3.2 – Before our EmojiMiddleware is added to the pipeline
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 在我们的 EmojiMiddleware 添加到管道之前
- en: 'When we add our Emoji Middleware to our pipeline and run our application again,
    we receive the following output (*Figure 3**.3*):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将我们的 Emoji 中间件添加到管道并再次运行我们的应用程序时，我们收到以下输出（**图 3.3**）：
- en: '![Figure 3.3 – After our EmojiMiddleware is added to the pipeline](img/Figure_3.03_B19493.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 在我们的 EmojiMiddleware 添加到管道之前](img/Figure_3.03_B19493.jpg)'
- en: Figure 3.3 – After our EmojiMiddleware is added to the pipeline
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 在我们的 EmojiMiddleware 添加到管道之后
- en: In this section, we built our first Middleware component by encapsulating the
    logic in a class, examined the components pipeline using streams, and used the
    Middleware component in a web application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过将逻辑封装在类中来构建我们的第一个中间件组件，使用流检查了组件管道，并在 web 应用程序中使用了中间件组件。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gained a solid understanding of the Middleware pipeline,
    its components, and best practices for using Middleware in ASP.NET Core. We also
    learned about common practices when using Middleware, such as always using asynchronous
    methods, prioritizing the order, consolidating your Middleware components into
    groups, and encapsulating your Middleware into classes. Knowing these Middleware
    concepts is key to creating maintainable and readable code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入理解了中间件管道、其组件以及在使用 ASP.NET Core 中间件的最佳实践。我们还学习了使用中间件时的常见做法，例如始终使用异步方法、优先考虑顺序、将你的中间件组件组合成组，并将你的中间件封装成类。了解这些中间件概念对于创建可维护和可读的代码至关重要。
- en: Finally, we finished the chapter by creating a simple component to replace text
    with an image in a stream for the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过创建一个简单的组件来替换流中的文本为图像来结束本章。
- en: In the next chapter, we’ll begin looking at applying security to new and existing
    applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨将安全性应用于新和现有应用程序。
