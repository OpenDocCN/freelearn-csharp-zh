- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing in ASP.NET Core (Part 1 – Unit Testing)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an essential part of any software development process, including
    ASP.NET Core web API development. Testing helps to ensure that the application
    works as expected and meets the requirements. It also helps to ensure that any
    changes made to the code don’t break existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at the different types of testing that are available
    in ASP.NET Core and how to implement unit tests in ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to testing in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the database access layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to write unit tests for your ASP.NET
    Core web API application to ensure that the code unit is functioning correctly.
    You will also learn how to use some libraries, such as `Moq` and `FluentAssertions`,
    to make your tests more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9).
    You can use VS Code or VS 2022 to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to testing in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different types of testing can be performed on an ASP.NET Core web API application,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: This is the process of testing individual units of code,
    such as methods and classes, to ensure that they work as expected. Unit tests
    should be small, fast, and isolated from other units of code. Mocking frameworks
    can be used to isolate units of code from their dependencies, such as databases
    and external services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: This involves testing the integration between different
    components of the application to ensure that they work together as expected. This
    type of testing helps to identify issues that may arise when the application is
    deployed to a production environment. Generally, integration tests are slower
    than unit tests. Integration tests may use mock objects or real objects, depending
    on the scenario. For example, if the integration test is to test the integration
    between the application and a database, then a real database instance should be
    used. But if the integration test is to test the application’s integration with
    an external service, such as a payment service, then we should use a mock object
    to simulate the external service. In the microservices architecture, integration
    tests are more complicated, as they may involve multiple services. Besides the
    integration tests for each service, there should also be integration tests for
    the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end testing**: This is the process of testing the application from
    the user’s perspective to ensure that the entire system from start to finish,
    including the user interface, the web API, the database, and more, is working
    as expected. End-to-end testing typically involves simulating user interactions
    with the application, such as clicking buttons and entering data into forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: This involves testing whether the application still
    works as expected after new features are added or bugs are fixed. Regression testing
    is usually performed after the application is deployed to a production environment.
    It helps to ensure that the new features or bug fixes don’t break existing functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load testing**: This involves testing whether the application can handle
    a normal load of users and requests. It helps to set the baseline for the performance
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress testing**: This involves testing whether the application can handle
    extreme conditions, such as a sudden spike in the number of users and requests,
    or gradually increasing the load over a long period. It also determines whether
    the application can recover from failures and how long it takes to recover.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance testing**: This is a type of testing that evaluates the performance
    of the application under different workloads, including response time, throughput,
    resource usage, and more. Performance testing is a superset of load testing and
    stress testing. Generally, unit testing and integration testing are performed
    in the development environment and the staging environment, while performance
    testing is performed in a production-like environment, such as a **user acceptance
    testing** (**UAT**) environment, which closely mirrors the production environment
    in terms of infrastructure and configuration. This ensures that the performance
    tests are accurate and reliable. In some cases, limited performance testing can
    be performed in a development environment during scheduled maintenance windows
    to validate real-world performance scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing and integration testing are the most common types of testing that
    are written in .NET by developers. In this chapter, we will focus on unit testing;
    we will discuss integration testing in [*Chapter 10*](B18971_10.xhtml#_idTextAnchor404).
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are written to test individual units of code, such as methods and
    classes. Unit tests are typically written by developers who are familiar with
    the code. When developers develop new features or fix bugs, they should also write
    unit tests to ensure that the code works as expected. There are many unit testing
    frameworks available for .NET, including NUnit, xUnit, and MSTest. In this chapter,
    we will use xUnit to write unit tests since it is one of the most popular unit
    testing frameworks for modern .NET applications at present.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the sample application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample application, `InvoiceApp`, is a simple ASP.NET Core web API application
    that exposes a set of RESTful APIs for managing invoices. The sample application
    uses EF Core to store and retrieve data from a SQL Server database. It has the
    following endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/invoices`: Retrieves a list of invoices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/invoices/{id}`: Retrieves an invoice by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/invoices`: Creates a new invoice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /api/invoices/{id}`: Updates an existing invoice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /api/invoices/{id}`: Deletes an invoice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /api/invoices/{id}/status`: Updates the status of an invoice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /api/invoices/{id}/send`: Sends an invoice email to the contact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/contacts`: Retrieves a list of contacts*   `GET /api/contacts/{id}`:
    Retrieves a contact by ID*   `POST /api/contacts`: Creates a new contact*   `PUT
    /api/contacts/{id}`: Updates an existing contact*   `DELETE /api/contacts/{id}`:
    Deletes a contact*   `GET /api/contacts/{id}/invoices`: Retrieves a list of invoices
    for a contact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the preceding endpoints are not enough to build a complete invoice
    management application. It is just a sample application to demonstrate how to
    write unit tests and integration tests for ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the sample application has a Swagger UI that can be used to test
    the APIs. *Figure 9**.1* shows the Swagger UI for the sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The sample application API endpoints](img/B18971_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The sample application API endpoints
  prefs: []
  type: TYPE_NORMAL
- en: After you run the sample application using the `dotnet run` command, you can
    access the Swagger UI at [http://localhost:5087/swagger/index.html](http://localhost:5087/swagger/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use this sample application to demonstrate how to write unit tests
    for ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the unit tests project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use xUnit to write unit tests for the sample application. xUnit is a
    popular unit testing framework for .NET applications. It is a free, open-source
    project that has been around for many years. It is also the default unit testing
    framework for .NET Core and .NET 5+ applications. You can find more information
    about xUnit at [https://xunit.net/](https://xunit.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the test project, you can use VS 2022 or the .NET CLI. If you use
    VS 2022, you can create a new xUnit test project by right-clicking on the solution
    and selecting `InvoiceApp.UnitTests` and click **Create** to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Creating a new xUnit test project in VS 2022](img/B18971_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Creating a new xUnit test project in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'After you create the project, add a project reference to the `InvoiceApp.WebApi`
    project so that the test project can access the classes in the main web API project.
    You can do this by right-clicking on the `InvoiceApp.WebApi` project from the
    list of projects and click **OK** to add the project reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Adding a project reference to the test project in VS 2022](img/B18971_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Adding a project reference to the test project in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the .NET CLI, you can create a new xUnit test project by running
    the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can add the test project to the solution by running the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to add the reference to the main project by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The default xUnit test project template contains a sample unit test. You can
    delete the sample unit test named `UnitTest1.cs`; we will write our own unit tests
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create the test project starting from a blank .NET library project,
    you need to add the following packages to the test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.NET.Test.Sdk`: This is required for running unit tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xunit`: This is the xUnit framework that we will use to write unit tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xunit.runner.visualstudio`: This is required for running unit tests in Visual
    Studio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coverlet.collector`: This is an open-source project that provides code coverage
    analysis for .NET applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we write unit tests, keep in mind that one unit test should test one unit
    of code, such as a method or a class. The unit test should be isolated from other
    units of code. If one method depends on another method, we should mock the other
    method to isolate the unit of code to ensure that we focus on the behavior of
    the unit of code that we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests without dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see the first example. In the sample application, you can find a `Services`
    folder, which includes the `IEmailService` interface and its implementation, `EmailService`.
    The `EmailService` class has a method named `GenerateInvoiceEmail()`. This method
    is a simple function that generates an email according to the `Invoice` entity.
    The following code shows the `GenerateInvoiceEmail()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Raw string literal
  prefs: []
  type: TYPE_NORMAL
- en: The `body` variable is a raw string literal, which is a new feature that was
    introduced in C# 11\. Raw string literals are enclosed in triple quotes (`"""`).
    They can span multiple lines and can contain double quotes without escaping them.
    You can find more information about raw string literals at [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string).
    Raw strings can also be used with interpolated strings, which is convenient for
    generating strings with variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no dependency in the `GenerateInvoiceEmail()` method, so we can write
    a unit test for this method without mocking any other methods. Create a class
    named `EmailServiceTests` in the `InvoiceApp.UnitTests` project. Then, add the
    following code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Fact` attribute indicates that the `GenerateInvoiceEmail_Should_Return_Email()`
    method is a unit test so that xUnit can discover and run this method as a unit
    test. In the `GenerateInvoiceEmail_Should_Return_Email()` method, we created an
    `Invoice` object and passed it to the `GenerateInvoiceEmail()` method. Then, we
    used the `Assert` class to verify that the `GenerateInvoiceEmail()` method returns
    the expected email.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing unit tests, we follow the *Arrange-Act-Assert* pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This is where we prepare the data and set up the environment for
    the unit test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: This is where we call the method that we want to test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: This is where we verify that the method returns the expected result
    or that the method behaves as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the unit test in VS 2022, you can right-click on the `InvoiceApp.UnitTests`
    project or the `EmailServiceTest.cs` file and select **Run Tests**. You can also
    use the **Test Explorer** window to run the unit test by clicking the **Test**
    menu and selecting **Run** **all tests**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Running unit tests in VS 2022](img/B18971_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Running unit tests in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code supports running unit tests as well. Click the **Testing** icon on
    the left-hand side of the VS Code window to open the **Test** view; you will see
    the unit tests, as shown in *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Running unit tests in VS Code](img/B18971_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Running unit tests in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the .NET CLI, you can run the unit tests by running the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the unit test passed. If you want to see the detailed
    test results, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will see detailed test results that show the test name, the result, the
    duration, and the output.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests with dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at another example. In the `EmailService` class, there is a method
    named `SendEmailAsync()`, which sends an email to the recipient. In real-world
    applications, we usually use a third-party email service to send emails. To make
    the `EmailService` class testable, we can create an `IEmailSender` interface and
    its implementation, `EmailSender`. The `EmailSender` class is a wrapper of the
    `SmtpClient` class, which is used to send emails. The following code shows the
    updated `EmailService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, now, `EmailService` has a dependency on the `IEmailSender` interface. To
    test the behavior of the `SendEmailAsync()` method of the `EmailService` class,
    we need to mock the `IEmailSender` interface to isolate the `EmailService` class
    from the `EmailSender` class. Otherwise, if any error occurs in the unit test,
    we cannot say for sure whether the error is caused by the `EmailService` class
    or the `EmailSender` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `Moq` library to mock the `IEmailSender` interface. `Moq` is
    a popular mocking library for .NET. It is available as a NuGet package. To install
    `Moq`, you can use **NuGet Package Manager** in VS 2022 or run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create the unit tests for the `SendEmailAsync()` method. Because
    the `SendEmailAsync()` method may throw an exception if the email-sending process
    fails, we need to write two unit tests to test the success and failure scenarios.
    The following code shows the unit test for the success scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the `Mock` class to create mock objects of the
    `IEmailSender` interface and the `ILogger` interface. We need to set up the behavior
    of the methods for the mock objects. If the methods used in the unit test are
    not set up, the unit test will fail. For example, we use the `SetUp()` method
    to mock the `SendEmailAsync` method of the `IEmailSender` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetUp()` method takes a lambda expression as the parameter, which is used
    to configure the behavior of the `SendEmailAsync()` method. In the preceding code,
    we use the `It.IsAny<string>()` method to specify that the `SendEmailAsync()`
    method can accept any string value as the parameter. Then, we use the `Returns()`
    method to specify the return value of the `SendEmailAsync()` method. In this case,
    we use the `Task.CompletedTask` property to specify that the `SendEmailAsync()`
    method will return a completed task. If you need to return a specific value, you
    can also use the `Returns()` method to return a specific value. For example, if
    the `SendEmailAsync()` method returns a `bool` value, you can use the following
    code to return a `true` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Mocking the ILogger interface
  prefs: []
  type: TYPE_NORMAL
- en: The `EmailService` class uses the `ILogger` interface to log the information
    and errors. We use the `LogInformation()` method to log the information and `LogError()`
    method to log the errors. However, we cannot mock the `LogInformation()` or `LogError()`
    method directly because they are extension methods on top of the `ILogger` interface.
    These extension methods, such as `LogInformation()`, `LogError()`, `LogDebug()`,
    `LogWarning()`, `LogCritical()`, `LogTrace()`, and others, all call the `Log()`
    method of the `ILogger` interface. Therefore, to verify that a given log message
    is logged, it is necessary to mock only the `Log()` method of the `ILogger` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `SendEmailAsync()` method throws an exception, we need to ensure the
    logger will log the exception when the exception occurs. To test the failure scenario,
    we need to mock the `SendEmailAsync()` method so that it throws an exception.
    We can use the `ThrowsAsync()` method to mock the `SendEmailAsync()` method to
    throw an exception explicitly. The following code shows how to mock the `SendEmailAsync()`
    method to throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can verify whether the `LogError()` method of the `ILogger` interface
    is called when the `SendEmailAsync()` method throws an exception, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can ensure that the `SendEmailAsync()` method will log the exception
    when the exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: When we write unit tests, note that the test method name should be descriptive
    and should indicate the purpose of the test. For example, `SendEmailAsync_ShouldLogError_WhenEmailSendingFails()`
    is a good name because it indicates that the `SendEmailAsync` method should log
    an error when the email sending fails. However, `SendEmailAsyncTest()` is not
    a good name because it does not indicate the purpose of the test.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how to use the `Mock` library to create mock objects,
    see [https://github.com/moq/moq](https://github.com/moq/moq).
  prefs: []
  type: TYPE_NORMAL
- en: Using FluentAssertions to verify the test results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`xUnit` provides a set of static assertion methods to verify the test results.
    For example, we can use the `Assert.Equal()` method to verify if two objects are
    equal. These methods cover most of the scenarios, such as verifying objects, collections,
    exceptions, events, equality, types, and more. Here is a list of the assertion
    methods provided by xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **xUnit** **Assertion Methods** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Equal(expected, actual)` | Verifies that the `expected` value is
    equal to the `actual` value |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotEqual(expected, actual)` | Verifies that the `expected` value
    is not equal to the `actual` value |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.StrictEqual(expected, actual)` | Verifies that the `expected` value
    is strictly equal to the `actual` value, using the type’s default comparer |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotStrictEqual(expected, actual)` | Verifies that the `expected`
    value is strictly not equal to the `actual` value, using the type’s default comparer
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Same(expected, actual)` | Verifies that the `expected` object is
    the same instance as the `actual` object |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotSame(expected, actual)` | Verifies that the `expected` object
    is not the same instance as the `actual` object |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.True(condition)` | Verifies that the `condition` is true |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.False(condition)` | Verifies that the `condition` is false |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Null(object)` | Verifies that the `object` is null |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotNull(object)` | Verifies that the `object` is not null |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsType(expectedType, object)` | Verifies that the `object` is exactly
    `expectedType`, and not a derived type |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsNotType(unexpectedType, object)` | Verifies that the `object` is
    not exactly `unexpectedType` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.IsAssignableFrom(expectedType, object)` | Verifies that the `object`
    is assignable to `expectedType`, which means that `object` is the given type or
    a derived type |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Contains(expected, collection)` | Verifies that `collection` contains
    the `expected` object |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.DoesNotContain(expected, collection)` | Verifies that `collection`
    does not contain the `expected` object |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Empty(collection)` | Verifies that `collection` is empty |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotEmpty(collection)` | Verifies that `collection` is not empty |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Single(collection)` | Verifies that `collection` contains exactly
    one element of the given type |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.InRange(actual,` `low, high)` | Verifies that the `actual` value
    is within the range of `low` and `high` (inclusive) |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotInRange(actual,` `low, high)` | Verifies that the `actual` value
    is not within the range of `low` and `high` (inclusive) |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Throws<exceptionType>(action)` | Verifies that `action` throws an
    exception of the specified `exceptionType`, and not a derived exception type |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.ThrowsAny<exceptionType>(action)` | Verifies that `action` throws
    an exception of the specified `exceptionType` or a derived exception type |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – List of assertion methods provided by xUnit
  prefs: []
  type: TYPE_NORMAL
- en: 'Note this list is not complete. You can find more assertion methods in xUnit’s
    GitHub repository: [https://github.com/xunit/assert.xunit](https://github.com/xunit/assert.xunit).'
  prefs: []
  type: TYPE_NORMAL
- en: Although the assertion methods provided by xUnit are enough for most scenarios,
    they are not very readable. A good way to make the unit tests more natural and
    readable is to use `FluentAssertions`, an open-source assertion library for .NET.
    It provides a set of extension methods that allow us to write assertions fluently.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `FluentAssertions`, we can use the following .NET CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can also use NuGet Package Manager to install the `FluentAssertions` package
    if you use VS 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can use the `Should()` method to verify the test results. For example,
    we can use the `Should().Be()` method to verify whether two objects are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use the `Should().Be()` method to verify whether
    the `GetInvoicesAsync()` method returns a list of invoices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `FluentAssertions` method is more intuitive and readable than the `Assert.Equal()`
    method. For most scenarios, you can easily replace the assertion methods provided
    by xUnit with the `FluentAssertions` methods without searching the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to verify the exception using `FluentAssertions`. In the `EmailServiceTests`
    class, there is a `SendEmailAsync_Should_Log_SmtpException()` method. This method
    verifies whether the `SendEmailAsync()` method will log the exception when the
    `SendEmailAsync()` method throws an exception. The following code shows how to
    use `xUnit` to verify the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Should().ThrowAsync<>()` method of `FluentAssertions` to verify
    the exception, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `FluentAssertions` is more readable and intuitive than the xUnit way.
    Here is a table comparing some common assertion methods provided by xUnit and
    `FluentAssertions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **xUnit** **Assertion Method** | **FluentAssertions** **Assertion Method**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Equal(expected, actual)` | `.``Should().Be(expected)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotEqual(expected, actual)` | `.``Should().NotBe(expected)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.True(condition)` | `.``Should().BeTrue()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.False(condition)` | `.``Should().BeFalse()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Null(object)` | `.``Should().BeNull()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotNull(object)` | `.``Should().NotBeNull()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Contains(expected, collection)` | `.``Should().Contain(expected)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.DoesNotContain(expected, collection)` | `.``Should().NotContain(expected)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Empty(collection)` | `.``Should().BeEmpty()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.NotEmpty(collection)` | `.``Should().NotBeEmpty()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.Throws<TException>(action)` | `.``Should().Throw<TException>()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Assert.DoesNotThrow(action)` | `.``Should().NotThrow()` |'
  prefs: []
  type: TYPE_TB
- en: Table 9.2 – Comparison of common assertion methods provided by xUnit and FluentAssertions
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the preceding table is not an exhaustive list. You can find more
    extension methods in the official documentation of `FluentAssertions`: [https://fluentassertions.com/introduction](https://fluentassertions.com/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the fluent assertion methods, `FluentAssertions` also provides better
    error messages if the test fails. For example, if we use the `Assert.Equal()`
    method to verify whether `returnResult` contains two invoices, the code will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the test fails, the error message will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we have multiple `Assert.Equal()` methods in the test method, which is not
    recommended but something we have to do occasionally, we cannot immediately know
    which `Assert.Equal()` method fails. We need to check the line number of the error
    message to find the failing assertion. This is not very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use `FluentAssertions`, the assertion code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the test fails with the same reason, the error message will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, the error message is more detailed and intuitive and tells us which assertion
    fails. This is very helpful when we have multiple assertions in the test method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even enrich the error message by adding a custom message to the assertion
    method. For example, we can add a custom message to the `Should().Be()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the error message will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, it is highly recommended to use `FluentAssertions` in your tests.
    It makes your tests more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the database access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many web API applications, we need to access the database to perform CRUD
    operations. In this section, we will learn how to test the database access layer
    in unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: How can we test the database access layer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, we inject `InvoiceDbContext` into controllers to access the database.
    This approach is easy for development, but it tightly couples the controllers
    with the `InvoiceDbContext` class. When we test the controllers, we need to create
    a real `InvoiceDbContext` object and use it to test the controllers, which means
    controllers are not tested in isolation. This problem can be addressed in a variety
    of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `InMemoryDatabase` provider of EF Core to create an in-memory database
    as the fake database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the SQLite in-memory database as the fake database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a separate repository layer to encapsulate the database access code,
    inject the repository layer into controllers (or services that need to access
    databases), and then use `Mock` objects to mock the repository layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the real database for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each approach has its pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `InMemoryDatabase` provider was originally designed for internal testing
    of EF Core. However, it is not a good choice for testing other applications because
    it does not behave like a real database. For example, it does not support transactions
    and raw SQL queries. So, it is not a good choice for testing the database access
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite also provides an in-memory database feature that can be used for testing.
    However, it has similar limitations to EF Core’s `InMemoryDatabase` provider.
    If the production database is SQL Server, EF Core cannot guarantee that the database
    access code will work correctly on SQL Server if we use SQLite for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a separate repository layer is to decouple the controllers from the
    `DbContext` class. In this pattern, a separate `IRepository` interface is created
    between the application code and `DbContext`, and the implementation of the `IRepository`
    interface is injected into controllers or services. In this way, we can use `Mock`
    objects to mock the `IRepository` interface to test controllers or services, which
    means controllers or services can be tested in isolation. However, this approach
    requires a lot of work to create the repository layer. Also, the `DbContext` class
    is already a repository pattern, so creating another repository layer is redundant
    if you do not need to change the database provider. But this pattern still has
    its advantages. Tests can focus on the application logic without worrying about
    the database access code. Also, if you need to change the database provider, you
    only need to change the implementation of the `IRepository` interface, and there
    is no need to change the controllers or services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing against a real database provides more benefits. One of the most important
    benefits is that it can ensure that the database access code works correctly on
    the database in production. Using a real database is also fast and reliable. However,
    one challenge is that we need to ensure the isolation for tests because some of
    them may change the data in the database. So, we need to make sure the data can
    be restored or recreated after the tests are completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will use a separate local database for testing, such as
    a LocalDB database. If your application will run on SQL Server, you can use another
    SQL Server for testing rather than LocalDB since LocalDB does not behave the same
    as SQL Server. If your application will run in the cloud, such as Azure, you may
    use an Azure SQL database. You can use another Azure SQL database for testing
    but you will need to allocate a small amount of resources for it to save the cost.
    Keep in mind that the database for testing should keep the same environment as
    much as possible to avoid unexpected behaviors in production.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the controllers, we will use the `InvoiceDbContext` class directly
    for simplicity; we will learn the repository pattern in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we test the CRUD methods against the database, we need to prepare the database
    before the tests are executed, and then clean up the database after the tests
    are completed so that the changes made by the tests will not affect other tests.
    xUnit provides the `IClassFixture<T>` interface to create a test fixture, which
    can be used to prepare and clean up the database for each test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a test fixture class in the `InvoiceApp.UnitTests`
    project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `TestDatabaseFixture` class, we define a connection string to the local
    database. Using a `const` string is for simplicity only. In a real application,
    you may want to use the configuration system to read the connection string from
    other sources, such as the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add a method to create the database context object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a method to initialize the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the `InitializeDatabase()` method, we create a new `InvoiceDbContext` object
    and then use the `EnsureDeleted()` method to delete the database if it exists.
    Then, we use the `EnsureCreated()` method to create the database. After that,
    we seed some data into the database. In this example, we create a few `Contact`
    and `Invoice` objects and add them to the database. Finally, we call the `SaveChanges()`
    method to save the changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to call the `InitializeDatabase()` method to initialize the database
    in the constructor of the `TestDatabaseFixture` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To avoid initializing the database multiple times, we use a static field, `_databaseInitialized`,
    to indicate whether the database has been initialized. We also define a static
    object, `Lock`, to ensure that the database is initialized only once. The `InitializeDatabase()`
    method is used to initialize the database. It will only be called once before
    the tests are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several important things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: xUnit creates a new instance of the test class for every test. So, the constructor
    of the test class is called for every test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting and recreating the database for each test run may slow down the tests
    and may not be necessary. If you do not want to delete and recreate the database
    for each test run, you can comment out the `EnsureDeleted()` method to allow the
    database to be reused. However, if you need to frequently change the database
    schema in the development phase, you may need to delete and recreate the database
    for each test run to ensure the database schema is up to date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a lock object to ensure the `InitializeDatabase()` method is only called
    once for each test run. The reason is that the `TextDatabaseFixture` class can
    be used in multiple test classes, and xUnit can run multiple test classes in parallel.
    Using a lock can help us ensure the seed method is only called once. We will learn
    more about parallel test execution in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the test fixture is ready, we can use it in the test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the test fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will use the test fixture in the test classes. First, let’s test the
    `GetAll()` method of the `InvoiceController` class. Create a new test class named
    `InvoiceControllerTests` in the `InvoiceApp.UnitTests` project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We use dependency injection to inject the `TestDatabaseFixture` object into
    the test class. Then, we can use the text fixture to create the `InvoiceDbContext`
    object in the test methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `GetInvoices_ShouldReturnInvoices()` method, we use the fixture to create
    the `InvoiceDbContext` object, and then create the `InvoiceController` object
    with some mocked dependencies. Then, we call the `GetInvoicesAsync()` method to
    get the invoices from the database. Finally, we use the `Assert` class to verify
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: The data we use to verify the controller is the data we seed into the database
    in the `TestDatabaseFixture` class. If you change the data in the `TestDatabaseFixture`
    class, you also need to change the expected data in the test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetInvoices_ShouldReturnInvoices()` method is a simple `Fact` test method.
    We can also use the `Theory` test method to test the `GetInvoicesAsync()` method
    with different parameters. For example, we can test whether the controller can
    return correct invoices when we pass the `status` parameter. The test method is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `Theory` attribute to indicate that the
    test method is a `Theory` test method. A `Theory` test method can have one or
    more `InlineData` attributes. Each `InlineData` attribute can pass one value or
    multiple values to the test method. In this case, we use the `InlineData` attribute
    to pass the `InvoiceStatus` value to the test method. You can use multiple `InlineData`
    attributes to pass multiple values to the test method. The test method will be
    executed multiple times with different values.
  prefs: []
  type: TYPE_NORMAL
- en: The tests we introduced in this chapter are used to test read-only methods.
    They do not change the database, so we do not need to worry about the database
    state. In the next section, we will introduce how to write tests for methods that
    change the database.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for methods that change the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a method changes the database, we need to ensure that the database is in
    a known state before we run the test, and also ensure that the database is restored
    to its original state so that the change will not affect other tests.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a method may delete a record from the database. If the test method
    deletes a record from the database but does not restore the database after the
    test, the next test method may fail because the record is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a test method for the `CreateInvoiceAsync()` method of the `InvoiceController`
    class. The `CreateInvoiceAsync()` method creates a new invoice in the database.
    The test method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this test method, we create a new invoice and pass it to the `CreateInvoiceAsync()`
    method. Then, we use the `Assert` class to verify the result. Finally, we remove
    the invoice from the database and save the changes. Note that the result of the
    `CreateInvoiceAsync()` method is a `CreatedActionResult` object, which contains
    the created invoice. So, we should convert the result into a `CreatedAtActionResult`
    object, and then get the created invoice from the `Value` property. Also, in this
    test method, we have asserted that the `Amount` property of the created invoice
    is correct based on the invoice items.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the test, an error may occur because the contact ID is incorrect,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The error says that the `CreateInvoiceAsync()` method does not behave as expected.
    We can debug the application to find out why the contact ID is not saved correctly.
    The reason is that when we created `Invoice`, we only specified the `ContactId`
    property, not the `Contact` property. So, EF Core could not find the contact with
    the specified ID, and then it created a new contact with a new ID. To fix this
    issue, we need to specify the `Contact` property when we create the `Invoice`
    object. Add the following code before calling the `dbContext.Invoices.AddAsync()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run the test again. This time, the test should pass. That is why
    unit tests are so important. They can help us find bugs early and fix them before
    we deploy the application to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the data was created in the test method and then
    removed from the database after the test. There is another way to manage this
    scenario: using a transaction. We can use a transaction to wrap the test method,
    and then roll back the transaction after the test. So, the data created in the
    test method will not be saved to the database. In this way, we do not need to
    manually remove the data from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a test for the `UpdateInvoiceAsync()` method of the `InvoiceController`
    class. The `UpdateInvoiceAsync()` method updates an invoice in the database. The
    test method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the `UpdateInvoice_ShouldUpdateInvoice()` method, before we call the `UpdateInvoiceAsync()`
    method, we start a transaction. After the test method is executed, we do not commit
    the transaction, so the transaction will roll back. The changes that are made
    in the test method will not be saved to the database. In this way, we do not need
    to manually remove the data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the `ChangeTracker.Clear()` method to clear the change tracker.
    The change tracker is used to track the changes made to the entities. If we do
    not clear the change tracker, we will get the tracked entities instead of querying
    the database. So, we need to explicitly clear the change tracker before we query
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is convenient when we test the methods that change the database.
    However, it can lead to a problem: what if the controller (or the service) method
    already starts a transaction? We cannot wrap a transaction in another transaction.
    In this case, we must explicitly clean up any changes made to the database after
    the test method is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `IDisposable` interface to clean up the database in our tests.
    To do this, we can create a test class that implements the `IDisposable` interface,
    and then clean up the database in the `Dispose()` method. To set up the test context,
    let’s create a class called `TransactionalTestDatabaseFixture`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a database called `InvoiceTransactionalTestDb`
    and initialize it. This file is similar to the `InvoiceTestDatabaseFixture` class,
    except that it has a `Cleanup` method, which is used to clean up the database.
    In the `Cleanup` method, we delete all the contacts and invoices from the database
    and then initialize the database to restore the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `InvoiceController.cs` file, the `UpdateInvoiceStatusAsync` method uses
    a transaction to update the status of an invoice. It is not required; this is
    purely for demonstration purposes. Let’s create a test class called `TransactionalInvoiceControllerTests`
    to test this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `TransactionalTestDatabaseFixture` class to
    create the database context. This class implements the `IDisposable` interface
    and calls the `Cleanup()` method in the `Dispose()` method. If we have multiple
    test methods in one test class, xUnit will create a new instance of the test class
    for each test method and run them in sequence. Therefore, the `Dispose()` method
    will be called after each test method is executed to clean up the database, which
    will ensure that the changes made in the test methods will not affect other test
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to share `TransactionalTestDatabaseFixture` in multiple test
    classes? By default, xUnit will run the test classes in parallel. If other test
    classes also need to use this fixture to clean up the database, it may cause a
    concurrency issue when xUnit initializes the test context. To avoid this problem,
    we can use the `Collection` attribute to specify that the test classes that use
    this fixture belong to the same test collection so that xUnit will not run them
    in parallel. We’ll discuss the parallelism of xUnit in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism of xUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the latest version of xUnit (v2+) runs tests in parallel. This is
    because parallelism can improve the performance of the test. If we have a lot
    of tests, running them in parallel can save a lot of time. Also, it can leverage
    the multi-core CPU to run the tests. However, we need to understand how xUnit
    runs tests in parallel, just in case it causes problems.
  prefs: []
  type: TYPE_NORMAL
- en: xUnit uses a concept called **test collection** to represent a group of tests.
    By default, each test class is a unique test collection. Note that the tests in
    the same test class will not run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the sample project, we can find an `InvoiceControllerTests.cs`
    file and a `ContactControllerTests.cs` file. So, xUnit will run these two test
    classes in parallel, but the tests in the same test class will not run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced a `TestDatabaseFixture` class in the *Creating a test fixture*
    section. A class fixture is used to share a single test context among all the
    tests in the same test class. So, if we use a class fixture to create a database
    context, the database context will be shared among all the tests in the same test
    class. Currently, we have two test classes that use the `TestDatabaseFixture`
    class to provide the database context. Will xUnit create only one instance of
    the `TestDatabaseFixture` class for these two test classes?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is no. We can set up a breakpoint in the constructor of the `TestDatabaseFixture`
    class, and then debug the tests by right-clicking `InvoiceApp.UnitTests` in the
    **Test Explorer** window of VS 2022 and then clicking **Debug**, as shown in *Figure
    9**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Debug tests in VS 2022](img/B18971_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Debug tests in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: You will find that the constructor of the `TestDatabaseFixture` class is called
    twice (or more, depending on how many tests use this text fixture). So, we know
    that xUnit will create a new instance of the `TestDatabaseFixture` class for each
    test class as well. That is why we use a lock to ensure that the database is only
    created once. If we do not use the lock, multiple test classes will try to initialize
    the database at the same time, which potentially causes problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Writing tests for methods that change the database* section, we created
    a `TransactionalTestDatabaseFixture` class that can clean up the database. If
    we apply it to one test class, such as `TransactionalInvoiceControllerTests`,
    it will work fine. But what if we want to use it for multiple test classes? By
    default, xUnit will run these test classes in parallel, which means that multiple
    test classes will try to clean up the database at the same time. In this case,
    we do not want to run these test classes in parallel. To do this, we can use the
    `Collection` attribute to group these test classes into one collection so that
    xUnit will not run them in parallel. This can help us avoid the concurrency issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. In the sample project, you will find that the `ContactController`
    file has a method named `UpdateContactAsync()` that uses a transaction. Again,
    this is not required and is just for demonstration purposes. To use the collection
    fixture, we need to create a definition for the collection. Let’s create a `TransactionalTestsCollection`
    class in the `InvoiceApp.UnitTests` project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we declare that the `TransactionalTestDatabaseFixture` class
    is a collection fixture that uses the `CollectionDefinition` attribute. We also
    specify a name for this collection, which is `TransactionalTests`. Then, we use
    the `ICollectionFixture<T>` interface to specify that the `TransactionalTestDatabaseFixture`
    class is a collection fixture.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we add the `Collection` attribute to the test classes, which specifies
    that the `TransactionalInvoiceControllerTests` and `TransactionalContactControllerTests`
    classes belong to the `TransactionalTests` collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we debug the tests, we will find that the constructor of the `TransactionalTestDatabaseFixture`
    class is only called once, which means that xUnit will only create one instance
    of the `TransactionalTestDatabaseFixture` class for these two test classes. Also,
    xUnit will not run these two test classes in parallel, which means that the `Cleanup`
    method of the `TransactionalTestDatabaseFixture` class will not be called at the
    same time. So, we can use the `TransactionalTestDatabaseFixture` class to clean
    up the database for each test method in multiple test classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize the key points of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, each test class is a unique test collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests in the same test class will not run in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to share a single test context among all the tests within the same
    test class, we can use a class fixture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit creates a new instance of the test class for each test method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit creates a new instance of the class fixture for each test class and shares
    the same instance among all the tests in the same test class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, xUnit runs test classes in parallel if they are not in the same
    test collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do not want to run multiple test classes in parallel, we can use the `Collection`
    attribute to group them into one test collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to share a single test context among several test classes and clean
    up the test context after each test method, we can use a collection fixture, and
    implement the `IDisposable` interface in each test class to clean up the test
    context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit creates a new instance of the test class for each test method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit creates only one instance of the collection fixture for the test collection
    and shares the same instance among all the tests in the collection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit does not run multiple test classes in parallel if they belong to the same
    test collection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit provides a lot of features to customize the test execution. If you want
    to learn more about xUnit, you can check out the official documentation at [https://xunit.net/](https://xunit.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Using the repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have learned how to use a real database to test the database access
    layer. There is another way to test the database access layer, which is to use
    a repository pattern to decouple the controllers from the `DbContext` class. In
    this section, we will show you how to use the repository pattern to test the database
    access layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository pattern is a common pattern that’s used to separate the application
    and the database access layer. Instead of using `DbContext` directly in the controllers,
    we can add a separate repository layer to encapsulate the database access logic.
    The controllers will use the repository layer to access the database, as shown
    in *Figure 9**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7– Using the repository pattern](img/B18971_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7– Using the repository pattern
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9**.7*, we can see that the application now has no dependency on
    EF Core. The application (controllers) only depends on the repository layer, and
    the repository layer depends on EF Core. Therefore, the repository layer can be
    mocked in the tests, and the controllers can be tested without a real database.
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to use the repository pattern for testing, you can look at the
    sample project in the `UnitTestsDemo\UnitTest-v2` folder. This project is based
    on the `v1` project, and we have added a repository layer to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IInvoiceRepository` interface defines the methods of the `Invoice` repository,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `IInvoiceRepository` interface is in the `InvoiceRepository`
    class; it uses the `DbContext` class to access the database. First, we inject
    the `InvoiceDbContext` class into the `InvoiceRepository` class using the constructor
    injection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can implement the `IInvoiceRepository` interface in the `InvoiceRepository`
    class. Here is an example of the `GetInvoicesAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the `GetInvoiceAsync()` method, we use a `LINQ` query to get the invoice
    by the specified ID. Note that we use the `Include` method to include the `Contact`
    property in the query result. This is because we want to get the contact information
    of the invoice. If we do not want to include the navigation property in the query
    result, we can remove the `Include()` method, or add a parameter to the `GetInvoiceAsync()`
    method to specify whether to include the navigation property. The `Include()`
    method is defined in the `Microsoft.EntityFrameworkCore` namespace, so we need
    to add the `using Microsoft.EntityFrameworkCore;` statement to the `InvoiceRepository.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `GetInvoicesAsync()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `GetInvoicesAsync()` method, we use some `LINQ` methods, such
    as `Where()`, `OrderByDescending()`, `Skip()`, and `Take()`, to implement the
    pagination feature. Note that the `ToListAsync()` method is defined in the `Microsoft.EntityFrameworkCore`
    namespace, so do not forget to add the `using` `Microsoft.EntityFrameworkCore;`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete implementation of the `InvoiceRepository` class in
    the `InvoiceRepository.cs` file in the `UnitTestsDemo\UnitTest-v2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the repository interface is just a class that uses the
    `DbContext` class to implement the CRUD operations. Generally, this layer does
    not contain any business logic. Also, we should note that the `GetInvoicesAsync()`
    method returns `IEnumerable<Invoice>` instead of `IQueryable<Invoice>`. This is
    because the `IQueryable` interface involves EF Core, but the purpose of using
    the repository pattern is to decouple the application from EF Core. So, we can
    easily mock the repository layer in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controllers now depend on the repository layer, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the controller is much cleaner, and there is no dependency on EF Core.
    We can update the tests so that they use the repository layer instead of the `DbContext`
    class. Similar to that in the previous `InvoiceControllerTests`, we may need a
    class fixture to manage the test context, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class fixture, we have added two lists to mock the database tables.
    Next, we can mock the tests, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test method, we mock the repository layer and pass it to the controller.
    It follows the concept of the unit tests: focus on the unit under test and mock
    the dependencies. You can check the other tests in the source code and try to
    add more tests to cover the other scenarios, such as creating invoices, updating
    invoices, deleting invoices, and so on. Note that we use two instances of `List<T>`
    to mock the database tables. If the test methods change the data, do not forget
    to restore the data after the test methods are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern is a good practice for decoupling the application from
    the data access layer, and it also makes it possible to replace the data access
    layer with another one. It allows us to mock the database access layer for testing
    purposes. However, it increases the complexity of the application. Also, if we
    use the repository pattern, we may lose some features of EF Core, such as `IQueryable`.
    Finally, the mock behavior may be different from the real behavior. So, we should
    consider the trade-offs before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the happy path and the sad path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have written some tests to cover the happy path. However, we should
    also test the sad path. In testing, the terms **happy path** and **sad path**
    are used to describe different scenarios or test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetInvoiceAsync(Guid id)` method, the happy path is that the invoice with
    the specified ID exists in the database, and the method returns the invoice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetInvoiceAsync(Guid id)` method, the sad path is that the invoice with the
    specified ID does not exist in the database, and the method returns the `404 Not`
    `Found` error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By combining both happy path and sad path tests, we can ensure that the code
    unit works as expected in different scenarios. Here is an example of a happy path
    for `the GetInvoiceAsync(Guid` `id)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this test method, we pass the ID of the first invoice in the `Invoices` list
    to the `GetInvoiceAsync(Guid id)` method. Since the invoice with the specified
    ID exists in the database, the method should return the invoice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a sad path test for the `GetInvoiceAsync(Guid` `id)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this test method, we pass a new GUID to the `GetInvoiceAsync(Guid id)` method.
    Since the invoice with the specified ID does not exist in the database, the method
    should return a `404 Not Found` error. We can also create sad path tests for other
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between `as` and `is` in C#?
  prefs: []
  type: TYPE_NORMAL
- en: The `as` operator is used to perform conversions between compatible types. If
    the conversion is not possible, the `as` operator returns `null` instead of raising
    an exception. So, in the preceding test, if `result` is not `null`, we can see
    that the result from the controller is `NotFoundResult`, which is the expected
    result.
  prefs: []
  type: TYPE_NORMAL
- en: The `is` operator is used to determine whether an object is compatible with
    a given type. If the object is compatible, the operator will return `true`; otherwise,
    it will return `false`. This is a useful tool for verifying the type of an object
    before performing an operation on it.
  prefs: []
  type: TYPE_NORMAL
- en: From C# 7, we can use `is` to check and convert the type at the same time. For
    example, we can use `if (result is NotFoundResult notFoundResult)` to check whether
    `result` is `NotFoundResult`, and convert it into `NotFoundResult` at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to write unit tests for the controller. You can
    check the other tests in the source code and try to add more tests to cover the
    other scenarios, such as creating invoices, updating invoices, deleting invoices,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the fundamentals of unit tests for ASP.NET web
    API applications. We discussed the use of xUnit as the testing framework and `Moq`
    as the mocking framework. We learned how to configure test fixtures with xUnit,
    and how to manage the test data with the test fixture. We also learned how to
    write unit tests to test the data access layer and the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are a great way to ensure that your code unit is working as expected.
    These tests often use mock objects to isolate the code unit from its dependencies,
    but this cannot guarantee that the code unit works well with its dependencies.
    Therefore, we also need to write integration tests to test if the code units can
    work together with their dependencies. For example, can the controllers handle
    the requests correctly?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to write integration tests for ASP.NET
    web API applications.
  prefs: []
  type: TYPE_NORMAL
