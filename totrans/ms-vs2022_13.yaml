- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Your Own Project Template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the world of Visual Studio by exploring how
    to create custom project templates. These templates are incredibly powerful tools
    that allow us to streamline our development process, ensuring that our team starts
    every project with a consistent structure and configuration. We’ll begin by breaking
    down the fundamental structures that make up a project template, giving you a
    solid foundation to build upon. As we progress, we’ll discover how to integrate
    parameters into our templates, allowing for dynamic customization at the point
    of project creation. Finally, we’ll delve into advanced features, teaching you
    how to extend your project templates into full-fledged solution templates that
    can handle complex, multi-project solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding project template structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a basic project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize project templates for different workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating template parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending project templates with advanced features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll not only have the knowledge to create and
    customize project templates, but you’ll also understand how to leverage these
    tools to enhance productivity and maintain consistency across your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch13](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch13)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding project template structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all use templates when we create a new project or a new item with Visual
    Studio. In this section, we will cover the difference between project and item
    templates and then see what files are involved in this process. Project templates
    in Visual Studio are powerful tools that help developers quickly set up new projects
    with predefined configurations and structures. On the other hand, we can create
    item templates for specific parts of the project. These templates provide a base
    that can be customized according to specific needs, streamlining the development
    process and ensuring consistency across projects.
  prefs: []
  type: TYPE_NORMAL
- en: Both project templates and item templates in Visual Studio are reusable structures
    designed to simplify development by providing basic code frameworks and configurations
    that can be tailored to specific needs. Despite their similarities, they differ
    significantly in scope and application within the Visual Studio environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project templates** serve as foundational blueprints for creating new projects.
    They include the entire project structure, necessary files, references, and configuration
    settings tailored to a specific project type (e.g., ASP.NET Core Web App, Class
    Library). When starting a new project in Visual Studio, we choose a project template
    that matches our requirements. This template establishes the initial project framework,
    including default namespaces, assembly references, and compiler options, saving
    time and ensuring consistency across projects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item templates** focus on individual components within a project. These templates
    can range from simple file types (e.g., XML, HTML, CSS) to complex structures
    involving multiple files and resources. They are designed to quickly add predefined
    items to an existing project. We use item templates when adding new elements to
    our project via the **Add New Item** dialog box. This could include anything from
    a class file or interface to a pre-configured web page. Item templates enable
    the rapid inclusion of these elements without the need for manual configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of new templates involves working with the different files described
    in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files to** **be created** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source code files** : These are the initial coding files included with the
    template. For example, a C# class library template might start with a default
    **Class1.cs** file.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded resources** : This category includes images, configuration files,
    or other resources the project might require.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project files** : These encompass the solution and project files (such as
    **.sln** and **.csproj** for C# projects) that outline the project’s structure
    and dependencies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** **vstemplate** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This XML file is essential for defining the template. It contains metadata such
    as the template’s name, description, icon, and project type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It outlines the files to be included in the project and specifies any additional
    parameters or wizard data that need to be processed when the template is instantiated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressed into a** **ZIP file** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the template and its associated files are prepared, they are compressed
    into a **.zip** file. This file is placed in a specific folder where Visual Studio
    can recognize it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For project templates, the **.zip** file is placed in the **\Documents\Visual
    Studio <** **version>\Templates\ProjectTemplates** directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For item templates, it goes into the **\Documents\Visual Studio <** **version>\Templates\ItemTemplates**
    directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Project templates in Visual Studio provide a starting point for entire projects,
    offering a structured foundation based on the chosen template’s specifications.
    Conversely, item templates serve to expedite the addition of individual components
    or files within those projects, streamlining the development workflow by providing
    reusable pieces of code or resources. Understanding the distinction between these
    two types of templates can significantly enhance productivity and consistency
    in software development practices.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to create basic templates.
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic project template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover the more convenient way to build a project template.
    The process consists of building a skeleton project with the minimum we need inside
    to fit with our company requirements for example. After that, we can export the
    existing project as a template using Visual Studio’s Export Template Wizard, by
    using the Visual Studio top bar menu: **Project** | **Export Template…** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Export Template…](img/B22218_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Export Template…
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding action will open the **Export Template** **Wizard** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Export Template Wizard](img/B22218_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Export Template Wizard
  prefs: []
  type: TYPE_NORMAL
- en: First, we choose the type of template we want to export; either **Project template**
    or **Item template** .
  prefs: []
  type: TYPE_NORMAL
- en: Then, the tool allows us to define key details, such as the template’s name,
    description, icon, and preview images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Select Template Options](img/B22218_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Select Template Options
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion, the project is bundled into a **.zip** file and saved to a
    chosen output location. Additionally, we can opt to directly import the template
    into Visual Studio for immediate utilization. To access and use our newly created
    template, open the dialog box for creating a new project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Use the custom template](img/B22218_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Use the custom template
  prefs: []
  type: TYPE_NORMAL
- en: We can locate the template by searching for its name or browsing through the
    list. Keep in mind that filtering by language or project type may not be supported
    for custom templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how to custom templates.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing project templates for different workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to update a Visual Studio template either by using the Export
    Template Wizard or by manually adjusting the files within the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is to utilize the Export Template Wizard by initiating a new
    project within the project template we are interested in modifying and then following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the project, carry out the modifications we desire. This could encompass
    changing the output type, incorporating new files, or implementing other alterations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Export the modified template** : With our project adjusted, head to **Project**
    | **Export Template** to access the Export Template Wizard.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Conclude the export process** : Adhere to the wizard’s instructions to successfully
    export our modified template as a **.** **zip** file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other option is to apply the manual modification to a template by revising
    the **.vstemplate** by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify the template** : Locate the **.zip** archive corresponding to the
    template we intend to alter. Typically, this resides in **%USERPROFILE%\Documents\Visual**
    **Studio <version>\Templates\ProjectTemplates** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Unpack the archive** : Extract the contents of the template archive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Edit the files** : Undertake the necessary edits, additions, or deletions
    to the files within the template.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Revise the .vstemplate file** : Adjust the **.vstemplate** XML file to accurately
    represent the changes made.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Archive the changes** : Compress all the modified files back into a **.**
    **zip** archive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement the updated template** : Transfer the newly compressed **.zip**
    file to the original directory, replacing the outdated template files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customizing allows us to use some parameters and variables in existing templates.
    Let’s see in the next section how to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating template parameters and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to open an existing **.vstemplate** in order to customize
    it, in this section, we will explore how to leverage parameters to dynamically
    replace values within the template when it’s instantiated. Using parameters and
    variables in **.vstemplate** files with Visual Studio allows us to create dynamic
    templates that can adapt to different project names, namespaces, and other customizable
    aspects. This feature enhances the reusability and customization of our templates,
    making template creation a powerful tool for streamlining development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Template parameters** are placeholders within our template that get replaced
    with actual values when the template is instantiated. These parameters can represent
    various aspects of our project, such as the project name, namespace, or even custom-defined
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio provides a set of reserved template parameters that you can use
    directly in the templates. Here is the list of these reserved parameters, according
    to the Microsoft documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**clrversion** : The current version of the **common language** **runtime**
    ( **CLR** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ext_*** : The prefix added to any parameter to refer to variables of the
    parent template ( e.g., **ext_safeprojectname** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**guid[1-10]** : A GUID used to replace the project GUID in a project file.
    Up to 10 unique GUIDs can be specified ( e.g., **guid1** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**itemname** : The name of the file in which the parameter is being used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**machinename** : The current computer name ( e.g., **Computer01** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**projectname** : The name provided by the user when the project was created.
    This applies only to project templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**registeredorganization** : The registry key value from **HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\RegisteredOrganization**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rootnamespace** : The root namespace of the current project followed by the
    subfolder of the current item, with slashes replaced by periods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**defaultnamespace** : The root namespace of the current project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**safeitemname** : The same as **itemname** but with all unsafe characters
    and spaces replaced by underscore characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**safeitemrootname** : Same as **safeitemname** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**safeprojectname** : The name provided by the user when the project was created
    but with all unsafe characters and spaces removed. This applies only to project
    templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**targetframeworkversion** : The current version of the target . NET Framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**time** : The current time in a format based on Windows user settings (e.g.,
    DD/MM/YYYY 00:00:00).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**specifiedsolutionname** : The name of the solution. Behavior varies based
    on whether **Place solution and project in the same directory** or **Create solution
    directory** is checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**userdomain** : The current user domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**username** : The current username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**webnamespace** : The name of the current website, used in web form templates
    to guarantee unique class names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**year** : The current year in YYYY format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**solutiondirectory** : The directory of the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**destinationdirectory** : The path to the directory of the **.csproj** once
    created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These reserved parameters can be used to dynamically insert project-specific
    information into your templates. For instance, we can use the **$safeprojectname$**
    and **$year$** reserved parameters to dynamically generate the namespace and add
    a copyright notice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will create a new template manually. This example will
    focus on creating a C# class library project template that uses several reserved
    template parameters to dynamically generate namespaces, class names, and file
    names based on user input and system information. Let’s get started with the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the structure of our project template in a **.vstemplate** file.
    This file specifies what gets created when the template is instantiated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that it’s common practice to specify **TargetFileName** for every **ProjectItem**
    if you need them to have a specific name in the newly created project. The second
    **<ProjectItem>** ( **Properties\AssemblyInfo.cs** ) does not have **TargetFileName**
    . If you want to ensure that this file has the same name in the new project, this
    is fine. If you want to replace parameters, it should also have the **ReplaceParameters="true"**
    attribute (as it currently does).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a C# class file named **Class1.cs** that will be part of our template.
    We’ll use the **$safeprojectname$** and **$year$** reserved parameters to dynamically
    generate the namespace and add a copyright notice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also create an **AssemblyInfo.cs** file under a **Properties** folder
    within our template. This file will contain assembly metadata, and we’ll use the
    **$projectname$** , **$year$** , and **$username$** reserved parameters to customize
    the assembly title and copyright:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After creating these files, package them into a **.zip** file and place them
    in the Visual Studio templates directory or import them through Visual Studio’s
    template manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When creating a new project based on this template, Visual Studio will prompt
    us for the project name and location. As a result, the **Class1.cs** file will
    be filled with the provided values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Generate Class1](img/B22218_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Generate Class1
  prefs: []
  type: TYPE_NORMAL
- en: It will then replace the reserved parameters in the template files with the
    actual values, such as the safe project name, current year, and username. In this
    example, I choose **DummyTemplate** as the project name and the system takes the
    current year to set the **$** **year$** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the point when we create a project from our custom template, you might notice
    that we can use the filter combo box to filter them. Within the **<TemplateData>**
    section of our **.vstemplate** file, we can add the following elements to specify
    tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<LanguageTag>** : This specifies the programming languages used in the template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<PlatformTag>** : This indicates the target platforms (e.g., Windows, web)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<ProjectTypeTag>** : This describes the type of project (e.g., Class Library,
    Console Application)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each tag element should contain the name of the tag as its text content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When updating our template this way, we can observe the tags that appear on
    the description in the template list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Template list with tags](img/B22218_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Template list with tags
  prefs: []
  type: TYPE_NORMAL
- en: These tags allow us to leverage the three filters upon the list when we are
    looking for a template.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need more than one project, and we expect to be more productive
    with a ready-to-use solution with multi-library projects to scaffold a clean architecture,
    for example; let’s see in the next section how we can achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Extending project templates with advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go further by creating what we can call a solution
    template by combining multiple project templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a multi-project solution template in Visual Studio involves several
    steps, including creating individual project templates, combining them into a
    single solution template, and configuring the solution template to instantiate
    multiple projects upon creation. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create the templates that will be included in the solution template.
    For that, follow the instructions provided in the *Building a basic project template*
    section of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, prepare a directory structure for the solution template. This involves
    creating a folder for the solution template and copying the unzipped contents
    of each project template into this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Folder structure](img/B22218_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Folder structure
  prefs: []
  type: TYPE_NORMAL
- en: For this example, I created three project templates to scaffold the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create or modify a **.vstemplate** file in the root of the solution template
    directory. This file defines the structure of our solution template, including
    references to the individual project templates. In this file, we set the **Project
    Type** option to **ProjectGroup** to indicate that this template represents a
    collection of projects as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside **<TemplateContent>** , we use **<ProjectCollection>** instead of **<Project>**
    to define a collection of projects. Each child project is linked by a **<ProjectTemplateLink>**
    element that establishes the link, pointing to the relative path of the project
    template within the solution template directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once our solution template is configured, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We zip the contents of the solution template directory, including the modified
    **.vstemplate** file and the unzipped project templates
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We place the zipped file in the Visual Studio templates directory or import
    it through Visual Studio’s template manager
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, test the solution template by creating a new project from it in Visual
    Studio to ensure that it correctly generates a solution with all the desired projects,
    through **Solution Explorer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Solution architecture](img/B22218_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Solution architecture
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we initiate a solution with three projects as defined in the template.
    This process allows us to create a reusable template for a solution that includes
    multiple projects, streamlining the setup of new solutions based on predefined
    configurations, saving time and ensuring consistency across projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored the art of crafting custom project templates
    in Visual Studio 2022, a crucial skill for any developer aiming to standardize
    and accelerate their workflow. We began by understanding the fundamental structures
    that form the backbone of project templates. We then delved into customization,
    showing you how to adapt these templates to suit different workflows, ensuring
    they meet the specific needs of your projects. From there, we explored the integration
    of parameters, allowing you to add dynamic elements to your templates for greater
    flexibility. Finally, we expanded our focus to include advanced features, enabling
    you to create solution templates that can manage intricate, multi-project solutions
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we move forward, we’ll build on this knowledge by exploring another powerful
    aspect of Visual Studio: creating your own extensions. In the next chapter, we’ll
    dive into the world of custom tooling, where you’ll learn how to enhance your
    development environment even further by creating and deploying extensions tailored
    to your unique needs.'
  prefs: []
  type: TYPE_NORMAL
