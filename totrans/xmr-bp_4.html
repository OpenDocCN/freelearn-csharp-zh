<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0; Building an Audio Player Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4.  Building an Audio Player Application </h1></div></div></div><p>In this chapter, we move back to native Xamarin. We will integrate native audio functions for processing a sound file using the <code class="literal">AVFramework</code> in iOS with the <code class="literal">AVAudioSessions</code>, <code class="literal">AVAudioSettings</code>, and <code class="literal">AVAudioRecorder</code> objects. In Android you will use the <code class="literal">MediaPlayer</code> object from the <code class="literal">Android.Media</code> library.</p><p>Expected knowledge:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some knowledge of either iOS <code class="literal">AVAudioSessions</code>, <code class="literal">AVAudioSettings</code>, and <code class="literal">AVAudioRecorder</code>, or the Android <code class="literal">MediaPlayer</code> and <code class="literal">MediaRecorder</code> classes</li><li class="listitem" style="list-style-type: disc">NSLayoutConstraints</li></ul></div><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Project setup</li><li class="listitem" style="list-style-type: disc">Inversion of control with MVVMCross</li><li class="listitem" style="list-style-type: disc">View models with Xamarin native</li><li class="listitem" style="list-style-type: disc">Creating the bindings</li><li class="listitem" style="list-style-type: disc">NSLayoutContraints</li><li class="listitem" style="list-style-type: disc">MVVMCross setup inside the Portable Class Library</li><li class="listitem" style="list-style-type: disc">Setting up MVVMCross with iOS</li><li class="listitem" style="list-style-type: disc">Setting up MVVMCross with Android</li><li class="listitem" style="list-style-type: disc">The <code class="literal">SoundHandler</code> interface</li><li class="listitem" style="list-style-type: disc">Implementing the iOS <code class="literal">SoundHandler</code> using the <code class="literal">AVAudioPlayer</code> framework</li><li class="listitem" style="list-style-type: disc">The Mvx IoC container</li><li class="listitem" style="list-style-type: disc">The audio player</li><li class="listitem" style="list-style-type: disc">A cleaner code approach to <code class="literal">NSLayout</code></li><li class="listitem" style="list-style-type: disc">Creating <code class="literal">AudioPlayerPageViewModel</code></li><li class="listitem" style="list-style-type: disc">Implementing the Android <code class="literal">SoundHandler</code> using the <code class="literal">MediaPlayer</code> framework</li><li class="listitem" style="list-style-type: disc">XML and Mvx bindings</li></ul></div><div class="section" title="Solution setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Solution setup</h1></div></div></div><p>Now that we are back to Xamarin native, it's time to get your mind out of XAML and back
into native iOS and Android. We aren't going to spend much time on user interface design, but more on audio processing using the native frameworks.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip49"/>Tip</h3><p>If you are testing this application on your computer, the microphone will still work as it will be using your laptop's microphone.</p></div></div><p>As we have looked into cross-platform applications and code sharing, we are going to apply some of these principles to native development and setup an MVVM architecture. Let's begin by setting up three different projects, an iOS, Android, and PCL project:</p><div class="mediaobject"><img src="graphics/B05293_04_01.jpg" alt="Solution setup"/></div></div></div>
<div class="section" title="Inversion of control with MVVMCross"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Inversion of control with MVVMCross</h1></div></div></div><p>In the last two chapters, we looked at the IoC container and bootstrapping fundamentals; now it's time to use a different library for this principle with Xamarin native.</p><p>For all projects, we want to import the <code class="literal">MVVMCross</code> library:</p><div class="mediaobject"><img src="graphics/B05293_04_02.jpg" alt="Inversion of control with MVVMCross"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip50"/>Tip</h3><p>MVVMCross is available for <code class="literal">Xamarin.Forms</code>, <code class="literal">Xamarin.iOS</code>, <code class="literal">Xamarin.Android</code>, <code class="literal">Xamarin.Mac</code>, and Windows, so take your pick.</p></div></div><p>MVVMCross is set up quite differently to <code class="literal">AutoFac</code>, but the principles are the same.</p></div>
<div class="section" title="View-models with Xamarin native"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>View-models with Xamarin native</h1></div></div></div><p>After we add the libraries, let's start with the <code class="literal">AudioPlayer.Portable</code> project. Create a new folder called <code class="literal">ViewModels</code>, and add a new file called <code class="literal">MainPageViewModel.cs</code>. Let's start implementing our first view-model with MVVMCross:</p><pre class="programlisting">namespace AudioPlayer.Portable.ViewModels 
{ 
    using MvvmCross.Core.ViewModels; 
 
    public class MainPageViewModel : MvxViewModel 
    { 
        public MainPageViewModel() 
        { 
        } 
   } 
} 
</pre><p>When we built our <code class="literal">Xamarin.Forms</code> view-models, we created our own base view-model for handling property changes; using this library we can cut a few corners with base properties. <code class="literal">MvxViewModel</code> has a similar implementation with handling property changes; for our <code class="literal">MainPage</code>, we are going to develop the same first page as the last chapter, so let's start with the private properties:</p><pre class="programlisting">public class MainPageViewModel : MvxViewModel 
    { 
        #region Private Properties 
 
        private string _descriptionMessage = "Welcome to the Music Room"; 
 
        private string _audioPlayerTitle = "Audio Player"; 
 
        private string _exitTitle = "Exit"; 
 
        private MvxCommand _audioPlayerCommand; 
 
        private MvxCommand _exitCommand; 
 
        #endregion 
} 
</pre><p>Notice how we are using a different <code class="literal">Command</code> type, called <code class="literal">MvxCommand</code>? It works very much the same as the <code class="literal">Xamarin.Forms.Command</code>. Let's add the public properties and see how we handle property changes:</p><pre class="programlisting">#region Public Properties 
 
        public string DescriptionMessage 
        { 
            get  
            {  
                return _descriptionMessage;  
            }  
            set  
            {  
                if (value.Equals(_descriptionMessage)) 
                { 
                    _descriptionMessage = value; 
                    RaisePropertyChanged (() =&gt; DescriptionMessage); 
                } 
            } 
        } 
 
         
        public MvxCommand AudioPlayerCommand 
        { 
            get 
            { 
                return _audioPlayerCommand; 
            } 
 
            set 
            { 
                if (value.Equals(_audioPlayerCommand)) 
                { 
                    _audioPlayerCommand = value; 
                    RaisePropertyChanged (() =&gt; AudioPlayerCommand); 
                } 
            } 
        } 
 
         
        #endregion 
</pre><p>Easy, right?</p><p>It is exactly the same as the <code class="literal">set</code> function. We are checking whether the value has changed; if it has, then we set the <code class="literal">private</code> property and call <code class="literal">RaisePropertyChanged</code>. The only difference is we are passing an action into the function with the <code class="literal">public</code> property.</p><p>Now we can start building the user interface for the <code class="literal">MainPage</code>. This time, we are going to develop the iOS interface entirely off a <code class="literal">.cs</code> sheet. Add a new <code class="literal">.cs</code> file and call it <code class="literal">MainPage.cs</code>:</p><pre class="programlisting">     
[MvxViewFor(typeof(MainPageViewModel))] 
    public partial class MainPage : MvxViewController 
    { 
        public MainPage () 
        { 
        } 
    }  
</pre></div>
<div class="section" title="Creating the bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Creating the bindings</h1></div></div></div><p>Our first step is to build the user interface. We are going to add two <code class="literal">UIButtons</code>, <code class="literal">UILabel</code>, and <code class="literal">UIImageView</code> to the view controller:</p><pre class="programlisting">public override void ViewDidLoad () 
        { 
            base.ViewDidLoad (); 
 
            var mainView = new UIView ()  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                BackgroundColor = UIColor.White 
            }; 
 
            var imageView = new UIImageView() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                ContentMode = UIViewContentMode.ScaleAspectFit, 
                Image = new UIImage("audio.png") 
            }; 
 
            var descriptionLabel = new UILabel ()  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                TextAlignment = UITextAlignment.Center 
            }; 
                 
            var audioPlayerButton = new UIButton (UIButtonType.RoundedRect)  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false 
            }; 
 
            var exitButton = new UIButton (UIButtonType.RoundedRect)  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false 
            }; 
 
            View.Add (mainView); 
 
            // add buttons to the main view 
            mainView.Add (imageView); 
            mainView.Add (descriptionLabel); 
            mainView.Add (audioPlayerButton); 
            mainView.Add (exitButton); 
 
        } 
</pre><p>Now let's create the bindings for the user interface elements. Add the following to the bottom of the <code class="literal">ViewDidLoad</code> function:</p><pre class="programlisting">var set = this.CreateBindingSet&lt;MainPage, MainPageViewModel&gt; (); 
            set.Bind(this).For("Title").To(vm =&gt; vm.Title); 
            set.Bind(descriptionLabel).To(vm =&gt; vm.DescriptionMessage); 
            set.Bind(audioPlayerButton).For("Title").To(vm =&gt; vm.AudioPlayerTitle); 
            set.Bind(audioPlayerButton).To(vm =&gt; vm.AudioPlayerCommand); 
            set.Bind(exitButton).For("Title").To(vm =&gt; vm.ExitTitle); 
            set.Bind(exitButton).To(vm =&gt; vm.ExitCommand); 
            set.Apply (); 
</pre><p>When we create a binding context (<code class="literal">BindingSet</code>), we will set up all the bindings through the binding set. The first binding is with the <code class="literal">description</code> label. The object we are binding too must be a string (<code class="literal">DescriptionMessage</code> is our string object from the view-model).</p><p>Further on, we can specify the particular properties of a UI element using the <code class="literal">For</code> function, and in the parameter we specify the name of the property. In our case, we are specifying the <code class="literal">Title</code> property of <code class="literal">UIButton</code>, then calling the <code class="literal">To</code> function to bind our specified string object. We have also done this with <code class="literal">UIViewController</code>.</p><p>Finally, the last bindings we are using are <code class="literal">MvxCommands</code> from our view-model. We don't need to specify the property name for this; all we do is call the <code class="literal">To</code> function and specify the command in the view-model.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>In the <code class="literal">UIImageView</code> we created, we used an image called <code class="literal">audio.png</code>. You can put in any image you like, provided the name matches the one being loaded inside the <code class="literal">UIImage</code>. All resources for this example can be found via the GitHub link: <a class="ulink" href="https://github.com/flusharcade/chapter4-audioplayer">https://github.com/flusharcade/chapter4-audioplayer</a>.</p></div></div></div>
<div class="section" title="NSLayoutContraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>NSLayoutContraints</h1></div></div></div><p>Let's have a closer look at where we are initializing our UI elements. The <code class="literal">TranslatesAutoresizingMaskIntoConstraints</code> property is used to determine whether we are going to use <code class="literal">NSLayoutConstraints</code> to build our user interface. When we set it to <code class="literal">false</code>, it means we have to implement the layout constraints for this element.</p><p>Now we want to build the user interface using layout constraints. Let's add the following after the elements are added to <code class="literal">mainView</code>:</p><pre class="programlisting">View.AddConstraints (NSLayoutConstraint.FromVisualFormat("V:|[mainView]|", NSLayoutFormatOptions.DirectionLeftToRight, null, new NSDictionary("mainView", mainView))); 
            View.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|[mainView]|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("mainView", mainView))); 
 
            mainView.AddConstraints (NSLayoutConstraint.FromVisualFormat("V:|-80-[welcomeLabel]-[audioPlayerButton]-[exitButton]", NSLayoutFormatOptions.DirectionLeftToRight, null, new NSDictionary("welcomeLabel", welcomeLabel, "audioPlayerButton", audioPlayerButton, "exitButton", exitButton))); 
            mainView.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|-5-[welcomeLabel]-5-|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("welcomeLabel", welcomeLabel))); 
            mainView.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|-5-[audioPlayerButton]-5-|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("audioPlayerButton", audioPlayerButton))); 
            mainView.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|-5-[exitButton]-5-|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("exitButton", exitButton))); 
</pre><p>In the first two lines, we are adding constraints for the <code class="literal">UIView</code>. As the view contains only one <code class="literal">UIView</code>, we create two constraints for the vertical and horizontal properties of the <code class="literal">mainView</code> object. The <code class="literal">vertical</code> property is set to the following:</p><pre class="programlisting">"V:|[mainView]|" 
</pre><p>This means <code class="literal">mainView</code> will be stretched to the entire height of the containing view, and the same applies for the <code class="literal">horizontal</code> property:</p><pre class="programlisting">"H:|[mainView]|" 
</pre><p>The width of the <code class="literal">mainView</code> object will be stretched to the entire width of the containing view. These two text lines are known as <code class="literal">VisualFormat.NSLayoutContraints</code>, and they use text input as a visual representation, describing how views present in their parent views.</p><p>Looking at the other properties we pass into the <code class="literal">AddConstraints</code> function, we pass in <code class="literal">NSLayoutFormatOption</code> used for the view to abide by (that is, aligned left/top), then the metrics and <code class="literal">NSDictionary</code>, which will contain the UI elements involved in the constraint. You will notice some other constraints, such as these:</p><pre class="programlisting">"H:|-5-[audioPlayerButton]-5-|" 
</pre><p>These constraints include padding around the UI element:</p><pre class="programlisting">"H:|-[audioPlayerButton]-|" 
</pre><p>We can even simply place a dash character around the UI element, which will place a default padding of <code class="literal">8</code>.</p></div>
<div class="section" title="MVVMCross setup inside the PCL"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>MVVMCross setup inside the PCL</h1></div></div></div><p>Further into the MVVMCross framework, let's begin by building the <code class="literal">MvxApplication</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>This is not the same as the application class inside a <code class="literal">Xamarin.Forms</code> application.</p></div></div><pre class="programlisting">public class App : MvxApplication 
    { 
        public override void Initialize() 
        { 
            CreatableTypes() 
                .EndingWith("Service") 
                .AsInterfaces() 
                .RegisterAsLazySingleton(); 
        } 
    } 
</pre><p>Pay attention to the <code class="literal">CreatableTypes</code> function being called; the function uses reflection to find all classes in the core assembly that are <code class="literal">Creatable</code>, meaning they have a public constructor and they are not abstract. Then, following this function, only register the class interfaces with their names ending in <code class="literal">Service</code> as lazy singletons.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>The lazy singleton ensures that if a class implements <code class="literal">IOne</code> and <code class="literal">ITwo</code>, then the same instance will be returned when resolving both <code class="literal">IOne</code> and <code class="literal">ITwo</code>.</p></div></div><p>There is one more part to add to the <code class="literal">Application</code> class. We must register the starting point, so add the following line under the <code class="literal">RegisterAsLazySingleton</code> function:</p><pre class="programlisting">RegisterAppStart&lt;MainPageViewModel&gt;(); 
</pre></div>
<div class="section" title="Setting up MVVMCross with iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Setting up MVVMCross with iOS</h1></div></div></div><p>Now we move over to the iOS project. For each platform, we must implement a <code class="literal">Setup</code> class that will be used to instantiate the <code class="literal">MvxApplication</code> class. Add a new class called <code class="literal">IosSetup</code> and implement the following:</p><pre class="programlisting">public class IosSetup : MvxIosSetup 
    { 
        public IosSetup(MvxApplicationDelegate applicationDelegate, UIWindow window) : base(applicationDelegate, window) 
        { 
        } 
 
        protected override IMvxApplication CreateApp() 
        { 
            return new App(); 
        } 
 
        protected override IMvxTrace CreateDebugTrace() 
        { 
            return new DebugTrace(); 
        } 
    } 
</pre><p>Firstly, we must include a constructor that takes in an <code class="literal">MvxApplicationDelegate</code> and <code class="literal">UIWindow</code>; these will be passed into the base on instantiation. We also have two functions that are overriden as part of the <code class="literal">MvxIosSetup</code> object.</p><p>Start with the <code class="literal">CreateApp</code> function. All we are doing here is instantiating the <code class="literal">MvxApplication</code> class that we implemented previously. We will break this down into more detail when we implement the <code class="literal">AppDelegate</code> class.</p><p>We must also override the <code class="literal">CreateDebugTrace</code> functions, which will instantiate a new <code class="literal">DebugTrace</code> object. Firstly, let's create a new folder called <code class="literal">Logging</code> inside our PCL project, add a new file called <code class="literal">DebugTrace.cs</code>, and implement the following:</p><pre class="programlisting">public class DebugTrace : IMvxTrace 
    { 
        public void Trace(MvxTraceLevel level, string tag, Func&lt;string&gt; message) 
        { 
            Debug.WriteLine(tag + ":" + level + ":" + message()); 
        } 
 
        public void Trace(MvxTraceLevel level, string tag, string message) 
        { 
            Debug.WriteLine(tag + ":" + level + ":" + message); 
        } 
 
        public void Trace(MvxTraceLevel level, string tag, string message, params object[] args) 
        { 
            try 
            { 
                Debug.WriteLine(string.Format(tag + ":" + level + ":" + message, args)); 
            } 
            catch (FormatException) 
            { 
                Trace(MvxTraceLevel.Error, tag, "Exception during trace of {0} {1}", level, message); 
            } 
        } 
    } 
</pre><p>As part of the <code class="literal">IMvxTrace</code> interface, we must implement all these functions. The functions are not complicated; we are simply catching errors and outputting text to the console when these functions are called. All the functions called via the <code class="literal">DebugTrace</code> object are routed via a singleton object. We will be sharing this object between the two platform projects.</p><p>Great! Now that we have completed all our MVVMCross requirements for iOS, let's piece it all together via the <code class="literal">AppDelegate</code> class:</p><pre class="programlisting">public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions) 
        { 
            _window = new UIWindow (UIScreen.MainScreen.Bounds); 
 
            var setup = new IosSetup(this, window); 
            setup.Initialize(); 
 
            var startup = Mvx.Resolve&lt;IMvxAppStart&gt;(); 
            startup.Start(); 
 
            _window.MakeKeyAndVisible (); 
 
            return true; 
        } 
</pre><p>What exactly are we doing in the <code class="literal">FinishedLaunching</code> function?</p><p>Firstly, we instantiate our <code class="literal">UIWindow</code> to the size of the main screen bounds. Then we instantiate the <code class="literal">IosSetup</code> class by passing in the new <code class="literal">UIWindow</code> object, and call the <code class="literal">Initialize</code> function we implemented in our <code class="literal">MvxApplication</code> in the PCL. Then, we use the Mvx IoC container to resolve the <code class="literal">IMvxAppStart</code> interface and call <code class="literal">Start</code> to begin the application at our <code class="literal">MainPageViewModel</code>.</p><p>Excellent! We have now set up MVVMCross with our iOS project; let's go ahead and do the same for the Android project.</p></div>
<div class="section" title="Setting up MVVMCross with Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Setting up MVVMCross with Android</h1></div></div></div><p>As we already completed the <code class="literal">PCL</code> setup for <code class="literal">MVVMCross</code>, we only need to create the setup object, which will inherit the <code class="literal">MvxAndroidSetup</code> class.</p><p>Create a new file called <code class="literal">AndroidSetup.cs</code> and implement the following:</p><pre class="programlisting">public class AndroidSetup : MvxAndroidSetup 
    { 
        public AndroidSetup(Context context) :base(context) 
        { 
        } 
 
        protected override IMvxApplication CreateApp() 
        { 
            return new App(); 
        } 
 
        protected override IMvxTrace CreateDebugTrace() 
        { 
            return new DebugTrace(); 
        } 
    } 
</pre><p>This is very much the same as the iOS setup, but in the constructor we must pass in the Android context.</p><p>Now for the final setup on Android. We don't normally have an application to override. Instead, MVVMCross by default provides a splash screen. Delete the <code class="literal">MainActivity</code> class that is automatically created, and replace it with a new activity called <code class="literal">SplashScreenActivity</code>:</p><pre class="programlisting">[Activity(Label = "AudioPlayer.Droid" 
        , MainLauncher = true 
        , Icon = "@drawable/icon" 
        , Theme = "@style/Theme.Splash" 
        , NoHistory = true 
        , ScreenOrientation = ScreenOrientation.Portrait)] 
    public class SplashScreenActivity : MvxSplashScreenActivity 
    { 
        public SplashScreenActivity(): base(Resource.Layout.SplashScreen) 
        { 
        } 
    } 
</pre><p>We don't need to add anything into our constructor, but we must add the <code class="literal">MainLauncher = true</code> flag to the attribute to ensure this is the first thing created when the platform starts. We must also create the new XML view for the splash screen activity. For this example, we are going to create a simple screen with a <code class="literal">TextView</code>:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>Try creating a splash screen that will display an image to give the application branding.</p></div></div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
    android:orientation="vertical" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent"&gt; 
    &lt;TextView   
    android:layout_width="fill_parent"  
    android:layout_height="wrap_content"  
    android:text="Loading...."/&gt; 
&lt;/LinearLayout&gt; 
</pre><p>That's everything; lets test run both platforms and we should now have the following screen:</p><div class="mediaobject"><img src="graphics/B05293_04_03.jpg" alt="Setting up MVVMCross with Android"/></div></div>
<div class="section" title="The SoundHandler interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>The SoundHandler interface</h1></div></div></div><p>One issue with playing audio across multiple platforms is we can't share much code when processing audio. We must create an interface and register implementations through an IoC container.</p><p>Our next step is to create the <code class="literal">ISoundHandler</code> interface. In the <code class="literal">AudioPlayer.Portable</code> project, add in a new folder called <code class="literal">Sound</code>. In this folder, add a new file called <code class="literal">ISoundHandler.cs</code> and implement the following:</p><pre class="programlisting">public interface ISoundHandler 
    { 
        bool IsPlaying { get; set; } 
 
        void Load(); 
 
        void PlayPause(); 
 
        void Stop(); 
 
        double Duration(); 
 
        void SetPosition(double value); 
 
        double CurrentPosition(); 
 
        void Forward(); 
 
        void Rewind(); 
    } 
</pre><p>Our interface will describe all the functions we will be using to process our audio streams via the <code class="literal">AudioPlayerPage</code> interface.</p><p>Now let's go ahead and start with the iOS implementation.</p></div>
<div class="section" title="Implementing the iOS SoundHandler using the AVAudioPlayer framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Implementing the iOS SoundHandler using the AVAudioPlayer framework</h1></div></div></div><p>The <code class="literal">AVAudioPlayer</code> class is the framework we will be using to play and control our audio streams in iOS, so let's begin by adding a new folder called <code class="literal">Sound</code> to the iOS project. We then want to create a new file called <code class="literal">SoundHandler.cs</code> that will inherit the <code class="literal">ISoundHandler</code> interface:</p><pre class="programlisting">public class SoundHandler : ISoundHandler 
    { 
         
    } 
</pre><p>Now let's create a private <code class="literal">AVAudioPlayer</code> object and add our public <code class="literal">IsPlaying</code>, which will hold the playing status of the audio player:</p><pre class="programlisting">private AVAudioPlayer _audioPlayer; 
 
public bool IsPlaying { get; set; } 
</pre><p>Then we add in the functions of the interface. In each function, we will be using the audio player object to do all our audio processing:</p><pre class="programlisting">public void Load() 
        { 
            _audioPlayer = AVAudioPlayer.FromUrl(NSUrl.FromFilename("Moby - The Only Thing.mp3")); 
        } 
 
public void PlayPause() 
        { 
            if (_audioPlayer != null) 
            { 
                if (IsPlaying) 
                { 
                    _audioPlayer.Stop(); 
                } 
                else 
                { 
                    _audioPlayer.Play(); 
                } 
 
                IsPlaying = !IsPlaying; 
            } 
        } 
</pre><p>The first function will load the file from the <code class="literal">Resources</code> folder. In this example, we are going to be loading in a Moby song (personally one of my favorites).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note55"/>Note</h3><p>You can add in any audio file, provided the name matches the filename being loaded via the <code class="literal">NSURL</code> object. If you want to use the same file as this one, visit the GitHub link stated previously.</p></div></div><p>The second function will control starting and stopping the audio. If we click the play button first, it will play and set the status of <code class="literal">IsPlaying</code> to <code class="literal">true</code>. Then if we click the play button again, it will stop the audio and set the <code class="literal">IsPlaying</code> to <code class="literal">false</code>.</p><p>Now for the rest of the implementation:</p><pre class="programlisting">public void Stop() 
        { 
            if (_audioPlayer != null) 
            { 
                _audioPlayer.Stop(); 
            } 
        } 
 
        public double Duration() 
        { 
            if (_audioPlayer != null) 
            { 
                return _audioPlayer.Duration; 
            } 
 
            return 0; 
        } 
 
        public void SetPosition(double value) 
        { 
            if (_audioPlayer != null) 
            { 
                _audioPlayer.CurrentTime = value; 
            } 
        } 
 
        public double CurrentPosition() 
        { 
            if (_audioPlayer != null) 
            { 
                return _audioPlayer.CurrentTime; 
            } 
 
            return 0; 
        } 
 
        public void Forward() 
        { 
            if (_audioPlayer != null) 
            { 
                IsPlaying = false; 
 
                _audioPlayer.Stop(); 
                _audioPlayer.CurrentTime = audioPlayer.Duration; 
            } 
        } 
 
        public void Rewind() 
        { 
            if (_audioPlayer != null) 
            { 
                IsPlaying = false; 
 
                _audioPlayer.Stop(); 
                _audioPlayer.CurrentTime = 0; 
            } 
        } 
</pre><p>All of this is straightforward: our <code class="literal">Stop</code> function will stop the audio. Our <code class="literal">Rewind</code> function will stop the audio and set the current time to 0 (meaning the beginning of the audio stream). Our <code class="literal">Forward</code> function will stop the audio and move the current time to the end of the stream. The last two functions will set the current position of the audio stream to the double value passed in. This will be used with our progress slider; when the slider position changes, the value will be passed into this function to update the position of the audio stream. Finally, the last function will retrieve the current time value so we can update our user interface with this detail.</p><p>Great! Now that we have our sound handler implemented for iOS, we want to register this through the IoC container.</p></div>
<div class="section" title="The Mvx IoC container"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>The Mvx IoC container</h1></div></div></div><p>MVVMCross comes with its very own IoC container. It works exactly like our previous example with Autofac, but we are not going to be using modules. Let's begin by registering our sound handler implementation; open our <code class="literal">AppDelegate.cs</code> file and create a new private function called <code class="literal">setupIoC</code>:</p><pre class="programlisting">private void SetupIoC() 
{ 
     Mvx.RegisterType&lt;ISoundHandler, SoundHandler&gt;(); 
} 
</pre><p>We must also register our view-models so we can retrieve registered interfaces within our view-model's constructor. Let's add a new folder called <code class="literal">IoC</code> inside our <code class="literal">AudioPlayer.Portable</code> project. Add a new file called <code class="literal">PortableMvxIoCRegistrations.cs</code> and implement the following:</p><pre class="programlisting">public static class PortableMvxIoCRegistrations 
    { 
        public static void InitIoC() 
        { 
            Mvx.IocConstruct&lt;MainPageViewModel&gt;(); 
            Mvx.IocConstruct&lt;AudioPlayerPageViewModel&gt;(); 
        } 
    } 
</pre><p>Now we must call the static function <code class="literal">InitIoC</code> from the <code class="literal">AppDelegate</code> function <code class="literal">SetupIoC</code>:</p><pre class="programlisting">private void SetupIoC() 
        { 
            Mvx.RegisterType&lt;ISoundHandler, SoundHandler&gt;(); 
            PortableMvxIoCRegistrations.InitIoC(); 
        } 
</pre><p>Now that we have everything we require registered inside the IoC container, let's begin building the <code class="literal">AudioPlayerPage</code>.</p></div>
<div class="section" title="The audio player"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>The audio player</h1></div></div></div><p>Our next step in this project is to build the user interface for controlling the audio. Add a new file called <code class="literal">AudioPlayerPage.cs</code> inside the <code class="literal">Views</code> folder; don't forget to add the attribute above the class declaration to register the view-model for the MVVMCross framework:</p><pre class="programlisting">[MvxViewFor(typeof(AudioPlayerPageViewModel))] 
public class AudioPlayerPage : MvxViewController 
{ 
   private UIButton playButton; 
 
        private UISlider _progressSlider; 
 
        private bool _playing; 
 
        private AudioPlayerPageViewModel _model; 
} 
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note56"/>Note</h3><p>We have declared some local scope variables that need to be used across multiple functions; you will see how these will be used later.</p></div></div><p>Now let's create the UI elements via the <code class="literal">ViewDidLoad</code> function:</p><pre class="programlisting">public override void ViewDidLoad() 
        { 
            base.ViewDidLoad(); 
 
            var mainView = new UIView() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                BackgroundColor = UIColor.White 
            }; 
 
            var buttonView = new UIView() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                BackgroundColor = UIColor.Clear 
            }; 
 
            var imageView = new UIImageView() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                ContentMode = UIViewContentMode.ScaleAspectFit, 
                Image = new UIImage("moby.png") 
            }; 
 
            var descriptionLabel = new UILabel() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                TextAlignment = UITextAlignment.Center 
            }; 
 
            var startLabel = new UILabel() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                TextAlignment = UITextAlignment.Left, 
            }; 
 
            var endLabel = new UILabel() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                TextAlignment = UITextAlignment.Right, 
            }; 
 
            _progressSlider = new UISlider() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                MinValue = 0 
            }; 
 
            _playButton = new UIButton(UIButtonType.Custom) 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
            var rewindButton = new UIButton(UIButtonType.Custom) 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
            var fastForwardButton = new UIButton(UIButtonType.Custom) 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
        } 
</pre><p>We have labels for displaying the current track name, the start time, and the end time. We also have our buttons for controlling the audio stream (play, pause, rewind, and forward). Finally, we have our progress slider for animating the current time of the audio; we are also going to be using this to change the position of the audio.</p><p>We now want to add the button events for controlling some UI changes on the button images; add the event handler assignation under the declaration of the play button:</p><pre class="programlisting">_playButton.TouchUpInside += HandlePlayButton; 
            _playButton.SetImage(UIImage.FromFile("play.png"), UIControlState.Normal); 
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note57"/>Note</h3><p>The <code class="literal">TouchUpInside</code> event will fire every time we click the button.</p></div></div><p>Then create the function for the event handler:</p><pre class="programlisting">        private void HandlePlayButton(object sender, EventArgs e) 
        { 
            _playing = !_playing; 
            _playButton.SetImage(UIImage.FromFile(playing ? "pause.png" : "play.png"), UIControlState.Normal); 
        } 
</pre><p>Every time we click the play button, it will move the image back and forth between the play and pause icon. Now let's add the rewind and forward button handlers; add the following lines under each UI element declaration:</p><pre class="programlisting">rewindButton.TouchUpInside += HandleRewindForwardButton; 
            rewindButton.SetImage(UIImage.FromFile("rewind.png"), UIControlState.Normal); 
fastForwardButton.TouchUpInside += HandleRewindForwardButton; 
            fastForwardButton.SetImage(UIImage.FromFile("fast_forward.png"), UIControlState.Normal); 
</pre><p>Now we add the event handler function:</p><pre class="programlisting">        private void HandleRewindForwardButton(object sender, EventArgs e) 
        { 
            _playing = false; 
            _playButton.SetImage(UIImage.FromFile("play.png"), UIControlState.Normal); 
        } 
</pre><p>This is similar to the play button handler, but this time we always set the playing status to false, and set the play button image to the play icon.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/>Note</h3><p>For all audio images, please visit the GitHub link given previously.</p></div></div></div>
<div class="section" title="A cleaner code approach to NSLayout"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>A cleaner code approach to NSLayout</h1></div></div></div><p>On our previous screen, we built a very simple user interface using <code class="literal">NSLayoutContraints</code>.</p><p>Would you agree that the code looked quite clunky?</p><p>With our <code class="literal">AudioPlayerPage</code>, we are going to use a cleaner approach to coding the <code class="literal">NSLayoutConstraints</code>. Firstly, create a new folder called <code class="literal">Extras</code>, and add a new file called <code class="literal">DictionaryViews.cs</code>:</p><div class="mediaobject"><img src="graphics/B05293_04_04.jpg" alt="A cleaner code approach to NSLayout"/></div><p>This class is going to inherit the <code class="literal">IEnumerable</code> interface in order to create an <code class="literal">NSDictionary</code>; part of this interface is we must specify the <code class="literal">GetEnumerator</code> function. It will pull this from the <code class="literal">NSDictionary</code>; we also have our <code class="literal">Add</code> function, which simply adds a new <code class="literal">UIView</code> to the dictionary. Then we have the static implicit operator which will return the object as an <code class="literal">NSDictionary</code> (this is used so we can directly pass the object as an <code class="literal">NSDictionary</code> to the <code class="literal">FromVisualLayout</code> function):</p><pre class="programlisting">public class DictionaryViews : IEnumerable 
    { 
        private readonly NSMutableDictionary _nsDictionary; 
 
        public DictionaryViews() 
        { 
            _nsDictionary = new NSMutableDictionary(); 
        } 
 
        public void Add(string name, UIView view) 
        { 
            _nsDictionary.Add(new NSString(name), view); 
        } 
 
        public static implicit operator NSDictionary(DictionaryViews us) 
        { 
            return us.ToNSDictionary(); 
        } 
 
        public NSDictionary ToNSDictionary() 
        { 
            return _nsDictionary; 
        } 
 
        public IEnumerator GetEnumerator() 
        { 
            return ((IEnumerable)_nsDictionary).GetEnumerator(); 
        } 
    } 
</pre><p>Now let's go ahead and create one of these inside our <code class="literal">AudioPlayerPage</code>; paste the following under the declaration of the fast forward button:</p><pre class="programlisting">            var views = new DictionaryViews() 
            { 
                {"mainView", mainView}, 
                {"buttonView", buttonView}, 
                {"imageView", imageView}, 
                {"descriptionLabel", descriptionLabel}, 
                {"startLabel", startLabel}, 
                {"endLabel", endLabel}, 
                {"progressSlider", progressSlider}, 
                {"playButton", playButton}, 
                {"rewindButton", rewindButton}, 
                {"fastForwardButton", fastForwardButton} 
            }; 
</pre><p>Great! We now have a new <code class="literal">IEnumerable</code>/<code class="literal">NSDictionary</code> with all the required views to be used through the entire interface. We can directly pass this object into the <code class="literal">NSLayoutConstraint</code> function <code class="literal">FromVisualFormat</code> so we don't need to repeat the declaration of new dictionaries when we create each <code class="literal">NSLayoutContraint</code>. Now add all the UI elements to the correct parent views:</p><pre class="programlisting">View.Add(mainView); 
 
            mainView.Add(imageView); 
            mainView.Add(descriptionLabel); 
            mainView.Add(buttonView); 
            mainView.Add(startLabel); 
            mainView.Add(endLabel); 
            mainView.Add(progressSlider); 
 
            buttonView.Add(playButton); 
            buttonView.Add(rewindButton); 
            buttonView.Add(fastForwardButton); 
</pre><p>Then let's build all the <code class="literal">NSLayoutConstraints</code>; our first is the <code class="literal">UIViewController'sUIView</code>:</p><pre class="programlisting">View.AddConstraints( 
                NSLayoutConstraint.FromVisualFormat("V:|[mainView]|", NSLayoutFormatOptions.DirectionLeftToRight, null, views) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|[mainView]|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .ToArray()); 
</pre><p>We have our new approach, using the <code class="literal">System.Linq</code> function <code class="literal">Concat</code> to combine all the <code class="literal">NSLayoutContraints</code> required for the view. We only have to call the <code class="literal">AddConstraints</code> function once, and pass in one array of all the required constraints for that parent view.</p><p>Let's add our constraint for <code class="literal">mainView</code> and <code class="literal">buttonView</code>:</p><pre class="programlisting">mainView.AddConstraints( 
                NSLayoutConstraint.FromVisualFormat("V:|-100-[imageView(200)]-[descriptionLabel(30)]-[buttonView(50)]-[startLabel(30)]-[progressSlider]", NSLayoutFormatOptions.DirectionLeftToRight, null, views) 
                .Concat(NSLayoutConstraint.FromVisualFormat("V:|-100-[imageView(200)]-[descriptionLabel(30)]-[buttonView(50)]-[endLabel(30)]-[progressSlider]", NSLayoutFormatOptions.DirectionLeftToRight, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-20-[progressSlider]-20-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-25-[startLabel(70)]", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:[endLabel(70)]-25-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-5-[descriptionLabel]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-5-[imageView]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(new[] { NSLayoutConstraint.Create(buttonView, NSLayoutAttribute.CenterX, NSLayoutRelation.Equal, mainView, NSLayoutAttribute.CenterX, 1, 0) }) 
                .ToArray()); 
 
            buttonView.AddConstraints( 
                NSLayoutConstraint.FromVisualFormat("V:|-5-[rewindButton]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views) 
                .Concat(NSLayoutConstraint.FromVisualFormat("V:|-5-[playButton]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("V:|-5-[fastForwardButton]-5-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .Concat(NSLayoutConstraint.FromVisualFormat("H:|-20-[rewindButton]-[playButton(100)]-[fastForwardButton]-20-|", NSLayoutFormatOptions.AlignAllTop, null, views)) 
                .ToArray()); 
</pre><p>This is exactly the same approach, but it looks much nicer and it reduces the number of times we call <code class="literal">AddConstraints</code>. The view only needs to add all the constraints once, and lay out the elements once, so it is much more efficient.</p><p>Our final step in building the user interface is to set up the MVVMCross bindings; we use the same approach as the <code class="literal">MainPage</code>. Let's create a new binding set between the <code class="literal">AudioPlayerPage</code> and the <code class="literal">AudioPlayerPageViewModel</code>:</p><pre class="programlisting">            var set = CreateBindingSet&lt;AudioPlayerPage, AudioPlayerPageViewModel&gt;(); 
            set.Apply(); 
</pre><p>Before we get into creating our bindings, let's first build our <code class="literal">AudioPlayerPageViewModel</code> for the <code class="literal">AudioPlayer.Portable</code> project.</p></div>
<div class="section" title="Creating AudioPlayerPageViewModel"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Creating AudioPlayerPageViewModel</h1></div></div></div><p>Our <code class="literal">AudioPlayerPageViewModel</code> must include our <code class="literal">ISoundHandler</code> interface. We are going to be controlling the audio from this view-model, so our buttons can initiate the required events on the sound handler. Let's begin by making a new file inside the <code class="literal">ViewModels</code> folder called <code class="literal">AudioPlayerPageViewModel.cs</code>, and implementing the private properties to begin with:</p><pre class="programlisting">public class AudioPlayerPageViewModel : MvxViewModel 
    { 
        #region Private Properties 
 
        private readonly ISoundHandler _soundHandler; 
 
        private string _title = "Audio Player"; 
 
        private string _descriptionMessage = "Moby - The Only Thing"; 
 
        private MvxCommand _playPauseCommand; 
 
        private MvxCommand _forwardCommand; 
 
        private MvxCommand _rewindCommand; 
 
        private float _audioPosition; 
 
        private double _currentTime; 
 
        private double _endTime; 
 
        private bool _updating; 
 
        #endregion 
</pre><p>Then we must add the <code class="literal">public</code> properties.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note59"/>Note</h3><p>We are only going to show two of the <code class="literal">public</code> properties as examples, as the code is repetitive.</p></div></div><pre class="programlisting">public MvxCommand PlayPauseCommand 
        { 
            get 
            { 
                return _playPauseCommand; 
            } 
 
            set 
            { 
                if (!value.Equals(_playPauseCommand)) 
                { 
                    _playPauseCommand = value; 
                    RaisePropertyChanged (() =&gt; PlayPauseCommand); 
                } 
            } 
        } 
 
        public MvxCommand RewindCommand 
        { 
            get 
            { 
                return _rewindCommand; 
            } 
 
            set 
            { 
                if (!value.Equals(_rewindCommand)) 
                { 
                    _rewindCommand = value; 
                    RaisePropertyChanged(() =&gt; RewindCommand); 
                } 
            } 
        } 
</pre><p>We also need to add these two public variables, which are going to take both the <code class="literal">CurrentTime</code> and <code class="literal">EndTime</code> double values and create a formatted string from a <code class="literal">TimeSpan</code> value.</p><p>Notice how we are also calling <code class="literal">RaisePropertyChanged</code> on the string inside the double setter? Every time we get a new current time value, the formatted string needs to update as well:</p><pre class="programlisting">public string CurrentTimeStr 
        { 
            get 
            { 
                return TimeSpan.FromSeconds(CurrentTime).ToString("mm\\:ss"); 
            } 
        } 
 
        public double CurrentTime 
        { 
            get 
            { 
                return _currentTime; 
            } 
 
            set 
            { 
                if (!value.Equals(_currentTime)) 
                { 
                    _currentTime = value; 
                    RaisePropertyChanged(() =&gt; CurrentTime); 
                    // everytime we change the current time, the time span values must also update 
                    RaisePropertyChanged(() =&gt; CurrentTimeStr); 
                } 
            } 
        } 
 
        public string EndTimeStr 
        { 
            get 
            { 
                return TimeSpan.FromSeconds(EndTime).ToString("mm\\:ss"); 
            } 
        } 
 
 
        public double EndTime 
        { 
            get 
            { 
                return _endTime; 
            } 
 
            set 
            { 
                if (!value.Equals(_endTime)) 
                { 
                    _endTime = value; 
                    RaisePropertyChanged(() =&gt; EndTime); 
                    RaisePropertyChanged(() =&gt; EndTimeStr); 
                } 
            } 
        } 
</pre><p>Now for our constructor function:</p><pre class="programlisting">#region Constructors 
 
        public AudioPlayerPageViewModel (ISoundHandler soundHandler) 
        { 
            _soundHandler = soundHandler; 
 
            // load sound file 
            _soundHandler.Load(); 
 
            EndTime = _soundHandler.Duration(); 
        } 
 
        #endregion 
</pre><p>Here we are pulling out the <code class="literal">ISoundHandler</code> implementation from the IoC container, as we will be registering this view-model inside the IoC container.</p><p>Our next step is to add two new functions to the view-model, <code class="literal">Load</code> and <code class="literal">Dispose</code>. These two functions will be called when the <code class="literal">AudioPlayerPage</code> is shown, and when it disappears. They will also be used when the audio stream is started and stopped.</p><p>Let's first add the <code class="literal">Load</code> function:</p><pre class="programlisting">public void Load() 
        { 
            // make sure we only start the loop once 
            if (!_updating) 
            { 
                _updating = true; 
 
                // we are going to post a regular update to the UI with the current time 
                var context = SynchronizationContext.Current; 
 
                Task.Run(async () =&gt; 
                { 
                    while (_updating) 
                    { 
                        await Task.Delay(1000); 
 
                        context.Post(unused =&gt; 
                        { 
                            var current = _soundHandler.CurrentPosition(); ; 
 
                            if (current &gt; 0) 
                            { 
                               CurrentTime = current; 
                            } 
 
                        }, null); 
                    } 
                }); 
            } 
        } 
</pre><p>The <code class="literal">Load</code> function will be called when the page is shown, and when the audio stream starts. The function uses the <code class="literal">Task</code> framework to run a repeating loop in the background, so every second we will retrieve the current time of the audio stream from the <code class="literal">ISoundHandler</code> interface. We propagate the updates to the current time label on the <code class="literal">AudioPlayerPage</code> interface.</p><p>Notice how we are using the <code class="literal">SynchronisationContext.Current</code> variable?</p><p>This is used for threading purposes so we make sure that we set our <code class="literal">CurrentTime</code> variable on the main UI thread. Since this loop is running on a separate thread, if we made changes to this variable on a separate thread, it will break the application because you are trying to make UI changes off the main UI thread.</p><p>Now for the <code class="literal">Dispose</code> function; this will be called every time the <code class="literal">AudioPlayerPage</code> disappears and when the audio stream is stopped (we don't need to make updates to the UI when the audio stream is not playing). This ensures we stop the background loop when the page is not visible:</p><pre class="programlisting">public void Dispose() 
        { 
            _updating = false; 
            _soundHandler.Stop(); 
        } 
</pre><p>The private variable <code class="literal">_updating</code> is used to control the status of whether the background loop is running, so we make sure that only one background loop is running at any one time.</p><p>Now let's initiate the audio commands:</p><pre class="programlisting">_playPauseCommand = new MvxCommand(() =&gt; 
            { 
                // start/stop UI updates if the audio is not playing 
                if (soundHandler.IsPlaying) 
                { 
                    Dispose(); 
                } 
                else 
                { 
                    Load(); 
                } 
 
                _soundHandler.PlayPause(); 
            }); 
 
            _rewindCommand = new MvxCommand(() =&gt; 
            { 
                // set current time to the beginning 
                CurrentTime = 0; 
                _soundHandler.Rewind(); 
                Dispose(); 
            }); 
 
            _forwardCommand = new MvxCommand(() =&gt; 
            { 
                // set current time to the end 
                CurrentTime = _soundHandler.Duration(); 
                _soundHandler.Forward(); 
                Dispose(); 
            }); 
</pre><p>Looking more closely at these commands, using <code class="literal">PlayPauseCommand</code> we will call <code class="literal">Load</code> or <code class="literal">Dispose</code> based on the playing status of the audio stream, and it will also call <code class="literal">PlayPause</code> on the <code class="literal">ISoundHandler</code> interface, which controls the audio stream. The <code class="literal">rewindCommand</code> property will set the current time to 0, set the current time on the audio stream to 0, and stop the background loop. The <code class="literal">forwardCommand</code> property will set the current time to the end duration of the audio stream (which it will retrieve from the <code class="literal">ISoundHandler</code> interface), set the current time on the audio stream to the end duration, and stop the background loop.</p><p>Finally, we have to create a <code class="literal">public</code> function to set the current time of the audio stream. This will be used by our progress slider every time the value changes, this function will be called:</p><pre class="programlisting">        public void UpdateAudioPosition(double value) 
        { 
            _soundHandler.SetPosition(value); 
        } 
</pre><p>Now revert back to the <code class="literal">AudioPlayerPage</code> and add the final additions.</p><p>Since we declared a local variable before for the view-model that is bound to the view, we want to pull this out of the data context of the <code class="literal">UIView</code>:</p><pre class="programlisting">_model = (AudioPlayerPageViewModel)DataContext; 
</pre><p>Our local variable has the bounded view-model. We need to call some public methods on the view-model from our view. We must add in our event handler for the <code class="literal">ValueChanged</code> event on the progress slider. Add the following under the declaration of the progress slider:</p><pre class="programlisting">progressSlider.ValueChanged += ProgressSliderValueChanged; 
</pre><p>Then create the event handler function:</p><pre class="programlisting">        private void ProgressSliderValueChanged(object sender, EventArgs e) 
        { 
            _model.UpdateAudioPosition(_progressSlider.Value); 
        } 
</pre><p>And add the calls to the <code class="literal">Load</code> function when the page appears:</p><pre class="programlisting">public override void ViewDidAppear(bool animated) 
        { 
            _model.Load(); 
 
            base.ViewDidAppear(animated); 
        } 
</pre><p>Override <code class="literal">ViewDidDisappear</code> to call the <code class="literal">Dispose</code> function:</p><pre class="programlisting">public override void ViewDidDisappear(bool animated) 
        { 
            _model.Dispose(); 
 
            base.ViewDidDisappear(animated); 
        } 
</pre><p>And create the following bindings in the binding set:</p><pre class="programlisting">set.Bind(this).For("Title").To(vm =&gt; vm.Title); 
            set.Bind(descriptionLabel).To(vm =&gt; vm.DescriptionMessage); 
            set.Bind(currentLabel).To(vm =&gt; vm.CurrentTime); 
            set.Bind(endLabel).To(vm =&gt; vm.EndTime); 
            set.Bind(progressSlider).For(v =&gt; v.Value).To(vm =&gt; vm.CurrentTime);  
            set.Bind(progressSlider).For(v =&gt; v.MaxValue).To(vm =&gt; vm.EndTime); 
            set.Bind(playButton).To(vm =&gt; vm.PlayPauseCommand); 
            set.Bind(rewindButton).To(vm =&gt; vm.RewindCommand); 
            set.Bind(fastForwardButton).To(vm =&gt; vm.ForwardCommand); 
</pre><p>We have our labels bound to the description, which are hard coded. This is why we must make changes to the <code class="literal">CurrentTime</code> variable on the main UI thread, because it affects what is displayed on the <code class="literal">currentLabel</code>. We also have our <code class="literal">MvxCommand</code> bindings on our audio buttons. Finally, we have our bindings on the <code class="literal">Value</code> property of the progress slider to match the <code class="literal">CurrentTime</code> variable, and the <code class="literal">MaxValue</code> to match the end time of the audio stream, so it matches the percentage playing time of the audio stream.</p><p>Excellent! Try running the application and playing around with the play/pause and progress slider functionality.</p><p>Let's move on to building the equivalent for the Android version.</p></div>
<div class="section" title="Implementing the Android SoundHandler using the MediaPlayer framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Implementing the Android SoundHandler using the MediaPlayer framework</h1></div></div></div><p>To implement the same functionality for the sound handler interface in Android, we will be using the the <code class="literal">MediaPlayer</code> framework.</p><p>Let's create a new folder in the Android project called <code class="literal">Sound</code>, and create a new file called <code class="literal">SoundHandler.cs</code>:</p><pre class="programlisting">public class SoundHandler : ISoundHandler 
{ 
        private MediaPlayer _mediaPlayer; 
 
        public bool IsPlaying { get; set; } 
} 
</pre><p>The same as the iOS version, let's add the <code class="literal">Load</code> and <code class="literal">PlayPause</code> functions:</p><pre class="programlisting">public void Load() 
        { 
            try 
            { 
                _mediaPlayer = new MediaPlayer(); 
                _mediaPlayer.SetAudioStreamType(Stream.Music); 
 
                AssetFileDescriptor descriptor = Android.App.Application.Context.Assets.OpenFd("Moby - The Only Thing.mp3"); 
                _mediaPlayer.SetDataSource(descriptor.FileDescriptor, descriptor.StartOffset, descriptor.Length); 
 
                _mediaPlayer.Prepare(); 
                _mediaPlayer.SetVolume(1f, 1f); 
            } 
            catch (Exception e) 
            { 
                Debug.WriteLine(e); 
            } 
        } 
 
        public void PlayPause() 
        { 
            if (_mediaPlayer != null) 
            { 
                if (IsPlaying) 
                { 
                    _mediaPlayer.Pause(); 
                } 
                else 
                { 
                    _mediaPlayer.Start(); 
                } 
 
                IsPlaying = !IsPlaying; 
            } 
        } 
</pre><p>We have some exception handling in the <code class="literal">Load</code> function just in case for any reason the file doesn't load; it will stop our app from crashing. When you place the <code class="literal">.mp3</code> inside the Android project, it must be placed in the <code class="literal">Assets</code> folder, and make sure the file build action is set to <code class="literal">AndroidAsset</code>:</p><div class="mediaobject"><img src="graphics/B05293_04_05.jpg" alt="Implementing the Android SoundHandler using the MediaPlayer framework"/></div><p>Inside our <code class="literal">load</code> function, after we initialize the <code class="literal">MediaPlayer</code> object, we set the stream type to <code class="literal">Stream.Music</code>, and then we use <code class="literal">AssestFileDescriptor</code> to retrieve the <code class="literal">.mp3</code> file. The <code class="literal">MediaPlayer's</code> source is then set to the <code class="literal">.mp3</code> file from <code class="literal">AssetFileDescriptor</code>. We then call <code class="literal">Prepare</code> and set the volume to full (1.0f).</p><p>Our <code class="literal">PlayPause</code> function is very simple; we simply check whether the audio is playing to determine whether we pause or start the audio stream.</p><p>Now for the other functions:</p><pre class="programlisting">public void Stop() 
        { 
            if (_mediaPlayer != null) 
            { 
                _mediaPlayer.Stop(); 
                _mediaPlayer.Reset(); 
            } 
        } 
 
        public double Duration() 
        { 
            if (_mediaPlayer != null) 
            { 
                return _mediaPlayer.Duration / 1000; 
            } 
 
            return 0; 
        } 
 
        public void SetPosition(double value) 
        { 
            if (_mediaPlayer != null) 
            { 
                _mediaPlayer.SeekTo((int)value * 1000); 
            } 
        } 
 
        public double CurrentPosition() 
        { 
            if (_mediaPlayer != null) 
            { 
                return _mediaPlayer.CurrentPosition / 1000; 
            } 
 
            return 0; 
        } 
 
        public void Forward() 
        { 
            if (_mediaPlayer != null) 
            { 
                IsPlaying = false; 
 
                _mediaPlayer.Pause(); 
                _mediaPlayer.SeekTo(_mediaPlayer.Duration); 
            } 
        } 
 
        public void Rewind() 
        { 
            if (_mediaPlayer != null) 
            { 
                IsPlaying = false; 
 
                _mediaPlayer.Pause(); 
                _mediaPlayer.SeekTo(0); 
            } 
        } 
</pre><p>The <code class="literal">Stop</code> function requires the <code class="literal">Reset</code> function to be called on the <code class="literal">MediaPlayer</code> after we call <code class="literal">Stop</code>. The <code class="literal">Duration</code> and <code class="literal">CurrentPosition</code> functions require the value to be divided by 1,000, as the values from <code class="literal">MediaPlayer</code> are in milliseconds. This is the same when we call <code class="literal">SeekTo</code> on <code class="literal">MediaPlayer</code>; because we are passing in a value in seconds, it has to be multiplied by 1,000 to give the answer in milliseconds. Then on to the <code class="literal">Rewind</code> and <code class="literal">Forward</code> functions; we must <code class="literal">Pause</code> the audio stream first then call the <code class="literal">SeekTo</code> method to set the stream position.</p><p>Excellent! We now have our Android implementation for the <code class="literal">ISoundHandler</code> interface, so let's get on to building the Android user interface.</p></div>
<div class="section" title="XML and Mvx bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec52"/>XML and Mvx bindings</h1></div></div></div><p>Our Android user interface will start at <code class="literal">MainPage</code>, so we need to add a new file called <code class="literal">MainPage.xml</code>, and a new <code class="literal">MvxActivity</code> called <code class="literal">MainPage.cs</code>. Firstly, add in a new folder called <code class="literal">Views</code>; this is where we will be storing our <code class="literal">MvxActivities</code>. Let's add a new file called <code class="literal">MainPage.cs</code> to the <code class="literal">Views</code> folder, and create a new file in the <span class="strong"><strong>Resources</strong></span> | <span class="strong"><strong>Layout</strong></span> folder called <code class="literal">Main.xml</code>. Our <code class="literal">Main.xml</code> is going to start with a <code class="literal">LinearLayout</code> and contain four elements: <code class="literal">ImageView</code>, <code class="literal">TextView</code>, and two <code class="literal">Buttons</code>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
     
    android:orientation="vertical" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent" 
    android:gravity="center"&gt; 
    &lt;ImageView 
        android:id="@+id/AudioImage" 
        android:layout_width="200dp" 
        android:layout_height="200dp" 
        android:src="@drawable/audio" /&gt; 
    &lt;TextView 
        android:id="@+id/DescriptionText" 
        android:textSize="32sp" 
        android:layout_marginBottom="5dp" 
        android:layout_marginTop="5dp" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        local:MvxBind="Text DescriptionMessage" /&gt; 
    &lt;Button 
        android:id="@+id/AudioPlayerButton" 
        android:layout_width="200dp" 
        android:layout_height="wrap_content" 
        local:MvxBind="Text AudioPlayerTitle; Click AudioPlayerCommand" /&gt; 
    &lt;Button 
        android:id="@+id/ExitButton" 
        android:layout_width="200dp" 
        android:layout_height="wrap_content" 
        local:MvxBind="Text ExitTitle; Click ExitCommand" /&gt; 
&lt;/LinearLayout&gt; 
</pre><p>Let's look more closely at the <code class="literal">local:Mvxbind</code> properties on the <code class="literal">Buttons</code> and <code class="literal">TextView</code>. This is where we will set up our bindings to the view-model. We must also add this line:</p><pre class="programlisting"> 
</pre><p>Does this look familiar?</p><p>It is the same as our XAML sheets in <code class="literal">Xamarin.Forms</code>; we must import this namespace so we can use the binding properties on our UI elements.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note60"/>Note</h3><p>Don't forget to copy all the images into the <code class="literal">drawable</code> folder before you try building the project.</p></div></div></div>
<div class="section" title="MvxActivities"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec53"/>MvxActivities</h1></div></div></div><p><code class="literal">MvxActivities</code> are an extended object from a regular Android <code class="literal">Activity</code>; the app knows we are using the MVVMCross binding system.</p><p>Let's implement <code class="literal">MainPageMvxActivity</code>:</p><pre class="programlisting">[Activity(Label = "Audio Player")] 
    public class MainPage : MvxActivity 
    { 
        protected override void OnCreate(Bundle bundle) 
        { 
            base.OnCreate(bundle); 
 
            SetupIoC(); 
 
            SetContentView(Resource.Layout.MainPage); 
        } 
 
        private void SetupIoC() 
        { 
            Mvx.RegisterType&lt;ISoundHandler, SoundHandler&gt;(); 
            PortableMvxIoCRegistrations.InitIoC(); 
        } 
    } 
</pre><p>We will need to set up our IoC registrations in the IoC container when this activity is created. Then we simply set the content view to the XML sheet we created previously. Let's test out the Android application and click run; you should now have a <code class="literal">MainPage</code> screen like this:</p><div class="mediaobject"><img src="graphics/B05293_04_06.jpg" alt="MvxActivities"/></div><p>Now we move on to the fun part: let's add a new <code class="literal">.xml</code> and <code class="literal">MvxActivity</code> for the <code class="literal">AudioPlayerPage</code>. Before we begin implementing the user interfaces for this page, we will need to create a custom <code class="literal">SeekBar</code>, because we want to register a new type of event for the <code class="literal">"UP"</code> motion event. Create a new folder called <code class="literal">Controls</code> and add a new file called <code class="literal">CustomSeekBar.cs</code>, then implement the following:</p><pre class="programlisting">public class CustomSeekBar : SeekBar 
    { 
        public event EventHandler ValueChanged; 
 
        protected CustomSeekBar(IntPtr javaReference, JniHandleOwnership transfer) 
            : base(javaReference, transfer) 
        { 
        } 
 
        public CustomSeekBar(Context context) 
            : base(context) 
        { 
 
        } 
 
        public CustomSeekBar(Context context, IAttributeSet attrs) 
            : base(context, attrs) 
        { 
        } 
 
        public CustomSeekBar(Context context, IAttributeSet attrs, int defStyle) 
            : base(context, attrs, defStyle) 
        { 
        } 
 
        public override bool OnTouchEvent(MotionEvent evt) 
        { 
            if (!Enabled) 
                return false; 
 
            switch (evt.Action) 
            { 
                // only fire value change events when the touch is released 
                case MotionEventActions.Up: 
                    { 
                        if (ValueChanged != null) 
                        { 
                            ValueChanged(this, EventArgs.Empty); 
                        } 
                    } 
                    break; 
            } 
 
            // we also want to fire all base motion events 
            base.OnTouchEvent(evt); 
 
            return true; 
        } 
    } 
</pre><p>We need to do this custom event because we are binding the progress of the audio stream to the SeekBar. Since we want to control the audio position, we need to make sure that only this event fires when we finish moving the seek bar.</p><p>Why can't we just use the <code class="literal">ProgressChanged</code> event, isn't that the same thing?</p><p>If we were to register the view-model function <code class="literal">UpdateAudioPosition</code> to the <code class="literal">ProgressChanged</code> event, every time the background loop updates the current time property, the SeekBar will call this event and try to set the audio position every second we update the SeekBar.</p><p>Now let's build the XML for the <code class="literal">AudioPlayerPage</code>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
     
    android:orientation="vertical" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent" 
    android:gravity="center"&gt; 
    &lt;ImageView 
        android:id="@+id/AudioImage" 
        android:layout_marginTop="20dp" 
        android:layout_marginBottom="80dp" 
        android:layout_width="200dp" 
        android:layout_height="200dp" 
        android:src="@drawable/moby" /&gt; 
    &lt;LinearLayout 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:orientation="horizontal" 
        android:gravity="center"&gt; 
        &lt;ImageButton 
            android:id="@+id/RewindButton" 
            android:layout_width="50dp" 
            android:layout_height="50dp" 
            android:src="@drawable/rewind" 
            local:MvxBind="Click RewindCommand" /&gt; 
        &lt;ImageButton 
            android:id="@+id/PlayButton" 
            android:layout_marginLeft="20dp" 
            android:layout_marginRight="20dp" 
            android:layout_width="50dp" 
            android:layout_height="50dp" 
            android:src="@drawable/play" 
            local:MvxBind="Click PlayPauseCommand" /&gt; 
        &lt;ImageButton 
            android:id="@+id/ForwardButton" 
            android:layout_width="50dp" 
            android:layout_height="50dp" 
            android:src="@drawable/fast_forward" 
            local:MvxBind="Click ForwardCommand" /&gt; 
    &lt;/LinearLayout&gt; 
    &lt;LinearLayout 
        android:layout_width="fill_parent" 
        android:layout_height="wrap_content" 
        android:orientation="horizontal" 
        android:gravity="center"&gt; 
        &lt;TextView 
            android:id="@+id/CurrentTimeText" 
            android:textSize="32sp" 
            android:layout_marginBottom="5dp" 
            android:layout_marginTop="5dp" 
            android:layout_marginLeft="20dp" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:layout_weight="1" 
            android:gravity="left" 
            local:MvxBind="Text CurrentTimeStr" /&gt; 
        &lt;TextView 
            android:id="@+id/EndTimeText" 
            android:textSize="32sp" 
            android:layout_marginBottom="5dp" 
            android:layout_marginTop="5dp" 
            android:layout_marginRight="20dp" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:layout_weight="1" 
            android:gravity="right" 
            local:MvxBind="Text EndTimeStr" /&gt; 
    &lt;/LinearLayout&gt; 
    &lt;AudioPlayer.Droid.Controls.CustomSeekBar 
        android:layout_width="fill_parent" 
        android:layout_height="wrap_content" 
        android:layout_gravity="center_vertical" 
        android:layout_marginLeft="20dp" 
        android:layout_marginRight="20dp" 
        android:id="@+id/seekBar" 
        local:MvxBind="Progress CurrentTime; Max EndTime" /&gt; 
&lt;/LinearLayout&gt; 
</pre><p>It is a fairly large <code class="literal">.xml</code> sheet. Starting from the top, we have <code class="literal">LinearLayout</code>, which contains <code class="literal">ImageView</code> at the very top where we will display the album art. We then have two <code class="literal">LinearLayouts</code>, which contain horizontal orientation for the three <code class="literal">ImageButtons</code> and the <code class="literal">TextViews</code>. These are stacked one under the other.</p><p>Finally, we have our custom <code class="literal">SeekBar</code> at the very bottom under the <code class="literal">TextView</code> items. You will notice the <code class="literal">layout_weight</code> property used on the <code class="literal">TextView</code> items, so both have the same width. We then use <code class="literal">gravity</code> to float each label to either side of the <code class="literal">SeekBar</code>.</p><p>Fantastic! Now let's add the <code class="literal">MvxActivity</code> for the <code class="literal">AudioPlayerPage</code> to the <code class="literal">Views</code> folder, and implement the following:</p><pre class="programlisting">[Activity(NoHistory = true)] 
    public class AudioPlayerPage : MvxActivity 
    { 
        private bool _playing; 
 
        private ImageButton _playButton; 
 
        private CustomSeekBar _seekBar; 
 
        private AudioPlayerPageViewModel _model; 
 
        protected override void OnCreate(Bundle bundle) 
        { 
            base.OnCreate(bundle); 
 
            SetContentView(Resource.Layout.AudioPlayerPage); 
 
            _seekBar = FindViewById&lt;CustomSeekBar&gt;(Resource.Id.seekBar); 
            _seekBar.ValueChanged += handleValueChanged; 
 
            _playButton = FindViewById&lt;ImageButton&gt;(Resource.Id.PlayButton); 
            _playButton.SetColorFilter(Color.White); 
            _playButton.Click += handlePlayClick; 
 
            var rewindButton = FindViewById&lt;ImageButton&gt;(Resource.Id.RewindButton); 
            rewindButton.SetColorFilter(Color.White); 
            rewindButton.Click += handleRewindForwardClick; 
 
            var forwardButton = FindViewById&lt;ImageButton&gt;(Resource.Id.ForwardButton); 
            forwardButton.SetColorFilter(Color.White); 
            forwardButton.Click += handleRewindForwardClick; 
 
            _model = (AudioPlayerPageViewModel)ViewModel; 
        } 
    } 
</pre><p>It all looks very similar to the iOS page. We assign the same types of event for each audio button. Now add the event functions:</p><pre class="programlisting">private void HandleValueChanged(object sender, System.EventArgs e) 
        { 
            _model.UpdateAudioPosition(_seekBar.Progress); 
        } 
 
        private void HandlePlayClick(object sender, System.EventArgs e) 
        { 
            _playing = !_playing; 
            _playButton.SetImageResource(playing ? Resource.Drawable.pause : Resource.Drawable.play); 
        } 
 
        private void handleRewindForwardClick(object sender, System.EventArgs e) 
        { 
            _playing = false; 
            _playButton.SetImageResource(Resource.Drawable.play); 
        } 
 
        protected override void OnDestroy() 
        { 
            _model.Dispose(); 
 
            base.OnDestroy(); 
        } 
</pre><p>You will notice the <code class="literal">NoHistory</code> flag set to true on this <code class="literal">Activity</code>, so every time we load the <code class="literal">Activity</code>, it loads a new <code class="literal">Activity</code>, and does not load any previously created <code class="literal">AudioPlayerPage</code>. We also override the <code class="literal">OnDestroy</code> function so it will call the <code class="literal">Dispose</code> method on our view-model.</p><p>There is an equivalent to the following iOS line:</p><pre class="programlisting">_model = (AudioPlayerPageViewModel)DataContext; 
</pre><p>This is much more straightforward in Android:</p><pre class="programlisting">_model = (AudioPlayerPageViewModel)ViewModel; 
</pre><p>And voila! We now have our Android version.</p><p>Try running the project and relax to one of Moby's greatest hits.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec54"/>Summary</h1></div></div></div><p>In this chapter, we implemented audio on iOS and Android using <code class="literal">Xamarin.iOS</code> and
<code class="literal">Xamarin.Android</code>. We learned how to load audio, stream audio, and process audio via start, stop, play, pause, rewind, and fast forward commands. We also built an MVVM architecture for native using MVVM Cross. In the next chapter, we will build an application for absorbing a web service using <code class="literal">Xamarin.Forms</code>. We will set up a <code class="literal">ListView</code> and create an <code class="literal">ObservableCollection</code> for displaying
JSON objects.</p></div></body></html>