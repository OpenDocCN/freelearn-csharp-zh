- en: '*Chapter 4*: User Interface Responsiveness and Threading'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：用户界面响应性和线程'
- en: One of the main reasons to introduce threading concepts to a project is the
    desire to keep an application responsive to user input. Accessing data through
    services, a database, or the filesystem can introduce delays, and the **user interface**
    (**UI**) should remain responsive. The real-world examples in this chapter will
    provide valuable options for ensuring UI responsiveness in your .NET client applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将线程概念引入项目的主要原因之一是希望保持应用程序对用户输入的响应性。通过服务、数据库或文件系统访问数据可能会引入延迟，而 **用户界面**（**UI**）
    应保持响应。本章中的实际示例将为确保 .NET 客户端应用程序中的 UI 响应性提供有价值的选项。
- en: 'In this chapter, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Leveraging background threads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用后台线程
- en: Using the thread pool
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池
- en: Updating the UI thread without exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无异常更新 UI 线程
- en: By the end of this chapter, you will understand how to take advantage of parallelism
    and concurrency to keep your client applications responsive and performant.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何利用并行性和并发性来保持客户端应用程序的响应性和性能。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows users:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例，以下软件被推荐给 Windows 用户：
- en: Visual Studio 2022 version 17.0 or later
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.0 或更高版本
- en: .NET 6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐的，但如果您已安装 .NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13 或更高版本的 Visual Studio 2022
    for Mac、JetBrains Rider 或 Visual Studio Code 都可以正常工作。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04)。
- en: Let’s get started by discussing how background threads can be used to perform
    non-critical tasks without impacting UI performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论如何使用后台线程执行非关键任务而不影响 UI 性能开始。
- en: Leveraging background threads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用后台线程
- en: In [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), we learned how to create
    background threads and discussed some of their uses. Background threads have a
    lower priority than the primary thread of the process and other thread pool threads.
    In addition, active background threads will not prevent the user or the system
    from terminating the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B18552_01_ePub.xhtml#_idTextAnchor014) 中，我们学习了如何创建后台线程，并讨论了它们的一些用途。后台线程的优先级低于进程的主线程和其他线程池线程。此外，活跃的后台线程不会阻止用户或系统终止应用程序。
- en: 'This means that background threads are perfect for tasks such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着后台线程非常适合以下任务：
- en: Writing log and analytics data
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写日志和数据分析
- en: Monitoring network or filesystem resources
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控网络或文件系统资源
- en: Reading data into the application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据读入应用程序
- en: 'Do not use background threads for critical application operations such as the
    following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将后台线程用于以下关键应用程序操作：
- en: Saving application state
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存应用程序状态
- en: Performing database transactions
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行数据库事务
- en: Application data processing
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用数据处理
- en: A good rule to follow when deciding whether some work can be processed by a
    background thread is to ask yourself whether abruptly interrupting the work to
    close the application would risk the data integrity of the system. So, how do
    you know whether you are creating a background or foreground thread?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定某些工作是否可以由后台线程处理时，一个好的规则是问自己，如果突然中断工作来关闭应用程序，是否会危及系统的数据完整性。那么，您如何知道您正在创建后台线程还是前台线程呢？
- en: Which threads are background threads?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些线程是后台线程？
- en: We have learned that a thread can be explicitly created as a background thread
    by setting its `IsBackground` property to `true`. All other threads created by
    calling a `Thread` constructor are foreground threads by default. The application’s
    primary (or main) thread is a foreground thread. All `ThreadPool` threads are
    background threads. This includes all asynchronous operations started by the **Task
    Parallel Library** (**TPL**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，可以通过将 `IsBackground` 属性设置为 `true` 来显式创建一个后台线程。默认情况下，通过调用 `Thread` 构造函数创建的所有其他线程都是前台线程。应用程序的主要（或主）线程是一个前台线程。所有
    `ThreadPool` 线程都是后台线程。这包括由 **Task Parallel Library** (**TPL**) 启动的所有异步操作。
- en: So, if all task-based operations such as `async` methods are executing on background
    threads, should you avoid using them for saving important application data? Will
    .NET allow your application to close while these `async` / `await` operations
    are in process? If there is a foreground thread awaiting an `async` operation,
    the application will not terminate until the operation is complete. If you do
    not use `await`, or you start an operation on the thread pool with `Task.Run`,
    it is possible for the application to terminate normally before the actions have
    finished.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果所有基于任务的操作，如 `async` 方法，都在后台线程上执行，你应该避免使用它们来保存重要的应用程序数据吗？.NET 允许在 `async`
    / `await` 操作进行中关闭你的应用程序吗？如果有前台线程正在等待一个 `async` 操作，应用程序将不会在操作完成之前终止。如果你不使用 `await`，或者你在线程池上启动操作时使用
    `Task.Run`，应用程序在动作完成之前可能正常终止。
- en: The great thing about using `await` with your `async` methods is the flexibility
    you gain in controlling the flow of execution while keeping the UI responsive.
    Let’s discuss `async` and `await` in client applications and create an example
    of a **Windows Presentation Foundation** (**WPF**) application that loads data
    from multiple sources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `await` 与 `async` 方法一起使用的好处是，你在保持 UI 响应的同时获得了控制执行流程的灵活性。让我们讨论客户端应用程序中的 `async`
    和 `await`，并创建一个 **Windows Presentation Foundation** (**WPF**) 应用程序的示例，该程序从多个来源加载数据。
- en: Using async, await, tasks, and WhenAll
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 async、await、任务和 WhenAll
- en: Using `async` and `await` in your code is the easiest way to introduce some
    background work using `ThreadPool`. An asynchronous method must be decorated with
    the `async` keyword and will return a `System.Threading.Tasks.Task` type instead
    of a `void` return.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用 `async` 和 `await` 是引入一些后台工作使用 `ThreadPool` 的最简单方法。异步方法必须用 `async` 关键字装饰，并将返回
    `System.Threading.Tasks.Task` 类型而不是 `void` 返回类型。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Async` methods return `Task` so the calling method can await the result of
    the method. If you were to create an `async` method with a `void` return type,
    it could not be awaited, and the calling code would continue processing subsequent
    code before the `async` method had completed. It is important to note that only
    event handlers should be declared as `async` with a `void` return type.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async` 方法返回 `Task`，因此调用方法可以等待该方法的返回结果。如果你创建一个返回类型为 `void` 的 `async` 方法，它将无法被等待，并且调用代码将在
    `async` 方法完成之前继续处理后续代码。需要注意的是，只有事件处理程序应该声明为 `async` 并具有 `void` 返回类型。'
- en: 'If the method returns `string`, then the `async` equivalent will return a `Task<string>`
    generic type. Let’s look at examples of each:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法返回 `string`，则 `async` 等效将返回 `Task<string>` 泛型类型。让我们看看每种情况的示例：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you call an `async` method, there are two common patterns to follow.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个 `async` 方法时，有两种常见的模式需要遵循。
- en: 'First, you can await the call and set the return type to a variable of the
    type returned inside the method:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你可以等待调用并将返回类型设置为方法内部返回的类型变量：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second option is to use `Task` variables when invoking the methods and
    await them later:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种选择是在调用方法时使用 `Task` 变量，稍后等待它们：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using this second method, the application can execute some synchronous work
    while the two `async` methods continue to run on background threads. Once the
    synchronous work is complete, the application will await the two `async` methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二种方法，应用程序可以在两个 `async` 方法在后台线程上继续运行的同时执行一些同步工作。一旦同步工作完成，应用程序将等待这两个 `async`
    方法。
- en: 'Let’s put our `async` knowledge to work in a more realistic sample project.
    In this example, we will create a new Windows client application with `async`
    methods. We will simulate slow service calls to fetch the data in these methods
    by injecting non-blocking delays with `Task.Delay`. Each method will take several
    seconds to return its data, but the UI will remain responsive to user input:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个更实际的示例项目中应用我们的 `async` 知识。在这个例子中，我们将创建一个新的 Windows 客户端应用程序，并使用 `async`
    方法。我们将通过使用 `Task.Delay` 注入非阻塞延迟来模拟这些方法中的慢速服务调用以获取数据。每个方法将需要几秒钟才能返回其数据，但 UI 将保持对用户输入的响应：
- en: Start by creating a new WPF project in Visual Studio. Name the project `AwaitWithWpf`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在 Visual Studio 中创建一个新的 WPF 项目。将项目命名为 `AwaitWithWpf`。
- en: 'Add two new classes to the project named `Order` and `MainViewModel`. Your
    solution should now look something like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加两个新类，分别命名为 `Order` 和 `MainViewModel`。你的解决方案现在应该看起来像这样：
- en: '![Figure 4.1 – The AwaitWithWpf solution in Visual Studio ](img/Figure_4.1_B18552.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Visual Studio 中的 AwaitWithWpf 解决方案](img/Figure_4.1_B18552.jpg)'
- en: Figure 4.1 – The AwaitWithWpf solution in Visual Studio
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Visual Studio 中的 AwaitWithWpf 解决方案
- en: 'Next, open `MVVM Toolkit` on the `Microsoft.Toolkit.Mvvm` package to your project:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `Microsoft.Toolkit.Mvvm` 包中的 `MVVM Toolkit` 并将其添加到你的项目中：
- en: '![Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project ](img/Figure_4.2_B18552.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 将 Microsoft.Toolkit.Mvvm 包添加到项目中](img/Figure_4.2_B18552.jpg)'
- en: Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 将 Microsoft.Toolkit.Mvvm 包添加到项目中
- en: We will be using the `MainViewModel` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `MainViewModel` 类。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The MVVM Toolkit is an open source MVVM library that is part of the **Windows
    Community Toolkit** maintained by Microsoft. If you are unfamiliar with the MVVM
    pattern or the MVVM Toolkit, you can read more about them on Microsoft Docs: [https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction](https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM Toolkit 是一个开源的 MVVM 库，它是微软维护的 **Windows Community Toolkit** 的一部分。如果你不熟悉
    MVVM 模式或 MVVM Toolkit，你可以在 Microsoft Docs 上了解更多信息：[https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction](https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction)。
- en: 'Now, open the `Order` class and add the following implementation:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `Order` 类并添加以下实现：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will provide a few properties to display for each order when the order
    list is populated on `MainWindow`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每个订单提供一些属性，以便在 `MainWindow` 上填充订单列表时显示。
- en: 'Now we will start to build the `MainViewModel` implementation. The first step
    is to add a list of orders to bind to the UI and a command to execute when we
    want to load the orders:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始构建 `MainViewModel` 的实现。第一步是添加一个要绑定到 UI 的订单列表和一个在我们要加载订单时执行的命令：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s review a few of the properties of the `MainViewModel` class before moving
    on to the next step:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，让我们回顾一下 `MainViewModel` 类的一些属性：
- en: The `MainViewModel` class inherits from the `ObservableObject` type provided
    by the MVVM Toolkit.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainViewModel` 类继承自 MVVM Toolkit 提供的 `ObservableObject` 类型。'
- en: This base class implements the `INotifyPropertyChanged` interface, which is
    used by WPF data binding to notify the UI when data-bound property values change.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个基类实现了 `INotifyPropertyChanged` 接口，该接口被 WPF 数据绑定用于在数据绑定属性值更改时通知 UI。
- en: The `Orders` property will provide the list of orders to the UI through WPF
    data binding. Calling `SetProperty` on the `ObservableObject` base sets the value
    of the `_orders` backing variable and triggers a property change notification.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Orders` 属性将通过 WPF 数据绑定将订单列表提供给 UI。在 `ObservableObject` 基类上调用 `SetProperty`
    会设置 `_orders` 后备变量的值并触发属性更改通知。'
- en: The `LoadOrderDataCommand` property will be executed by a button on `MainWindow`.
    In the constructor, the property is being initialized as a new `AsyncRelayCommand`
    that calls `LoadOrderDataAsync` when the command is invoked by the UI.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadOrderDataCommand` 属性将由 `MainWindow` 上的按钮执行。在构造函数中，该属性被初始化为一个新的 `AsyncRelayCommand`，当命令被
    UI 调用时，它会调用 `LoadOrderDataAsync`。'
- en: 'Don’t forget to add the necessary `using` statements to the class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将必要的 `using` 语句添加到类中：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, let’s create two `async` methods to load order data. One will create
    current orders and the other will create a list of archived orders. These are
    differentiated by the `IsArchived` property on the `Order` class. Each method
    uses `Task.Delay` to simulate a service call across a slow internet or network
    connection:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建两个 `async` 方法来加载订单数据。一个将创建当前订单，另一个将创建已存档订单的列表。这些通过 `Order` 类上的 `IsArchived`
    属性来区分。每个方法都使用 `Task.Delay` 来模拟在缓慢的互联网或网络连接上的服务调用：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to create a synchronous `ProcessOrders` method that combines the
    two lists of orders and updates the `Orders` property with the full dataset:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个同步的 `ProcessOrders` 方法，将两个订单列表合并，并使用完整的数据集更新 `Orders` 属性：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final step in building the `MainViewModel` class is the most important.
    Add the following implementation to the `LoadOrderDataAsync` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `MainViewModel` 类的最后一步是最重要的。将以下实现添加到 `LoadOrderDataAsync` 方法中：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method calls `GetCurrentOrdersAsync` and `GetArchivedOrdersAsync` and captures
    each in a `Task<List<Order>>` variable. You could simply await each call and store
    the returned orders in `List<Order>` variables. However, that would mean the second
    method would not start executing until the first one completed. By awaiting `Task.WhenAll`
    instead, the methods can execute in parallel on background threads.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用 `GetCurrentOrdersAsync` 和 `GetArchivedOrdersAsync`，并将每个调用捕获在一个 `Task<List<Order>>`
    变量中。你可以简单地等待每个调用并将返回的订单存储在 `List<Order>` 变量中。然而，这意味着第二个方法将不会在第一个方法完成之前开始执行。通过等待
    `Task.WhenAll`，方法可以在后台线程上并行执行。
- en: If your methods all return the same data type, you can capture the results of
    `Task.WhenAll` in an array of the return type. In our case, we are receiving the
    two lists of orders in an array of `List<Order>` and passing the two array values
    to `ProcessOrders`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法都返回相同的数据类型，你可以在返回类型的数组中捕获 `Task.WhenAll` 的结果。在我们的例子中，我们正在接收一个 `List<Order>`
    的数组，并将其传递给 `ProcessOrders`。
- en: 'Now, let’s move on to the `MainWindow.xaml.cs` code-behind file. Add the following
    code to set `DataContext` of `MainWindow` in the constructor after the call to
    `InitializeComponent`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到 `MainWindow.xaml.cs` 的代码隐藏文件。在调用 `InitializeComponent` 之后，在构造函数中添加以下代码来设置
    `MainWindow` 的 `DataContext`：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`DataContext` is the source for all `Binding` references in the XAML for `MainWindow`.
    We will create the XAML for our UI in the next step.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataContext` 是 `MainWindow` 的 XAML 中所有 `Binding` 引用的来源。我们将在下一步创建我们 UI 的 XAML。'
- en: 'The last file to update is `MainWindow.xaml`. Open the XAML file and start
    by adding two rows to `Grid`. The first row will contain another `Grid` containing
    `Button` and `TextBox`. The second row will contain `ListView` to display the
    list of orders. We’ll create a template for the orders in a moment:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要更新的文件是 `MainWindow.xaml`。打开 XAML 文件，首先向 `Grid` 添加两行。第一行将包含另一个 `Grid`，其中包含
    `Button` 和 `TextBox`。第二行将包含 `ListView` 来显示订单列表。我们将在稍后为订单创建一个模板：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I have highlighted the two data binding instances in the XAML markup. The `Command`
    of `Button` is bound to the `LoadOrderDataCommand` property, and `ItemsSource`
    of `ListView` is bound to the `Orders` property. Setting `ItemsSource` will make
    the properties of the `Order` class available to the members of `ListView.ItemTemplate`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 XAML 标记中突出显示了两个数据绑定实例。`Button` 的 `Command` 绑定到 `LoadOrderDataCommand` 属性，`ListView`
    的 `ItemsSource` 绑定到 `Orders` 属性。设置 `ItemsSource` 将使 `Order` 类的属性可用于 `ListView.ItemTemplate`
    的成员。
- en: 'Let’s add `ItemTemplate` to `ListView` next. Defining `DataTemplate` within
    `ItemTemplate` defines the structure of each item within `ListView`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们接下来为 `ListView` 添加 `ItemTemplate`。在 `ItemTemplate` 中定义 `DataTemplate` 定义了
    `ListView` 中每个项目的结构：
- en: '[PRE21]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each `Order` instance will render as a `StackPanel` containing three horizontally
    aligned `StackPanel` elements, displaying labels and values for the `OrderId`,
    `CustomerName`, and `IsArchived` data-bound properties.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Order` 实例将渲染为一个包含三个水平对齐的 `StackPanel` 元素的 `StackPanel`，显示 `OrderId`、`CustomerName`
    和 `IsArchived` 数据绑定属性标签和值。
- en: 'We’re ready to run the application and see how things work. After the program
    starts, click the `ListView`. While you wait, try typing some text into the box
    to the right of the `async`/`await` and the `Task.WhenAll` method. Once the data
    has finished loading, you should see a list of twelve orders in the scrollable
    list:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好运行应用程序并查看一切是如何工作的。程序启动后，点击 `ListView`。在你等待的时候，尝试在 `async`/`await` 和 `Task.WhenAll`
    方法右侧的框中输入一些文本。一旦数据加载完成，你应该在可滚动的列表中看到十二个订单：
- en: '![Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application ](img/Figure_4.3_B18552.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 在AsyncWithWpf应用程序中查看订单列表](img/Figure_4.3_B18552.jpg)'
- en: Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 在AsyncWithWpf应用程序中查看订单列表
- en: In a real production application, the implementations of the two `async` methods
    would be replaced by service calls to fetch data from a database or web services.
    Regardless of how long it takes to return and populate the data, other parts of
    the UI will remain responsive to user input. One change you would want to make
    is adding an indicator to the UI to inform the user that data is being loaded.
    You should also disable the `LoadOrderDataAsync`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的生产应用程序中，两个`async`方法的实现将被替换为从数据库或Web服务获取数据的调用。无论返回和填充数据需要多长时间，UI的其他部分都将保持对用户输入的响应。你想要做的更改之一是向UI添加一个指示器，告知用户数据正在加载。你还应该禁用`LoadOrderDataAsync`。
- en: The example illustrates the benefits of using `async` and `await` in a Windows
    application. These `async` calls are using `ThreadPool` within the TPL. Let’s
    look at some other ways to leverage `ThreadPool` in a Windows application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例说明了在Windows应用程序中使用`async`和`await`的好处。这些`async`调用在TPL中使用`ThreadPool`。让我们看看在Windows应用程序中利用`ThreadPool`的其他方法。
- en: Using the thread pool
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池
- en: There are other ways to use `ThreadPool` threads in a .NET application. Let’s
    discuss a situation where you want to accomplish the same result that was achieved
    with `async` and `await` in the previous example, but the methods to fetch the
    order data are not marked as `async`. One option is to update the methods to be
    `async`. If that code is not within your control to change, you have some other
    options available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET应用程序中，还有其他方法可以使用`ThreadPool`线程。让我们讨论一种情况，即你想要实现与上一个示例中`async`和`await`达到相同结果，但获取订单数据的方法并未标记为`async`。一个选择是将方法更新为`async`。如果这段代码不在你的控制范围内进行更改，你还有一些其他选项可用。
- en: 'The `ThreadPool` class has a method called `QueueUserWorkItem`. This method
    accepts a method to call and queues it for execution on the thread pool. We could
    use it with our project like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`类有一个名为`QueueUserWorkItem`的方法。此方法接受一个要调用的方法，并将其排队在线程池上执行。我们可以像这样在我们的项目中使用它：'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are a few problems with using this method. The primary issue is that there
    is no return value to get the list of orders from the method call. You could work
    around this issue with some wrapper methods that update a shared thread-safe collection
    such as the `BlockingCollection`. That isn’t a great design, and there is a better
    option.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法有几个问题。主要问题是方法调用没有返回值来获取订单列表。你可以通过一些包装方法来解决这个问题，这些方法更新一个共享的线程安全集合，如`BlockingCollection`。这不是一个好的设计，有一个更好的选择。
- en: 'The `QueueUserWorkItem` method was more commonly used before the introduction
    of the TPL. In today’s task-based world, you can use `Task.Run` to execute a synchronous
    method as `async`. Let’s update our WPF project to use `Task.Run`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在TPL引入之前，`QueueUserWorkItem`方法更常被使用。在当今基于任务的世界中，你可以使用`Task.Run`来执行同步方法作为`async`。让我们更新我们的WPF项目以使用`Task.Run`：
- en: 'The only file that needs to be modified to use `Task.Run` is `MainViewModel`.
    Start by updating `GetCurrentOrdersAsync` and `GetArchivedOrdersAsync` to no longer
    be `async` methods. They should also be renamed as `GetCurrentOrders` and `GetArchivedOrders`
    so consumers are aware that they are not `async` methods:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需要修改一个文件来使用`Task.Run`，那就是`MainViewModel`。首先，将`GetCurrentOrdersAsync`和`GetArchivedOrdersAsync`更新为不再为`async`方法。它们还应该被重命名为`GetCurrentOrders`和`GetArchivedOrders`，以便消费者知道它们不是`async`方法：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The changes are minimal, and I have highlighted them in the preceding source
    code. The `async` modifier has been removed from the method declarations, the
    methods have been renamed and they no longer return tasks, and `Task.Delay` in
    each method has been updated to `Thread.Sleep`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改很小，我在前面的源代码中已经突出显示了它们。方法声明中已经移除了`async`修饰符，方法已经被重命名，并且它们不再返回任务，每个方法中的`Task.Delay`已经被更新为`Thread.Sleep`。
- en: 'Next, we will update the `LoadOrderDataAsync` method to call the synchronous
    methods with `Task.Run`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`LoadOrderDataAsync`方法，使用`Task.Run`调用同步方法：
- en: '[PRE24]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: No other changes are necessary. `Task.Run` will return the same `Task<List<Order>>`
    type, which can still be used with `Task.WhenAll` to wait for their completion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他必要的更改。`Task.Run`将返回相同的`Task<List<Order>>`类型，这仍然可以与`Task.WhenAll`一起使用以等待它们的完成。
- en: Run the program, and it should work exactly as it did before. The UI remains
    responsive while the order data is loading.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，它应该和之前完全一样工作。当加载数据时，UI保持响应。
- en: This is an excellent way to start incorporating `async` and `await` into existing
    code, but always use caution when adding threading to your applications. In this
    application, the two methods being called do not access any shared data. So, there
    was no need to think about thread safety. If these methods were updating a private
    collection of orders, you would need to introduce a locking mechanism or use a
    thread-safe collection for the orders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种将`async`和`await`集成到现有代码中的极好方式，但在向应用程序添加线程时始终要小心。在此应用程序中，被调用的两个方法都没有访问任何共享数据。因此，没有必要考虑线程安全性。如果这些方法正在更新一个私有的订单集合，你需要引入一个锁定机制或使用线程安全的订单集合。
- en: 'Before we move on to a discussion of the UI thread, there is one other `Task`
    method to discuss. The `Task.Factory.StartNew` method is similar in use to `Task.Run`.
    In fact, you can use them in the same way. This code uses `Task.Run` to get a
    `Task` with the current orders:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论UI线程之前，还有一个其他的`Task`方法需要讨论。`Task.Factory.StartNew`方法的使用与`Task.Run`类似。实际上，你可以以相同的方式使用它们。此代码使用`Task.Run`来获取当前订单的`Task`：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code does the same thing with `Task.Factory.StartNew`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用`Task.Factory.StartNew`做同样的事情：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, you should use `Task.Run`. It is a newer method and is simply
    a shortcut meant to simplify the most common use cases. The `Task.Factory.StartNew`
    method has some additional overloads for specific uses. This example uses `StartNew`
    to call `GetCurrentOrders` with some optional parameters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该使用`Task.Run`。这是一个较新的方法，它只是一个简化最常见用例的快捷方式。`Task.Factory.StartNew`方法有一些额外的重载用于特定用途。此示例使用`StartNew`调用`GetCurrentOrders`并带有一些可选参数：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The interesting option we have provided here is `TaskCreationOptions.AttachedToParent`.
    What this does is it links the task completion of the calling method to that of
    the child, `GetCurrentOrders`. The default behavior is for their completions to
    be unlinked. For a complete list of available overloads and their uses, you can
    review Microsoft Docs here: [https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew](https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的有趣选项是`TaskCreationOptions.AttachedToParent`。这样做是将调用方法的任务完成与子任务`GetCurrentOrders`相链接。默认行为是它们的完成是未链接的。要查看可用重载及其用途的完整列表，你可以在Microsoft
    Docs上查看：[https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew](https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew).
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Stephen Toub* of the .NET team has a blog post where he discusses `Task.Run`
    versus `Task.Factory.StartNew` and why you might want to choose each option. You
    can read his post on the *.NET Parallel Programming* blog here: [https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: .NET团队的*Stephen Toub*在他的博客文章中讨论了`Task.Run`与`Task.Factory.StartNew`的区别以及为什么你可能想要选择每个选项。你可以在*.NET
    Parallel Programming*博客上阅读他的文章：[https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/).
- en: Now, let’s move on to discuss when you will need to write code to explicitly
    update the UI thread from a background thread.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论在何时你需要编写代码来显式地从后台线程更新UI线程。
- en: Updating the UI thread without exceptions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无异常地更新UI线程
- en: When working with managed threading in .NET applications, there are many pitfalls
    that developers must learn to avoid. One of the common mistakes developers make
    is writing code that updates a UI control in a Windows application from a non-UI
    thread. This kind of error will not be detected by the compiler. Developers will
    receive a runtime error indicating that a control created on the main thread cannot
    be modified on another thread.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当在.NET应用程序中处理托管线程时，开发者必须学会避免许多陷阱。开发者常见的错误之一是在Windows应用程序的非UI线程中更新UI控件。这种错误不会被编译器检测到。开发者将收到一个运行时错误，表明在主线程上创建的控件不能在其他线程上修改。
- en: So, how do you avoid these runtime errors? The best way to avoid them is by
    not updating UI controls from background threads at all. WPF helps avoid the problem
    with the MVVM pattern and data binding. Binding updates are automatically marshaled
    to the UI thread by .NET. You can safely update properties in your `ViewModel`
    classes from a background thread without causing errors at runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何避免这些运行时错误呢？最好的办法是完全不在后台线程中更新 UI 控件。WPF 通过 MVVM 模式和数据绑定帮助避免了这个问题。绑定更新会自动由
    .NET 调度到 UI 线程。您可以从后台线程安全地更新 `ViewModel` 类中的属性，而不会在运行时引发错误。
- en: 'If you are updating UI controls directly in your code, either in a WinForms
    application or in the code-behind file of a WPF control, you can use an `Invoke`
    call to *push* the execution to the main thread. The implementation is slightly
    different between WinForms and WPF. Let’s start with a WPF example. If you have
    a method performing some work on a background thread, and it needs to update the
    `Text` property of a `TextBox` on a WPF window, you could wrap the code in an
    action:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您直接在代码中更新 UI 控件，无论是在 WinForms 应用程序中还是在 WPF 控件的代码后文件中，您可以使用 `Invoke` 调用来 *推送*
    执行到主线程。WinForms 和 WPF 之间的实现略有不同。让我们从一个 WPF 示例开始。如果您有一个在后台线程上执行某些工作的方法，并且它需要更新
    WPF 窗口上 `TextBox` 的 `Text` 属性，您可以将代码包裹在一个操作中：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Dispatcher.Invoke` will push the execution to the main thread. Keep in mind
    that if the main thread is busy with other work, your background thread will wait
    here for this action to complete. If your background worker wants to fire and
    forget this action, you can use `Dispatcher.BeginInvoke` instead.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher.Invoke` 将执行推送至主线程。请注意，如果主线程正忙于其他工作，您的后台线程将在这里等待此操作完成。如果您的后台工作器想要触发并忘记此操作，您可以使用
    `Dispatcher.BeginInvoke` 代替。'
- en: 'Let’s assume we want to update `usernameTextBox`, but this time, we are working
    with a WinForms project. The same invocation can be accomplished by using `Form`
    or `UserControl` executing the code. This example is a WinForms application with
    two buttons. Clicking one button will call the `UpdateUsername` method. The other
    button will call `Task.Run(UpdateUsername)`, putting it on a background thread.
    To determine whether `Invoke` is needed to access the main thread, you check the
    Boolean `InvokeRequired` read-only property. It may not be required if the thread
    pool chose to run `Task` on the main thread:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要更新 `usernameTextBox`，但这次我们正在处理一个 WinForms 项目。可以通过使用 `Form` 或 `UserControl`
    执行代码来实现相同的调用。这个例子是一个包含两个按钮的 WinForms 应用程序。点击一个按钮将调用 `UpdateUsername` 方法。另一个按钮将调用
    `Task.Run(UpdateUsername)`，将其放在后台线程上。要确定是否需要 `Invoke` 来访问主线程，您检查只读布尔属性 `InvokeRequired`。如果线程池选择在主线程上运行
    `Task`，则可能不需要：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `usernameTextBox` will display the name **John Doe** successfully regardless
    of which button is clicked:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论点击哪个按钮，`usernameTextBox` 都将成功显示名称 **John Doe**：
- en: '![Figure 4.3 – Updating a control on a WinForms form ](img/Figure_4.4_B18552.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 更新 WinForms 表单上的控件](img/Figure_4.4_B18552.jpg)'
- en: Figure 4.3 – Updating a control on a WinForms form
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 更新 WinForms 表单上的控件
- en: Like WPF, WinForms has a `BeginInvoke` method if the background code does not
    need to wait for the main thread update to complete. `BeginInvoke` can also accept
    an `EndInvoke` delegate that will receive a callback when the main thread invocation
    has completed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与 WPF 类似，WinForms 也提供了一个 `BeginInvoke` 方法，如果后台代码不需要等待主线程更新完成。`BeginInvoke` 还可以接受一个
    `EndInvoke` 委托，当主线程调用完成时，该委托将接收回调。
- en: This section provided a great start on using .NET managed threading in your
    Windows client applications. Let’s finish up with a summary of what we learned
    in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您在 Windows 客户端应用程序中使用 .NET 管理线程提供了一个良好的起点。让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some useful techniques for improving client application
    performance. We started by exploring some different uses of `async` and `await`
    in the ViewModel of a WPF application. In that project, we saw that awaiting `Task.WhenAll`
    does not block the main thread, which keeps the UI responsive to user input. We
    discussed how `Task.Run` and `Task.Factory.StartNew` can be used to call synchronous
    code from asynchronous code, making it easier to introduce managed threading to
    existing applications. We finished up the chapter by learning some techniques
    to update the UI thread from other threads without causing exceptions at runtime.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些提高客户端应用程序性能的有用技术。我们首先从探索 WPF 应用程序中 ViewModel 的 `async` 和 `await`
    的不同用法开始。在那个项目中，我们看到了等待 `Task.WhenAll` 不会阻塞主线程，这保持了用户输入对 UI 的响应性。我们讨论了如何使用 `Task.Run`
    和 `Task.Factory.StartNew` 从异步代码中调用同步代码，使得将托管线程引入现有应用程序变得更加容易。我们通过学习一些技术来更新 UI
    线程，而不会在运行时引发异常来结束本章。
- en: 'You should be feeling more comfortable using `async`, `await`, and the TPL
    in your code after reading this chapter. Try taking what you have learned here
    and start adding some `async` code to your own client applications. For additional
    reading on `async` and `await`, you can check out this C# article on Microsoft
    Docs: [https://docs.microsoft.com/dotnet/csharp/async](https://docs.microsoft.com/dotnet/csharp/async).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你应该在使用 `async`、`await` 和 TPL 的代码中感到更加自在。尝试将这里学到的知识应用到自己的客户端应用程序中。关于 `async`
    和 `await` 的更多阅读，你可以查看 Microsoft Docs 上的这篇 C# 文章：[https://docs.microsoft.com/dotnet/csharp/async](https://docs.microsoft.com/dotnet/csharp/async)。
- en: In the next chapter, we will dive even deeper into using `async`, `await`, and
    the TPL. We will take some of the concepts from this chapter and expand on them
    while introducing some best practices.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨使用 `async`、`await` 和 TPL。我们将从本章中的一些概念出发，在介绍一些最佳实践的同时进行扩展。
- en: Questions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What type should every `async` method return?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个异步方法应该返回什么类型？
- en: Which method can be used to await multiple tasks?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个方法可以用来等待多个任务？
- en: Which method to start a new task accepts `TaskDispatcher` as one of the parameters?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个启动新任务的方法接受 `TaskDispatcher` 作为参数之一？
- en: When calling an `async` method, what type of thread will execute the task?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用异步方法时，哪种类型的线程将执行任务？
- en: What method should be used in a WPF application when updating a user control
    from a background thread?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 WPF 应用程序中，从后台线程更新用户控件时应使用哪种方法？
- en: Which method should be used on a WinForms control to execute an action on the
    main thread but not wait for the method to complete?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 WinForms 控件上使用哪个方法可以在主线程上执行操作，但不需要等待方法完成？
- en: In WinForms, how can you check whether calling `Invoke` is necessary?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 WinForms 中，如何检查调用 `Invoke` 是否必要？
