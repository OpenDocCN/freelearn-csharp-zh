- en: Chapter 9. Reusable UI Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 可重用UI模式
- en: 'In this chapter, we will discuss strategies and patterns for reusing visual
    assets (that is, text and media resources) in cross platform projects. Furthermore,
    reusable assets will be iteratively explained from the localization perspective.
    Finally, some advanced software architectural topics about Model-View-Controller
    and Model-View-ViewModel patterns will be analyzed and demonstrated. This chapter
    is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在跨平台项目中重用视觉资源（即文本和媒体资源）的策略和模式。此外，将从本地化的角度迭代解释可重用资源。最后，将分析和演示关于模型-视图-控制器和模型-视图-视图模型模式的高级软件架构主题。本章分为以下部分：
- en: Visual assets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉资源
- en: Localization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化
- en: Architectural patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构模式
- en: Visual assets
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉资源
- en: We can classify any resource included in the project at compile time and used
    by the user interface as a visual asset. Visual assets can vary from simple text
    elements to media items (for example images, animations, videos, and so on) to
    be used for creating the visual elements of the user interface. Each Xamarin target
    platform provides different mechanisms to store and dispatch these assets.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在编译时对项目中的任何资源进行分类，这些资源被用户界面使用，作为视觉资源。视觉资源可以从简单的文本元素到媒体项目（例如图像、动画、视频等），用于创建用户界面的视觉元素。每个Xamarin目标平台都提供不同的机制来存储和分发这些资源。
- en: On Android and iOS, resources and their localized representations are kept in
    the designated `Resources` folder and substructures. On Windows Phone (both Silverlight
    and Windows Runtime), resources can be managed by using embedded resource files
    (that is, `resw` or `resx`).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android和iOS上，资源和它们的本地化表示形式保存在指定的`Resources`文件夹和子结构中。在Windows Phone（包括Silverlight和Windows
    Runtime）上，可以使用嵌入的资源文件（即`resw`或`resx`）来管理资源。
- en: Text resources
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本资源
- en: Each Xamarin target platform uses various strategies to filter out static text
    resources, such as the content of a message dialog or a label, from the **View**
    implementation. Doing this helps developers separate human readable resources
    from code base, creating a project structure in line with the separation of concerns
    principle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Xamarin目标平台使用各种策略来过滤掉静态文本资源，例如消息对话框或标签的内容，从**视图**实现中。这样做有助于开发人员将可读性资源与代码库分离，创建符合关注点分离原则的项目结构。
- en: Xamarin.Android
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Xamarin.Android
- en: On the Android platform, text resources can be stored in the `strings.xml` file
    and retrieved through code or used in declarative markups (that is, AXML files).
    The XML file containing the string resources can be found or created in the `Resources\values`
    directory. There is no relevance between the filenames and how the resources are
    retrieved later on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，文本资源可以存储在`strings.xml`文件中，通过代码检索或用于声明性标记（即AXML文件）。包含字符串资源的XML文件可以在`Resources\values`目录中找到或创建。文件名与资源检索后的相关性不大。
- en: 'The resource XML file has a simple format, where each string is defined as
    an XML node with an associated name as an attribute:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 资源XML文件具有简单的格式，其中每个字符串都定义为具有关联名称属性的XML节点：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The string values can later be used in markup, and also in Android declarative
    attributes, using the `@string/<ResourceName>` notation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值可以在标记中使用，也可以在Android声明性属性中使用`@string/<ResourceName>`的表示法：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to add an activity label for a view, the `ApplicationName` string
    can be included directly with the `@string` notation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为视图添加活动标签，可以直接使用`@string`表示法包含`ApplicationName`字符串：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On top of the classic string resources, a collection of string resources and
    quantity strings can also be included in the resource XML file(s). Quantity strings
    are resource strings with a definition for different countable references for
    various scenarios with the correct pluralization rule.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典字符串资源的基础上，还可以在资源XML文件中包含一组字符串资源和数量字符串。数量字符串是具有不同计数引用定义的资源字符串，适用于各种场景，并遵循正确的复数规则。
- en: 'For instance, for an application with English as the default language, the
    plural quantity strings would look similar to the following (for example, a singular
    word for one, a plural form for others):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于一个以英语为默认语言的应用程序，复数数量字符串将类似于以下内容（例如，一个单词表示一个，复数形式表示其他）：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Whereas for the Turkish language, it would look similar to the following (the
    same rule applies to all countable words):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于土耳其语，它将类似于以下内容（相同的规则适用于所有可数名词）：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Examples of this usage can be extended to Slavic languages (for example Russian,
    Polish, and Czech), where languages have different use cases for a small number
    of items or for numbers ending with certain digits. Possible switch values for
    quantities are `zero`, `one`, `two`, `few`, `many`, and `other`. The application
    of these switches follows the rules defined for language plurals in the unicode
    common locale data repository (see [http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
    for more information). For instance, English does not require a specific handling
    for few items or zero items, so any rule defined for these cases will be ignored
    by the runtime.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的示例可以扩展到斯拉夫语系（例如俄语、波兰语和捷克语），在这些语言中，对于少量项目或以特定数字结尾的数字有不同的用法。数量可能的切换值有`zero`、`one`、`two`、`few`、`many`和`other`。这些切换值的运用遵循Unicode通用区域数据仓库中定义的语言复数规则（更多信息请参见[http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)）。例如，英语不需要对少量或零个项目的特定处理，因此为这些情况定义的任何规则都将被运行时忽略。
- en: Once the resource XML file(s) are modified, you can see that the `Resource.Designer.cs`
    file is (re)generated with each compilation. This file contains the associated
    ID values for different types of resources and can be used for retrieving the
    resource items with the `Resources` utility class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦修改了资源XML文件，你将看到`Resource.Designer.cs`文件在每次编译时都会（重新）生成。此文件包含不同类型资源的关联ID值，并可用于使用`Resources`实用工具类检索资源项。
- en: '![Xamarin.Android](img/B04693_09_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.Android](img/B04693_09_01.jpg)'
- en: 'Figure 1: Generated resource constants'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：生成的资源常量
- en: 'Using the `Resources` utility, text resources can be retrieved in the following
    ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Resources`实用工具，可以通过以下方式检索文本资源：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Additionally, other primitive data types (for example, integers, Booleans, and
    so on), as well as units or `structs` used in style definitions (for example,
    dimension and color) can be included in resource XML files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其他原始数据类型（例如整数、布尔值等），以及用于样式定义中的单位或`structs`（例如尺寸和颜色）也可以包含在资源XML文件中。
- en: Xamarin.iOS
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Xamarin.iOS
- en: 'On the iOS platform, the simplest way to separate the text resources from the
    rest of the project would be to create `.strings` files (for example, `Localizable.strings`),
    which follow a simple JSON-like pattern with key/value pairs:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS平台上，将文本资源与其他项目内容分离的最简单方法就是创建`.strings`文件（例如，`Localizable.strings`），这些文件遵循简单的类似JSON的模式，包含键/值对：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These string values, compiled into bundle resources, can, later on, be accessed
    using the `NSBundle.MainBundle.LocalizedString` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串值，编译成资源包后，可以使用`NSBundle.MainBundle.LocalizedString`方法进行访问：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Localized string values can be used as labels for UI controls, creating a loosely-coupled
    relationship between the static text content and the actual runtime components.
    This process is referred to as internationalization in the iOS ecosystem. Internationalized
    controls and elements can easily be localized for different languages. `Strings`
    files can be created in the `Resources` folder or can be placed in the `Base.lproj`
    folder inside the `Resources` directory, which constitutes the base localization
    project folder for iOS projects (the default/fallback resources).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化字符串值可以用作UI控件的标签，在静态文本内容和实际运行时组件之间创建松散耦合的关系。这个过程在iOS生态系统中被称为国际化。国际化的控件和元素可以轻松地本地化为不同的语言。`Strings`文件可以创建在`Resources`文件夹中，或者可以放置在`Resources`目录内的`Base.lproj`文件夹中，这构成了iOS项目的基本地化项目文件夹（默认/回退资源）。
- en: 'For storyboards, the internationalization process can be a little more complicated.
    Each UI element in a storyboard is assigned a unique identifier called the **Object
    ID** in Xcode, while it is referred to as the **Localization ID** in Xamarin Storyboard
    Designer. In order to assign text content to a specific item on the storyboard,
    developers are required to create string files for each storyboard (for example,
    for a storyboard called `Main.storyboard`, you will need to create a `Main.strings`
    file) and use the localization ID of the specific control and the name of the
    text attribute:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故事板，国际化过程可能稍微复杂一些。Xcode 中每个故事板中的 UI 元素都被分配了一个唯一的标识符，称为 **Object ID**，而在 Xamarin
    Storyboard Designer 中则被称为 **Localization ID**。为了将文本内容分配给故事板上的特定项，开发者需要为每个故事板创建字符串文件（例如，对于名为
    `Main.storyboard` 的故事板，你需要创建一个 `Main.strings` 文件），并使用特定控件的本地化 ID 和文本属性的名称：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As one can see, the attribute names and casings are clearly different from the
    actual type properties of UI controls (for example, `text` for `UILabel`, `normalTitle`
    for `UIButton`). The iOS internationalization guidelines can provide details on
    the storyboard attributes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，属性名称和大小写与 UI 控件的实际类型属性（例如，`text` 对于 `UILabel`，`normalTitle` 对于 `UIButton`）明显不同。iOS
    国际化指南可以提供有关故事板属性的详细信息。
- en: Another way to create the base internationalization file for a storyboard is
    to use Xcode to generate the `string` file. In order to modify the Xamarin.iOS
    project with Xcode, the **Open With** context menu item can be used to select
    **Xcode Interface Builder** for a storyboard and the main project window to access
    the project properties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建故事板的基础国际化文件的另一种方法是使用 Xcode 生成 `string` 文件。为了使用 Xcode 修改 Xamarin.iOS 项目，可以使用
    **打开方式** 右键菜单项选择 **Xcode Interface Builder** 以访问故事板和主项目窗口的项目属性。
- en: '![Xamarin.iOS](img/B04693_09_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.iOS](img/B04693_09_02.jpg)'
- en: 'Figure 2: Xcode Interface Builder'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：Xcode Interface Builder
- en: In the Xcode interface, the localization settings are located on the project
    settings page. If the base localization folder was created beforehand, the **Base
    Localization** option will already be checked in the project settings localization
    section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 界面中，国际化设置位于项目设置页面。如果事先创建了基础国际化文件夹，项目设置国际化部分中的 **基础国际化** 选项将已经选中。
- en: '![Xamarin.iOS](img/B04693_09_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.iOS](img/B04693_09_03.jpg)'
- en: 'Figure 3: Xcode project configuration'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：Xcode 项目配置
- en: Any additional language selection generates a language specific `.lproj` folder
    and the `.strings` file for the targeted storyboards and strings files. Once the
    Xcode window is closed, these changes will be reflected in the Xamarin.iOS project
    structure.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何额外的语言选择都会生成特定语言的 `.lproj` 文件夹和目标故事板及字符串文件的 `.strings` 文件。一旦关闭 Xcode 窗口，这些更改将在
    Xamarin.iOS 项目结构中反映出来。
- en: Windows Phone
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows Phone
- en: In Windows Phone (Silverlight) projects, resources are managed through traditional
    `resx` files (a legacy of the .NET framework). The default language resources
    are generated with the project template and stored in the `AppResources.resx`
    file, located under the `Resources` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Phone (Silverlight) 项目中，资源通过传统的 `resx` 文件管理（.NET 框架的遗留）。默认语言资源由项目模板生成并存储在
    `Resources` 文件夹下的 `AppResources.resx` 文件中。
- en: '![Windows Phone](img/B04693_09_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Phone](img/B04693_09_04.jpg)'
- en: 'Figure 4: Windows Phone resources'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：Windows Phone 资源
- en: 'Additional types of content that can be embedded in the resources file are
    images, icons, audio, and other types of files. These files can be accessed through
    code and also in markup, using the generated `AppResources` class. Another generated
    class, `LocalizedStrings`, provides access to the resources stored in the embedded
    resource file(s):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以嵌入到资源文件中的其他内容类型包括图像、图标、音频和其他类型的文件。这些文件可以通过代码和标记来访问，使用生成的 `AppResources` 类。另一个生成的类
    `LocalizedStrings` 提供了对存储在嵌入的资源文件中的资源的访问：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Windows Phone 8.1 (that is, Windows Runtime) and Windows 10, the applications
    use a `resw` file (called `PRIResource`, referring to the compilation method).
    Even though the format of `resx` and `resw` files is identical, `resw` files can
    only contain primitive values (that is, string values or values that can be expressed
    as strings). Using `resw` files, developers can assign style or other attribute
    values directly to user controls using the `Uid` value of the controls, similar
    to the internationalization of storyboards on iOS.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Phone 8.1（即 Windows Runtime）和 Windows 10 中，应用程序使用 `resw` 文件（称为 `PRIResource`，指代编译方法）。尽管
    `resx` 和 `resw` 文件的格式相同，但 `resw` 文件只能包含原始值（即字符串值或可以表示为字符串的值）。使用 `resw` 文件，开发者可以直接使用控件的
    `Uid` 值将样式或其他属性值分配给用户控件，类似于iOS上故事板的国际化。
- en: '![Windows Phone](img/B04693_09_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Phone](img/B04693_09_05.jpg)'
- en: 'Figure 5: Windows Runtime PRI resources'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：Windows Runtime PRI 资源
- en: In addition to the targeted resources, developers are still free to use simple
    resource strings. These resources can be accessed using the `ResourceLoader` class
    and the `GetString` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了目标资源外，开发者仍然可以自由使用简单的资源字符串。这些资源可以通过 `ResourceLoader` 类和 `GetString` 方法访问。
- en: Image resources
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像资源
- en: Mobile application projects can contain media assets from external sources as
    well as the application bundle. In each target platform, media assets can be included
    in different ways.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序项目可以包含来自外部来源的媒体资源以及应用程序包。在每一个目标平台上，媒体资源可以通过不同的方式包含在内。
- en: While iOS and Windows Phone do not dictate a certain location in the project
    tree for media assets, in Android projects, developers are obliged to include
    image documents in the `drawable` folder of the `Resources` directory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 iOS 和 Windows Phone 没有规定媒体资源在项目树中的特定位置，但在 Android 项目中，开发者有义务将图像文档包含在 `Resources`
    目录下的 `drawable` 文件夹中。
- en: '![Image resources](img/B04693_09_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图像资源](img/B04693_09_06.jpg)'
- en: 'Figure 6: Project structures'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：项目结构
- en: Similar to the text resource structure on the iOS platform, it is advisable
    to place language-neutral image elements (for the default language) in the `Base.lproj`
    location if you are planning to localize them in later iterations. Also, asset
    catalogs can be employed to simplify the management of images and their pixel-perfect
    alternatives for different resolutions (see the *Adaptive visual assets* section).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS平台上的文本资源结构类似，如果你计划在后续迭代中进行本地化，建议将语言中立的图像元素（针对默认语言）放置在 `Base.lproj` 位置。此外，还可以使用资产目录来简化图像及其不同分辨率下的像素完美替代物的管理（参见
    *自适应视觉资源* 部分）。
- en: Adaptive visual assets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自适应视觉资源
- en: Adaptive UI patterns for applications targeting Xamarin platforms force developers,
    at times, to include variations of media assets for different resolutions and
    pixel densities. Even though the image resources are scaled according to the aforementioned
    adaptive UI metrics, the scaled images do not always result in visually pleasing
    displays (for example, an image resized to double the original size, to have the
    same physical screen dimensions on different devices, does not appear as it should).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 针对Xamarin平台的自适应UI模式有时迫使开发者包含不同分辨率和像素密度的媒体资源变体。尽管图像资源根据上述自适应UI指标进行了缩放，但缩放后的图像并不总是能呈现出令人满意的效果（例如，将图像大小调整为原始大小的两倍，以在不同设备上具有相同的物理屏幕尺寸，其显示效果可能并不如预期）。
- en: The Android platform uses the device compatibility configuration qualifiers
    for both image and text resource folders (that is, `drawables` and `values`),
    as well as other types of resources, such as layouts. In such projects, compatibility
    qualifiers are concatenated to the resource folder as a suffix (for example, the
    `drawables-xhdpi` folder can be used to provide images specific to extra high
    density device displays of approximately 320 dpi) and various default resources
    are added to this folder. Compatibility configuration not only deals with pixel
    density, but also provides selectors for mobile network related switches (that
    is, **MCC** (**mobile country code**) and **MNC** (**mobile network code**)),
    language, and region (see the *Localization* section), layout direction (that
    is, left to right or right to left), various screen size-related options, screen
    orientation, UI mode (related to the platform displaying the application—a car,
    desk, television, appliance, or watch), night mode (that is, day or night), input
    type-related configurations, and finally the platform API level/version.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台使用设备兼容性配置限定符来处理图像和文本资源文件夹（即`drawables`和`values`），以及其他类型的资源，例如布局。在这些项目中，兼容性限定符作为后缀连接到资源文件夹（例如，`drawables-xhdpi`文件夹可以用来提供针对大约320
    dpi的超高密度设备显示的特定图像）并且向此文件夹添加各种默认资源。兼容性配置不仅处理像素密度，还提供与移动网络相关开关的选择器（即**MCC**（**移动国家代码**）和**MNC**（**移动网络代码**）），语言，和地区（见*本地化*部分），布局方向（即从左到右或从右到左），与屏幕尺寸相关的各种选项，屏幕方向，UI模式（与显示应用程序的平台相关——汽车、桌面、电视、家电或手表），夜间模式（即白天或夜晚），与输入类型相关的配置，最后是平台API级别/版本。
- en: On the iOS platform, image assets can be individually suffixed to provide different
    versions of the same image for different resolutions and device idioms (that is,
    iPhone, iPod, and iPad). Device idiom values (that is, device modifiers) are used
    with the tilde (`~`) character and can identify resources for iPhone and iPod
    using the `~iphone` suffix and resources for iPad using the `~ipad` suffix. The
    `@2x` suffix, which should appear before the device modifier, is used to identify
    high resolution image variants.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS平台上，可以通过添加不同的后缀为图像资产提供不同分辨率和设备风格的同一图像版本（即iPhone、iPod和iPad）。设备风格值（即设备修饰符）与波浪号（`~`）字符一起使用，可以使用`~iphone`后缀识别iPhone和iPod的资源，使用`~ipad`后缀识别iPad的资源。`@2x`后缀，应出现在设备修饰符之前，用于识别高分辨率图像变体。
- en: 'Before the introduction of Windows Phone 8.1, the Windows Phone operating system
    only supported four variations: WVGA (480 x 800, only used by WP 7.1), WXGA (768
    x 1280), 720p (720 x 1280), and 1080p (1080 x 1920). The only way to differentiate
    between these resolutions was to use the `App.Current.Host.ScaleFactor` device
    configuration property (for example, a scale factor of 100 refers to WVGA and
    150 refers to HD). Windows Store apps (including Windows Phone 8.1) provide an
    automated scaling mechanism similar to that of iOS and Android. On the Windows
    Phone 8.1 platform, each resource file and/or folder can be suffixed with various
    qualifiers to support multiple display scales, languages and regions, contrasts,
    and similar, to tailor a customized look and feel for different device configurations.
    If the qualifiers are applied to a specific file, each qualifier/value pair should
    be separated by an underscore and added between the filename and the extension
    (that is, `filename.qualifiername-value_otherqualifier-value.fileextension`).
    If the qualifiers are applied to complete folders, for each qualifier/value, a
    subfolder should be created (that is, `resourcefolder/qualifier-value/otherqualifier-value/`).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Phone 8.1引入之前，Windows Phone操作系统仅支持四种变体：WVGA（480 x 800，仅用于WP 7.1）、WXGA（768
    x 1280）、720p（720 x 1280）和1080p（1080 x 1920）。区分这些分辨率的唯一方法是使用`App.Current.Host.ScaleFactor`设备配置属性（例如，100的缩放因子表示WVGA，150表示HD）。Windows
    Store应用程序（包括Windows Phone 8.1）提供了一种类似于iOS和Android的自动缩放机制。在Windows Phone 8.1平台上，每个资源文件和/或文件夹都可以添加各种限定符以支持多个显示比例、语言和地区、对比度等，以针对不同的设备配置定制外观和感觉。如果限定符应用于特定文件，则每个限定符/值对应通过下划线分隔，并添加在文件名和扩展名之间（即`filename.qualifiername-value_otherqualifier-value.fileextension`）。如果限定符应用于完整文件夹，则对于每个限定符/值，应创建一个子文件夹（即`resourcefolder/qualifier-value/otherqualifier-value/`）。
- en: 'For instance, see the following project path:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看以下项目路径：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can be accessed with the `Images/myImage.png` resource path.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`Images/myImage.png`资源路径访问。
- en: Reusable assets
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用资产
- en: Managing media assets in cross platform projects, especially if you are providing
    variations for different device configurations, can become quite a hurdle. In
    order to reuse these assets for multiple platforms, linked file references can
    be utilized (**Add** | **Existing Item** | **Add as Link**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台项目中管理媒体资产，尤其是如果你为不同的设备配置提供变体时，可能会变得相当困难。为了在多个平台上重用这些资产，可以利用链接文件引用（**添加**
    | **现有项** | **添加为链接**）。
- en: '![Reusable assets](img/B04693_09_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![可重用资产](img/B04693_09_07.jpg)'
- en: 'Figure 7: Add resource as link'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：将资源作为链接添加
- en: Using this strategy, image documents can be included in a common location for
    all platform-specific projects (for example, the common portable library), and
    only linked file references can be added to platform-specific projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，图像文档可以包含在所有特定平台项目的公共位置（例如，公共便携式库），并且只需将链接文件引用添加到特定平台项目中。
- en: This way, image documents are not copied to multiple locations, but only compiled
    into different platform-specific projects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，图像文档不会被复制到多个位置，而只是编译到不同的特定平台项目中。
- en: '![Reusable assets](img/B04693_09_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![可重用资产](img/B04693_09_08.jpg)'
- en: 'Figure 8: Linked resources for normal and high definition in Windows Phone
    and Android projects'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Windows Phone和Android项目中正常和高清晰度的链接资源
- en: Text resources in a cross-platform project do not differ greatly between platforms,
    especially if the resources in question are simple string values, rather than
    targeted attributes for UI controls (for example, text content specified for a
    label or a button on a storyboard). Another observation is that most of the text
    resource values are handled as key/value pairs in XML format (for Windows Phone
    and Android) or with simple JavaScript-like notation (in iOS). Elaborating on
    these assumptions, we can create an automated process that evaluates a common
    resource file and creates/generates the resource strings for the target platforms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台项目中，文本资源在不同平台之间差异不大，尤其是如果涉及的资源是简单的字符串值，而不是针对UI控件的特定属性（例如，在故事板中指定的标签或按钮的文本内容）。另一个观察结果是，大多数文本资源值都以XML格式（针对Windows
    Phone和Android）或简单的JavaScript-like表示法（在iOS中）作为键/值对处理。基于这些假设，我们可以创建一个自动化的过程，该过程评估一个通用的资源文件，并为目标平台创建/生成资源字符串。
- en: Considering the fact that we will use either a shared project library or a portable
    class library that will contain the shared code for the platform specific projects,
    this common project would be the most appropriate location to store the common
    resource strings. We can use this project to create the common resource package
    in the `resx` format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们将使用一个共享的项目库或便携式类库，该库将包含针对特定平台项目的共享代码，这个通用项目将是存储通用资源字符串的最合适位置。我们可以使用此项目创建`resx`格式的通用资源包。
- en: These embedded resource files, as previously mentioned, are simple XML files
    in which the string resources pairs are stored in `<data>` nodes with the `name`
    attribute as the key and the `<value>` text node as the value (the rest of the
    file contains the XSD schema and metadata values for code generation).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些嵌入式资源文件是简单的XML文件，其中字符串资源对存储在具有`name`属性作为键的`<data>`节点中，以及`<value>`文本节点作为值（文件的其余部分包含用于代码生成的XSD架构和元数据值）。
- en: '![Reusable assets](img/B04693_09_09.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![可重用资产](img/B04693_09_09.jpg)'
- en: 'Figure 9: Resx file XML structure'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：Resx文件XML结构
- en: Android string resources have a similar structure with less complexity and different
    node names (that is, resource values are represented with `<string>` text nodes
    with the attribute `name`). Conversion between the two XML files is fairly simple
    with an XSL transformation in Visual Studio.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Android字符串资源结构与复杂性较低，节点名称不同（即，资源值由具有`name`属性的`<string>`文本节点表示）。在Visual Studio中使用XSL转换在两个XML文件之间进行转换相对简单。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XSL is an abbreviation for Extensible Stylesheet Language and is used for transforming
    XML documents from one format to another. XSLT files may utilize templates, XPath
    queries, and other XSL functions to process XML document content. More information
    can be found at [http://www.w3schools.com/xsl/default.asp](http://www.w3schools.com/xsl/default.asp).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: XSL是可扩展样式表语言的缩写，用于将XML文档从一种格式转换为另一种格式。XSLT文件可以使用模板、XPath查询和其他XSL函数来处理XML文档内容。更多信息可以在[http://www.w3schools.com/xsl/default.asp](http://www.w3schools.com/xsl/default.asp)找到。
- en: 'To transform the resource file into the Android format, we will create an XSLT
    file in the same folder as the `AppResources.resx` file in the common project.
    In order to create the Android XML resource file, we need to select each `<data>`
    element from the `<root>` node and create `<string>` nodes with appropriate text
    content and attributes inside the `<resources>` root node:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要将资源文件转换为 Android 格式，我们将在通用项目中的 `AppResources.resx` 文件相同的文件夹中创建一个 XSLT 文件。为了创建
    Android XML 资源文件，我们需要从 `<root>` 节点中选择每个 `<data>` 元素，并在 `<resources>` 根节点内创建具有适当文本内容和属性的
    `<string>` 节点：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, after this step, we can use the XML menu to debug the XSLT file using
    the `resx` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成此步骤后，我们可以使用 XML 菜单通过 `resx` 文件来调试 XSLT 文件：
- en: '![Reusable assets](img/B04693_09_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![可重用资产](img/B04693_09_10.jpg)'
- en: 'Figure 10: XSL Transformation debug session in Visual Studio'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10：Visual Studio 中的 XSL 转换调试会话
- en: After confirming that the transformation works as expected, we can now automate
    this process to regenerate the strings file every time the common project is rebuilt.
    For this automation, we can use a third-party XML transformation command line
    application and add the console command as a pre-build event command line argument
    using the project settings. Another option would be to use the out-of-box `MSBuild`
    task `XslTransformation` to add a `BeforeBuild` target.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 确认转换按预期工作后，我们现在可以自动化此过程，以便每次重建通用项目时都重新生成字符串文件。为此自动化，我们可以使用第三方 XML 转换命令行应用程序，并通过项目设置将控制台命令作为预构建事件命令行参数添加。另一个选项是使用内置的
    `MSBuild` 任务 `XslTransformation` 来添加 `BeforeBuild` 目标。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to add new build targets, the `csproj` file needs to be modified in
    Visual Studio. For this purpose, the common project first needs to be unloaded
    using **Unload Project** from the project context menu, and the project file can
    be edited using the **Edit <Project File Name>** option from the same context
    menu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加新的构建目标，需要在 Visual Studio 中修改 `csproj` 文件。为此，首先需要使用项目上下文菜单中的 **卸载项目** 选项卸载通用项目，然后可以从相同的上下文菜单中选择
    **编辑 <项目文件名>** 选项来编辑项目文件。
- en: 'The `XslTransformation` task is a simple build task with three basic parameters
    for the XML file that needs to be transformed (that is, `XmlInputPath`), the XSL
    file to be used for the transformation (that is, `XslInputPath`), and finally
    the output path (that is, `OutputPaths`):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`XslTransformation` 任务是一个简单的构建任务，有三个基本参数用于需要转换的 XML 文件（即 `XmlInputPath`），用于转换的
    XSL 文件（即 `XslInputPath`），以及最终的输出路径（即 `OutputPaths`）：'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this modification, every time the common project is built (with a default
    setup, the common project should be built before the Android project), the `strings.xml`
    file will be generated and placed into the values folder in the Android project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此修改，每次构建通用项目（默认设置下，通用项目应在 Android 项目之前构建）时，`strings.xml` 文件将被生成并放置在 Android
    项目的 values 文件夹中。
- en: 'The same transformation approach is applicable to the iOS localized `strings`
    files. In an iOS-specific transformation, the output should be set to text and
    the transformation style sheet should create the key/value pairs. In order to
    create the lines of text for each data element in the embedded resource file,
    the `concat` function can be utilized:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的转换方法也适用于 iOS 本地化的 `strings` 文件。在 iOS 特定的转换中，输出应设置为文本，转换样式表应创建键/值对。为了为嵌入的资源文件中的每个数据元素创建文本行，可以利用
    `concat` 函数：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this stylesheet, it is important to note that text elements (symbols), such
    as double quotes and carriage return (that is, line feed and end of line), are
    HTML encoded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此样式表中，需要注意的是，文本元素（符号），如双引号和换行符（即行结束），是 HTML 编码的。
- en: 'Once the transformation result is confirmed, we can add another `XslTransformation`
    task to the project file as a `BeforeBuild` target to create the localized `strings`
    file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认转换结果，我们可以在项目文件中添加另一个 `XslTransformation` 任务作为 `BeforeBuild` 目标来创建本地化的 `strings`
    文件：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the same implementation, the translation values containing the `resx`
    files can be transformed and used to generate localized resources for the target
    platforms. In addition to XSL transformations, T4 templates can also be used to
    generate the text resource files. Since certain build tasks (including `XslTransformation`)
    are not yet supported by xBuild and Xamarin Studio, T4 templates can provide an
    alternative if your main development environment is Mac OS and main development
    IDE is Xamarin Studio. With T4 templates, it is also possible to iterate through
    each file in the common resources and generate matching localization files in
    platform-specific projects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的实现，包含 `resx` 文件的翻译值可以转换并用于为目标平台生成本地化资源。除了 XSL 转换之外，T4 模板也可以用来生成文本资源文件。由于某些构建任务（包括
    `XslTransformation`）尚未被 xBuild 和 Xamarin Studio 支持，如果您的开发环境主要是 Mac OS 且主要开发 IDE
    是 Xamarin Studio，则 T4 模板可以提供一种替代方案。使用 T4 模板，还可以遍历通用资源中的每个文件并生成平台特定项目中匹配的本地化文件。
- en: The next section will summarize the localization strategies on Xamarin target
    platforms.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将总结在 Xamarin 目标平台上的本地化策略。
- en: Localization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化
- en: Localization and globalization are the two fundamental concepts of mobile applications.
    In the previous sections, we discussed different ways of separating visual content
    from the rest of the application. This process, in essence, prepares the mobile
    application to be localized and is generally a part of the globalization phase.
    Globalized applications should function the same way, independent of the culture
    or locale they are being executed on. During localization, developers are supposed
    to create language-specific resources and integrate them into the globalized applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化和全球化是移动应用的两个基本概念。在前几节中，我们讨论了将视觉内容与应用程序其余部分分离的不同方法。这个过程本质上是为移动应用本地化做准备，通常是全球化阶段的一部分。全球化应用应独立于它们正在执行的
    culture 或 locale 运行，功能相同。在本地化过程中，开发者应创建特定语言的资源并将它们集成到全球化应用程序中。
- en: Locale and culture
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区域设置和文化
- en: Locale can be defined as the umbrella term that includes all regional configurations
    on a specific device (or a specific application in some cases). The locale not
    only represents the user interface language, but also the formats used to display
    dates, times, numbers, and currency values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置可以定义为包括特定设备（或在某些情况下特定应用程序）上所有区域配置的通用术语。区域设置不仅代表用户界面语言，还包括用于显示日期、时间、数字和货币值的格式。
- en: As part of the globalization effort, in Xamarin target platforms, developers
    first need to identify which languages are going to be supported as part of the
    localization effort. A mobile application, after it is published and installed
    by the user, should manifest the supported languages so that the user interface
    can be rendered either with the locale that is dictated by the operating system
    (if supported) or the default/fallback language of the application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为全球化工作的一部分，在 Xamarin 目标平台上，开发者首先需要确定哪些语言将作为本地化工作的一部分得到支持。一旦用户发布并安装了移动应用，它应显示支持的语言，以便用户界面可以使用操作系统指定的区域设置（如果支持）或应用程序的默认/后备语言进行渲染。
- en: The supported languages manifest is a calculated value according to the resources
    provided (Android) or a pre-declared manifest or project entry (iOS and Windows
    Phone).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的语言清单是根据提供的资源（Android）或预先声明的清单或项目条目（iOS 和 Windows Phone）计算得出的值。
- en: Windows Phone
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows Phone
- en: In Windows Phone Silverlight application projects, resources for different languages
    can be provided using resource packages according to the naming conventions. The
    provided packages should then be referenced in the `WMAppManifest.xml` file. The
    easiest way to include additional language support for a Windows Phone application
    is to use the project properties to identify the supported cultures.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Phone Silverlight 应用程序项目中，可以根据命名约定使用资源包提供不同语言的资源。然后应在 `WMAppManifest.xml`
    文件中引用提供的包。为 Windows Phone 应用程序添加额外的语言支持的最简单方法是通过项目属性来识别支持的文化。
- en: '![Windows Phone](img/B04693_09_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Phone](img/B04693_09_11.jpg)'
- en: 'Figure 11: Project Properties for Windows Phone Silverlight application'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11：Windows Phone Silverlight 应用程序的项目属性
- en: Once the project configuration modifications are saved, Visual Studio automatically
    creates the associated `resx` files (for example, `AppResources.bs.resx` for Bosnian,
    `AppResources.tr-TR.resx` for Turkish) and updates the application manifest. The
    default language can be modified from the package manifest (that is, `package.appxmanifest`)
    or the application manifest (`WMAppManifest.xml`) designers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目配置修改后，Visual Studio 会自动创建相关的 `resx` 文件（例如，为波斯尼亚语创建 `AppResources.bs.resx`，为土耳其语创建
    `AppResources.tr-TR.resx`）并更新应用程序清单。默认语言可以从包清单（即 `package.appxmanifest`）或应用程序清单（`WMAppManifest.xml`）设计器中进行修改。
- en: 'Windows Store applications (that is, Windows Phone 8.1) are globalized using
    folders named after the supported languages containing the `resw` resource files.
    For instance, in order to create an application that targets the same cultures
    as the previous example, we would need to create a folder structure and culture-specific
    resource files similar to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Store 应用程序（即 Windows Phone 8.1）使用以支持的语言命名的文件夹进行全球化，其中包含 `resw` 资源文件。例如，为了创建一个针对与上一个示例相同文化的应用程序，我们需要创建一个类似以下的文件夹结构和特定文化资源文件：
- en: '![Windows Phone](img/B04693_09_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Phone](img/B04693_09_12.jpg)'
- en: 'Figure 12: Windows Store apps supported cultures and app bundle'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12：Windows Store 应用支持的文化和应用程序包
- en: Once the application package is created, you will notice that instead of a single
    application package, an application bundle is created and each supported culture
    has an associated store app package in the bundle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建完应用程序包，你会注意到，除了单个应用程序包外，还会创建一个应用程序包，并且每个支持的文化都关联一个存储应用程序包在该包中。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Application bundles are used in Windows Store applications to reduce the size
    of the application packages that users are going to download for specific CPU
    architecture (ARM, x86, or x64), display hardware (image and other media assets,
    optimized for different resolutions), or locale. The packaging strategy can be
    selected while creating application packages, but if bundling is declined, developers
    are required to create a different upload package for each CPU architecture they
    are planning to support with their applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包在 Windows Store 应用中使用，以减少用户为特定 CPU 架构（ARM、x86 或 x64）、显示硬件（图像和其他媒体资产，针对不同分辨率进行优化）或区域设置下载的应用程序包的大小。可以在创建应用程序包时选择打包策略，但如果放弃打包，开发者需要为计划支持其应用程序的每个
    CPU 架构创建不同的上传包。
- en: Xamarin.iOS
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin.iOS
- en: As previously explained, for Xamarin.iOS, once the additional languages are
    selected for the project in the Xcode development environment, generated localization
    folders and files are automatically added to the Xamarin.iOS project. The generated
    storyboard string files initially contain the possible localizable fields and
    the assigned values from the storyboard. Other string bundle resource files are
    copied with the same values from the `Base.lproj` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于 Xamarin.iOS，一旦在 Xcode 开发环境中为项目选择了附加语言，生成的本地化文件夹和文件将自动添加到 Xamarin.iOS
    项目中。生成的故事板字符串文件最初包含可能的本地化字段和从故事板分配的值。其他字符串包资源文件从 `Base.lproj` 文件夹复制相同的值。
- en: '![Xamarin.iOS](img/B04693_09_13.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.iOS](img/B04693_09_13.jpg)'
- en: 'Figure 13: Localized Xamarin.iOS project'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13：本地化的 Xamarin.iOS 项目
- en: When using text resource files for localization, the `LocalizedString` function
    for the `MainBundle` property either returns the value that matches the current
    user language selection or the default value defined in the `Base.lproj` directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用文本资源文件进行本地化时，`MainBundle` 属性的 `LocalizedString` 函数要么返回与当前用户语言选择匹配的值，要么返回在
    `Base.lproj` 目录中定义的默认值。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using Visual Studio for creating and editing the `strings` files, it is
    a good idea to map the `strings` extension to JavaScript editor using the **Options**
    dialog and the **Text Editor** | **File Extension** section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Visual Studio 创建和编辑 `strings` 文件时，使用 **选项** 对话框和 **文本编辑器** | **文件扩展名** 部分将
    `strings` 扩展名映射到 JavaScript 编辑器是一个好主意。
- en: 'In order to load a language-specific resource that does not match the current
    preferred language(s) configuration, you will need to use the localization bundle
    path and retrieve the localized resources using the same function on this bundle:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载与当前首选语言（或语言）配置不匹配的语言特定资源，你需要使用本地化包路径，并使用此包上的相同函数检索本地化资源：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The native development language directory (that is, `Base.lproj`), as well as
    the language-specific folders, can also be used to store other types of bundle
    resources, such as image resources, storyboards, XIB files, or even language-specific
    `Info.plist` files. (The `InfoPlist.strings` file in a language directory can
    be used to override values from the application's `Info.plist` file, such as the
    application name.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 原生开发语言目录（即，`Base.lproj`），以及特定语言的文件夹，也可以用来存储其他类型的包资源，例如图像资源、故事板、XIB文件，甚至是特定语言的`Info.plist`文件。（语言目录中的`InfoPlist.strings`文件可以用来覆盖应用程序`Info.plist`文件中的值，例如应用程序名称。）
- en: It is crucial to add the supported languages to the info manifest. For localization,
    there are two relevant keys. The first relevant item is the *Localization* native
    development region (that is, `CFBundleDevelopmentRegion`) and the second key is
    the *Localizations* (that is, `CFBundleLocalizations`). While the native development
    region defines the language associated with the `Base.lproj` location, the localizations
    entries provide information about the other supported localizations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 向信息清单中添加支持的语言至关重要。对于本地化，有两个相关的键。第一个相关项是*本地化*原生开发区域（即，`CFBundleDevelopmentRegion`），第二个键是*本地化*（即，`CFBundleLocalizations`）。虽然原生开发区域定义了与`Base.lproj`位置关联的语言，但本地化条目提供了有关其他支持本地化的信息。
- en: Xamarin.Android
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin.Android
- en: Localization in Xamarin.Android projects, similar to the folder structure of
    Windows Phone 8.1 projects, is achieved using a specific folder structure with
    the language code suffixed into the localized resource items (for example, `drawable-tr`
    or `values-en`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Android项目中，本地化与Windows Phone 8.1项目的文件夹结构类似，通过特定的文件夹结构实现，语言代码附加到本地化资源项中（例如，`drawable-tr`或`values-en`）。
- en: '![Xamarin.Android](img/B04693_09_14.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.Android](img/B04693_09_14.jpg)'
- en: 'Figure 14: Android localization folder structure'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：Android本地化文件夹结构
- en: An appropriate resource is selected in the runtime using a simple elimination
    algorithm that selects the correct resource file according to the locale, display
    density, display size, touch support, and other criteria.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，通过一个简单的消除算法选择合适的资源，该算法根据地区、显示密度、显示大小、触摸支持和其他标准选择正确的资源文件。
- en: Xamarin.Forms
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin.Forms
- en: The Xamarin.Forms portable class library project template provides the ideal
    environment for text resource sharing. In this setup, with a process similar to
    Windows Phone Silverlight projects, `resx` files can be used to create resource
    bundles that can be used to localize the cross-platform views created with Xamarin.Forms
    framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms便携式类库项目模板提供了一个理想的文本资源共享环境。在这个设置中，与Windows Phone Silverlight项目类似的过程，可以使用`resx`文件创建资源包，这些资源包可以用来本地化使用Xamarin.Forms框架创建的跨平台视图。
- en: '![Xamarin.Forms](img/B04693_09_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin.Forms](img/B04693_09_15.jpg)'
- en: 'Figure 15: Localized Xamarin.Forms resources'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：本地化的Xamarin.Forms资源
- en: Once the embedded resource files and their translation counterparts are added
    to the common PCL project, the resource entries can be accessed using the generated
    static class. In order for the generated class to be accessible from the platform
    specific implementations, the **Custom Tool** property of the resource file must
    be set to `PublicResXFileCodeGenerator` and the **Build Action** property to `Embedded
    Resource`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将嵌入的资源文件及其翻译对应的文件添加到公共PCL项目中，就可以使用生成的静态类来访问资源条目。为了使生成的类可以从特定平台实现中访问，资源文件的**自定义工具**属性必须设置为`PublicResXFileCodeGenerator`，而**构建操作**属性必须设置为`Embedded
    Resource`。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: With Xamarin Studio or Visual Studio, the file properties window can be used
    to set to the correct access modifier for the resource accessors. In Visual Studio,
    the resource editor can also be used to correct the access modifier of resource
    items (that is, select **Access Modifier** | **Public** using the resource designer).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Xamarin Studio或Visual Studio，可以通过文件属性窗口设置资源访问器的正确访问修饰符。在Visual Studio中，资源编辑器也可以用来修正资源项的访问修饰符（即，使用资源设计器选择**访问修饰符**
    | **Public**）。
- en: In the Windows Phone runtime, the correct resource files are loaded according
    to the current thread culture, so the preceding implementation would automatically
    choose the appropriate embedded resource. However, supported languages should
    still be configured using the application manifest. In Xamarin.iOS, the correct
    resources are loaded according to the users' language preferences (not the current
    UI language) and supported languages should be included in the `Info.plist` file
    using the `CFLocalizations` entry. For the Android platform, UI language selection
    is taken as the identifier for the resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Phone 运行时，根据当前线程的文化，正确加载资源文件，因此先前的实现会自动选择合适的嵌入式资源。然而，支持的语言仍然需要通过应用程序清单进行配置。在
    Xamarin.iOS 中，根据用户的语言偏好（而不是当前 UI 语言）加载正确的资源，并且应使用 `CFLocalizations` 条目将支持的语言包含在
    `Info.plist` 文件中。对于 Android 平台，UI 语言选择被视为资源的标识符。
- en: 'The following implementation would localize the tabbed page implementation
    from the previous chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现将本地化前一章中的选项卡页实现：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding example, the highlighted line of code sets the accessor properties
    to specific resource elements. When using XAML for the same implementation, we
    can resort to statically bound properties using the `TextResources` generated
    class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，高亮显示的代码行将访问器属性设置为特定的资源元素。当使用 XAML 进行相同的实现时，我们可以求助于使用 `TextResources`
    生成的类进行静态绑定属性：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is important to include the CLR namespace containing the generated resource
    accessor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 包含生成的资源访问器的 CLR 命名空间是很重要的。
- en: Architectural patterns
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构模式
- en: The user interface of an application can be described as the packaging over
    the sum of all the moving parts underneath. As applications get more complex,
    the responsibilities of the user interface increase and it gets harder to package
    the product underneath. Leaving aside the static parts of the UI (that is, assets
    described in the previous sections of this chapter), it is the most volatile part
    of an application. In order to counteract the entropy that builds up throughout
    the application's lifetime, solve recurring problem patterns, and re-use modules,
    developers often utilize certain design patterns in their development efforts.
    Especially in cross-platform projects, the importance of these architectural design
    patterns have been proven to be irrefutable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的用户界面可以描述为对下面所有移动部分的封装。随着应用程序变得更加复杂，用户界面的责任也在增加，封装下面的产品变得更加困难。抛开 UI 的静态部分（即本章前几节中描述的资产），它是应用程序中最易变的部分。为了对抗整个应用程序生命周期中积累的熵，解决重复的问题模式，以及重用模块，开发者通常会在他们的开发工作中利用某些设计模式。特别是在跨平台项目中，这些架构设计模式的重要性已经被证明是无可辩驳的。
- en: For demonstration purposes, let's use a simple form-submit scenario. In this
    implementation, the users will be greeted with a form they will have to fill in.
    Once all the required text fields are populated by the user, he/she will submit
    the content using the submit button. The data is then validated and stored. The
    user should then be informed about the submission with a read-only screen where
    he/she can see the submitted and stored data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，让我们使用一个简单的表单提交场景。在这个实现中，用户将看到一个需要填写的表单。一旦用户填写了所有必需的文本字段，他/她将通过提交按钮提交内容。然后验证数据并存储。用户应该随后通过一个只读屏幕被告知提交情况，在该屏幕上他/她可以看到提交和存储的数据。
- en: '![Architectural patterns](img/B04693_09_16.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![架构模式](img/B04693_09_16.jpg)'
- en: 'Figure 16: The classic *n*-tier scenario'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16：经典的 *n* 层场景
- en: In an *n*-tier implementation, the presentation tier would be responsible for
    visualizing the data and would hold an instance of the API façade. The API façade
    would implement the business logic to validate the information and submit it to
    the data tier instance. The data tier would be solely responsible for communicating
    with the persistence store (possibly through the service layer).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *n* 层实现中，表示层将负责可视化数据并持有 API 门面实例。API 门面将实现业务逻辑以验证信息并将其提交给数据层实例。数据层将仅负责与持久存储进行通信（可能通过服务层）。
- en: The event subscriptions (that is, text field changed or submit button clicked)
    would be implemented in the presentation layer. On successful submission, the
    presentation layer would pass on the current API object to a new presentation
    container and visualize the submitted data. Even though this approach provides
    a clear separation between the tiers, there are still strong ties between the
    layers in the hierarchy (that is, the presentation layer holds a strongly typed
    reference of the API and the API either reuses or creates a new instance of the
    data model). The application tier also creates an unnecessarily large and complex
    structure that should provide the required methods for all the containers and
    related scenarios in the presentation layer. The presentation layer still has
    the most responsibility in terms of event-driven implementation. If we transpose
    this implementation onto a Xamarin cross-platform project, we would be able to
    reuse the complete application tier and the data tier across platforms. However,
    it would still require quite a bit of re-implementation for the presentation layer
    for other platform projects, as this layer is responsible for using the API. Another
    downside of this pattern is the fact that, other than the façade, it isn't easy
    to unit test the implementation (that is, there are multiple event subscriptions
    on the presentation layer).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事件订阅（即文本字段更改或提交按钮点击）将在表示层中实现。在成功提交后，表示层会将当前的API对象传递给一个新的表示容器，并可视化提交的数据。尽管这种方法在层之间提供了清晰的分离，但在层次结构中（即表示层持有API的强类型引用，API要么重用或创建数据模型的新实例）仍然存在强烈的联系。应用程序层还创建了一个不必要的庞大且复杂的结构，该结构应提供所有容器和相关场景在表示层中所需的方法。在事件驱动实现方面，表示层仍然承担着最大的责任。如果我们把这个实现转移到Xamarin跨平台项目中，我们就能在各个平台上重用完整的应用程序层和数据层。然而，对于其他平台项目，仍然需要对表示层进行相当多的重新实现，因为这一层负责使用API。这种模式的另一个缺点是，除了门面之外，实现单元测试并不容易（即在表示层上有多个事件订阅）。
- en: '**MVP** (**model-view-presenter**) and **MVVM** (**model-view-viewmodel**),
    both derivatives of **MVC** (**model-view-controller**), try to answer some of
    these issues for classic *n*-tier implementations. Both of these patterns inherently
    use a passive presentation layer and delegate the main responsibility to the supervising
    or mediating component; the main reason for this is the fact that unit testing
    the view is generally impractical, hence it should be devoid of logic as much
    as possible. The presenter communicates with the data tier actively and is responsible
    for how the view should be visualized. In this paradigm, the only way the view
    communicates with the mediator is through routed events (separation of concerns).
    It is also important to note that in these architectural implementations, the
    application is divided into self-sufficient triads (that is, model, view, and
    presenter) which make up different use-cases and views in the application. Façades
    are generally used only in the model component.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVP**（**模型-视图-演示者**）和**MVVM**（**模型-视图-视图模型**），都是**MVC**（**模型-视图-控制器**）的衍生模式，试图解决经典*n*层实现中的一些问题。这两种模式本质上都使用一个被动的表示层，并将主要责任委托给监督或中介组件；这样做的主要原因是因为对视图进行单元测试通常是不切实际的，因此视图应尽可能不包含逻辑。演示者与数据层进行主动通信，并负责视图的视觉呈现。在这个范例中，视图与中介通信的唯一方式是通过路由事件（关注点分离）。还应注意，在这些架构实现中，应用程序被划分为自给自足的三元组（即模型、视图和演示者），它们构成了应用程序中的不同用例和视图。门面通常仅在模型组件中使用。'
- en: MVC
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC
- en: The MVC pattern was initially introduced into Smalltalk, and later on popularized
    with its (excessive) use in web applications and frameworks. In classic MVC implementation,
    the **Model** not only provides access to a data store but also implements any
    required business logic. The **Model** can be described as the core implementation
    of the problem domain, independent of the user interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式最初被引入到Smalltalk中，后来随着其在Web应用程序和框架中的（过度）使用而流行起来。在经典的MVC实现中，**模型**不仅提供对数据存储的访问，还实现了任何所需的企业逻辑。**模型**可以描述为问题域的核心实现，与用户界面无关。
- en: The **Controller** generally represents the logic stripped out of the **View**;
    it can send commands to the **Model** as well as the **View**, and receive the
    routed events from the **View**. Changes in state (that is, in the **Model**),
    are reflected on the **View** with or without the intervention of the **Controller**
    (classic MVC allows active or implicit interactions between the **Model** and
    the **View**).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**通常代表从**视图**中剥离的逻辑；它可以向**模型**以及**视图**发送命令，并从**视图**接收路由的事件。状态的变化（即在**模型**中），无论是否有**控制器**的干预，都会在**视图**上反映出来（经典的MVC允许**模型**和**视图**之间的主动或隐式交互）。'
- en: iOS app architecture
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS应用架构
- en: In iOS applications, the main development language hitherto has been Objective-C.
    The Cocoa and Cocoa Touch frameworks used for Mac OS and iOS application development,
    respectively, were also developed mainly in Objective-C. Considering the strong
    ties between Objective-C and SmallTalk, it is no surprise the main development
    pattern adopted and enforced by the iOS development kit is MVC.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS应用程序中，迄今为止主要开发语言一直是Objective-C。用于Mac OS和iOS应用程序开发的Cocoa和Cocoa Touch框架也主要用Objective-C开发。考虑到Objective-C和SmallTalk之间的紧密联系，iOS开发工具包采用和强制执行的主要开发模式是MVC也就不足为奇了。
- en: 'In the Cocoa version of MVC implementation, direct communication between the
    **View** and **Model** is completely abandoned (and prohibited) because of the
    technical requirements of the mobile application development environment, and
    in order to increase the reusability of model and view components. In this pattern,
    the **Controller** (also called the mediator at times) is given the main responsibility
    to control the flow of data between the **View** and the **Model**. From this
    aspect, Cocoa''s implementation of MVC undeniably resembles the MVP pattern:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cocoa版本的MVC实现中，由于移动应用程序开发环境的技术要求，**视图**和**模型**之间的直接通信完全放弃（并被禁止），并且为了提高模型和视图组件的可重用性。在这个模式中，**控制器**（有时也称为调解者）被赋予控制**视图**和**模型**之间数据流的主要责任。从这个角度来看，Cocoa对MVC的实现无疑类似于MVP模式：
- en: '![iOS app architecture](img/B04693_09_17.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![iOS应用架构](img/B04693_09_17.jpg)'
- en: 'Figure 17: Cocoa MVC'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：Cocoa MVC
- en: In this implementation schema, developers are encouraged to decouple the components
    of the triad from each other and implement the communication between them only
    through the defined abstractions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现方案中，鼓励开发人员将三联组件相互解耦，并通过定义的抽象来实现它们之间的通信。
- en: The separation between the **View** and the **Controller** is generally achieved
    with commands, outlets, and bindings. Commands provide actionable composites that
    can be passed from one layer to another, and outlets are extensions of certain
    UI elements so that the controller can subscribe to events and control how the
    UI is presented according to state.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**和**控制器**之间的分离通常通过命令、出口和绑定来实现。命令提供可执行的组合，可以从一层传递到另一层，出口是某些UI元素的扩展，以便控制器可以订阅事件并根据状态控制UI的呈现方式。'
- en: When view elements are designed using XIBs or storyboards (that is, storyboards
    are used to generate the XIBs at compile time), the outlets are defined as access
    points for the **View**-**Controller**. **View**-**Controllers** do not have a
    direct dependency on the **View**, nor does the **View** have any knowledge of
    the **Controller**. This setup complies with the separation of concerns principle
    and provides a loosely coupled structure as advised.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图元素使用XIBs或故事板（即在编译时使用故事板生成XIBs）设计时，出口被定义为**视图**-**控制器**的访问点。**视图**-**控制器**不直接依赖于**视图**，**视图**也没有任何关于**控制器**的知识。这种设置符合关注点分离原则，并提供了松散耦合的结构，正如建议的那样。
- en: If we were to implement the scenario from the previous example, we would be
    exposing two outlets for the text input fields in the submit form and an outlet
    for the submit button. These outlets would, in return, be used by the Controller
    assigned to the **View** for subscribing to certain events, to validate and submit
    the data. The **View**-**Controller** (that is, **UIController**) is also responsible
    for changing how the controls are displayed (for example, validation can change
    the color of the text input field) and communicating user actions such as the
    submission of data to the **Model**. Navigating to another view is also the responsibility
    of the **Controller** in this case.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实现前一个示例中的场景，我们将在提交表单中暴露两个文本输入字段的出口和一个提交按钮的出口。这些出口将反过来被分配给**视图**的控制器用于订阅某些事件，以验证和提交数据。**视图-控制器**（即**UIController**）还负责更改控件显示方式（例如，验证可以改变文本输入字段的颜色）以及将用户操作（例如，提交数据）与**模型**进行通信。在这种情况下，导航到另一个视图也是**控制器**的责任。
- en: '![iOS app architecture](img/B04693_09_18.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![iOS应用架构](img/B04693_09_18.jpg)'
- en: 'Figure 18: MVC demonstration on an iOS form'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图18：iOS表单上的MVC演示
- en: Segue navigation between views is another possible navigation strategy when
    the Controller for the new **View** exists in the calling **Controller**, or the
    same UI controller is used for both of the views (that is, the same **Controller**
    could have been used for both submit and read-only views in the preceding example).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当新**视图**的控制器存在于调用**控制器**中，或者两个视图都使用相同的UI控制器（即，在先前的示例中，相同的**控制器**可以用于提交和只读视图）时，视图之间的segue导航是另一种可能的导航策略。
- en: MVVM
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM
- en: '**MVVM** (**Model-View-ViewModel**), a derivative of the MVP pattern, provides
    well-established boundaries between the UI, business logic, and data. After its
    emergence, it almost immediately became the main implementation pattern for **WPF**
    (**Windows Presentation Foundation**) applications. The data binding features
    provided by the WPF framework make up the foundation of this mediation pattern.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVVM**（**模型-视图-视图模型**），MVP模式的衍生品，为UI、业务逻辑和数据之间提供了明确的边界。自从其出现以来，它几乎立即成为了**WPF**（**Windows演示基础**）应用程序的主要实现模式。WPF框架提供的数据绑定功能构成了这种中介模式的基础。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Data binding is the terminology used to describe the mechanism which connects
    data visualization elements from the UI layer (that is, the controls) to other
    controls or data objects from other tiers. The synchronization between the two
    actors of the binding is maintained through various events (for example, the `INotifyPropertyChanged`
    interface is used to propagate value change events).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是用来描述将UI层（即控件）中的数据可视化元素与其他层（例如，其他控件或数据对象）连接起来的机制的术语。绑定双方之间的同步通过各种事件（例如，使用`INotifyPropertyChanged`接口来传播值更改事件）来维护。
- en: In this pattern, the ViewModel is the main actor, whose responsibility is to
    control the data flow between the **View** and the **Model**. The outlets, in
    this architecture, are exposed by the ViewModel and used by the View implementation
    (as opposed to the iOS MVC architecture). The ViewModel provides these outlets
    in the form of data elements that can be associated to attributes or states of
    the UI controls, and also as generic commands that can be used by the **View**
    controls to respond to user input.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，ViewModel是主要演员，其责任是控制**视图**和**模型**之间的数据流。在这个架构中，出口由ViewModel暴露并由视图实现使用（与iOS
    MVC架构相反）。ViewModel以可以与UI控件属性或状态关联的数据元素的形式提供这些出口，以及作为**视图**控件可以用来响应用户输入的通用命令。
- en: Windows Runtime
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows Runtime
- en: Windows Phone applications, as well as Windows Store applications, natively
    support data binding for UI controls. This feature makes Windows Phone applications
    ideal candidates for this architecture. However, architectural elements should
    still be implemented by developers according to the requirements of specific projects.
    There are multiple (open-source or commercial) libraries that can be included
    as NuGet packages in development projects, including Prism (a cross-platform MVVM
    library, which was initially a pet project of the Microsoft patterns and practices
    team, but is now being maintained by the community) and MVVMCross (a cross-platform
    open source MVVM framework).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Phone应用程序以及Windows Store应用程序原生支持UI控件的数据绑定。这一特性使得Windows Phone应用程序成为这种架构的理想候选者。然而，架构元素仍应由开发者根据特定项目的需求来实现。有多个（开源或商业）库可以作为NuGet包包含在开发项目中，包括Prism（一个跨平台MVVM库，最初是微软模式和实践团队的宠物项目，但现在由社区维护）和MVVMCross（一个跨平台开源MVVM框架）。
- en: At the core of the MVVM pattern and data binding, we can locate the implementation
    of a bindable base class. A bindable base provides the implementation of the `INotifyPropertyChanged`
    interface and makes it easier to identify and implement the data elements that
    will take part in data binding. This interface is used to route value changed
    events from data items and their properties to UI elements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM模式和数据绑定的核心，我们可以找到可绑定基类的实现。可绑定基类提供了`INotifyPropertyChanged`接口的实现，使得识别和实现将参与数据绑定的数据元素变得更加容易。此接口用于将数据项及其属性的价值更改事件路由到UI元素。
- en: 'A simple bindable base implementation would look similar to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的可绑定基类实现看起来会类似于以下这样：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The implementation of this class can be used with model data items so that
    any change can be reflected on the UI:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实现可以与模型数据项一起使用，以便任何更改都可以在UI上反映出来：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now the `ModelData` class can already be used as the ViewModel and its bindings
    provided to `Property1`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ModelData`类已经可以用作ViewModel，并且其绑定可以提供给`Property1`：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The data binding to an input control on the main page would look similar to
    this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 主页上的输入控件的数据绑定看起来会类似于以下这样：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this binding scenario, we set the binding mode to `TwoWay`. This binding
    type means that any change on this property value, either on the ViewModel or
    on the user interface (that is, on user input), would be propagated to the UI
    element, or vice versa.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种绑定场景中，我们将绑定模式设置为`TwoWay`。这种绑定类型意味着，无论属性值的变化是在ViewModel还是用户界面（即用户输入）上，都会传播到UI元素，反之亦然。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Data bindings can be maintained using different modes. The **OneTime** binding
    is used to update the target property using the source property when the data
    source changes. This type of binding is generally used by read-only controls.
    The **OneWay** binding is used only to update the target property when the source
    property value changes, whereas the **TwoWay** mode is for duplex synchronization.
    Finally, **OneWayToSource** is used only to update the source property if there
    are any changes on the target property.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定可以使用不同的模式来维护。**OneTime**绑定用于在数据源更改时使用源属性更新目标属性。这种类型的绑定通常用于只读控件。**OneWay**绑定仅在源属性值更改时更新目标属性，而**TwoWay**模式用于双向同步。最后，**OneWayToSource**仅在目标属性有更改时更新源属性。
- en: Data bindings are not limited to values from and to ViewModel properties. Bindable
    properties of user controls can also be bridged in this pattern. Moreover, bindable
    properties of user controls include behavioral and style attributes (for example,
    the `IsEnabled` property of a `TextBox` user controls). Additional bindable properties
    can be provided to intrinsic or derived user controls using attached and/or dependency
    properties.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定不仅限于从ViewModel属性到值和从值到ViewModel属性的绑定。用户控件的可绑定属性也可以在这个模式中桥接。此外，用户控件的可绑定属性包括行为和样式属性（例如，`TextBox`用户控件上的`IsEnabled`属性）。还可以通过附加和/或依赖属性为内建或派生用户控件提供额外的可绑定属性。
- en: Command binding is another concept which provides a decoupled way to associate
    user action controls (for example, `Button`) with executable elements on the data
    context (that is, the ViewModel). In order for a user control to be bound to a
    command, the user control should implement a bindable command attribute and the
    ViewModel should provide an `ICommand` implementation of a specific action. The
    `ICommand` interface is a simple interface containing a `CanExecute` property,
    an associated `CanExecuteChanged` event (which is generally bound to the `IsEnabled`
    property of the user control), and the `Execute` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 命令绑定是另一个概念，它提供了一种解耦的方式来将用户操作控件（例如，`Button`）与数据上下文中的可执行元素（即，ViewModel）关联起来。为了使用户控件绑定到命令，用户控件应实现可绑定命令属性，而ViewModel应提供特定操作的`ICommand`实现。`ICommand`接口是一个简单的接口，包含一个`CanExecute`属性，一个相关的`CanExecuteChanged`事件（通常绑定到用户控件的`IsEnabled`属性），以及`Execute`方法。
- en: 'A simple command implementation that will validate the data model from the
    previous example and then execute would look similar to the following implementation
    (note that MVVM frameworks generally provide a generic `Command` class, which
    accepts delegates and/or lambdas for `Execute` and `CanExecute` methods):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的命令实现，将验证前一个示例中的数据模型并执行，其实现方式如下（请注意，MVVM框架通常提供一个通用的`Command`类，该类接受用于`Execute`和`CanExecute`方法的委托和/或lambda表达式）：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this implementation (either public or a nested class of the data model
    defined previously), we can initialize and expose the command when a new `ModelData`
    class is initialized:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现（无论是公共的还是之前定义的数据模型嵌套类），我们可以在初始化新的`ModelData`类时初始化和公开命令：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the binding for this command in XAML markup would look similar to:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，此命令在XAML标记中的绑定看起来如下：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we were to use the MVVM pattern to implement the previous form submission
    scenario, we can observe the implementation of both data and command bindings.
    We could implement a ViewModel class that is responsible for loading and submitting
    a bindable data item. The view would have the bindings to the ViewModel properties
    and commands, as well as bindings to the data item itself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用MVVM模式实现前一个表单提交场景，我们可以观察到数据和命令绑定的实现。我们可以实现一个ViewModel类，该类负责加载和提交可绑定数据项。视图将绑定到ViewModel属性和命令，以及绑定到数据项本身。
- en: '![Windows Runtime](img/B04693_09_19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Runtime](img/B04693_09_19.jpg)'
- en: 'Figure 19: MVVM implementation of the form submission scenario'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图19：表单提交场景的MVVM实现
- en: In this design, `SubmitCommand` is used both to submit the user input to the
    **Model** and to validate the form itself (using the `CanExecute` method). The
    `IsReadOnly` property of the ViewModel is bound to the `IsReadOnly` properties
    of the text fields and the `Visibility` property of the submit button (in read-only
    mode, instead of the submit button, the submitted label should be displayed),
    possibly with an `IValueConverter` (an interface used in two-way conversions between
    bound properties in data-binding scenarios).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设计中，`SubmitCommand`既用于将用户输入提交到**模型**，也用于验证表单本身（使用`CanExecute`方法）。ViewModel的`IsReadOnly`属性绑定到文本字段的`IsReadOnly`属性以及提交按钮的`Visibility`属性（在只读模式下，而不是提交按钮，应显示提交标签），可能还使用`IValueConverter`（在数据绑定场景中用于绑定属性之间的双向转换的接口）。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Value converters implement the `IValueConverter` interface to apply custom logic
    to the binding process. They are generally used as adapters for the CLR type of
    the target property and the source property (for example, if the data model property
    type was a `string` defining a certain color, we would need to convert/parse this
    value to `SolidColorBrush` or similar to assign it to visual elements' properties).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器实现了`IValueConverter`接口，以在绑定过程中应用自定义逻辑。它们通常用作目标属性和源属性的CLR类型（例如，如果数据模型属性类型是定义某种颜色的`string`，我们需要将此值转换/解析为`SolidColorBrush`或类似类型以分配给视觉元素的属性）的适配器。
- en: Besides the loose coupling and modularity achieved by using MVVM, the pseudo-finite
    automaton provided by the ViewModel allows developers to easily recreate different
    data states used by the view and implement unit tests without much hassle.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过使用MVVM实现的松散耦合和模块化之外，ViewModel提供的伪有限自动机允许开发者轻松地重新创建视图使用的数据状态，并轻松实现单元测试。
- en: MVVM on Xamarin.iOS and Xamarin.Android
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS和Xamarin.Android上实现MVVM
- en: In Xamarin projects, in order to create a uniform structure between the applications
    for different platforms and maximize code sharing, it is a widely accepted implementation
    principle to use the MVVM pattern solution-wide. Since data bindings and commanding
    pattern implementations are not natively supported on iOS and Android, using an
    MVVM framework that supports cross-platform development with Xamarin can be a
    solution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin项目中，为了在不同平台的应用程序之间创建统一的结构并最大化代码共享，使用MVVM模式作为全局实现原则是一种广泛接受的做法。由于iOS和Android原生不支持数据绑定和命令模式实现，使用支持Xamarin跨平台开发的MVVM框架可以是一个解决方案。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to mention that iOS and Cocoa have the concept of key-value
    observing, and a binding-like implementation can be applied to some extent.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，iOS和Cocoa有键值观察的概念，并且可以在一定程度上应用类似绑定的实现。
- en: On Xamarin.iOS and Xamarin.Android, bindings are generally provided through
    the extensions to `UIViewController` (on iOS) and `Activities` (on Android). In
    iOS, this implementation strategy transforms the **View** and **Controller** from
    MVC architecture into mere **View** implementations, while the ViewModel, conceptually,
    replaces the **Model** implementation. Bindings to the ViewModel are initialized
    in the application lifecycle events of the `UIViewControllers` and `Activities`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS和Xamarin.Android上，绑定通常通过`UIViewController`（在iOS上）和`Activities`（在Android上）的扩展提供。在iOS中，这种实现策略将MVC架构中的**视图**和**控制器**转换为仅有的**视图**实现，而ViewModel在概念上取代了**模型**实现。对ViewModel的绑定是在`UIViewControllers`和`Activities`的应用程序生命周期事件中初始化的。
- en: MVVM with Xamarin.Forms
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Xamarin.Forms的MVVM
- en: The data binding feature of Xamarin.Forms is an implementation/port of the WPF
    data bindings, so XAML bindings are supported for both data and commands. The
    main difference between Xamarin.Forms and Windows Runtime is that in Windows Store
    applications, binding context for a user control or a container is configured
    using the `DataContext` property, whereas in Xamarin.Forms, the `BindingContext`
    property is used for the same purpose. Xamarin.Forms additionally provides generic
    command implementation classes (namely, `Command` and `Command<T>`) which allow
    developers to expose commands without having to implement the `ICommand` interface
    in nested classes for the ViewModels.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms的数据绑定功能是对WPF数据绑定的实现/端口，因此支持XAML绑定用于数据和命令。Xamarin.Forms与Windows
    Runtime的主要区别在于，在Windows Store应用程序中，用户控件或容器的绑定上下文是通过`DataContext`属性配置的，而在Xamarin.Forms中，使用`BindingContext`属性用于相同的目的。Xamarin.Forms还提供了通用的命令实现类（即`Command`和`Command<T>`），允许开发者无需在嵌套类中实现`ICommand`接口即可暴露命令。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In cross-platform projects, with or without Xamarin.Forms, it is advisable to
    maintain the View elements as thin and devoid of static and/or sharable elements
    as possible. As discussed in this chapter, each Xamarin target platform supports
    resource and asset management in particular ways. These methodologies can be expanded
    to share static resources between the platform-specific projects by using linked
    resources and/or using special build techniques.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台项目中，无论是否使用Xamarin.Forms，建议尽可能保持视图元素薄，不包含静态和/或可共享元素。正如本章所讨论的，每个Xamarin目标平台都支持特定的资源和管理方式。这些方法可以通过使用链接资源和使用特殊的构建技术来扩展，以便在特定平台的项目之间共享静态资源。
- en: Architectural patterns, imposed by the platform or otherwise, can also be employed
    either at the beginning of the project or as the project matures through iterations.
    MVC and MVVM, as well as MVP, patterns help reduce the sharable logic components
    on the View, creating a more loosely-coupled project structure (see quality identifiers
    in [Chapter 1](ch01.html "Chapter 1. Developing with Xamarin"), *Developing with
    Xamarin*).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式，无论是平台强制的还是其他原因，可以在项目开始时或通过迭代项目成熟时采用。MVC、MVVM以及MVP模式有助于减少视图上的可共享逻辑组件，从而创建一个更松散耦合的项目结构（参见[第1章](ch01.html
    "第1章. 使用Xamarin进行开发")中的质量标识符，*使用Xamarin进行开发*）。
- en: After having covered different aspects of the Xamarin framework and UI-related
    concepts, in the next part of the book, we will discuss **Application Lifecycle
    Management** (**ALM**)-related topics to create an efficient development pipeline
    for individuals or teams dealing with Xamarin projects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完Xamarin框架和UI相关概念的不同方面之后，本书的下一部分将讨论与**应用程序生命周期管理**（**ALM**）相关的话题，以创建针对处理Xamarin项目的个人或团队的效率开发流程。
