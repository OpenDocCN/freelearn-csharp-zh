- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Working with External APIs and Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部 API 和服务一起工作
- en: Although an autonomous application can provide great value to its users, consuming
    external APIs and services can make it provide even greater value to those users
    by integrating the functionalities of the application with other applications!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个自主的应用程序可以为用户提供很大的价值，但通过将应用程序的功能与其他应用程序集成，消费外部 API 和服务可以使它为这些用户提供更大的价值！
- en: However, consuming external APIs and services creates new dependencies for your
    application. While this might make perfect sense, you have to know how to interact
    with these dependencies and how to integrate them into your application, so you
    don’t couple your application too much to that external dependency and avoid having
    to change your application’s code every time that dependency changes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，消费外部 API 和服务为您的应用程序创建了新的依赖。虽然这听起来可能非常合理，但您必须知道如何与这些依赖项交互以及如何将它们集成到您的应用程序中，这样您就不会使应用程序过于紧密地耦合到外部依赖，并避免每次依赖项更改时都需要更改应用程序的代码。
- en: 'More specifically, in this chapter, we will discuss the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，我们将讨论以下内容：
- en: The benefits of consuming external APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费外部 API 的好处
- en: Extending **Bookmarkr**’s capabilities by consuming an external API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消费外部 API 扩展 **Bookmarkr** 的功能
- en: The proper way in .NET to consume external APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 .NET 中正确消费外部 API 的方法
- en: How to avoid tight coupling between our application’s commands and the external
    API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免应用程序的命令与外部 API 之间的紧密耦合
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的 GitHub 仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09)
- en: Why consume external APIs?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要消费外部 API？
- en: When building your application, you have to consider multiple factors and sometimes
    implement multiple features that go well beyond your expertise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建您的应用程序时，您必须考虑多个因素，有时还需要实现超出您专业领域的多个功能。
- en: Does that mean you should not build an application if you do not master every
    feature? No! Many applications rely on code developed by other people who are
    more skilled and experienced in a very specific area. These pieces of code are
    packaged as APIs and services so we can use (aka consume) them without having
    to understand every line of code they contain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着如果您不掌握每个功能就不应该构建应用程序？不！许多应用程序依赖于由其他人在非常具体的领域内更熟练和更有经验的人开发的代码。这些代码片段被打包成
    API 和服务，这样我们就可以使用（即消费）它们，而无需理解它们包含的每一行代码。
- en: We have already come across this situation when we added logging into Bookmarkr.
    We didn’t develop the logging engine ourselves. We instead relied on an existing
    service provided by an organization that knows how to do it (and do it well!).
    By relying on that service, our application was able to benefit from logging functionality
    without having to be experts in the logging business domain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Bookmarkr 中添加日志记录时，我们已经遇到了这种情况。我们没有自己开发日志记录引擎。相反，我们依赖于一个由知道如何做（并且做得很好！）的组织提供的服务。通过依赖该服务，我们的应用程序能够从日志记录功能中受益，而无需成为日志记录业务领域的专家。
- en: 'Now, I can hear your thoughts (yes, I can – that is my sixth sense 😊). You
    are thinking that it doesn’t seem that complicated to develop your own logging
    engine, and you might be right. This is a business decision: if it is part of
    your core business, then yes, it makes sense to invest time, resources, and money
    in developing, testing, and maintaining your own logging engine. But remember,
    while it might be cool to develop it, you will have to maintain it, and that is
    what hurts many organizations in the long run! You know what they say… You build
    it, you run it! 😉'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以听到你的想法（是的，我可以——这是我的第六感 😊）。你认为开发自己的日志记录引擎似乎并不复杂，你可能是对的。这是一个商业决策：如果它是您核心业务的一部分，那么是的，投入时间、资源和金钱来开发、测试和维护自己的日志记录引擎是有意义的。但记住，虽然开发它可能很酷，但您将不得不维护它，这正是许多组织长期受苦的原因！你知道他们说什么……你建了它，你就得运行它！
    😉
- en: Also keep in mind that building your own “dependencies” (aka, services that
    are not part of your core business) is not always easy. An example of that is
    a payment gateway. There is a lot of regulation involved in building and offering
    such a service. If it’s not your core business (in other words, if you are not
    Stripe or such a company), don’t do it! Consume an existing service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，构建自己的“依赖项”（即，不属于你核心业务的服务）并不总是容易。一个例子就是支付网关。在构建和提供此类服务时涉及大量的法规。如果你的核心业务不是（换句话说，如果你不是Stripe或此类公司），不要这样做！使用现有的服务。
- en: 'By consuming external APIs and services, we can then focus on what we do best,
    and in our case, it is managing bookmarks! That is the key to consuming external
    APIs and services: having the ability to focus on our core business and delegating
    other concerns to whom those concerns are their core business.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消费外部API和服务，我们就可以专注于我们最擅长的事情，在我们的案例中，那就是管理书签！这就是消费外部API和服务的关键：拥有专注于我们核心业务的能力，并将其他关注点委托给那些关注点是他们的核心业务的人。
- en: How to consume an external API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何消费外部API
- en: .NET provides a way to interact with external APIs and services by abstracting
    the need to construct our own HTTP requests, handle the underlying networking
    details, send the request, and receive the response while performing serialization
    and deserialization and handling communication issues.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了一种通过抽象构建我们自己的HTTP请求、处理底层网络细节、发送请求、接收响应（同时执行序列化和反序列化以及处理通信问题）的需求来与外部API和服务交互的方法。
- en: So, in order to interact with these external APIs and services, .NET provides
    us with the `HttpClient` class. However, the proper way to deal with this class
    is through the `IHttpClientFactory` interface. This allows us to create and manage
    `HttpClient` instances for optimal performance and resource management.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了与这些外部API和服务交互，.NET为我们提供了`HttpClient`类。然而，处理这个类的正确方式是通过`IHttpClientFactory`接口。这允许我们创建和管理`HttpClient`实例，以实现最佳性能和资源管理。
- en: Benefits of using IHttpClientFactory
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IHttpClientFactory的优点
- en: 'Using `IHttpClientFactory` provides several advantages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IHttpClientFactory` 提供了几个优点：
- en: '`HttpMessageHandler` instances, which helps prevent issues such as socket exhaustion'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpMessageHandler`实例，有助于防止诸如套接字耗尽等问题'
- en: '**Connection reuse**: It reuses underlying HTTP connections, improving performance'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接重用**: 它重用底层的HTTP连接，提高性能'
- en: '**Resilience**: It adds resilience to transient faults'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**: 它增加了对瞬时错误的弹性'
- en: '`HttpClient` instances'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`实例'
- en: 'Bookmarkr: your bookmarks, anywhere!'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Bookmarkr: 你的书签，无处不在！'
- en: Up to this point, Bookmarkr has been managing our bookmarks locally. This means
    that we are tied to the physical boundaries of our computer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Bookmarkr一直在本地管理我们的书签。这意味着我们被绑定到我们计算机的物理边界。
- en: But what happens if we want to access these bookmarks from another computer?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想从另一台计算机访问这些书签怎么办？
- en: To make this happen, we will need to extend the capabilities of Bookmarkr beyond
    the local computer. To do this, we will make Bookmarkr call an external API that
    will be responsible for storing and retrieving our bookmarks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要扩展Bookmarkr的功能，使其超越本地计算机。为此，我们将使Bookmarkr调用一个外部API，该API将负责存储和检索我们的书签。
- en: For that matter, we will add a new command called `sync` that will be responsible
    for synchronizing the local bookmarks with the ones stored by the external service.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，我们将添加一个名为`sync`的新命令，该命令将负责同步本地书签与外部服务存储的书签。
- en: About the external service
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于外部服务
- en: When you consume an external service, you don’t have to know its internals (aka,
    its architecture, technology stack, application code, and dependencies). This
    is in accordance with the encapsulation principle of object-oriented programming.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你消费外部服务时，你不需要了解其内部（即，其架构、技术堆栈、应用程序代码和依赖项）。这符合面向对象编程的封装原则。
- en: All you need to know is how to send requests to it and how to interpret the
    responses it returns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的就是如何向它发送请求以及如何解释它返回的响应。
- en: However, since I know that you are curious to know more about it, I have provided
    the details of its architecture and its application and infrastructure code in
    the `appendixA-bookmarkr-syncr` branch of the GitHub repository.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，既然我知道你很想知道更多关于它的细节，我已经在GitHub仓库的`appendixA-bookmarkr-syncr`分支中提供了其架构和应用程序及基础设施代码的详细信息。
- en: Let’s start by adding the new command!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加新命令开始！
- en: The sync command
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步命令
- en: Following the project structure that we designed in the previous chapter, let’s
    add a new folder named `Sync` under the `Commands` folder, and within this folder,
    let’s add a new code file named `SyncCommand.cs`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在上一章中设计的项目结构，让我们在 `Commands` 文件夹下添加一个名为 `Sync` 的新文件夹，并在该文件夹内添加一个名为 `SyncCommand.cs`
    的新代码文件。
- en: 'The startup code for this command is the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的启动代码如下：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is pretty straightforward and needs no explanation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当直接，无需解释。
- en: 'The synchronization process comprises the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同步过程包括以下步骤：
- en: The local bookmarks are sent by Bookmarkr’s `sync` command to the external service
    (called BookmarkrSyncr).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地书签通过 Bookmarkr 的 `sync` 命令发送到外部服务（称为 BookmarkrSyncr）。
- en: BookmarkrSyncr will then perform the synchronization between the local bookmarks
    it receives from Bookmarkr with the ones it has in its data store.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BookmarkrSyncr 将执行从 Bookmarkr 收到的本地书签与其数据存储中的书签之间的同步。
- en: BookmarkrSyncr will send the synchronized bookmarks back to the Bookmarkr `sync`
    command’s handler method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BookmarkrSyncr 将同步后的书签发送回 Bookmarkr `sync` 命令的处理方法。
- en: The `sync` command’s handler method will store the received bookmarks in the
    local data store. Keep in mind that if the application is dealing with large datasets
    or rate-limiting APIs, batching and retry techniques will be needed.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sync` 命令的处理方法将接收到的书签存储在本地数据存储中。请注意，如果应用程序正在处理大型数据集或速率限制 API，则需要批处理和重试技术。'
- en: 'So, the `sync` command needs to have a reference to `IHttpClientFactory`. Let’s
    add this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`sync` 命令需要引用 `IHttpClientFactory`。让我们添加这个：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we are adding a `private` property of type `IHttpClientFactory`
    and we are injecting it through the constructor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们添加了一个类型为 `IHttpClientFactory` 的 `private` 属性，并通过构造函数进行注入。
- en: 'We are then using it in the command’s method handler:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在命令的方法处理程序中使用它：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is pretty easy to understand and conforms to the synchronization process
    we described earlier.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很容易理解，并符合我们之前描述的同步过程。
- en: 'There is, however, one segment in that code that requires an explanation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码中有一个部分需要解释：
- en: We create an HTTP client from the `IHttpClientFactory` instance by relying on
    the named clients approach. As you can see, we are providing the name of the client
    configuration (here, `bookmarkrSyncr`) to the `CreateClient` method. We will get
    back to this configuration later.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过依赖命名客户端方法从 `IHttpClientFactory` 实例创建一个 HTTP 客户端。正如你所见，我们向 `CreateClient`
    方法提供了客户端配置的名称（在这里，`bookmarkrSyncr`）。我们稍后会回到这个配置。
- en: 'Next, we issue a `POST` request to the `sync` endpoint of the remote web service,
    passing the list of local bookmarks that have been previously serialized as JSON
    using an instance of the `StringContent` class:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们向远程 Web 服务的 `sync` 端点发出一个 `POST` 请求，传递之前使用 `StringContent` 类实例序列化为本地的书签列表：
- en: If the request is successful, we deserialize the returned list of bookmarks
    (which represents the list of synchronized local and remote bookmarks) and we
    replace the local list of bookmarks with this new list
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求成功，我们将反序列化返回的书签列表（表示同步的本地和远程书签列表），并用这个新列表替换本地书签列表
- en: If the request is not successful, we display an error message corresponding
    to the returned HTTP status code
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求不成功，我们将显示一个与返回的 HTTP 状态码相对应的错误消息
- en: 'In order to import the `IHttpClientFactory` interface, we need to reference
    the `Microsoft.Extensions.Http` NuGet package. As we already know by now, we can
    do this by typing this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导入 `IHttpClientFactory` 接口，我们需要引用 `Microsoft.Extensions.Http` NuGet 包。正如我们之前所知道的，我们可以通过输入以下命令来完成：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before we can use our new command, let’s register it within the `Program` class!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用我们的新命令之前，让我们在 `Program` 类中注册它！
- en: Registering the sync command
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册同步命令
- en: 'Let’s register the `sync` command in the `Program` class. It’s only a matter
    of one line of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Program` 类中注册 `sync` 命令。这只需要一行代码：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But wait! Where did the `_clientFactory` variable come from?!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！`_clientFactory` 变量是从哪里来的？！
- en: Well done! You spotted it! 😊
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！你发现了！😊
- en: As you may have guessed, this is a reference to the `HttpClient` that we need
    to configure to make the magic happen. This is where we will talk about the named
    clients approach that we mentioned earlier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这是对需要配置以实现魔法的 `HttpClient` 的引用。这就是我们将讨论之前提到的命名客户端方法的地方。
- en: 'The `_clientFactory` variable is of type `IHttpClientFactory`. So, we first
    need to declare it within the `Main` method of the `Program` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`_clientFactory` 变量是 `IHttpClientFactory` 类型。因此，我们首先需要在 `Program` 类的 `Main`
    方法中声明它：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will allow us later to retrieve a reference to it and pass it to the constructor
    of `SyncCommand` during its registration (as we saw earlier). We can retrieve
    that reference as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们稍后检索其引用，并在注册期间将其传递给 `SyncCommand` 的构造函数（正如我们之前看到的）。我们可以这样检索那个引用：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let’s register the HTTP client for the BookmarkrSyncr service. We
    do this within the `ConfigureServices` block as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为 BookmarkrSyncr 服务注册 HTTP 客户端。我们是在 `ConfigureServices` 块中这样做的：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s explain what this code does:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这段代码的作用：
- en: A name (`bookmarkrSyncr`) is provided for the registered HTTP client. This is
    why we call this approach “`named clients`”. Notice that this is the same name
    that is passed to the `CreateClient` method in the `SyncCommand` class we saw
    earlier. This is how the appropriate HTTP client is selected.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为注册的 HTTP 客户端提供了一个名称（`bookmarkrSyncr`）。这就是我们为什么称这种方法为“`named clients`”。请注意，这与我们在前面看到的
    `SyncCommand` 类中传递给 `CreateClient` 方法的名称相同。这就是如何选择适当的 HTTP 客户端的方式。
- en: We then specify the base address for the service and a couple of request headers.
    Note that the base address does not specify the `sync` endpoint. It is specified
    when performing the request. This allows a web service to have different endpoints
    and for those endpoints to be invoked as needed without having to specify the
    base address over and over again.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定了服务的基准地址和一些请求头。请注意，基准地址没有指定 `sync` 端点。它在执行请求时指定。这允许一个网络服务有不同的端点，并且可以在需要时调用这些端点，而无需反复指定基准地址。
- en: About the base address
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基本地址
- en: You may have noticed that the base address points to an external URL. I deployed
    the code of the BookmarkrSyncr service in App Service on Azure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到基本地址指向一个外部 URL。我在 Azure 的 App Service 上部署了 BookmarkrSyncr 服务的代码。
- en: I will keep this service up and running as long as I can but keep in mind that
    you have access to both its infrastructure and application code in the `appendixA-bookmarkr-syncr`
    branch if you need to redeploy it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尽可能地保持这个服务运行，但请记住，如果你需要重新部署它，你可以在 `appendixA-bookmarkr-syncr` 分支中访问其基础设施和应用代码。
- en: Everything is now set up. We can run the program and see what happens.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了。我们可以运行程序并看看会发生什么。
- en: Running the program
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行程序
- en: 'To run the program, we simply need to execute this command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，我们只需执行这个命令：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '![Figure 9.1 – The sync command in action](img/B22400_09_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 同步命令在行动](img/B22400_09_01.jpg)'
- en: Figure 9.1 – The sync command in action
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 同步命令在行动
- en: Great, isn’t it?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？
- en: If we list all available local bookmarks, we will notice that they have indeed
    been synchronized with the remote list of bookmarks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们列出所有可用的本地书签，我们会注意到它们确实已经与远程书签列表同步了。
- en: What about security?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安全性？
- en: You may certainly have noticed that the web service can be used without any
    authentication. In other words, anonymous requests are allowed, which may be a
    security concern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可能已经注意到，可以不进行任何身份验证就使用该网络服务。换句话说，允许匿名请求，这可能会引起安全问题。
- en: You are totally right, and this is intentional for now as security will be addressed
    in [*Chapter 13*](B22400_13.xhtml#_idTextAnchor220) where we will see how we can
    authenticate users using a technique called “Personal Access Tokens,” which resembles
    using API keys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全正确，目前这是故意的，因为安全性将在[*第 13 章*](B22400_13.xhtml#_idTextAnchor220)中解决，我们将看到如何使用称为“个人访问令牌”的技术来验证用户，这类似于使用
    API 密钥。
- en: The code works great but there is actually a drawback to it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行得很好，但实际上有一个缺点。
- en: Reducing the coupling between our application and the external dependency
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少我们的应用程序与外部依赖项之间的耦合
- en: In the previous section, although we applied the best practices of consuming
    external APIs, we created a coupling between our application and that dependency…
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，尽管我们应用了消费外部 API 的最佳实践，但我们还是在我们的应用程序和那个依赖项之间创建了一种耦合…
- en: Notice that our application actually knows about the data type and structure
    that is returned by the API. This means that whenever this API changes, we will
    need to update our code accordingly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的应用程序实际上知道 API 返回的数据类型和结构。这意味着每当这个 API 发生变化时，我们都需要相应地更新我们的代码。
- en: This also means that our application is responsible for handling the different
    HTTP codes that the API may return. Can’t we abstract this complexity somewhere
    so that eventual changes are scoped to a small portion of our code?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们的应用程序负责处理 API 可能返回的不同 HTTP 状态码。我们能否将这种复杂性抽象到某个地方，以便最终更改仅限于我们代码的一小部分？
- en: Of course we can! And there is a pattern for that, which is called **Service
    Agent**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然我们可以！而且有一个模式，这被称为 **服务代理**。
- en: About the Service Agent pattern
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于服务代理模式
- en: The Service Agent pattern abstracts away the details of HTTP communication into
    a dedicated service, allowing other services (or, in our case, commands) to interact
    with external systems without directly dealing with HTTP requests and responses.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 服务代理模式将 HTTP 通信的细节抽象到一个专门的服务中，允许其他服务（或在我们的情况下，命令）与外部系统交互，而无需直接处理 HTTP 请求和响应。
- en: 'There are many benefits to the Service Agent pattern, among which are the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 服务代理模式有许多好处，其中以下是一些：
- en: '**Abstraction**: It abstracts the complexity of HTTP communication, including
    constructing the HTTP request, handling the response, and managing errors'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：它抽象了 HTTP 通信的复杂性，包括构建 HTTP 请求、处理响应和管理错误'
- en: '**Encapsulation**: It encapsulates all the logic related to communicating with
    a specific external service or API'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：它封装了与特定外部服务或 API 通信相关的所有逻辑'
- en: '**Reusability**: Service Agent can be reused by multiple components or services
    within the application'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：服务代理可以在应用程序的多个组件或服务中被重用'
- en: '`sync` command) from the communication logic (in Service Agent)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （`sync` 命令）从通信逻辑（在服务代理中）
- en: '**Maintainability**: Changes to the external API or communication protocol
    only need to be made in one place (Service Agent)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：对外部 API 或通信协议的更改只需要在服务代理的一个地方进行'
- en: I believe that it’s clear to you by now that our CLI application can greatly
    benefit from leveraging the Service Agent pattern. Let’s now see how we can implement
    it!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在对你来说已经很清楚，我们的 CLI 应用程序可以从利用服务代理模式中受益良多。现在让我们看看我们如何实现它！
- en: Implementing the Service Agent pattern
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现服务代理模式
- en: This pattern is often implemented using `IHttpClientFactory` and named or typed
    `HttpClient` instances.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式通常使用 `IHttpClientFactory` 和命名或类型化的 `HttpClient` 实例来实现。
- en: We are already using these artifacts, so it will be quite straightforward for
    us to abstract the HTTP details away from the `sync` command and into a dedicated
    Service Agent class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在使用这些工具，因此对于我们来说，将 HTTP 细节从 `sync` 命令抽象出来，并放入一个专门的服务代理类中将会非常直接。
- en: The first step we will perform is to create a folder structure for Service Agents.
    Following the project structure we have laid out in the previous chapter, let’s
    create a folder named `ServiceAgents` and a subfolder named `BookmarkrSyncrServiceAgent`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的第一步是为服务代理创建一个文件夹结构。遵循我们在上一章中概述的项目结构，让我们创建一个名为 `ServiceAgents` 的文件夹和一个名为
    `BookmarkrSyncrServiceAgent` 的子文件夹。
- en: 'Within this subfolder, let’s create two code artifacts: an interface file named
    `IBookmarkrSyncrServiceAgent.cs`, and a class file named `BookmarkrSyncrServiceAgent.cs`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子文件夹中，让我们创建两个代码工具：一个名为 `IBookmarkrSyncrServiceAgent.cs` 的接口文件和一个名为 `BookmarkrSyncrServiceAgent.cs`
    的类文件。
- en: 'Here is the code of the `IBookmarkrSyncrServiceAgent` interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `IBookmarkrSyncrServiceAgent` 接口的代码：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This interface only exposes one operation, `SyncBookmarks`, which takes the
    list of local bookmarks (held by the Bookmarkr CLI application) and returns the
    synced list of bookmarks that includes the bookmarks from the remote web service,
    BookmarkrSyncr.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口仅公开一个操作，`SyncBookmarks`，它接受本地书签列表（由 Bookmarkr CLI 应用程序持有）并返回同步后的书签列表，包括来自远程
    Web 服务 BookmarkrSyncr 的书签。
- en: 'Let’s now implement this interface:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现这个接口：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you may have noticed, this implementation is reusing the code that was located
    in the body of the `Sync` command’s handler method, hence abstracting it from
    this method and encapsulating it into the Service Agent class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个实现正在重用位于 `Sync` 命令处理方法主体中的代码，因此将其从该方法中抽象出来，并将其封装到服务代理类中。
- en: For this reason, the code of this class does not need a lot of explanation.
    However, it is worth mentioning that in case of an unsuccessful request, we return
    an instance of `HttpRequestException` with the details about the issue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个类的代码不需要太多的解释。然而，值得一提的是，在请求失败的情况下，我们返回一个包含问题详细信息的 `HttpRequestException`
    实例。
- en: 'Next, we need to update the code of the `SyncCommand` class to abstract the
    use of `IHttpClientFactory` and use our new Service Agent instead. The updated
    code is the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`SyncCommand`类的代码，以抽象化`IHttpClientFactory`的使用，并使用我们新的服务代理。更新的代码如下：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is quite simple and easy to read. What we did basically was replace
    the use of `IHttpClientFactory` with the use of `IBookmarkrSyncrServiceAgent`
    and remove all the code, in the `OnSyncCommand` method, that was dealing with
    the HTTP communication (which we abstracted away into the Service Agent class)
    by the call to the `Sync` method of the Service Agent. Hence, the `OnSyncCommand`
    method is also leaner, shrinking from 41 lines of code down to 16.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单且易于阅读。我们基本上是用`IBookmarkrSyncrServiceAgent`的使用替换了`IHttpClientFactory`的使用，并通过调用服务代理的`Sync`方法，移除了`OnSyncCommand`方法中处理HTTP通信的所有代码（我们将其抽象到服务代理类中）。因此，`OnSyncCommand`方法也更加精简，从41行代码缩减到16行。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For your reference, we provide a copy of the `SyncCommand` class as it was before
    introducing the use of the Service Agent class. By doing so, you can easily compare
    the differences between the two implementations. Look for the file named `SyncCommand_NoServiceAgent.txt`
    in the `Commands/Sync` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的参考，我们提供了一个在引入使用服务代理类之前的`SyncCommand`类的副本。通过这样做，您可以轻松地比较两种实现之间的差异。在`Commands/Sync`文件夹中查找名为`SyncCommand_NoServiceAgent.txt`的文件。
- en: The final step is to register the Service Agent into the list of services in
    the `ConfigureServices` section of the `Program` class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将服务代理注册到`Program`类中的`ConfigureServices`部分的服务列表中。
- en: 'As we have seen previously, this can be easily done by adding this line of
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，这可以通过添加以下代码行轻松完成：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need not forget to declare a variable for the Service Agent:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住声明一个服务代理的变量：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to retrieve the instance of that Service Agent:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检索该服务代理的实例：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We pass it to the constructor of the `SyncCommand` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其传递给`SyncCommand`类的构造函数：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Everything is now in place. Let’s make sure that the application still works
    as expected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一切现在都已就绪。让我们确保应用程序仍然按预期工作。
- en: Rerunning the program
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新运行程序
- en: 'We can run the program the same way we did before, by typing this command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样运行程序，通过输入以下命令：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will get the exact same result, proving that the application still works
    as it is supposed to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到完全相同的结果，证明应用程序仍然按预期工作：
- en: '![Figure 9.2 – The sync command in action using the Service Agent](img/B22400_09_02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 使用服务代理执行同步命令](img/B22400_09_02.jpg)'
- en: Figure 9.2 – The sync command in action using the Service Agent
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用服务代理执行同步命令
- en: Awesome! By leveraging the Service Agent pattern, we have been able to provide
    a clean separation between the business logic and the details of HTTP communication.
    Hence, we can consume the BookmarkrSyncr web service in any other command (using
    the `BookmarkrSyncrServiceAgent` class), without this command having to deal with
    the HTTP communication details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过利用服务代理模式，我们已经能够提供业务逻辑和HTTP通信细节之间的清晰分离。因此，我们可以在任何其他命令（使用`BookmarkrSyncrServiceAgent`类）中消费`BookmarkrSyncr`网络服务，而无需这个命令处理HTTP通信细节。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to extend the functionalities of Bookmarkr by
    consuming external APIs and services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过消费外部API和服务来扩展Bookmarkr的功能。
- en: We explored the best practices of communicating with external dependencies,
    handling response data, codes, and errors, and designing that integration in a
    way that does not create a heavy coupling between the external dependency and
    our application, making it easy to replace that dependency over time if this proves
    necessary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了与外部依赖项通信的最佳实践，处理响应数据、代码和错误，以及以不创建外部依赖项和我们的应用程序之间紧密耦合的方式设计该集成，这样如果证明这是必要的，就可以轻松替换该依赖项。
- en: In the next chapter, we will cover one of the key aspects of building applications,
    which is testing those applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍构建应用程序的关键方面之一，即测试这些应用程序。
- en: Your turn!
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码是一种很好的通过实践学习的方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下功能来改进Bookmarkr应用程序。
- en: 'Task #1 – adding SQLite as a data store'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 添加SQLite作为数据存储'
- en: Who said that APIs are the only external dependencies an application can rely
    on? Certainly not me! 😊
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 谁说API是应用程序可以依赖的唯一外部依赖项？当然不是我了！😊
- en: Until now, our application has stored its bookmarks in memory. You will certainly
    agree with me that this is not an ideal solution as bookmarks will be lost as
    soon as the application terminates or restarts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序已经将书签存储在内存中。你一定会同意我的观点，这不是一个理想的解决方案，因为一旦应用程序终止或重启，书签就会丢失。
- en: You are asked to add a new dependency to the Bookmarkr application – a **SQLite**
    database! This will allow bookmarks to be stored in a more permanent manner by
    Bookmarkr, making it more useful to our users 😉.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求向Bookmarkr应用程序添加一个新的依赖项——一个**SQLite**数据库！这将允许Bookmarkr以更持久的方式存储书签，使其对我们的用户更有用
    😉。
- en: Why SQLite? You may ask…
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择SQLite？你可能想知道...
- en: 'SQLite is a versatile and lightweight database solution, designed to be both
    simple and easy to use while requiring minimal setup and administration. One of
    its most significant advantages is its portability: the entire database is stored
    in a single file, which makes it easy to move, back up, and distribute. Its self-contained
    nature also means that SQLite doesn’t require a separate server process or system
    configuration, simplifying its deployment. That is why it is a great fit for CLI
    applications!'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个多才多艺且轻量级的数据库解决方案，旨在简单易用，同时需要最少的设置和管理。它最显著的优势之一是其可移植性：整个数据库存储在一个单独的文件中，这使得移动、备份和分发变得容易。其自包含的特性还意味着SQLite不需要单独的服务器进程或系统配置，简化了其部署。这就是为什么它非常适合CLI应用程序！
- en: Now, you will also need to modify the code of `BookmarkService` to retrieve
    bookmarks from and store bookmarks in the SQLite database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你还需要修改`BookmarkService`的代码，以便从SQLite数据库中检索书签并将其存储在SQLite数据库中。
- en: Consider using the `Microsoft.Data.Sqlite` library for .NET, as it is a reliable
    and lightweight library. Consider adding migrations and ensuring thread-safe access
    for SQLite in concurrent CLI scenarios.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用.NET的`Microsoft.Data.Sqlite`库，因为它是一个可靠且轻量级的库。考虑添加迁移并确保SQLite在并发CLI场景中的线程安全访问。
- en: 'Task #2 – retrieving the web page name based on its URL'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务#2 – 根据URL检索网页名称
- en: Until now, when adding a new bookmark, we had to pass both the web page name
    and URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在添加新的书签时，我们必须传递网页名称和URL。
- en: Now that we know how to work with external dependencies, let’s tweak the `link
    add` command so that it makes an HTTP request to retrieve the name of the web
    page to bookmark based on the provided URL. If the name can’t be retrieved, we
    can then use the name that was passed as a command option.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何处理外部依赖项，那么让我们调整`link add`命令，使其通过提供的URL发送HTTP请求以检索要书签的网页名称。如果无法检索名称，我们可以使用作为命令选项传递的名称。
- en: If the web page cannot be found, the bookmark’s name should be `Unnamed bookmark`.
    If the request takes more than 30 seconds, terminate it and also set the name
    to `Unnamed bookmark`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到网页，书签的名称应该是`未命名书签`。如果请求超过30秒，则终止请求并将名称设置为`未命名书签`。
- en: 'Part 4: Testing and Deployment'
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：测试和部署
- en: In this part, you will explore the critical aspects of testing, packaging, and
    deploying CLI applications. You'll learn various strategies for testing CLI tools,
    including unit testing individual components. Next, you'll delve into packaging
    your CLI application for distribution, using the most commonly used mechanisms
    such as Docker, .NET Tool, and Winget. You'll understand how to specify entry
    points, define dependencies, and structure your project for optimal packaging.
    Finally, you'll explore deployment methods, learning how to distribute your CLI
    tool through package managers and ensure it works consistently across different
    environments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将探索测试、打包和部署CLI应用程序的关键方面。你将学习各种测试CLI工具的策略，包括对单个组件进行单元测试。接下来，你将深入了解如何打包你的CLI应用程序以进行分发，使用最常用的机制，如Docker、.NET
    Tool和Winget。你将了解如何指定入口点、定义依赖项以及为最佳打包结构化你的项目。最后，你将探索部署方法，学习如何通过包管理器分发你的CLI工具并确保它在不同的环境中保持一致性。
- en: 'This part has the following chapters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B22400_10.xhtml#_idTextAnchor155)*, Testing CLI Applications*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B22400_10.xhtml#_idTextAnchor155)*，测试CLI应用程序*'
- en: '[*Chapter 11*](B22400_11.xhtml#_idTextAnchor185)*, Packaging and Deployment*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B22400_11.xhtml#_idTextAnchor185)*，打包和部署*'
