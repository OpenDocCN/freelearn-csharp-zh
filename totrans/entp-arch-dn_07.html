<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-147"><a id="_idTextAnchor248"/>7</h1>
<h1 id="_idParaDest-148"><a id="_idTextAnchor249"/>C4 and Other Approaches</h1>
<p>In the previous chapter, we provided an initial idea of the business goal of the sample information system (and application software modules) that we are going to build as a practical exercise to follow the principles outlined in this book. Talking about principles, while introducing the demo system, we also explained how the most important principles in object-oriented programming would apply to the design of our system.</p>
<p>Now that the high-level principles have been set, it is time to go a level deeper in understanding our sample information system, and we will take advantage of this to show a few different methods professionals use. There exist many architectural methods and software representations, as we are going to see, and many overlap in lots of ways. In fact, some of them are so close that they really are a way for their author to mark their individual approach, rather than bringing some additional value to the architectural tools. This is the same situation with the JavaScript ecosystem, where there are way too many frameworks. Furthermore, it becomes even worse every day, with a new team thinking they can solve a problem by proposing yet another one. The same thing happens with architectural methods, and we have recently been overwhelmed with <strong class="bold">clean architecture</strong>, <strong class="bold">hexagonal architecture</strong>, <strong class="bold">onion architecture</strong>, and so on.</p>
<p>As the choice of one method over the other is really not important, we will only quickly show these methods so that you can choose which one adapts better to your way of thinking, or simply mix some interesting bits from many methods, as these are merely sets of long-known best practices assembled in a new package name. In the case of our sample information system, the <strong class="bold">C4 approach</strong> sounded <a id="_idIndexMarker363"/>interesting to provide a first approach on how it is designed, so this is the method that I will focus on to provide more details about. The idea behind the C4 architectural framework is to focus on IT systems from a context level to a container level, then a component level, and finally, a code level. The four levels will be explained as we apply them to our sample system.</p>
<p>Just like with <strong class="bold">SOLID principles</strong> in the previous chapter, my goal here is not to explain these methods in depth, as there would be no value in writing what is already available in more detail on freely available and quality resources. My intention is to extract how these methods can be useful to reach a business/IT alignment or at least help represent the questions that are related to this same subject.</p>
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>The C4 approach</li>
<li>Clean architecture</li>
<li>Hexagonal architecture</li>
<li>Onion architecture<a id="_idTextAnchor250"/></li>
</ul>
<h1 id="_idParaDest-149"><a id="_idTextAnchor251"/>The C4 approach</h1>
<p>The C4 approach <a id="_idIndexMarker364"/>is about designing a system (or an application) with four different levels of granularity, moving from the context level in which the application is placed, to the container level that will show the different processes composing the application, to the component layer showing the different parts composing the process, and finally, to the code level, where we will find the classes and interfaces used to create the application. Here is the diagram for this approach:</p>
<div><div><img alt="Figure 7.1 – The levels in the C4 approach" src="img/B21293_07_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The levels in the C4 approach</p>
<p>Each level details<a id="_idIndexMarker365"/> the content of the previous level and gives a more detailed view of the application. The fact that units of the lower level always have to be related to one given unit of the upper layer also helps to correctly share responsibilities and maintain a low level of coupling.</p>
<p>In the following sections, we will draw the four levels for our sample system and software modules to show the methods; at the same time, we will start designing our demo a bit further than the business requirements in the previous chapter allowed us to do. Note that the following diagrams will not necessarily be the exact ones that correspond to the system created at the end of the book; I really wanted to show the complete and realistic process of design, so I am drawing these at the same time as I design the sample application for the book. Drawing the schemas after I got a clear and complete view of the final result would – in my opinion – not be as pedagogical and, in some way, I would have felt like cheating<a id="_idTextAnchor252"/>.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor253"/>The context level</h2>
<p>On the <strong class="bold">context level</strong>, our <a id="_idIndexMarker366"/>system will be used by the three user profiles that were detailed before, namely the editors, the salespersons, and the director of DemoEditor. We will consider that the list of users is already present in the information system as an Active Directory or something equivalent. The same goes for a content management system, which will be considered to already exist for binary document management. Finally, we will consider that a module responsible for the emission of electronic mail is also available in the overall system. It is used to send emails to actors of the system, either to validate some data or to inform them of something. Of course, the authors will be represented in the context, even if they do not use the internal information system directly. Here is a diagram of the context level:</p>
<div><div><img alt="Figure 7.2 – A context-level diagram" src="img/Figure_7.2_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – A context-level diagram</p>
<p>We could be<a id="_idIndexMarker367"/> more detailed on the content of the arrows, but for now, the diagram is self-explanatory, and the functions used by the different roles were explained in the previous chapter. Our most important center of interest in this diagram is the <strong class="bold">Demo Editor System</strong> box, and this is the one that we will detail in the next level of the C4 architectur<a id="_idTextAnchor254"/>e.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor255"/>The container level</h2>
<p>At the <strong class="bold">container level</strong>, we <a id="_idIndexMarker368"/>show what the system uses in terms of building blocks. Most of the time, these blocks are separated processes. In our case, since we have decided to have completely independent services, we will have as many containers as API exposition servers. I anticipate a bit on the technical chapters of the book, but we will deploy the system as Docker containers, so there is a complete match between “containers” in the C4 architecture and “containers” in terms of the units of deployment used in Docker or other such technologies.</p>
<p>In the following diagram, the boxes inside the dotted rectangle represent the details of the higher-level box corresponding to the Demo Editor system. We can still represent the other parts of the Context level, but it’s best practice not to detail them, as they are outside the scope of our study. We can detail the stream that goes to them (as we did for the <strong class="bold">Users directory</strong> arrow, pointing from <strong class="bold">Single Page Application</strong>), but this is not mandatory, and we can also keep arrows that simply point from the system as a whole if we do<a id="_idIndexMarker369"/> not want to be precise about these streams of data yet (this is what has been done for the mail sender and CMS subsystems).</p>
<div><div><img alt="Figure 7.3 – The container level" src="img/Figure_7.3_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The container level</p>
<p>By the way, at this level of reflection, we start considering what the content of the streams of data could be, and in this particular case, I realized that instead of a CMS, electronic document management could possibly be more appropriate. If we consider that this is an external system and not part of the one we are designing, we would, in reality, not have the ability to change it. However, since there is an interoperation with it, we might be able to influence the protocol used to communicate with it, and this is what our analysis is about. From a practical point of view, I do not know yet, at the time of writing (remember, I want to be as realistic as possible and I have not finished the exercise before writing the chapters), whether there will be an Alfresco container, an Azure Storage, or a SharePoint 365 site to implement this subsystem. All I know is that I will need to pass <a id="_idIndexMarker370"/>binary documents and retrieve them, which means something such as <strong class="bold">Content Management Interoperability Services</strong> (<strong class="bold">CMIS</strong>) streams will certainly be indicated (CMIS is an interoperability standard for electronic documents).</p>
<p>For now, we have not <a id="_idIndexMarker371"/>expressed what is inside each of the boxes. We only know that each of them will have its own life cycle as a software application and represent a process and a Docker container (a good practice is, indeed, to have one process per container only so that all things align well). If we go a bit into the development details, it would then be in the right alignment to have a continuous integration pipeline for each of these containers and, logically, a git repository for each of them as well. But I am anticipating the “hands-on” part of the book. For now, let’s dive deeper into one of the boxes, namely <strong class="bold">Books repository</strong>, and show what it will be composed with, using the third level of the C4 approach, namely the component dia<a id="_idTextAnchor256"/>gram.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor257"/>The component level</h2>
<p>At the <strong class="bold">component level</strong>, we<a id="_idIndexMarker372"/> show the different modules and libraries that the executable container will use to accomplish its business requirements. As our books repository will expose two contract APIs, we will need a web server to support the controllers, a client to call the persistence system, maybe together with a repository pattern, a cache component to keep some data locally, and so on. This is what is drawn in the following diagram that corresponds to the third level in the C4 architecture:</p>
<div><div><img alt="Figure 7.4 – The component level" src="img/Figure_7.4_B21293_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The component level</p>
<p>A component may correspond to different names of artifacts, depending on the platform that is going to be used. In .NET, components may be assemblies, while in Java, they will be JAR archives. Anyhow, this decomposition in components exists in basically all programming <a id="_idIndexMarker373"/>platforms, even if it appears in different forms. For example, in some platforms, components will correspond to separate files, while in others, they will be more abstract, through the use of namespaces, for example. In any case, there will be ways to group code-level content into coherent groups, while still with a lower granularity than the higher level of containers, which correspond to entire processes made with several compo<a id="_idTextAnchor258"/>nents.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor259"/>The code level</h2>
<p>As the <a id="_idIndexMarker374"/>reference documentation of the C4 method (available at <a href="https://c4model.com/">https://c4model.com/</a>) states, it is important to use diagrams only if they add value. This is something I also stressed when <a id="_idIndexMarker375"/>presenting the <code>IDbRepository</code> pattern will be used and maybe a <code>UnitOfWork</code> pattern, but the class organization is not clear yet, so there is no use in trying to draw the diagram yet.</p>
<p>Also, even if it was for pedagogical reasons, drawing such a diagram would not bring much value, since the fourth level of the C4 approach is simply<a id="_idIndexMarker376"/> the same as a class diagram from <strong class="bold">UML</strong> or <strong class="bold">Unified Modeling Language</strong>. We will use these detailed diagrams if we need to in the following chapters, once we progress into the actual making of the system. In the meantime, we are done with the C4 method used to explain the sample system we want to create, and we will now briefly discuss the alternative software architectural design methods, using them to better express our context under <a id="_idTextAnchor260"/>analysis.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor261"/>Clean architecture, hexagonal architecture, and other frameworks</h1>
<p>What comes next <a id="_idIndexMarker377"/>may be a surprise for you in the context of software architecture – the choice of an architecture method does not matter much, as long as you have <a id="_idIndexMarker378"/>a method (or several methods used together, by the way, if you maintain control of their interactions and know when to choose one over another). Of course, that does not mean you do not need to apply some method when designing the architecture of an information system. My point of view after many years of experience in the field is that you should find and apply <em class="italic">your</em> method.</p>
<p>Also, if you try many different existing methods such as hexagonal architecture, clean architecture, onion architecture, and other domain-centric approaches, you will quickly realize that they offer little more than a different visual approach to the same basic principles, which are highly related to the business/IT alignment we discussed at the beginning of this book and the principles that have been extracted from the SOLID approach, namely the following:</p>
<ul>
<li>The business model (<em class="italic">data structures representing functional concepts</em> and <em class="italic">business rules translated into code</em>) should be at the core of the architecture. This way, it does not depend on anything, which allows easy changes, fast automated testing, a lack of external versioning constraints, and lots of other advantages. Most importantly, it enables the concentration of the team on the most important thing – business alignment.</li>
<li>Everything surrounding this business-aligned core should use some kind of indirection to introduce low-coupling and make the evolution of any module of the system easier. Everything depends on the business core module, which itself depends on nothing else. In addition, these dependencies are easy to modify if<a id="_idTextAnchor262"/> necessary.</li>
</ul>
<h2 id="_idParaDest-155"><a id="_idTextAnchor263"/>Technical architecture patterns</h2>
<p>One last thing <a id="_idIndexMarker379"/>before we dive into the details of the methods – here, I will only discuss the architectural methods that can apply to the design of an entire information system. There are lots of methods that deal with the technical architecture of a single application, how it should be structured, how its source code and information flow should be organized, what technical layers should be present, and even, in some cases, recommendations on how to name things.</p>
<p>For example, the <strong class="bold">N-tier architectures</strong> (also called <strong class="bold">layer-based</strong>) will describe how each set of source<a id="_idIndexMarker380"/> code should call another set, from the GUI to the service to the application to the database. MVC, MVP, and MVVM architectures are slightly less linear and describe how each group of source code would talk to only some of them, to ease the evolution and maintenance of the application (with generally an emphasis on their visual part).</p>
<p>These architectures can, theoretically, be used at the level of the entire information system, but that does not mean much more than applying them to all applications that constitute the information system, since they do not say much about how the applications should work together. N-tier architecture recommends that software blocks should talk to each other using the application layer, but since it does not enforce it, lots of old applications interop at the database level, which is a catastrophic coupling in most cases and certainly one of the major reasons why a vast majority of legacy systems are nowadays unable to evolve. MVC is supposed to be applicable at a higher level than just the visual interface, but despite this, it does not reach the level of the entire information system. It may be just a question of semantics, but I personally tend to classify these methods as patterns rather than architectures, since they come from experience rather than pure reflection (and there is absolutely no value judgment in this – we need both experimental and intellectual approaches to be complete).</p>
<p>Since this book is about the architecture of a whole information system, I have focused on the purpose of architectural methods that naturally are applicable at such levels. It happens that domain-centric methods typically respond to this because they convey the very notion of a business domain, which has to be the very first (and unique) way to decompose an information system if you want to get a result that is aligned with a business. All technical approaches can work on the software and hardware layers, but what we need is methods that work at the business capability map level.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor264"/>Onion architecture</h2>
<p><strong class="bold">Onion architecture</strong> pictures<a id="_idIndexMarker381"/> a software unit as several concentric circles containing, right at the center, the business <strong class="bold">domain model</strong>! And around it, you will find services (persistence, etc.) and then presentation (a GUI, external interfaces, tests, etc.):</p>
<div><div><img alt="Figure 7.5 – Onion architecture" src="img/Figure_7.5_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Onion architecture</p>
<p>One of the main rules in onion architecture is that all dependencies should go from the outer side to the inner layers. This way, again, the core business model does not depend on anything, which makes it easy to evolve, while outer circles can be changed provided that they do not impact the business (which is generally much easier than the reverse – imagine basing your entire business model on a proprietary relational database procedures language and trying to change to another database engine).</p>
<p>While this method does not insist on levels of indirection, the principle of dependency inversion (see the previous chapter for an explanation), together with the rule just cited, makes it obvious that interfaces are necessary to implement functions such as persistence. And the same goes, of course, for one<a id="_idTextAnchor265"/> layer above.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor266"/>Hexagonal architecture</h2>
<p><strong class="bold">Hexagonal architecture</strong> represents <a id="_idIndexMarker382"/>a software unit in a hexagonal shape, hence its name, with the left part of the hexagon containing interfaces consuming the inside (such as a GUI or automated tests), the right part containing adapters to functional dependencies (such as persistence, notification service, etc.), and right in the middle of it, as you may have guessed, the core, containing the business entities and business rules!</p>
<div><div><img alt="Figure 7.6 – Hexagonal architecture" src="img/Figure_7.6_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Hexagonal architecture</p>
<p>Hexagonal architecture insists on ports and adapters to organize the communication between the different parts of the application, but this is also a rule in the onion architecture even if it is not displayed in the same way. This helps us remember that interfaces and contracts should always be applied for the dependencies not to evolve into hard coupling, which makes it difficult to evolve the system.</p>
<p>As far as the “<em class="italic">hexagonal</em>” shape goes, it is pure clutter! I intended to draw three “clients” of the business domain to stress the point that there is absolutely no relationship between the name of the method and a given technical constraint or a particular advantage of the technique. In fact, it is explained in the method that the hexagonal shape is simply used to preserve enough space to display shapes around the central one. How would this be different from circles (used by the other approaches cited previously), ovals, or squares? If the hexagonal shape does not bring anything conceptually enriching, my personal opinion is that it should not be declared in the name of the method.</p>
<p>This may sound like<a id="_idIndexMarker383"/> a useless rant against methods, but this is only to make it clear that their value really lies in what they have in common and not their differences. What really matters is the centrality of the core domain, aligned to the business, and the control of the dependencies, but all of this is already there in the SOL<a id="_idTextAnchor267"/>ID principles.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor268"/>Clean architecture</h2>
<p><strong class="bold">Clean architecture</strong> involves <a id="_idIndexMarker384"/>basically joining the two approaches presented previously while proposing some additional rules. Graphically, it appears very similar to the onion architecture, in concentric circles with the business entities in the middle, and several layers organized around in the core, evolving to the outside in the same direction as dependencies apply.</p>
<p>In this method, you will find almost everything that has already been explained previously in the two other methods, including the fact that the domain model must be clean of any technical dependencies, to address its utmost importance in the system and to bring all kinds of other benefits such as testability.</p>
<p>Inversion of dependency is also recommended, as the separation of concerns. The vocabulary slightly differs, but a quick search on the internet will show lots of blog articles about the extreme similarities between the three architectures. Clean architecture may be a bit more “guiding” than the others, but it is impossible – at the time of writing – to find a documented analysis proving one better, or even widely different in results, than the other.</p>
<p>My personal opinion is that these three approaches (onion, hexagonal, and clean architecture) are so close to each other in the way they work and in their recommendations that you can use one or another without making any real difference in the quality of the architecture produced.</p>
<p>What will bring quality is the profound understanding of why these methods exist and, in particular, the capacity to create modules that are cleanly separated and where you keep control of the dependencies. Cutting concerns and responsibilities without strict rules on their relationship will end up in a spaghetti-like system.</p>
<p>Conversely, following strict principles where the business domain (the most important part) does not have any dependencies and where everything technical is interfaced around it, with an indirection layer in between, is what really matters. And all three approaches have this in common. The rest is pure details, and if you consider, for example, that the<a id="_idIndexMarker385"/> hexagonal shape does not bring anything to the method, as explained previously, the existence of several methods really gives the impression that some of them are there just because their author wanted to have t<a id="_idTextAnchor269"/>heir own method.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor270"/>Summary</h1>
<p>The C4 approach was used in this chapter to detail our demo application from four points of view, namely the context in which it is used, the containers it uses, and the components and code that it is made of. Diagrams following this approach have helped us explain what the sample information system we will create is about. We also learned that it is not necessary to create a diagram that completely covers the domain of study, but only for the bits these diagrams have value.</p>
<p>Also, lots of architectural methods have emerged in the past decades. Although they clearly have value in the design of software applications, and thus in information systems, they resemble very much each other in the sense that most recent methods are domain-centric; as such, their value can basically be summarized by the two principles that we already know, SOLID and business alignment principles, namely putting the business functions model first and applying a method to reduce the coupling to dependencies. Both of these make the evolution of a system easier. I do not have any doubt that these methods may have additional value for software organization, and they certainly help you to take a step further than purely technically oriented architecture patterns. However, as far as entire systems are concerned, the C4 approach explored at the beginning of the chapter should – in my opinion – be applied first in a top-down approach, leaving the domain-centric approaches as a way of organizing the third level (the components) of the C4 method.</p>
<p>In <a href="B21293_08.xhtml#_idTextAnchor271"><em class="italic">Chapter 8</em></a>, we will start defining more precisely the API on which our demonstration system will be based, as these entities are definitely the most important technical aspects if you want a freely evolving application. In the upcoming chapter, we will start by explaining the concept of service orientation and its relation to APIs. In <a href="B21293_09.xhtml#_idTextAnchor318"><em class="italic">Chapter 9</em></a>, we will use a semantics-based approach to define the business domains of our sample application and translate them into actual API contracts. We have talked a lot about business domains – in the next two chapters, they will be defined, as well as their interactions, for our demonstration system.</p>
</div>
</body></html>