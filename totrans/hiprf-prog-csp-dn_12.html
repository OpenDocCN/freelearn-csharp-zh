<html><head></head><body>
		<div><h1 id="_idParaDest-185"><em class="italic"><a id="_idTextAnchor189"/>Chapter 10</em>: Setting Up Our Database Project</h1>
			<p>In this and the following two chapters, we will be improving the performance of your database-based applications. In this chapter, we will be setting up our relational database and the code to access that database. In the next chapter, we will write benchmarks to test the performance of the different frameworks, which consist of Entity Framework, Dapper, and ADO.NET. Finally, in <a href="B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215"><em class="italic">Chapter 12</em></a>, <em class="italic">Responsive User Interfaces</em>, we will learn how to improve the performance of SQL Server and Cosmos DB.</p>
			<p>Data is extensively used in all aspects of our daily lives. In today's world of big data, the volume of data being collected and stored for all kinds of analysis is phenomenal. When working with data, performance can slow down exponentially as the size of your data grows. And depending on how much data you have to process, time is often critical.</p>
			<p>In this chapter, we will create a database and populate it, and we will write the code to access the database and perform insert, update, select, and delete operations. Our database access code will consist of Entity Framework, Dapper.NET, and ADO.NET.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">No code performance improvements will be discussed in this chapter. We are only concerned with setting up our database and source code in preparation for the benchmarking that we will be doing in the next chapter.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating and populating a SQL Server database</li>
				<li>Writing code to access the database using Entity Framework</li>
				<li>Writing code to access the database using Dapper.NET</li>
				<li>Writing code to access the database using ADO.NET</li>
			</ul>
			<p>After completing this chapter, you will be able to do the following:</p>
			<ul>
				<li>Log on to SQL Server Management Studio and execute database creation and seeding scripts</li>
				<li>Store secrets in <code>secrets.json</code> when developing so that secrets don't get stored in version control</li>
				<li>Access SQL Server databases and perform <strong class="bold">Create/Insert, Read/Select, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations using Entity Framework</li>
				<li>Access SQL Server databases and perform CRUD operations using Dapper.NET</li>
				<li>Access SQL Server databases and perform CRUD operations using ADO.NET</li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor190"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need to ensure that you have the following:</p>
			<ul>
				<li>SQL Server 2019 Express Edition or higher</li>
				<li>SQL Server Management Studio</li>
				<li>Visual Studio 2022</li>
				<li>This book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10</a><a href="https://github.com/PacktPublishing/Mastering-High-Performance-with-C-10.0-and-.NET-6&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor191"/>Setting up our database</h1>
			<p>In this section, we will set up our database and get our project ready for benchmarking. We will be <a id="_idIndexMarker1038"/>benchmarking different methods of inserting, updating, selecting, and deleting data. Let's start with setting up our database:</p>
			<ol>
				<li>Visit <a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs">https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs</a>.</li>
				<li>Download the <code>instnwnd.sql</code> file.</li>
				<li>Once the file has been downloaded, open it in SQL Server Management Studio.</li>
				<li>Execute the file. This will install the database.</li>
				<li>Open a <a id="_idIndexMarker1039"/>new query window and enter the following SQL code:<pre>USE [Northwind]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[InsertProduct] 
    @ProductName NVARCHAR(40),
    @CategoryID INT,
    @SupplierID INT,
    @Discontinued BIT
AS
BEGIN
SET NOCOUNT ON;
INSERT INTO 
        Products (
            ProductName,
            CategoryID,
            SupplierID,
            Discontinued,
             QuantityPerUnit
        )
    VALUES (
        @ProductName,
        @CategoryID,
        @SupplierID,
        @Discontinued,
         '1'
    )
END
GO</pre></li>
			</ol>
			<p>Once the code has been entered, execute the script. This code generates the <code>InsertProduct</code> stored <a id="_idIndexMarker1040"/>procedure. This stored procedure inserts a product into the <code>Products</code> table of the <code>Northwind</code> database.</p>
			<ol>
				<li value="6">Replace the existing SQL with the following SQ<a id="_idTextAnchor192"/>L:<pre>USE [Northwind]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[GetProductName]
    @ProductName NVARCHAR(40)
AS
BEGIN
    SET NOCOUNT ON;
    SELECT 
        Top 1 ProductName 
    FROM 
        Products
    WHERE
        ProductName LIKE @ProductName
END
GO</pre></li>
			</ol>
			<p>Execute the SQL to generate the <code>GetProductName</code> stored procedure. A product <a id="_idIndexMarker1041"/>name can have different variations. This stored procedure gets the top 1 name for the given product.</p>
			<ol>
				<li value="7">Replace the existing SQL code with the following SQL:<pre>USE [Northwind]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[FilterProducts]
    @ProductName NVARCHAR(40)
AS
BEGIN
        SET NOCOUNT ON;
        SELECT 
            * 
        FROM 
            Products
        WHERE
            ProductName LIKE @ProductName
END
GO</pre></li>
			</ol>
			<p>Execute the SQL to generate the <code>FilterProducts</code> stored procedure. The stored procedure returns all the products whose names contain the search term.</p>
			<ol>
				<li value="8">Now, replace <a id="_idIndexMarker1042"/>the existing SQL with this SQL:<pre>USE [Northwind]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[UpdateProductName]
        @OldProductName NVARCHAR(40),
        @NewProductName NVARCHAR(40)
AS
BEGIN
    SET NOCOUNT ON;
     UPDATE 
         Products
         SET 
            ProductName = @NewProductName
         WHERE
            ProductName = @OldProductName
END
GO</pre></li>
			</ol>
			<p>Execute this SQL to generate the <code>UpdateProductName</code> stored procedure. This procedure updates a product name from its current name to a new name.</p>
			<ol>
				<li value="9">Replace <a id="_idIndexMarker1043"/>the existing SQL with the following:<pre>USE [Northwind]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[DeleteProduct]
    @ProductName NVARCHAR(40)
AS
BEGIN
    SET NOCOUNT ON;
     DELETE FROM 
            Products
     WHERE
            ProductName = @ProductName
END
GO</pre></li>
			</ol>
			<p>Execute this code to generate the <code>DeleteProduct</code> stored procedure. This deletes products from the database that match the given product name.</p>
			<ol>
				<li value="10">Once the database <a id="_idIndexMarker1044"/>has been installed and all the procedures have been written and executed, you can close SQL Server Management Studio.</li>
			</ol>
			<p>Now that we have set up our database, we will set up our database access project.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor193"/>Setting up our database access project</h1>
			<p>In this section, we will be creating our database access project and classes. In the next chapter, we will <a id="_idIndexMarker1045"/>be writing some benchmarks that reference the classes that we will write in this chapter. Create the project as follows: </p>
			<ol>
				<li value="1">Open Visual Studio and create a new .NET 6.0 console application called <code>CH10_DataAccessBenchmarks</code>.</li>
				<li>Add the latest version of the <code>Microsoft.EntityFrameworkCore.SqlServer</code> NuGet package.</li>
				<li>Add the latest version of the <code>Dapper</code> NuGet package.</li>
				<li>Add the latest version of the <code>System.Data.SqlClient</code> NuGet package.</li>
				<li>Add a new folder called <code>Configuration</code>, and add two classes called <code>DatabaseSettings</code> and <code>SecretsManager</code>.</li>
				<li>Add a folder called <code>Data</code>, and add three classes called <code>AdoDotNetData</code>, <code>DapperDotNet</code>, and <code>EntityFrameworkCoreData</code>.</li>
				<li>Add a folder called <code>Models</code>, and add three classes called <code>Product</code>, <code>SqlCommandModel</code>, and <code>SqlCommandParameterModel</code>.</li>
				<li>Add a folder called <code>Reflection</code>, and add a class called <code>Properties</code>.</li>
				<li>On the main root, add a class called <code>BenchmarkTests</code>.</li>
				<li>Save the project.</li>
			</ol>
			<p>With that, we have created and updated our database with the stored procedures we will be calling, and <a id="_idIndexMarker1046"/>we have also put in place the project, folders, and class files that we will be using to benchmark the various types of data operations we normally perform on a database from code. Let's start by writing the <code>Properties</code> class.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor194"/>Writing the Properties class</h2>
			<p>As part of our <a id="_idIndexMarker1047"/>benchmarking, we need to <a id="_idIndexMarker1048"/>obtain the <code>FieldCount</code> value of a <code>DbDataRecord</code>. But the property is not readily accessible without using reflection. Therefore, to make our lives easier, we will write a class called <code>Properties</code> that helps us get the values of properties using reflection easily. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>Properties</code> class and add the following <code>using</code> statements:<pre>using System.Data.Common;
using System.Reflection;
internal class Properties 
{
}</pre></li>
			</ol>
			<p>We need both these namespaces to be imported as we are using reflection and need access to the <code>DbDataRecord</code> class.</p>
			<ol>
				<li value="2">Add the <code>GetProperty</code> method:<pre>public static PropertyInfo GetProperty&lt;T&gt;(string name)
{
      return typeof(T).GetProperty(name);
}</pre></li>
			</ol>
			<p>This method takes a generic type and a property name. Then, it obtains the property and returns it as a <code>PropertyInfo</code> instance.</p>
			<ol>
				<li value="3">Now, add the <code>GetValue</code> method:<pre>public static T GetValue&lt;T, U&gt;(U source, string name)
{
      return (T)GetProperty&lt;U&gt;(name).GetValue(source);
}</pre></li>
			</ol>
			<p>This method <a id="_idIndexMarker1049"/>takes a generic object <a id="_idIndexMarker1050"/>type, return type, and property name. Then, it calls the <code>GetProperty</code> method by passing in the generic object type and property name. The <code>GetValue</code> method is then called, passing in the source object. The result is cast to the generic return type and returned to the caller.</p>
			<ol>
				<li value="4">Add the <code>GetFieldCount</code> method:<pre>    public static int GetFieldCount(DbDataRecord 
        record)
    {
        return GetValue&lt;int, DbDataRecord&gt;(
        record, "FieldCount"
    );
}</pre></li>
			</ol>
			<p>This method accepts a <code>DbDataRecord</code> object. It calls our <code>GetValue</code> method by passing in the return type, our <code>DbDataRecord</code>, and our <code>FieldCount</code> property name. An integer is returned that contains the number of fields that our <code>DbDataRecord</code> object has.</p>
			<p>With that, we have created our <code>Properties</code> class. As part of our benchmarking, we will be inserting, reading, editing, and deleting data from a SQL Server database. And so, in the next section, we will update our <code>DatabaseSettings</code> class.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor195"/>Writing the DatabaseSettings class</h2>
			<p>Our <code>DatabaseSettings</code> class is <a id="_idIndexMarker1051"/>really simple: it contains a single property. Open the database and add the following property:</p>
			<pre class="source-code">public string ConnectionString { get; set; }</pre>
			<p>This property holds our connection string for the SQL Server database. We will be setting this property in each of our benchmark methods. Then, it will be passed to the constructors of our data access classes.</p>
			<p>Because database connection strings are a sensitive form of data that should be kept very private, we will be storing our database connection strings in a <code>secrets.json</code> file during the development process. But in production, we will obtain the connection string from an <code>appsettings.json</code> file. And so, in the next section, we will be writing a <code>SecretsManager</code> class.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor196"/>Writing the SecretsManager</h1>
			<p>In this section, we are <a id="_idIndexMarker1052"/>going to update our <code>SecretsManager</code> class so that we can safely obtain secrets. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Our development environment will use a <code>secrets.json</code> file. This is very serious as private credentials have been found and accessed on source code hosting sites such as GitHub before now, and we don't want to be the ones responsible for checking in code that contains secrets that should be kept private.</p>
			<p>Follow these steps:</p>
			<ol>
				<li value="1">Add the following NuGet packages:<pre>Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.JsonFile
Microsoft.Extensions.Configuration.EnvironmentVariables
Microsoft.Extensions.Configuration.UserSecrets</pre></li>
			</ol>
			<p>We need these packages so that we can configure the project for user secrets and <code>appsettings.json</code>.</p>
			<ol>
				<li value="2">Open the <code>SecretsManager</code> class and add the following <code>using</code> statements:<pre>using Microsoft.Extensions.Configuration;
using System;
using System.IO;</pre></li>
			</ol>
			<p>We need <a id="_idIndexMarker1053"/>these <code>using</code> statements for our property, filesystem, and environment variable access, and for access to the Microsoft <code>IConfiguration</code> interface.</p>
			<ol>
				<li value="3">Add the <code>Configuration</code> property:<pre>public static IConfiguration Configuration 
{
      get; private set; 
}</pre></li>
			</ol>
			<p>This property will hold the correct configuration object, which depends on whether we are in development or production mode.</p>
			<ol>
				<li value="4">Now, add the <code>GetSecrets</code> method:<pre>public static string GetSecrets&lt;T&gt;(string sectionName)
where T : class
{
var devEnvironmentVariable = 
    Environment
        .GetEnvironmentVariable("NETCORE_ENVIRONMENT");
var isDevelopment = 
    string.IsNullOrEmpty(devEnvironmentVariable) 
    || devEnvironmentVariable.ToLower() == "development";
var builder = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
        .AddJsonFile(
            "appsettings.json", 
            optional: true, 
            reloadOnChange: true
    )
    .AddEnvironmentVariables();
//only add secrets in development
if (isDevelopment) 
{
    builder.AddUserSecrets&lt;T&gt;();
}
Configuration = builder.Build();
return Configuration.GetSection($"{typeof(T).Name}
      :{sectionName}").Value;
}</pre></li>
			</ol>
			<p>This method determines whether we are in development or non-development mode. If we are <a id="_idIndexMarker1054"/>in development mode, then we use the secrets configuration mode. Otherwise, we obtain secrets from the <code>appsettings.json</code> file. The method accepts a section name, which is the name of the secret we want to retrieve, and it returns the value of that secret.</p>
			<p>With that, we have finished writing our <code>secrets</code> class. For our data manipulation benchmarks, we will <a id="_idIndexMarker1055"/>be focusing on a single table – the <code>Products</code> table of the <code>Northwind</code> database. We will need a class that will act as a model for the data. So, in the next section, we'll write the <code>Product</code> class.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor197"/>Writing the Product class</h1>
			<p>In this section, we <a id="_idIndexMarker1056"/>will update our <code>Product</code> class. It is a simple object that is used for data manipulation benchmarks and contains properties that match the <code>Products</code> table in the <code>Northwind</code> database. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>Product</code> class and update it as follows:<pre>using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
[Table("Products")]
public class Product
{
}</pre></li>
			</ol>
			<p>Here, we annotated our class with the <code>Table</code> annotation, passing the name of the table in the <code>Northwind</code> database that this class maps to into the annotation.</p>
			<ol>
				<li value="2">Add the following properties and annotations:<pre>[Key]
public int ProductID { get; set; }
public string ProductName { get; set; }
[ForeignKey("Suppliers")]
public int SupplierID { get; set; }
[ForeignKey("Categories")]
public int CategoryID { get; set; }
public string QuantityPerUnit { get; set; } = "1"
public decimal UnitPrice { get; set; }
public Int16 UnitsInStock { get; set; }
public Int16 UnitsOnOrder { get; set; }
public Int16 ReorderLevel { get; set; }
public bool Discontinued { get; set; }</pre></li>
			</ol>
			<p>These properties match the columns of the <code>Product</code> table in the <code>Northwind</code> database. The <code>[Key]</code> annotation identifies the <code>ProductID</code> property as the table's primary <a id="_idIndexMarker1057"/>key. Two foreign keys are identified by the <code>[ForeignKey]</code> annotation. We pass the name of the table into this annotation, which contains the primary key.</p>
			<p>And that's it – we've finished writing our <code>Product</code> class. We will be using several commands  and parameters when accessing data. To make life easy, we will have a <code>SqlCommandModel</code><code> </code>class for defining our commands, and a <code>SqlCommandParameterModel</code> class for defining our command parameters. Let's begin by writing the <code>SqlCommandModel</code> class.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor198"/>Writing the SqlCommandModel class</h1>
			<p>In this section, we <a id="_idIndexMarker1058"/>write a simple class that models a SQL command. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>SqlCommandModel</code> class, define the class as public, and add the <code>System.Data</code> namespace.</li>
				<li>Now, add the following three properties:<pre>public string CommandText { get; set; }
public CommandType CommandType { get; set; }
public SqlCommandParameterModel[] CommandParameters { 
    get; set; }</pre></li>
			</ol>
			<p>The <code>CommandText</code> property holds our SQL command. This may be the name of a stored <a id="_idIndexMarker1059"/>procedure or a SQL statement. The <code>CommandType</code> property determines whether the command is a <code>Text</code> command or a <code>StoredProcedure</code> command, while the <code>CommandParameters</code> property contains an array of SQL command parameters.</p>
			<p>Now that we have written <code>SqlCommandModel</code>, let's write the <code>SqlCommandParameterModel</code> class.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor199"/>Writing the SqlCommandParameterModel class</h1>
			<p>In this <a id="_idIndexMarker1060"/>section, we'll write our <code>SqlCommandParameterModel</code> class. This class is simply a SQL parameter definition model.</p>
			<p>Open the <code>SqlCommandParameterModel</code> class, make the class public, and add the <code>System.Data</code> namespace.</p>
			<p>Now, add the following three parameters:</p>
			<pre class="source-code">public string ParameterName { get; set; }</pre>
			<pre class="source-code">public DbType DataType { get; set; }</pre>
			<pre class="source-code">public dynamic Value { get; set; }</pre>
			<p>This class models a standard parameter that consists of the name of the parameter, its database type, and its value.</p>
			<p>With that, we have created the core functionality that we need in place for our data access classes. In the following sections, we will be writing data access classes to access data using Entity Framework, Dapper, and ADO.NET.</p>
			<p>The reason behind choosing SQL Server for the database server is that it is one of the most common database servers and is used in many business scenarios the world over. In professional <a id="_idIndexMarker1061"/>environments where SQL Server is employed, the three most common data access methods are Entity Framework, Dapper, and ADO.NET. That is why we will be benchmarking them in this chapter. Let's start by writing our ADO.NET data access class.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor200"/>Writing the AdoDotNet class</h1>
			<p>In this section, we will <a id="_idIndexMarker1062"/>be writing our data insertion methods. However, we will not be running our benchmarks, which will be performed in the next chapter as we analyze our results. Follow these steps:</p>
			<ol>
				<li value="1">Update the <code>AdoDotNetData</code> class, as follows:<pre>using CH10_DataAccessBenchmarks.Models;
using CH10_DataAccessBenchmarks.Reflection;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Data.SqlClient;
using System.Reflection;
internal class AdoDotNetData : IDisposable
{
private readonly SqlConnection _sqlConnection;
private bool _isDisposed;
public AdoDotNetData(string connectionString)
{
          _sqlConnection = 
           new SqlConnection(connectionString);
}
public void Dispose()
{
    Dispose(_isDisposed);
}
public void Dispose(bool disposing)
{
        if (disposing)
        {
        _sqlConnection.Dispose();
        _isDisposed = true;
    }
}
}</pre></li>
			</ol>
			<p>In the <a id="_idIndexMarker1063"/>preceding code, we implemented the <code>IDisposable</code> pattern. When we have finished with our class, we dispose of our class, which also disposes of disposable objects that it holds in memory.</p>
			<ol>
				<li value="2">Add the <code>ExecuteNonQuery</code> method:<pre>    internal void ExecuteNonQuery(SqlCommandModel 
        model)
    {
        SqlCommand sqlCommand 
         = new (model.CommandText, _sqlConnection);
     sqlCommand.CommandType = model.CommandType;
     foreach (SqlCommandParameterModel parameter in 
        model.CommandParameters)
     sqlCommand.Parameters.Add(new SqlParameter()
        {
            ParameterName = parameter.ParameterName,
            DbType = parameter.DataType,
            Value = parameter.Value
     });
     _sqlConnection.Open();
     sqlCommand.ExecuteNonQuery();
     _sqlConnection.Close();
}</pre></li>
			</ol>
			<p>This method takes a <code>SqlCommandModel</code> object. A new instance of the <code>SqlCommand</code> object is created. We pass the SQL command and SQL connection <a id="_idIndexMarker1064"/>into the constructor during instantiation. Then, we loop through the command parameters, instantiating and adding a <code>SqlParameter</code> for each <code>model.CommandParameter</code> to the <code>sqlCommand</code> object. Next, we open a connection to the database, execute the query, and close the connection.</p>
			<ol>
				<li value="3">Add the following code:<pre>internal int ExecuteNonQuery(string sql)
{
try
{
_sqlConnection.Open();
return new SqlCommand(sql, _sqlConnection)
    .ExecuteNonQuery();
}
finally
{
_sqlConnection.Close();
}
}</pre></li>
			</ol>
			<p>The preceding code executes the non-query SQL code that's been passed in via the <code>sql</code> string.</p>
			<ol>
				<li value="4">Add the <a id="_idIndexMarker1065"/>following generic scalar method:<pre>internal T ExecuteScalar&lt;T&gt;(string sql)
{
     try
     {
        _sqlConnection.Open();
        return (T)new SqlCommand(sql, _sqlConnection)
            .ExecuteScalar();
}
    finally
    {
        _sqlConnection.Close();
}
}</pre></li>
			</ol>
			<p>This method takes a SQL command as a string. A connection to the database is opened, and a new <code>SqlCommand</code> is instantiated. The <code>ExecuteScalar</code> command is executed, which returns a single value from the database. Before the value is returned, it is cast to the generic type specified by the caller and returned as that type. The connection is then closed.</p>
			<ol>
				<li value="5">Add the <a id="_idIndexMarker1066"/>following scalar method:<pre>internal T ExecuteScalar&lt;T&gt;(SqlCommandModel model)
{
SqlCommand sqlCommand = new(
     model.CommandText, _sqlConnection);
sqlCommand.CommandType = model.CommandType;
    foreach (SqlCommandParameterModel parameter in 
        model.CommandParameters)
        sqlCommand.Parameters.Add(new SqlParameter()
        {
            ParameterName = parameter.ParameterName,
            DbType = parameter.DataType,
            Value = parameter.Value
     });
  _sqlConnection.Open();
    T data = (T)sqlCommand.ExecuteScalar();
    _sqlConnection.Close();
    return data;
}</pre></li>
			</ol>
			<p>This method takes a <code>SqlCommandModel</code> and uses it to build up a <code>SqlCommand</code>. The <code>SqlCommand</code> class is executed by calling the <code>ExecuteScalar</code> method and is cast to the generic type before being returned.</p>
			<ol>
				<li value="6">Add <a id="_idIndexMarker1067"/>the following reader method:<pre>internal IEnumerator&lt;T&gt; ExecuteReader&lt;T&gt;(string sql)
{
    Type TypeT = typeof(T);
    ConstructorInfo ctor = 
      TypeT.GetConstructor(Type.EmptyTypes);
if (ctor == null)
    {
throw new InvalidOperationException($"Type 
    {TypeT.Name} does not have a default
        constructor.");
}
    _sqlConnection.Open();
IEnumerator data = new SqlCommand(sql, _sqlConnection)
 .ExecuteReader().GetEnumerator();    
while (data.MoveNext())
    {
        T newInst = (T)ctor.Invoke(null);
        DbDataRecord record = (DbDataRecord)
                data.Current;
        int fieldCount = Properties
             .GetFieldCount((DbDataRecord)
                data.Current);
     for (int i = 0; i &lt; fieldCount; i++)
        {
            string propertyName = record.GetName(i);
            PropertyInfo propertyInfo = TypeT
                 .GetProperty(propertyName);
             if (propertyInfo != null)
            {
                object value = record[i];
                if (value == DBNull.Value)
                    propertyInfo
                         .SetValue(newInst, null);
                 else
                    propertyInfo
                         .SetValue(newInst, value);
         }
     }
        yield return newInst;
}
}</pre></li>
			</ol>
			<p>This method takes a SQL statement and executes it by calling the <code>ExecuteReader</code> method. Once the method has been executed, we obtain the <a id="_idIndexMarker1068"/>reader's enumerator. Then, we iterate through the enumerator and build up an object for the current iteration and yield the result.</p>
			<ol>
				<li value="7">Add the following reader method:<pre>internal IEnumerator&lt;T&gt; ExecuteReader&lt;T&gt;
     (SqlCommandModel model) {
Type TypeT = typeof(T);
ConstructorInfo ctor 
         = TypeT.GetConstructor(Type.EmptyTypes);
if (ctor == null) {
throw new InvalidOperationException($"Type 
    {TypeT.Name} does not have a default
         constructor.");
}
SqlCommand sqlCommand 
    = new(model.CommandText, _sqlConnection);
sqlCommand.CommandType = model.CommandType;
foreach (SqlCommandParameterModel parameter in 
    model.CommandParameters)
sqlCommand.Parameters.Add(new SqlParameter() {
ParameterName = parameter.ParameterName,
DbType = parameter.DataType, Value = 
    parameter.Value});
_sqlConnection.Open();
SqlDataReader reader = sqlCommand.ExecuteReader();
if (reader.HasRows) {
while (reader.Read()) {
T newInst = (T)ctor.Invoke(null);
for (int i = 0; i &lt; reader.FieldCount; i++) {
     string propertyName = reader.GetName(i);
     PropertyInfo propertyInfo 
         = TypeT.GetProperty(propertyName);
     if (propertyInfo != null) {
         object value = reader[i];
         if (value == DBNull.Value)
               propertyInfo.SetValue(newInst, null);
         else  
               propertyInfo.SetValue(newInst, value);
     }
}        
    yield return newInst;
}
}
  _sqlConnection.Close();
}</pre></li>
			</ol>
			<p>This reader method takes a <code>SqlCommandModel</code> and builds up a <code>SqlCommand</code>. It executes the reader and obtains <code>SqlDataReader</code>. It iterates <a id="_idIndexMarker1069"/>through the reader and builds up an instance of the generic type that is then yielded to the user.</p>
			<p>That's our ADO.NET data access class completed. Now, let's learn how to write the Entity Framework data access class.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor201"/>Writing the EntityFrameworkCoreData class</h1>
			<p>In this section, we <a id="_idIndexMarker1070"/>will be writing the methods for our Entity Framework data access class. The code we will write in this section will be executed in the next chapter. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>EntityFrameworkCoreData</code> class and edit it as follows:<pre>using CH10_DataAccessBenchmarks.Models;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using Microsoft.Data.SqlClient;
using System.Linq;
using Microsoft.EntityFrameworkCore.SqlServer
    .Infrastructure.Internal;
public class EntityFrameworkCoreData : DbContext
{
    private string _connectionString = string.Empty;
    public DbSet&lt;Product&gt; Products { get; set; }
    public EntityFrameworkCoreData(string 
        connectionString) : base(GetOptions
             (connectionString))
    {
        _connectionString = connectionString;
    }
    private static DbContextOptions GetOptions(string 
        connectionString)
    {
    return SqlServerDbContextOptionsExtensions
        .UseSqlServer(new DbContextOptionsBuilder(), 
            connectionString).Options;
    }</pre></li>
			</ol>
			<p>Our class inherits from the <code>DbContext</code> class of the <code>Microsoft.EntityFrameworkCore</code> library. We declare a variable to hold our database connection string, and a variable to hold a collection of <code>Products</code>. In our constructor, we set the connection string and call the base constructor.</p>
			<ol>
				<li value="2">Add <a id="_idIndexMarker1071"/>the <code>OnConfiguring</code> method:<pre>protected override void OnConfiguring
     (DbContextOptionsBuilder optionsBuilder)
{     
      optionsBuilder.UseSqlServer(_connectionString);
}</pre></li>
			</ol>
			<p>This method determines that we will be using SQL Server and passes in the SQL Server connection string that we will be using.</p>
			<ol>
				<li value="3">Add the following method, which executes raw SQL:<pre>public int ExecuteSQL(string sql)
    {
        return Database.ExecuteSqlRaw(sql, null);
}</pre></li>
			</ol>
			<p>This method takes a SQL statement and executes it against the database as raw SQL. The returned value is the number of records affected by the execution of the statement.</p>
			<ol>
				<li value="4">Add the following method for executing a stored procedure as a non-query:<pre>public int ExecuteNonQuerySP(SqlCommandModel model)
    {
        SqlParameter[] parameters 
        = new SqlParameter[model.CommandParameters
            .Length];
        for (int i = 0; i &lt; parameters.Length; i++)
        {
            parameters[i] = new SqlParameter(
            model.CommandParameters[i].ParameterName,
             model.CommandParameters[i].Value
             );
     }
        if (parameters.Length == 4)
            return Database.ExecuteSqlRaw(
             model.CommandText, parameters[0], 
             parameters[1], parameters[2], 
             parameters[3]
         );
     else if (parameters.Length == 2)
         return Database.ExecuteSqlRaw(
             model.CommandText, parameters[0], 
             parameters[1]
         );
     else
         return Database.ExecuteSqlRaw(
             model.CommandText, parameters[0]
         );
}</pre></li>
			</ol>
			<p>In this method, we build up a <code>SqlParameter</code> array from our <code>SqlCommandModel</code>. Then, we execute raw SQL by passing in each of the parameters to the stored procedure. This execution is a non-query and returns the number of rows affected by running the procedure.</p>
			<ol>
				<li value="5">The following <a id="_idIndexMarker1072"/>method will execute and return a scalar value of the <code>string</code> type:<pre>public string ExecuteScalarSP(string productName)
    {
        return Products.FromSqlRaw(
            "EXEC FilterProducts @ProductName={0}",
            new SqlParameter() { 
        ParameterName = "@ProductName", Value = 
                productName })
            .AsEnumerable().FirstOrDefault()
              .ProductName;
    }</pre></li>
			</ol>
			<p>This method executes a stored procedure with a single parameter. We obtain the enumerable return object and filter it to get the first record. The name of the product is then returned as a string.</p>
			<ol>
				<li value="6">Add the final method to our class, which returns an enumerator:<pre>public IEnumerator&lt;Product&gt; ExecuteReaderSP(string 
    productName)
{
return Products.FromSqlRaw(
        "EXEC FilterProducts @ProductName={0}", 
        new SqlParameter() { 
             ParameterName = "@ProductName", 
             Value = productName 
         }
     ).GetEnumerator();
}</pre></li>
			</ol>
			<p>This executes a stored procedure with a single parameter and returns an enumerator full of filtered products.</p>
			<p>With that, we <a id="_idIndexMarker1073"/>have written all our Entity Framework classes. Now, it's time to write our Dapper.NET methods.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor202"/>Writing the DapperDotNet class</h1>
			<p>In this section, we'll <a id="_idIndexMarker1074"/>write our Dapper.NET methods. This is the last section before we write our benchmarking methods. We will run the code we write in this section in the next chapter. Follow these steps:</p>
			<ol>
				<li value="1">Open the <code>DapperDotNet</code> class, add the <code>SimpleCRUD</code> package, and modify it as follows:<pre>public class DapperDotNet : IDisposable
{
    private bool isDisposed = false;
     private IDbConnection _dbConnection;
     public DapperDotNet(string connection)
    {
     SimpleCRUD
            .SetDialect(SimpleCRUD.Dialect.SQLServer);
         _dbConnection = new SqlConnection
             (connection);
     }
     public void Dispose()
    {
         Dispose(true);
        GC.SuppressFinalize(this);
     }
     protected virtual void Dispose(bool disposing)
    {
        if (isDisposed)
            return;
         if (disposing)
             _dbConnection.Dispose();
         isDisposed = true;
}
}</pre></li>
			</ol>
			<p>We implement the <code>IDisposable</code> pattern in this class and set the SQL dialect to the <a id="_idIndexMarker1075"/>SQL Server.</p>
			<ol>
				<li value="2">Add the following non-query method:<pre>    public int ExecuteNonQuery(string sql)
    {
        try
        {
            _dbConnection.Open();
            return _dbConnection.Execute(sql);
     }
        finally
        {
            _dbConnection.Close();
     }
    }</pre></li>
			</ol>
			<p>This method executes raw SQL and returns the number of records affected by the SQL statement.</p>
			<ol>
				<li value="3">Add <a id="_idIndexMarker1076"/>the following method to execute a non-query:<pre>public void ExecuteNonQuery(SqlCommandModel model)
    {
        try
        {
            _dbConnection.Open();
         var parameters = new DynamicParameters();
            foreach (
             SqlCommandParameterModel parameter in  
             model.CommandParameters
         ) 
             parameters.Add(
                 parameter.ParameterName, 
                 parameter.Value
             );
             _dbConnection.Query(
             model.CommandText, 
             parameters, 
             commandType: CommandType.StoredProcedure
         );
        }
        finally
     {
            _dbConnection.Close();
        }
}</pre></li>
			</ol>
			<p>This method takes a <code>SqlCommandModel</code> instance and builds up a <code>DynamicParameter</code> bag. Then, it executes a stored procedure defined by the model's <code>CommandText</code>.</p>
			<ol>
				<li value="4">Add <a id="_idIndexMarker1077"/>the following generic scalar method:<pre>    public T ExecuteScalar&lt;T&gt;(string sql)
    {
        try
        {
            _dbConnection.Open();
            return _dbConnection.ExecuteScalar
                &lt;T&gt;(sql);
     }
        finally
        {
            if (_dbConnection != null 
             &amp;&amp; _dbConnection.State 
                 == ConnectionState.Open)
             _dbConnection.Close();
     }
}</pre></li>
			</ol>
			<p>This method takes a SQL statement and executes it, returning a single value of the required type.</p>
			<ol>
				<li value="5">Add the <a id="_idIndexMarker1078"/>following method, which executes a stored procedure and returns a string:<pre>public string ExecuteScalarSP(SqlCommandModel model)
{
        try
        {
            _dbConnection.Open();
            var parameters = new DynamicParameters();
                parameters.Add(
                model.CommandParameters[0]
                 .ParameterName,   
             model.CommandParameters[0].Value
         );
            return _dbConnection.Query&lt;Product&gt;(
             model.CommandText, 
             parameters, 
             commandType: CommandType.StoredProcedure
         ).First().ProductName;
     }
        finally
        {
            if (
             _dbConnection != null 
             &amp;&amp; _dbConnection.State 
                 == ConnectionState.Open)
             _dbConnection.Close();
     }
}</pre></li>
			</ol>
			<p>This method takes a <code>SqlCommandModel</code> instance and uses it to execute a stored <a id="_idIndexMarker1079"/>procedure. Remember to add the missing <code>using</code> statements for <code>SqlCommandModel</code> to the class. The stored procedure execution returns a type of <code>IEnumerable&lt;Product&gt;</code>. So, we obtain the first product in the list and return its <code>ProductName</code>.</p>
			<ol>
				<li value="6">Add the following method, which executes raw SQL and returns a type of <code>IEnumerator&lt;T&gt;</code>:<pre>public IEnumerator&lt;T&gt; ExecuteReader&lt;T&gt;(string sql) 
    where T : class
{
         try
        {
            _dbConnection.Open();
            return _dbConnection.Query&lt;T&gt;(sql)
             .GetEnumerator();
    }
        finally
        {
            if (_dbConnection != null 
             &amp;&amp; _dbConnection.State 
                 == ConnectionState.Open)
             _dbConnection.Close();
    }
}</pre></li>
			</ol>
			<p>This method executes a raw SQL string and returns a type of <code>IEnumerable&lt;T&gt;</code>.</p>
			<ol>
				<li value="7">Add the <a id="_idIndexMarker1080"/>following method, which executes a stored procedure and returns a type of <code>IEnumerator&lt;Product&gt;</code>:<pre>    public IEnumerator&lt;Product&gt; ExecuteReaderSP
        &lt;Product&gt;(
    SqlCommandModel model
)
    {
        try
        { 
            _dbConnection.Open();
            var parameters = new DynamicParameters();
            foreach (SqlCommandParameterModel 
                parameter in model.CommandParameters)
             parameters.Add(
                 parameter.ParameterName, 
                 parameter.Value
             );
         return _dbConnection.Query&lt;Product&gt;(
             model.CommandText, 
             parameters, 
             commandType: CommandType.StoredProcedure
         ).GetEnumerator();
     }
        finally
        {
            if (_dbConnection != null 
             &amp;&amp; _dbConnection.State 
             == ConnectionState.Open)
         _dbConnection.Close();
     }
}</pre></li>
			</ol>
			<p>This method takes a <code>SqlCommandModel</code> instance and builds up a parameterized <a id="_idIndexMarker1081"/>stored procedure that is executed. A type of <code>IEnumerator&lt;Product&gt;</code> is returned.</p>
			<ol>
				<li value="8">Add our final dapper method, which will obtain the first product name that matches the <code>productName</code> parameter:<pre>public string GetProductNameSP(string productName)
    {
        try
        {
            _dbConnection.Open();
            var parameters = new DynamicParameters();
            parameters.Add("@ProductName", 
                productName);
            return _dbConnection.Query&lt;Product&gt;(
             $"GetProductName", parameters, 
             commandType: CommandType.StoredProcedure
             ).First().ProductName;
     }
        finally
        {
            if (_dbConnection != null 
             &amp;&amp; _dbConnection.State 
             == ConnectionState.Open)
             _dbConnection.Close();
        }
}</pre></li>
			</ol>
			<p>This method takes a product name and executes the <code>GetProductName</code> stored procedure. The stored procedure matches all the products in the database <a id="_idIndexMarker1082"/>whose product names are like the product name argument. Then, it gets the first product in the returned list and returns its product name.</p>
			<p>That concludes our database and data access project setup in preparation for the benchmarking work we will be doing in the next chapter. Let's review what we have accomplished in this chapter.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor203"/>Summary</h1>
			<p>In this chapter, we downloaded the <code>Products</code> table.</p>
			<p>After making sure that we have our database in place with the required stored procedures, we started a .NET 6.0 console application. We added our model class and data access classes for performing data access operations in Entity Framework, Dapper, and ADO.NET.</p>
			<p>In the next chapter, we will be benchmarking the data access methods for each of these frameworks. In the <em class="italic">Further reading</em> section, you can further your knowledge of Entity Framework, Dapper, and ADO.NET using the links provided.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor204"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>Entity Framework Core: <a href="https://docs.microsoft.com/ef/core/&#13;">https://docs.microsoft.com/ef/core/</a></li>
				<li>Dapper: <a href="https://dapper-tutorial.net/dapper&#13;">https://dapper-tutorial.net/dapper</a></li>
				<li>ADO.NET: <a href="https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/">https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/</a></li>
			</ul>
		</div>
	</body></html>