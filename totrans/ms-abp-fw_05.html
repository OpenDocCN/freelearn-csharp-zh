<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-80"><em class="italic"><a id="_idTextAnchor130"/>Chapter 4</em>: Understanding the Reference Solution</h1>
			<p>In the previous chapter, we built a simple full-stack web application that is used to manage products with categories. We've seen a typical flow of developing applications with ABP Framework. You are now ready to create your own application with the basic features. In the next chapters, you will better understand the ABP features and create more advanced applications.</p>
			<p>Giving examples with real-world complexities in a book is not very easy. Having reflected on that, we've prepared a complete, real-world reference application built with ABP Framework: <em class="italic">EventHub</em>. It is open source and freely available on GitHub.</p>
			<p>The EventHub solution is thought of as a live system that is available on <a href="http://openeventhub.com.">openeventhub.com.</a> You can just try it out to explore it. We've established the <strong class="bold">continuous integration/continuous development</strong> (<strong class="bold">CI/CD</strong>) pipelines, and we are updating the website as we develop it and get contributions from the community. Feel free to see its source code, submit bug reports or feature requests, or even send your pull requests to contribute! As the name suggests, this is an open platform.</p>
			<p>This book is the only source of documentation that explains the EventHub solution because we've mainly prepared it for the readers of this book. I will refer to that solution in the next chapters of the book, especially in <em class="italic">Part 3</em>, <em class="italic">Implementing Domain-Driven Design</em>.</p>
			<p>In this chapter, we will investigate the EventHub solution in the following sections:</p>
			<ul>
				<li>Introducing the application</li>
				<li>Understanding the architecture</li>
				<li>Running the solution</li>
			</ul>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor131"/>Technical requirements</h1>
			<p>You can clone or download the source code of the EventHub project from GitHub, at <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>.</p>
			<p>If you want to run the solution in your local development environment, you need to have an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>)/editor (such as Visual Studio) to build and run ASP.NET Core solutions. You also need to have <strong class="bold">Docker</strong> installed on your computer. You can download and install <strong class="bold">Docker Desktop</strong> for the development environment by following the documentation at <a href="https://docs.docker.com/get-docker">https://docs.docker.com/get-docker</a>.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor132"/>Introducing the application</h1>
			<p>EventHub<a id="_idIndexMarker210"/> is a platform that is used to create organizations to organize events. You create events, either online or in person, then people register them. The following screenshot is taken from the <strong class="bold">Home</strong> page of the <a href="http://openeventhub.com">openeventhub.com</a> website:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_4.01_B17287.jpg" alt="Figure 4.1 – EventHub Home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – EventHub Home page</p>
			<p>You can explore upcoming<strong class="bold"> Events</strong> section on the <strong class="bold">Home</strong> page. Click on an event for details and register for the event. You get an email notification before the event starts or the event time changes.</p>
			<p>Here is another screenshot from the <strong class="bold">Create New Event</strong> page:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_4.02_B17287.jpg" alt="Figure 4.2 – Create New Event page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Create New Event page</p>
			<p>You can select one of your owned organizations <a id="_idIndexMarker211"/>on this page, set a <strong class="bold">Title</strong>, time, and description, pick a <strong class="bold">Cover Image</strong>, and determine other details about the event you are organizing.</p>
			<p>If you want to learn more, please register at <a href="http://openeventhub.com">openeventhub.com</a> and explore the platform. In this book, I want to talk about the technical details rather than the application's features. Let's begin with the big picture and understand the solution's architecture.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor133"/>Understanding the architecture</h1>
			<p>Here is an overall diagram of the applications inside the solution:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_4.03_B17287.jpg" alt="Figure 4.3 – Applications of the EventHub solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Applications of the EventHub solution</p>
			<p>There are six applications<a id="_idIndexMarker212"/> and one database shown in <em class="italic">Figure 4.3</em>, and more information on them is provided here:</p>
			<ul>
				<li><strong class="bold">Authentication Server</strong>: This application is used for logging in, registering, and managing the user account. It is based on ABP's standard <strong class="bold">Account</strong> module, which is based on the <strong class="source-inline">IdentityServer</strong> library. It is a <strong class="bold">single sign-on</strong> (<strong class="bold">SSO</strong>) server, which means that if you log in to one of the applications, you are then logged in to all of the applications (and vice versa, meaning that if you log out of one of the applications, you are logged out of all of the applications). That is an <strong class="bold">ASP.NET Core Razor Pages</strong> application, and it directly connects to <strong class="bold">The Database</strong>.</li>
				<li><strong class="bold">Main Website</strong>: This is an essential website (<a href="http://www.openeventhub.com">www.openeventhub.com</a>) of the platform used by <strong class="bold">End Users</strong> to create new events and register for events. It is an <strong class="bold">ASP.NET Core Razor Pages</strong> application that uses the <strong class="bold">Main HTTP API</strong> as the backend.</li>
				<li><strong class="bold">Admin Application</strong>: This application allows <strong class="bold">Admin Users</strong> to manage organizations, events, and the system. It uses the <strong class="bold">Admin HTTP API</strong> for all the operations, which is a <strong class="bold">Blazor WebAssembly</strong> application that runs in the browser.</li>
				<li><strong class="bold">Main HTTP API</strong>: Exposes <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) to be consumed by the main website.</li>
				<li><strong class="bold">Admin HTTP API</strong>: Exposes HTTP APIs to be consumed by the admin application.</li>
				<li><strong class="bold">Background Services</strong>: A <strong class="bold">console application</strong> that runs background workers and background jobs of the system.</li>
				<li><strong class="bold">The Database</strong>: This is a relational <strong class="bold">PostgreSQL</strong> database that stores all the data in the system.</li>
			</ul>
			<p>Since it is a distributed system, it uses <strong class="bold">Redis</strong> as the distributed cache server.</p>
			<p>It is a good idea to start by understanding the authentication flow to then understand the system.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor134"/>Authentication flow</h2>
			<p>As mentioned in the previous<a id="_idIndexMarker213"/> section, the <strong class="bold">Authentication Server</strong> is an SSO server used to authenticate users and clients. <strong class="bold">Main Website</strong> and <strong class="bold">Admin Application</strong> use the <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) protocol to redirect users to the <strong class="bold">Authentication Server</strong> when users want or need to log in to the application. The following diagram shows the login process:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_4.04_B17287.jpg" alt="Figure 4.4 – The authentication flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – The authentication flow</p>
			<p>In <em class="italic">Figure 4.4</em>, the logic process occurs in the following order:</p>
			<ul>
				<li>Whenever a user wants to visit a page that requires<a id="_idIndexMarker214"/> authentication <strong class="bold">(1)</strong> or a user explicitly clicks to the login link, the <strong class="bold">Main Website</strong> redirects the user <strong class="bold">(2)</strong> to the <strong class="bold">Authentication Server</strong>.</li>
				<li><strong class="bold">Authentication Server</strong> has a login page so that users can enter a username and password or register as a new user. Once the login process is done, the user is redirected back to the <strong class="bold">Main Website</strong> with an authorization code <strong class="bold">(3)</strong> and <strong class="bold">(4)</strong>.</li>
				<li>The <strong class="bold">Main Website</strong> then performs a token request <strong class="bold">(5)</strong> to the server using the obtained authorization code.</li>
				<li><strong class="bold">Authentication Server</strong> returns an <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) token (contains some user information such as username, ID, email, and so on) and an access token <strong class="bold">(6)</strong>.</li>
				<li>The <strong class="bold">Main Website</strong> stores the access token in a cookie so that it can be obtained in the next requests. In the next requests, it gets the access token from the cookie and adds it to the HTTP request header while performing HTTP requests to the <strong class="bold">Main HTTP API</strong> application <strong class="bold">(7)</strong>.</li>
				<li>The <strong class="bold">Main HTTP API</strong> application validates the access token <strong class="bold">(8)</strong> and authorizes the request.</li>
			</ul>
			<p>The <strong class="bold">Main Website</strong> uses cookies to store the access<a id="_idIndexMarker215"/> token, as mentioned. On the other hand, the <strong class="bold">Admin (Blazor WebAssembly) Application</strong> stores the access token in the local storage of the browser and adds it to the HTTP request header in every request to the server.</p>
			<p>All that process is done by ABP's <strong class="source-inline">Account</strong> and <strong class="source-inline">IdentityServer</strong> modules with some configurations in the applications. I won't show the detailed configuration here to keep this chapter focused on the overall solution structure and architecture (check the source code for more details). </p>
			<p>In the next section, we will explore the EventHub .NET solution and the projects inside it.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor135"/>Exploring the solution</h2>
			<p>The EventHub .NET solution consists of several projects, grouped by the application type and shown in the following screenshot:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.05_B17287.jpg" alt="Figure 4.5 – EventHub .NET solution in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – EventHub .NET solution in Visual Studio</p>
			<p>The solution contains a single domain layer with two application<a id="_idIndexMarker216"/> layers and corresponding HTTP API and <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) layers. Two applications use the single domain layer but they have different application logic, so they are separated. We will return to this topic (multiple application layers) in the <em class="italic">Dealing with multiple applications</em> section of <a href="B17287_09_Epub_AM.xhtml#_idTextAnchor300"><em class="italic">Chapter 9</em></a>,<em class="italic"> Understanding Domain-Driven Design</em>.</p>
			<p>Let's begin explaining the projects with the core part, the <strong class="source-inline">common</strong> folder. That folder contains common libraries and services, as outlined here:</p>
			<ul>
				<li>The <strong class="source-inline">EventHub.Domain</strong> project is the domain layer that contains the entities, domain services, and other domain objects. The <strong class="source-inline">EventHub.Domain.Shared</strong> project contains constants and some other classes, which are shared among all layers and applications in the solution.</li>
				<li>The <strong class="source-inline">EventHub.EntityFrameworkCore</strong> project contains the code that defines <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>) <strong class="source-inline">DbContext</strong>, mappings, database migrations, repository implementations, and other code related to EF Core.</li>
				<li>The <strong class="source-inline">EventHub.DbMigrator</strong> project is a console application that you can run to apply pending database migrations and seed the initial data (such as the admin user/ role and their permissions). It is suitable to use in development and production environments.</li>
				<li>The <strong class="source-inline">EventHub.BackgroundServices</strong> project is another console application that runs background workers and jobs on the system and should always be running.</li>
			</ul>
			<p>The <strong class="source-inline">www</strong> folder contains<a id="_idIndexMarker217"/> the <strong class="bold">Main Website</strong> (<a href="http://www.openeventhub.com">www.openeventhub.com</a>) application's components, listed as follows:</p>
			<ul>
				<li>The <strong class="source-inline">EventHub.Application</strong> project is the application layer that contains the implementation of the application services, while the <strong class="source-inline">EventHub.Application.Contracts</strong> project includes the application service interfaces and <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>) that are shared with the UI layer.</li>
				<li>The <strong class="source-inline">EventHub.HttpApi</strong> project contains the API controllers that are consumed by the UI (web) layer. The controllers in that project are simple wrappers around the application services.</li>
				<li>The <strong class="source-inline">EventHub.HttpApi.Host</strong> project hosts the HTTP API layer. In this way, the hosting logic is separated from the project that contains the API controllers (which makes it possible to reuse the <strong class="source-inline">EventHub.HttpApi</strong> project as a library).</li>
				<li>The <strong class="source-inline">EventHub.HttpApi.Client</strong> project is a library that can be referenced by a .NET application to consume the API controllers easily. The UI (web) layer uses that project to call the HTTP APIs. This project uses ABP's dynamic C# proxy feature, which will be covered in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>. In this way, we don't need to deal with HTTP clients and low-level details to call HTTP APIs from the UI layer.</li>
				<li>The <strong class="source-inline">EventHub.Web</strong> project is the UI layer of the application. That is a typical Razor Pages application that renders the <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) in the server. It has no database connection but uses the <strong class="bold">Main HTTP API</strong> application for all operations.</li>
				<li>The <strong class="source-inline">EventHub.Web.Theme</strong> project is a custom theme for the application. ABP has a theming system that you can use to build your own themes and reuse them in any application. The <strong class="source-inline">EventHub.Web</strong> project uses this theme. Theming system will be covered in <em class="italic">Part 4</em>, <em class="italic">User Interface and API Development</em>.</li>
			</ul>
			<p>The <strong class="source-inline">admin</strong> folder contains the admin application<a id="_idIndexMarker218"/> that is used by the users who maintain the system, and is explained in more detail here:</p>
			<ul>
				<li>The <strong class="source-inline">EventHub.Admin.Application</strong> project is the application layer of the admin side that contains the implementation of the application services, while the <strong class="source-inline">EventHub.Admin.Application.Contracts</strong> project includes the application service interfaces and DTOs that are shared with the UI layer.</li>
				<li>The <strong class="source-inline">EventHub.Admin.HttpApi</strong> project contains the API controllers that are consumed by the UI (web) layer.</li>
				<li>The <strong class="source-inline">EventHub.Admin.HttpApi.Host</strong> project hosts the HTTP API layer. In this way, the hosting logic is separated from the project that contains the API controllers.</li>
				<li>The <strong class="source-inline">EventHub.Admin.HttpApi.Client</strong> project is a library that can be referenced by a .NET application to consume the API controllers easily. The UI (web) layer uses that project to call the HTTP APIs. This project uses ABP's dynamic C# proxy feature, which will be covered in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>. In this way, we don't need to deal with HTTP clients and low-level details to call HTTP APIs from the UI layer.</li>
				<li>The <strong class="source-inline">EventHub.Admin.Web</strong> project is the UI layer of the application. That is a <strong class="bold">Blazor WebAssembly</strong> application that runs in the browser and performs HTTP API calls to the server.</li>
			</ul>
			<p>Finally, the <strong class="source-inline">account</strong> folder contains the <strong class="bold">Authentication Server</strong>, which contains a single project, <strong class="source-inline">EventHub.IdentityServer</strong>, that is used by other applications to authenticate the users.</p>
			<p>I've explained all the projects in the solution, in brief. It is also important to understand the relations and dependencies between the projects.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor136"/>Project dependencies</h2>
			<p>Separating the solution into multiple projects makes it possible to have multiple applications on runtime while sharing the code base between applications where it is necessary.</p>
			<p>In the next sections, I will show the dependency graph of each application so that you can understand how the code base is organized. We begin with the <strong class="bold">Main Website</strong>, the essential application.</p>
			<h3>Main Website</h3>
			<p>Remember that the <strong class="bold">Main Website</strong> is the application<a id="_idIndexMarker219"/> that is used by the <strong class="bold">End Users</strong>: <a href="http://www.openeventhub.com">www.openeventhub.com</a>. I won't use the <em class="italic">EventHub</em> prefix for project names anymore since all the projects have the same prefix, and there is no need to repeat it everywhere. The following diagram shows the project dependencies, beginning from the root project of the application—<strong class="source-inline">Web</strong>:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.06_B17287.jpg" alt="Figure 4.6 – Main website project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Main website project dependencies</p>
			<p>The <strong class="source-inline">Web</strong> project depends on <strong class="source-inline">Web.Theme</strong>, which implements the EventHub application's UI theme. <strong class="source-inline">Web.Theme</strong> is a separate project because it is reused from the <strong class="bold">Authentication Server</strong> application. That is an example of reusing a UI theme between multiple applications.</p>
			<p>The <strong class="source-inline">Web</strong> project also depends on the <strong class="source-inline">HttpApi</strong> project. In this way, the HTTP API controllers become available in the web application, and we can consume these APIs from the client (JavaScript) code. However, when you call an HTTP API controller of this application, the request is redirected to the <strong class="bold">Main HTTP API</strong> (backend) by using the <strong class="source-inline">HttpApi.Client</strong> package. Notice that both the <strong class="source-inline">HttpApi</strong> and <strong class="source-inline">HttpApi.Client</strong> project reference the <strong class="source-inline">Application.Contacts</strong> project. API controllers in the <strong class="source-inline">HttpApi</strong> project use the application service interfaces, while the <strong class="source-inline">HttpApi.Client</strong> package implements these interfaces (using ABP's dynamic C# proxy system, which will be explored in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>) to perform remote HTTP calls to the <strong class="bold">Main HTTP API</strong> application. So, this application becomes a proxy for the direct API calls between the client (JavaScript) and the HTTP API server. The actual implementations of the application service interfaces run in the <strong class="bold">Main HTTP API</strong> application, which will be explained in the next section.</p>
			<h3>Main HTTP API</h3>
			<p><strong class="bold">Main HTTP API</strong> is used by the <strong class="bold">Main Website</strong> as the backend API. It runs the application and domain<a id="_idIndexMarker220"/> logic of the application and is deployed to <a href="http://api.openeventhub.com">api.openeventhub.com</a>. The following diagram shows the root <strong class="source-inline">HttpApi.Host</strong> project and its direct and indirect dependencies:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_4.07_B17287.jpg" alt="Figure 4.7 – Main HTTP API project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Main HTTP API project dependencies</p>
			<p>By referencing (adding a project dependency to) the <strong class="source-inline">HttpApi</strong> project (which includes the API controllers), we can respond to HTTP API calls. The API controllers use the application service interfaces defined in the <strong class="source-inline">Application.Contracts</strong> project. These interfaces are implemented by the <strong class="source-inline">Application</strong> project. That is why we need to reference the <strong class="source-inline">Application</strong> project from the <strong class="source-inline">HttpApi.Host</strong> project. The <strong class="source-inline">Application</strong> project uses the <strong class="source-inline">Domain</strong> project to perform the business logic of the application.</p>
			<p>The <strong class="source-inline">HttpApi.Host</strong> project also references the <strong class="source-inline">EntityFrameworkCore</strong> project since we need a data layer on runtime. The <strong class="source-inline">EntityFrameworkCore</strong> project maps entities to the tables in the database, and implements the repositories defined in the <strong class="source-inline">Domain</strong> project.</p>
			<p>Notice that the <strong class="source-inline">Application.Contracts</strong> project (and the <strong class="source-inline">Domain.Shared</strong> project, indirectly) is shared by the client application, the <strong class="bold">Main Website</strong>, so they can rely on the same application service interfaces to communicate.</p>
			<p>We have now explored the <strong class="bold">Main Website</strong> application components. The next section continues from the admin side.</p>
			<h3>Admin application</h3>
			<p>The admin application is a Blazor WebAssembly<a id="_idIndexMarker221"/> application that runs on the browser and is accessed using the following <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>): <a href="http://admin.openeventhub.com">admin.openeventhub.com</a>. It is used by the users who maintain the system. This application has a different set of APIs, UI pages, authorization rules, caching requirements, and so on. Hence, we've created a different application and HTTP API layers for that application. Nevertheless, it shares the same domain layer, so it uses the same domain logic and the same database.</p>
			<p>Let's start from the following diagram of the frontend (Blazor WebAssembly) application:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_4.08_B17287.jpg" alt="Figure 4.8 – Admin website project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Admin website project dependencies</p>
			<p>This diagram is simple compared to previous ones. The <strong class="source-inline">Admin.Web</strong> project (which is the Blazor WebAssembly application) references the <strong class="source-inline">Admin.HttpApi.Client</strong> project because it needs to call remote HTTP APIs. ABP's dynamic C# client proxy system (covered in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>) makes it possible to use the application service interfaces in the Blazor WebAssembly application to consume Admin HTTP APIs on the server easily. The <strong class="source-inline">Admin.HttpApi.Client</strong> project depends on the <strong class="source-inline">Admin.Application.Contracts</strong> project (which internally depends on the <strong class="source-inline">Domain.Shared</strong> project) to be able to use the application service interfaces defined in that project.</p>
			<h3>Admin HTTP API</h3>
			<p>The <strong class="bold">Admin HTTP API</strong> application is used by the admin website as a backend API. It runs the application and domain logic of the admin application and is deployed to <a href="https://admin-api.openeventhub.com">https://admin-api.openeventhub.com</a>. The following diagram shows the root <strong class="source-inline">Admin.HttpApi.Host</strong> project and its direct and indirect dependencies:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_4.09_B17287.jpg" alt="Figure 4.9 – Admin HTTP API project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Admin HTTP API project dependencies</p>
			<p>The diagram is very similar to the diagram of the <strong class="bold">Main HTTP API</strong> application. The difference<a id="_idIndexMarker222"/> is that the <strong class="bold">Admin Application</strong> has different HTTP API and application layers. However, it uses the same <strong class="bold">Domain</strong> and database integration (<strong class="source-inline">EntityFrameworkCore</strong>) layers to share the same core domain rules and the same <strong class="bold">Database</strong>. I will return to that topic in the <em class="italic">Dealing with multiple applications</em> section of <a href="B17287_09_Epub_AM.xhtml#_idTextAnchor300"><em class="italic">Chapter 9</em></a>, <em class="italic">Understanding Domain-Driven Design</em>.</p>
			<p>All the applications use the <strong class="bold">Authentication Server</strong> application as an SSO server, discussed in the next section.</p>
			<h3>Authentication Server</h3>
			<p>The <strong class="bold">Authentication Server</strong>'s root project is the <strong class="source-inline">IdentityServer</strong> project and has the dependencies shown in the following diagram:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_4.10_B17287.jpg" alt="Figure 4.10 – Authentication Server project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Authentication Server project dependencies</p>
			<p>The <strong class="source-inline">IdentityServer</strong> project has a reference to the <strong class="source-inline">Web.Theme</strong> project, which is the UI theme that is shared with the <strong class="bold">Main Website</strong>. It also references the <strong class="source-inline">EntityFrameworkCore</strong> project to be able to use the <strong class="bold">Database</strong>. By referencing the <strong class="source-inline">EntityFrameworkCore</strong> project, we also have indirect references to the <strong class="source-inline">Domain</strong> and <strong class="source-inline">Domain.Shared</strong> projects.</p>
			<p>The next section shows the dependencies of the final application in the solution.</p>
			<h3>Background Services</h3>
			<p>The <strong class="source-inline">BackgroundServices</strong> project has the dependencies shown in the following diagram:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_4.11_B17287.jpg" alt="Figure 4.11 – BackgroundServices project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – BackgroundServices project dependencies</p>
			<p>The <strong class="source-inline">BackgroundServices</strong> project uses the <strong class="source-inline">EntityFrameworkCore</strong> project so that it can work with the <strong class="bold">Database</strong>. It can also use the <strong class="bold">Domain</strong> objects (entities, domain services) to perform background tasks.</p>
			<p>We've <a id="_idIndexMarker223"/>explored <a id="_idIndexMarker224"/>all the projects in the solution. Now, we are ready to run them in our local development environment.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor137"/>Running the solution</h1>
			<p>If you want<a id="_idIndexMarker225"/> to run the solution in your local environment, follow the steps in the next sections.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor138"/>Cloning the GitHub repository</h2>
			<p>First of all, you <a id="_idIndexMarker226"/>need to <a id="_idIndexMarker227"/>clone the GitHub repository on your local computer. The repository is located at <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a> and can be cloned using the following command (which requires Git tools to be installed):</p>
			<p class="source-code">git clone https://github.com/volosoft/eventhub.git</p>
			<p>Alternatively, navigate to <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>, click the <strong class="bold">Code</strong> button, and then click <strong class="bold">Download ZIP</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_4.12_B17287.jpg" alt="Figure 4.12 – Downloading the EventHub repository from GitHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Downloading the EventHub repository from GitHub</p>
			<p>You should<a id="_idIndexMarker228"/> extract the ZIP <a id="_idIndexMarker229"/>file into an empty folder.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor139"/>Running the infrastructure</h2>
			<p>The EventHub<a id="_idIndexMarker230"/> solution needs <strong class="bold">Redis</strong> and <strong class="bold">PostgreSQL</strong> servers. The repository contains <strong class="source-inline">docker-compose</strong> files in the <strong class="source-inline">etc/docker</strong> folder. If you have the Docker installed on your computer, you can execute the <strong class="source-inline">up.ps1</strong> file in that folder to run these servers. If you can't use PowerShell on your computer, you can just open it in a text editor, copy the content, and execute it in a command-line terminal in the <strong class="source-inline">etc/docker</strong> directory. In the first run, it may take a few minutes to download the Docker images. If you don't want to use Docker, you need to install <strong class="bold">Redis</strong> and <strong class="bold">PostgreSQL</strong> servers on your computer.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor140"/>Opening the solution</h2>
			<p>The cloned or <a id="_idIndexMarker231"/>downloaded repository contains an <strong class="source-inline">EventHub.sln</strong> file in the root folder. If you want to develop or debug the solution, open it in Visual Studio or another .NET-compatible IDE.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor141"/>Creating a database</h2>
			<p>The solution has a <a id="_idIndexMarker232"/>console application named <strong class="source-inline">EventHub.DbMigrator</strong> that is shown in <em class="italic">Figure 4.5</em>. Run this application (for Visual Studio, right-click on it and choose <strong class="bold">Set as the startup project</strong>, then hit <em class="italic">Ctrl</em> + <em class="italic">F5</em>). It will create a database and seed some initial data.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor142"/>Running the applications</h2>
			<p>We are now ready to<a id="_idIndexMarker233"/> start the actual applications. You can run the projects in the following order (for Visual Studio, right-click on each project, select <strong class="bold">Set as the startup project</strong>, then hit <em class="italic">Ctrl</em> + <em class="italic">F5</em>):</p>
			<ul>
				<li><strong class="source-inline">EventHub.IdentityServer</strong></li>
				<li><strong class="source-inline">EventHub.HttpApi.Host</strong></li>
				<li><strong class="source-inline">EventHub.Web</strong></li>
				<li><strong class="source-inline">EventHub.Admin.HttpApi.Host</strong></li>
				<li><strong class="source-inline">EventHub.Admin.Web</strong></li>
				<li><strong class="source-inline">EventHub.BackgroundServices</strong></li>
			</ul>
			<p>To log in to one of the applications, use <strong class="source-inline">admin</strong> as the username and <strong class="source-inline">1q2w3E*</strong> as the password. Of course, you can create additional users on the UI.</p>
			<p>Notice that Visual Studio has some problems when you run multiple applications. Sometimes, a previously run application may stop. In this case, run the stopped applications again. However, Microsoft's <strong class="source-inline">Tye</strong> project makes it much easier to run multiple applications.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor143"/>Using the Tye project</h2>
			<p>If you don't need to<a id="_idIndexMarker234"/> develop or<a id="_idIndexMarker235"/> debug the solution but just want to run it, you can use the Microsoft <strong class="source-inline">Tye</strong> project to run it without opening an IDE. <strong class="source-inline">Tye</strong> is a .NET global tool used to run such distributed applications easily with a simple configuration file. The EventHub solution was configured to run with <strong class="source-inline">Tye</strong>. All you need to do is to install <strong class="source-inline">Tye</strong> and run it.</p>
			<p>Before using <strong class="source-inline">Tye</strong>, you still need to run the infrastructure (see the <em class="italic">Running the infrastructure</em> section), then create a database using the <strong class="source-inline">EventHub.DbMigrator</strong> application. If you haven't done this before, open a command-line terminal in the <strong class="source-inline">src/EventHub.DbMigrator</strong> directory and run the following command:</p>
			<p class="source-code">dotnet run</p>
			<p>After the database is ready, you can install <strong class="source-inline">Tye</strong> using the following command in a command-line terminal:</p>
			<p class="source-code">dotnet tool install -g Microsoft.Tye</p>
			<p>At the time of writing this book, the <strong class="source-inline">Tye</strong> project was still in preview. You may need to specify the latest preview version (you<a id="_idIndexMarker236"/> can find this on NuGet, at <a href="https://www.nuget.org/packages/Microsoft.Tye">https://www.nuget.org/packages/Microsoft.Tye</a>). For example, see the following code snippet:</p>
			<p class="source-code">dotnet tool install -g Microsoft.Tye --version "0.10.0-alpha.21420.1"</p>
			<p>Check <a href="https://github.com/dotnet/tye/blob/main/docs/getting_started.md">https://github.com/dotnet/tye/blob/main/docs/getting_started.md</a> to learn how to install <strong class="source-inline">Tye</strong>.</p>
			<p><strong class="source-inline">Tye</strong> requires Docker to be installed on your computer. If you haven't installed it yet, you also need to do so. After all the installation is done, you can run the following command to start the applications (it is suggested to close the IDE first if it is open):</p>
			<p class="source-code">tye run</p>
			<p>It will take some time on the first run. Once it is complete, you can open a browser and navigate to <strong class="source-inline">http://127.0.0.1:8000</strong> to open the <strong class="bold">Tye Dashboard</strong>, which you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_4.13_B17287.jpg" alt="Figure 4.13 – The Tye Dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – The Tye Dashboard</p>
			<p>The <strong class="bold">Tye Dashboard</strong> is used to <a id="_idIndexMarker237"/>view the<a id="_idIndexMarker238"/> applications and their <strong class="bold">Logs</strong> in real time. You can click links on the <strong class="bold">Bindings</strong> column for any application to open. <strong class="source-inline">web</strong> is the <strong class="bold">Main Website</strong> of the system.</p>
			<p>Tye is a handy tool when you have a solution with multiple applications that need to run together. You can also configure <strong class="source-inline">dotnet watch</strong> for a project so that it is automatically reloaded (or hotloaded with .NET 6.0) when you change it. See Microsoft's documentation to learn more about this: <a href="https://github.com/dotnet/tye/tree/main/docs">https://github.com/dotnet/tye/tree/main/docs</a>.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor144"/>Summary</h1>
			<p>EventHub is a complete, real-world quality application built on ABP Framework. It is not just an example but also a live project published on <a href="http://openeventhub.com">openeventhub.com</a> and actively developed on <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>. Feel free to send bug reports, feature requests, and pull requests.</p>
			<p>In this chapter, my purpose was not to explain the code base in detail. I explained the overall architecture and structure of the solution so that you can understand how to explore the code base and run the solution. The next chapters will refer to that solution while introducing some ABP features and concepts.</p>
			<p>EventHub is a good example of a system that was built with multiple applications. It is also a clear example to understand the purpose of ABP's layering model and how to reuse these layers in different applications.</p>
			<p>You may not understand all the details of the EventHub solution now because we haven't explained the module system, database integrations, dynamic C# client proxies, and all the other ABP features yet. The chapters in the next part will explore the fundamental building blocks of ABP Framework and the ASP.NET Core framework so that you will start to understand all the details.</p>
			<p>In the next chapter, we will explore the basic building blocks of ASP.NET Core and ABP Framework to understand how an application is configured and initialized.</p>
		</div>
	</body></html>