["```cs\n    interface IComparatorStrategy<T> \n    { int Execute(T a, T b); } \n\n```", "```cs\n    class IntComparator : IComparatorStrategy<int> { \n      public int Execute(int a, int b) { \n        return a > b ? 1 : (b > a ) ? -1 : 0; \n      } \n    } \n\n    class DoubleComparator : IComparatorStrategy<double> { \n      public int Execute(double a, double b){ \n        return a > b ? 1 : (b > a) ? -1 : 0; \n      } \n    } \n\n```", "```cs\n    private static void BSort<T>(this T[] arr,  \n    IComparatorStrategy<T> test) where T : struct \n    { \n      int n = arr.Length; \n      for(int i = 0; i<n; ++i) \n      for (int j = 0; j < n-i-1; j++) \n      if (test.Execute(arr[j],arr[j + 1]) > 0){ \n        T temp = arr[j]; arr[j] = arr[j + 1]; \n        arr[j + 1] = temp; \n      } \n    } \n\n```", "```cs\n    int [] s= {  -19,20,41, 23, -6}; \n    s.BSort(new IntComparator()); \n    foreach( var n in s )  \n    Console.WriteLine(n); \n\n```", "```cs\n    double[] s2 = { -19.3, 20.5, 41.0, 23.6, -6.0 }; \n    s2.BSort(new DoubleComparator()); \n    foreach (var n in s2) \n    Console.WriteLine(n); \n\n```", "```cs\n    private static void BSort2<T>(this T[] arr,  \n    Func<T,T,int> test) where T : struct \n    { \n      int n = arr.Length; \n      for (int i = 0; i < n; ++i) \n      for (int j = 0; j < n - i - 1; j++) \n      if (test(arr[j], arr[j + 1]) > 0) { \n        T temp = arr[j]; arr[j] = arr[j + 1]; \n        arr[j + 1] = temp; \n      } \n    } \n\n```", "```cs\n    int[] s3 = { -19, 20, 41, 23, -6 }; \n    Func<int ,int ,int> fn = (int a, int b ) => { \n      return (a > b) ? 1 : -1; \n    }; \n    s3.BSort2(fn); \n    foreach (var n in s3) \n    Console.WriteLine(n); \n\n```", "```cs\n    s3.BSort2( (int a, int b ) =>  (a > b ) ? 1 : -1); \n\n```", "```cs\n    s4.BSort2( (double  a, double  b ) =>  (a > b ) ? 1 : -1); \n\n```", "```cs\n    double[] arr = { 2, 4, 4, 4 ,5, 5, 7, 9}; \n    List<double> arrlist = arr.ToList(); \n    double nsum = 0; \n    foreach (var n in arr) { \n      nsum += n;  \n    } \n    double avg = nsum / arrlist.Count; \n    Console.WriteLine(avg); \n\n```", "```cs\n    private static double Aggregate( double [] p ,  \n    double init,Func<double,double,double> fn)  \n    { \n      double temp = init; \n      foreach (var n in p) \n      temp =  fn(n,temp); \n      return temp; \n    } \n\n```", "```cs\n    private static double AMEAN(double[] p) \n    { \n      return Aggregate(p, 0, (double a, double b) =>  \n      { return b += a; }) / p.Length; \n    } \n\n```", "```cs\n    private static double GMEAN(double[] p) \n    { \n      double pi = Aggregate(p, 1,  \n      (double a, double accum) => { return accum *= a; }); \n      return Math.Exp(Math.Log(pi)*(1 / p.Length)); \n    } \n\n```", "```cs\n    private static double STD(double[] p) \n    { \n      double avg = Aggregate(p, 0,(double a, double b) =>  \n      { return b += a; }) / p.Length; \n      double var = Aggregate(p, 0, (double a, double b) =>  \n      { return b += ((a - avg)*(a-avg)); }) / p.Length; \n      return Math.Sqrt(var); \n    } \n\n```", "```cs\n    public static double []  Map( double []  src,  \n    Func<double,double> fnapply) \n    { \n      double[] ret = new double[src.Length]; \n      Parallel.For(0,ret.Length, \n      new ParallelOptions {  \n        MaxDegreeOfParallelism =Environment.ProcessorCount }, \n        (i) => { ret[i] = fnapply(src[i]); \n      }); \n      return ret; \n    } \n\n```", "```cs\n    public static double Reduce( double[] arr, \n    Func<double,double,double> reducer,double init) \n    { \n      double accum = init; \n      for(int i=0; i< arr.Length; ++i) \n      accum = reducer(arr[i], accum); \n      return accum; \n    } \n\n```", "```cs\n    double[] arr = { 2, 4, 4, 4 ,5,5,7,9}; \n    double avg = Reduce( Map(arr,(double a) => {return a;}),  \n    (double a, double b) =>  \n    {return b +=a;},0)/arr.Length; \n    double var = Reduce(Map(arr, (double a) =>  \n    {return (a-avg)*(a-avg); }), \n    (double a, double b) =>  \n    {return b += a; }, 1) / arr.Length; \n    Console.WriteLine(Math.Sqrt(var)); \n\n```", "```cs\n    public static double CashFlowPVDiscreteAnnual( \n    List<double> arr, double rate, double period) \n    { \n      int len = arr.Count; \n      double PV = 0.0; \n      for (int i = 0; i < len; ++i) \n      PV += arr[i] / Math.Pow((1+rate/100), i); \n      return PV; \n    } \n\n```", "```cs\n    public static double CashFlow_IRR_Annual(List<double> arr, \n    double rate,double period)  \n    { \n      const double ACCURACY = 1.0e-5; \n      const int MAX_ITERATIONS = 50; \n      const double ERROR = -1e30; \n      double x1 = 0.0; \n      double x2 = 20.0; \n      // create an initial bracket,  \n      // with a root somewhere between bot,top \n      double f1 = CashFlowPVDiscreteAnnual(arr,x1,period); \n      double f2 = CashFlowPVDiscreteAnnual(arr,x2,period); \n\n      for (int j = 0; j < MAX_ITERATIONS; ++j) \n      { \n        if ( (f1*f2) < 0.0)  {break; } \n\n        if (Math.Abs(f1) < Math.Abs(f2))  \n          f1 = CashFlowPVDiscreteAnnual(arr, \n          x1+= 1.06*(x1-x2),period ); \n        else  \n          f2 = CashFlowPVDiscreteAnnual(arr, \n          x2+=1.06*(x2-x1),period); \n        if (f2*f1>0.0) \n          return ERROR; \n      } \n      double f = CashFlowPVDiscreteAnnual(arr,x1,period); \n      double rtb; \n      double dx=0; \n      if (f<0.0) { \n        rtb = x1;dx=x2-x1; \n      } \n      else { \n        rtb = x2; dx = x1-x2; \n      } \n      for (int i=0;i<MAX_ITERATIONS;i++) \n      { \n        dx *= 0.5; \n        double x_mid = rtb+dx; \n        double f_mid = CashFlowPVDiscreteAnnual(arr,x_mid,period); \n        if (f_mid<=0.0) { rtb = x_mid; } \n        if ( (Math.Abs(f_mid)<ACCURACY) ||  \n        (Math.Abs(dx)<ACCURACY) ) \n        return x_mid; \n      } \n      return ERROR; // error. \n    } \n\n```", "```cs\n    public class IRR_PARAMS \n    { \n      public List<double> revenue { get; set; } \n      public double rate { get; set; } \n      public double period { get; set; } \n    } \n\n```", "```cs\n    public abstract class IRRComputationEngine \n    { \n      public abstract IRR_PARAMS Compute(); \n      public double Evaluate() \n      { \n        IRR_PARAMS par = Compute(); \n        if (par == null) return -1; \n        return CashFlow_IRR_Annual(par.revenue, \n        par.rate, par.period);  \n      } \n      private static double CashFlow_IRR_Annual( \n      List<double> arr,double rate,double period) \n      { //----- Code Omitted } \n    } \n  } \n\n```", "```cs\n    public class BridgeIRR :IRRComputationEngine { \n      IRR_PARAMS ps = new IRR_PARAMS(); \n      public BridgeIRR(List<double> rev, double period, double rate){ \n        ps.period = period; ps.rate = rate; ps.revenue = rev; \n      } \n      public override IRR_PARAMS Compute() { return ps;} \n    } \n\n```", "```cs\n    double[] ns = { 10, 12, 13, 14, 20 }; \n    BridgeIRR test = new BridgeIRR(ns.ToList(),10,5); \n    double irr = test.Evaluate(); \n    Console.WriteLine(irr); \n\n```", "```cs\n    public class IRRComputationEngine2 \n    { \n      public delegate IRR_PARAMS Compute(); \n      public Compute comp{get;set;}  \n\n      public double Evaluate() \n      { \n        if (comp == null) return -1; \n        IRR_PARAMS par = comp(); \n        return CashFlow_IRR_Annual(par.revenue, \n        par.rate, par.period); \n      } \n      private static double CashFlow_IRR_Annual( \n        List<double> arr,double rate,double period) \n      { //--- Code Omitted } \n    } \n\n```", "```cs\n    IRRComputationEngine2 n = new IRRComputationEngine2(); \n    double[] ns = { 10, 12, 13, 14, 20 }; \n    n.comp = () => { \n      IRR_PARAMS par = new IRR_PARAMS(); \n      par.revenue = ns.ToList(); \n      par.rate = 10; par.period = 5; \n      return par; \n    }; \n    double r = n.Evaluate(); \n    Console.WriteLine(r);\n```"]