- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Mastering Physics and Animation in Unity Game Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握Unity游戏开发中的物理和动画
- en: This chapter delves into the realms of physics and animation, which are both
    crucial in ensuring that your games are imbued with realism and dynamism. We will
    explore the fundamentals of Unity physics, from Rigidbody dynamics and colliders
    to Physic Materials, then transition into animating game characters, dissecting
    the `Animator` component and animation states, as well as integrating external
    animations. As we progress, the focus will shift to scripting environmental interactions
    and advanced animation techniques such as **Inverse Kinematics** (**IK**) and
    Blend Trees, addressing the challenges of synchronizing animations with physics
    for lifelike movements. This comprehensive guide lays a solid foundation in physics
    and animation within Unity, paving the way for more engaging and interactive gaming
    experiences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨物理和动画领域，这两个领域对于确保你的游戏充满真实感和动态性至关重要。我们将探讨Unity物理学的根本原理，从刚体动力学和碰撞体到物理材料，然后过渡到游戏角色的动画制作，分析`Animator`组件和动画状态，以及集成外部动画。随着我们的进展，重点将转向脚本化环境交互和高级动画技术，如**逆运动学**（**IK**）和混合树，解决同步动画与物理以实现逼真运动的问题。本全面指南在Unity中为物理和动画奠定了坚实的基础，为更吸引人和互动的游戏体验铺平了道路。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The core concepts of Unity physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity物理学的核心概念
- en: Creating and controlling character animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和控制角色动画
- en: Scripting interactions with the environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与环境交互的脚本
- en: Employing advanced animation features for complex visual experiences
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级动画功能实现复杂视觉体验
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you start, ensure that your development environment is set up as described
    in [*Chapter 1*](B22128_01.xhtml#_idTextAnchor015). This includes having the latest
    recommended version of Unity and a suitable code editor installed on your system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保你的开发环境已按照[*第1章*](B22128_01.xhtml#_idTextAnchor015)中描述的方式进行设置。这包括在你的系统上安装最新推荐的Unity版本和合适的代码编辑器。
- en: Hardware requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件要求
- en: Ensure that your computer meets Unity’s minimum hardware specifications, especially
    a graphics card that supports at least DX10 (shader model 4.0) and a minimum of
    8 GB of RAM for optimal performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的计算机满足Unity的最低硬件规格，特别是至少支持DX10（着色器模型4.0）的显卡和至少8 GB的RAM以实现最佳性能。
- en: Software requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件要求
- en: 'Before diving into development, ensure you have the following tools ready:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发之前，请确保你已经准备好了以下工具：
- en: '**Unity Editor**: Utilize the version of the Unity Editor installed from [*Chapter
    1*](B22128_01.xhtml#_idTextAnchor015), ideally the latest **Long-Term Support**
    (**LTS**) version.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity编辑器**：使用从[*第1章*](B22128_01.xhtml#_idTextAnchor015)安装的Unity编辑器版本，理想情况下是最新**长期支持**（**LTS**）版本。'
- en: '**Code editor**: Use Visual Studio or Visual Studio Code with Unity development
    tools; these should already be integrated as per the initial setup.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编辑器**：使用带有Unity开发工具的Visual Studio或Visual Studio Code；这些工具应已根据初始设置集成。'
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter08](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter08)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到与本章相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter08](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter08)
- en: The core concepts of Unity physics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity物理学的核心概念
- en: Embarking on the exploration of Unity’s physics engine marks a pivotal chapter
    in your journey to understanding the intricacies of game development. This foundational
    section is your gateway to mastering the elements that breathe life into static
    objects, transforming them into dynamic participants of a virtual world governed
    by the laws of physics. Here, we will delve into the core components that make
    up Unity’s physics engine—Rigidbody, colliders, and Physic Materials. Each plays
    a crucial role in simulating realistic object interactions that are fundamental
    to the immersive game experience. Through a series of focused tutorials, we’ll
    navigate the principles of gravity, friction, and collision detection, equipping
    you with the knowledge to apply forces, manipulate impulses, and construct simple
    yet engaging physics-based puzzles. Prepare to unravel the mechanics behind the
    movement and interaction of game objects, setting the stage for creating more
    compelling and interactive gaming environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开始探索Unity的物理引擎标志着你在理解游戏开发复杂性的旅程中的一个关键章节。这一基础部分是你掌握赋予静态物体生命力的元素，将它们转变为受物理定律支配的虚拟世界中的动态参与者的门户。在这里，我们将深入研究构成Unity物理引擎的核心组件——刚体、碰撞体和物理材质。每个组件都在模拟现实物体交互中扮演着至关重要的角色，这些交互是沉浸式游戏体验的基础。通过一系列专注的教程，我们将导航重力、摩擦和碰撞检测的原则，为你提供应用力、操纵冲量和构建简单但引人入胜的基于物理的谜题的知识。准备好揭开游戏对象运动和交互背后的机制，为创建更具吸引力和互动性的游戏环境奠定基础。
- en: Understanding physics components
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解物理组件
- en: 'In the realm of Unity game development, mastering the intricacies of physics
    components not only enhances the realism of your game world but also enriches
    the player’s interaction within it. At the heart of these interactions lie two
    fundamental components: Rigidbodies and colliders. Each plays a pivotal role in
    translating the laws of physics from theoretical constructs into tangible gameplay
    experiences.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏开发领域，掌握物理组件的复杂性不仅增强了游戏世界的真实性，也丰富了玩家在其中的交互。这些交互的核心是两个基本组件：刚体和碰撞体。每个组件都在将物理定律从理论结构转化为可触摸的游戏体验中扮演着关键角色。
- en: Rigidbodies
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚体
- en: The `RigidBody` component is the cornerstone of physical simulation in Unity.
    By attaching a Rigidbody to a game object, you grant it the ability to interact
    with forces, allowing it to exhibit realistic movement and rotation. This transformation
    from a static entity to a dynamic one opens up a myriad of possibilities for gameplay
    mechanics. The key properties of a Rigidbody include **mass**, **drag**, and **angular
    drag**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`RigidBody`组件是Unity中物理模拟的基石。通过将刚体附加到游戏对象上，你赋予它与力交互的能力，使其能够表现出逼真的运动和旋转。这种从静态实体到动态实体的转变为游戏机制提供了无限可能。刚体的关键属性包括**质量**、**阻力**和**角阻力**。'
- en: Mass determines the heaviness of an object, affecting how it responds to forces
    and collisions. A higher mass means that the object will require a greater force
    to move or stop. Drag acts as air resistance, slowing down the object’s movement
    and eventually bringing it to a halt if no other forces act upon it. This is crucial
    for simulating objects moving through fluid environments or adding resistance
    to aerial objects. Angular drag is similar to drag but for rotational motion,
    affecting how quickly an object can stop spinning. Lower angular drag means that
    the object will spin longer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 质量决定了物体的重量，影响它对力和碰撞的反应。质量越大，物体移动或停止所需的力就越大。阻力充当空气阻力，减慢物体的运动，并在没有其他力作用的情况下最终将其停止。这对于模拟物体在流体环境中移动或为空中物体增加阻力至关重要。角阻力与阻力类似，但针对旋转运动，影响物体停止旋转的速度。角阻力越低，物体旋转的时间就越长。
- en: The Unity Editor’s `RigidBody` component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器的`RigidBody`组件。
- en: '![Figure 8.1 – The Rigid Body component as it appears in the Inspector window](img/B22128_08_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 在检查器窗口中显示的刚体组件](img/B22128_08_1.jpg)'
- en: Figure 8.1 – The Rigid Body component as it appears in the Inspector window
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 在检查器窗口中显示的刚体组件
- en: In the Unity Editor’s `RigidBody` component to a GameObject. Typically, you
    will only need to select the **isKinematic** option for objects that are static
    and do not move. Adding a RigidBody to static objects and setting them as kinematic
    ensures that collisions with other objects are properly detected by Unity’s physics
    system, even if the static object itself doesn’t use gravity. The **Use Gravity**
    option is usually enabled, except in special scenarios such as outer space-themed
    games.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity编辑器的`RigidBody`组件中添加到GameObject。通常，你只需要为静态且不移动的物体选择**isKinematic**选项。将RigidBody添加到静态物体并将它们设置为kinematic确保Unity的物理系统能够正确检测与其他物体的碰撞，即使静态物体本身不使用重力。**Use
    Gravity**选项通常启用，除非在特殊场景中，如太空主题游戏。
- en: The `Box collider` component is added and configured within the Unity Editor’s
    **Inspector** window.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box碰撞体`组件是在Unity编辑器的**检查器**窗口中添加和配置的。'
- en: '![Figure 8.2 – The Box collider component as it appears in the Inspector window](img/B22128_08_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – Box碰撞体组件在检查器窗口中的外观](img/B22128_08_02.jpg)'
- en: Figure 8.2 – The Box collider component as it appears in the Inspector window
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – Box碰撞体组件在检查器窗口中的外观
- en: Just like RigidBodies, colliders are added to a GameObject in the **Inspector**
    window. Colliders are offered in several different shapes. You’ll usually use
    a Capsule collider for a Character. Note the **isTrigger** option; if this is
    selected, the collider will report when another GameObject with a collider intersects
    its space.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像RigidBodies一样，碰撞体是在**检查器**窗口中添加到GameObject的。碰撞体提供了几种不同的形状。你通常会对角色使用胶囊碰撞体。注意**isTrigger**选项；如果选中，碰撞体会报告当另一个具有碰撞体的GameObject与其空间相交时。
- en: Incorporating these properties allows developers to fine-tune the physical behavior
    of objects, ensuring that they behave as expected in various scenarios. For instance,
    setting the right mass and drag can differentiate a feather’s slow descent from
    a rock’s rapid fall.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过整合这些属性，开发者可以微调物体的物理行为，确保它们在各种场景中表现出预期的行为。例如，设置正确的质量和阻力可以区分羽毛的缓慢下降和岩石的快速坠落。
- en: Colliders
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞体
- en: 'Colliders serve as the invisible force fields that define the boundaries of
    an object for the purpose of collision detection. Without colliders, objects would
    pass through each other, breaking the immersion and realism of the game world.
    There are two main types of colliders: primitive colliders and mesh colliders:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞体作为定义物体碰撞检测边界的无形力场。没有碰撞体，物体将相互穿过，破坏游戏世界的沉浸感和现实感。主要有两种类型的碰撞体：原始碰撞体和网格碰撞体：
- en: Primitive colliders are simple shapes (Box, Sphere, Capsule) that are computationally
    efficient and often used to approximate the collision boundaries of more complex
    objects. Their simplicity makes them ideal for most collision detection scenarios.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始碰撞体是简单的形状（盒形、球体、胶囊），计算效率高，通常用于近似更复杂物体的碰撞边界。它们的简单性使它们成为大多数碰撞检测场景的理想选择。
- en: Mesh colliders, on the other hand, are used when the shape of an object is too
    complex to be approximated by a primitive collider. They conform to the object’s
    exact shape, allowing for precise collision detection but at a higher computational
    cost.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，当物体的形状过于复杂，无法用原始碰撞体来近似时，就会使用网格碰撞体。它们符合物体的精确形状，允许进行精确的碰撞检测，但计算成本更高。
- en: The choice between primitive and mesh colliders depends on the need for accuracy
    versus the need to conserve computational resources. For dynamic objects involved
    in frequent collisions, primitive colliders are preferred. Mesh colliders, on
    the other hand, might be reserved for static elements in an environment where
    precise collision boundaries are crucial.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之间选择原始碰撞体和网格碰撞体取决于对精度和节省计算资源的需求。对于参与频繁碰撞的动态物体，通常首选原始碰撞体。另一方面，网格碰撞体可能被保留用于环境中静态元素，在这些环境中精确的碰撞边界至关重要。
- en: Understanding and effectively utilizing Rigidbodies and colliders is fundamental
    to crafting believable and interactive game environments. By manipulating properties
    such as mass and drag, and by selecting the appropriate type of collider, developers
    can simulate a wide range of physical behaviors and interactions. As we transition
    from the static to the dynamic, from the immovable to the kinetic, our next focus
    will be on the forces that act upon these entities. The next sub-section will
    delve into how we apply the invisible hands that guide and animate the objects
    within our game world, propelling them with purpose and direction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并有效地利用 Rigidbodies 和碰撞体对于构建逼真和交互式的游戏环境至关重要。通过操纵质量、阻力和选择适当的碰撞体类型，开发者可以模拟广泛的物理行为和交互。当我们从静态过渡到动态，从不可移动过渡到动态时，我们的下一个关注点将是作用于这些实体的力。下一小节将深入探讨如何应用那些引导和动画化我们游戏世界中物体的无形之手，使它们有目的地被推动并具有方向性。
- en: Exploring forces, gravity, and impulses
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索力、重力和冲量
- en: In the captivating dance of objects within the virtual realms we craft in Unity,
    the choreography is dictated by forces and the foundational principle of gravity.
    This segment of our exploration of Unity’s physics engine delves into the art
    of applying forces and manipulating gravity and impulses. These elements are not
    merely variables in equations but the very essence that breathes life into static
    objects, transforming them into dynamic actors on the stage of our game worlds.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用 Unity 构建的虚拟领域中物体之间的迷人舞蹈中，编排是由力和重力这一基本原理决定的。我们探索 Unity 物理引擎的这一部分深入探讨了应用力和操纵重力和冲量的艺术。这些元素不仅仅是方程式中的变量，而是赋予静态物体生命，使它们成为我们游戏世界舞台上的动态演员的精髓。
- en: Forces
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 力
- en: At the core of dynamic movement within Unity is the application of forces to
    `Rigidbody` components, propelling objects through space and giving them velocity
    and direction. `AddForce` applies a continuous force to an object, propelling
    it in a specified direction, similar to the wind pushing a sailboat or a player
    kicking a ball. This force can be applied instantly or continuously over time,
    allowing for a wide range of motion effects. `AddTorque`, on the other hand, imparts
    a rotational force, causing objects to spin. This is useful for simulating actions
    such as rolling a ball or turning a car.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中的动态运动的核心是向 `Rigidbody` 组件应用力，推动物体在空间中移动，并赋予它们速度和方向。`AddForce` 对物体施加连续的力，使其在指定方向上移动，类似于风推动帆船或玩家踢球。这种力可以瞬间施加，也可以在一段时间内连续施加，从而产生广泛的运动效果。另一方面，`AddTorque`
    施加旋转力，使物体旋转。这对于模拟滚动球或转动汽车等动作非常有用。
- en: Manipulating these forces allows developers to simulate realistic or fantastical
    movements, from the gentle drift of a leaf to the powerful thrust of a rocket.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 操作这些力允许开发者模拟现实或奇幻的运动，从树叶的轻柔飘动到火箭的强大推力。
- en: 'Here’s a simple C# script for Unity that demonstrates the use of the `AddForce`
    and `AddTorque` methods to apply forces and rotational forces (torque) to a `Rigidbody`
    component attached to a GameObject. This script assumes that you have a 3D GameObject
    with a `Rigidbody` component to which this script is attached:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的 C# 脚本，用于 Unity，演示了如何使用 `AddForce` 和 `AddTorque` 方法将力和旋转力（扭矩）应用于 GameObject
    上附加的 `Rigidbody` 组件。此脚本假设你有一个带有 `Rigidbody` 组件的 3D GameObject，并且此脚本附加到该 GameObject
    上：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s see how it works:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '`forceMagnitude`: This public variable allows you to set the magnitude of the
    force applied when pressing the *spacebar*. You can adjust this in the Unity Inspector.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forceMagnitude`：这个公共变量允许你在按下 *空格键* 时设置施加的力的强度。你可以在 Unity 检查器中调整这个值。'
- en: '`torqueMagnitude`: This is similar to `forceMagnitude`, but for the rotational
    force applied when pressing the *T* key.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`torqueMagnitude`：这与 `forceMagnitude` 类似，但用于按下 *T* 键时施加的旋转力。'
- en: '`rb`: This is a private variable to hold the reference to the `RigidBody` component.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rb`：这是一个私有变量，用于保存对 `RigidBody` 组件的引用。'
- en: '`Start`: With this method, the script gets the `RigidBody` component attached
    to the same GameObject.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start`：使用此方法，脚本获取与同一 GameObject 附加的 `RigidBody` 组件。'
- en: '`Update`: With this method, the script listens for key presses:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`：使用此方法，脚本监听按键操作：'
- en: Pressing the *spacebar* will apply an upward force to the GameObject, making
    it jump.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 *空格键* 将对 GameObject 施加向上的力，使其跳跃。
- en: Pressing the *T* key will apply a rotational force around the GameObject’s *z*
    axis, making it spin.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 *T* 键将在 GameObject 的 *z* 轴上施加旋转力，使其旋转。
- en: 'Here are the steps to achieve that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的步骤如下：
- en: Create a new 3D GameObject (such as a Cube or Sphere) in your Unity scene.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity场景中创建一个新的3D GameObject（例如立方体或球体）。
- en: Add a `RigidBody` component to the GameObject if it doesn’t already have one.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果GameObject还没有，请为其添加`RigidBody`组件。
- en: Attach the preceding script to the GameObject.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的脚本附加到GameObject上。
- en: Play the scene. Press the *spacebar* to see the object jump and *T* to see it
    spin.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。按*空格键*可以看到物体跳跃，按*T键*可以看到物体旋转。
- en: In summary, dynamic movement in Unity is achieved through the application of
    forces to Rigidbody components, using methods such as `AddForce` to propel objects
    in specific directions and `AddTorque` to impart rotational motion. These methods
    enable a wide range of realistic motion effects, from linear propulsion to spinning.
    Next, we’ll explore the concepts of gravity and impulse, delving into how these
    forces further influence object behavior and interactions in the game world.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Unity中的动态运动是通过向Rigidbody组件应用力来实现的，使用如`AddForce`等方法将物体推向特定方向，以及使用`AddTorque`来赋予旋转运动。这些方法能够实现广泛的现实运动效果，从线性推进到旋转。接下来，我们将探讨重力和冲量的概念，深入了解这些力量如何进一步影响游戏世界中的物体行为和交互。
- en: Gravity and impulse
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重力和冲量
- en: Gravity, the unseen force that keeps our feet grounded, also anchors the objects
    in our game worlds, providing a baseline from which we can launch them into motion
    or let them fall back to rest. Unity allows developers to customize the global
    gravity settings to fit the needs of their game world, whether that means simulating
    the weightlessness of space or the heavy pull of an alien planet. Adjusting gravity
    can drastically alter the gameplay experience. Impulses provide a means to apply
    a sudden, large force to an object. They are typically used for actions such as
    jumping or quick directional changes. By applying an impulse, you can instantly
    change an object’s velocity, simulating a burst of energy or power.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重力，一种看不见的力量，它使我们的脚保持在地面上，也在我们的游戏世界中锚定物体，为我们提供了一个基准，从这里我们可以将它们推向运动或让它们回到静止状态。Unity允许开发者自定义全局重力设置以适应他们游戏世界的需求，无论是模拟太空的失重还是外星行星的重力。调整重力可以极大地改变游戏体验。冲量提供了一种给物体施加突然、强大力量的方法。它们通常用于跳跃或快速方向改变等动作。通过施加冲量，你可以瞬间改变物体的速度，模拟能量的爆发或力量的增强。
- en: Understanding and mastering the interplay of gravity and impulses is the key
    to creating engaging and responsive game mechanics that feel right to the player.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和掌握重力和冲量之间的相互作用是创建吸引人和响应迅速的游戏机制的关键，这些机制会让玩家感觉自然。
- en: 'The following C# script demonstrates how to work with Unity’s gravity settings
    on a `RigidBody` and how to apply an impulse force to simulate a jump or a sudden
    movement. This script should be attached to a GameObject with a `RigidBody` component:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下C#脚本演示了如何在`RigidBody`上使用Unity的重力设置以及如何施加冲量力来模拟跳跃或突然移动。此脚本应附加到具有`RigidBody`组件的GameObject上：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code demonstrates how to adjust gravity settings and apply impulses
    to objects in Unity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了如何在Unity中调整重力设置并给物体施加冲量。
- en: 'Here’s a breakdown of what the code does:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码功能的分解：
- en: '`jumpForce`: This public variable sets the magnitude of the impulse force applied
    when the *spacebar* is pressed. It can be adjusted in the Unity Inspector to modify
    the jump height.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jumpForce`：这个公共变量设置了按下*空格键*时施加的冲量力的幅度。它可以在Unity检查器中调整以修改跳跃高度。'
- en: '`gravitySlider`: This is a public variable that references a `UI Slider` component,
    which is used to adjust gravity at runtime.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gravitySlider`：这是一个公共变量，它引用了一个`UI Slider`组件，用于在运行时调整重力。'
- en: '`rb`: This is a private variable holding the reference to the Rigidbody component.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rb`：这是一个私有变量，它持有Rigidbody组件的引用。'
- en: 'Now we’ll explore the `Start` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索`Start`方法：
- en: Fetches the attached `Rigidbody` component.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取附加的`Rigidbody`组件。
- en: Initializes the gravity slider and adds a listener to call `` `OnGravityChanged`
    `` when the slider value changes.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化重力滑块，并在滑块值改变时调用`OnGravityChanged`。
- en: 'Let’s look at the `Update` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Update`方法：
- en: Listens for the *spacebar* and applies an upward impulse force to the `Rigidbody`,
    simulating a jump.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听*空格键*，并对`Rigidbody`施加向上的冲量力，模拟跳跃。
- en: Finally, the `OnGravityChanged` method updates the global gravity setting based
    on the gravity slider’s value, allowing for real-time gravity adjustment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`OnGravityChanged`方法根据重力滑块的值更新全局重力设置，允许实时调整重力。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the `RigidBody` component is affected by gravity as defined in Unity’s
    physics settings (**Edit** | **Project Settings** | **Physics**). You don’t need
    to manually apply gravity to each frame; Unity’s physics engine handles this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`RigidBody`组件受Unity的物理设置中定义的重力影响（**编辑** | **项目设置** | **物理**）。你不需要手动在每一帧应用重力；Unity的物理引擎处理这一点。
- en: If you want to customize gravity for a specific object, you can adjust the Rigidbody’s
    `useGravity` property and manually apply a custom gravity force if needed. However,
    in most cases, using the global gravity setting is sufficient and realistic.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为特定对象自定义重力，你可以调整Rigidbody的`useGravity`属性，并在需要时手动应用自定义的重力力。然而，在大多数情况下，使用全局重力设置是足够且逼真的。
- en: 'To apply the `GravityAndImpulseDemo` code to a GameObject in the Unity, follow
    these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`GravityAndImpulseDemo`代码应用到Unity中的游戏对象，请按照以下步骤操作：
- en: In your Unity scene, create a new 3D GameObject (such as a Cube or Sphere).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Unity场景中，创建一个新的3D游戏对象（例如一个立方体或球体）。
- en: Ensure that the GameObject has a `RigidBody` component. If it does not, add
    one by clicking **Add Component** | **Physics** | **RigidBody** in the **Inspector**
    window.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保游戏对象具有`RigidBody`组件。如果没有，请在**检查器**窗口中点击**添加组件** | **物理** | **RigidBody**来添加一个。
- en: Attach the `GravityAndImpulseDemo` script to the GameObject.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GravityAndImpulseDemo`脚本附加到游戏对象上。
- en: In your Unity UI, add a `Slider` element to adjust gravity. Name it `gravitySlider`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Unity UI中，添加一个`Slider`元素来调整重力。将其命名为`gravitySlider`。
- en: Assign `gravitySlider` in the `gravitySlider` field of the `GravityAndImpulseDemo`
    script.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GravityAndImpulseDemo`脚本的`gravitySlider`字段中分配`gravitySlider`。
- en: Enter Play Mode and press the *spacebar* to apply the impulse force and see
    the object jump.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入播放模式并按*空格键*来应用冲量力并看到物体跳跃。
- en: This script effectively demonstrates the concept of using impulse forces in
    conjunction with Unity’s built-in gravity to create realistic jumping behavior
    or sudden movements in GameObjects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本有效地展示了使用冲量力与Unity内置重力结合以创建逼真的跳跃行为或游戏对象中的突然移动的概念。
- en: The manipulation of forces, coupled with the foundational pull of gravity, sets
    the stage for the dynamic ballet of objects within our games. Through the careful
    application of forces and impulses, we can create a world that responds believably
    to player actions and environmental conditions. As we move forward in this chapter,
    we will transition from the ethereal forces that move objects to the tangible
    materials that they interact with. In the upcoming section, we’ll explore how
    the surfaces of objects interact with each other, adding another layer of realism
    and complexity to our game physics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 力量的操控，加上基础的重力吸引，为我们在游戏中的物体动态芭蕾舞奠定了基础。通过仔细应用力和冲量，我们可以创建一个对玩家动作和环境条件做出可信反应的世界。随着我们进入本章，我们将从移动物体的虚幻力过渡到它们与之交互的有形材料。在接下来的部分中，我们将探讨物体表面如何相互作用，为我们的游戏物理增加另一层真实性和复杂性。
- en: Physic Materials and friction
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理材料和摩擦
- en: In the vast canvas of Unity’s game development framework, the subtle dance between
    objects is often governed by unseen forces, among which the interactions facilitated
    by Physic Materials play a pivotal role. This section delves into the realm of
    Physic Materials, a powerful feature in Unity that allows developers to define
    how objects interact at their surfaces, influencing everything from the bounce
    of a ball to the slide of a character across different terrains. Alongside this,
    we will navigate the complexities of friction, an inherent force that adds depth
    and realism to the physical interactions within our game environments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的游戏开发框架的广阔画布上，物体之间的微妙舞蹈通常由看不见的力所控制，其中物理材料促进的交互在其中扮演着关键角色。本节深入探讨物理材料领域，这是Unity中的一个强大功能，允许开发者定义对象在其表面上的交互方式，影响从球的弹跳到角色在不同地形上滑动的各个方面。与此同时，我们将导航摩擦的复杂性，这是一种固有的力，为我们的游戏环境中的物理交互增添了深度和真实性。
- en: The following is a screenshot of a Physic Material named **Standard Physics
    Mat** as it appears in the **Inspector** window.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为**Standard Physics Mat**的物理材料的截图，如图所示在**检查器**窗口中。
- en: '![Figure 8.3 – A Physic Material as seen in the Inspector window](img/B22128_08_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 在检查器窗口中看到的物理材料](img/B22128_08_03.jpg)'
- en: Figure 8.3 – A Physic Material as seen in the Inspector window
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 在检查器窗口中看到的物理材料
- en: In the **Inspector** window, you can adjust Physic Material properties such
    as **Dynamic Friction**, **Static Friction**, and **Bounciness**. These properties
    can be combined to further affect the physical behavior of GameObjects. Now, let’s
    explore how to create and apply these materials in your projects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，您可以调整物理材质属性，如**动态摩擦**、**静态摩擦**和**弹性**。这些属性可以组合起来进一步影响游戏对象的行为。现在，让我们探索如何在项目中创建和应用这些材质。
- en: Creating and using Physic Materials
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用物理材质
- en: 'Physic Materials in Unity are assets that encapsulate properties related to
    friction and bounciness, allowing developers to craft a wide array of physical
    behaviors. Creating a Physic Material is straightforward: within the **Project**
    panel, right-click, navigate to **Create** | **Physic Material**, and give it
    a name. Once created, you can adjust properties such as **Dynamic Friction** (resistance
    while in motion), **Static** **Friction** (resistance when stationary), and **Bounciness**
    (how much an object rebounds after impact) to achieve the desired interaction
    effect. Applying Physic Materials to objects is as simple as dragging and dropping
    the material onto the collider component of a GameObject. This immediate application
    allows for rapid testing and iteration, providing a tactile feel to the virtual
    world, where each surface can tell its own story through interaction.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的物理材质是封装了与摩擦和弹性相关属性的资产，允许开发者制作各种物理行为。创建物理材质很简单：在**项目**面板中右键单击，导航到**创建**
    | **物理材质**，并给它命名。创建后，您可以调整如**动态摩擦**（运动时的阻力）、**静态** **摩擦**（静止时的阻力）和**弹性**（物体碰撞后反弹的程度）等属性，以达到期望的交互效果。将物理材质应用到对象上就像将材质拖放到游戏对象的碰撞组件上一样简单。这种即时应用允许快速测试和迭代，为虚拟世界提供触觉感，其中每个表面都可以通过交互讲述自己的故事。
- en: Friction considerations
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摩擦考虑
- en: Friction in Unity, which is managed via Physic Material on colliders, finely
    tunes the interaction between objects and surfaces, balancing realism and gameplay.
    Adjusting dynamic and static friction parameters impacts how objects move, which
    is essential for creating believable or fantastical game environments. As we conclude
    our discussion on friction, we will transition to exploring collision detection
    and responses, delving into how Unity handles object interactions and scripting
    reactions to enrich game dynamics.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的摩擦通过在碰撞体上管理物理材质进行精细调整，精细地调节对象与表面之间的交互，平衡真实性和游戏玩法。调整动态和静态摩擦参数会影响物体的移动方式，这对于创建可信或奇幻的游戏环境至关重要。随着我们对摩擦的讨论结束，我们将转向探索碰撞检测和响应，深入了解Unity如何处理对象交互和编写反应脚本来丰富游戏动态。
- en: Collision detection and responses
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测和响应
- en: As we delve deeper into the physics of Unity, we reach a critical juncture where
    the abstract principles of motion and materiality manifest in the tangible realm
    of collision detection and responses. This essential component of game physics
    breathes life into the virtual world, allowing objects to not only recognize when
    they have come into contact but also react in myriad, customizable ways. Through
    Unity’s robust collision detection system and the versatile scripting capabilities
    it offers, developers can craft an immersive environment where every contact tells
    a story, be it a simple touch, a forceful impact, or the subtle grazing of surfaces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入Unity的物理原理，我们达到了一个关键转折点，即运动和物质性的抽象原理在碰撞检测和响应的实体领域中显现出来。游戏物理的这部分基本组件为虚拟世界注入了生命，使对象不仅能识别它们何时接触，还能以多种可定制的方
    式做出反应。通过Unity强大的碰撞检测系统和它提供的灵活脚本能力，开发者可以构建一个沉浸式环境，其中每个接触都讲述一个故事，无论是简单的触摸、强烈的碰撞还是表面的微妙擦过。
- en: Detecting collisions
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'In Unity, collision detection is the cornerstone of interactive game environments,
    allowing objects to perceive and react to contact with other objects. Unity provides
    a set of collision detection events that are pivotal for scripting interactions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，碰撞检测是交互式游戏环境的基础，允许对象感知并响应与其他对象的接触。Unity提供了一套碰撞检测事件，对于脚本交互至关重要：
- en: '`OnCollisionEnter`: This event is triggered when a collider makes contact with
    another collider for the first time. It’s the starting point for many interaction
    scripts, signaling the initial moment of impact.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter`: 当一个碰撞体首次与其他碰撞体接触时，会触发此事件。它是许多交互脚本的起点，标志着碰撞的初始时刻。'
- en: '`OnCollisionStay`: This event continuously fires as long as colliders remain
    in contact, allowing for the scripting of sustained interactions such as objects
    pushing against each other.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionStay`：只要碰撞体保持接触，此事件就会持续触发，允许脚本化持续的交互，例如物体相互推挤。'
- en: '`OnCollisionExit`: Triggered when colliders that were in contact separate,
    this event can be used to script effects or behaviors that occur once an object
    is no longer in contact with another.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionExit`：当接触的碰撞体分离时触发，此事件可用于脚本化一旦对象不再与另一个对象接触就发生的效果或行为。'
- en: These events hinge on the presence of a `RigidBody` component on at least one
    of the colliding objects, which can be either kinematic or dynamic, ensuring that
    collision detection is both efficient and accurate within Unity’s physics engine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件依赖于至少一个碰撞物体上存在一个 `RigidBody` 组件，该组件可以是运动学或动态的，确保在 Unity 的物理引擎中碰撞检测既高效又准确。
- en: Scripting collision responses
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 碰撞响应脚本
- en: 'The real magic happens in how we respond to these collisions. Unity allows
    developers to script responses to collision events, enabling objects to exhibit
    realistic behaviors or trigger game mechanics:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔法在于我们如何响应这些碰撞。Unity 允许开发者编写对碰撞事件的响应脚本，使物体表现出逼真的行为或触发游戏机制：
- en: '`AudioSource` component to an object and scripting it to play a sound within
    the `OnCollisionEnter` method, developers can create aural feedback for collisions,
    enhancing the sensory experience of the game.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以将 `AudioSource` 组件附加到对象上，并在 `OnCollisionEnter` 方法中对其进行脚本化，以播放声音，为碰撞创建音频反馈，增强游戏的感觉体验。
- en: '`OnCollisionExit` to reset properties once the collision ends.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionExit` 用于在碰撞结束时重置属性。'
- en: 'The following code snippet shows a typical `OnCollisionEnter` coding:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了典型的 `OnCollisionEnter` 编码：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code snippet triggers when a collision occurs. It retrieves the game object’s
    `AudioSource` component to play a sound, indicating an interaction such as a hit.
    Additionally, it accesses the `Renderer` component to change the object’s material
    color to red, visually signaling damage or impact. This immediate audio-visual
    feedback enhances gameplay realism and player engagement.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生碰撞时，此代码片段会被触发。它检索游戏对象的 `AudioSource` 组件来播放声音，指示如击打等交互。此外，它访问 `Renderer` 组件来改变物体的材质颜色为红色，视觉上表示伤害或冲击。这种即时的音频-视觉反馈增强了游戏的真实感和玩家的参与度。
- en: Through the intricate dance of collision detection and the creative scripting
    of collision responses, Unity developers have a powerful toolkit for crafting
    engaging and dynamic game environments at their disposal. Whether it’s the clang
    of swords, the thud of a ball, or the shattering of glass, every collision can
    be imbued with meaning and consequence, propelling the narrative forward and deepening
    the player’s immersion. As we conclude this exploration, we are reminded that
    in the realm of game development, even the smallest contact can have a profound
    impact, echoing through the virtual world we’ve painstakingly constructed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过碰撞检测的复杂舞蹈和碰撞响应的创造性脚本编写，Unity 开发者拥有一个强大的工具集，可以制作引人入胜且动态的游戏环境。无论是剑的铿锵声、球的砰然声，还是玻璃的破碎声，每个碰撞都可以赋予意义和后果，推动故事向前发展并加深玩家的沉浸感。随着我们结束这次探索，我们被提醒，在游戏开发领域，即使是微小的接触也可能产生深远的影响，在我们的虚拟世界中回响。
- en: Wrapping up our dive into the basics of Unity physics, we’ve navigated through
    the essentials of `RigidBody` dynamics, collider interactions, and the subtleties
    of Physic Materials. We’ve explored how forces, gravity, and impulses bring motion
    to objects, as well as how friction and collisions add depth and realiism to their
    interactions. Transitioning away from the physics that shape our game environments,
    we will now move to the next section, where we’ll bring characters to life through
    animation, connecting their movements to the rich physics-based world we’ve constructed.
    This next section promises to elevate our game development skills further, merging
    the physical with the expressive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨 Unity 物理基础的过程中，我们已经了解了 `RigidBody` 动力学、碰撞体交互和物理材料的微妙之处。我们探讨了力、重力和冲量如何使物体运动，以及摩擦和碰撞如何为它们的交互增添深度和真实感。从塑造游戏环境的物理过渡到下一部分，我们将通过动画使角色栩栩如生，将它们的动作与我们所构建的基于物理的丰富世界联系起来。下一部分承诺将进一步提高我们的游戏开发技能，将物理与表现力相结合。
- en: Animating game characters
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏角色动画
- en: Dive into the art of character animation in Unity, exploring core concepts such
    as the Animator component, animation states, and transitions. Learn how to import
    external animations and craft basic movements, enriching your characters with
    lifelike dynamics. This section offers a structured guide, going from introducing
    the Animator component to linking animations with player inputs. This is crucial
    knowledge for ensuring that your characters move and react in a responsive and
    realistic manner.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 深入Unity中角色动画的艺术，探索核心概念，如动画组件、动画状态和过渡。学习如何导入外部动画并制作基本动作，为角色增添逼真的动态。本节提供了一个结构化的指南，从介绍动画组件到将动画与玩家输入链接。这对于确保角色能够以响应和逼真的方式移动和反应至关重要。
- en: Introducing the Animator component
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍动画组件
- en: The Unity Animator component is key for animating characters, managing states
    such as *idle* and *running* through the **Animator Controller** for fluid transitions.
    Acting as a bridge between characters and their animations, it ensures dynamic,
    responsive movements by interpreting the Controller’s instructions for seamless
    animation playback.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的动画组件对于动画角色至关重要，通过**动画控制器**管理*空闲*和*跑步*等状态，实现流畅的过渡。作为角色和动画之间的桥梁，它通过解释控制器的指令，确保动态、响应式的动作，实现无缝的动画播放。
- en: The figure that follows demonstrates the setup of the Animator component for
    a game character within the Unity Editor. It shows how the Animator component
    is attached to the character model and linked to the `Player_Controller`, which
    is responsible for managing animations. This setup is crucial for enabling complex
    animations and interactions within the game environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示演示了在Unity编辑器中为游戏角色设置动画组件的过程。它显示了动画组件如何附加到角色模型上，并链接到负责管理动画的`Player_Controller`。这种设置对于在游戏环境中启用复杂的动画和交互至关重要。
- en: '![Figure 8.4 – The Animator component setup for a game character in the Unity
    Editor](img/B22128_08_4.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 在Unity编辑器中为游戏角色设置动画组件](img/B22128_08_4.jpg)'
- en: Figure 8.4 – The Animator component setup for a game character in the Unity
    Editor
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 在Unity编辑器中为游戏角色设置动画组件
- en: With the character selected in the **Hierarchy** window, look in the **Inspector**
    window and add the **Animator** component. The **Animator** component is used
    to control animations for the character. The **Controller** field links to the
    **Animator Controller**, which contains the animation logic. Additional settings
    such as **Avatar**, **Apply Root Motion**, and **Culling Mode** appear here to
    help manage the animations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择角色后，在**检查器**窗口中添加**动画组件**。**动画组件**用于控制角色的动画。**控制器**字段链接到**动画控制器**，其中包含动画逻辑。此处还出现了一些额外的设置，如**Avatar**、**应用根运动**和**剔除模式**，以帮助管理动画。
- en: The **Animator** component and **Animator** controller collaborate to animate
    characters in Unity, with the controller housing animation states, transitions,
    and parameters. After creating animation clips for states such as *idle* or *run*,
    they’re added to the controller, allowing for detailed customization and control
    over each animation’s playback on the character model.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画组件**和**动画控制器**协作在Unity中为角色动画，控制器包含动画状态、过渡和参数。在为*空闲*或*跑步*等状态创建动画剪辑后，它们被添加到控制器中，允许对每个动画在角色模型上的播放进行详细的自定义和控制。'
- en: The screenshot that follows displays the **Animator** window in Unity, showcasing
    the setup of animation states and transitions for a character, including the **Idle**,
    **Walking**, and **Running** states, along with their respective parameters and
    transitions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了Unity中的**动画窗口**，展示了为角色设置动画状态和过渡，包括**空闲**、**行走**和**跑步**状态，以及它们各自的参数和过渡。
- en: '![Figure 8.5 – The Animator window showing animation states and transitions
    for a character in Unity](img/B22128_08_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 显示Unity中角色动画状态和过渡的动画窗口](img/B22128_08_05.jpg)'
- en: Figure 8.5 – The Animator window showing animation states and transitions for
    a character in Unity
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 显示Unity中角色动画状态和过渡的动画窗口
- en: The **Animator** window displays the available parameters in the left column,
    where a float parameter named **Speed** has been added. The right column shows
    the various states of the **Animator** controller, including **Entry**, **Idle**,
    **Walking**, and **Running**, with transitions connecting these states. The **Inspector**
    window on the right side of the figure shows the configurations for the **Idle**
    state, detailing its motion settings and transition conditions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画器**窗口在左侧列显示可用的参数，其中已添加了一个名为**速度**的浮点参数。右侧列显示了**动画器**控制器的各种状态，包括**进入**、**空闲**、**行走**和**奔跑**，以及连接这些状态的过渡。图中的右侧**检查器**窗口显示了**空闲**状态的配置，详细说明了其运动设置和过渡条件。'
- en: Within each animation state, you can adjust various parameters to control the
    animation’s playback, such as the animation clip’s speed, looping behavior, and
    blend settings. This allows you to ensure that the animations seamlessly transition
    between one another, creating natural and believable movement for your character.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个动画状态内，您可以调整各种参数来控制动画的播放，例如动画剪辑的速度、循环行为和混合设置。这确保了动画之间能够无缝过渡，为您的角色创造自然且逼真的动作。
- en: The following screenshot illustrates the setup of animation transitions between
    states in the **Animator** window, specifically showing the transition from **Idle**
    to **Walking** and the associated parameters and conditions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**动画器**窗口中不同状态之间的动画过渡设置，特别是从**空闲**到**行走**的过渡以及相关的参数和条件。
- en: '![Figure 8.6 – The Animator window showing animation transitions from Idle
    to Walking with their associated parameters and conditions](img/B22128_08_06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 动画器窗口显示从空闲到行走状态的动画过渡及其相关参数和条件](img/B22128_08_06.jpg)'
- en: Figure 8.6 – The Animator window showing animation transitions from Idle to
    Walking with their associated parameters and conditions
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 动画器窗口显示从空闲到行走状态的动画过渡及其相关参数和条件
- en: With one of the transitions selected in the **Animator** window, the **Inspector**
    window displays its configuration. The **Speed** parameter controls the transition,
    and when it reaches **0.1**, the **Animator** controller begins playing the **Walking**
    animation. The transition length, which determines how smoothly the animation
    shifts from one state to another, can be adjusted in the timeline.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在**动画器**窗口中选择一个过渡后，**检查器**窗口将显示其配置。**速度**参数控制过渡，当它达到**0.1**时，**动画器**控制器开始播放**行走**动画。过渡长度，它决定了动画从一个状态平滑过渡到另一个状态的程度，可以在时间轴中进行调整。
- en: The **Animator** controller also allows you to define the rules for transitioning
    between the different animation states. You can create transitions between states
    based on various parameters, such as the character’s speed, input from the player,
    or other game-specific conditions. By carefully crafting these transitions, you
    can create smooth, responsive, and visually appealing character animations that
    respond dynamically to the player’s actions and the game’s events.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画器**控制器还允许您定义在不同动画状态之间过渡的规则。您可以根据各种参数创建状态之间的过渡，例如角色的速度、玩家的输入或其他游戏特定条件。通过精心设计这些过渡，您可以创建平滑、响应迅速且视觉上吸引人的角色动画，这些动画能够动态地响应玩家的动作和游戏事件。'
- en: Setting up the animation states within the **Animator** controller is crucial.
    You’ll learn how to create and configure states such as *idle*, *walk*, *run*,
    and *jump*, and customize their properties for smooth transitions. This lays the
    groundwork for the next section on animation transitions and parameters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在**动画器**控制器中设置动画状态至关重要。您将学习如何创建和配置诸如**空闲**、**行走**、**奔跑**和**跳跃**等状态，并自定义它们的属性以实现平滑过渡。这为下一节关于动画过渡和参数的讨论奠定了基础。
- en: Animation transitions and parameters
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画过渡和参数
- en: We’ll delve into refining character movements within Unity, focusing on seamless
    transitions between states such as walking and jumping, which are controlled by
    parameters such as **Speed**. This section also covers scripting with C# to adjust
    these parameters dynamically, reacting to player inputs or game scenarios, thereby
    enriching the gameplay experience with fluid, responsive animations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨在 Unity 中细化角色动作，重点关注行走和跳跃等状态之间的无缝过渡，这些过渡由**速度**等参数控制。本节还将涵盖使用 C# 编写脚本以动态调整这些参数，以响应玩家输入或游戏场景，从而通过流畅、响应迅速的动画丰富游戏体验。
- en: Creating realistic animations in Unity3D involves implementing smooth transitions
    between states such as idle to walk or run to jump using the **Animator** controller.
    Parameters based on player inputs or game conditions ensure dynamic, responsive
    character movements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity3D中创建逼真的动画涉及使用**Animator**控制器实现状态之间的平滑过渡，例如从空闲到行走或从跑步到跳跃。基于玩家输入或游戏条件的参数确保了动态、响应式的角色动作。
- en: In the `isJumping` for run to jump, enabling seamless and immersive animations
    that are responsive to gameplay.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在跑步到跳跃的`isJumping`中，启用无缝和沉浸式的动画，这些动画对游戏玩法做出响应。
- en: 'The following script snippet demonstrates altering an `Animator` parameter,
    `isJumping`, based on player input (pressing the *spacebar*) to trigger a jump
    animation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的脚本片段演示了根据玩家输入（按下*空格键*）来触发跳跃动画，修改`Animator`参数`isJumping`：
- en: '[PRE3]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the provided code, an `Animator` component is accessed from a GameObject,
    likely intended to represent a player character. The script listens for a specific
    player input (*spacebar* press) within the `Update` method, which is called every
    frame. Upon detecting the press, it sets an `Animator` parameter named `isJumping`
    to `true`, presumably to trigger a jump animation. This demonstrates dynamic animation
    control based on player actions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码中，从一个GameObject中访问了`Animator`组件，可能旨在表示玩家角色。该脚本在`Update`方法中监听特定的玩家输入（*空格键*按下），该方法每帧都会被调用。检测到按下后，它将`Animator`参数`isJumping`设置为`true`，可能是为了触发跳跃动画。这展示了基于玩家动作的动态动画控制。
- en: Here, we explored crafting fluid movements in Unity by setting up nuanced transitions
    between animation states using parameters such as `speed` and `isJumping`, controlled
    via C# scripting in response to gameplay dynamics. Next, we’ll expand our animation
    toolkit with assets from outside sources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用参数如`speed`和`isJumping`设置动画状态之间的细微过渡，并通过C#脚本对游戏玩法动态做出响应，探讨了在Unity中制作流畅动作。接下来，我们将通过外部资源扩展我们的动画工具包。
- en: Importing and using external animations
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入和使用外部动画
- en: Importing animations into Unity is a crucial step for enhancing the dynamism
    and realism of game characters. This section will guide you through the process
    of importing external animations, covering essential aspects such as file formats
    and setting up imported animations within the **Animator Controller**. One popular
    resource for high-quality animations is **Mixamo**, an online platform that provides
    a vast library of character animations. The screenshot that follows shows the
    Mixamo (Adobe) interface, where you can browse, customize, and download animations
    for use with your game characters. By leveraging platforms such as Mixamo, you
    can significantly streamline the animation process and enrich your Unity projects
    with diverse and professionally created movements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将动画导入Unity是增强游戏角色动态性和真实感的关键步骤。本节将指导您通过导入外部动画的过程，涵盖文件格式和设置导入动画在**Animator Controller**中的基本方面。一个高质量动画的流行资源是**Mixamo**，这是一个在线平台，提供了大量的角色动画库。接下来的截图显示了Mixamo（Adobe）界面，您可以在其中浏览、自定义并下载用于游戏角色的动画。通过利用像Mixamo这样的平台，您可以显著简化动画过程，并用多样化和专业制作的动作丰富您的Unity项目。
- en: The figure that follows shows Mixamo’s main interface, which allows you to browse
    available animations, view a model demonstrating the selected animation, make
    adjustments, and download the animation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图示展示了Mixamo的主界面，该界面允许您浏览可用的动画，查看演示所选动画的模型，进行调整，并下载动画。
- en: '![Figure 8.7 – The Mixamo [Adobe] interface showing a library of character
    animations and customization options](img/B22128_08_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – Mixamo [Adobe] 界面显示角色动画库和自定义选项](img/B22128_08_07.jpg)'
- en: Figure 8.7 – The Mixamo [Adobe] interface showing a library of character animations
    and customization options
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – Mixamo [Adobe] 界面显示角色动画库和自定义选项
- en: Mixamo is a popular source for character animations. The left-hand section displays
    a vast collection of animations. Selecting an option, such as **Walking**, will
    display it in the right-hand window. Use the sliders to adjust the animation to
    your needs. Check the **In Place** box if you plan to move your character with
    **Transform**; leave it unchecked if you will be using a tool such as **Character
    controller**. Once you’re satisfied with the settings, click **Download**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Mixamo是角色动画的一个流行来源。左侧部分显示了一个庞大的动画集合。选择一个选项，例如**行走**，它将在右侧窗口中显示。使用滑块调整动画以满足您的需求。如果您计划使用**变换**来移动角色，请勾选**就地**框；如果您将使用**角色控制器**等工具，请取消勾选。一旦您对设置满意，请点击**下载**。
- en: In this section, you will learn how to import and integrate external animations
    into Unity, detailing the processes to ensure seamless integration. Unity supports
    the **Filmbox** (**FBX**) file format, which is the most robust and recommended
    for animations. While **COLLAborative Design Activity** (**COLLADA**) is supported,
    it is less reliable and should generally be avoided. The **Biovision Hierarchical
    Data** (**BVH**) file format requires third-party utilities to be used effectively.
    We will guide you through the steps of importing these files, setting them up
    in the **Animator**, and ensuring that they function correctly within your game
    environment. Understanding these file formats and their import process is crucial
    for incorporating high-quality animations into your Unity projects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将外部动画导入Unity，详细说明确保无缝集成的流程。Unity支持**Filmbox**（**FBX**）文件格式，这是最稳健且推荐用于动画的格式。虽然**COLLAborative
    Design Activity**（**COLLADA**）也受到支持，但它的可靠性较低，通常应避免使用。**Biovision Hierarchical
    Data**（**BVH**）文件格式需要第三方工具才能有效使用。我们将指导您完成导入这些文件、在**动画器**中设置它们以及确保它们在您的游戏环境中正确运行的步骤。了解这些文件格式及其导入流程对于将高质量动画融入您的Unity项目至关重要。
- en: Once your animations have been imported, we will delve into the setup processes
    within the **Animator** component. This involves configuring animation states,
    transitions, and parameters to create a cohesive animation flow. We will explore
    how to link these animations to your character models, ensuring that the animations
    play correctly and appear natural. Proper setup within the **Animator** is essential
    for achieving smooth and believable character movements, enhancing the overall
    gaming experience.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的动画被导入，我们将深入探讨**动画器**组件内的设置过程。这包括配置动画状态、过渡和参数，以创建一个连贯的动画流程。我们将探讨如何将这些动画链接到您的角色模型上，确保动画播放正确且看起来自然。在**动画器**中正确设置对于实现平滑且逼真的角色动作至关重要，从而提升整体游戏体验。
- en: Additionally, we will cover the best practices for merging external animations
    with your character models. This includes ensuring rig compatibility between the
    animations and your models, adjusting animation settings for optimal performance,
    and using animation layers to blend multiple animations seamlessly. By adhering
    to these best practices, you can ensure smooth and compatible animation playback,
    resulting in a polished and professional game experience. These guidelines will
    help you avoid common pitfalls and achieve a higher level of quality in your animations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将介绍将外部动画与您的角色模型合并的最佳实践。这包括确保动画与您的模型之间的绑定兼容性，调整动画设置以实现最佳性能，并使用动画层无缝混合多个动画。通过遵循这些最佳实践，您可以确保平滑且兼容的动画播放，从而实现精致且专业的游戏体验。这些指南将帮助您避免常见陷阱，并在动画中实现更高的质量水平。
- en: 'After selecting **Download** on the Mixamo main screen, the following screen
    will appear:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mixamo主屏幕上选择**下载**后，将出现以下屏幕：
- en: '![Figure 8.8 – The Mixamo animation download settings](img/B22128_08_8.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – Mixamo动画下载设置](img/B22128_08_8.jpg)'
- en: Figure 8.8 – The Mixamo animation download settings
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – Mixamo动画下载设置
- en: In the **DOWNLOAD SETTINGS**, it’s important to select **FBX for Unity(.fbx)**
    under **Format** to ensure that Unity recognizes the file. Choosing **Without
    Skin** means that Mixamo will not include the character shown. Setting the **Frames
    per Second** to **30** is best, as larger numbers produce larger files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在**下载设置**中，选择**格式**下的**FBX for Unity(.fbx**)非常重要，以确保Unity能够识别该文件。选择**无皮肤**意味着Mixamo不会包含显示的角色。将**每秒帧数**设置为**30**最佳，因为较大的数字会产生更大的文件。
- en: The figure that follows shows the process of dragging animation files into the
    **Project** window of the Unity Editor. The right side of the figure shows the
    recently added animation selected where it displays its contents.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了将动画文件拖入Unity编辑器**项目**窗口的过程。图例的右侧显示了最近添加的动画，其中显示了其内容。
- en: '![Figure 8.9 – The Project window of the Unity Editor](img/B22128_08_9.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – Unity编辑器的项目窗口](img/B22128_08_9.jpg)'
- en: Figure 8.9 – The Project window of the Unity Editor
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – Unity编辑器的项目窗口
- en: To add an animation to a Unity project, simply drag the file into the **Project**
    window of the Unity Editor. Unity will process the file and add the animation
    to the project. On the right-hand side, the processed FBX file is selected. It
    shows that it contains two files. The triangle icon is for animations. Here, the
    animation is named **Walking**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将动画添加到Unity项目，只需将文件拖入Unity编辑器的**项目**窗口。Unity将处理文件并将动画添加到项目中。在右侧，选中的处理后的FBX文件显示。它显示它包含两个文件。三角形图标表示动画。在这里，动画被命名为**Walking**。
- en: The following figure shows the **Inspector** window after selecting the FBX
    file in the **Project** window; the animation file can be further configured here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在**项目**窗口中选择FBX文件后的**检查器**窗口；动画文件可以在此处进一步配置。
- en: '![Figure 8.10 – The Rig section of the animation file as it appears in the
    Inspector window](img/B22128_08_10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 动画文件在检查器窗口中显示的绑定部分](img/B22128_08_10.jpg)'
- en: Figure 8.10 – The Rig section of the animation file as it appears in the Inspector
    window
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 动画文件在检查器窗口中显示的绑定部分
- en: With the FBX file selected in the **Project** window, look at the **Inspector**
    window. For character animations, select **Rig** and then choose **Humanoid**
    under **Animation Type**. Finally, click **Apply**. It’s important for the rig’s
    animation type to match the character’s type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择FBX文件后，查看**检查器**窗口。对于角色动画，选择**绑定**，然后在**动画类型**下选择**人类**。最后，点击**应用**。确保绑定的动画类型与角色的类型相匹配非常重要。
- en: The most common file format for importing animations into Unity is the FBX format.
    FBX is a widely adopted standard that preserves animation data, including keyframes,
    bone transformations, and other animation-specific information. When importing
    an FBX file containing animations, Unity will automatically create the necessary
    animation clips that you can then use within the **Animator** controller.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将动画导入Unity中最常见的文件格式是FBX格式。FBX是一个广泛采用的标准，它保留了动画数据，包括关键帧、骨骼变换和其他动画特定信息。当导入包含动画的FBX文件时，Unity将自动创建必要的动画剪辑，您可以在**动画控制器**中使用这些剪辑。
- en: In addition to FBX, Unity also supports the import of other animation file formats,
    such as Alembic and USD, depending on the version of Unity you are using. It’s
    important to ensure that the animation data is properly exported from the original
    3D software and that the file format is compatible with Unity’s requirements.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FBX之外，Unity还支持导入其他动画文件格式，如Alembic和USD，具体取决于您使用的Unity版本。确保动画数据从原始3D软件正确导出，并且文件格式与Unity的要求兼容非常重要。
- en: Creating basic animations and linking to player input
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本动画并将其链接到玩家输入
- en: This sub-section introduces the process of crafting basic animations in Unity
    and linking them to player interactions. It covers utilizing the **Animation**
    window for simple animations and scripting input-driven animations, such as initiating
    a walk cycle with a key press, thereby enhancing gameplay with responsive character
    movements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了在Unity中制作基本动画并将其链接到玩家交互的过程。它涵盖了使用**动画**窗口进行简单动画和编写输入驱动的动画，例如通过按键启动行走循环，从而通过响应式角色动作增强游戏玩法。
- en: The **Animation** window in Unity is important for crafting basic animations
    such as blinking or gestures. It involves selecting a GameObject, recording keyframes
    to capture desired movements, and editing these animations for timing and interpolation,
    allowing for the fine-tuning of animations to achieve the intended visual effect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的**动画**窗口对于制作基本动画（如眨眼或手势）非常重要。它涉及选择一个GameObject，记录关键帧以捕获所需的动作，并编辑这些动画以调整时间和插值，从而实现对动画的精细调整以实现预期的视觉效果。
- en: Input-driven animations, such as a character’s walk cycle triggered by a move
    key press, blend scripting with the Animator component parameters to reflect player
    actions, enhancing game interactivity. For instance, pressing the jump or attack
    buttons could initiate respective animations, making the character’s movements
    more dynamic and responsive to player inputs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输入驱动的动画，如通过移动按键触发的角色行走循环，将脚本与 Animator 组件参数相结合，以反映玩家动作，增强游戏交互性。例如，按下跳跃或攻击按钮可以启动相应的动画，使角色的动作更加动态并对玩家输入做出响应。
- en: This section on animating game characters delves into Unity’s Animator component,
    animation states, and transitions, as well as the integration of external animations,
    enriched with practical examples such as walk cycles and input-driven animations
    for dynamic character control. As we transition to the next section, we’ll explore
    how these animated characters interact within their surroundings, further immersing
    players in the game world.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了动画游戏角色的方法，涉及 Unity 的 Animator 组件、动画状态和过渡，以及外部动画的集成，通过如行走循环和输入驱动的动态角色控制等实际示例进行丰富。当我们过渡到下一节时，我们将探讨这些动画角色如何在周围环境中交互，进一步将玩家沉浸到游戏世界中。
- en: Environmental interactions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境交互
- en: This section delves into how characters engage with their surroundings in Unity,
    focusing on scripting physics-driven reactions and animating interactive elements
    such as doors and platforms for a more immersive experience. It provides script
    examples to dynamically alter the game environment in response to player actions,
    making the virtual world feel alive and responsive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了角色在 Unity 中如何与环境互动，重点关注脚本驱动的物理反应和动画交互元素（如门和平台），以提供更沉浸式的体验。它提供了脚本示例，以动态地根据玩家动作改变游戏环境，使虚拟世界感觉生动且具有响应性。
- en: Building on the foundations of animation and scripting, we now turn our attention
    to physics-based character interactions. This section will cover how characters
    can interact with their environment using physics, focusing on events such as
    `OnCollisionEnter` to create responsive and immersive gameplay experiences.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画和脚本的基础之上，我们现在将注意力转向基于物理的角色交互。本节将介绍角色如何通过物理与周围环境交互，重点关注如 `OnCollisionEnter`
    事件以创建响应性和沉浸式的游戏体验。
- en: Physics-based character interactions
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于物理的角色交互
- en: One way to create physics-based character interactions is to script character
    reactions to various physics events, such as collisions or triggers. For example,
    you could have a character stumble or adjust their posture when they collide with
    an obstacle or encounter a change in terrain slope. To achieve this, you can use
    Unity’s built-in physics event callbacks, such as `OnCollisionEnter` or `OnTriggerEnter`.
    These callbacks allow you to detect when a character’s collider interacts with
    another object, and then trigger the appropriate animation or effect. The main
    difference between `OnCollision` and `OnTrigger` events is that `OnCollision`
    is used for detecting physical collisions where the colliders respond with physics,
    while `OnTrigger` is used for detecting interactions within a defined trigger
    zone without applying physical force, enabling more abstract or gameplay-specific
    interactions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于物理的角色交互的一种方法是为各种物理事件（如碰撞或触发器）编写角色反应的脚本。例如，当角色与障碍物碰撞或遇到地形坡度变化时，它们可能会绊倒或调整姿势。为了实现这一点，你可以使用
    Unity 内置的物理事件回调，如 `OnCollisionEnter` 或 `OnTriggerEnter`。这些回调允许你检测角色的碰撞器何时与另一个对象交互，然后触发相应的动画或效果。`OnCollision`
    和 `OnTrigger` 事件之间的主要区别在于，`OnCollision` 用于检测物理碰撞，其中碰撞器会以物理方式响应，而 `OnTrigger` 用于检测定义的触发区域内的交互，而不应用物理力，从而实现更抽象或游戏特定的交互。
- en: 'Here’s an example C# script that demonstrates how to use `OnCollisionEnter`
    to trigger a stumble animation when a character collides with an obstacle:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例 C# 脚本，演示了如何使用 `OnCollisionEnter` 触发当角色与障碍物碰撞时的绊倒动画：
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `CharacterPhysicsReactions` script is attached to the character
    GameObject. When the character collides with an `Obstacle` object, the `OnCollisionEnter`
    method is called. The script then plays a stumble animation using the `Animator`
    component and applies a force to the character’s RigidBody to make them stumble
    back.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CharacterPhysicsReactions` 脚本被附加到角色 GameObject 上。当角色与一个 `Obstacle` 对象发生碰撞时，会调用
    `OnCollisionEnter` 方法。然后脚本使用 `Animator` 组件播放绊倒动画，并施加一个力到角色的 RigidBody 上，使其向后绊倒。
- en: Transitioning away from physics-based interactions, we will now explore interactive
    environmental elements. This section will cover the implementation of dynamic
    features such as moving platforms and opening doors, enhancing the interactivity
    of your game world. By scripting these elements, we can create more engaging and
    immersive experiences for players, making the environment feel alive and responsive
    to their actions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从基于物理的交互过渡到交互式环境元素，我们将现在探讨动态功能的实现，如移动平台和开门，增强游戏世界的交互性。通过编写这些元素的脚本，我们可以为玩家创造更加吸引人和沉浸式的体验，使环境感觉生动并对他们的动作做出响应。
- en: Interactive environmental elements
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式环境元素
- en: One common example of animating the environment is creating doors or platforms
    that move or change state based on player interaction. For instance, you could
    have a door that opens when the player approaches it or a platform that moves
    up and down when the player steps on it. To achieve this, you would first create
    the necessary animations for the environmental element in the **Animation** window.
    This could involve keyframing the movement or transformation of the object, such
    as a door rotating open or a platform rising and falling.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 环境动画的一个常见例子是创建基于玩家交互移动或改变状态的门或平台。例如，你可以有一个当玩家靠近时打开的门，或者一个当玩家踏上时上下移动的平台。为了实现这一点，你首先需要在
    **Animation** 窗口中为环境元素创建必要的动画。这可能包括为对象的移动或变换设置关键帧，例如门旋转打开或平台上升下降。
- en: 'Once you have the animations set up, you can then write scripts to control
    the interactivity of these environmental elements. This typically involves detecting
    when the player is in proximity to the object or triggering a specific action,
    and then using that information to play the appropriate animation. For example,
    let’s consider a script for a door that opens when the player approaches it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了动画，你就可以编写脚本以控制这些环境元素的交互性。这通常涉及检测玩家是否接近对象或触发特定动作，然后使用这些信息来播放适当的动画。例如，让我们考虑一个当玩家靠近时打开的门的脚本：
- en: '[PRE5]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `InteractiveDoor` script is attached to the door GameObject.
    The script checks the distance between the door and the player’s position in the
    `Update` method. If the player is within the specified interaction range, the
    script triggers the *Open* animation on the door’s `Animator` component. If the
    player moves away, the script triggers the *Close* animation instead.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`InteractiveDoor` 脚本被附加到了门 GameObject 上。该脚本在 `Update` 方法中检查门与玩家位置之间的距离。如果玩家位于指定的交互范围内，脚本会在门的
    `Animator` 组件上触发 *Open* 动画。如果玩家离开，脚本则会触发 *Close* 动画。
- en: Dynamic environment responses
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态环境响应
- en: In addition to creating interactive environmental elements, Unity also allows
    you to take things a step further by making the game environment dynamically adapt
    to the player’s actions. This can create a more immersive and responsive game
    world, where the environment feels alive and reacts to the player’s presence in
    meaningful ways.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建交互式环境元素外，Unity 还允许你通过使游戏环境动态适应玩家的动作来更进一步。这可以创建一个更加沉浸和响应的游戏世界，其中环境感觉是活生生的，并以有意义的方式对玩家的存在做出反应。
- en: One example of dynamic environment adaptation could be a bridge that collapses
    under the weight of the player character. As the player steps onto the bridge,
    the structure could start to sag and eventually give way, forcing the player to
    find an alternative route. Another example could be foliage or vegetation that
    moves and sways as the player character passes through it. This could be achieved
    by using physics-based simulations or scripted animations to create a more realistic
    and responsive environment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 动态环境适应的一个例子可能是一座在玩家角色重量下坍塌的桥梁。当玩家踏上桥梁时，结构可能会开始下沉，最终屈服，迫使玩家找到另一条路线。另一个例子可能是当玩家角色穿过时移动和摇曳的植被。这可以通过使用基于物理的模拟或脚本动画来实现，以创建更加真实和响应的环境。
- en: 'To implement these dynamic environment responses, you’ll need to leverage a
    combination of physics, scripting, and animation techniques. This may involve
    using Unity’s built-in physics system to detect collisions or triggers, and then
    triggering the appropriate animations or visual effects to create the desired
    environmental response. For example, let’s consider a script that could be used
    to make a bridge collapse under the player’s weight:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些动态环境响应，您需要利用物理、脚本和动画技术的组合。这可能涉及使用 Unity 内置的物理系统来检测碰撞或触发器，然后触发适当的动画或视觉效果以创建所需的环境响应。例如，让我们考虑一个可以用来使桥梁在玩家重量下坍塌的脚本：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `BridgeCollapse` script is attached to the bridge GameObject.
    When the player’s collider enters the bridge’s trigger area, the script checks
    the total weight of the player and any carried objects. If the weight exceeds
    the bridge’s maximum capacity, the script sets a Boolean variable to `true` and
    triggers the *Collapse* animation on the bridge’s `Animator` component and gradually
    lowers the bridge’s position over time. The `Update` method then checks this Boolean
    variable and, if it is `true`, gradually lowers the bridge’s position over time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`BridgeCollapse` 脚本被附加到桥梁 GameObject 上。当玩家的碰撞器进入桥梁的触发区域时，脚本会检查玩家及其携带物体的总重量。如果重量超过桥梁的最大承载能力，脚本会将布尔变量设置为
    `true`，并在桥梁的 `Animator` 组件上触发 *Collapse* 动画，并随着时间的推移逐渐降低桥梁的位置。然后 `Update` 方法会检查这个布尔变量，如果它是
    `true`，则会随着时间的推移逐渐降低桥梁的位置。
- en: To summarize, this section delves into scripting nuanced interactions between
    characters and their surroundings, focusing on physics and animations to heighten
    game immersion. This includes character responses to environmental elements and
    dynamic environment adaptations to player actions. The next section will explore
    sophisticated animation features such as IK and Blend Trees, enhancing character
    movements and realism in Unity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本节深入探讨了角色与其周围环境之间细微的交互，重点关注物理和动画以增强游戏沉浸感。这包括角色对环境元素的响应以及环境对玩家动作的动态适应。下一节将探讨逆运动学（IK）和混合树（Blend
    Trees）等复杂的动画功能，以增强 Unity 中的角色动作和逼真度。
- en: Advanced animation techniques
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级动画技术
- en: This section introduces sophisticated features in Unity for crafting complex
    character movements and behaviors, such as IK and Blend Trees. It covers integrating
    these advanced animations with physics for lifelike motion, offering insights
    into best practices and case studies on dynamic character interactions with their
    environment. First, let’s take a look at IK.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Unity 中用于制作复杂角色动作和行为的先进功能，例如逆运动学（IK）和混合树（Blend Trees）。它涵盖了将这些高级动画与物理结合以实现逼真运动的方法，并提供了关于最佳实践和动态角色与环境交互案例研究的见解。首先，让我们看看逆运动学（IK）。
- en: Mastering IK
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握逆运动学
- en: This sub-section delves into the concept of IK and its crucial role in creating
    realistic movements for character joints in Unity. It covers the essentials of
    IK for tasks such as reaching and walking and guides you through implementing
    IK using Unity’s built-in solvers to dynamically control limb movements.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节深入探讨了逆运动学（IK）的概念及其在 Unity 中为角色关节创建逼真动作中的关键作用。它涵盖了逆运动学在诸如伸手和行走等任务中的基本知识，并指导您使用
    Unity 内置求解器实现逆运动学，以动态控制肢体运动。
- en: IK is particularly useful for tasks where the character needs to interact with
    the environment in a natural and responsive way, such as reaching for an object
    or adjusting their footsteps to match uneven terrain. By using IK, you can ensure
    that the character’s limbs and joints move in a more lifelike and believable manner,
    rather than relying solely on pre-defined animations. Unity provides several built-in
    tools and features to help you implement IK within your projects. The **Animator**
    component, for example, includes IK features that allow you to control the position
    and orientation of a character’s limbs dynamically. To use IK in Unity, you’ll
    typically start by setting up IK targets for the character’s limbs, such as the
    hands or feet. These targets can then be positioned in the scene, and the IK solver
    will automatically adjust the character’s joint rotations to match the target
    positions. Additionally, Unity’s Cinemachine package includes a powerful IK system
    that can be used to control the character’s head and eye movements, allowing you
    to create more natural and responsive camera behaviors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 反向运动学（IK）特别适用于角色需要以自然和响应的方式与环境交互的任务，例如伸手取物或调整脚步以适应不平坦的地形。通过使用 IK，你可以确保角色的肢体和关节以更逼真和可信的方式移动，而不是完全依赖于预定义的动画。Unity
    提供了几个内置工具和功能，帮助你将 IK 集成到你的项目中。例如，**Animator** 组件包括 IK 功能，允许你动态地控制角色肢体的位置和方向。要在
    Unity 中使用 IK，你通常需要首先为角色的肢体设置 IK 目标，如手或脚。然后，这些目标可以在场景中定位，IK 求解器会自动调整角色的关节旋转以匹配目标位置。此外，Unity
    的 Cinemachine 包含一个强大的 IK 系统，可用于控制角色的头部和眼部运动，从而创建更自然和响应灵敏的摄像机行为。
- en: Utilizing Blend Trees for fluid animations
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 Blend Trees 实现流畅动画
- en: This section covers the fundamentals of Blend Trees in Unity, highlighting their
    ability to facilitate smooth transitions between animations based on parameters,
    thus enhancing character movement fluidity. It includes a practical guide to setting
    up and configuring Blend Trees in the **Animator** controller, showing how to
    seamlessly blend different animations, such as walking and running, according
    to **Speed** parameters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Unity 中 Blend Trees 的基础知识，强调了它们根据参数促进动画之间平滑过渡的能力，从而增强角色动作的流畅性。它包括一个实际指南，说明如何在
    **Animator** 控制器中设置和配置 Blend Trees，展示了如何根据 **速度** 参数无缝混合不同的动画，如行走和跑步。
- en: Blend Trees are a way to blend between multiple animations based on one or more
    parameters, such as the character’s speed or direction. This allows you to create
    smooth transitions between different animations, rather than having abrupt changes
    that can disrupt the overall fluidity of the character’s movements. For example,
    you might have a Blend Tree that blends between a walking animation and a running
    animation based on the character’s speed. As the character accelerates, the Blend
    Tree would gradually transition from the walking animation to the running animation,
    creating a natural and responsive movement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Blend Trees 是一种基于一个或多个参数（如角色的速度或方向）在多个动画之间进行混合的方法。这允许你创建不同动画之间的平滑过渡，而不是有突兀的变化，这可能会破坏角色动作的整体流畅性。例如，你可能有一个基于角色速度在行走动画和跑步动画之间进行混合的
    Blend Tree。随着角色加速，Blend Tree 会逐渐从行走动画过渡到跑步动画，创建出自然且响应灵敏的动作。
- en: Creating and configuring Blend Trees
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和配置 Blend Trees
- en: 'To set up a Blend Tree in Unity, you’ll first need to create the individual
    animations that you want to blend between. Once you have your animations, you
    can then create a new Blend Tree state in your **Animator** controller and configure
    the blending parameters. Here’s a step-by-step guide on how to create and configure
    a Blend Tree for a character’s walking and running animations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Unity 中设置 Blend Tree，你首先需要创建你想要混合的单独动画。一旦你有了动画，你就可以在你的 **Animator** 控制器中创建一个新的
    Blend Tree 状态并配置混合参数。以下是如何为角色的行走和跑步动画创建和配置 Blend Tree 的分步指南：
- en: In the **Animator** window, create a new **Blend** **Tree** state.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Animator** 窗口中，创建一个新的 **Blend Tree** 状态。
- en: Drag and drop your walking and running animations into the Blend Tree.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的行走和跑步动画拖放到 Blend Tree 中。
- en: In the Blend Tree settings, create a new parameter (e.g., `Speed`) to control
    the blending between the animations.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Blend Tree 设置中，创建一个新的参数（例如，`速度`）来控制动画之间的混合。
- en: Adjust the Blend Tree’s settings to define how the animations should be blended
    based on the **Speed** parameter. For example, you might set the walking animation
    to be used when the speed is below two m/s and the running animation to be used
    when the speed is above four m/s, with a smooth transition in between.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整Blend Tree的设置以定义动画应根据**速度**参数如何混合。例如，你可能将行走动画设置为当速度低于两米/秒时使用，将跑步动画设置为当速度高于四米/秒时使用，并在两者之间实现平滑过渡。
- en: '![Figure 8.11 – An example of a Blend Tree](img/B22128_08_11.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – Blend Tree的示例](img/B22128_08_11.jpg)'
- en: Figure 8.11 – An example of a Blend Tree
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – Blend Tree的示例
- en: In the example shown in *Figure 8**.11*, the Blend Tree is added in the **Animator**
    window, then configured in the **Inspector** window.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在图8.11中所示示例中，Blend Tree被添加到**Animator**窗口中，然后在**Inspector**窗口中进行配置。
- en: Having explored the use of Blend Trees to create smooth and dynamic animations,
    we now move on to the concept of animation layers. This section will delve into
    how animation layers can be utilized to manage multiple animations simultaneously,
    allowing for greater flexibility and complexity in character movements and behaviors.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了使用Blend Trees创建平滑和动态动画之后，我们现在转向动画层的概念。本节将深入探讨如何利用动画层同时管理多个动画，从而在角色动作和行为上实现更大的灵活性和复杂性。
- en: Leveraging animation layers for complex behaviors
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用动画层实现复杂行为
- en: This sub-section dives into how animation layers in Unity can manage multiple
    animations for nuanced character behaviors, such as separating upper-body actions
    from lower-body movements. It discusses setting up these layers and using avatar
    masks to isolate and blend animation parts for dynamic character expressions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节深入探讨了Unity中动画层如何管理多个动画，以实现细腻的角色行为，例如将上半身动作与下半身运动分离。它讨论了如何设置这些层以及使用角色面具来隔离和混合动画部分，以实现动态的角色表情。
- en: Animation layers in Unity allow you to stack and blend multiple animations on
    top of each other, enabling you to create complex animation behaviors that would
    be difficult to achieve with a single animation. This is particularly useful for
    scenarios where you want to have independent control over different parts of the
    character’s body, such as having the upper body perform a shooting animation while
    the lower body continues a running cycle. By organizing your animations into separate
    layers, you can apply different blending modes and weight values to each layer,
    allowing you to fine-tune the interactions between the various animations and
    create a more natural and responsive character performance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的动画层允许你在多个动画之上堆叠和混合，使你能够创建单动画难以实现的复杂动画行为。这在需要独立控制角色身体不同部分的情况下特别有用，例如上半身执行射击动画，而下半身继续跑步循环。通过将动画组织到单独的层中，你可以为每个层应用不同的混合模式和权重值，从而精细调整各种动画之间的交互，并创建更自然和响应灵敏的角色表现。
- en: To set up animation layers in Unity, you’ll first need to create additional
    layers in your **Animator** controller. Each layer can then be assigned its own
    set of animations, and you can use the layer’s weight value to control the influence
    of that layer on the final animation output. In addition to layers, you can also
    leverage avatar masks to further refine the blending of animations. Avatar masks
    allow you to isolate specific parts of the character’s body, such as the upper
    body or the legs, and apply different animations or blending settings to those
    specific areas. For example, you might have a running animation on the base layer,
    and then overlay a shooting animation on the upper body layer. By using an avatar
    mask to restrict the shooting animation to only the upper body, you can create
    a seamless blend between the running and shooting actions, resulting in a more
    dynamic and engaging character performance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中设置动画层，你首先需要在你的**Animator**控制器中创建额外的层。然后，每个层都可以分配自己的动画集，你可以使用层的权重值来控制该层对最终动画输出的影响。除了层之外，你还可以利用角色面具来进一步细化动画的混合。角色面具允许你隔离角色的特定身体部位，如上半身或腿部，并对这些特定区域应用不同的动画或混合设置。例如，你可能在基础层上有一个跑步动画，然后在上半身层上叠加一个射击动画。通过使用角色面具将射击动画限制在上半身，你可以创建跑步和射击动作之间的无缝混合，从而实现更动态和吸引人的角色表现。
- en: Synchronizing animations with physics
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将动画与物理同步
- en: This sub-section addresses the intricate task of aligning animations with physics
    for realism, exploring common synchronization challenges and offering best practices
    to ensure that movements such as jumping or falling are convincingly matched with
    physical forces and interactions. One of the primary challenges is the inherent
    disconnect between the two systems, where pre-defined animations and physics-based
    movements can become out of sync, resulting in unnatural or jarring transitions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨将动画与物理对齐以实现逼真效果的复杂任务，探讨常见的同步挑战，并提供最佳实践以确保跳跃或坠落等动作能够令人信服地与物理力量和交互匹配。其中主要挑战之一是两个系统之间的固有脱节，预定义的动画和基于物理的运动可能会变得不同步，导致不自然或令人不适的过渡。
- en: To effectively synchronize animations with physics, you need to employ a combination
    of techniques. Unity’s Mecanim system, a powerful tool that allows for complex
    animation blending, state machines, and event handling, can be used for this.
    By leveraging Mecanim, you can create transitions between animation states that
    respond dynamically to changes in the game’s physics.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地同步动画与物理，您需要采用一系列技术。Unity的Mecanim系统，这是一个强大的工具，允许进行复杂的动画混合、状态机和事件处理，可以用于此目的。通过利用Mecanim，您可以在动画状态之间创建动态响应游戏物理变化的过渡。
- en: Another technique involves using physics-based animations, such as ragdoll physics.
    Ragdoll physics allow a character’s skeleton to be controlled by the physics engine,
    resulting in realistic responses to impacts and forces. This is especially useful
    for simulating natural reactions to falls or impacts.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术涉及使用基于物理的动画，例如ragdoll物理。ragdoll物理允许角色的骨骼由物理引擎控制，从而对冲击和力量产生逼真的反应。这对于模拟坠落或冲击的自然反应特别有用。
- en: Achieving a natural integration requires careful tuning and testing. Adjusting
    animation curves, fine-tuning collision detection, and creating custom scripts
    for specific interactions can help resolve synchronization issues. By rigorously
    testing these elements, you can ensure that character movements appear smooth
    and lifelike.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自然的集成需要仔细的调整和测试。调整动画曲线、微调碰撞检测以及为特定交互创建自定义脚本可以帮助解决同步问题。通过严格测试这些元素，您可以确保角色动作看起来平滑且逼真。
- en: Aligning animations with physics in Unity requires a thoughtful approach that
    combines the strengths of the Mecanim system, the realism of ragdoll physics,
    and meticulous tuning and testing. This ensures that animations and physics work
    together seamlessly to create a more immersive game experience.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中将动画与物理对齐需要一种深思熟虑的方法，这种方法结合了Mecanim系统的优势、ragdoll物理的逼真效果以及细致的调整和测试。这确保了动画和物理能够无缝协作，从而创造更加沉浸式的游戏体验。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter equipped you with the skills to infuse realism into your Unity
    games through physics and animation, covering everything from physics implementation
    to character animation, environmental interactions, and advanced animation techniques.
    Mastering these concepts is crucial for creating immersive and believable game
    worlds, as realistic animations and physics interactions greatly enhance player
    engagement and the overall gaming experience. By understanding how to seamlessly
    integrate animations with physics, you can ensure that your characters move naturally
    and interact with the environment in a convincing manner. That is why we covered
    these topics in this chapter. These lessons also lay the foundation for more complex
    gameplay mechanics, allowing you to build sophisticated and responsive game systems.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了通过物理和动画将现实主义融入Unity游戏中的技能，涵盖了从物理实现到角色动画、环境交互和高级动画技术的各个方面。掌握这些概念对于创建沉浸式和逼真的游戏世界至关重要，因为逼真的动画和物理交互极大地增强了玩家的参与度和整体游戏体验。通过了解如何无缝集成动画与物理，您可以确保角色动作自然，并以令人信服的方式与环境交互。这就是为什么我们在本章中涵盖了这些主题。这些课程还为更复杂的游戏机制奠定了基础，让您能够构建复杂和响应灵敏的游戏系统。
- en: As we transition to the next chapter, we will further your C# scripting proficiency,
    delving into asynchronous programming, cloud integration, event systems, and script
    optimization for enhanced game performance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们过渡到下一章节，我们将进一步提升您的C#脚本编写能力，深入探讨异步编程、云集成、事件系统和脚本优化以提高游戏性能。
- en: Join our community on Discord
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: [https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：[https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)
- en: '![](img/Disclaimer_QR1.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Disclaimer_QR1.jpg)'
- en: 'Part 3: Advanced Game Development'
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：高级游戏开发
- en: In this part, you will master advanced concepts in Unity and C# programming.
    You will learn to utilize coroutines for non-blocking code execution, manage and
    manipulate complex data structures, design custom event systems, and optimize
    scripts for performance and efficiency. You will delve into **artificial intelligence**
    (**AI**), applying pathfinding algorithms, building decision-making logic, and
    creating sophisticated NPC behaviors. Networking fundamentals will be covered,
    including developing multiplayer matchmaking systems, ensuring consistent game
    states, and managing network latency and security. Additionally, you will use
    profiling tools to analyze game performance, manage memory usage, optimize graphical
    assets and rendering processes, and write efficient, optimized code to enhance
    overall game performance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将掌握Unity和C#编程的高级概念。你将学习如何使用协程进行非阻塞代码执行，管理和操作复杂的数据结构，设计自定义事件系统，并优化脚本以提高性能和效率。你将深入研究**人工智能**（**AI**），应用路径查找算法，构建决策逻辑，并创建复杂的NPC行为。还将涵盖网络基础知识，包括开发多人匹配系统，确保游戏状态的一致性，以及管理网络延迟和安全。此外，你将使用性能分析工具来分析游戏性能，管理内存使用，优化图形资源和渲染过程，并编写高效、优化的代码以提升整体游戏性能。
- en: 'This part includes the following chapters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B22128_09.xhtml#_idTextAnchor209), *Advanced Scripting Techniques
    in Unity* *–* *Async, Cloud Integration, Events, and Optimizing*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B22128_09.xhtml#_idTextAnchor209), *Unity中的高级脚本技术* *–* *异步、云集成、事件和优化*'
- en: '[*Chapter 10*](B22128_10.xhtml#_idTextAnchor234), *Implementing Artificial
    Intelligence in Unity*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B22128_10.xhtml#_idTextAnchor234), *在Unity中实现人工智能*'
- en: '[*Chapter 11*](B22128_11.xhtml#_idTextAnchor255), *Multiplayer and Networking*
    *–* *Matchmaking, Security, and Interactive Gameplay*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B22128_11.xhtml#_idTextAnchor255), *多人游戏和网络* *–* *匹配、安全和交互式游戏*'
- en: '[*Chapter 12*](B22128_12.xhtml#_idTextAnchor276), *Optimizing Game Performance
    in Unity* *–* *Profiling and Analysis Techniques*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B22128_12.xhtml#_idTextAnchor276), *在Unity中优化游戏性能* *–* *性能分析和技术*'
