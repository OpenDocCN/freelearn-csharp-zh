- en: Automation for Software Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed the importance of unit tests and integration
    tests in software development, and how they ensure the reliability of your code
    base. We also discussed how unit and integration tests are integral parts of all
    software production stages and are run each time the code base is modified.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other important tests, called **functional**/**acceptation**
    tests. They are run only at the end of each sprint to verify that the output of
    the sprint actually satisfies the specifications that were agreed upon with the
    stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is specifically dedicated to functional/acceptance tests and to
    the techniques for defining and executing them. More specifically, this chapter
    covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using unit testing tools for automating functional tests in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – automating functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to design both manual and automatic
    tests to verify that the code produced by a sprint complies with its specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reader is encouraged to read [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*, before proceeding with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2017 or the 2019 free Community Edition
    or better with all the database tools installed. Here, we will modify the code
    of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing Your Code
    with Unit Test Cases and TDD*, which is available at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20)[.](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional/acceptance tests use techniques similar to unit and integration
    tests but differ from them in that they are run only at the end of each sprint.
    They have the fundamental role of verifying that the current version of the whole
    software complies with its specifications. This verification is turned into a
    formal process for the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests represent the most important part of the contract between stakeholders
    and the development team, the other part being the verification of non-functional
    specifications. The way this contract is formalized depends on the very nature
    of the relationship between the development team and stakeholders. In the case
    of a supplier-customer relationship, they become part of the supplier-customer
    business contract for each sprint, and they are written by a team that works for
    the customer. If the tests fail, then the sprint is rejected and the supplier
    must run a supplementary sprint to fix all problems. In case there is no formal
    business contract, the result of the tests is usually used to drive the specifications
    for the next sprints. However, also in this case, if the failure percentage is
    high, the sprint may be rejected and should be repeated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formalized functional tests that run at the end of each sprint avoid that results
    achieved in previous sprints might be destroyed by new code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using an agile development methodology, maintaining an updated battery
    of functional tests is the best way to get a formal representation of the final
    system specifications since, during agile development, the specifications of the
    final system are not decided before development starts but are the result of the
    system evolution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the output of the first sprints may differ a lot from the final system
    in these early stages, it is not worth spending too much time writing detailed
    manual tests and/or automatized tests. Therefore, you may limit to add a few examples
    to the user stories that will be used both as inputs for software development
    and as manual tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As system functionalities become always more stable, it is worth investing
    time in writing detailed and formal functional tests for them. For each functional
    specification, we must write tests that verify their correct operation also in
    extreme cases. For instance, in a payment use case, we must write tests that verify
    all possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Not enough funds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various digitization errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Card expired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrong credentials and repeated wrong credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of manual tests, for each of the preceding scenarios, we must give
    all details of all steps involved in each operation, and for each step, the expected
    result.
  prefs: []
  type: TYPE_NORMAL
- en: An important decision is if you want to automate all or a part of the acceptance/functional
    tests since it is very expansive to write automatic tests that simulate a human
    operator that interacts with a system's user interface. The final decision depends
    on the cost of the test implementation divided by the expected number of times
    it will be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of CI/CD, the same functional test can be executed several times
    but, unluckily, functional/acceptance tests are strictly tied to the way the user
    interface is implemented, and, in modern systems, the user interface is frequently
    changed. Therefore, in this case, the same test is executed with exactly the same
    user interface not more than a couple of times.
  prefs: []
  type: TYPE_NORMAL
- en: In order to overcome all the problems related to the user interface, functional
    tests can be implemented as **subcutaneous tests**, that is, as tests that bypass
    the user interface. However, subcutaneous tests are incomplete by their very nature since
    they can't detect errors in the user interface itself. Moreover, in the case of
    a web application, subcutaneous tests usually suffer from other limitations because
    they bypass the whole HTTP protocol. In the case of ASP.NET Core applications,
    this means that the whole ASP.NET Core pipeline must be bypassed and that requests
    are passed directly to ASP.NET controllers. Therefore, authentication, authorization,
    CORS, and the behavior of other modules in the ASP.NET Core pipeline will not
    be analyzed by the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete automatic functional test of a web application should do the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Start an actual browser on the URL to be tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait so that any JavaScript on the page completes its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, send commands to the browser that simulate the behavior of a human operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, after each interaction with the browser, automatic tests should wait
    so that any JavaScript that was triggered by the interaction completes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While browser automatization tools exist, tests implemented with browser automatization,
    as mentioned earlier, are very expensive and difficult to implement. Therefore,
    the suggested approach of ASP.NET Core MVC is to send actual HTTP requests to
    an actual copy of the web application, with a .NET HTTP client instead of using
    a browser. Once the HTTP client receives an HTTP response, it parses it in a DOM
    tree and verifies that it received the right response.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference with the browser automatization tools is that the HTTP client
    is not able to run any JavaScript. However, other tests may be added to test the
    JavaScript code. These tests are based on test tools that are specific to JavaScript,
    such as **Jasmine** and **Karma**.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to automatize functional tests for web applications
    with a .NET HTTP client, while a practical example of functional test automation
    is shown in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Using unit testing tools to automate functional tests in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated functional/acceptance tests use the same test tools as unit and integration
    tests. That is, these tests can be embedded in the same xUnit, NUnit, or MSTests
    projects that we described in [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*. However, in this case, we must add further
    tools that are able to interact with and inspect the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this chapter, we will focus on web applications since they
    are the main focus of this book. Accordingly, if we are testing web APIs, we just need
    `HTTPClient` instances since they can easily interact with web API endpoints both
    in XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of ASP.NET Core MVC applications that return HTML pages, the interaction
    is more complex, since we also need tools for parsing and interacting with the
    HTML page DOM tree. The `AngleSharp` NuGet package is a great solution since it
    supports state-of-the-art HTML and minimal CSS and has extension points for externally
    provided JavaScript engines, such as Node.js. However, we don't advise you to
    include JavaScript and CSS in your tests, since they are strictly tied to target
    browsers, so the best option for them is to use JavaScript-specific test tools
    that you can run directly in the target browsers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic options for testing a web application with the `HTTPClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: An `HTTPClient` instance connects with the actual *staging* web application
    through the internet/intranet, together with all other humans that are beta-testing
    the software. The advantage of this approach is that you are testing the *real
    stuff*, but tests are more difficult to conceive since you can't control the initial
    state of the application before each test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `HTTPClient` instance connects with a local application that is configured,
    initialized, and launched before every single test. This scenario is completely
    analogous to the unit test scenario. Test results are reproducible the initial
    state before each test is fixed, tests are easier to design, and the actual database
    can be replaced by a faster and easier-to-initialize in-memory database. However,
    in this case, you are far from the actual system's operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good strategy is to use the second approach, where you have full control of
    the initial state, for testing all extreme cases, and then the first approach
    for testing random average cases on the *real stuff*.
  prefs: []
  type: TYPE_NORMAL
- en: The two sections that follow describe both approaches. The two approaches differ
    just in the way you define the fixtures of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the staging application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, your tests need just an instance of `HTTPClient`, so you must
    define an efficient fixture that supplies `HTTPClient` instances, avoiding the
    risk of running out of windows connections. We faced this problem in the *.NET
    Core HTTP clients* section of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml), *Applying
    Service-Oriented Architectures with .NET Core*. It can be solved by managing `HTTPClient` instances
    with `IHTTPClientFactory` and injecting them with dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a dependency injection container, we can enrich it with the capability
    of efficiently handling `HTTPClient` instances with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `AddHTTPClient` extension belongs to the `Microsoft.Extensions.DependencyInjection`
    namespace and is defined in the `Microsoft.Extensions.HTTP` NuGet package. Therefore,
    our test fixture must create a dependency injection container, must call `AddHTTPClient`,
    and finally, must build the container. The following fixture class does this job
    (please refer to the *Advanced test preparation/test tear down scenarios* section
    of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing Your Code
    with Unit Test Cases and TDD*, if you don''t remember fixture classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding definition, your tests should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In `Test1`, once you get an HTTP client, you can test the application by issuing
    an HTTP request and then by analyzing the response returned by the application.
    More details on how to process the response returned by the server will be given
    in the *Use case* section.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to test an application that runs in a controlled
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a controlled application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, we create an ASP.NET Core server within the test application and
    test it with an `HTTPClient` instance. The `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package contains all that we need to create both an HTTP client and the
    server running the application. We also need to reference the whole web framework
    by referencing the `Microsoft.AspNetCore.App` NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must also transform the test project into a web project with the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the test project icon in Visual Studio solution explorer, and select
    the edit project item from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the root XML node, which should be `<Project Sdk="Microsoft.NET.Sdk">`,
    with `<Project Sdk="Microsoft.NET.Sdk.web">`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Mvc.Testing` contains a fixture class that does the job
    of launching a local web server and furnishing a client for interacting with it.
    The predefined fixture class is `WebApplicationFactory<T>`. The generic `T` argument
    must be instantiated with the `Startup` class of your web project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests look like the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want to analyze the HTML of the returned pages, you must also reference
    the `AngleSharp` NuGet package. We will see how to use it in the example of the
    next section. The simplest way to cope with databases in this type of tests is
    to replace them with in-memory databases that are faster and automatically cleared
    whenever the local server is shut down and restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by creating a new deployment environment, say `AutomaticStaging`,
    and an associate configuration file that is specific for the tests. After having
    created this new deployment environment, go to the `ConfigureServices` method
    of your application''s `Startup` class and locate the place where you add your
    `DBContext` configuration. Once located that place, add an `if` there, that, in
    case the application is running in the `AutomaticStaging` environment, replaces
    your `DBContext` configuration with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, you can also add all needed instructions to clear a standard
    database in the constructor of a custom fixture that inherits from `WebApplicationFactory<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – automating functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add a simple acceptance test to the ASP.NET Core test
    project of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*. Our test approach is based on the `Microsoft.AspNetCore.Mvc.Testing`
    and `AngleSharp` NuGet packages. Please make a new copy of the whole solution.
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, we must turn the test project into a web project by replacing
    the `sdk` attribute of the root node of its project file in `Sdk="Microsoft.NET.Sdk.web"`.
  prefs: []
  type: TYPE_NORMAL
- en: The test project already references the ASP.NET Core project under `test` and
    all the required xUnit NuGet packages, so we need to add just the `Microsoft.AspNetCore.Mvc.Testing`
    and `AngleSharp` NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a new class file called `UIExampleTestcs.cs`. We need `using`
    statements to reference all the necessary namespaces. More specifically, we need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`using PackagesManagement;`: This is needed for referencing your application
    classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using Microsoft.AspNetCore.Mvc.Testing;`: This is needed for referencing the
    client and server classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using AngleSharp;` and `using AngleSharp.Html.Parser;`: These are needed for
    referencing `AngleSharp` classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO`: This is needed in order to extract HTML from HTTP responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using Xunit`: This is needed for referencing all `xUnit` classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up, the whole `using` block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the standard fixture class we introduced in the previous *Testing
    a controlled application* section, that is, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to write a test for the home page! This test verifies that
    the home URL returns a successful HTTP result and that the home page contains
    a link to the package management page, which is the `/ManagePackages` relative
    link.
  prefs: []
  type: TYPE_NORMAL
- en: It is fundamental to understand that automatic tests must not depend on the
    details of the HTML, but that they must verify just logical facts, in order to
    avoid frequent changes after each small modification of the application HTML.
    That's why we just verify that the needed links exist without putting constraints
    on where they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call `TestMenu` our home page test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step of each test is the creation of a client. Then, if the test
    needs the analysis of some HTML, we must prepare the so-called `AngleSharp` browsing
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration object specifies options such as cookie handling and other
    browser-related properties. At this point, we are ready to require the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As a first step, we verify that the response we received contains a success
    status code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method call throws an exception in case of unsuccessful status
    code, hence causing the test to fail. HTML analysis needs to be extracted from
    the response. The following code shows a simple way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`ReadAsStreamAsync` returns `Stream`, which we can use to build `StreamReader`
    (a stream specialized for reading text), which can read the whole response body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must pass the extracted HTML to our previous `AngleSharp` browsing
    context object, so it can build a DOM tree. The following code shows how to do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `OpenAsync` method executes a DOM-building activity with the settings contained
    in `context`. The input for building the DOM document is specified by the lambda
    function passed as an argument to `OpenAsync`. In our case, `req.Content(...)`
    builds a DOM tree from the HTML string passed to the `Content` method, which is
    the HTML contained in the response received by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a `document` object is obtained, we can use it as we would use it in JavaScript.
    In particular, we can use `QuerySelector` to find an anchor with the required
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It remains to verify just that `node` is not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have done it! If you want to analyze pages that require a user to be logged
    in or other more complex scenarios, you need to enable cookies and automatic URL
    redirects in the HTTP client. This way, the client will behave like a usual browser
    that stores and sends cookies and that moves to another URL whenever it receives
    a `Redirect` HTTP response. This can be done by passing an options object to the `CreateClient` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding setup, your tests can do everything a usual browser can do.
    For instance, you can design tests where the HTTP client logs in and accesses
    pages that require authentication since `HandleCookies=true` lets the authentication
    cookie be stored by the client and be sent in all subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains the importance of acceptance/functional tests, and how
    to define detailed manual tests to be run on the output of each sprint. At this
    point, you should be able to define automatic and/or manual tests to verify that,
    at the end of each sprint, your application complies with its specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Then, this chapter analyzed when it is worth automating some or all acceptance/functional
    tests and describes how to automate them in ASP.NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: A final example showed how to write, in practice, ASP.NET Core acceptance/functional
    tests with the help of `AngleSharp` to inspect the responses returned by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it always worth automating user interface acceptance tests in the case of
    quick CI/CD cycles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the disadvantage of the subcutaneous test for ASP.NET Core applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the suggested technique for writing ASP.NET Core acceptance tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the suggested way of inspecting the HTML returned by the server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More details on the `Microsoft.AspNetCore.Mvc.Testing` NuGet package and `AngleSharp` can
    be found in their respective official documentation at [https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0) and [https://anglesharp.github.io/](https://anglesharp.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Readers interested in JavaScript tests can refer to the Jasmine documentation: [https://jasmine.github.io/](https://jasmine.github.io/).
  prefs: []
  type: TYPE_NORMAL
