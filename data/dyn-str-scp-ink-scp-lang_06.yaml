- en: '*Chapter 5*: Tunnels and Threads'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：隧道和线程'
- en: This chapter begins with the concept of a **tunnel**. Created using multiple
    diverts and at least two knots (please refer to [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031),
    *Knots, Diverts, and Looping Patterns*), tunnels serve as a faster way in which
    to create complex structures than previously discussed in the last chapters. Following
    this, we will move on to review **threads**, which is another way of using diverts
    to connect multiple parts of an ink project dynamically. Finally, we will look
    at combining tunnels and threads to make even more complex structures based on
    the simple rules of how ink understands knots and diverts within a story.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从**隧道**的概念开始。通过多个转向和至少两个结（请参阅[*第二章*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)，“结、转向和循环模式”）创建，隧道提供了一种比上一章中讨论的更快的创建复杂结构的方法。在此之后，我们将继续回顾**线程**，这是另一种使用转向动态连接墨水项目多个部分的方法。最后，我们将探讨结合隧道和线程，根据墨水在故事中理解结和转向的简单规则，创建更复杂的结构。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Diverting to a divert
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向到转向
- en: Pulling on threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉动线程
- en: Combining tunnels and threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合隧道和线程
- en: In this chapter, we will explore the various ways of using tunnels and threads
    to make more complex projects. We have already explored multiple levels of choices
    and their outcomes to create a subdivided story. Instead of diverting to one knot
    or stitch after another, we will learn how to integrate tunnels as a series of
    diverts before returning to their original location. We will also look at how
    knots can be easily combined into one by *threading* them together.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用隧道和线程创建更复杂项目的各种方法。我们已经探讨了多个级别的选择及其结果，以创建一个细分的故事。我们不会转向一个接一个的结或针，而是学习如何将隧道作为一系列转向整合，然后再返回到它们原来的位置。我们还将探讨如何通过*编织*将结轻松地组合在一起。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples used in this chapter, in the `*.ink` files, can be found on GitHub
    at [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter5](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter5).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的示例，在`*.ink`文件中，可以在GitHub上找到：[https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter5](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter5)。
- en: Diverting to a divert
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向到转向
- en: In [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031), *Knots, Diverts,
    and Looping Patterns*, the concept of a divert was introduced alongside story
    sections called knots. Using diverts and knots, looping structures were created
    and other ink concepts were also revealed as alternatives (please refer to [*Chapter
    3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048), *Sequences, Cycles, and Shuffling
    Text*). The use of functions and passing values to knots were covered in [*Chapter
    4*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062), *Variables, Lists, and Functions*.
    This section builds on those concepts by explaining how diverts can be used to
    create more advanced stories.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)，“结、转向和循环模式”，转向的概念与被称为结的故事部分一起引入。使用转向和结，创建了循环结构，并揭示了其他墨水概念作为替代方案（请参阅[*第三章*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048)，“序列、循环和文本洗牌”）。在[*第四章*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062)，“变量、列表和函数”中，介绍了函数的使用和向结传递值。本节基于这些概念，通过解释如何使用转向来创建更高级的故事来构建。
- en: 'In [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031), *Knots, Diverts,
    and Looping Patterns*, diverts appeared according to the following pattern:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)，“结、转向和循环模式”中，转向按照以下模式出现：
- en: 'Example 1:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 5.1 – Inky''s output for Example 1'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 示例1的Inky输出'
- en: '](img/Figure_5.1_B17597.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17597.jpg)'
- en: Figure 5.1 – Inky's output for Example 1
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 示例1的Inky输出
- en: A divert can also be used multiple times. In ink, this is known as the concept
    of a **tunnel**. The flow will move to a knot and then back to its original position.
    From the reader's perspective, the flow *tunnels* from one section to another.
    Tunnels are an incredibly useful concept in ink where looping structures are common.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 转向也可以多次使用。在ink中，这被称为**隧道**的概念。流程将移动到一个结，然后返回到其原始位置。从读者的角度来看，流程*隧道*从一个部分到另一个部分。隧道是ink中循环结构常见时的一个极其有用的概念。
- en: In this topic, we will review how to make and use tunnels. Instead of needing
    to specify each location of a divert within a knot or a stitch, a tunnel allows
    an author to move the flow of a story through a series of sections and then back
    again when the tunnel finally ends.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将回顾如何制作和使用隧道。不需要在结或缝合中指定每个转向的位置，隧道允许作者将故事的流程通过一系列章节移动，并在隧道最终结束时再次返回。
- en: Making tunnels
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作隧道
- en: 'Tunnels are created in ink by using a divert, `->`, the name of a knot or stitch,
    and then another divert, `->`. This signals to ink that the flow will move to
    the knot and then back again. In the destination knot, two diverts are then used
    together: `->->`. This creates the *tunneling* effect of the flow moving to the
    knot and then moving back again:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用转向符号`->`、结或缝合的名称，然后另一个转向符号`->`，在墨水中创建隧道。这会告诉墨水，流程将移动到结，然后再返回。在目标结中，然后使用两个转向符号一起：`->->`。这创建了流程移动到结然后再返回的*隧道效应*：
- en: 'Example 2:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Example 2* can appear confusing if you don''t remember how the flow works
    in ink. A divert moves the flow to a destination in the story. In *Example 2*,
    the flow starts with the text of `For the reader, <>`. Then, this is diverted
    to the `next_part` knot. The start of the tunnel begins with the code of `-> next_part
    ->`, continues into the `next_part` knot, and then returns with the use of two
    diverts, `->->`. For a reader who only sees the output, it will appear as a complete
    sentence:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了墨水中的流程是如何工作的，*示例 2*可能会显得令人困惑。转向符号将流程移动到故事中的目的地。在*示例 2*中，流程从`For the reader,
    <>`的文本开始。然后，这被转向到`next_part`结。隧道的开始以`-> next_part ->`的代码开始，继续到`next_part`结，然后使用两个转向符号`->->`返回。对于只看到输出的读者来说，它将看起来是一个完整的句子：
- en: '![Figure 5.2 – Inky''s output from Example 2'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2 – Inky 的 Example 2 输出'
- en: '](img/Figure_5.2_B17597.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2_B17597.jpg](img/Figure_5.2_B17597.jpg)'
- en: Figure 5.2 – Inky's output from Example 2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Inky 的 Example 2 输出
- en: Reminder
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: '*Chapter 1, Text, Flow, Choices, and Weaves*, introduced the concept of glue
    and the use of the less-than and greater-than symbols together. This concept *glues* one
    line to the end of the previous. In *Example 2*, glue is used before the start
    of the tunnel and then after it ends to create the complete sentence from the
    knot in the story.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一章，文本，流程，选择和编织*介绍了胶水的概念以及使用小于和大于符号的组合。这个概念*粘合*了一行到前一行。在*示例 2*中，胶水用于隧道开始之前和结束之后，以从故事中的结创建完整的句子。'
- en: 'Tunnels can connect any two points within a story. In *Example 2*, the tunnel
    started, moved to a knot, and then returned. Another use of a tunnel might be
    to create a series of story events for a player to view. You can do this by creating
    a tunnel from one knot to the next until the end of the story:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道可以连接故事中的任何两个点。在*示例 2*中，隧道开始，移动到一个结，然后返回。隧道可能还有另一种用途，即为玩家创建一系列故事事件来查看。你可以通过从一个结到下一个结创建隧道直到故事结束来实现这一点：
- en: 'Example 3:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In *Example 3*, the three different knots (that is, `past`, `present`, and `future`)
    are all part of one long tunnel. The first connects to the `past` knot, the `past`
    knot is then connected to the `present` knot, the `present` knot is connected
    to the `future` knot, and, finally, the `future` knot is connected to the `DONE`
    knot to end the flow and the story. In each of these cases, the use of the two
    diverts, `->->`, points back to where the tunnel started before it continues to
    the next knot in the longer series. As with *Example 2* and its complete sentence,
    the resulting output from *Example 3* is one single flow through the sections
    to create a complete narrative experience for the reader.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 3*中，三个不同的结（即`过去`、`现在`和`未来`）都是一条长隧道的部分。第一个连接到`过去`结，然后`过去`结连接到`现在`结，`现在`结连接到`未来`结，最后，`未来`结连接到`完成`结以结束流程和故事。在这些情况下，使用两个转向符号`->->`都指回隧道开始的地方，然后再继续到更长的系列中的下一个结。与*示例
    2*及其完整的句子一样，*示例 3*的结果是读者通过章节的单个流程来创造一个完整的叙事体验。
- en: Tunneling to tunnels
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隧道到隧道
- en: '*Example 3* pointed towards a great use of tunnels: they can connect to other
    tunnels! It is possible to tunnel into a tunnel in ink. While linear patterns
    such as the one used in *Example 3* are common, advanced patterns reuse tunnels
    as part of larger, looping structures. Because knots that use two diverts will
    always return to where they started, it is possible to use knots to perform small
    calculations or to check values before continuing the repeating pattern:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3* 指出了隧道的伟大用途：它们可以连接到其他隧道！在墨迹中，可以进入隧道中的隧道。虽然像 *示例 3* 中使用的线性模式很常见，但高级模式会重用隧道作为更大、循环结构的一部分。因为使用两个转向的结总是会返回到起始位置，所以可以使用结来执行小计算或检查值，然后再继续重复的模式：'
- en: 'Example 4:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 4:'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Example 4* demonstrates a more complex pattern using knots, variables, and
    tunnels. For each loop of the `kitten` knot, a tunnel is created for the `check_kitten`
    knot, which then returns to `kitten` again. In the `check_kitten` knot, two checks
    are made. The first check is to make sure the value of the `anger` variable is
    greater than or equal to `2`. If it is, the sentence is shown and then the story
    diverts to `DONE`. The second check is to make sure the `playful` variable is
    greater than or equal to `2`. If this second check is true, a different sentence
    is shown, and the story diverts to `DONE`. Inside the weave created by the two
    sticky choices, each option, either `scratch_head` or `scratch_side`. Inside each,
    the knots associated with the player''s actions increase the value of the variable.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4* 展示了一个使用结、变量和隧道的更复杂模式。对于 `kitten` 结的每一圈，都会为 `check_kitten` 结创建一个隧道，然后再次返回到
    `kitten`。在 `check_kitten` 结中，进行了两次检查。第一次检查是确保 `anger` 变量的值大于或等于 `2`。如果是，则显示句子，并将故事转向
    `DONE`。第二次检查是确保 `playful` 变量的值大于或等于 `2`。如果这个第二次检查为真，则显示不同的句子，并将故事转向 `DONE`。在由两个粘性选择创建的编织中，每个选项，无论是
    `scratch_head` 还是 `scratch_side`，都会增加与玩家动作相关的结的变量值。'
- en: '*Example 4* uses multiple tunnels to create a complex pattern. However, there
    is another concept in ink that would make the same code easier to understand:
    **threads**. As we will discuss in the next section, threads allow us to easily
    pull in knots without needing to divert to them first.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4* 使用多个隧道创建了一个复杂模式。然而，墨迹中还有一个概念可以使相同的代码更容易理解：**线程**。正如我们将在下一节中讨论的，线程允许我们轻松地拉入结，而无需首先转向它们。'
- en: Pulling on threads
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉动线程
- en: Diverts were introduced as *pointing* to their destination. To create a tunnel,
    a hyphen and a greater-than symbol were combined, `->`, on either side of the
    name of the knot or stitch. However, diverts can *point* inward as well. When
    a divert is created with a less-than symbol and a hyphen, `<-`, it becomes a different
    concept called a **thread**. Instead of moving the flow to the destination, ink
    *threads* the destination's text or code into another location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 转向被引入为 *指向* 目的地。要创建隧道，将破折号和大于符号组合在一起，`->`，位于结或针的名称两侧。然而，转向也可以 *指向* 内部。当使用小于符号和破折号创建转向时，`<-`，它变成了一个称为
    **线程** 的不同概念。而不是将流程移动到目的地，墨迹 *线程化* 目的地文本或代码到另一个位置。
- en: In this section, we will work with threads to collapse more complex weaves into
    simpler structures. Instead of multiple levels of choices and their text outcomes,
    we will use threads to achieve the same result in a more efficient way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用线程将更复杂的编织简化为更简单的结构。而不是多级选择及其文本结果，我们将使用线程以更有效的方式实现相同的结果。
- en: Making threads
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作线程
- en: 'Often, threads are considered to be an inverse of diverts. Instead of the flow
    moving to the section of the story, the section of the story moves to the current
    position of the flow. Returning to the code from *Example 4*, threads can be used
    in multiple places to achieve the same result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线程被认为是转向的逆。而不是流程移动到故事的部分，故事的部分移动到流程的当前位置。回到 *示例 4* 的代码，线程可以在多个地方使用以实现相同的结果：
- en: 'Example 5:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5:'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In *Example 5*, threads are used in place of the previous tunnels in *Example
    4*. The `scratch_head` and `scratch_side` knots are now *threaded* into the code
    of the `kitten` knot. This is also true for `check_kitten`. Instead of creating
    multiple tunnels, threads are often used to collapse an increasingly complex structure
    into sections that can be *threaded* together.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 5* 中，使用了线程代替了 *示例 4* 中的先前隧道。现在 `scratch_head` 和 `scratch_side` 结被 *线程化*
    到 `kitten` 结的代码中。对于 `check_kitten` 也是如此。而不是创建多个隧道，通常使用线程将越来越复杂的结构折叠成可以 *线程化* 在一起的段落。
- en: Warning
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Sometimes, the use of complex tunnel and thread structures can confuse Inky.
    Always double-check all of the code when using these more advanced concepts!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用复杂的隧道和线程结构可能会让 Inky 迷惑。在使用这些更高级的概念时，总是要仔细检查所有代码！
- en: Using multiple threads
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个线程
- en: 'Each use of a thread must be on its own line. The reason why they cannot be
    combined is that ink moves the section of the story up to the location of the
    current flow. A second thread cannot have its content moved to the previous location.
    It no longer exists! However, threads, like diverts, can also be elements within
    a set or alternative. Just as a different form of a divert can be *pointing* inward,
    threads can be used with a shuffle on a single line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程的使用都必须单独一行。它们不能合并的原因是墨水会将故事的部分移动到当前流程的位置。第二个线程不能将其内容移动到上一个位置。它不再存在了！然而，线程，就像改道一样，也可以是集合或替代中的元素。就像不同的改道形式可以
    *指向* 内部一样，线程也可以在单行上使用洗牌：
- en: 'Example 6:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In *Example 6*, threads are used as elements of a shuffle. Each time the story
    is run, one of the two threads will be chosen and *threaded* into the story, creating
    a new experience. Combining threads with alternatives in this way is useful when
    creating *alternative* content for a story that is accessed as part of the thread
    itself.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 6* 中，线程被用作洗牌的元素。每次运行故事时，两个线程中的一个将被选择并 *编织* 到故事中，创造一个新的体验。以这种方式将线程与替代结合使用，在创建作为线程本身访问的故事的
    *替代* 内容时非常有用。
- en: 'A common pattern found in many role-playing video games uses various player
    statistics to determine what content is available based on testing the value of
    a variable. If it is within a certain range, content can then be *threaded* into
    the current weave. This will add additional context for the result of an action
    for the reader:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多角色扮演视频游戏中常见的一种模式是使用各种玩家统计数据来确定基于测试变量的值，哪些内容是可用的。如果它在某个范围内，内容就可以被 *编织* 到当前的结构中。这将为读者提供关于行动结果的额外上下文：
- en: 'Example 7:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each of the stitches in *Example 7* holds additional text. Because the stitches
    are a part of the overall `save_or_doom` knot, they can be used as part of a thread.
    Subsections of a story are still *sections*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7* 中的每个针都包含额外的文本。因为针是 `save_or_doom` 结的一部分，所以它们可以用作线程的一部分。故事的小节仍然是 *部分*。'
- en: '*Example 7* also uses conditional options, as covered in [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031),
    *Knots, Diverts, and Looping Patterns*, and variables, as discussed in [*Chapter
    4*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062), *Variables, Lists, and Functions*.
    By testing for the range of values of the `strength` and `intelligence` variables,
    the `15`, both options are shown:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7* 也使用了条件选项，如[*第 2 章*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)中所述的“结、改道和循环模式”，以及[*第
    4 章*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062)中讨论的变量。通过测试 `strength` 和
    `intelligence` 变量的值范围，`15` 个选项都显示出来：'
- en: '![Figure 5.3 – Inky''s output from Example 7'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 从示例 7 中输出的 Inky 的结果'
- en: '](img/Figure_5.3_B17597.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B17597.jpg)'
- en: Figure 5.3 – Inky's output from Example 7
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 从示例 7 中输出的 Inky 的结果
- en: 'A single thread can be created using the inverse action of diverting. Instead
    of moving to a location, the section moves to the current moment in the flow.
    Additionally, multiple threads can be combined to create a continuous narrative
    experience for the reader as they are pulled together. When working with threads,
    there is one more important aspect: the `DONE` keyword. In the last section of
    this topic, we will examine how threads can be closed and what this means when
    you are using threads inside each other.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用改道的逆动作创建单个线程。不是移动到某个位置，而是该部分移动到流程的当前时刻。此外，可以将多个线程组合起来，为读者创造一个连续的叙事体验，因为它们被拉在一起。当处理线程时，还有一个更重要的方面：`DONE`
    关键字。在本主题的最后部分，我们将探讨如何关闭线程以及当你使用嵌套线程时这意味着什么。
- en: Ending threads
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束线程
- en: The `DONE` and `END` keywords were introduced in [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031),
    *Knots, Diverts, and Looping Patterns*. The differences between the two keywords
    were explained in their usage. The `END` keyword stops the story, and the `DONE`
    keyword stops the current flow. When using threads, the flow of a story is also
    affected. In other words, the `DONE` keyword closes the *current* flow. In many
    cases, this will be the story itself. When using threads, the keyword closes the
    thread itself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`DONE`和`END`关键字在[*第二章*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)“节点、转向和循环模式”中引入。这两个关键字的使用之间的区别在它们的用法中得到了解释。`END`关键字停止故事，而`DONE`关键字停止当前流程。当使用线程时，故事流程也会受到影响。换句话说，`DONE`关键字关闭了*当前*流程。在许多情况下，这将是故事本身。当使用线程时，该关键字会关闭线程本身。'
- en: 'When creating knots in Inky, often, authors will get a warning suggesting the
    `DONE` keyword is needed within a knot that does not contain the keyword. When
    working with threads, this warning clues the author into this important aspect
    of threads and the `DONE` keyword:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Inky 中创建节点时，作者通常会收到一个警告，提示在不含该关键字的节点中需要`DONE`关键字。当处理线程时，这个警告会提示作者注意线程和`DONE`关键字的重要方面：
- en: 'Example 8:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Example 8* uses two instances of the `DONE` keyword. This might seem strange,
    but each use of the keyword closes its own thread. When run within Inky, the two
    choices, each within a separate thread, will be combined:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8*使用了两个`DONE`关键字的实例。这可能会显得有些奇怪，但每个关键字的用法都会关闭其自己的线程。在 Inky 中运行时，两个选择，每个选择都在一个单独的线程中，将被合并：'
- en: '![Figure 5.4 – The combined thread output for Example 8'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 示例 8 的组合线程输出'
- en: '](img/Figure_5.4_B17597.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.4_B17597.jpg)'
- en: Figure 5.4 – The combined thread output for Example 8
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 示例 8 的组合线程输出
- en: 'In *Example 8*, the separate uses of the `DONE` keyword do not interact with
    each other. Each thread is contained within itself. This becomes evident when
    trying to move the inclusion of the second thread inside the first after the `DONE`
    keyword:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 8*中，`DONE` 关键字的单独使用不会相互影响。每个线程都包含在其自身之内。这一点在尝试在`DONE`关键字之后将第二个线程的包含移动到第一个线程中时变得明显：
- en: 'Example 9:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In *Example 9*, the second thread comes after the use of the `DONE` keyword.
    Unlike *Example 8*, where both choices will be combined into a single weave, the
    story will end before the second thread occurs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 9*中，第二个线程出现在`DONE`关键字的使用之后。与*示例 8*不同，其中两个选择将合并成一个单一的编织，故事将在第二个线程出现之前结束：
- en: '![Figure 5.5 – Thread closing in Example 9'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 示例 9 中的线程关闭'
- en: '](img/Figure_5.5_B17597.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.5_B17597.jpg)'
- en: Figure 5.5 – Thread closing in Example 9
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 示例 9 中的线程关闭
- en: '*Example 9* demonstrates the interaction between the `DONE` keyword and the
    threads. The `DONE` keyword closes the current flow. In *Example 9*, the second
    thread inside the first is never reached because it is closed using the `DONE`
    keyword.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9*展示了`DONE`关键字与线程之间的交互。`DONE`关键字关闭当前流程。在*示例 9*中，第一个线程内部的第二个线程永远不会到达，因为它被`DONE`关键字关闭。'
- en: Threads and tunnels are not separate concepts, but two different ways in which
    to achieve similar results based on the needs of the author. In the next topic,
    we will look at various ways of combining both concepts to create even more complex
    stories. We will use tunnels to move to a location in a story and examine how
    threads can be repeated instead of writing more code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和洞穴不是两个独立的概念，而是根据作者的需求以两种不同的方式实现类似结果的方法。在下一个主题中，我们将探讨结合这两个概念的各种方法，以创建更复杂的故事。我们将使用洞穴移动到故事中的某个位置，并检查线程如何重复而不是编写更多代码。
- en: Combining tunnels and threads
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洞穴和线程的结合
- en: Tunnels allow the flow of a story to move to a knot or a stitch and then return.
    Threads act as the inverse, moving the content from the knot or the stitch to
    the current flow position. Together, they form a powerful way in which to craft
    a story composed of different parts. Often, in advanced projects, these two concepts
    are paired together with weaves and gathering points to expand or contract the
    number of possible branches.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 洞穴允许故事流程移动到节点或缝合处，然后返回。线程作为其逆过程，将内容从节点或缝合处移动到当前流程位置。共同作用，它们形成了一种强大的方式，可以用来构建由不同部分组成的叙事。在高级项目中，这两个概念通常与编织和聚集点一起使用，以扩展或收缩可能的分支数量。
- en: Tunnels can be reused, and threads can be repeated. In this topic, we will explore
    how threads and tunnels can be combined to create more complex stories using less
    overall code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道可以被重复使用，线程可以被重复。在本主题中，我们将探讨如何将线程和隧道结合起来，使用更少的总体代码创建更复杂的故事。
- en: Reusing tunnels and repeating threads
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用隧道和重复线程
- en: '*Example 4* used multiple tunnels, and *Example 5* showed the same result using
    multiple threads. It is also possible to combine multiple tunnels and threads
    by breaking up content into stitches as part of multiple knots for each part of
    a story. For example, many role-playing video games start by presenting dialogue
    from a character. Then, they provide the player with the illusion of control by
    letting them choose between various options before, finally, looping back to the
    same options until the player makes a certain selection to continue:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4*使用了多个隧道，而*示例 5*使用多个线程展示了相同的结果。也可以通过将内容分割成线迹作为每个故事部分的多个结点的一部分来组合多个隧道和线程。例如，许多角色扮演视频游戏开始时先展示角色的对话。然后，他们通过让玩家在做出最终选择之前选择各种选项，来给玩家提供控制的错觉，最终回到相同的选项，直到玩家做出某个选择以继续：'
- en: 'Example 10:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Example 10* reuses a tunnel. The first instance occurs when the reader selects
    between the `old_shrine` knot and does not have the rake (that is, if `has_rake`
    is equal to `false`), they are prompted with the **Retrieve rake** option and
    the second possible instance of the tunnel.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10*重复使用了一个隧道。第一次出现是在读者在`old_shrine`结点之间选择，并且没有耙子（即，如果`has_rake`等于`false`），他们会收到**检索耙子**选项和隧道的第二个可能实例。'
- en: Threads are used in *Example 10* to break up the text of the responses from
    the character. This creates a simplified weave with the text split into its stitches.
    For authors, this pattern allows them to change or add to the response text without
    needing to worry about the code portion of the weave.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 10*中，线程被用来分割角色的响应文本。这创建了一个简化的编织模式，文本被分割成其线迹。对于作者来说，这种模式允许他们在不担心编织代码部分的情况下更改或添加响应文本。
- en: 'Finally, gathering points (as discussed in [*Chapter 1*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014),
    *Text, Flow, Choices, and Weaves*) are used three times. The first one collapses
    the possible branches of the first weave and creates the first instance of a tunnel.
    The second occurs as part of the `rake` stitch. This gathering point is the end
    of both instances of tunnels and collapses the result of either option: `has_rake`
    is equal to `true`), the **Retrieve rake** option no longer appears, and the story
    ends with the character raking the leaves at the old shrine.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，收集点（如[*第 1 章*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014)，*文本、流程、选择和编织*中讨论的）被使用了三次。第一次是折叠第一个编织的可能分支，并创建隧道的第一个实例。第二次是作为`rake`线迹的一部分发生。这个收集点是两个隧道实例的结束，并折叠了任何选项的结果：`has_rake`等于`true`），**检索耙子**选项不再出现，故事以角色在旧神社耙树叶结束。
- en: '`"This is an example," Dan wrote`. However, in *Example 8*, the name of the
    character appears before the dialogue to signal who is saying the words. [*Chapter
    10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145), *Dialogue Systems with ink*,
    will revisit the use of tags and examine some approaches for writing and tagging
    dialogue appearing in a video game.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: “这是一个例子，”丹写道。然而，在*示例 8*中，角色的名字出现在对话之前，以表明是谁在说话。[*第 10 章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)，*带有墨水的对话系统*将重新审视标签的使用，并探讨一些在视频游戏中编写和标记对话的方法。
- en: Threads with tunnels
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有隧道的线程
- en: 'Threads move a section of a story to the current flow position when moving
    through the in-memory version of the code. Internally, this does not change their
    actual location in the larger story code but their connection to the current version
    of the flow as the story is run. This means it is possible to include a tunnel
    inside a thread. In these scenarios, the flow would *thread* the knot or stitch
    and then move to another section and back again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过代码的内存版本移动时，线程会将故事的一部分移动到当前流程位置。内部来说，这不会改变它们在更大故事代码中的实际位置，但它们与故事运行时当前版本流程的连接会改变。这意味着可以在线程内包含隧道。在这些情况下，流程会“线程”结点或线迹，然后移动到另一个部分，然后再返回：
- en: 'Example 11:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Example 11* demonstrates the basic pattern of using tunnels inside threads.
    This is safe to do in ink because of the way the flow *threads* through the knots
    or stitches. A more complicated usage might be part of a dialogue system for a
    video game, where data is passed to knots to perform different small calculations
    as part of the reaction to a player following certain branches of a conversation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11* 展示了在线程中使用隧道的基模式。在墨迹中这样做是安全的，因为流程*线程化*通过结或缝合点的方式。更复杂的用法可能是视频游戏对话系统的一部分，其中数据被传递到结以执行不同的微小计算，作为玩家跟随对话某些分支的反应的一部分：'
- en: 'Example 12:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 12:'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Example 12* is a more practical example of the pattern introduced in *Example
    1*. It uses a thread to pass data to a knot as if it was a function. Additionally,
    *Example 12* uses a tunnel inside the `adjust_reputation` knot as a connection
    to the `report_reputation` knot. For each choice, the value of the `reputation`
    variable will be changed after a reader makes the selection. The new value of
    `reputation` will be shown as a result.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12* 是 *示例 1* 中引入的模式的一个更实际的例子。它使用线程将数据传递到结，就像是一个函数。此外，*示例 12* 在 `adjust_reputation`
    结内部使用隧道作为连接到 `report_reputation` 结的连接。对于每个选择，`reputation` 变量的值将在读者做出选择后更改。新的 `reputation`
    值将作为结果显示。'
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Example 12* uses a backslash, `\`, with opening, `(`, and closing, `)`, parentheses.
    These *escape* the use of the parentheses instead of creating an optional label.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12* 使用反斜杠`\`，带有开括号`(`和闭括号`)`，来*转义*括号的使用，而不是创建一个可选的标签。'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned even more about how diverts work with knots and
    stitches in ink. We explored how the concept of a tunnel connects two different
    sections in ink. When a story runs, the flow moves to the knot or the stitch and
    then returns with the use of two diverts, `->->`. We also reviewed how tunnels
    can be used as part of a more complicated flow pattern of a longer series of connections
    between two sections. Next, we saw how threads, another concept in ink, act as
    the inverse of a divert, where a section is moved to the current flow location
    instead of the flow moving to its content. Finally, we examined some patterns
    of using tunnels inside threads to pass data to a knot and show the changed values
    of a variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了更多关于转向如何在墨迹中与结和缝合点协同工作的知识。我们探讨了隧道概念如何将墨迹中的两个不同部分连接起来。当故事运行时，流程移动到结或缝合点，然后使用两个转向`->->`返回。我们还回顾了隧道如何作为更复杂流程模式的一部分被使用，该模式是两个部分之间更长的连接序列。接下来，我们看到了线程，墨迹中的另一个概念，作为转向的逆过程，其中部分被移动到当前流程位置而不是流程移动到其内容。最后，我们检查了一些在线程中使用隧道将数据传递到结并显示变量更改值的模式。
- en: Threads and tunnels, while more advanced concepts, create simpler overall code.
    Threads allow developers to separate code into different sections and then *thread*
    them back together again. Tunnels allow developers to achieve the same general
    result as threads but in a different way. Instead of pulling content together,
    a tunnel moves to a knot or a stitch and then back again, *tunneling* through
    a story to a location and then back again. Threads and tunnels have their specific
    usages, but both allow a developer to create more complex projects by using their
    different sections more efficiently.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和隧道虽然是更高级的概念，但可以使代码更加简洁。线程允许开发者将代码分成不同的部分，然后将它们再次*线程化*组合在一起。隧道允许开发者以不同的方式实现与线程相同的一般结果。而不是将内容拉在一起，隧道移动到一个结或一个缝合点，然后再返回，*隧道化*通过故事到达一个位置然后再返回。线程和隧道有其特定的用法，但两者都允许开发者通过更有效地使用它们的各个部分来创建更复杂的项目。
- en: In the next chapter, we move on to use the ink-Unity Integration plugin. While
    Inky has been used to show the ink code output, the ink-Unity Integration plugin
    will allow us to have far more control over how an ink story runs. In the coming
    chapters, we will also learn how to use C# and the ink API to make selections,
    change the value of variables, and even access functions in ink code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用 ink-Unity Integration 插件。虽然 Inky 已经被用来显示墨迹代码输出，但 ink-Unity Integration
    插件将允许我们更全面地控制墨迹故事如何运行。在接下来的章节中，我们还将学习如何使用 C# 和 ink API 来进行选择、更改变量的值，甚至访问墨迹代码中的函数。
- en: Questions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: To return from a tunnel in a knot or a stitch, which ink concept must be used
    twice?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从结或缝合点中的隧道返回，必须使用哪个墨迹概念两次？
- en: How do tunnels work in ink?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 墨迹中的隧道是如何工作的？
- en: How are threads different from diverts and tunnels?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程与转向和隧道有何不同？
- en: Can multiple threads be used on the same line?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以在同一行上使用多个线程？
