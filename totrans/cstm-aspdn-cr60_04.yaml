- en: '*Chapter 4*: Configuring and Customizing HTTPS with Kestrel'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：使用 Kestrel 配置和自定义 HTTPS'
- en: In **ASP.NET** **Core**, **HTTPS** is on by default, and it is a first-class
    feature. On Windows, the certificate that is needed to enable HTTPS is loaded
    from the Windows certificate store. If you create a project on **Linux** or **Mac**,
    the certificate is loaded from a certificate file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **ASP.NET** **Core** 中，**HTTPS** 默认启用，并且是一个一等特性。在 Windows 上，启用 HTTPS 所需的证书是从
    Windows 证书存储中加载的。如果你在 **Linux** 或 **Mac** 上创建项目，证书是从证书文件中加载的。
- en: Even if you want to create a project to run it behind an **IIS** or an **NGINX**
    web server, HTTPS is enabled. Usually, you would manage the certificate on the
    IIS or NGINX web server in that case. Having HTTPS enabled here shouldn't be a
    problem, however, so don't disable it in the ASP.NET Core settings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你想创建一个在 **IIS** 或 **NGINX** 网络服务器后面运行的项目，HTTPS 也会被启用。通常情况下，你会在 IIS 或 NGINX
    网络服务器上管理证书。然而，在这里启用 HTTPS 不会成为问题，所以不要在 ASP.NET Core 设置中禁用它。
- en: Managing the certificate within the ASP.NET Core application directly makes
    sense if you run services behind the firewall, services that are not accessible
    from the internet, services such as background services for a microservice-based
    application, or services in a self-hosted ASP.NET Core application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在防火墙后面运行服务，例如不可从互联网访问的服务，如基于微服务的应用程序的后台服务，或者自托管的 ASP.NET Core 应用程序中的服务，直接在
    ASP.NET Core 应用程序中管理证书是有意义的。
- en: There are also some scenarios on Windows where it makes sense to load the certificate
    from a file. This could be in an application that you will run on **Docker** for
    Windows or Linux. Personally, I like the flexible way of loading the certificate
    from a file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，也有一些场景下从文件中加载证书是有意义的。这可能是你将在 **Docker** for Windows 或 Linux 上运行的应用程序中。我个人喜欢从文件中灵活加载证书的方式。
- en: 'Only two topics will be covered in this short chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本简短章节将涵盖两个主题：
- en: Introducing Kestrel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Kestrel
- en: Setting up Kestrel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Kestrel
- en: 'The topics in this chapter refer to the hosting layer of the ASP.NET Core architecture:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的主题涉及 ASP.NET Core 架构的托管层：
- en: '![Figure 4.1 – The ASP.NET Core architecture](img/Figure_4.1_B17996.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – ASP.NET Core 架构](img/Figure_4.1_B17996.jpg)'
- en: Figure 4.1 – The ASP.NET Core architecture
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – ASP.NET Core 架构
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core MVC application. To do this, open your console, shell, or Bash terminal,
    and change to your working directory. Then, use the following command to create
    a new MVC application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的描述，你需要创建一个 ASP.NET Core MVC 应用程序。为此，打开你的控制台、shell 或 Bash 终端，切换到你的工作目录。然后，使用以下命令创建一个新的
    MVC 应用程序：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code by typing the following command in the already-open console:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过双击项目文件在 Visual Studio 中打开项目，或在 Visual Studio Code 中通过在已打开的控制台中输入以下命令来打开项目：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter04).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的 **GitHub** 仓库中找到，网址为 [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter04)。
- en: Introducing Kestrel
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Kestrel
- en: '**Kestrel** is a newly implemented HTTP server that is the hosting engine of
    ASP.NET Core. Every ASP.NET Core application will run on the Kestrel server. Classic
    ASP.NET applications (running on **.NET** **Framework**) usually run directly
    on the IIS. With ASP.NET Core, Microsoft was inspired by **Node.js**, which also
    ships an HTTP server called **libuv**. In the first version of ASP.NET Core, Microsoft
    also used libuv, and then it added a layer on top called Kestrel. At that time,
    Node.js and ASP.NET Core shared the same HTTP server.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kestrel** 是一个新实现的 HTTP 服务器，它是 ASP.NET Core 的托管引擎。每个 ASP.NET Core 应用程序都会在
    Kestrel 服务器上运行。经典的 ASP.NET 应用程序（在 **.NET** **Framework** 上运行）通常直接在 IIS 上运行。在 ASP.NET
    Core 中，微软受到了 **Node.js** 的启发，它也提供了一个名为 **libuv** 的 HTTP 服务器。在 ASP.NET Core 的第一个版本中，微软也使用了
    libuv，然后它添加了一个名为 Kestrel 的层。当时，Node.js 和 ASP.NET Core 共享同一个 HTTP 服务器。'
- en: Since the .NET Core framework has grown and **.NET sockets** have been implemented
    on it, Microsoft has built its own HTTP server based on .NET sockets and removed
    libuv, which was a dependency they don't own and control. Now, Kestrel is a full-featured
    HTTP server that runs ASP.NET Core applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.NET Core框架已经发展，并且在其上实现了**.NET套接字**，因此微软基于.NET套接字构建了自己的HTTP服务器，并移除了libuv，这是一个他们不拥有和控制依赖项。现在，Kestrel是一个功能齐全的HTTP服务器，可以运行ASP.NET
    Core应用程序。
- en: The IIS acts as a reverse proxy that forwards the traffic to Kestrel and manages
    the Kestrel process. On Linux, usually NGINX is used as a reverse proxy for Kestrel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IIS充当反向代理，将流量转发到Kestrel并管理Kestrel进程。在Linux上，通常使用NGINX作为Kestrel的反向代理。
- en: Setting up Kestrel
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Kestrel
- en: 'As we did in the first two chapters of this book, we need to override the default
    `WebHostBuilder` a little bit to set up Kestrel. With ASP.NET Core 3.0 and later,
    it is possible to replace the default Kestrel base configuration with a custom
    configuration. This means that the Kestrel web server is configured to the host
    builder. Let''s look at the steps to set up:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的前两章中所做的那样，我们需要稍微覆盖默认的`WebHostBuilder`来设置Kestrel。从ASP.NET Core 3.0开始，可以替换默认的Kestrel基础配置为自定义配置。这意味着Kestrel网络服务器被配置到主机构建器。让我们看看设置的步骤：
- en: 'You will be able to add and configure Kestrel manually simply by using it.
    The following code shows what happens when you call the `UseKestrel()` method
    on `IwebHostBuilder`. Let''s now see how this fits into the `CreateWebHostBuilder`
    method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只需使用它，就可以手动添加和配置Kestrel。以下代码展示了在`IwebHostBuilder`上调用`UseKestrel()`方法时会发生什么。现在让我们看看这是如何与`CreateWebHostBuilder`方法结合的：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code shows how the `Program.cs` looked until ASP.NET Core 5.0\.
    In ASP.NET Core 6.0, the new minimal API approach is used to configure your application:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码显示了直到ASP.NET Core 5.0的`Program.cs`看起来如何。在ASP.NET Core 6.0中，使用新的最小API方法来配置您的应用程序：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We'll focus on the `UseKestrel()` method for the rest of this chapter. The `UseKestrel()`
    method accepts an action to configure the Kestrel web server.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章的剩余部分专注于`UseKestrel()`方法。`UseKestrel()`方法接受一个操作来配置Kestrel网络服务器。
- en: 'What we *actually* need to do is configure the addresses and ports that the
    web server is listening on. For the HTTPS port, we also need to configure how
    the certificate should be loaded:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上需要做的是配置网络服务器监听的地址和端口。对于HTTPS端口，我们还需要配置证书应该如何加载：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't forget to add a using statement to the `System.Net` namespace to resolve
    the `IPAddress`.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记添加一个`using`语句到`System.Net`命名空间以解析`IPAddress`。
- en: In this snippet, we add the addresses and ports to listen on. The configuration
    is defined as a secure endpoint configured to use HTTPS. The `UseHttps()` method
    is overloaded multiple times in order to load certificates from the Windows certificate
    store as well as from files. In this case, we will use a file called `certificate.pfx`
    located in the project folder.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个片段中，我们添加了要监听的地址和端口。配置被定义为使用HTTPS的安全端点。`UseHttps()`方法被多次重载，以便从Windows证书存储以及从文件中加载证书。在这种情况下，我们将使用位于项目文件夹中的名为`certificate.pfx`的文件。
- en: 'To create a certificate file to just play around with this configuration, open
    the certificate store and export the development certificate created by Visual
    Studio. It is located in the current user certificates under the personal certificates:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个证书文件来玩这个配置，请打开证书存储并导出Visual Studio创建的开发证书。它位于当前用户证书下的个人证书中：
- en: '![](img/Figure_4.2_B17996.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_4.2_B17996.jpg)'
- en: Figure 4.2 – Certificates
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 证书
- en: Right-click this entry. In the context menu, go to **All Tasks** and click **Export**.
    In the **Certificate Export Wizard**, click **Next** and then click **Yes, export
    the private key**, then click **Next**. Now, choose the **.PFX** format in the
    next screen and click **Next**. Here, you need to set a password. This is the
    exact same password you will need to use in the code, as seen in the following
    code example. Choose a filename and a location to store the file, and then click
    **Next**. The last screen will show a summary. Click **Finish** to save the certificate
    to a file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击此条目。在上下文菜单中，转到**所有任务**并单击**导出**。在**证书导出向导**中，单击**下一步**然后单击**是，导出私钥**，然后单击**下一步**。现在，在下一屏幕中选择**.PFX**格式并单击**下一步**。在这里，您需要设置一个密码。这就是您在代码中需要使用的密码，如以下代码示例所示。选择一个文件名和一个存储文件的位置，然后单击**下一步**。最后一个屏幕将显示摘要。单击**完成**将证书保存到文件。
- en: For your safety
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了您的安全
- en: 'Use the following line *only* to play around with this configuration:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用以下行来尝试这个配置：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To clarify why – the problem is the hardcoded password. Never, *ever* store
    a password in a code file that gets pushed to any source code repository. Ensure
    that you load the password from the configuration API of ASP.NET Core. Use the
    user secrets on your local development machine and use environment variables on
    a server. On **Azure**, use the application settings to store the passwords. Passwords
    will be hidden on the Azure portal UI if they are marked as passwords.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明原因——问题是硬编码的密码。永远，**永远**不要将密码存储在会被推送到任何源代码仓库的代码文件中。请确保您从 ASP.NET Core 的配置
    API 中加载密码。在您的本地开发机器上使用用户密钥，在服务器上使用环境变量。在 **Azure** 上，使用应用程序设置来存储密码。如果将它们标记为密码，密码将在
    Azure 门户 UI 中被隐藏。
- en: Summary
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This is just a small customization, but it should help if you want to share
    the code between different platforms, or if you want to run your application on
    Docker and don't want to worry about certificate stores, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小的定制，但如果您想在不同的平台之间共享代码，或者想在 Docker 上运行应用程序而不想担心证书存储等问题，它应该会有所帮助。
- en: Usually, if you run your application behind a web server such as an IIS or NGINX,
    you don't need to care about certificates in your ASP.NET Core 6.0 application.
    However, if you host your application inside another application, on Docker, or
    without an IIS or NGINX, you will need to.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您在 IIS 或 NGINX 等网络服务器后面运行应用程序，您不需要关心您的 ASP.NET Core 6.0 应用程序中的证书。然而，如果您在另一个应用程序内部、Docker
    上或没有 IIS 或 NGINX 的情况下托管应用程序，您将需要这样做。
- en: In the next chapter, we're going to talk about how to configure the hosting
    of ASP.NET Core web applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何配置 ASP.NET Core 网络应用程序的托管。
