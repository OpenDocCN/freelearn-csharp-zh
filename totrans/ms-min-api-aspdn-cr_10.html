<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-135"><a id="_idTextAnchor140"/>10</h1>
<h1 id="_idParaDest-136"><a id="_idTextAnchor141"/>Evaluating and Benchmarking the Performance of Minimal APIs</h1>
<p>The purpose of this chapter is to understand one of the motivations for which the minimal APIs framework was created.</p>
<p>This chapter will provide some obvious data and examples of how you can measure the performance of an ASP.NET 6 application using the traditional approach as well as how you can measure the performance of an ASP.NET application using the minimal API approach.</p>
<p>Performance is key to any functioning application; however, very often it takes a back seat.</p>
<p>A performant and scalable application depends not only on our code but also on the development stack. Today, we have moved on from the .NET full framework and .NET Core to .NET and can start to appreciate the performance that the new .NET has achieved, version after version – not only with the introduction of new features and the clarity of the framework but also primarily because the framework has been completely rewritten and improved with many features that have made it fast and very competitive compared to other languages. </p>
<p>In this chapter, we will evaluate the performance of the minimal API by comparing its code with identical code that has been developed traditionally. We’ll understand how to evaluate the performance of a web application, taking advantage of the <strong class="bold">BenchmarkDotNet</strong> framework, which can be useful in other application scenarios.</p>
<p>With minimal APIs, we have a new simplified framework that helps improve performance by leaving out some components that we take for granted with ASP.NET.</p>
<p>The themes we will touch on in this chapter are as follows:</p>
<ul>
<li>Improvements with minimal APIs</li>
<li>Exploring performance with load tests</li>
<li>Benchmarking minimal APIs with BenchmarkDotNet</li>
</ul>
<h1 id="_idParaDest-137"><a id="_idTextAnchor142"/>Technical requirements</h1>
<p>Many systems can help us test the performance of a framework.</p>
<p>We can measure how many requests per second one application can handle compared to another, assuming equal application load. In this case, we are talking about load testing.</p>
<p>To put the minimal APIs on the test bench, we need to install <strong class="bold">k6</strong>, the framework we will use for conducting our tests.</p>
<p>We will launch load testing on a Windows machine with only .NET applications running.</p>
<p>To install k6, you can do either one of the following:</p>
<ul>
<li>If you’re using the <em class="italic">Chocolatey package manager</em> (<a href="https://chocolatey.org/">https://chocolatey.org/</a>), you can install the unofficial k6 package with the following command:<pre><strong class="bold">choco install k6</strong></pre></li>
<li>If you’re using <em class="italic">Windows Package Manager</em> (<a href="https://github.com/microsoft/winget-cli">https://github.com/microsoft/winget-cli</a>), you can install the official package from the k6 manifests with this command:<pre><strong class="bold">winget install k6</strong></pre></li>
<li>You can also test your application published on the internet with Docker:<pre><strong class="bold">docker pull loadimpact/k6</strong></pre></li>
<li>Or as we did, we installed k6 on the Windows machine and launched everything from the command line. You can download k6 from this link: <a href="https://dl.k6.io/msi/k6-latest-amd64.msi">https://dl.k6.io/msi/k6-latest-amd64.msi</a>.</li>
</ul>
<p>In the final part of the chapter, we’ll measure the duration of the HTTP method for making calls to the API.</p>
<p>We’ll stand at the end of the system as if the API were a black box and measure the reaction time. BenchmarkDotNet is the tool we’ll be using – to include it in our project, we need to reference its <strong class="bold">NuGet</strong> package:</p>
<pre>dotnet add package BenchmarkDotNet</pre>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at the following link:</p>
<p><a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter10">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter10</a></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor143"/>Improvements with minimal APIs </h1>
<p>Minimal APIs <a id="_idIndexMarker510"/>were designed not only to improve the performance of APIs but also for better code convenience and similarity to other languages to bring developers from other platforms closer. Performance has increased both from the point of view of the .NET framework, as each version has incredible improvements, as well as from the point of view of the simplification of the application pipeline. Let’s see in detail what has not been ported and what improves the performance of this framework.</p>
<p>The minimal APIs execution pipeline omits the following features, which makes the framework lighter:</p>
<ul>
<li>Filters, such as <code>IAsyncAuthorizationFilter</code>, <code>IAsyncActionFilter</code>, <code>IAsyncExceptionFilter</code>, <code>IAsyncResultFilter</code>, and <code>IasyncResourceFilter</code></li>
<li>Model binding</li>
<li>Binding for forms, such as <code>IFormFile</code></li>
<li>Built-in validation</li>
<li>Formatters</li>
<li>Content negotiations</li>
<li>Some middleware</li>
<li>View rendering</li>
<li>JsonPatch</li>
<li>OData</li>
<li>API versioning</li>
</ul>
<p class="callout-heading">Performance Improvements in .NET 6</p>
<p class="callout">Version after version, .NET improves its performance. In the latest version of the framework, improvements made over previous versions have been reported. Here’s where you can find a complete summary of what’s new in .NET 6:</p>
<p class="callout"><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/">https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/</a> </p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor144"/>Exploring performance with load tests</h1>
<p>How to estimate<a id="_idIndexMarker511"/> the performance of minimal APIs? There are many points of view to consider and in this chapter, we will try to address them from the point of view of the load they can support. We decided to adopt a tool – k6 – that performs load tests on a web application and tells us how many requests per second can a minimal API handle. </p>
<p>As described by its creators, k6 is an open source load testing tool that makes performance testing easy and productive for engineering teams. The tool is free, developer-centric, and extensible. Using k6, you can test the reliability and performance of your systems and catch performance regressions and problems earlier. This tool will help you to build resilient and performant applications that scale.</p>
<p>In our case, we would like to use the tool for performance evaluation and not for load testing. Many parameters should be considered during load testing, but we will only focus on the <code>http_reqs</code> index, which indicates how many requests have been handled correctly by the system.</p>
<p>We agree with the creators of k6 about the purpose of our test, namely <em class="italic">performance</em> and <em class="italic">synthetic monitoring</em>.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>Use cases</h2>
<p>k6 users are<a id="_idIndexMarker512"/> typically developers, QA engineers, SDETs, and SREs. They use k6 for testing the performance and reliability of APIs, microservices, and websites. Common k6 use cases include the following:</p>
<ul>
<li><strong class="bold">Load testing</strong>: k6 is optimized for minimal resource consumption and designed for running high load tests (spike, stress, and soak tests).</li>
<li><strong class="bold">Performance and synthetic monitoring</strong>: With k6, you can run tests with a small load to continuously validate the performance and availability of your production environment.</li>
<li><strong class="bold">Chaos and reliability testing</strong>: k6 provides an extensible architecture. You can use k6 to simulate traffic as part of your chaos experiments or trigger them from your k6 tests.</li>
</ul>
<p>However, we have to make several assumptions if we want to evaluate the application from the point of view just described. When a load test is performed, it is usually much more complex than the ones we will perform in this section. When an application is bombarded with requests, not all of them will be successful. We can say that the test passed successfully if a very small percentage of the responses failed. In particular, we usually consider 95 or 98 percentiles of outcomes as the statistic on which to derive the test numbers.</p>
<p>With this background, we can perform stepwise load testing as follows: in ramp up, the system will be concerned with running the <strong class="bold">virtual user</strong> (<strong class="bold">VU</strong>) load from 0 to 50 for about 15 seconds. Then, we will keep the number of users stable for 60 seconds, and finally, ramp down the load to zero virtual users for another 15 seconds.</p>
<p>Each newly written stage of the test is expressed in the JavaScript file in the <em class="italic">stages</em> section. Testing is therefore conducted under a simple empirical evaluation.</p>
<p>First, we create three types of responses, both for the ASP.NET Web API and minimal API:</p>
<ul>
<li><em class="italic">Plain-text</em>.</li>
<li>Very small <em class="italic">JSON</em> data against a call – the data is static and always the same.</li>
<li>In the third response, we send JSON data with an HTTP <code>POST</code> method to the API. For the Web API, we check the <em class="italic">validation</em> of the object, and for the minimal API, since there is no validation, we return the object as received.</li>
</ul>
<p>The following code will be used to compare the performance between the minimal API and the traditional <a id="_idIndexMarker513"/>approach:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Minimal API</p>
<pre class="source-code">
app.MapGet("text-plain",() =&gt; Results.Content("response"))
.WithName("GetTextPlain");
app.MapPost("validations",(ValidationData validation) =&gt; Results.Ok(validation)).WithName("PostValidationData");
app.MapGet("jsons", () =&gt;
     {
           var response = new[]
           {
                new PersonData { Name = "Andrea", Surname = 
                "Tosato", BirthDate = new DateTime
                (2022, 01, 01) },
                new PersonData { Name = "Emanuele", 
                Surname = "Bartolesi", BirthDate = new 
                DateTime(2022, 01, 01) },
                new PersonData { Name = "Marco", Surname = 
                "Minerva", BirthDate = new DateTime
                (2022, 01, 01) }
           };
           return Results.Ok(response);
     })
.WithName("GetJsonData");</pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Traditional Approach</p>
<p>For the traditional <a id="_idIndexMarker514"/>approach, three distinct controllers have been designed as shown here:</p>
<pre class="source-code">
[Route("text-plain")]
     [ApiController]
     public class TextPlainController : ControllerBase
     {
           [HttpGet]
           public IActionResult Get()
           {
                 return Content("response");
           }
     }
[Route("validations")]
     [ApiController]
     public class ValidationsController : ControllerBase
     {
           [HttpPost]
           public IActionResult Post(ValidationData data)
           {
                 return Ok(data);
           }
     }
     public class ValidationData
     {
           [Required]
           public int Id { get; set; }
           [Required]
           [StringLength(100)]
           public string Description { get; set; }
     }
[Route("jsons")]
[ApiController]
public class JsonsController : ControllerBase
{
     [HttpGet]
     public IActionResult Get()
     {
           var response = new[]
           {
              new PersonData { Name = "Andrea", Surname = 
              "Tosato", BirthDate = new 
              DateTime(2022, 01, 01) },
              new PersonData { Name = "Emanuele", Surname = 
              "Bartolesi", BirthDate = new 
              DateTime(2022, 01, 01) },
              new PersonData { Name = "Marco", Surname = 
              "Minerva", BirthDate = new 
              DateTime(2022, 01, 01) }
            };
            return Ok(response);
     }
}
     public class PersonData
     {
           public string Name { get; set; }
           public string Surname { get; set; }
           public DateTime BirthDate { get; set; }
     }</pre>
<p>In the next section, we <a id="_idIndexMarker515"/>will define an <code>options</code> object, where we are going to define the execution ramp described here. We define all clauses to consider the test satisfied. As the last step, we write the real test, which does nothing but call the HTTP endpoint using <code>GET</code> or <code>POST</code>, depending on the test.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>Writing k6 tests</h2>
<p>Let’s create a test <a id="_idIndexMarker516"/>for each case <a id="_idIndexMarker517"/>scenario that we described in the previous section:</p>
<pre class="source-code">
import http from "k6/http";
import { check } from "k6";
export let options = {
     summaryTrendStats: ["avg", "p(95)"],
     stages: [
           // Linearly ramp up from 1 to 50 VUs during 10 
              seconds
              { target: 50, duration: "10s" },
           // Hold at 50 VUs for the next 1 minute
              { target: 50, duration: "1m" },
           // Linearly ramp down from 50 to 0 VUs over the 
              last 15 seconds
              { target: 0, duration: "15s" }
     ],
     thresholds: {
           // We want the 95th percentile of all HTTP 
              request durations to be less than 500ms
              "http_req_duration": ["p(95)&lt;500"],
           // Thresholds based on the custom metric we 
              defined and use to track application failures
              "check_failure_rate": [
          // Global failure rate should be less than 1%
             "rate&lt;0.01",
          // Abort the test early if it climbs over 5%
             { threshold: "rate&lt;=0.05", abortOnFail: true },
           ],
     },
};
export default function () {
    // execute http get call
    let response = http.get("http://localhost:7060/jsons");
    // check() returns false if any of the specified 
       conditions fail
    check(response, {
           "status is 200": (r) =&gt; r.status === 200,
    });
}</pre>
<p>In the preceding <a id="_idIndexMarker518"/>JavaScript file, we <a id="_idIndexMarker519"/>wrote the test using k6 syntax. We have defined the options, such as the evaluation threshold of the test, the parameters to be measured, and the stages that the test should simulate. Once we have defined the options of the test, we just have to write the code to call the APIs that interest us – in our case, we have defined three tests to call<a id="_idIndexMarker520"/> the<a id="_idIndexMarker521"/> three endpoints that we want to evaluate.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>Running a k6 performance test</h2>
<p>Now that we <a id="_idIndexMarker522"/>have<a id="_idIndexMarker523"/> written the code to test the performance, let’s run the test and generate the statistics of the tests.</p>
<p>We will report all the general statistics of the collected tests:</p>
<ol>
<li>First, we need to start the web applications to run the load test. Let’s start with both the ASP.NET Web API application and the minimal API application. We expose the URLs, both the HTTPS and HTTP protocols. </li>
<li>Move the shell to the root folder and run the following two commands in two different shells:<pre><strong class="bold">dotnet .\MinimalAPI.Sample\bin\Release\net6.0\MinimalAPI.Sample.dll --urls=https://localhost:7059/;http://localhost:7060/</strong>
<strong class="bold">dotnet .\ControllerAPI.Sample\bin\Release\net6.0\ControllerAPI.Sample.dll --urls="https://localhost:7149/;http://localhost:7150/"</strong></pre></li>
<li>Now, we just have to run the three test files for each project. <ul><li>This one is for the controller-based Web API:<pre><strong class="bold">k6 run .\K6\Controllers\json.js --summary-export=.\K6\results\controller-json.json</strong></pre></li><li>This one is for the minimal API:<pre><strong class="bold">k6 run .\K6\Minimal\json.js --summary-export=.\K6\results\minimal-json.json</strong></pre></li></ul></li>
</ol>
<p>Here are the results.</p>
<p>For the test in traditional development mode with a <code>plain-text</code> content type, the number of requests served per second is 1,547:</p>
<div><div><img alt="Figure 10.1 – The load test for a controller-based API and plain text " height="886" src="img/Figure_10.1_B17902.jpg" width="1102"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The load test for a controller-based API and plain text</p>
<p>For the test in<a id="_idIndexMarker524"/> traditional <a id="_idIndexMarker525"/>development mode with a <code>json</code> content type, the number of requests served per second is 1,614:</p>
<div><div><img alt="Figure 10.2 – The load test for a controller-based API and JSON result " height="879" src="img/Figure_10.2_B17902.jpg" width="1090"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The load test for a controller-based API and JSON result</p>
<p>For the test in<a id="_idIndexMarker526"/> traditional <a id="_idIndexMarker527"/>development mode with a <code>json</code> content type and model validation, the number of requests served per second is 1,602:</p>
<div><div><img alt="Figure 10.3 – The load test for a controller-based API and validation payload " height="918" src="img/Figure_10.3_B17902.jpg" width="1113"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – The load test for a controller-based API and validation payload</p>
<p>For the test in<a id="_idIndexMarker528"/> minimal <a id="_idIndexMarker529"/>API development mode with a <code>plain-text</code> content type, the number of requests served per second is 2,285:</p>
<div><div><img alt="Figure 10.4 – The load test for a minimal API and plain text " height="885" src="img/Figure_10.4_B17902.jpg" width="1096"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – The load test for a minimal API and plain text</p>
<p>For the test<a id="_idIndexMarker530"/> in<a id="_idIndexMarker531"/> minimal API development mode with a <code>json</code> content type, the number of requests served per second is 2,030:</p>
<div><div><img alt="Figure 10.5 – The load test for a minimal API and JSON result " height="882" src="img/Figure_10.5_B17902.jpg" width="1115"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – The load test for a minimal API and JSON result</p>
<p>For the test <a id="_idIndexMarker532"/>in <a id="_idIndexMarker533"/>minimal API development mode with a <code>json</code> content type with model validation, the number of requests served per second is 2,070:</p>
<div><div><img alt="Figure 10.6 – The load test for a minimal API and no validation payload " height="905" src="img/Figure_10.6_B17902.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – The load test for a minimal API and no validation payload</p>
<p>In the following image, we show a comparison of the three tested functionalities, reporting the number of requests served with the same functionality:</p>
<div><div><img alt="Figure 10.7 – The performance results " height="507" src="img/Figure_10.7_B17902.jpg" width="752"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – The performance results</p>
<p>As we might have<a id="_idIndexMarker534"/> expected, minimal <a id="_idIndexMarker535"/>APIs are much faster than controller-based web APIs.</p>
<p>The difference is approximately 30%, and that’s no small feat. </p>
<p>Obviously, as previously mentioned, minimal APIs have features missing in order to optimize performance, the most striking being data validation.</p>
<p>In the example, the payload is very small, and the differences are not very noticeable.</p>
<p>As the payload and validation rules grow, the difference in speed between the two frameworks will only increase.</p>
<p>We have seen how to<a id="_idIndexMarker536"/> measure <a id="_idIndexMarker537"/>performance with a load testing tool and then evaluate how many requests it can serve per second with the same number of machines and users connected.</p>
<p>We can also use other tools to understand how minimal APIs have had a strong positive impact on performance.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/>Benchmarking minimal APIs with BenchmarkDotNet</h1>
<p>BenchmarkDotNet<a id="_idIndexMarker538"/> is a framework <a id="_idIndexMarker539"/>that allows you to measure written code and compare performance between libraries written in different versions or compiled with different .NET frameworks.</p>
<p>This tool is used for calculating the time taken for the execution of a task, the memory used, and many other parameters.</p>
<p>Our case is a very simple scenario. We want to compare the response times of two applications written to the same version of the .NET Framework.</p>
<p>How do we perform this comparison? We take an <code>HttpClient</code> object and start calling the methods that we have also defined for the load testing case.</p>
<p>We will therefore obtain a comparison between two methods that exploit the same <code>HttpClient</code> object and recall methods with the same functionality, but one is written with the ASP.NET Web API and the traditional controllers, while the other is written using minimal APIs.</p>
<p>BenchmarkDotNet helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. </p>
<p>Under the hood, it performs a lot of magic that guarantees reliable and precise results thanks to the perfolizer statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or <a id="_idIndexMarker540"/>obtained <a id="_idIndexMarker541"/>measurements. The library has been adopted by over 6,800 projects, including .NET Runtime, and is supported by the .NET Foundation (<a href="https://benchmarkdotnet.org/">https://benchmarkdotnet.org/</a>).</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor149"/>Running BenchmarkDotNet</h2>
<p>We will write a class that <a id="_idIndexMarker542"/>represents all the methods for calling the APIs of the two web applications. Let’s make the most of the startup feature and prepare the objects we will send via <code>POST</code>. The function marked as <code>[GlobalSetup]</code> is not computed during runtime, and this helps us calculate exactly how long it takes between the call and the response from the web application:</p>
<ol>
<li value="1">Register all the classes in <code>Program.cs</code> that implement BenchmarkDotNet:<pre>BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);</pre></li>
</ol>
<p>In the preceding snippet, we have registered the current assembly that implements all the functions that will be needed to be evaluated in the performance calculation. The methods marked with <code>[Benchmark]</code> will be executed over and over again to establish the average execution time.</p>
<ol>
<li value="2">The application<a id="_idIndexMarker543"/> must be compiled on release and possibly within the production environment:<pre>namespace DotNetBenchmarkRunners
{
     [SimpleJob(RuntimeMoniker.Net60, baseline: true)]
     [JsonExporter]
     public class Performances
     {
           private readonly HttpClient clientMinimal = 
           new HttpClient();
           private readonly HttpClient 
           clientControllers = new HttpClient();
           private readonly ValidationData data = new 
           ValidationData()
           {
                 Id = 1,
                 Description = "Performance"
           };
           [GlobalSetup]
           public void Setup()
           {
                 clientMinimal.BaseAddress = new 
                 Uri("https://localhost:7059");
                 clientControllers.BaseAddress = new 
                 Uri("https://localhost:7149");
           }
           [Benchmark]
           public async Task Minimal_Json_Get() =&gt; 
           await clientMinimal.GetAsync("/jsons");
           [Benchmark]
           public async Task Controller_Json_Get() =&gt; 
           await clientControllers.GetAsync("/jsons");
           [Benchmark]
           public async Task Minimal_TextPlain_Get() 
           =&gt; await clientMinimal.
           GetAsync("/text-plain");
           [Benchmark]
           public async Task 
           Controller_TextPlain_Get() =&gt; await 
           clientControllers.GetAsync("/text-plain");
           
           [Benchmark]
           public async Task Minimal_Validation_Post() 
           =&gt; await clientMinimal.
           PostAsJsonAsync("/validations", data);
           
           [Benchmark]
           public async Task 
           Controller_Validation_Post() =&gt; await 
           clientControllers.
           PostAsJsonAsync("/validations", data);
     }
     public class ValidationData
     {
           public int Id { get; set; }
           public string Description { get; set; }
     }
}</pre></li>
<li>Before launching<a id="_idIndexMarker544"/> the benchmark application, launch the web applications:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Minimal API application</p>
<pre><strong class="bold">dotnet .\MinimalAPI.Sample\bin\Release\net6.0\MinimalAPI.Sample.dll --urls="https://localhost:7059/;http://localhost:7060/"</strong></pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Controller-based application</p>
<pre><strong class="bold">dotnet .\ControllerAPI.Sample\bin\Release\net6.0\ControllerAPI.Sample.dll --urls=https://localhost:7149/;http://localhost:7150/</strong></pre>
<p>By launching these applications, various steps will be performed and a summary report will be extracted with the timelines that we report here:</p>
<pre><strong class="bold">dotnet .\DotNetBenchmarkRunners\bin\Release\net6.0\DotNetBenchmarkRunners.dll --filter *</strong></pre>
<p>For each method performed, the average value or the average execution <a id="_idIndexMarker545"/>time is reported.</p>
<div><div><img alt="Table 10.1 – Benchmark HTTP requests for minimal APIs and controllers " height="400" src="img/B17902_10_Table1.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 – Benchmark HTTP requests for minimal APIs and controllers</p>
<p>In the following table, <strong class="bold">Error</strong> denotes how much the average value may vary due to a measurement error. Finally, the standard deviation (<strong class="bold">StdDev</strong>) indicates the deviation from the mean value. The times are given in <strong class="bold">μs</strong> and are therefore very small to measure empirically if not with instruments with that just exposed.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor150"/>Summary</h1>
<p>In the chapter, we compared the performance of minimal APIs with that of the traditional approach by using two very different methods.</p>
<p>Minimal APIs were not designed for performance alone and evaluating them solely on that basis is a poor starting point.</p>
<p><em class="italic">Table 10.1</em> indicates that there are a lot of differences between the responses of minimal APIs and that of traditional ASP.NET Web API applications.</p>
<p>The tests were conducted on the same machine with the same resources. We found that minimal APIs performed about 30% better than the traditional framework.</p>
<p>We have learned about how to measure the speed of our applications – this can be useful for understanding whether the application will hold the load and what response time it can offer. We can also leverage this on small portions of critical code.</p>
<p>As a final note, the applications tested were practically bare bones. The validation part that should be evaluated in the ASP.NET Web API application is almost irrelevant since there are only two fields to consider. The gap between the two frameworks increases as the number of components that have been eliminated in the minimal APIs that we have already described increases.</p>
</div>
</div></body></html>