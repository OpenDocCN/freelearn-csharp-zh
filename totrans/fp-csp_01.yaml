- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with Functional Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程入门
- en: Functional programming is a way of thinking about software based on treating
    computation as the evaluation of mathematical functions. It avoids changing state
    and mutable data, focusing instead on pure functions, immutability, and composing
    functions to solve complex problems. By sticking to these principles, functional
    programming creates code that is more predictable, easier to understand, and less
    prone to bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种基于将计算视为数学函数评估的方式来思考软件的方法。它避免改变状态和可变数据，而是专注于纯函数、不可变性和通过组合函数来解决复杂问题。通过坚持这些原则，函数式编程创建的代码更具可预测性、更容易理解，并且更不容易出错。
- en: 'But why should you consider adopting functional programming in your projects?
    The benefits are many, including the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么你应该考虑在你的项目中采用函数式编程呢？好处很多，包括以下内容：
- en: '**Increased readability and maintainability**: Functional code is often more
    concise and expressive, making it easier to read and maintain. By focusing on
    what needs to be done rather than how to do it, functional programming promotes
    clearer and more readable code.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高的可读性和可维护性**：函数式代码通常更简洁、更易于表达，这使得它更容易阅读和维护。通过关注需要做什么而不是如何做，函数式编程促进了更清晰、更易于阅读的代码。'
- en: '**Enhanced testability**: Pure functions always produce the same output for
    a given input and have no side effects, making them easier to test. This leads
    to more comprehensive and reliable unit testing, resulting in higher code quality
    and fewer bugs.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的可测试性**：纯函数对于给定的输入总是产生相同的输出，并且没有副作用，这使得它们更容易测试。这导致更全面和可靠的单元测试，从而提高代码质量并减少错误。'
- en: '**Improved concurrency and parallelism**: The emphasis on immutability and
    avoiding shared state in functional programming makes it well suited for concurrent
    and parallel processing. It reduces the risks associated with race conditions
    and allows safer and more efficient use of multi-core processors.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的并发性和并行性**：函数式编程中强调不可变性和避免共享状态，这使得它非常适合并发和并行处理。它减少了与竞态条件相关的风险，并允许更安全、更有效地使用多核处理器。'
- en: '**Reusability and composability**: Functional programming encourages the creation
    of small, focused functions that can be easily combined and reused throughout
    the code base. This promotes code reuse, modularity, and the ability to build
    complex systems from simple building blocks.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性和可组合性**：函数式编程鼓励创建小型、专注的函数，这些函数可以轻松地在整个代码库中组合和重用。这促进了代码重用、模块化，并能够从简单的构建块构建复杂系统。'
- en: As we progress through this book, we’ll explore these benefits in greater detail,
    making it more compelling to use functional programming in your projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在这本书中的进展，我们将更详细地探讨这些好处，使你在项目中使用函数式编程更具吸引力。
- en: Functional versus imperative versus object-oriented programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程与命令式编程和面向对象编程的比较
- en: To fully appreciate the power of functional programming, it’s essential to understand
    how it differs from other paradigms, such as imperative and object-oriented programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分欣赏函数式编程的力量，了解它与其他范式（如命令式和面向对象编程）的不同是至关重要的。
- en: Imperative programming
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式编程
- en: Imperative programming is the traditional approach in many languages. It focuses
    on explicitly specifying the sequence of steps to solve a problem. This style
    relies heavily on mutable state and side effects, which can make code more prone
    to bugs and harder to understand as the code base grows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程是许多语言中的传统方法。它侧重于明确指定解决问题的步骤顺序。这种风格严重依赖于可变状态和副作用，这可能导致代码更容易出错，并且随着代码库的增长，更难理解。
- en: Object-oriented programming
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**Object-oriented programming** (**OOP**) organizes code around objects, which
    encapsulate data and behavior. OOP is great for modeling real-world entities and
    promoting encapsulation. However, it can sometimes lead to complex hierarchies
    and tight coupling between objects, making code harder to modify and test.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）将代码组织在对象周围，这些对象封装了数据和行为。面向对象编程非常适合模拟现实世界实体并促进封装。然而，它有时会导致复杂的层次结构和对象之间的紧密耦合，使得代码更难修改和测试。'
- en: Functional programming
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional programming, in contrast, emphasizes pure functions and immutable
    data. It treats computation as the evaluation of expressions rather than a sequence
    of state changes. By minimizing side effects and focusing on the input-output
    relationship of functions, functional programming enables more declarative and
    composable code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，函数式编程强调纯函数和不可变数据。它将计算视为表达式的评估，而不是状态变化的序列。通过最小化副作用并关注函数的输入输出关系，函数式编程使得代码更加声明式和可组合。
- en: Blending paradigms
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合范式
- en: It’s important to note that these paradigms are not mutually exclusive. Modern
    programming languages such as C# support a mix of imperative, object-oriented,
    and functional programming styles. The key is to understand the strengths and
    weaknesses of each paradigm and apply them wisely based on the problem at hand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些范式不是相互排斥的。现代编程语言，如C#，支持命令式、面向对象和函数式编程风格的混合。关键是理解每个范式的优势和劣势，并根据手头的实际问题明智地应用它们。
- en: How functional programming is supported in C#
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程在C#中的支持
- en: 'C# has evolved significantly over the years, incorporating a range of functional
    programming features that make it a powerful language for this paradigm. Let’s
    take a closer look at some of these features and how they support functional programming:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C#在多年中经历了显著的发展，吸收了一系列函数式编程特性，使其成为支持该范式的强大语言。让我们更详细地看看这些特性以及它们如何支持函数式编程：
- en: '**Lambda expressions**: These provide a concise syntax for creating anonymous
    functions, enabling easy creation of higher-order functions'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda表达式**：这些提供了创建匿名函数的简洁语法，使得创建高阶函数变得容易。'
- en: '**LINQ**: This provides a set of extension methods that enable functional-style
    operations such as filtering, mapping, and reducing collections'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ**：这提供了一套扩展方法，使得可以进行如过滤、映射和归约集合等函数式操作。'
- en: '**Immutable data types**: Data types such as strings and tuples guarantee that
    once created, their values cannot be changed'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变数据类型**：如字符串和元组这样的数据类型保证一旦创建，它们的值就不能改变。'
- en: '**Pattern matching**: This allows us to test values against patterns and extract
    data based on those patterns'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式匹配**：这允许我们根据模式测试值并基于这些模式提取数据。'
- en: '**Delegates and events**: These allow you to treat functions as first-class
    citizens, passing them as arguments and storing them in variables'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托和事件**：这些允许你将函数视为一等公民，将它们作为参数传递并存储在变量中。'
- en: Throughout this book, we’ll explore how to utilize these features to write code
    in a functional approach. Let’s look at what I mean by a functional approach next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将探讨如何利用这些特性以函数式方法编写代码。接下来，让我们看看我所说的函数式方法是什么意思。
- en: How to write functional code in C#
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在C#中编写函数式代码
- en: 'Writing functional code in C# means the implementation of functional concepts
    and techniques that will help us write functional code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中编写函数式代码意味着实现有助于我们编写函数式代码的概念和技术：
- en: '**Expressions**: By favoring expressions over statements, we can write more
    declarative code that focuses on the desired result rather than the steps to achieve
    it.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式**：通过优先考虑表达式而不是语句，我们可以编写更多关注预期结果的声明式代码，而不是实现它的步骤。'
- en: '**Pure functions**: A pure function always produces the same output for a given
    input and has no side effects. It relies solely on its input parameters and does
    not modify any external state. Using pure functions, we can create easier code
    to reason about, test, and parallelize.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：纯函数对于给定的输入总是产生相同的输出，并且没有副作用。它仅依赖于其输入参数，不修改任何外部状态。使用纯函数，我们可以创建更容易推理、测试和并行化的代码。'
- en: '**Honest functions**: Honest functions are an extension of pure functions that
    provide a clear and unambiguous contract. They explicitly communicate their input
    requirements and potential output scenarios, including error cases. Honest functions
    enhance code readability, maintainability, and error handling.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诚实函数**：诚实函数是纯函数的扩展，提供了清晰且无歧义的契约。它们明确传达其输入要求以及可能的输出场景，包括错误情况。诚实函数增强了代码的可读性、可维护性和错误处理。'
- en: '**Higher-order functions**: These functions can accept other functions as arguments
    or return functions as results. They enable powerful abstractions and allow you
    to create reusable and composable code.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶函数**：这些函数可以接受其他函数作为参数或返回函数作为结果。它们允许强大的抽象，并允许你创建可重用和可组合的代码。'
- en: '**Functors and monads**: Functors and monads are abstractions that help you
    manage and compose computations in a functional way. A functor is a type that
    defines a mapping operation, allowing you to apply a function to the values inside
    the functor while preserving its structure. Monads, on the other hand, provide
    a way to chain computations together, handling complexities such as error propagation
    and state management.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函子和单子**：函子和单子是帮助你以函数式方式管理和组合计算的抽象。函子是一种类型，它定义了一个映射操作，允许你在保留其结构的同时将函数应用于函子内的值。另一方面，单子提供了一种将计算链式连接起来的方法，处理诸如错误传播和状态管理之类的复杂性。'
- en: Don’t worry if any of these concepts and techniques are not familiar to you.
    Throughout this book, we’ll explore them in detail and use practical coding examples
    to help you understand how to use them in your code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些概念和技术对你来说不熟悉，请不要担心。在这本书的整个过程中，我们将详细探讨它们，并使用实际的编码示例来帮助你理解如何在代码中使用它们。
- en: A practical example – a book publishing system
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际例子——图书出版系统
- en: 'Let’s examine an example that demonstrates functional programming concepts
    using a book publishing system scenario:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来考察使用图书出版系统场景演示的函数式编程概念：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example demonstrates several key functional programming concepts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了几个关键函数式编程概念：
- en: '`record` for the `Book` type, which is immutable by default.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `Book` 类型定义的 `record`，默认是不可变的。
- en: '`IsValid` and `FormatBook` are pure functions. They always return the same
    output for the same input and have no side effects.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsValid` 和 `FormatBook` 是纯函数。它们对于相同的输入总是返回相同的输出，并且没有副作用。'
- en: '`ProcessBooks` is a higher-order function that takes two functions as parameters
    (a validator and a formatter).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessBooks` 是一个接受两个函数作为参数（验证器和格式化器）的更高阶函数。'
- en: '`ProcessBooks` function.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessBooks` 函数。'
- en: '**Declarative style**: We describe what we want (valid, formatted books) rather
    than how to do it step by step.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式风格**：我们描述我们想要什么（有效的、格式化的书籍），而不是如何一步一步地实现它。'
- en: '`Where` and `Select`) that align well with functional programming principles.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where` 和 `Select`）与函数式编程原则相吻合。'
- en: This example shows how functional programming can be applied to a real-world
    scenario such as a book publishing system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何将函数式编程应用于现实世界场景，例如图书出版系统。
- en: How to combine functional and object-oriented paradigms
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何结合函数式和面向对象范式
- en: 'One of the strengths of C# is its ability to seamlessly combine functional
    and object-oriented programming paradigms. By leveraging the best of both worlds,
    we can create code that is modular, reusable, and expressive. Here are some strategies
    for combining functional and object-oriented programming:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的一大优势在于其能够无缝结合函数式和面向对象编程范式。通过利用两者的最佳特性，我们可以创建模块化、可重用且表达性强的代码。以下是一些结合函数式和面向对象编程的策略：
- en: '**Immutable objects**: Immutable objects are thread-safe, easier to reason
    about, and align well with functional programming principles'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变对象**：不可变对象是线程安全的，更容易推理，并且与函数式编程原则相吻合'
- en: '**Extension methods**: These allow us to enhance the functionality of types
    without modifying their original implementation, promoting a more functional and
    compositional approach'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展方法**：这些方法允许我们在不修改原始实现的情况下增强类型的功能，从而促进更函数式和组合式的方法'
- en: '**Higher-order functions as instance methods**: This approach helps us to encapsulate
    behavior and provide a fluent and expressive API for working with objects in a
    functional manner'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为实例方法的更高阶函数**：这种方法帮助我们封装行为，并为以函数式方式处理对象提供流畅且表达性强的 API'
- en: '**Dependency injection and composition**: By injecting functional dependencies
    and composing objects based on their behavior, you can achieve a more modular
    and flexible design that aligns with functional programming principles'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入和组合**：通过注入函数式依赖并根据行为组合对象，你可以实现更模块化和灵活的设计，这与函数式编程原则相一致'
- en: These tools help us combine functional and object-oriented programming techniques,
    making our code more expressive and easier to maintain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具帮助我们结合函数式和面向对象编程技术，使我们的代码更具表达性和易于维护。
- en: Meet Steve and Julia
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识史蒂夫和朱莉娅
- en: 'To make our journey through functional programming in C# more engaging and
    relatable, let’s introduce our main characters: Steve and Julia.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们在 C# 中进行函数式编程的旅程更加引人入胜和贴近实际，让我们介绍我们的主要角色：史蒂夫和朱莉娅。
- en: Steve is a middle-level C# software developer who has heard that functional
    programming can help him write better code, become more valuable at his current
    job, and gain an advantage over other candidates if he decides to pursue a new
    opportunity. He’s eager to learn but unsure where to start.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫是一位中级C#软件开发者，他听说函数式编程可以帮助他编写更好的代码，在当前工作中更有价值，如果他决定追求新的机会，还能在求职者中占据优势。他渴望学习，但不确定从何开始。
- en: Julia, on the other hand, is already an expert in functional programming in
    C#. She’s passionate about the paradigm and enjoys sharing her knowledge with
    others. Throughout the book, Julia will provide Steve with advice, guidance, and
    practical examples to help him master functional programming concepts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，朱莉娅已经是C#函数式编程的专家。她对这种范式充满热情，并乐于与他人分享她的知识。在整个书中，朱莉娅将为史蒂夫提供建议、指导和实际示例，帮助他掌握函数式编程概念。
- en: As we progress through the chapters, we’ll follow Steve’s journey as he learns
    from Julia and applies functional programming techniques to real-world scenarios.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐步进入章节，我们将跟随史蒂夫的旅程，看他如何从朱莉娅那里学习，并将函数式编程技术应用于现实世界的场景中。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on taking the first step toward mastering functional programming
    in C#! In this chapter, we’ve explored the differences between functional, imperative,
    and object-oriented programming paradigms. We’ve also delved into the functional
    features of C#, such as lambda expressions, LINQ, immutable data types, pattern
    matching, and delegates, and how they support functional programming.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你迈出了掌握C#函数式编程的第一步！在本章中，我们探讨了函数式、命令式和面向对象编程范式的区别。我们还深入研究了C#的函数式特性，例如lambda表达式、LINQ、不可变数据类型、模式匹配和委托，以及它们如何支持函数式编程。
- en: Furthermore, we’ve introduced the concepts and techniques for writing functional
    code in C# such as expressions, pure functions, honest functions, higher-order
    functions, functors, and monads. Finally, we’ve discussed strategies for combining
    functional and object-oriented programming in C#, allowing us to leverage the
    best of both paradigms in our projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了在C#中编写函数式代码的概念和技术，例如表达式、纯函数、诚实函数、高阶函数、函子以及单子。最后，我们讨论了在C#中将函数式编程和面向对象编程相结合的策略，使我们能够在项目中充分利用这两种范式的优点。
- en: As we progress through the next chapters, we’ll dive deeper into each of these
    concepts, learning how to write cleaner, more modular, and more testable code
    using functional principles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续阅读下一章，我们将更深入地探讨这些概念，学习如何使用函数式原则编写更干净、更模块化、更易于测试的代码。
- en: Let’s get started!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
