<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Surface Shaders and Texture Mapping</h1>
                
            
            
                
<p class="calibre3">In this chapter, we will explore the topic of Surface Shaders in greater detail than in the previous chapter. We will start from building a very simple matte material and end with holographic projections and the advanced blending of terrains. We will also see how you can use textures to animate, blend, and drive any other property that they like.</p>
<p class="calibre3">In this chapter, you will learn about the following methods:</p>
<ul class="calibre11">
<li class="calibre12">Diffuse shading</li>
<li class="calibre12">Accessing and modifying packed arrays</li>
<li class="calibre12">Adding a texture to a shader</li>
<li class="calibre12">Scrolling textures by modifying UV values</li>
<li class="calibre12">Creating a shader with normal mapping</li>
<li class="calibre12">Creating a transparent material</li>
<li class="calibre12">Creating a Holographic Shader</li>
<li class="calibre12">Packing and blending textures</li>
<li class="calibre12">Creating a circle around your terrain</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            
                
<p class="calibre3">Surface Shaders were introduced in <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 2</a>, <em class="calibre14">Creating Your First Shader</em>, as the main type of shader that's used in Unity. This chapter will show you in detail what these actually are and how they work. Generally speaking, there are two essential steps in every Surface Shader. First, you have to specify certain physical properties of the material that you want to describe, such as its diffuse color, smoothness, and transparency. These properties are initialized in a function called the <strong class="calibre5">surface function</strong> and are stored in a structure called the <kbd class="calibre13">SurfaceOutput</kbd>. Secondly, the <kbd class="calibre13">SurfaceOutput</kbd> is passed to a lighting model. This is a special function that will also take information about the nearby lights in the scene. Both of these parameters are then used to calculate the final color for each pixel of your model. The lighting function is where the real calculations of a shader take place as it's the piece of code that determines how light should behave when it touches a material.</p>
<p class="calibre3">The following diagram loosely summarizes how a Surface Shader works. Custom lighting models will be explored in <a href="part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 4</a>, <em class="calibre14">Understanding Lighting Models</em>, while <a href="part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 6</a>, <em class="calibre14">Vertex Functions</em>, will focus on vertex modifiers:</p>
<div><img src="img/00040.jpeg" class="calibre51"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Diffuse shading</h1>
                
            
            
                
<p class="calibre3">Before starting our journey into texture mapping, it is important to understand how diffuse materials work. Certain objects might have a uniform color and smooth surface, but are not smooth enough to shine in reflected light. These matte materials are best represented with a Diffuse Shader. While, in the real world pure diffuse materials do not exist, Diffuse Shaders are relatively cheap to implement and are largely applied in games with low-poly aesthetics, so they're worth learning about.</p>
<p class="calibre3">There are several ways in which you can create your own Diffuse Shader. A quick way is to start with Unity's Standard Surface Shader and edit it to remove any additional texture information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Before starting this recipe, you should have created a Standard Surface Shader with the name <kbd class="calibre13">SimpleDiffuse</kbd>. For instructions on creating a Standard Surface Shader, look at the <em class="calibre14">Creating a basic Standard Surface Shader</em> recipe located in  <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 2</a>, <em class="calibre14">Creating Your First Shader, </em>if you haven't done so already.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">Open up the <kbd class="calibre13">SimpleDiffuse</kbd> shader you've created and make the following changes: </p>
<ol class="calibre15">
<li value="1" class="calibre12">In the <kbd class="calibre13">Properties</kbd> section, remove all of the variables except for  <kbd class="calibre13">_Color</kbd>:</li>
</ol>
<pre class="calibre18">  Properties <br class="title-page-name"/>  {<br class="title-page-name"/>    _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/>  }</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">From the <kbd class="calibre13">SubShader{}</kbd> section, remove the <kbd class="calibre13">_MainTex</kbd>, <kbd class="calibre13">_Glossiness</kbd>, and <kbd class="calibre13">_Metallic</kbd> variables. You should not remove the reference to <kbd class="calibre13">uv_MainTex</kbd> as Cg does not allow the <kbd class="calibre13">Input</kbd> struct to be empty. The value will simply be ignored.</li>
<li value="3" class="calibre12">Also, remove the <kbd class="calibre13">UNITY_INSTANCING_BUFFER_START/END</kbd> macros and the comments used with them.</li>
</ol>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Remove the content of the <kbd class="calibre13">surf()</kbd> function and replace it with the following:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutputStandard o) <br class="title-page-name"/>{<br class="title-page-name"/>  o.Albedo = _Color.rgb; <br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Your shader should look as follows:</li>
</ol>
<pre class="calibre18">Shader "CookbookShaders/Chapter03/SimpleDiffuse" {<br class="title-page-name"/>  Properties <br class="title-page-name"/>  {<br class="title-page-name"/>    _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/>  }<br class="title-page-name"/>  SubShader <br class="title-page-name"/>  {<br class="title-page-name"/>    Tags { "RenderType"="Opaque" }<br class="title-page-name"/>    LOD 200<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    // Physically based Standard lighting model, and enable shadows on all light types<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows<br class="title-page-name"/><br class="title-page-name"/>    // Use shader model 3.0 target, to get nicer looking lighting<br class="title-page-name"/>    #pragma target 3.0<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    struct Input <br class="title-page-name"/>    {<br class="title-page-name"/>      float2 uv_MainTex;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    fixed4 _Color;<br class="title-page-name"/><br class="title-page-name"/>    void surf (Input IN, inout SurfaceOutputStandard o) <br class="title-page-name"/>    {<br class="title-page-name"/>      o.Albedo = _Color.rgb; <br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    ENDCG<br class="title-page-name"/>  }<br class="title-page-name"/>  FallBack "Diffuse"<br class="title-page-name"/>}</pre>
<p>The two lines below <kbd class="calibre37">CGPROGRAM</kbd> is actually one line and is cut off due to the size of the book.</p>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">As this shader has been refitted with a Standard Shader, it will use physically-based rendering to simulate how light behaves on your models.</li>
</ol>
<p>If you are trying to achieve a non-photorealistic look, you can change the first <kbd class="calibre37">#pragma</kbd> directive so that it uses <kbd class="calibre37">Lambert</kbd> rather than <kbd class="calibre37">Standard</kbd>. If you do so, you should also replace the  <kbd class="calibre37">SurfaceOutputStandard</kbd> parameter of the <kbd class="calibre37">surf</kbd> function with <kbd class="calibre37">SurfaceOutput</kbd>. For more information on this and the other lighting models that Unity supports, Jordan Stevens put together a very nice article about it, which you can see here: <a href="http://www.jordanstevenstechart.com/lighting-models" class="calibre31">http://www.jordanstevenstechart.com/lighting-models</a></p>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Save the shader and dive back into Unity. Using the same instructions as in the <em class="calibre2">Creating a basic Standard Surface Shader</em> recipe located in  <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 2</a>, <em class="calibre2">Creating Your First Shader,</em> create a new material called <kbd class="calibre13">SimpleDiffuseMat</kbd> and apply our newly created shader to it. Change the color to something different, such as red, by clicking on the window next to the Color property in the Inspector window while selected.</li>
<li value="8" class="calibre12">Then, go into the <kbd class="calibre13">Models</kbd> folder of this book's example code and bring the bunny object into our scene by dragging and dropping it from the Project window into the Hierarchy window. From there, assign the <kbd class="calibre13">SimpleDiffuseMat</kbd> material to the object:</li>
</ol>
<div><img src="img/00041.jpeg" class="calibre52"/></div>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">You can double-click on an object in the Hierarchy tab in order to center the camera on the object that's been selected.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">The way shaders allow you to communicate the rendering properties of your material to their lighting model is via their <kbd class="calibre13">SurfaceOutput</kbd>. It is basically a wrapper around all the parameters that the current lighting model needs. It should not surprise you that different lighting models have different <kbd class="calibre13">SurfaceOutput</kbd> structs. The following table shows the three main output structs used in Unity and how they can be used:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre53">
<p class="calibre3"><strong class="calibre5">Type of shaders</strong></p>
</td>
<td class="calibre54">
<p class="calibre3"><strong class="calibre5">Standard</strong></p>
</td>
<td class="calibre55">
<p class="calibre3"><strong class="calibre5">Physically-Based Lighting Models</strong></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre53">
<p class="calibre3">Diffuse</p>
</td>
<td class="calibre54">
<p class="calibre3">Any Surface Shader</p>
<p class="calibre3"><kbd class="calibre13">SurfaceOutput</kbd></p>
</td>
<td class="calibre55">
<p class="calibre3">Standard</p>
<p class="calibre3"><kbd class="calibre13">SurfaceOutputStandard</kbd></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre53">
<p class="calibre3">Specular</p>
</td>
<td class="calibre54">
<p class="calibre3">Any Surface Shader</p>
<p class="calibre3"><kbd class="calibre13">SurfaceOutput</kbd></p>
</td>
<td class="calibre55">
<p class="calibre3">Standard (Specular setup)</p>
<p class="calibre3"><kbd class="calibre13">SurfaceOutputStandardSpecular</kbd></p>
</td>
</tr>
</tbody>
</table>
<div><p class="calibre3"> </p>
<p class="calibre3">The <kbd class="calibre13">SurfaceOutput</kbd> struct has the following properties:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">fixed3 Albedo;</kbd>: This is the diffuse color of the material</li>
<li class="calibre12"><kbd class="calibre13">fixed3 Normal;</kbd>: This is the tangent space, normal, if written</li>
<li class="calibre12"><kbd class="calibre13">fixed3 Emission;</kbd>: This is the color of the light emitted by the material (this property is declared as <kbd class="calibre13">half3</kbd> in the Standard Shaders)</li>
<li class="calibre12"><kbd class="calibre13">fixed Alpha;</kbd>: This is the transparency of the material</li>
<li class="calibre12"><kbd class="calibre13">half Specular;</kbd>: This is the specular power from <kbd class="calibre13">0</kbd> to <kbd class="calibre13">1</kbd></li>
<li class="calibre12"><kbd class="calibre13">fixed Gloss;</kbd>: This is the specular intensity</li>
</ul>
<p class="calibre3">The <kbd class="calibre13">SurfaceOutputStandard</kbd> struct has the following properties:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">fixed3 Albedo;</kbd>: This is the base color of the material (whether it's diffuse or specular)</li>
<li class="calibre12"><kbd class="calibre13">fixed3 Normal;</kbd></li>
<li class="calibre12"><kbd class="calibre13">half3 Emission;</kbd>: This property is declared as <kbd class="calibre13">half3</kbd>, while it was defined as <kbd class="calibre13">fixed3</kbd> in <kbd class="calibre13">SurfaceOutput</kbd></li>
<li class="calibre12"><kbd class="calibre13">fixed Alpha;</kbd></li>
<li class="calibre12"><kbd class="calibre13">half Occlusion;</kbd>: This is the occlusion (default <kbd class="calibre13">1</kbd>)</li>
<li class="calibre12"><kbd class="calibre13">half Smoothness;</kbd>: This is the smoothness (<kbd class="calibre13">0</kbd> = rough, <kbd class="calibre13">1</kbd> = smooth)</li>
<li class="calibre12"><kbd class="calibre13">half Metallic;</kbd>: <kbd class="calibre13">0</kbd> = non-metal, <kbd class="calibre13">1</kbd>= metal</li>
</ul>
<p class="calibre3">The <kbd class="calibre13">SurfaceOutputStandardSpecular</kbd> struct has the following properties:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">fixed3 Albedo;</kbd></li>
<li class="calibre12"><kbd class="calibre13">fixed3 Normal;</kbd></li>
<li class="calibre12"><kbd class="calibre13">half3 Emission;</kbd></li>
<li class="calibre12"><kbd class="calibre13">fixed Alpha;</kbd></li>
<li class="calibre12"><kbd class="calibre13">half Occlusion;</kbd></li>
<li class="calibre12"><kbd class="calibre13">half Smoothness;</kbd></li>
<li class="calibre12"><kbd class="calibre13">fixed3 Specular;</kbd>: This is the specular color. This is very different from the <kbd class="calibre13">Specular</kbd> property in <kbd class="calibre13">SurfaceOutput</kbd> as it allows you to specify a color rather than a single value.</li>
</ul>
<p class="calibre3">Using a Surface Shader correctly is a matter of initializing the <kbd class="calibre13">SurfaceOutput</kbd> with the correct values.</p>
<p>For more information on creating Surface Shaders, check out the following link: <a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html" class="calibre31">https://docs.unity3d.com/Manual/SL-SurfaceShaders.html</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Accessing and modifying packed arrays</h1>
                
            
            
                
<p class="calibre3">Loosely speaking, the code inside a shader has to be executed for at least every pixel in your screen. This is the reason why GPUs are highly optimized for parallel computing; they can execute multiple processes at the same time. This philosophy is also evident in the standard type of variables and operators available in Cg. Understanding them is essential, not just so that you can use the shaders correctly, but also to write highly optimized ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">There are two types of variables in Cg: single values and packed arrays. The latter can be identified because their type ends with a number such as <kbd class="calibre13">float3</kbd> or <kbd class="calibre13">int4</kbd>. As their names suggest, these types of variables are similar to structs, which means that they each contain several single values. Cg calls them packed arrays, though they are not exactly <em class="calibre14">arrays</em> in the traditional sense.</p>
<p class="calibre3">The elements of a packed array can be accessed as a normal struct. They are typically called <kbd class="calibre13">x</kbd>, <kbd class="calibre13">y</kbd>, <kbd class="calibre13">z</kbd>, and <kbd class="calibre13">w</kbd>. However, Cg also provides you with another alias for them, that is, <kbd class="calibre13">r</kbd>, <kbd class="calibre13">g</kbd>, <kbd class="calibre13">b</kbd>, and <kbd class="calibre13">a</kbd>. Despite there being no difference between using <kbd class="calibre13">x</kbd> or <kbd class="calibre13">r</kbd>, it can make a huge difference for the readers. Shader coding, in fact, often involves calculation with positions and colors. You might have seen this in the Standard Shaders:</p>
<pre class="calibre19">o.Alpha = _Color.a; </pre>
<p class="calibre3">Here, <kbd class="calibre13">o</kbd> was a struct and <kbd class="calibre13">_Color</kbd> was a packed array. This is also why Cg prohibits the mixed usage of these two syntaxes: you cannot use <kbd class="calibre13">_Color.xgz</kbd>.</p>
<p class="calibre3">There is also another important feature of packed arrays that has no equivalent in C#: <strong class="calibre5">swizzling</strong>. Cg allows addressing and reordering elements within packed arrays in just a single line. Once again, this appears in the Standard Shader:</p>
<pre class="calibre19">o.Albedo = _Color.rgb; </pre>
<p class="calibre3"><kbd class="calibre13">Albedo</kbd> is <kbd class="calibre13">fixed3</kbd>, which means that it contains three values of the <kbd class="calibre13">fixed</kbd> type. However, <kbd class="calibre13">_Color</kbd> is defined as a  <kbd class="calibre13">fixed4</kbd> type.  A direct assignment would result in a compiler error as <kbd class="calibre13">_Color</kbd> is bigger than <kbd class="calibre13">Albedo</kbd>. The C# way of doing this would be as follows:</p>
<pre class="calibre19">o.Albedo.r = _Color.r; 
o.Albedo.g = _Color.g; 
o.Albedo.b = _Color.b; </pre>
<p class="calibre3">However, it can be compressed in Cg:</p>
<pre class="calibre19">o.Albedo = _Color.rgb; </pre>
<p class="calibre3">Cg also allows reordering elements, for instance, using <kbd class="calibre13">_Color.bgr</kbd> to swap the red and blue channels.</p>
<p class="calibre3">Lastly, when a single value is assigned to a packed array, it is copied to all of its fields:</p>
<pre class="calibre19">o.Albedo = 0; // Black =(0,0,0) 
o.Albedo = 1; // White =(1,1,1) </pre>
<p class="calibre3">This is referred to as <strong class="calibre5">smearing</strong>.</p>
<p class="calibre3">Swizzling can also be used on the left-hand side of an expression, allowing only certain components of a packed array to be overwritten:</p>
<pre class="calibre19">o.Albedo.rg = _Color.rg; </pre>
<p class="calibre3">In this case, it is called <strong class="calibre5">masking</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">Where swizzling really shows its full potential is when it's applied to packed matrices. Cg allows types such as <kbd class="calibre13">float4x4</kbd>, which represents a matrix of floats with four rows and four columns. You can access a single element of the matrix using the <kbd class="calibre13">_mRC</kbd> notation, where <em class="calibre14">R</em> is the row and <em class="calibre14">C</em> is the column:</p>
<pre class="calibre19">float4x4 matrix; 
// ... 
float first = matrix._m00; 
float last = matrix._m33; </pre>
<p class="calibre3">The <kbd class="calibre13">_mRC</kbd> notation can also be chained:</p>
<pre class="calibre19">float4 diagonal = matrix._m00_m11_m22_m33; </pre>
<p class="calibre3">An entire row can be selected using squared brackets:</p>
<pre class="calibre19">float4 firstRow = matrix[0]; 
// Equivalent to 
float4 firstRow = matrix._m00_m01_m02_m03; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<ul class="calibre11">
<li class="calibre12">In addition to being easier to write, swizzling, smearing, and masking properties have performance benefits as well</li>
<li class="calibre12">However, inappropriate use of swizzling can also make your code harder to understand at first glance, and may make it harder for the compiler to automatically optimize your code</li>
<li class="calibre12">Packed arrays are one of the nicest features of Cg. You can discover more about them here: <a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html" class="calibre10">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter02.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding a texture to a shader</h1>
                
            
            
                
<p class="calibre3">Textures can bring our shaders to life very quickly in terms of achieving very realistic effects. In order to effectively use textures, we need to understand how a 2D image is mapped to a 3D model. This process is called texture mapping, and it requires some work to be done on the shader and 3D model that we want to use. Models, in fact, are made out of triangles, which are often referred to as polygons; each vertex on the model can store data that shaders can access and use to determine what to draw.</p>
<p class="calibre3">One of the most important pieces of information that are stored in vertices is the <strong class="calibre5">UV data</strong>. It consists of two coordinates, <em class="calibre14">U</em> and <em class="calibre14">V</em>, ranging from 0 to 1. They represent the <em class="calibre14">XY</em> position of the pixel in the 2D image that will be mapped to the vertices. UV data is present only for vertices; when the inner points of a triangle have to be texture-mapped, the GPU interpolates the closest UV values to find the right pixel in the texture to be used. The following diagram shows you how a <strong class="calibre5">2D Texture</strong> is mapped to a triangle from a 3D model:</p>
<div><img src="img/00042.jpeg" class="calibre56"/></div>
<p class="calibre3">The UV data is stored in the 3D model and requires modeling software to be edited. Some models lack the UV component, hence they cannot support texture mapping. The Stanford bunny, for example, was not originally provided with one. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">For this recipe, you'll need a 3D model with UV data and its texture. They both need to be imported to Unity before starting. You can do this simply by dragging them to the editor. As the Standard Shader supports texture mapping by default, we'll use this and then explain how it works in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">Adding a texture to your model using the Standard Shader is incredibly simple, as follows:</p>
<ol class="calibre15">
<li value="1" class="calibre12">In the Sample Code for this chapter that's provided with this book, you can find the <kbd class="calibre13">basicCharacter</kbd> model which, by default, has UV information embedded into it, making it so that when we attach a material, it will draw the texture using that information.</li>
<li value="2" class="calibre12">Create a new Standard Surface Shader called <kbd class="calibre13">TexturedShader</kbd> by going to the Project tab and then selecting Create | Shaders | Standard Surface Shader. Once created, you can type in a new name for the shader and then press <em class="calibre2">Enter</em>. </li>
<li value="3" class="calibre12">For organization's sake, open the shader and change the first line to the following:</li>
</ol>
<pre class="calibre18">Shader "CookbookShaders/Chapter03/TexturedShader" {</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12"> This will allow us to find the shader inside of the organization we have been using so far for this book.</li>
<li value="5" class="calibre12">Create a new material called <kbd class="calibre13">TexturedMaterial</kbd> by going to the Project tab and then selecting Create | Material. Once created, you can type in a new name for the material and then press <em class="calibre2">Enter</em> to confirm the change. </li>
</ol>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Assign the shader to the material by going to the Inspector tab and then clicking on the Shader dropdown before selecting <kbd class="calibre13">CookbookShaders/Chapter 03/TexturedShader</kbd>:</li>
</ol>
<div><img src="img/00043.jpeg" class="calibre57"/></div>
<p>You may also do this by first selecting the material and then dragging the shader file over it in the Project tab.</p>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">After selecting the material, drag your texture to the empty rectangle called Albedo (RGB). If you are missing some, there are textures located in this chapter's example code that can be used. If you have followed all of these steps correctly, your material Inspector tab should look like this:</li>
</ol>
<div><img src="img/00044.jpeg" class="calibre58"/></div>
<p>The Standard Shader knows how to map a 2D image to a 3D model using its UV models and textures used in this example were created by Kenney Vleugels and Casper Jorissen. You can find these and many other public domain game assets at <a href="http://Kenney.nl" class="calibre31">Kenney.nl</a>.</p>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">To see the UV data in action, in the example code's <kbd class="calibre13">Models</kbd> folder, drag and drop the model into the Hierarchy tab. Once there, double-click on the newly created object to zoom in so that you can see the object:</li>
</ol>
<div><img src="img/00045.jpeg" class="calibre25"/></div>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">Once there, you may go to the Project tab and open up the <kbd class="calibre13">Chapter 3 </kbd>| <kbd class="calibre13">Materials</kbd> folder and drag and drop our <kbd class="calibre13">Textured Material</kbd> onto the character. Note that the model consists of different objects, each of which provides direction to draw in a particular place. This means that you will need to drop the material on each part of the model (<kbd class="calibre13">ArmLeft1</kbd>, <kbd class="calibre13">ArmRight1</kbd>, <kbd class="calibre13">Body1</kbd>, and so on); trying to apply this to the top level of the hierarchy only (<kbd class="calibre13">basicCharacter</kbd>) will not work:</li>
</ol>
<div><img src="img/00046.jpeg" class="calibre59"/></div>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">It is also possible to change what the object looks like by changing the texture that's being used. For instance, if we use the other texture provided (<kbd class="calibre13">skin_womanAlternative</kbd>), we have a very different looking character:</li>
</ol>
<div><img src="img/00047.jpeg" class="calibre60"/></div>
<p>This is often used in games to provide different kinds of characters with minimal cost. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">When the Standard Shader is used from the Inspector of a material, the process behind texture mapping is completely transparent to developers. If we want to understand how it works, it's necessary to take a closer look at <kbd class="calibre13">TexturedShader</kbd>. From the <kbd class="calibre13">Properties</kbd> section, we can see that the <kbd class="calibre13">Albedo (RGB)</kbd> texture is actually referred to in the code as <kbd class="calibre13">_MainTex</kbd>:</p>
<pre class="calibre19">_MainTex ("Albedo (RGB)", 2D) = "white" {} </pre>
<p class="calibre3">In the <kbd class="calibre13">CGPROGRAM</kbd> section, this texture is defined as <kbd class="calibre13">sampler2D</kbd>, the standard type for 2D textures:</p>
<pre class="calibre19">sampler2D _MainTex; </pre>
<p class="calibre3">The following line shows a <kbd class="calibre13">struct</kbd> called <kbd class="calibre13">Input</kbd>. This is the input parameter for the surface function and contains a packed array called <kbd class="calibre13">uv_MainTex</kbd>:</p>
<pre class="calibre19">struct Input { 
  float2 uv_MainTex; 
}; </pre>
<p class="calibre3">Every time the <kbd class="calibre13">surf()</kbd> function is called, the <kbd class="calibre13">Input</kbd> structure will contain the UV of <kbd class="calibre13">_MainTex</kbd> for the specific point of the 3D model that needs to be rendered. The Standard Shader recognizes that the name <kbd class="calibre13">uv_MainTex</kbd> refers to <kbd class="calibre13">_MainTex</kbd> and initializes it automatically. If you are interested in understanding how the UV is actually mapped from a 3D space to a 2D texture, you can check out <a href="part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 5</a>, <em class="calibre14">Understanding Lighting Models</em>.</p>
<p class="calibre3">Finally, the UV data is used to sample the texture in the first line of the surface function:</p>
<pre class="calibre19">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; </pre>
<p class="calibre3">This is done using the <kbd class="calibre13">tex2D()</kbd> function of Cg; it takes a texture and UV and returns the color of the pixel at that position.</p>
<p>The <em class="calibre21">U</em> and <em class="calibre21">V</em> coordinates go from <em class="calibre21">0</em> to <em class="calibre21">1</em>, where (0,0) and (1,1) correspond to two opposite corners. Different implementations associate UV with different corners; if your texture happens to appear reversed, try inverting the V component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">When you import a texture to Unity, you are setting up some of the properties that <kbd class="calibre13">sampler2D</kbd> will use. The most important is the Filter mode, which determines how colors are interpolated when the texture is sampled. It is very unlikely that the UV data will point exactly to the center of a pixel; in all other cases, you might want to interpolate between the closest pixels to get a more uniform color. The following is a screenshot of the Inspector tab of an example texture:</p>
<div><img src="img/00048.jpeg" class="calibre61"/></div>
<p class="calibre3">For most applications, Bilinear provides an inexpensive, yet effective, way to smooth the texture. If you are creating a 2D game, however, Bilinear might produce blurred tiles. In this case, you can use Point to remove any interpolation from the texture sampling.</p>
<p class="calibre3">When a texture is seen from a steep angle, texture sampling is likely to produce visually unpleasant artifacts. You can reduce them by setting the Aniso Level to a higher value. This is particularly useful for floor and ceiling textures, where glitches can break the illusion of continuity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<ul class="calibre11">
<li class="calibre12">If you would like to know more about the inner workings of how textures are mapped to a 3D surface, you can read the information available at <a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html" class="calibre10">http://developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html</a>.</li>
<li class="calibre12">For a complete list of the options available when importing a 2D texture, you can refer to the following website: <a href="http://docs.unity3d.com/Manual/class-TextureImporter.html" class="calibre10">http://docs.unity3d.com/Manual/class-TextureImporter.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Scrolling textures by modifying UV values</h1>
                
            
            
                
<p class="calibre3">One of the most common texture techniques used in today's game industry is the process of allowing you to scroll the textures over the surface of an object. This allows you to create effects such as waterfalls, rivers, and lava flows. It's also a technique that is the basis of creating animated sprite effects, but we will cover this in a subsequent recipe of this chapter. First, let's see how we will create a simple scrolling effect in a Surface Shader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">To begin this recipe, you will need to create a new shader file (<kbd class="calibre13">ScrollingUVs</kbd>) and material (<kbd class="calibre13">ScrollingUVMat</kbd>). This will set us up with a nice clean shader that we can use to study the scrolling effect by itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">To begin with, we will launch our new shader file that we just created and enter the code mentioned in the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">The shader will need two new properties that will allow us to control the speed of the texture scrolling. So, let's add a speed property for the <em class="calibre2">X</em> direction and a speed property for the <em class="calibre2">Y</em> direction, as shown in the following code:</li>
</ol>
<pre class="calibre62">Properties {<br class="title-page-name"/>  _Color ("Color", Color) = (1,1,1,1)<br class="title-page-name"/>  _MainTex ("Albedo (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _ScrollXSpeed ("X Scroll Speed", Range(0,10)) = 2 <br class="title-page-name"/>  _ScrollYSpeed ("Y Scroll Speed", Range(0,10)) = 2 <br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">When working in ShaderLab, <kbd class="calibre13">Properties</kbd> has a syntax that looks like the following:</li>
</ol>
<pre class="calibre62">Properties<br class="title-page-name"/>{<br class="title-page-name"/>    _propertyName("Name in Inspector", Type) = value<br class="title-page-name"/>}</pre>
<p class="calibre26">Each property contained in the <kbd class="calibre13">Properties</kbd> block first has a name that is used in code to refer to the object, here specified as <kbd class="calibre13">_propertyName</kbd>. The underscore isn't required but is a common standard in place. Inside the parenthesis, you'll see two parameters. The first is a string that defines what text will be displayed in the Inspector for what this property is. The second parameter is the type of data we wish to store.</p>
<p class="calibre26">In our case, for the <em class="calibre14">X</em> and <em class="calibre14">Y</em> Scroll Speed, we are creating a number with a possible Range from 0 to 10. Lastly, we can initialize the property with a default value which is done on the end. As we've seen before, these properties will show up in the Inspector if you select a material that is using this shader.</p>
<p>For more information on Properties and how to create them, check out <a href="https://docs.unity3d.com/Manual/SL-Properties.html" class="calibre31">https://docs.unity3d.com/Manual/SL-Properties.html</a>.</p>
<p class="calibre26">For this example, we don't need the <kbd class="calibre13">Smoothness</kbd> or <kbd class="calibre13">Metallic</kbd> properties, so we can remove them as well.</p>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Modify the Cg properties in the <kbd class="calibre13">CGPROGRAM</kbd> section above the definition of <kbd class="calibre13">_MainTex</kbd> and create new variables so that we can access the values from our properties:</li>
</ol>
<pre class="calibre62">fixed _ScrollXSpeed; 
fixed _ScrollYSpeed; 
sampler2D _MainTex; </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">We also need to remove the <kbd class="calibre13">_Glossiness</kbd> and <kbd class="calibre13">_Metallic</kbd> definitions as we are not using them anymore.</li>
<li value="5" class="calibre12">Modify the surface function to change the UVs given to the <kbd class="calibre13">tex2D()</kbd> function. Then, use the built-in <kbd class="calibre13">_Time</kbd> variable to animate the UVs over time when the Play button is pressed in the editor:</li>
</ol>
<pre class="calibre62">void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>    // Create a separate variable to store our UVs <br class="title-page-name"/>    // before we pass them to the tex2D() function <br class="title-page-name"/>    fixed2 scrolledUV = IN.uv_MainTex; <br class="title-page-name"/>       <br class="title-page-name"/>    // Create variables that store the individual x and y <br class="title-page-name"/>    // components for the UV's scaled by time <br class="title-page-name"/>    fixed xScrollValue = _ScrollXSpeed * _Time; <br class="title-page-name"/>    fixed yScrollValue = _ScrollYSpeed * _Time; <br class="title-page-name"/>       <br class="title-page-name"/>    // Apply the final UV offset <br class="title-page-name"/>    scrolledUV += fixed2(xScrollValue, yScrollValue); <br class="title-page-name"/>       <br class="title-page-name"/>    // Apply textures and tint <br class="title-page-name"/>    half4 c = tex2D(_MainTex, scrolledUV); <br class="title-page-name"/>    o.Albedo = c.rgb * _Color; <br class="title-page-name"/>    o.Alpha = c.a; <br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Once the script is finished, save it and then go back to the Unity editor. Go to the <kbd class="calibre13">Materials</kbd> folder and assign <kbd class="calibre13">ScrollingUVsMat</kbd> to use our <kbd class="calibre13">ScrollingUVs</kbd> shader. Once that is done, under the Albedo (RGB) property, drag and drop the water texture from the example code provided with this book to assign the property:</li>
</ol>
<div><img src="img/00049.jpeg" class="calibre63"/></div>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">After this is created, we need to create an object that can use the shader. From a new scene, go ahead and select GameObject | 3D Object | Plane and drag and drop the <kbd class="calibre13">ScrollingUVMat</kbd> material onto it.</li>
</ol>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">Once applied, go ahead and play the game to see the shader in action:</li>
</ol>
<div><img src="img/00050.jpeg" class="calibre25"/></div>
<p class="calibre3">While it's not visible in this still image, you will notice that in the Unity editor, the object will now move in both the <em class="calibre14">X</em> and <em class="calibre14">Y</em> axes! Feel free to drag the X Scroll Speed and Y Scroll Speed properties in the Inspector tab to see how the changes affect how the object moves. Also, feel free to move the camera to make it easier to see if you would like.</p>
<p>If you modify a variable on a Material during gameplay, the value will stay changed, unlike how Unity typically works.</p>
<p class="calibre3">Pretty cool! With this knowledge, we can take this concept much further to create interesting visual effects. The following screenshot demonstrates the result of utilizing the scrolling UV system with multiple materials in order to create a simple river motion for your environments:</p>
<div><img src="img/00051.jpeg" class="calibre64"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">The scrolling system starts with the declaration of a couple of properties, which will allow the user of this shader to increase or decrease the speed of the scrolling effect itself. At their core, they are float values being passed from the material's Inspector tab to the surface function of the shader. For more information on shader properties, see <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 2</a>, <em class="calibre14">Creating Your First Shader</em>.</p>
<p class="calibre3">Once we have these float values from the material's Inspector tab, we can use them to offset our UV values in the shader.</p>
<p class="calibre3">To begin this process, we first store the UVs in a separate variable called <kbd class="calibre13">scrolledUV</kbd>. This variable has to be <kbd class="calibre13">float2</kbd>/<kbd class="calibre13">fixed2</kbd> because the UV values are being passed to us from the <kbd class="calibre13">Input</kbd> structure:</p>
<pre class="calibre19">struct Input 
{ 
  float2 uv_MainTex; 
} </pre>
<p class="calibre3">Once we have access to the mesh's UVs, we can offset them using our scroll speed variables and built-in <kbd class="calibre13">_Time</kbd> variable. This built-in variable returns a variable of the <kbd class="calibre13">float4</kbd> type, meaning that each component of this variable contains different values of time as it pertains to game time.</p>
<p class="calibre3">A complete description of these individual time values is described at the following link: <a href="http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html" class="calibre10">http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a></p>
<p class="calibre3">This <kbd class="calibre13">_Time</kbd> variable will give us an incremented float value based on Unity's game time clock. So, we can use this value to move our UVs in a UV direction and scale that time with our scroll speed variables:</p>
<pre class="calibre19">// Create variables that store the individual x and y  
// components for the uv's scaled by time 
fixed xScrollValue = _ScrollXSpeed * _Time; 
fixed yScrollValue = _ScrollYSpeed * _Time; </pre>
<p class="calibre3">With the correct offset being calculated by time, we can add the new offset value back to the original UV position. This is why we are using the <kbd class="calibre13">+=</kbd> operator in the next line. We want to take the original UV position, add the new offset value, and then pass this to the <kbd class="calibre13">tex2D()</kbd> function as the texture's new UVs. This creates the effect of the texture moving on the surface. What we are really doing is manipulating the UVs, so we are faking the effect of the texture moving:</p>
<pre class="calibre19">scrolledUV += fixed2(xScrollValue, yScrollValue); 
half4 c = tex2D (_MainTex, scrolledUV); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a shader with normal mapping</h1>
                
            
            
                
<p class="calibre3">Every triangle of a 3D model has a <em class="calibre14">facing direction</em>, which is the direction that it is pointing toward. It is often represented with an arrow placed in the center of the triangle and is orthogonal to the surface. The facing direction plays an important role in the way light reflects on a surface. If two adjacent triangles face different directions, they will reflect lights at different angles, hence they'll be shaded differently. For curved objects, this is a problem: it is obvious that the geometry is made out of flat triangles.</p>
<p class="calibre3">To avoid this problem, the way the light reflects on a triangle doesn't take into account its facing direction, but its <em class="calibre14">normal direction</em> instead. As stated in the <em class="calibre14">Adding a texture to a shader</em> recipe, vertices can store data; the normal direction is the most used information after the UV data. This is a vector of unit length (which means it has a length of 1) that indicates the direction faced by the vertex.</p>
<p class="calibre3">Regardless of the facing direction, every point within a triangle has its own normal direction that is a linear interpolation of the ones stored in its vertices. This gives us the ability to fake the effect of high-resolution geometry on a low-resolution model.</p>
<p class="calibre3">The following screenshot shows the same geometric shape rendered with different per-vertex normals. In the image, on the left, normals are orthogonal to the face represented by its vertices; this indicates that there is a clear separation between each face. On the right, normals are interpolated along the surface, indicating that even if the surface is rough, a light should reflect as if it's smooth. It's easy to see that even if the three objects in the following screenshot share the same geometry, they reflect light differently. Despite being made out of flat triangles, the object on the right reflects light as if its surface was actually curved:</p>
<div><img src="img/00052.jpeg" class="calibre65"/></div>
<p class="calibre3">Smooth objects with rough edges are a clear indication that per-vertex normals have been interpolated. This can be seen if we draw the direction of the normal stored in every vertex, as shown in the following screenshot. You should note that every triangle has only three normals, but as multiple triangles can share the same vertex, more than one line can come out of it:</p>
<div><img src="img/00053.jpeg" class="calibre66"/></div>
<p class="calibre3">Calculating the normals from the 3D model is a technique that has rapidly declined in favor of a more advanced one-normal mapping. Similar to what happens with texture mapping, the normal directions can be provided using an additional texture, usually called a normal map or bump map.</p>
<p class="calibre3">Normal maps are usually images where the red, green, and blue channels of the image are used to indicate the <em class="calibre14">X</em>, <em class="calibre14">Y</em>, and <em class="calibre14">Z</em> components of the normal direction. There are many ways to create normal maps these days. Some applications, such as CrazyBump (<a href="http://www.crazybump.com/" class="calibre10">http://www.crazybump.com/</a>) and NDO Painter (<a href="http://quixel.se/ndo/" class="calibre10">http://quixel.se/ndo/</a>), will take in 2D data and convert it to normal data for you. Other applications such as Zbrush 4R7 (<a href="http://www.pixologic.com/" class="calibre10">http://www.pixologic.com/</a>) and AUTODESK (<a href="http://usa.autodesk.com/" class="calibre10">http://usa.autodesk.com</a>) will take 3D-sculpted data and create normal maps for you. The actual process of creating normal maps is out of the scope of this book, but the links in the previous text should help you get started.</p>
<p class="calibre3">Unity makes the process of adding normals to your shaders quite an easy process in the Surface Shader realm using the <kbd class="calibre13">UnpackNormals()</kbd> function. Let's see how this is done.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">To begin this recipe, first create a new scene by selecting File | New Scene. Then, create a sphere game object by going to GameObject | 3D Objects | Sphere. Double-click on the object in the Hierarchy tab to bring the object into focus in the Scene tab. You will also need to create a new standard Surface Shader file (<kbd class="calibre13">NormalShader</kbd>) and material (<kbd class="calibre13">NormalShaderMat</kbd>). Once created, set the material to a sphere in the Scene view. This will give us a clean workspace in which we can look at just the normal mapping technique:</p>
<div><img src="img/00054.jpeg" class="calibre67"/></div>
<p class="calibre3">You will need a normal map for this recipe, but there is also one in the Unity project included with this book.</p>
<p class="calibre3">An example normal map included with this book's content is shown here:</p>
<div><img src="img/00055.jpeg" class="calibre68"/></div>
<p class="calibre3">You can see it for yourself in the <kbd class="calibre13">Assets </kbd>|  <kbd class="calibre13">Chapter 03 </kbd>| <kbd class="calibre13">Textures</kbd> folder under <kbd class="calibre13">normalMapExample</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">The following are the steps to create a normal map shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Let's get the <kbd class="calibre13">Properties</kbd> block set up in order to have a color <kbd class="calibre13">Tint</kbd> and texture:</li>
</ol>
<pre class="calibre18">Properties 
{ 
  _MainTint ("Diffuse Tint", Color) = (0,1,0,1) 
  _NormalTex ("Normal Map", 2D) = "bump" {} 
} </pre>
<p>In this case, I have 1 in the green and alpha channels and <kbd class="calibre37">0</kbd> for red and blue, so the default color will be green. For the <kbd class="calibre37">_NormalTex</kbd> property, we are using a 2D type, which means we can use a 2D image to dictate what each pixel will use. By initializing the texture as <kbd class="calibre37">bump</kbd>, we are telling Unity that <kbd class="calibre37">_NormalTex</kbd> will contain a normal map (sometimes referred to as bump maps as well, hence the bump name). If the texture is not set, it will be replaced by a grey texture. The color used (<kbd class="calibre37">0.5</kbd>, <kbd class="calibre37">0.5</kbd>, <kbd class="calibre37">0.5</kbd>, <kbd class="calibre37">1</kbd>) indicates no bump at all.</p>
<ol start="2" class="calibre15">
<li value="2" class="calibre12"> In the <kbd class="calibre13">SubShader{}</kbd> block, scroll below the <kbd class="calibre13">CGPROGRAM</kbd> statement and remove the original <kbd class="calibre13">_MainText</kbd>,  <kbd class="calibre13">_Glossiness</kbd>, <kbd class="calibre13">_Metallic</kbd>, and <kbd class="calibre13">_Color</kbd> definitions. Afterward, add in our <kbd class="calibre13">_NormalTex</kbd> and <kbd class="calibre13">_MainTint</kbd>: </li>
</ol>
<pre class="calibre18">    CGPROGRAM<br class="title-page-name"/>    // Physically based Standard lighting model, and enable shadows <br class="title-page-name"/>    // on all light types<br class="title-page-name"/>    #pragma surface surf Standard fullforwardshadows<br class="title-page-name"/><br class="title-page-name"/>    // Use shader model 3.0 target, to get nicer looking lighting<br class="title-page-name"/>    #pragma target 3.0<br class="title-page-name"/><br class="title-page-name"/>    // Link the property to the CG program <br class="title-page-name"/>    sampler2D _NormalTex; <br class="title-page-name"/>    float4 _MainTint; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">We need to make sure that we update the <kbd class="calibre13">Input</kbd> struct with the proper variable name so that we can use the model's UVs for the normal map texture:</li>
</ol>
<pre class="calibre62">// Make sure you get the UVs for the texture in the struct 
struct Input 
{ 
  float2 uv_NormalTex; 
} </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Finally, we extract the normal information from the normal map texture using the built-in <kbd class="calibre13">UnpackNormal()</kbd> function. Then, you only have to apply these new normals to the output of the Surface Shader:</li>
</ol>
<pre class="calibre62">void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>  // Use the tint provided as the base color for the material<br class="title-page-name"/>  o.Albedo = _MainTint;<br class="title-page-name"/><br class="title-page-name"/>  // Get the normal data out of the normal map texture <br class="title-page-name"/>  // using the UnpackNormal function <br class="title-page-name"/>  float3 normalMap = UnpackNormal(tex2D(_NormalTex, <br class="title-page-name"/>    IN.uv_NormalTex)); <br class="title-page-name"/> <br class="title-page-name"/>  // Apply the new normal to the lighting model <br class="title-page-name"/>  o.Normal = normalMap.rgb; <br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Save your script and return to the Unity editor. You should notice that the sphere has now become green by default if added. More importantly though, notice the Normal Map property that has been added. Drag and drop the normal map texture into the slot.</li>
</ol>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">You may notice some changes, but it may be hard to visually see what is going on. In the Normal Map property, change the Tiling to (<kbd class="calibre13">10</kbd>, <kbd class="calibre13">10</kbd>). This way, you can see the normal map duplicated 10 times over the course of the sphere in the <em class="calibre2">X</em> and <em class="calibre2">Y</em> axes instead of only once:</li>
</ol>
<div><img src="img/00056.jpeg" class="calibre25"/></div>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">The following screenshot demonstrates the result of our normal map shader:</li>
</ol>
<div><img src="img/00057.jpeg" class="calibre69"/></div>
<p>Shaders can have both a texture map and a normal map. It is not uncommon to use the same UV data to address both. However, it is possible to provide a secondary set of UVs in the vertex data (UV2), which are specifically used for the normal map.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">The actual math to perform the normal mapping effect is definitely beyond the scope of this chapter, but Unity has done it all for us already. It has created the functions for us so that we don't have to keep doing it over and over again. This is another reason why Surface Shaders are a really efficient way to write shaders.</p>
<p class="calibre3">If you look in the <kbd class="calibre13">UnityCG.cginc</kbd> file found in the <kbd class="calibre13">Editor</kbd> | <kbd class="calibre13">Data</kbd>| <kbd class="calibre13">CGIncludes</kbd> folder in your Unity installation directory, you will find the definitions for the <kbd class="calibre13">UnpackNormal()</kbd> function. When you declare this function in your Surface Shader, Unity takes the normal map provided and processes it for you, giving you the correct type of data so that you can use it in your per-pixel lighting function. It's a huge time-saver! When sampling a texture, you get RGB values from <kbd class="calibre13">0</kbd> to <kbd class="calibre13">1</kbd>; however, the directions of a normal vector range from <kbd class="calibre13">-1</kbd> to <kbd class="calibre13">1</kbd>. <kbd class="calibre13">UnpackNormal()</kbd> brings these components into the right range.</p>
<p class="calibre3">Once you have processed the normal map with the <kbd class="calibre13">UnpackNormal()</kbd> function, you send it back to your <kbd class="calibre13">SurfaceOutput</kbd> struct so that it can be used in the lighting function. This is done by using <kbd class="calibre13">o.Normal = normalMap.rgb;</kbd>. We will see how the normal is actually used to calculate the final color of each pixel in <a href="part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 4</a>, <em class="calibre14">Understanding Lighting Models</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">You can also add some controls to your normal map shader that lets a user adjust the intensity of the normal map. This is easily done by modifying the <kbd class="calibre13">x</kbd> and <kbd class="calibre13">y</kbd> components of the normal map variable and then adding it all back together. Add another property to the <kbd class="calibre13">Properties</kbd> block and name it <kbd class="calibre13">_NormalMapIntensity</kbd>:</p>
<pre class="calibre19">_NormalMapIntensity("Normal intensity", Range(0,3)) = 1 </pre>
<p class="calibre3">In this case, we are giving the property the ability to be between <kbd class="calibre13">0</kbd> and <kbd class="calibre13">3</kbd> with a default value of <kbd class="calibre13">1</kbd>. Once created, you'll need to add the variable inside the SubShader:</p>
<pre class="calibre19">// Link the property to the CG program <br class="title-page-name"/>sampler2D _NormalTex; <br class="title-page-name"/>float4 _MainTint; <br class="title-page-name"/><strong class="calibre1">float _NormalMapIntensity;</strong></pre>
<p class="calibre3">After the property is added, we can make use of it. Multiply the <kbd class="calibre13">x</kbd> and <kbd class="calibre13">y</kbd> components of the unpacked normal map and reapply this value to the normal map variable with the bolded changes:</p>
<pre class="calibre19">void surf (Input IN, inout SurfaceOutputStandard o) {<br class="title-page-name"/>  // Use the tint provided as the base color for the material<br class="title-page-name"/>  o.Albedo = _MainTint;<br class="title-page-name"/><br class="title-page-name"/>  // Get the normal data out of the normal map texture <br class="title-page-name"/>  // using the UnpackNormal function <br class="title-page-name"/>  float3 normalMap = UnpackNormal(tex2D(_NormalTex, <br class="title-page-name"/>    IN.uv_NormalTex)); <br class="title-page-name"/><strong class="calibre1"> </strong><br class="title-page-name"/><strong class="calibre1">  normalMap.x *= _NormalMapIntensity; </strong><br class="title-page-name"/><strong class="calibre1">  normalMap.y *= _NormalMapIntensity; </strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  // Apply the new normal to the lighting model </strong><br class="title-page-name"/><strong class="calibre1">  o.Normal = normalize(normalMap.rgb);</strong> <br class="title-page-name"/>}</pre>
<div><br class="calibre40"/>
Normal vectors are supposed to have lengths equal to one. Multiplying them for <kbd class="calibre37">_NormalMapIntensity</kbd> changes their length, making normalization necessary. The normalize function will take the vector and adjust it so that it is pointing in the correct direction but with a length of one, which is what we are looking for.</div>
<p class="calibre3">Now, you can let a user adjust the intensity of the normal map in the material's Inspector tab, as follows:</p>
<div><img src="img/00058.jpeg" class="calibre25"/></div>
<p class="calibre3">The following screenshot shows the result of modifying the normal map with our scalar values:</p>
<div><img src="img/00059.jpeg" class="calibre70"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a transparent material</h1>
                
            
            
                
<p class="calibre3">All the shaders we have seen so far have something in common; they are used for solid materials. If you want to improve the look of your game, transparent materials are often a good way to start. They can be used for anything from a fire effect to a glass window. Working with them, unfortunately, is slightly more complicated. Before rendering solid models, Unity orders them according to the distance from the camera (<em class="calibre14">Z ordering</em>) and skips all the triangles that are facing away from the camera (<strong class="calibre5">culling</strong>). When rendering transparent geometries, there are instances in which these two aspects can cause problems. This recipe will show you how to solve some of these issues when it comes to creating a transparent Surface Shader. This topic will be heavily revisited in <a href="part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 7</a>, <em class="calibre14">Fragment Shaders and Grab Passes</em>, where realistic glass and water shaders will be provided.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">This recipe requires a new shader, which we'll be calling <kbd class="calibre13">Transparent</kbd>, and a new material (<kbd class="calibre13">TransparentMat</kbd>) so that it can be attached to an object. As this is going to be a transparent glass window, a quad or plane is perfect (GameObject | 3D Objects | Quad). We will also need several other non-transparent objects to test the effect:</p>
<div><img src="img/00060.jpeg" class="calibre25"/></div>
<p class="calibre3">In this example, we will use a PNG image file for the glass texture since it has support for an alpha channel that will be used to determine the transparency of the glass. The process of creating such an image depends on the software that you are using. However, these are the main steps that you will need to follow:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Find the image of the glass you want for your windows.</li>
<li value="2" class="calibre12">Open it with a photo editing software, such as <em class="calibre2">GIMP</em> or <em class="calibre2">Photoshop</em>.</li>
<li value="3" class="calibre12">Select the parts of the image that you want to be semi-transparent.</li>
<li value="4" class="calibre12">Create a white (full opacity) layer mask on your image.</li>
<li value="5" class="calibre12">Use the selection previously made to fill the layer mask with a darker color. White is treated as fully visible, black will be treated as invisible, and grey will be somewhere in the middle.</li>
<li value="6" class="calibre12">Save the image and import it into Unity.</li>
</ol>
<p class="calibre3">The toy image used in this recipe is a picture of stained glass from the <em class="calibre14">Meaux Cathedral </em>in <em class="calibre14">France</em> (<a href="https://en.wikipedia.org/wiki/Stained_glass" class="calibre10">https://en.wikipedia.org/wiki/Stained_glass</a>). If you have followed all of these steps, your image should look like this (<strong class="calibre5">RGB</strong> channels on the left, and <strong class="calibre5">A</strong> channel on the right):</p>
<div><img src="img/00061.jpeg" class="calibre71"/></div>
<p class="calibre3">You can also make use of the image file in provided the example code for this book in <kbd class="calibre13">Chapter 3 </kbd>| <kbd class="calibre13">Textures</kbd> folder (<kbd class="calibre13">Meaux_Vitrail.psd</kbd>).</p>
<p class="calibre3">Attaching this image to the material will cause the image to show up, but we cannot see it behind the glass:</p>
<div><img src="img/00062.jpeg" class="calibre25"/></div>
<p class="calibre3">As we would like to see behind this, we can make adjustments to the shader to do exactly that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">As mentioned previously, there are a few aspects that we need to take care of while using a Transparent Shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Remove the <kbd class="calibre13">_Glossiness</kbd> and <kbd class="calibre13">_Metallic</kbd> variables from the <kbd class="calibre13">Properties</kbd> and <kbd class="calibre13">SubShader</kbd> sections of the code as they aren't needed for this example.</li>
<li value="2" class="calibre12">In the <kbd class="calibre13">SubShader{}</kbd> section of the shader, modify the <kbd class="calibre13">Tags</kbd> section to the following so that we can signal that the shader is transparent:</li>
</ol>
<pre class="calibre18">Tags 
{ 
  "Queue" = "Transparent" 
  "IgnoreProjector" = "True" 
  "RenderType" = "Transparent" 
} </pre>
<p class="calibre72">Tags are used by the <kbd class="calibre13">SubShader</kbd> to know how and when items should be rendered. Similar to the dictionary type, tags are key-value pairs where the left-hand side is the tag name and the right-hand side is the value you wish for it to be set to.</p>
<p>For more information on tags in ShaderLab, check out: <a href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html" class="calibre31">https://docs.unity3d.com/Manual/SL-SubShaderTags.html</a></p>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">As this shader is designed for 2D materials, make sure that the back geometry of your model is not drawn by adding the following below the <kbd class="calibre13">LOD 200</kbd> line:</li>
</ol>
<pre class="calibre18">    LOD 200<br class="title-page-name"/><br class="title-page-name"/>    // Do not show back<br class="title-page-name"/>    Cull Back<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    // Physically based Standard lighting model, and enable shadows on all light types<br class="title-page-name"/>    #pragma surface surf Standard alpha:fade </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Tell the shader that this material is transparent and needs to be blended with what was drawn on the screen before:</li>
</ol>
<pre class="calibre18">#pragma surface surf Standard alpha:fade </pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Use this Surface Shader to determine the final color and transparency of the glass:</li>
</ol>
<pre class="calibre18">void surf(Input IN, inout SurfaceOutputStandard o) 
{ 
  float4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; 
  o.Albedo = c.rgb; 
  o.Alpha = c.a; 
} </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Afterward, save your script and dive back to the Unity editor:</li>
</ol>
<div><img src="img/00063.jpeg" class="calibre25"/></div>
<p class="calibre3">Notice that you can now see the cube behind the glass. Perfect!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">This shader introduces several new concepts. First of all, <kbd class="calibre13">Tags</kbd> are used to add information about how the object is going to be rendered. The really interesting one here is <kbd class="calibre13">Queue</kbd>. Unity, by default, will sort your objects for you based on the distance from the camera. So, as an object gets nearer to the camera, it is going to be drawn over all the objects that are further away from the camera. For most cases, this works out just fine for games, but you will find yourself in certain situations where you will want to have more control over the sorting of your objects in your scene. Unity has provided us with some default render queues, each with a unique value that directs Unity when to draw the object to the screen. These built-in render queues are called <kbd class="calibre13">Background</kbd>, <kbd class="calibre13">Geometry</kbd>, <kbd class="calibre13">AlphaTest</kbd>, <kbd class="calibre13">Transparent</kbd>, and <kbd class="calibre13">Overlay</kbd>. These queues weren't just created arbitrarily; they actually serve a purpose to make our lives easier when writing shaders and interacting with the real-time renderer.</p>
<p class="calibre3">Refer to the following table for descriptions on the usage of each of these individual render queues:</p>
<table border="1" class="calibre43">
<thead class="calibre73">
<tr class="calibre45">
<td class="calibre74">
<p class="calibre3"><strong class="calibre5">Render queue</strong></p>
</td>
<td class="calibre75">
<p class="calibre3"><strong class="calibre5">Render queue description</strong></p>
</td>
<td class="calibre76">
<p class="calibre3"><strong class="calibre5">Render queue value</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre74">
<p class="calibre3"><kbd class="calibre13">Background</kbd></p>
</td>
<td class="calibre75">
<p class="calibre3">This render queue is rendered first. It is used for skyboxes and so on.</p>
</td>
<td class="calibre76">
<p class="calibre3"><kbd class="calibre13">1000</kbd></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre74">
<p class="calibre3"><kbd class="calibre13">Geometry</kbd></p>
</td>
<td class="calibre75">
<p class="calibre3">This is the default render queue. This is used for most objects. Opaque geometry uses this queue.</p>
</td>
<td class="calibre76">
<p class="calibre3"><kbd class="calibre13">2000</kbd></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre74">
<p class="calibre3"><kbd class="calibre13">AlphaTest</kbd></p>
</td>
<td class="calibre75">
<p class="calibre3">Alpha-tested geometry uses this queue. It's different from the <kbd class="calibre13">Geometry</kbd> queue as it's more efficient to render alpha-tested objects after all the solid objects are drawn.</p>
</td>
<td class="calibre76">
<p class="calibre3"><kbd class="calibre13">2450</kbd></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre74">
<p class="calibre3"><kbd class="calibre13">Transparent</kbd></p>
</td>
<td class="calibre75">
<p class="calibre3">This render queue is rendered after <kbd class="calibre13">Geometry</kbd> and <kbd class="calibre13">AlphaTest</kbd> queues in back-to-front order. Anything alpha-blended (that is, shaders that don't write to the depth buffer) should go here, for example, glass and particle effects.</p>
</td>
<td class="calibre76">
<p class="calibre3"><kbd class="calibre13">3000</kbd></p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre74">
<p class="calibre3"><kbd class="calibre13">Overlay</kbd></p>
</td>
<td class="calibre75">
<p class="calibre3">This render queue is meant for overlay effects. Anything rendered last should go here, for example, lens flares.</p>
</td>
<td class="calibre76">
<p class="calibre3"><kbd class="calibre13">4000</kbd></p>
</td>
</tr>
</tbody>
</table>
<div><p class="calibre3"> </p>
<p class="calibre3">So, once you know which render queue your object belongs to, you can assign its built-in render queue tag. Our shader used the <kbd class="calibre13">Transparent</kbd> queue, so we wrote <kbd class="calibre13">Tags{"Queue"="Transparent"}</kbd>.</p>
<p>The fact that the <kbd class="calibre37">Transparent</kbd> queue is rendered after <kbd class="calibre37">Geometry</kbd> does <em class="calibre21">not</em> mean that our glass will appear on top of all the other solid objects. Unity will draw the glass last, but it will not render pixels that belong to pieces of geometry hidden behind something else. This control is done using a technique called <strong class="calibre77">ZBuffering</strong>. More information on how models are rendered can be found at the following link: <a href="http://docs.unity3d.com/Manual/SL-CullAndDepth.html" class="calibre31">http://docs.unity3d.com/Manual/SL-CullAndDepth.html</a>.</p>
<p class="calibre3">The <kbd class="calibre13">IgnoreProjector</kbd> tag makes this object unaffected by Unity's projectors. Lastly, <kbd class="calibre13">RenderType</kbd> plays a role in <strong class="calibre5">shader replacement</strong>, a topic that will be covered briefly in <a href="part0246.html#7AJAC0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 10</a>, <em class="calibre14">Gameplay and Screen Effects</em>.</p>
<p class="calibre3">The last concept introduced is <kbd class="calibre13">alpha:fade</kbd>. This indicates that all the pixels from this material have to be blended with what was on the screen before according to their alpha values. Without this directive, the pixels will be drawn in the correct order, but they won't have any transparency.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a Holographic Shader</h1>
                
            
            
                
<p class="calibre3">More and more space-themed games are being released every year. An important part of a good sci-fi game is the way futuristic technology is presented and integrated into gameplay. There's nothing that screams futuristic more than holograms. Despite being present in many flavors, holograms are often represented as semi-transparent, thin projections of an object. This recipe shows you how to create a shader that simulates such effects. Take this as a starting point: you can add noise, animated scan lines, and vibrations to create a truly outstanding holographic effect. The following screenshot shows an example of a Holographic effect:</p>
<div><img src="img/00064.jpeg" class="calibre78"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Create a shader called <kbd class="calibre13">Holographic</kbd>. Attach it to a material (<kbd class="calibre13">HolographicMat</kbd>) and assign it to a 3D model in your scene:</p>
<div><img src="img/00065.jpeg" class="calibre79"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">The following changes will change our existing shader into a holographic one:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Remove the following properties as they will not be used:
<ul class="calibre80">
<li class="calibre12"><kbd class="calibre13">_Glossiness</kbd></li>
<li class="calibre12"><kbd class="calibre13">_Metallic</kbd></li>
</ul>
</li>
<li value="2" class="calibre12">Add the following property to the shader:</li>
</ol>
<pre class="calibre18">_DotProduct("Rim effect", Range(-1,1)) = 0.25 </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Add its respective variable to the <kbd class="calibre13">CGPROGRAM</kbd> section:</li>
</ol>
<pre class="calibre18">float _DotProduct; </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">As this material is transparent, add the following tags:</li>
</ol>
<pre class="calibre18">Tags 
{ 
  "Queue" = "Transparent" 
  "IgnoreProjector" = "True" 
  "RenderType" = "Transparent" 
} </pre>
<div><br class="calibre40"/>
According to the type of object that you will use, you might want its backside to appear. If this is the case, add <kbd class="calibre37">Cull Off</kbd> so that the back of the model won't be removed (<em class="calibre21">culled</em>).</div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">This shader is not trying to simulate a realistic material, so there is no need to use the PBR lighting model. <strong class="calibre1">Lambertian reflectance</strong>, which is very cheap, is used instead. Additionally, we should disable any lighting with <kbd class="calibre13">nolighting</kbd> and signal to Cg that this is a Transparent Shader using <kbd class="calibre13">alpha:fade</kbd>:</li>
</ol>
<pre class="calibre18">#pragma surface surf Lambert alpha:fade nolighting </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Change the <kbd class="calibre13">Input</kbd> structure so that Unity will fill it with the current view direction and the world normal direction:</li>
</ol>
<pre class="calibre18">struct Input 
{ 
  float2 uv_MainTex; 
  float3 worldNormal; 
  float3 viewDir; 
}; </pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Use the following surface function. Remember that since this shader is using Lambertian reflectance as its lighting function, the name of the <kbd class="calibre13">SurfaceOutput</kbd> structure should be changed accordingly to <kbd class="calibre13">SurfaceOutput</kbd> instead of <kbd class="calibre13">SurfaceOutputStandard</kbd>:</li>
</ol>
<pre class="calibre18">void surf(Input IN, inout SurfaceOutput o) 
{ 
  float4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; 
  o.Albedo = c.rgb; 
 
  float border = 1 - (abs(dot(IN.viewDir, <br class="title-page-name"/>     IN.worldNormal))); 
  float alpha = (border * (1 - _DotProduct) + _DotProduct); 
  o.Alpha = c.a * alpha; 
} </pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">Save your script and dive into Unity. From there, change the Color property in the HolographicMat and see your hologram come to life:</li>
</ol>
<div><img src="img/00066.jpeg" class="calibre25"/></div>
<p class="calibre3">You can now use the Rim effect slider to choose the strength of the holographic effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">As mentioned previously, this shader works by showing only the silhouette of an object. If we look at the object from another angle, its outline will change. Geometrically speaking, the edges of a model are all those triangles whose <em class="calibre14">normal direction</em> is orthogonal (90 degrees) to the current <em class="calibre14">view direction</em>. The <kbd class="calibre13">Input</kbd> structure declares these parameters, <kbd class="calibre13">worldNormal</kbd> and <kbd class="calibre13">viewDir</kbd>, respectively.</p>
<p class="calibre3">The problem of understanding when two vectors are orthogonal can be solved using <kbd class="calibre13">_DotProduct</kbd>. This is an operator that takes two vectors and returns zero if they are orthogonal. We use <kbd class="calibre13">_DotProduct</kbd> to determine how close to zero the <kbd class="calibre13">_DotProduct</kbd> has to be for the triangle to fade completely.</p>
<p class="calibre3">The second aspect that is used in this shader is the gentle fading between the edge of the model (fully visible) and the angle determined by <kbd class="calibre13">_DotProduct</kbd> (invisible). This linear interpolation is effected as follows:</p>
<pre class="calibre19">float alpha = (border * (1 - _DotProduct) + _DotProduct); </pre>
<p class="calibre3">Finally, the original <kbd class="calibre13">alpha</kbd> from the texture is multiplied with the newly calculated coefficient to achieve the final look.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            
                
<p class="calibre3">This technique is very simple and relatively inexpensive, and yet it can be used for a large variety of effects, such as the following:</p>
<ul class="calibre11">
<li class="calibre12">The slightly colored atmosphere of a planet in sci-fi games</li>
<li class="calibre12">The edge of an object that has been selected or is currently under the mouse</li>
<li class="calibre12">A ghost or specter</li>
<li class="calibre12">Smoke coming out of an engine</li>
<li class="calibre12">The shockwave of an explosion</li>
<li class="calibre12">The bubble shield of a spaceship under attack</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            
                
<p class="calibre3">The <kbd class="calibre13">_DotProduct</kbd> plays an important role in the way reflections are calculated. <a href="part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 4</a>, <em class="calibre14">Understanding Lighting Models</em>, will explain in detail how it works and why it is widely used in so many shaders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Packing and blending textures</h1>
                
            
            
                
<p class="calibre3">Textures are useful for storing not only loads of data, not just pixel colors as we generally tend to think of them, but also for multiple sets of pixels in both the <em class="calibre14">x</em> and <em class="calibre14">y</em> directions and RGBA channels. We can actually pack multiple images into a single RGBA texture and use each of the R, G, B, and A components as individual textures themselves by extracting each of these components from the shader code.</p>
<p class="calibre3">The result of packing individual grayscale images into a single RGBA texture can be seen in the following screenshot:</p>
<div><img src="img/00067.jpeg" class="calibre81"/></div>
<p class="calibre3">Why is this helpful? Well, in terms of the amount of actual memory that your application takes up, textures are a large portion of your application's size. We can, of course, reduce the size of the image, but then we would lose details in how it can be represented. So, to begin reducing the size of your application, we can look at all of the images that we are using in our shader and see if we can merge these textures into a single texture. Using a single texture with multiple images in them requires fewer draw calls and less overhead than separate files. We can also use this concept to combine irregularly shaped textures (that being, those that are not squares) into a single one to take up less space than giving them their own full texture.</p>
<p class="calibre3">Any texture that is grayscale can be packed into one of the RGBA channels of another texture. This might sound a bit odd at first, but this recipe is going to demonstrate one of the uses of packing a texture and using these packed textures in a shader.</p>
<p class="calibre3">One example of using these packed textures is when you want to blend a set of textures together onto a single surface. You see this most often in terrain type shaders, where you need to blend into another texture nicely using some sort of control texture or the packed texture, in this case. This recipe covers this technique and shows you how to construct the beginnings of a nice four-texture blended terrain shader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Let's create a new shader file in your <kbd class="calibre13">Shaders</kbd> folder (<kbd class="calibre13">TextureBlending</kbd>) and then create a new material for this shader (<kbd class="calibre13">TextureBlendingMat</kbd>). The naming convention is entirely up to you for your shader and material files, so try your best to keep them organized, and easy to reference later on.</p>
<p class="calibre3">Once you have your shader and material ready, create a new scene in which we can test our shader. Inside to the scene, place the <kbd class="calibre13">Terrain_001</kbd> object from the <kbd class="calibre13">Chapter 3 </kbd>| <kbd class="calibre13">Models</kbd> folder and assign the <kbd class="calibre13">TextureBlendingMat</kbd> material to it:</p>
<div><img src="img/00068.jpeg" class="calibre25"/></div>
<p class="calibre3">You will also need to gather up four textures that you would want to blend together. These can be anything, but for a nice terrain shader, you will want grass, dirt, rocky dirt, and rock textures. You can find these assets in <kbd class="calibre13">Chapter 1 </kbd>| <kbd class="calibre13">Standard Assets </kbd>| <kbd class="calibre13">Environment </kbd>| <kbd class="calibre13">TerrainAssets </kbd>| <kbd class="calibre13">SurfaceTextures</kbd> folder in the example code for this book.</p>
<p class="calibre3">Finally, we will also need a blending texture that is packed with grayscale images. This will give us the four blending textures that we can use to direct how the color textures will be placed on the object surface.</p>
<p class="calibre3">We can use very intricate blending textures to create a very realistic distribution of terrain textures over a terrain mesh, as shown in the following screenshot:</p>
<div><img src="img/00069.jpeg" class="calibre82"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">Let's learn how to use packed textures by entering the code shown in the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">We need to add a few properties to our <kbd class="calibre13">Properties</kbd> block. We will need five <kbd class="calibre13">sampler2D</kbd> objects, or textures, and two <kbd class="calibre13">Color</kbd> properties:</li>
</ol>
<pre class="calibre18">Properties 
{ 
 _MainTint ("Diffuse Tint", Color) = (1,1,1,1) 
     
//Add the properties below so we can input all of our <br class="title-page-name"/>   textures 
  _ColorA ("Terrain Color A", Color) = (1,1,1,1) 
  _ColorB ("Terrain Color B", Color) = (1,1,1,1) 
  _RTexture ("Red Channel Texture", 2D) = ""{} 
  _GTexture ("Green Channel Texture", 2D) = ""{} 
  _BTexture ("Blue Channel Texture", 2D) = ""{} 
  _ATexture ("Alpha Channel Texture", 2D) = ""{} 
  _BlendTex ("Blend Texture", 2D) = ""{} 
} </pre>
<p>As always, remove the properties we are not using from the base shader from our code.</p>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We then need to create the <kbd class="calibre13">SubShader{}</kbd> section variables that will be our link to the data in the <kbd class="calibre13">Properties</kbd> block:</li>
</ol>
<pre class="calibre18">CGPROGRAM 
#pragma surface surf Lambert <br class="title-page-name"/><br class="title-page-name"/>// Use shader model 3.5 target, to support enough textures<br class="title-page-name"/>#pragma target 3.5<br class="title-page-name"/>float4 _MainTint; 
float4 _ColorA; 
float4 _ColorB; 
sampler2D _RTexture; 
sampler2D _GTexture; 
sampler2D _BTexture; 
sampler2D _BlendTex; 
sampler2D _ATexture; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Due to the number of items inside of our shader, we will need to update the target level version of our shader model to <kbd class="calibre13">3.5</kbd>:</li>
</ol>
<ol start="2" class="calibre15"/>
<p>For more information on Shader Compilation Target Levels, check out: <a href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html" class="calibre31">https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</a>.</p>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">So, now we have our texture properties and we are passing them to our <kbd class="calibre13">SubShader{}</kbd> function. In order to allow the user to change the tiling rates on a per-texture basis, we will need to modify our <kbd class="calibre13">Input</kbd> struct. This will allow us to use the tiling and offset parameters on each texture:</li>
</ol>
<pre class="calibre18">struct Input  
{ 
  float2 uv_RTexture; 
  float2 uv_GTexture; 
  float2 uv_BTexture; 
  float2 uv_ATexture; 
  float2 uv_BlendTex; 
}; </pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">In the <kbd class="calibre13">surf()</kbd> function, get the texture information and store it in its own variables so that we can work with the data in a clean, easy-to-understand way:</li>
</ol>
<pre class="calibre18">  void surf (Input IN, inout SurfaceOutput o) {<br class="title-page-name"/>    //Get the pixel data from the blend texture <br class="title-page-name"/>    //we need a float 4 here because the texture <br class="title-page-name"/>    //will return R,G,B,and A or X,Y,Z, and W <br class="title-page-name"/>    float4 blendData = tex2D(_BlendTex, IN.uv_BlendTex); <br class="title-page-name"/>       <br class="title-page-name"/>    //Get the data from the textures we want to blend <br class="title-page-name"/>    float4 rTexData = tex2D(_RTexture, IN.uv_RTexture); <br class="title-page-name"/>    float4 gTexData = tex2D(_GTexture, IN.uv_GTexture); <br class="title-page-name"/>    float4 bTexData = tex2D(_BTexture, IN.uv_BTexture); <br class="title-page-name"/>    float4 aTexData = tex2D(_ATexture, IN.uv_ATexture); </pre>
<p>Remember that due to us using Lambert, we will be using <kbd class="calibre37">SurfaceOutput</kbd> instead of <kbd class="calibre37">SurfaceOutputStandard</kbd> for the <kbd class="calibre37">surf</kbd> function.</p>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Let's blend each of our textures together using the <kbd class="calibre13">lerp()</kbd> function. It takes three arguments, <kbd class="calibre13">lerp(value : a, value : b,</kbd> and <kbd class="calibre13">blend: c)</kbd>. The <kbd class="calibre13">lerp()</kbd> function takes in two textures and blends them with the float value given in the last argument:</li>
</ol>
<pre class="calibre18">//No we need to construct a new RGBA value and add all  
//the different blended texture back together 
float4 finalColor; 
finalColor = lerp(rTexData, gTexData, blendData.g); 
finalColor = lerp(finalColor, bTexData, blendData.b); 
finalColor = lerp(finalColor, aTexData, blendData.a);<br class="title-page-name"/>finalColor.a = 1.0;</pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Finally, we multiply our blended texture by the color tint values and use the red channel to determine where the two different terrain tint colors go:</li>
</ol>
<pre class="calibre18">  //Add on our terrain tinting colors <br class="title-page-name"/>  float4 terrainLayers = lerp(_ColorA, _ColorB, blendData.r); <br class="title-page-name"/>  finalColor *= terrainLayers; <br class="title-page-name"/>  finalColor = saturate(finalColor); <br class="title-page-name"/>         <br class="title-page-name"/>  o.Albedo = finalColor.rgb * _MainTint.rgb; <br class="title-page-name"/>  o.Alpha = finalColor.a;<br class="title-page-name"/>}</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">Save your script and go back into Unity. Once there, you can assign the <kbd class="calibre13">TerrainBlend</kbd> texture to the Blend Texture property. Once you've done that, place different textures in the different channels in order to see our script in action:</li>
</ol>
<div><img src="img/00070.jpeg" class="calibre25"/></div>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">This effect can be taken even further by using different textures and terrain tinting to create some great looking terrains with minimal effort. The result of blending together four terrain textures and creating a terrain tinting technique can be seen in the following screenshot:</li>
</ol>
<div><img src="img/00071.jpeg" class="calibre83"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">This might seem like quite a few lines of code, but the concept behind blending is actually quite simple. For the technique to work, we have to employ the built-in <kbd class="calibre13">lerp()</kbd> function from the <kbd class="calibre13">CgFX</kbd> standard library. This function allows us to pick a value between argument one and argument two using argument three as the blend amount:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre84">
<p class="calibre3">Function</p>
</td>
<td class="calibre85">
<p class="calibre3">Description</p>
</td>
</tr>
<tr class="calibre45">
<td class="calibre84">
<p class="calibre3"><kbd class="calibre13">lerp(a, b, f )</kbd></p>
</td>
<td class="calibre85">
<p class="calibre3">This involves linear interpolation:</p>
<p class="calibre3"><em class="calibre14">(1 - f )* a + b * f</em></p>
<p class="calibre3">Here, <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd> are matching vector or scalar types. The <kbd class="calibre13">f</kbd> parameter can be either a scalar or vector of the same type as <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<div><p class="calibre3">So, for example, if we wanted to find the mid-value between <kbd class="calibre13">1</kbd> and <kbd class="calibre13">2</kbd>, we could feed the value <kbd class="calibre13">0.5</kbd> as the third argument to the <kbd class="calibre13">lerp()</kbd> function and it would return the value <kbd class="calibre13">1.5</kbd>. This works perfectly for our blending needs as the values of an individual channel in an RGBA texture are single float values, usually in the range of <kbd class="calibre13">0</kbd> to <kbd class="calibre13">1</kbd>.</p>
<p class="calibre3">In the shader, we simply take one of the channels from our Blend Texture and use it to drive the color that is picked in a <kbd class="calibre13">lerp()</kbd> function for each pixel. For instance, we take our grass texture and dirt texture, use the red channel from our blending texture, and feed this to a <kbd class="calibre13">lerp()</kbd> function. This will give us the correct blended color result for each pixel on the surface.</p>
<p class="calibre3">A more visual representation of what is happening when using the <kbd class="calibre13">lerp()</kbd> function is shown in the following diagram:</p>
<div><img src="img/00072.jpeg" class="calibre86"/></div>
<p class="calibre3">The shader code simply uses the four channels of the Blend Texture and all the color textures to create a final Blended Texture. This final texture then becomes the color that we can multiply with our diffuse lighting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a circle around your terrain</h1>
                
            
            
                
<p class="calibre3">Many RTS games display distances (range attack, moving distance, sight, and so on) by drawing a circle around the selected unit. If the terrain is flat, this can be done simply by stretching a quad with the texture of a circle. If that's not the case, the quad will most likely be clipped behind a hill or another piece of geometry. This recipe will show you how to create a shader that allows you to draw circles around an object of arbitrary complexity. If you want to be able to move or animate your circle, we will need both a shader and C# script.</p>
<p class="calibre3">The following screenshot shows an example of drawing a circle in a hilly region using a shader:</p>
<div><img src="img/00073.jpeg" class="calibre87"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            
                
<p class="calibre3">Despite working with every piece of geometry, this technique is oriented to terrains. Hence, the first step is setting up a terrain in Unity, but instead of using a model, we will create one within the Unity editor:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Let's start by creating a new shader called <kbd class="calibre13">RadiusShader</kbd> and the respective material, <kbd class="calibre13">RadiusMat</kbd>.</li>
<li value="2" class="calibre12">Have the character for your object ready; we will draw a circle around it.</li>
<li value="3" class="calibre12">From the menu, navigate to GameObject | 3D Object | Terrain to create a new terrain.</li>
<li value="4" class="calibre12">Create the geometry for your terrain. You can either import an existing one or draw your own using the tools available (Raise/Lower Terrain, Paint Height, Smooth Height).</li>
</ol>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">The terrains are special objects in Unity, and the way texture mapping works on them is different from traditional 3D models. You cannot provide <kbd class="calibre13">_MainTex</kbd> from a shader as it needs to be provided directly from the terrain itself. To do this, select Paint Texture and then click on Add Texture...:</li>
</ol>
<div><img src="img/00074.jpeg" class="calibre88"/></div>
<p>The creation  of a terrain isn't covered in this book, but if you would like to learn more about it, check out the following link: <a href="https://docs.unity3d.com/Manual/terrain-UsingTerrains.html" class="calibre31">https://docs.unity3d.com/Manual/terrain-UsingTerrains.html</a></p>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Now that the texture is set, you have to change the material of the terrain so that a custom shader can be provided. From Terrain Settings, change the Material property to <kbd class="calibre13">Custom</kbd>, and then drag the Radius material to the <kbd class="calibre13">Custom Material</kbd> box:</li>
</ol>
<div><img src="img/00075.jpeg" class="calibre25"/></div>
<p class="calibre3">You are now ready to create your shader.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            
                
<p class="calibre3">Let's start by editing the <kbd class="calibre13">RadiusShader</kbd> file:</p>
<ol class="calibre15">
<li value="1" class="calibre12">In the new shader, remove the <kbd class="calibre13">_Glossiness</kbd> and <kbd class="calibre13">_Metallic</kbd> properties and add these four properties:</li>
</ol>
<pre class="calibre18">_Center("Center", Vector) = (200,0,200,0) 
_Radius("Radius", Float) = 100 
_RadiusColor("Radius Color", Color) = (1,0,0,1) 
_RadiusWidth("Radius Width", Float) = 10</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Add their respective variables to the <kbd class="calibre13">CGPROGRAM</kbd> section, remembering to remove the declaration of <kbd class="calibre13">_Glossiness</kbd> and <kbd class="calibre13">_Metallic</kbd>:</li>
</ol>
<pre class="calibre18">float3 _Center; 
float _Radius; 
fixed4 _RadiusColor; 
float _RadiusWidth; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12"><kbd class="calibre13">Input</kbd> to our surface function requires not only the UV of the texture but also the position (in world coordinates) of every point of the terrain. We can retrieve this parameter by changing the <kbd class="calibre13">struct Input </kbd> as follows:</li>
</ol>
<pre class="calibre18">struct Input 
{ 
  float2 uv_MainTex; // The UV of the terrain texture 
  float3 worldPos;   // The in-world position 
}; </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Lastly, we use this surface function:</li>
</ol>
<pre class="calibre18">void surf(Input IN, inout SurfaceOutputStandard o) <br class="title-page-name"/>{<br class="title-page-name"/>  // Get the distance between the center of the <br class="title-page-name"/>  // place we wish to draw from and the input's <br class="title-page-name"/>  // world position<br class="title-page-name"/>  float d = distance(_Center, IN.worldPos);<br class="title-page-name"/><br class="title-page-name"/>  // If the distance is larger than the radius and<br class="title-page-name"/>  // it is less than our radius + width change the color<br class="title-page-name"/>  if ((d &gt; _Radius) &amp;&amp; (d &lt; (_Radius + _RadiusWidth)))<br class="title-page-name"/>  {<br class="title-page-name"/>    o.Albedo = _RadiusColor;<br class="title-page-name"/>  }<br class="title-page-name"/>  // Otherwise, use the normal color<br class="title-page-name"/>  else<br class="title-page-name"/>  {<br class="title-page-name"/>    o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">These steps are all it takes to draw a circle on your terrain. You can use the material's Inspector tab to change the position, radius, and color of the circle:</p>
<div><img src="img/00076.jpeg" class="calibre25"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Moving the circle</h1>
                
            
            
                
<p class="calibre3">This is great, but you'll likely also want to change where the circle is at run-time, which we can do via code. If you want the circle to follow your character, other steps are necessary:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new C# script called <kbd class="calibre13">SetRadiusProperties</kbd>.</li>
<li value="2" class="calibre12">Since you may wish to see this change both in the game and outside, we can add a tag to the top of the class saying to execute this code while in the editor, in addition to when the game is being played, by adding the following tag:</li>
</ol>
<pre class="calibre18"><strong class="calibre1">[ExecuteInEditMode]</strong><br class="title-page-name"/>public class SetRadiusProperties : MonoBehaviour</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Add these properties to the script:</li>
</ol>
<pre class="calibre18">public Material radiusMaterial; 
public float radius = 1; 
public Color color = Color.white; </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">In the <kbd class="calibre13">Update()</kbd> method, add these lines of code:</li>
</ol>
<pre class="calibre18">if(radiusMaterial != null)<br class="title-page-name"/>{<br class="title-page-name"/>    radiusMaterial.SetVector("_Center", transform.position);<br class="title-page-name"/>    radiusMaterial.SetFloat("_Radius", radius);<br class="title-page-name"/>    radiusMaterial.SetColor("_RadiusColor", color);<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Attach the script to the object you wish to have the circle drawn around.</li>
<li value="6" class="calibre12">Finally, drag the <kbd class="calibre13">RadiusMat</kbd> material to the Radius Material slot of the script:</li>
</ol>
<div><img src="img/00077.jpeg" class="calibre25"/></div>
<p class="calibre3">You can now move your character around and this will create a nice circle around it. Changing the properties of the <kbd class="calibre13">Radius</kbd> script will change the radius as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            
                
<p class="calibre3">The relevant parameters to draw a circle are its center, radius, and color. They are all available in the shader with the names <kbd class="calibre13">_Center</kbd>, <kbd class="calibre13">_Radius</kbd>, and <kbd class="calibre13">_RadiusColor</kbd>. By adding the <kbd class="calibre13">worldPos</kbd> variable to the <kbd class="calibre13">Input</kbd> structure, we are asking Unity to provide us with the position of the pixel that we are drawing expressed in world coordinates. This is the actual position of an object in the editor.</p>
<p class="calibre3">The <kbd class="calibre13">surf()</kbd> function is where the circle is actually drawn. It calculates the distance from the point being drawn and the center of the radius, and then it checks whether it is between <kbd class="calibre13">_Radius</kbd> and <kbd class="calibre13">_Radius + _RadiusWidth</kbd>; if this is the case, it uses the chosen color. In the other case, it just samples the texture map like all the other shaders we have seen so far.</p>


            

            
        
    </body></html>