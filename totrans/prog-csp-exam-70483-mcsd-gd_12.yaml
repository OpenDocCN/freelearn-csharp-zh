- en: Performing Symmetric and Asymmetric Encryption
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行对称和不对称加密
- en: While working on distributed applications, it is very important to keep information
    secure, in particular, in the case of eCommerce applications, where user data,
    such as your personal and credit card-related information, is collected and transmitted
    over the internet. Cryptography enables us to encrypt and decrypt plain text.
    To understand it in simple terms, let's suppose that there is plain text in our
    application that can be transformed by adding a static value to each character
    in the text, thereby rendering it non-readable. This process is called **encryption**.
    Conversely, decryption is the process of transforming this unreadable text back
    into readable text.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发分布式应用程序时，保持信息的安全非常重要，特别是在电子商务应用程序的情况下，用户数据，如您的个人和信用卡相关信息，被收集并通过互联网传输。密码学使我们能够加密和解密明文。简单来说，假设我们的应用程序中有明文，可以通过向文本中的每个字符添加一个静态值来转换它，从而使它变得不可读。这个过程称为**加密**。相反，解密是将这种不可读文本转换回可读文本的过程。
- en: When you encrypt text, it looks like random bytes, and is called **cipher-text**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当您加密文本时，它看起来像随机的字节，被称为**密文**。
- en: After reading this chapter, you will be able to understand how to encrypt and
    decrypt text, the different algorithms that are available to perform these encrypt
    and decrypt operations, and the options that .NET Framework affords us in terms
    of their application to actual projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将能够理解如何加密和解密文本，执行这些加密和解密操作的不同算法，以及.NET Framework在将它们应用于实际项目方面提供的选项。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Cryptography
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学
- en: Symmetric encryption
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称加密
- en: Asymmetric encryption
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Digital signatures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名
- en: Hash values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希值
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and
    above require Visual Studio 2017.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习可以使用支持.NET Framework 2.0或更高版本的Visual Studio 2012或更高版本进行练习。然而，任何从C# 7.0及更高版本开始的新C#功能都需要Visual
    Studio 2017。
- en: If you don't have a license for any of the products, you can download the community
    version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有任何产品的许可证，您可以从[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)下载Visual
    Studio 2017的社区版本。
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12)。
- en: Cryptography
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: When working with public networks involved with creating and managing web applications
    that are accessible over the internet, your application is at high risk of being
    intercepted and modified by unauthorized parties. Cryptography allows us to protect
    data from such unauthorized parties from being viewed or modified. Cryptography
    also provides ways to protect our data and assists in the transfer of data securely
    over the network. To perform such operations, we can use encryption algorithms
    to create cipher data prior to transmission. When intercepted by unauthorized
    parties, it will be difficult for them to decrypt this in order to read or modify
    this data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与涉及创建和管理可通过互联网访问的Web应用程序的公共网络一起工作时，您的应用程序面临被未经授权的第三方拦截和修改的高风险。密码学使我们能够保护数据免受此类未经授权的第三方查看或修改。密码学还提供了保护我们的数据并帮助在网络上安全传输数据的方法。要执行此类操作，我们可以使用加密算法在传输之前创建密文。当被未经授权的第三方拦截时，他们很难解密以读取或修改这些数据。
- en: 'To perform such operations, .NET framework is shipped with the `System.Secure.Cryptography`
    namespace, which comes with many algorithms, including the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此类操作，.NET框架提供了`System.Secure.Cryptography`命名空间，其中包含许多算法，包括以下内容：
- en: Secret key encryption
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密密钥加密
- en: Public key encryption
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥加密
- en: Digital signatures
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字签名
- en: Hash values
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希值
- en: Let's jump into an example regarding where cryptography can be used. Suppose,
    as a customer, that I am trying to place an order for a laptop over the internet.
    For this, I am chatting with the company's representative. Once I am sufficiently
    satisfied with the quote, the discount offered, and the terms and conditions to
    place an order, I then need to provide personal and credit card information via
    this channel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个关于加密可以用于哪些方面的例子。假设，作为一个客户，我正在尝试通过互联网订购一台笔记本电脑。为此，我正在与公司的代表聊天。一旦我对报价、提供的折扣和下订单的条款和条件感到满意，我然后需要通过这个渠道提供个人信息和信用卡信息。
- en: So, how can we ensure the following in this regard?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何确保以下方面的内容呢？
- en: That this information is unclear for anyone listening in on our conversation
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对任何窃听我们对话的人来说，这些信息是不清晰的
- en: That there was no unauthorized access to the information transferred
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息传输没有未经授权的访问
- en: That the information received is from the company's representative
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收到的信息来自公司的代表
- en: All of this can be achieved with the implementation of cryptographic algorithms.
    These algorithms facilitate confidentiality, data integrity, authentication, and
    non-repudiation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过实现加密算法来实现。这些算法促进了保密性、数据完整性、身份验证和非否认性。
- en: Confidentiality protects the identity of users, data integrity protects data
    from being changed, authentication ensures that data is from an authenticated
    party, and non-repudiation prevents any party from denying that a message was
    sent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性保护用户的身份，数据完整性保护数据免受更改，身份验证确保数据来自已验证的实体，非否认性防止任何一方否认发送了消息。
- en: .NET Framework provides different algorithms, as mentioned earlier. Although
    these are numerous, we will limit our discussion to four major ones in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架提供了不同的算法，如前所述。尽管这些很多，但我们将限制本章的讨论到四个主要算法。
- en: Secret-key encryption, which is also referred to as symmetric encryption, uses
    a single shared key to encrypt and decrypt data. In this regard, however, it is
    important to keep the secret information safe from unauthorized access because
    anyone in possession of this key can then access the data and misuse it. Because
    it uses the same key for both encryption and decryption, this works faster and
    is suitable for large amounts of data. There are different types of algorithm
    available, such as **DES** (short for **Data Encryption Standard**), triple DES,
    and **AES** (short for **Advanced Encryption Standard**). These algorithms encrypt
    blocks of data simultaneously, so they are also referred to as block ciphers.
    DES and Triple DES use 8 bytes as a block, while AES uses 16 bytes as a block,
    but also supports 24 and 32 bytes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥加密，也称为对称加密，使用单个共享密钥来加密和解密数据。然而，在这种情况下，保护秘密信息免受未经授权的访问非常重要，因为任何拥有这个密钥的人都可以访问数据并滥用它。因为它使用相同的密钥进行加密和解密，所以这更快，适合大量数据。有不同类型的算法可用，例如**DES**（代表**数据加密标准**），三重DES和**AES**（代表**高级加密标准**）。这些算法同时加密数据块，因此它们也被称为分组密码。DES和三重DES使用8字节作为块，而AES使用16字节作为块，但也支持24和32字节。
- en: Public-key encryption, also referred to as asymmetric encryption, uses public/private
    keys to encrypt and decrypt data. Of these two keys, the private key must be kept
    secret from unauthorized access, as anyone with the private key can access your
    data. Public and private keys in this encryption technique are mathematically
    linked and use a fixed buffer size. These are slow compared to secret key encryption,
    and are useful for encrypting small amounts of data. Any data encrypted using
    a public key can only be decrypted using a private key. Also, if you sign data
    using a private key, it can only be verified using a public key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密，也称为非对称加密，使用公钥/私钥来加密和解密数据。在这两个密钥中，私钥必须保密，防止未经授权的访问，因为任何拥有私钥的人都可以访问你的数据。在这种加密技术中，公钥和私钥在数学上是相关的，并使用固定缓冲区大小。与密钥加密相比，这些更慢，适用于加密少量数据。使用公钥加密的任何数据只能使用私钥解密。此外，如果你使用私钥签名数据，它只能使用公钥验证。
- en: Digital signing uses digital signatures that are unique to that party. As mentioned
    in public key encryption, a party can sign the data using a private key and, when
    the other party receives information and when the public key of the sending party
    is trusted, you can identify who sent the message and, in turn, maintain the integrity
    of the data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名使用该方独有的数字签名。如公开密钥加密中提到的，一方可以使用私钥签名数据，当另一方收到信息并且发送方的公钥被信任时，你可以识别谁发送了消息，从而维护数据的完整性。
- en: Since the public key of the sending party is public, anyone in possession of
    the public key can process the message, meaning that your message is not secret.
    To keep it secret, you also need to encrypt the message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送方的公钥是公开的，任何拥有公钥的人都可以处理消息，这意味着您的消息不是秘密的。为了保持其秘密性，您还需要加密消息。
- en: Hash values map data of any length to a fixed-length byte sequence. When you
    have a block of text and change it prior to rehashing, it will produce a new hash.
    This way, we can maintain data integrity during transfer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值将任意长度的数据映射到固定长度的字节序列。当你有一段文本并在重新哈希之前更改它时，它将产生一个新的哈希。这样，我们可以在传输过程中保持数据完整性。
- en: However, as has been discussed in relation to other cryptographic methods, this
    method does not authenticate the sender of the message.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如在讨论其他加密方法时提到的，这种方法并不验证消息的发送者。
- en: Symmetric encryption
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密
- en: Symmetric encryption uses a single key and works on blocks of text. This method
    works quicker than others. While using this method, it is important to maintain
    the confidentiality of the secret key, and both the sender and receiver should
    use the same key, which is a disadvantage of this method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密使用单个密钥，并在文本块上工作。这种方法比其他方法更快。在使用此方法时，保持密钥的机密性非常重要，发送者和接收者应使用相同的密钥，这是此方法的缺点。
- en: 'Let''s look at an example and understand how we can encrypt a message or block
    of text:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，了解我们如何加密消息或文本块：
- en: Here, we use the encrypt method, where we read a block of text from a file,
    encrypt it using a symmetric algorithm, and write the encrypted content to a different
    file.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们使用加密方法，从文件中读取一段文本，使用对称算法对其进行加密，并将加密内容写入不同的文件。
- en: The encrypt method accepts an instance of `SymmetricAlgorithm`, which is used
    to create an instance of `ICryptoTransform` by passing a key and initial vector.
    The system allows you to generate your own key or use the one it generates.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密方法接受一个`SymmetricAlgorithm`实例，该实例通过传递密钥和初始向量创建一个`ICryptoTransform`实例。系统允许您生成自己的密钥或使用它生成的密钥。
- en: 'Then, we create a memory stream to store the buffer at runtime:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个内存流来存储运行时的缓冲区：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A cryptostream is created using the memory stream, `ICryptoTransform`, along
    with the write mode. A cryptostream is used to write to memory, which can then
    be converted into an array and written to an output file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存流、`ICryptoTransform`以及写入模式创建了一个cryptostream。cryptostream用于写入内存，然后可以将其转换为数组并写入输出文件。
- en: Once you execute the encrypt method, you can now open the output file from the
    solution and check the results.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行加密方法后，现在您可以打开解决方案中的输出文件并检查结果。
- en: 'Now, we will read the data from the output file and decrypt it to plain text:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从输出文件中读取数据并将其解密为纯文本：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The decrypt method uses the same signature as the encrypt method. However, instead
    of creating an `encryptor` class, we create a `decryptor` class, which implements
    the `ICryptoTransform` interface.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 解密方法与加密方法具有相同的签名。然而，我们不是创建一个`encryptor`类，而是创建一个`decryptor`类，该类实现了`ICryptoTransform`接口。
- en: 'The following is the main program, where we create `SymmetricAlgorithm` of
    the `AESManaged` instance type, and then pass it to the encrypt and decrypt methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们创建的main程序，其中我们创建`AESManaged`实例类型的`SymmetricAlgorithm`，然后将其传递给加密和解密方法：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before executing the program, check the input file in the solution where you
    can change the content and execute it. Following encryption, the output file in
    the solution can be verified for the encrypted content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行程序之前，请检查解决方案中的输入文件，您可以在其中更改内容并执行它。加密后，可以验证解决方案中的输出文件中的加密内容：
- en: '![](img/8e6106fb-9c05-4d06-8682-c8aff8eb3d9e.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e6106fb-9c05-4d06-8682-c8aff8eb3d9e.png)'
- en: When you practice this example, make sure that you have all the helper methods
    in one class, and the main method in another class, as specified in the sample
    code on GitHub. Now that you have all the methods, when you execute them, you
    see the preceding output.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你练习这个示例时，确保所有辅助方法在一个类中，主方法在另一个类中，如GitHub上的示例代码所指定。现在你有了所有方法，当你执行它们时，你会看到前面的输出。
- en: Your encryption method uses the AES algorithm. It reads data from the input
    file, encrypts data using the AES algorithm, and then writes a message on the
    screen. Once you press any key, your decrypt method is initiated, decrypts the
    message, and writes to the output file. The same message is displayed on screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你的加密方法使用AES算法。它从输入文件读取数据，使用AES算法加密数据，然后在屏幕上写一条消息。一旦你按下任意键，你的解密方法就会被启动，解密消息并将其写入输出文件。相同的信息会在屏幕上显示。
- en: In a real-time scenario, when you want to perform secure transactions using
    file transfers, this is one way to do so. Because you will be using symmetric
    algorithms, it will be easy to encrypt or decrypt the content.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时场景中，当你想通过文件传输执行安全交易时，这是其中一种方法。因为你将使用对称算法，所以加密或解密内容将很容易。
- en: A sender encrypts the content of the file and sends it to the receiver. The
    receiver decrypts the file content and processes it. In this method, both the
    sender and receiver should be aware of the key used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者加密文件的内容并发送给接收者。接收者解密文件内容并对其进行处理。在此方法中，发送者和接收者都应该知道所使用的密钥。
- en: Asymmetric encryption
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Asymmetric encryption uses two keys—a public key and a private key. Because
    of this, it runs bit slowly. Also, it is necessary to keep the private key safe
    at all times. Unless you have the private key, you cannot decrypt the message.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密使用两个密钥——一个公钥和一个私钥。正因为如此，它的运行速度较慢。此外，必须始终确保私钥的安全。除非你有私钥，否则你不能解密消息。
- en: 'Now, let''s jump into an example and try to understand how this is done. In
    this scenario, we will be using `RSACryptoServiceProvider`. This algorithm provides
    us with public and private keys that can be used to encrypt and decrypt messages.
    The encrypt method accepts a public key and text to encrypt, and we then convert
    the text to a byte array since the encrypt method accepts byte arrays. Then, we
    set the public key for the algorithm and invoke the encrypt method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入一个示例，尝试了解这是如何完成的。在这个场景中，我们将使用`RSACryptoServiceProvider`。此算法为我们提供了可用于加密和解密消息的公钥和私钥。加密方法接受一个公钥和要加密的文本，然后我们将文本转换为字节数组，因为加密方法接受字节数组。然后，我们为算法设置公钥并调用加密方法：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the decrypt method, we pass the byte array that needs to be decrypted along
    with a private key. Once a message is encrypted using a public key, it can only
    be decrypted using its corresponding private key:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在解密方法中，我们传递需要解密的字节数组以及一个私钥。一旦使用公钥加密了一条消息，它只能使用对应的私钥进行解密：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the main method, where we create the `RSACryptoproviderservice`
    class to get public and private keys. `rsa.ToXmlString(false)` provides a public
    key, and setting it to `true` will give us a private key. We will use these keys
    to encrypt and decrypt messages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为主要方法，其中我们创建`RSACryptoproviderservice`类以获取公钥和私钥。`rsa.ToXmlString(false)`提供公钥，将其设置为`true`将给我们私钥。我们将使用这些密钥来加密和解密消息：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the program by changing the input text, or you can try changing the
    algorithm. However, when you change the algorithm, you may need to apply any syntactical
    changes that are required in order for the program to run and work:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改输入文本来执行程序，或者你可以尝试更改算法。然而，当你更改算法时，你可能需要应用程序运行和工作所需的任何语法更改：
- en: '![](img/133e0fd4-14f3-414a-8909-1289f9e6d1db.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/133e0fd4-14f3-414a-8909-1289f9e6d1db.png)'
- en: When you execute the program, you see the preceding output. In the sample, you
    are using an asymmetric algorithm to encrypt content. As the control flows through
    the code, it display messages. Once the message is encrypted, it will ask you
    to press any key. Upon pressing any key, the program decrypts the message and
    displays it on screen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，你会看到前面的输出。在示例中，你正在使用非对称算法加密内容。随着控制流通过代码，它显示消息。一旦消息被加密，它将要求你按任意键。按下任意键后，程序将解密消息并在屏幕上显示。
- en: In the scenario that we discussed under symmetric algorithms, where you want
    to perform secure transactions between two parties, you can use public-private
    key combinations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的对称算法场景中，如果您想在两个当事人之间进行安全交易，您可以使用公私钥组合。
- en: A receiver performs encryption using a private key and sends the file or block
    of text to the receiver, where a public key is used to decrypt the content. In
    the event the public-private keys do not match, you cannot read or validate the
    data. This is one way to validate input data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者使用私钥进行加密，并将文件或文本块发送给接收者，在那里使用公钥来解密内容。如果公钥和私钥不匹配，您将无法读取或验证数据。这是验证输入数据的一种方式。
- en: Digital signatures
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字签名
- en: Digital signatures can be used to sign the message that will authenticate the
    sender. However, signing a message doesn't prevent a third party from reading
    the message. To achieve this, we need to encrypt the message and sign it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名可以用来签名消息，从而验证发送者。然而，签名消息并不能防止第三方读取消息。为了实现这一点，我们需要加密消息并对其进行签名。
- en: In the following example, we are using a public key and a private key (asymmetric
    algorithm). We use the sender's private key to sign the message and the receiver's
    public key to encrypt the message. If you observe the code, we also use hash computing
    in this example. After encrypting the message, we hash the message.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用公钥和私钥（非对称算法）。我们使用发送者的私钥对消息进行签名，并使用接收者的公钥加密消息。如果您观察代码，我们在这个示例中也使用了哈希计算。在加密消息后，我们再次对消息进行哈希处理。
- en: We are going to use `RSACryptoServiceProvider`, along with `RSAPKCS1SignatureFormatter`,
    which will be used to create a signature.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`RSACryptoServiceProvider`，以及`RSAPKCS1SignatureFormatter`，它将被用来创建签名。
- en: In the following program, we convert text to a byte array using `UnicodeEncoding`
    classes, encrypt the message using the receiver's public key and the symmetric
    or asymmetric algorithms we learned in previous sections, compute the hash of
    the content, and then digitally sign the message. Once all of these processes
    have been implemented, we transmit the data across, where we recompute the hash,
    verify the signature, and then decrypt the message using the keys.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中，我们使用`UnicodeEncoding`类将文本转换为字节数组，使用接收者的公钥和我们在前几节中学到的对称或非对称算法加密消息，计算内容的哈希值，然后对消息进行数字签名。一旦所有这些过程都得到实现，我们就将数据传输过去，在那里我们重新计算哈希值，验证签名，然后使用密钥解密消息。
- en: 'In the following example, we are using public-private keys to perform encryption.
    As mentioned previously, simply signing the message doesn''t secure the content
    of the message. Instead, it will allow you to authenticate the sender:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用公私钥进行加密。如前所述，仅仅签名消息并不能保证消息内容的安全。相反，它将允许您验证发送者：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following is the main program, where we create an instance of the `RSACryptoServiceProvider`
    class and collect public and private keys. However, as we are encrypting and decrypting
    the message in the same method, a single set of public and private keys was used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为主要程序，其中我们创建`RSACryptoServiceProvider`类的实例并收集公钥和私钥。然而，由于我们在同一方法中加密和解密消息，因此使用了同一套公钥和私钥。
- en: 'As part of this example, we perform both encryption and decryption. We can
    create multiple RSA providers and use their public-private keys for senders and
    receivers. You can create different console applications, one as a sender and
    the other as a receiver, and simulate a real-world scenario. For simplicity''s
    sake, I have used one pair of public-private keys to perform operations:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本示例的一部分，我们执行了加密和解密。我们可以创建多个RSA提供者，并使用它们的公私钥作为发送者和接收者。您可以创建不同的控制台应用程序，一个作为发送者，另一个作为接收者，并模拟现实世界场景。为了简化起见，我使用了一对公私钥来执行操作：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check the output by changing the input message and algorithms. However, as
    said earlier, you may need to take care of any syntactical changes before executing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改输入消息和算法来检查输出。然而，如前所述，在执行之前，您可能需要注意任何语法上的变化：
- en: '![](img/5c7417d1-6458-4e10-96b3-5291bbeba425.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c7417d1-6458-4e10-96b3-5291bbeba425.png)'
- en: In a real-world scenario, suppose two entities are communicating via web services
    where such digital signatures are implemented. The sender will have a set of public
    and private keys, and the receiver will have public and private keys. Both parties
    should exchange their respective public keys to facilitate application communication.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，假设两个实体通过实现数字签名的Web服务进行通信。发送者将有一组公钥和私钥，接收者也将有一组公钥和私钥。双方应交换各自的公钥以促进应用程序通信。
- en: Hash values
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希值
- en: Computing a hash creates a fixed-length numeric value from a byte array. A hash
    maps a variable-length binary string to a fixed-length binary string. A hash cannot
    be used for two-way conversion. When you apply a hash algorithm, each character
    gets hashed into a different binary string.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 计算哈希从字节数组创建一个固定长度的数值。哈希将可变长度的二进制字符串映射到固定长度的二进制字符串。哈希不能用于双向转换。当你应用哈希算法时，每个字符都会被哈希到一个不同的二进制字符串。
- en: In the following example, we use the `SHA1Managed` algorithm to compute the
    hash. We compute the hash twice to check whether the result is the same. As mentioned
    earlier, this method is used to maintain data integrity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用`SHA1Managed`算法来计算哈希。我们计算哈希两次以检查结果是否相同。如前所述，此方法用于维护数据完整性。
- en: 'In the following code, we are using the `UnicodeEncoding` class to convert
    the text to a byte array, and the `SHA1Managed` algorithm to compute the hash
    for the byte array. Once converted, we display each and every hashed byte on the
    screen. To validate the hash, we recompute the hash on the string and compare
    the hash values. This is one way to validate input data:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们使用`UnicodeEncoding`类将文本转换为字节数组，并使用`SHA1Managed`算法计算字节数组的哈希。一旦转换，我们将在屏幕上显示每个哈希字节。为了验证哈希，我们重新计算字符串的哈希并比较哈希值。这是验证输入数据的一种方法：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main method for invoking the hash value example is as follows. Here, we
    just call the helper method that performs the hash compute on the text provided:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 调用哈希值示例的主要方法如下。在这里，我们只是调用一个辅助方法，它对提供的文本执行哈希计算：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we compute the hash, we display the result and then we undertake a comparison
    to see whether the result from both calls is the same:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计算哈希时，我们显示结果，然后我们进行对比以查看两次调用的结果是否相同：
- en: '![](img/1e9da11f-81c9-4994-8f5c-cd99d45b3573.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e9da11f-81c9-4994-8f5c-cd99d45b3573.png)'
- en: The preceding screenshot shows the program where you compute the hash and display
    the hashed array. Also, when the program recomputes the hash and effects a comparison,
    you see the same hash value message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了计算哈希并显示哈希数组的程序。此外，当程序重新计算哈希并进行比较时，你会看到相同的哈希值消息。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on understanding cryptography and how we can use
    symmetric and asymmetric algorithms. We also focused on how we can use these to
    validate senders, receivers, and the content of messages. We can use the techniques
    learned in the chapter to validate input data and perform similar operations when
    working with secure transactions. We also looked at how we can sign messages using
    digital signatures, and how can we maintain data integrity using hash values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于理解密码学以及我们如何使用对称和非对称算法。我们还关注了如何使用这些算法来验证发送者、接收者和消息内容。我们可以利用本章学到的技术来验证输入数据，并在处理安全交易时执行类似操作。我们还探讨了如何使用数字签名来签名消息，以及如何使用哈希值来维护数据完整性。
- en: In the next chapter, we will focus on .NET assemblies, how we can manage them,
    and how we can debug C# applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注.NET程序集，我们将如何管理它们，以及我们将如何调试C#应用程序。
- en: Questions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Out of the four methods discussed in this chapter, which two can be used to
    authenticate the sender?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章讨论的四种方法中，哪两种可以用来验证发送者？
- en: Symmetric algorithm
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称算法
- en: Asymmetric algorithm
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非对称算法
- en: Hash values
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希值
- en: Digital signatures
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字签名
- en: When two parties need to communicate using an asymmetric algorithm, which key
    do they need to share?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个实体需要使用非对称算法进行通信时，他们需要共享哪个密钥？
- en: Private key
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私钥
- en: Public key
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公钥
- en: Both
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者
- en: None
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无
- en: Which type of algorithm is used to encrypt large amounts of data?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的算法用于加密大量数据？
- en: Symmetric
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称
- en: Asymmetric
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非对称
- en: Both
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者
- en: None
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无
- en: Answers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**Digital signatures**'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数字签名**'
- en: '**Public key**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**公钥**'
- en: '**Symmetric**'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对称**'
