- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Intricacies of Rolling Out TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have frequently seen developers putting their efforts into trying to convince
    the business to follow TDD or adopt unit tests. In fact, this is a situation in
    which I have often found myself, and for this reason, I want to share my experience
    with you in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book, you might feel strongly about implementing TDD in your
    direct team or large organization to reap the quality benefits. So far, so good.
    The second stage is doing this in a structured manner and being prepared for the
    business’ counter-arguments and rejections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will highlight the challenges and guide you through the process of convincing
    your business and team to take the TDD approach. In this chapter, we will discuss
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Technical challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD arguments and misconceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be ready to present your team and/or business
    with a plan to move forward with TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Technical challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a set of technical and business challenges an organization must overcome
    before adopting TDD. Here, we will cover the technical challenges, and in the
    next section, we will consider the team challenges and then the wider organization
    challenges (business challenges). We will start with a diagram to explain the
    workflow of rolling out TDD in your organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Technical challenges when planning to move to TDD  ](img/Figure_13.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Technical challenges when planning to move to TDD
  prefs: []
  type: TYPE_NORMAL
- en: We will go through the diagram in the next sub-sections, so let’s start.
  prefs: []
  type: TYPE_NORMAL
- en: Greenfield or brownfield?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working on a brownfield project, the technical challenges were well
    presented in the previous chapter, so I will not go further into these challenges.
    To introduce TDD, you need to consider the effort, suitability, and alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: If you are starting a new project (a greenfield project), then you are in luck.
    You can go ahead with your plan.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today, with the availability of the cloud, having an infrastructure to run your
    **continuous integration** (**CI**) pipeline is easy and cheap. However, some
    organizations have restrictions on using the cloud and you might struggle to get
    a CI server.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have a CI server in place, then at the risk of sounding pessimistic,
    doing TDD is doomed to fail. This is because developers will break the unit tests
    and you will have them disabled or failing.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers also like to invest in tools such as **JetBrains ReSharper**
    for its good-quality test runner and refactoring capabilities, but this is optional.
    Also, you may want to consider JetBrains Rider as it has all the capabilities
    of ReSharper, as discussed in [*Chapter 1*](B18370_01.xhtml#_idTextAnchor014)
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are using MS Visual Studio Professional 2022 or later, you already
    have a good tool for a proper TDD process.
  prefs: []
  type: TYPE_NORMAL
- en: The technical challenges are not all you need to think about. Consider also
    your team and its readiness to embrace TDD and then your business challenges.
    Let’s continue with the team challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Team challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are a solo developer working on a project, no worries, you can do whatever.
    However, most business projects are implemented by a team, so making the effort
    to use TDD is a team decision. Again, let’s start with a workflow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Team challenges when planning to move to TDD  ](img/Figure_13.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Team challenges when planning to move to TDD
  prefs: []
  type: TYPE_NORMAL
- en: We will go through this diagram in the next sub-sections. Let’s go through the
    points to keep in mind when planning to move your team – whether you are a developer
    wanting to influence the team or in a position where you can enforce technical
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: Team experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing requires DI, which in turn requires experience in OOP. Your team
    members may be unfamiliar with unit testing or may mistake unit testing with integration
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: The xUnit and NUnit libraries are widely used to implement integration tests.
    Because they have the suffix **Unit**, developers sometimes incorrectly assume
    the written tests are unit tests. I’ve seen teams claiming they have unit tests,
    but when I inspected the code, I discovered otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: If your team requires training in TDD, then they need to be educated on what
    it is, how to do it, and the value of TDD. I have a book in mind to recommend
    for the training, but I will leave it to you to guess which it is.
  prefs: []
  type: TYPE_NORMAL
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: I usually ask the team to read certain material on their own before having a
    session or several sessions on the topic. Training a team can be done in many
    ways, and it is more related to your company and team culture. I also document
    the conventions and the agreement on Confluence or whatever tool the organization
    uses for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to have a competent developer in the team, who understands unit
    testing, is a good explainer, and can squeeze in some time, which could be you.
    This would be helpful, as your team will have questions when they start TDD.
  prefs: []
  type: TYPE_NORMAL
- en: But training the team may not be an option for many reasons. Having a few members
    of the team doing unit testing and others not won’t be productive, as everyone
    is going to operate on the same code base, so having everybody trained and ready
    for TDD is a prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: Willingness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some teams are not willing to do unit testing whether they feel it is difficult
    or increases development time or they don’t perceive the value.
  prefs: []
  type: TYPE_NORMAL
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: I have seen unit testing enforced by an organization, but the team was unwilling
    to write the tests, and they just created a unit test project with meaningless
    tests to tick the box of the question *Have you implemented unit testing?*.
  prefs: []
  type: TYPE_NORMAL
- en: Having the team synchronized with the objective and collaborating for one goal
    is valuable in promoting product quality.
  prefs: []
  type: TYPE_NORMAL
- en: If your team is not willing to go for TDD for whatever reason but unit testing
    is OK, then go for it! You can gently introduce TDD soon after. It doesn’t need
    to be all or nothing. It is also worth noting that some members can do TDD while
    others can do unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is useless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have heard this argument from many developers. They might have formed their
    opinion on bad implementations of unit testing or have other reasons. Certainly,
    unit testing has some disadvantages, but so do most technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Your best shot is to understand the reasons behind this misconception and see
    whether you can address them.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is useless, I would do unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD is controversial and sometimes developers have their own experiences that
    told them that TDD is unusable. This is OK as long as they are happy with unit
    testing because not all team members have to do TDD.
  prefs: []
  type: TYPE_NORMAL
- en: If the developers who don’t believe in unit tests are building their arguments
    on seeing bad practices, then your job might be to promote good practices.
  prefs: []
  type: TYPE_NORMAL
- en: The team’s willingness to follow TDD has a crucial impact on the success of
    the project, so it is important to have everybody on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Timing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD requires some preparations and extra effort to get the essential quality,
    following the *no pain, no gain* mantra. Having the right time is important and
    it should definitely not be near the release time or when the team is stressed.
  prefs: []
  type: TYPE_NORMAL
- en: The perfect time is at the start of the project, but there is no harm in introducing
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve passed the first and second challenges, you will have the business
    challenges, which are arguably the hardest.
  prefs: []
  type: TYPE_NORMAL
- en: Business challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The business here means a higher technical authority outside the team, who can
    enforce rules. Also, it can be the project manager or the product owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe that a successful rollout of TDD or unit testing comes from top to
    bottom, management-wise. Enforcement can come from:'
  prefs: []
  type: TYPE_NORMAL
- en: Head of development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team lead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical lead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IT auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is a personal initiative or a team initiative, the team might think
    of dropping it under delivery pressure. However, if they are responsible for providing
    unit tests as part of the delivery, including a coverage level, then it cannot
    be missed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think of TDD from the business perspective, so that we are better equipped
    and articulated in getting our points across.
  prefs: []
  type: TYPE_NORMAL
- en: Business benefits of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are well aware of what the benefits of TDD are from a technical point of
    view. But businesses would be more open to the benefits from the business point
    of view, so let’s get into it.
  prefs: []
  type: TYPE_NORMAL
- en: Fewer bugs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is clearly the biggest seller, as nobody likes bugs. Some businesses are
    stung by a high number of defects in their products, and having less is definitely
    a welcome promise.
  prefs: []
  type: TYPE_NORMAL
- en: The only issue is that it is hard to prove a lower number of bugs via statistics
    – the project will have unit tests from day one, so we can’t make a comparison
    between before and after.
  prefs: []
  type: TYPE_NORMAL
- en: Live documentation for the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing that worries the business is documentation, which has a tight relationship
    with developers’ turnover. The risk is that if a developer leaves, some of the
    business knowledge is lost. To prevent this situation, it is important to have
    the business rules robustly documented, and, in all honesty, I can’t think of
    any tool that is better for this than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Project documentation contains documents that cannot be covered by unit tests,
    such as project architecture. However, the detailed business rules that nobody
    will remember in a few months will be covered by unit tests and monitored with
    every developer source control push.
  prefs: []
  type: TYPE_NORMAL
- en: Promoting unit testing as a documentation tool is powerful and will give you
    listening ears from the business.
  prefs: []
  type: TYPE_NORMAL
- en: Fewer testing resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the old days, manual testing took a good chunk of the **software development
    life cycle** (**SDLC**). Today, with unit tests and other automated tests, manual
    testing has shrunk in size and the number of required manual testers has gone
    down. Some organizations have even eliminated manual testing completely in favor
    of having automated tests (including unit tests).
  prefs: []
  type: TYPE_NORMAL
- en: So, the promise of unit tests is about covering lots of edge cases and business
    rules with fewer testers and almost no regression test time.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Regression testing** is going through existing functionality to ensure it
    is still working. This typically happens before a new release.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, fewer testing resources means less cost, while less time means shipping
    a feature faster, which naturally leads us to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Ability to release in short cycles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development model today in more agile organizations has moved to shipping
    a few features now and then.
  prefs: []
  type: TYPE_NORMAL
- en: Having unit tests regressing the code with every change and a CI/CD system in
    place means your software is ready to be shipped anytime.
  prefs: []
  type: TYPE_NORMAL
- en: No clever business person will believe all these aforementioned benefits will
    come at no cost, so next, we will discuss the disadvantages of unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages from the business perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, extra quality requires more effort, and TDD is no different, but
    luckily the disadvantages are minimal.
  prefs: []
  type: TYPE_NORMAL
- en: Slight delay in the first release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have discussed before that teams not using TDD tend to deliver faster in
    the first period; we have spoken about this in [*Chapter 5*](B18370_05.xhtml#_idTextAnchor114),
    *Test-Driven Development Explained*. Here is a quick reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_13.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – TDD versus no unit testing
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that the effort of writing unit tests adds to the development
    time in the short term, but the speed becomes faster in the mid and long terms.
  prefs: []
  type: TYPE_NORMAL
- en: This is a small price to pay for quality, but just be aware of this point.
  prefs: []
  type: TYPE_NORMAL
- en: Delay in the first release is not acceptable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are circumstances where the business wants the first version as soon
    as possible and they are not interested in looking beyond this. Here are a few
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The product manager wants the first version out as soon as possible, as this
    can lead them to get a higher bonus or a promotion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a competitive advantage in releasing as soon as possible and not worrying
    about the future. This is the mentality of a start-up trying to survive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This project is done for a third party, and the business doesn’t get paid extra
    for ensuring added quality. But getting this in the shortest time possible is
    the intention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be clear if the business is not interested, and you can feel this in
    advance if you know the business model that the company uses. This is not a criticism
    against TDD, but it would become a disadvantage when mixed with such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through all the challenges and the merits of TDD, let’s
    form a plan to introduce TDD.
  prefs: []
  type: TYPE_NORMAL
- en: TDD arguments and misconceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are a few hints and tips – from my own experience – that will occur again
    and again in a conversation with the business or your colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing, not TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When discussing with the business, to reduce the complexity of the conversation,
    especially if the business is not tech-savvy, use the term unit testing rather
    than TDD. TDD is a technical process that individuals will do themselves and it
    is not directly related to the business, so why complicate the discussion by adding
    it? Sometimes the business has heard the term TDD, and they are excited about
    it, so then TDD is the right term to use!
  prefs: []
  type: TYPE_NORMAL
- en: My advice is to use unit testing in your conversation unless the business has
    some preference for the term TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is not implemented by testers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *testing* in unit testing is misleading to the non-techies as it implies
    a tester doing manual testing. I have had this conversation with many business
    individuals.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to clarify that unit testing has more functionality other than
    just testing, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Shaping the code design architecture of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live documenting the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instant feedback during development when breaking a business rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, unit tests are written in C# (or whatever other language you are using),
    and they are implemented by the same developer writing the code. A manual tester,
    most probably, won’t have the willingness or the expertise to write these tests.
  prefs: []
  type: TYPE_NORMAL
- en: This argument might be triggered when the business is wondering why you want
    to consume the engineers’ expensive time on unit testing when there are testers
    that could (as they initially thought) do the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The way for writing and maintaining documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am sure experienced business people will relate to the lack of documentation
    or the documentation becoming out of date.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, documenting the code with unit tests provides fresh documentation
    versus text-based stale documentation that is written and forgotten or covers
    part of the system (a hit and a miss). The keyword here is up-to-date, fresh,
    or live. Obviously, we are talking about part of the documentation and you might
    have to make this clear. This is the detailed business rules part.
  prefs: []
  type: TYPE_NORMAL
- en: We have incompetent developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Businesses sometimes believe they have incompetent developers, and this is why
    they are producing plenty of bugs. I have heard this argument whispered by the
    business on multiple occasions when talking about their team.
  prefs: []
  type: TYPE_NORMAL
- en: When I hear this argument, I quickly dig and discover that the business does
    not have a structure in place for the agile process and that the developers are
    rewarded for how fast they finish developing a feature. We all know that person
    who takes the shortest route to get their features done and show off to the business!
  prefs: []
  type: TYPE_NORMAL
- en: Developers are highly logical individuals who like structure and order. Having
    a development process with TDD will definitely reduce bugs and set things on track.
  prefs: []
  type: TYPE_NORMAL
- en: Your challenge here is to show how the TDD process and the tests will have a
    positive effect on the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter utilizes all the knowledge provided in this book and demonstrates
    the challenges of rolling out TDD into your organization. I hope I gave you enough
    arguments to convince the team and the business to subscribe to the TDD point
    of view.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this chapter, your presentation skills and familiarity with the subject
    will be highly useful when planning to roll out TDD.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I have endeavored to provide practical examples of real frameworks
    and tools that I’ve worked with, rather than using abstract and oversimplified
    examples. I wrote the book out of love and passion for the topic and I tried to
    stay pragmatic, and I hope I delivered what I aimed to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: While the title of this book refers to TDD, this book contains pragmatic examples
    of OOP and good programming practices, and by finishing the book, I trust you
    have stepped into the world of advanced software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Good luck and I would love to know how the book has contributed to you or your
    team adopting TDD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix 1: Commonly Used Libraries with Unit Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used two major libraries for unit testing across the book:'
  prefs: []
  type: TYPE_NORMAL
- en: xUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSubstitute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your team may be using these libraries already. Or you may have done a bit
    of experimentation with unit testing, and you want to expand your horizon into
    more libraries. While these libraries are popular, other libraries can replace
    them or work side by side with them. This appendix will skim through the following
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: MSTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluent Assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AutoFixture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these libraries use the MIT license, the most permissive license and you
    can install any of them via NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this appendix, you will be familiar with the libraries that form
    the ecosystem of unit testing in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1)'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen xUnit, and we have briefly spoken about MSTest and NUnit. This
    section will give you a feeling of what these other frameworks are about.
  prefs: []
  type: TYPE_NORMAL
- en: MSTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MSTest** used to be popular, as it was installed as part of **Visual Studio**
    (**VS**) in the older versions of VS. Prior to NuGet’s existence, using a *built-in*
    library could cut configuration and deployment time compared to adding and using
    another framework such as NUnit.'
  prefs: []
  type: TYPE_NORMAL
- en: Before NuGet, installing a new library involved manually copying DLLs, putting
    them in the right location, changing some configurations, and pushing them into
    source control for the team to share the same files. So, having a pre-installed
    library and one that didn’t require configuration, such as MSTest, was a blessing.
    We have moved a long way since then.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an MSTest project into your solution, you can do it via the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.1 – Adding MSTest via the UI ](img/Figure_A1.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A1.1 – Adding MSTest via the UI
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are two copies of the C# version. The bottom one is for the
    classical .NET Framework, and the top one is what we use with .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add MSTest via the `dotnet` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'MSTest and xUnit have similar syntax, so let me show you the code in xUnit
    and its equivalent in MSTest. I’ll start with xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent in MSTest is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can directly spot a few differences between the two code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test class in MSTest has to be decorated with `TestClass`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor in MSTest would work, but the standard way of initializing is
    to decorate a method with `TestInitialize`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both libraries use the `Assert` class name, but the method names in the class
    are different; for example, xUnit uses `Equal` and `True`, while MSTest uses `AreEqual`
    and `IsTrue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When doing multiple tests, xUnit and MSTest use different attributes. This
    code is in xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In MSTest, the equivalent code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can notice two differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Theory` becomes `DataTestMethod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InlineData` becomes `DataRow`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there isn’t much difference between the two libraries. Also,
    executing the test running, running the Test Explorer and other test activities
    other than the code stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: NUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NUnit** used to be the dominant library in the first decade of the two-thousands;
    it is still in use today, with xUnit becoming more prevalent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an NUnit project to your solution, you can do it via the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A1.2 – Adding NUnit via the UI ](img/Figure_A1.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A1.2 – Adding NUnit via the UI
  prefs: []
  type: TYPE_NORMAL
- en: Just like MSTest, NUnit has two copies of the .NET version. The bottom one is
    for the classical .NET Framework, and the top one is what we use with .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add NUnit via the `dotnet` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'NUnit and xUnit have similar syntax, so let me show you the code in NUnit and
    its equivalent in MSTest. I’ll start with xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent in MSTest is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can directly spot a few differences between the two code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor in NUnit would work, but the standard way of initializing is
    to decorate a method with `Setup`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both libraries use the `Assert` class name, but the method names in the class
    are different; for example, xUnit uses `Equal`, while NUnit uses `AreEqual`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The style of NUnit uses a fluent interface design, and the recommended approach
    to test equality is to use `That` and `Is.EqualTo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When doing multiple tests, xUnit and NUnit use different class names. This
    code is in xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In NUnit, the equivalent code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can notice that `InlineData` becomes `TestCase`. Besides this, there
    isn’t much difference between the two libraries, and their template is included
    in the default installation of VS 2022.
  prefs: []
  type: TYPE_NORMAL
- en: These three libraries are interchangeable, and the syntax changes are minimal.
    Once you are used to one, it will take minimal time to switch to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no shortage of mocking libraries in .NET; however, the top two used
    libraries are NSubstitute and Moq. We have covered plenty of examples of NSubstitute
    in this book, so let’s see how Moq works.
  prefs: []
  type: TYPE_NORMAL
- en: Moq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Moq** has the same role and same functionality, more or less, as NSubstitute.
    Given that the book was using NSubstitute, the fastest way to introduce Moq is
    to compare the two libraries. Let’s start with a snippet from NSubstitute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This snippet instantiates and creates a mock object from `IOpenWeatherService`
    and spies on the `lat` and `lon` input parameters of `OneCallAsync`. The idea
    is to ensure the two parameters passed to `GetForecastWeatherAnalysis` are passed
    without modification to the `OneCallAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the same code using Moq:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This Moq code doesn’t look much different from its NSubstitute rival. Let’s
    analyze the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: NSubstitute instantiates a mock object using the `Substitute.For` method, whereas
    Moq does it using `Mock.Of`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSubstitute uses extension methods such as `Returns` to configure the mock object,
    whereas Moq doesn’t use extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSubstitute uses `Args.Any` to pass parameters, whereas Moq uses `It.IsAny`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, while Moq favors syntax with lambda expressions, NSubstitute takes
    another route and uses extension methods. NSubstitute tries to make the code look
    as natural as possible and get out of the way by having less syntax, while Moq
    relies on the power of lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Moq has another way of creating a mock. I opted to show the modern version.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, using one library or another is a matter of style and syntax
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing helper libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have seen developers adding these two libraries to their unit tests to enhance
    the syntax and readability: **Fluent Assertions** and **AutoFixture**.'
  prefs: []
  type: TYPE_NORMAL
- en: Fluent Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fluent implementation, also known as a fluent interface, is trying to make
    the code read like an English sentence. Take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Some developers like to have the tests written in this way as it supports a
    more natural way of reading a test. Some like it for their own reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '`FluentAssertions` is a popular library that integrates with all popular test
    frameworks among MSTest, Nunit, and xUnit to enable fluent interfaces. You can
    add it to your unit test project via NuGet under the name `FluentAssertions`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how our code will be without and with the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But the previous snippet doesn’t show the true power of the library, so let’s
    do some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous snippet is an example of a fluent syntax, and the code is self-explanatory.
    To test this code, you will require a few lines of the standard `Assert` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is also self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While these code snippets show the power of `FluentAssertions`, asserting too
    many unrelated elements in a unit test is not recommended. These examples are
    for illustration only and do not focus on best unit testing practices.
  prefs: []
  type: TYPE_NORMAL
- en: These two code snippets are enough to show why some developers are fond of this
    syntax style. Now that you know about it, the choice of using such syntax is yours.
  prefs: []
  type: TYPE_NORMAL
- en: AutoFixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you have to generate data to populate an object. The object may be
    directly related to your unit test. Or maybe you just want to populate it for
    the rest of the unit to execute, but it is not the subject of the test. This is
    when **AutoFixture** comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write the tedious code to generate an object, or you can use `AutoFixture`.
    Let’s illustrate this with an example. Consider the following `record` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Populating this in the `Arrange` part of your unit test will increase the size
    of your unit test and distract the test from its real intention.
  prefs: []
  type: TYPE_NORMAL
- en: 'AutoFixture can create an instance of this class using the least amount of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an object of this class and populate it with random values.
    These are some of the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is the first level of the `OneCallResponse` class, but all
    the succeeding levels are also populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you want fine control of the generated data? Let’s say we want
    to generate the class, but with the `Daily` property having an array length of
    `8` rather than a random size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will generate everything randomly, but the `Daily` property will have eight
    array elements with random values.
  prefs: []
  type: TYPE_NORMAL
- en: This library has plenty of methods and customizations; this section only scratches
    the surface.
  prefs: []
  type: TYPE_NORMAL
- en: This appendix is a brief pointer to several libraries used for, or in conjunction
    with, unit testing. The intention here is to tell you these libraries exist and
    intrigue you to dig further if the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*xUnit*: [https://xunit.net](https://xunit.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MSTest*: [https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest](https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NUnit*: [https://nunit.org](https://nunit.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Moq*: [https://github.com/moq/moq4](https://github.com/moq/moq4%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fluent Assertions*: [https://fluentassertions.com](https://fluentassertions.com%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AutoFixture*: [https://github.com/AutoFixture](https://github.com/AutoFixture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appendix 2: Advanced Mocking Scenarios'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book has numerous examples of straightforward mocking scenarios. And the
    good news is, in a clean code environment, implementing most of those mocking
    requirements will be easy.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are times when you have to *innovate* a bit to be able to mock
    your desired class. I did not want to end this book without presenting you with
    a scenario, so here you go.
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix, we will experience how to combine a fake with a mock to deal
    with a .NET class called `HttpMessageHandler`. By the end of this appendix, you
    will be familiar with more NSubstitute functionalities and ready to tackle more
    advanced mocking cases.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing an OpenWeather client library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used the OpenWeather service in this book frequently, so I will give
    you a quick reminder – OpenWeather provides a set of RESTful APIs to bring you
    the weather and the forecast.
  prefs: []
  type: TYPE_NORMAL
- en: To consume the service from a C# application, it is good to have a library that
    will translate RESTful API calls to C# and shield the developer from the little
    details of HTTP. We call this sort of library a **RESTful client library** or
    sometimes a **software development kit** (**SDK**).
  prefs: []
  type: TYPE_NORMAL
- en: We will build an SDK for this service using TDD (of course!) and, while doing
    so, we will encounter more advanced mocking requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The One Call API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenWeather has an API called **One Call** that will get you today’s weather
    information and the forecast for the next few days. The best way to illustrate
    how this works is by using an example that gets the weather and the forecast for
    Greenwich, London.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, issue a RESTful `GET` request. You can use your browser for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the first two query string parameters are the latitude and the
    longitude of Greenwich, and the last one is your API key (which is omitted here).
    You will get a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a very long JSON output; it is around 21,129 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the solution skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have created a library and tested it frequently, so we will need to do the
    same here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a library project, call it `Uqs.OpenWeather`, and delete the sample class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an xUnit project and call it `Uqs.OpenWeather.Test.Unit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference from the test project to the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add NSubstitute from NuGet to the test project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the class and the filename in the unit test to `ClientTests.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your VS solution will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure A2.1 – Project skeleton’s Solution Explorer ](img/Figure_A2.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure A2.1 – Project skeleton’s Solution Explorer
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to write the first unit test with TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the implementation with TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this moment, you can open your `ClientTests.cs` and start your first test,
    which will drive the library’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to pass to a C# method, which we will call `OneCallAsync`, the two
    required parameters, `lat` and `lon`. This will then generate a URL with the right
    query string. So, our unit test class and the first unit test code will start
    to take shape, as shown in the following code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Given that the API key needs to be sent with every API call, the API key is
    to be in the constructor and not part of the method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Having the API key in the constructor will free the class’s consumer of having
    to fetch the API key to pass it to the method call. Instead, it will become the
    responsibility of the dependency injection setup to fetch the key, which makes
    more sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will definitely need the `HttpClient` class because your client will be
    using REST, and this is what you usually use with RESTful calls in .NET Core.
    However, when using this class, we may face the following challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` is a concrete class, and calling any method on it will lead to
    `HttpClient` issuing a call to the destination – this is the default behavior,
    but it can be tweaked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` doesn’t give us access to the generated URL, which is what we
    want in the current test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to figure out a way to intercept the call before `HttpClient` calls
    the destination (which is the actual third-party service) and get a hold of the
    generated URL for inspection. Of course, we also want to eliminate the outbound
    call as this is a unit test, and we don’t want to call the third party for real.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` can be passed an instance of `HttpMessageHandler` in the constructor,
    and then from `HttpMessageHandler` we can get hold of the generated URL by spying
    on `HttpMessageHandler.SendAsync` and eliminate the real call. But `HttpMessageHandler`
    is an abstract class, so we cannot instantiate it; we need to inherit from it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a child class from `HttpMessageHandler` and call it `FakeHttpMessageHandler`
    in your unit test project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a fake class that will allow us to get access to `HttpRequestMessage`.
    Now, our `Arrange` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We first created a response message, so any method call will return this empty
    object. This object will contain the third-party response when we run the real
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We have created a fake for `HttpMessageHandler`; we could have mocked it as
    well. Both work, and it is based on preference of what is more readable. Here
    I feel that having a fake `HttpMessageHandler` is easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the preceding implementation could be called a stub (rather than
    a fake) but I opted to refer to it as fake as it contains some real implementation.
    Sometimes there is a thin line between stubs and fakes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used NSubstitute to create a mock of the fake. The reason for that
    is we want to have access to `HttpRequestMessage`, which contains our final URL.
  prefs: []
  type: TYPE_NORMAL
- en: We have used `Substitute.ForPartsOf` rather than `Substitute.For` for the first
    time in this book, because `For` is not meant for concrete classes; the code will
    compile, but you will get a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We have always used `Substitute.For<ISomeInterface>` and this is what you would
    do in 95% of the cases. We have not created an instance of a concrete class. For
    concrete classes, without interfaces, you would use `ForPartsOf<SomeClass>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Assert` section becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to write the production code.
  prefs: []
  type: TYPE_NORMAL
- en: Fail then pass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code will fail to even compile as we have not created the production code,
    which will give us the TDD fail that we are looking for. Now, we shall do the
    minimal implementation that will pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run your test again, and it will pass.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve done a lot for this test, but other tests will flow easily as they will
    use the same fake that we’ve created. Let’s do a recap of what we’ve done.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a recap of all the important activities that we’ve done to make the
    first test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: We wanted to write a test that checks whether the URL is formed right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We had to get into the internals of `HttpClient` to get the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` doesn’t have the right methods to spy on the generated URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a fake `FakeHttpMessageHandler` that inherited `HttpMessageHandler`
    and passed it to `HttpClient` so we can reach the `HttpClient` internals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We mocked our fake `FakeHttpMessageHandler` and spied on the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We utilized a less-used method of NSubstitute for creating a mock, `Substitute.ForPartsOf`,
    which allowed us to mock a concrete class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We followed the standard TDD route of fail and pass to implement our production
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope this made the activities clearer. You have the full source code to inspect
    if this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: You will encounter similar advanced mocking scenarios in the future, so how
    do you attack them?
  prefs: []
  type: TYPE_NORMAL
- en: Investigating complex mocking scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like everything in a developer’s life, you will be able to find someone else
    who has encountered a similar mocking scenario to the one you are facing. Searching
    online for `access url HttpClient NSubstitute` would have given you the clues
    you needed to cut through the problem quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that most of the sophisticated mocking problems have already
    been sorted out, and the solutions have been published (thanks to all developers’
    hard work). You just need to understand the concept and incorporate it into your
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this appendix, we went through a more advanced but less frequent mocking
    scenario. It requires more fiddling and extra effort, but with experience in mocking,
    you will become familiar with these scenarios, and you will cut through them in
    no time.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to *OpenWeather’s*
    official website: [https://openweathermap.org](https://openweathermap.org)'
  prefs: []
  type: TYPE_NORMAL
