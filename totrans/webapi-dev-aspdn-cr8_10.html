<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-211"><a id="_idTextAnchor404"/>10</h1>
<h1 id="_idParaDest-212"><a id="_idTextAnchor405"/>Testing in ASP.NET Core (Part 2 – Integration Testing)</h1>
<p>In <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>, we learned how to write unit tests for a ASP.NET Core web API application. Unit tests are used to test code units in isolation. However, a code unit often depends on other components, such as the database, external services, and so on. To test the code thoroughly, we need to test the code units in the context of the application. In other words, we need to test how the code units interact with other parts of the application. This type of testing is called integration testing.</p>
<p>In this chapter, we will mainly focus on integration testing. We will cover the following topics:</p>
<ul>
<li>Writing integration tests</li>
<li>Testing with authentication and authorization</li>
<li>Understanding code coverage</li>
</ul>
<p>By the end of this chapter, you should be able to write integration tests for a ASP.NET Core web API application.</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor406"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</a>. You can use VS Code or VS 2022 to open the solutions.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor407"/>Writing integration tests</h1>
<p>In the unit tests, we create<a id="_idIndexMarker1019"/> the instances of the controllers directly. This approach does not consider some features of ASP.NET Core, such as routing, model binding, and validation and so on. To test the application thoroughly, we need to write integration tests. In this section, we <a id="_idIndexMarker1020"/>will write integration tests for the application.</p>
<p>Unlike unit tests, which<a id="_idIndexMarker1021"/> focus on isolated units, integration tests focus on the interactions between components. These integration tests may involve different layers, such as the database, the file system, the network, the HTTP request/response pipeline and so on. Integration tests ensure that the components of the application work together as expected. So, normally, integration tests use actual dependencies instead of mocks. Also, integration tests are slower than unit tests because they involve more components. Considering the cost of integration tests, we do not need to write too many integration tests. Instead, we should focus on the critical parts of the application. Most of the time, we can use unit tests to cover the other parts.</p>
<p>You can find the sample code of this section in the <code>IntegrationTestsDemo</code> folder. The code is based on the <code>InvoiceApp</code> project we created in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>. You can use VS 2022 or VS Code to open the solution. We will use the term <strong class="bold">System Under Test</strong> (<strong class="bold">SUT</strong>) to<a id="_idIndexMarker1022"/> refer to the ASP.NET Core web API application we are testi<a id="_idTextAnchor408"/>ng.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor409"/>Setting up the integration test project</h2>
<p>We can <a id="_idIndexMarker1023"/>continue to <a id="_idIndexMarker1024"/>use <strong class="bold">xUnit</strong> as the test framework for integration tests. A good practice is to create a separate integration test project from the unit test project. This approach allows us to run the unit tests and integration tests separately and also makes it easier to use different configurations for the two types of tests.</p>
<p>If you are using VS 2022, you can create a new xUnit project by right-clicking on the solution and selecting <code>InvoiceApp.IntegrationTests</code> and click <code>InvoiceApp.WebApi</code> project to allow the integration test project to access the classes in the web API project (see <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>).</p>
<p>If you are using <strong class="bold">.NET CLI</strong>, you can<a id="_idIndexMarker1025"/> create a new xUnit test project by running the following commands in the terminal:</p>
<pre class="console">
dotnet new xunit -n InvoiceApp.IntegrationTestsdotnet sln InvoiceApp.sln add InvoiceApp.IntegrationTests/InvoiceApp.IntegrationTests.csproj
dotnet add InvoiceApp.IntegrationTests/InvoiceApp.IntegrationTests.csproj reference InvoiceApp.WebApi/InvoiceApp.WebApi.csproj</pre>
<p>ASP.NET Core <a id="_idIndexMarker1026"/>provides a built-in test web host that we can use to host the SUT to handle the HTTP requests. The benefit of using a test web host is that we can use a different configuration for the test environment, and it also saves the network traffic because the HTTP requests are handled in the same process. So, the tests using a test web host are faster than those using a real web host. To use the test web host, we need to add the <code>Microsoft.AspNetCore.Mvc.Testing</code> NuGet package to the integration test project. You can add the package in VS 2022 by right-clicking on the project and selecting <code>Microsoft.AspNetCore.Mvc.Testing</code> and install the package.</p>
<p>You can also use the following command to add the package:</p>
<pre class="console">
dotnet add InvoiceApp.IntegrationTests/InvoiceApp.IntegrationTests.csproj package Microsoft.AspNetCore.Mvc.Testing</pre> <p>The default <code>UnitTest1.cs</code> file can be removed.</p>
<p>Feel free to <a id="_idIndexMarker1027"/>install <strong class="bold">FluentAssertions</strong> if you want to use it in the tests, as we demonstrated in the <em class="italic">Using FluentAssertions to verify the test results</em> section in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>.</p>
<p>Now we can start to write integratio<a id="_idTextAnchor410"/>n tests.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor411"/>Writing basic integration tests with WebApplicationFactory</h2>
<p>Let'sstart<a id="_idIndexMarker1028"/> with a simple integration test to check whether the SUT can correctly handle the HTTP requests. The sample application has a <code>WeatherForecastController.cs</code> controller that is provided by the ASP.NET Core project template. It returns a list of weather forecasts. We can write an integration test to check whether the controller returns the expected result.</p>
<p>Create a new file named <code>WeatherForecastApiTests</code> in the <code>InvoiceApp.IntegrationTests</code> project. Then add the following code to the file:</p>
<pre class="source-code">
public class WeatherForecastApiTests(WebApplicationFactory&lt;Program&gt; factory)    : IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;
{
}</pre>
<p>In the <a id="_idIndexMarker1029"/>test class, we use the <code>WebApplicationFactory&lt;T&gt;</code> type to create a test web host and use it as the class fixture. The instance of this class fixture will be shared across the tests in the class. The <code>WebApplicationFactory&lt;T&gt;</code> type is provided by the <code>Microsoft.AspNetCore.Mvc.Testing</code> package. It is a generic type that allows us to create a test web host for the specified application entry point. In this case, we use the <code>Program</code> class defined in the web API project as the entry point. But you will see an error that says <code>CS0122'Program' is inaccessible due to its protection level</code>. This is because the <code>Program</code> class is defined as <code>internal</code> by default.</p>
<p>To solve this issue, there are two ways:</p>
<ul>
<li>Open the <code>InvoiceApp.WebApi.csproj</code> file and add the following line to the file:<pre class="source-code">
&lt;ItemGroup&gt;     &lt;InternalsVisibleTo Include="MyTestProject" /&gt;&lt;/ItemGroup&gt;</pre><p class="list-inset">Replace <code>MyTestProject</code> with the name of your test project, such as <code>InvoiceApp.IntegrationTests</code>. This approach allows the test project to access the<a id="_idIndexMarker1030"/> internal members of the web API project.</p></li> <li>Alternatively, you can change the access modifier of the <code>Program</code> class to <code>public</code>. Add the following code to the end of the <code>Program.cs</code> file:<pre class="source-code">
public partial class Program { }</pre></li> </ul>
<p>You can use either approach to solve the issue. After that, we can write the test method, as follows:</p>
<pre class="source-code">
[Fact]public async Task GetWeatherForecast_ReturnsSuccessAndCorrectContentType()
{
    // Arrange
    var client = factory.CreateClient();
    // Act
    var response = await client.GetAsync("/WeatherForecast");
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    Assert.Equal("application/json; charset=utf-8", response.Content.Headers.ContentType.ToString());
    // Deserialize the response
    var responseContent = await response.Content.ReadAsStringAsync();
    var weatherForecast = JsonSerializer.Deserialize&lt;List&lt;WeatherForecast&gt;&gt;(responseContent, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    });
    weatherForecast.Should().NotBeNull();
    weatherForecast.Should().HaveCount(5);
}</pre>
<p>In the test <a id="_idIndexMarker1031"/>method, we first create an instance of the <code>HttpClient</code> class using the <code>WebApplicationFactory&lt;T&gt;</code> instance. Then we send an HTTP <code>GET</code> request to the <code>/WeatherForecast</code> endpoint. The <code>EnsureSuccessStatusCode</code> method ensures that the response has a status code in the <em class="italic">200-299</em> range. Then we check whether the content type of the response is <code>application/json; charset=utf-8</code>. Finally, we deserialize the response content to a list of <code>WeatherForecast</code> objects and check whether the list contains five items.</p>
<p>Because this controller does not have any dependencies, the test is simple. What if the controller has dependencies, such as a database context, other services, or other external dependencies? We will see how to handle these scenarios in the followi<a id="_idTextAnchor412"/>ng sections.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor413"/>Testing with a database context</h2>
<p>In the <a id="_idIndexMarker1032"/>sample application, the <code>ContactController</code> class has dependencies, such as the <code>IContactRepository</code> interface. The <code>ContactRepository</code> class implements this interface and uses the <code>InvoiceContext</code> class to access the database. So, if we want to test whether the SUT can correctly handle the HTTP requests, we need to create a test database and configure the test web host to use the test database. Similar to the unit tests, we can use a separate database for integration tests.</p>
<p>The <code>WebApplicationFactory&lt;T&gt;</code> type provides a way to configure the test web host. We can override the <code>ConfigureWebHost</code> method to configure the test web host. For example, we can replace the default database context with a test database context. Let us create a new <a id="_idIndexMarker1033"/>text fixture class named <code>CustomIntegrationTestsFixture</code> and add the following code to the class:</p>
<pre class="source-code">
public class CustomIntegrationTestsFixture : WebApplicationFactory&lt;Program&gt;{
    private const string ConnectionString = @"Server=(localdb)\mssqllocaldb;Database=InvoiceIntegrationTestDb;Trusted_Connection=True";
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // Set up a test database
        builder.ConfigureServices(services =&gt;
        {
            var descriptor = services.SingleOrDefault(d =&gt; d.ServiceType == typeof(DbContextOptions&lt;InvoiceDbContext&gt;));
            services.Remove(descriptor);
            services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;
            {
                options.UseSqlServer(ConnectionString);
            });
        });
    }
}</pre>
<p>In the preceding code, we override the <code>ConfigureWebHost()</code> method to configure the test web host for the SUT. When the test web host is created, the <code>Program</code> class will execute first, which means the default database context defined in the <code>Program</code> class will be created. Then the <code>ConfigureWebHost()</code> method defined in the <code>CustomIntegrationTestsFixture</code> class will be executed. So we need to find the default database context using <code>services.SingleOrDefault(d =&gt; d.ServiceType == typeof(DbContextOptions&lt;InvoiceDbContext&gt;))</code> and then remove it from the <a id="_idIndexMarker1034"/>service collection. Then we add a new database context that uses the test database. This approach allows us to use a separate database for integration tests. We also need to create the test database and seed some test data when we initialize the test fixture.</p>
<p>You can also add more customizations to the test web host in the <code>ConfigureWebHost()</code> method. For example, you can configure the test web host to use a different configuration file, as follows:</p>
<pre class="source-code">
builder.ConfigureAppConfiguration((context, config) =&gt;{
    config.AddJsonFile("appsettings.IntegrationTest.json");
});</pre>
<p>The default environment for the test web host of the SUT is <code>Development</code>. If you want to use a different environment, you can use the <code>UseEnvironment()</code> method, as follows:</p>
<pre class="source-code">
builder.UseEnvironment("IntegrationTest");</pre> <p>Next, we need a way to create the test database and seed some test data. Create a static class named <code>Utilities</code> and add the following code to the class:</p>
<pre class="source-code">
public static class Utilities{
    public static void InitializeDatabase(InvoiceDbContext context)
    {
        context.Database.EnsureDeleted();
        context.Database.EnsureCreated();
        SeedDatabase(context);
    }
    public static void Cleanup(InvoiceDbContext context)
    {
        context.Contacts.ExecuteDelete();
        context.Invoices.ExecuteDelete();
        context.SaveChanges();
        SeedDatabase(context);
    }
    private static void SeedDatabase(InvoiceDbContext context)
    {
        // Omitted for brevity
    }
}</pre>
<p>The <code>Utilities</code> class <a id="_idIndexMarker1035"/>contains a few static methods that help us manage the test database. We need to initialize the test database before we run the tests and clean up the test database after we run the tests that change the data in the database.</p>
<p>When should we initialize the test database? We learned that the instance of the class fixture is created before the test class is initialized and is shared among all test methods in the test class. So, we can initialize the test database in the class fixture. Update the following code in the <code>ConfigureWebHost()</code> method of the <code>CustomIntegrationTestsFixture</code> class:</p>
<pre class="source-code">
builder.ConfigureServices(services =&gt;{
    var descriptor = services.SingleOrDefault(d =&gt; d.ServiceType == typeof(DbContextOptions&lt;InvoiceDbContext&gt;));
    services.Remove(descriptor);
    services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;
    {
        options.UseSqlServer(ConnectionString);
    });
    using var scope = services.BuildServiceProvider().CreateScope();
    var scopeServices = scope.ServiceProvider;
    var dbContext = scopeServices.GetRequiredService&lt;InvoiceDbContext&gt;();
    Utilities.InitializeDatabase(dbContext);
});</pre>
<p>When the<a id="_idIndexMarker1036"/> test web host of SUT is created, we replace the default database context with a test database context, and also initialize the test database, so that all the test methods in the test class can use the same test database.</p>
<p>Next, we can create a new test class named <code>InvoicesApiTests</code>, which is used to test the <code>/api/invoices</code> endpoint. Add the following code to the class:</p>
<pre class="source-code">
public class InvoicesApiTests(CustomIntegrationTestsFixture factory) : IClassFixture&lt;CustomIntegrationTestsFixture&gt;{
}</pre>
<p>The <code>InvoicesApiTests</code> test class will be initialized with an instance of the <code>CustomIntegrationTestsFixture</code> class. Then we can create some test methods to test the <code>/api/invoices</code> endpoint. A test method to test the <code>GET /api/invoices</code> endpoint<a id="_idIndexMarker1037"/> might look as follows:</p>
<pre class="source-code">
[Fact]public async Task GetInvoices_ReturnsSuccessAndCorrectContentType()
{
    // Arrange
    var client = _factory.CreateClient();
    // Act
    var response = await client.GetAsync("/api/invoice");
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    response.Content.Headers.ContentType.Should().NotBeNull();
    response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
    // Deserialize the response
    var responseContent = await response.Content.ReadAsStringAsync();
    var invoices = JsonSerializer.Deserialize&lt;List&lt;Invoice&gt;&gt;(responseContent, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    });
    invoices.Should().NotBeNull();
    invoices.Should().HaveCount(2);
}</pre>
<p>As this request to the <code>GET /api/invoices</code> endpoint does not change the database, the test method is straightforward.</p>
<p>Next, <a id="_idIndexMarker1038"/>let's see how to test the <code>POST /api/invoices</code> endpoint, which changes the database. A test method to test this endpoint might look as follows:</p>
<pre class="source-code">
[Fact]public async Task PostInvoice_ReturnsSuccessAndCorrectContentType()
{
    // Arrange
    var client = factory.CreateClient();
    var invoice = new Invoice
    {
        DueDate = DateTimeOffset.Now.AddDays(30),
        ContactId = Guid.Parse("8a9de219-2dde-4f2a-9ebd-b1f8df9fef03"),
        Status = InvoiceStatus.Draft,
        InvoiceItems = new List&lt;InvoiceItem&gt;
        {
            // Omitted for brevity        }
    };
    var json = JsonSerializer.Serialize(invoice);
    var data = new StringContent(json, Encoding.UTF8, "application/json");
    // Act
    var response = await client.PostAsync("/api/invoice", data);
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    response.Content.Headers.ContentType.Should().NotBeNull();
    response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
    // Deserialize the response
    var responseContent = await response.Content.ReadAsStringAsync();
    var invoiceResponse = JsonSerializer.Deserialize&lt;Invoice&gt;(responseContent, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    });
    invoiceResponse.Should().NotBeNull();
    invoiceResponse!.Id.Should().NotBeEmpty();
    invoiceResponse.Amount.Should().Be(500);
    invoiceResponse.Status.Should().Be(invoice.Status);
    invoiceResponse.ContactId.Should().Be(invoice.ContactId);
    // Clean up the database
    var scope = factory.Services.CreateScope();
    var scopedServices = scope.ServiceProvider;
    var db = scopedServices.GetRequiredService&lt;InvoiceDbContext&gt;();
    Utilities.Cleanup(db);
}</pre>
<p>As this <a id="_idIndexMarker1039"/>request to the <code>POST /api/invoices</code> endpoint changes the database, we need to clean up the database after we run the test. To get the current instance of the database context, we need to create a new scope and get the database context from the scope. Then we can use the <code>Cleanup</code> method of the <code>Utilities</code> class to clean up the database.</p>
<p>A test for the sad path of the <code>POST /api/invoices</code> endpoint might look as follows:</p>
<pre class="source-code">
[Fact]public async Task PostInvoice_WhenContactIdDoesNotExist_ReturnsBadRequest()
{
    // Arrange
    var client = factory.CreateClient();
    var invoice = new Invoice
    {
        DueDate = DateTimeOffset.Now.AddDays(30),
        ContactId = Guid.NewGuid(),
        Status = InvoiceStatus.Draft,
        InvoiceItems = new List&lt;InvoiceItem&gt;
        {
            // Omitted for brevity
        }
    };
    var json = JsonSerializer.Serialize(invoice);
    var data = new StringContent(json, Encoding.UTF8, "application/json");
    // Act
    var response = await client.PostAsync("/api/invoice", data);
    // Assert
    response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
}</pre>
<p>You can try<a id="_idIndexMarker1040"/> to add more integration tests per your needs. Note that we need to manage the test database carefully. If you have multiple test classes that change the database, you may need to follow the same pattern (using a lock or collection fixture) as that in the unit tests we introduced in the <em class="italic">Creating a test fixture</em> section in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>, to ensure the test database is clean before each test class runs and clean up the test database after each test class runs.</p>
<p>For example, if we have another <code>ContactsApiTests</code> class that also uses <code>CustomIntegrationTestsFixture</code>, xUnit will run <code>InvoicesApiTests</code> and <code>ContactsApiTests</code> in parallel. This may cause issues because both test classes try to initialize the test database at the same time. To avoid this issue, we can run these test classes in one collection to ensure that they run sequentially.</p>
<p>We can <a id="_idIndexMarker1041"/>demonstrate this by creating a test collection named <code>CustomIntegrationTests</code> and adding the <code>CollectionDefinition</code> attribute to the <code>CustomIntegrationTestsCollection</code> class. This attribute will enable us to define the collection and its associated tests, as shown here:</p>
<pre class="source-code">
[CollectionDefinition("CustomIntegrationTests")]public class CustomIntegrationTestsCollection : ICollectionFixture&lt;CustomIntegrationTestsFixture&gt;
{
}</pre>
<p>Then we can add the <code>Collection</code> attribute to the <code>InvoicesApiTestsWithCollection</code> and <code>ContactsApiTestsWithCollection</code> classes. For example, the <code>InvoicesApiTestsWithCollection</code> class might look as follows:</p>
<pre class="source-code">
[Collection("CustomIntegrationTests")]public class InvoicesApiTestsWithCollection(CustomIntegrationTestsFixture factory) : IDisposable
{
    // Omitted for brevity
}</pre>
<p>You can find the complete source code in the sample repo. Note that the normal integration test class, <code>InvoicesApiTests</code>, does not have the <code>Collection</code> attribute, so <a id="_idIndexMarker1042"/>xUnit will run it in parallel with the <code>CustomIntegrationTests</code> collection. To avoid conflicts, we can skip the test methods in the <code>InvoicesApiTests</code> class, as shown here:</p>
<pre class="source-code">
[Fact(Skip = "This test is skipped to avoid conflicts with the test collection")]public async Task GetInvoices_ReturnsSuccessAndCorrectContentType()
{
    // Omitted for brevity
}</pre>
<p>When you run the tests in the sample repo, please add or comment out the <code>Skip</code> att<a id="_idTextAnchor414"/>ributes per your needs.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor415"/>Testing with mock services</h2>
<p>As we<a id="_idIndexMarker1043"/> explained in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>, unit tests should focus on isolated units of code. So, unit tests often use mock or stub services to isolate the code under test from other services. Integration tests, on the other hand, should test the integration between different components. So, technically, integration tests should use real services instead of mock services.</p>
<p>However, in some cases, using mock dependencies in integration tests can be helpful. For example, in the sample invoice application, we need to call a third-party service to send emails. If we use the real email service in the integration tests, it may have the following issues:</p>
<ul>
<li>The actual email service may not be available in the test environment. For example, the email service may be hosted in a different environment, and the test environment may not be able to access the email service.</li>
<li>The email service may have rate limits, strict network policies, or other restrictions that may cause issues in the integration tests or slow down the test execution.</li>
<li>The email service may cause unnecessary costs in the test environment, especially if the service has usage-based pricing or requires a paid subscription. If we run the integration tests frequently, it may incur high costs.</li>
<li>The test may impact production and cause issues for real users.</li>
</ul>
<p>In this <a id="_idIndexMarker1044"/>case, using a mock email service in the integration can help us avoid these issues so that we can run the tests faster and more efficiently, avoid impacting production, and save costs.</p>
<p>Let's see how to use a mock email service in the integration tests. The service we use to send email is the <code>IEmailSender</code> interface. We can inject a mock service that implements the <code>IEmailSender</code> interface in the integration tests. Create a new test method in the test class:</p>
<pre class="source-code">
[Theory][InlineData("7e096984-5919-492c-8d4f-ce93f25eaed5")]
[InlineData("b1ca459c-6874-4f2b-bc9d-f3a45a9120e4")]
public async Task SendInvoiceAsync_ReturnsSuccessAndCorrectContentType(string invoiceId)
{
    // Arrange
    var mockEmailSender = new Mock&lt;IEmailSender&gt;();
    mockEmailSender.Setup(x =&gt; x.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))
        .Returns(Task.CompletedTask).Verifiable();
    var client = factory.WithWebHostBuilder(builder =&gt;
    {
        builder.ConfigureTestServices(services =&gt;
        {
            var emailSender = services.SingleOrDefault(x =&gt; x.ServiceType == typeof(IEmailSender));
            services.Remove(emailSender);
            services.AddScoped&lt;IEmailSender&gt;(_ =&gt; mockEmailSender.Object);
        });
    }).CreateClient();
    // Act
    var response = await client.PostAsync($"/api/invoice/{invoiceId}/send", null);
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    mockEmailSender.Verify(x =&gt; x.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()), Times.Once);
    var scope = factory.Services.CreateScope();
    var scopedServices = scope.ServiceProvider;
    var db = scopedServices.GetRequiredService&lt;InvoiceDbContext&gt;();
    var invoice = await db.Invoices.FindAsync(Guid.Parse(invoiceId));
    invoice!.Status.Should().Be(InvoiceStatus.AwaitPayment);
}</pre>
<p>In the preceding code, we created a mock email sender service using the <code>Moq</code> library. The test web host of SUT provides a <code>WithWebHostBuilder()</code> method to configure the web host builder. In this method, we can configure the service collection of the web host using the <code>ConfigureTestServices()</code> method. Similar to the mock database context we introduced in the <em class="italic">Testing with a database context</em> section, we find the registered <code>IEmailSender</code> service and remove it from the service collection, then add the mock service to the service collection. Finally, we create the HTTP client and send the request to the API endpoint. If the mock service is used correctly, the test should pass.</p>
<p>In summary, whether<a id="_idIndexMarker1045"/> to use mock services in integration tests or not should be decided on a case-by-case basis and depends on the specific requirements and objectives of the tests. Mocks can be useful in certain scenarios, but they should not be overused, otherwise, the integration tests may not be able to reflect the real-world scenarios.</p>
<p>If your web API project runs in a microservice architecture, you may need to call other microservices in the integration tests. In this case, you can use the same approach to mock the HTTP client and the HTTP responses. The integration tests may be more complicated. We will stop here and explore more when we discuss the microservice archite<a id="_idTextAnchor416"/>cture in the next chapter.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor417"/>Testing with authentication and authorization</h1>
<p>A common<a id="_idIndexMarker1046"/> scenario in web APIs is that some API endpoints require authentication and authorization. We introduced how to implement authentication and authorization in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a>. In this section, we will discuss how to test the API endpoints that require authen<a id="_idTextAnchor418"/>tication and authorization.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor419"/>Preparing the sample application</h2>
<p>To demonstrate<a id="_idIndexMarker1047"/> testing with authentication and authorization, we will use the sample application we created in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a>. You can find the source code in the <code>chapter10\AuthTestsDemo\start\</code> folder of the sample repo. This sample application uses claims-based authentication and authorization. You can recap the implementation details in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a>.</p>
<p>In <code>WeatherForecastController</code>, there are several methods that require authentication and authorization. (Forgive the naming – we just use the default template of ASP.NET Core web APIs.)</p>
<p>Create a new <a id="_idIndexMarker1048"/>integration test project as described in the <em class="italic">Setting up the integration test project</em> section. You need to ensure that the integration test project has the following NuGet packages installed:</p>
<ul>
<li><code>Microsoft.AspNetCore.Mvc.Testing</code>: This is the test web host of SUT</li>
<li><code>xUnit</code>: This is the test framework</li>
<li><code>Moq</code>: This is the mocking library</li>
<li><code>FluentAssertions</code>: This is the assertion library (optional)</li>
</ul>
<p>If you want to run the tests in VS 2022, you also need to install <code>xunit.runner.visualstudio</code>, the test runner for VS 2022.</p>
<p>Also add the reference to the sample application project. For simplicity, we will only focus on the integration tests for authentication and authorization. So, this demo does not involve the database context and the database.</p>
<p>Another thing you need to do is make the <code>Program</code> class public. Just add the following code at the end of the <code>Program</code> file:</p>
<pre class="source-code">
public partial class Program { }</pre> <p>Next, we can start to write the integration tests for the API endpoints that require auth<a id="_idTextAnchor420"/>entication and authorization.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor421"/>Creating a test fixture</h2>
<p>As we<a id="_idIndexMarker1049"/> explained in the <em class="italic">Creating a test fixture</em> section in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>, we can create a test fixture to share the common code among the tests. Create a new class named <code>IntegrationTestsFixture</code> and add the following code:</p>
<pre class="source-code">
public class IntegrationTestsFixture : WebApplicationFactory&lt;Program&gt;{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // This is where you can set up your test server with the services you need
        base.ConfigureWebHost(builder);
    }
}</pre>
<p>This is a <a id="_idIndexMarker1050"/>simple test fixture that inherits from the <code>WebApplicationFactory&lt;Program&gt;</code> class. Because we do not need to set up any services in this demo, there is no custom code in the <code>ConfigureWebHost</code> method. If you need to set up services<a id="_idTextAnchor422"/>, you can do it in this method.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor423"/>Creating the test class</h2>
<p>Next, we<a id="_idIndexMarker1051"/> can create the test class. Create a new class named <code>AuthTests</code> and add the following code:</p>
<pre class="source-code">
public class AuthTests(IntegrationTestsFixture fixture) : IClassFixture&lt;IntegrationTestsFixture&gt;{
}</pre>
<p>This is similar to the test class we created in the <em class="italic">Using the test fixture</em> section in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>. It inherits from the <code>IClassFixture&lt;IntegrationTestsFixture&gt;</code> interface and has <a id="_idIndexMarker1052"/>a constructor that accepts an <code>IntegrationTestsFixture</code> instance. So, the test class can use the <code>IntegrationTestsFixture</code> instance to access the test web host of SUT. So far, there is n<a id="_idTextAnchor424"/>o special code in the test class.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor425"/>Testing the anonymous API endpoints</h2>
<p>Next, let us<a id="_idIndexMarker1053"/> test the API endpoints that do not require authentication and authorization. In the <code>WeatherForecastController</code> class, copy the <code>Get()</code> method and paste it below the <code>Get()</code> method. Rename the new method <code>GetAnonymous()</code> and add the <code>AllowAnonymous</code> attribute. The new method should look like the following code:</p>
<pre class="source-code">
[AllowAnonymous][HttpGet("anonymous")]
public IEnumerable&lt;WeatherForecast&gt; GetAnonymous()
{
    // Omitted for brevity
}</pre>
<p>Now, we have a new API endpoint that does not require authentication and authorization. Create a new test method in the test class:</p>
<pre class="source-code">
[Fact]public async Task GetAnonymousWeatherForecast_ShouldReturnOk()
{
    // Arrange
    var client = fixture.CreateClient();
    // Act
    var response = await client.GetAsync("/weatherforecast/anonymous");
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    response.Content.Headers.ContentType.Should().NotBeNull();
    response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
    // Deserialize the response
    var responseContent = await response.Content.ReadAsStringAsync();
    var weatherForecasts = JsonSerializer.Deserialize&lt;List&lt;WeatherForecast&gt;&gt;(responseContent, new JsonSerializerOptions
    {
        PropertyNameCaseInsensitive = true
    });
    weatherForecasts.Should().NotBeNull();
    weatherForecasts.Should().HaveCount(5);
}</pre>
<p>There <a id="_idIndexMarker1054"/>are not many differences between this test method and the test method we created in the <em class="italic">Using the test fixture</em> section in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>. When we use the <code>CreateClient()</code> method, there is no special code to set up <code>HttpClient</code>. So, the test method can send the request to the API endpoint without any authentication and authorization. Because this endpoint allows anon<a id="_idTextAnchor426"/>ymous access, the test should pass.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor427"/>Testing the authorized API endpoints</h2>
<p>The <code>WeatherForecastController</code> class has an <code>Authorize</code> attribute. So, the API endpoints<a id="_idIndexMarker1055"/> that do not have the <code>AllowAnonymous</code> attribute require authentication and authorization. Let's test the sad path for the <code>Get()</code> method. Create a new test method in the test class:</p>
<pre class="source-code">
[Fact]public async Task GetWeatherForecast_ShouldReturnUnauthorized_WhenNotAuthorized()
{
    // Arrange
    var client = fixture.CreateClient();
    // Act
    var response = await client.GetAsync("/weatherforecast");
    // Assert
    response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
}</pre>
<p>This test method is similar to the previous <code>GetAnonymousWeatherForecast_ShouldReturnOk()</code> method, but we expect the status code to be <code>401 Unauthorized</code> because the API endpoint requires authentication and authorization. This test should pass as well.</p>
<p>Next, we need to set up the authentication and authorization in the test. There are several ways to do this:</p>
<ul>
<li>In the test, call the authentication endpoint to get the access token. Then add the access token to the <code>Authorization</code> header of the HTTP request. However, this approach is not recommended because it needs additional effort to maintain the credentials, such as the username, password, client ID, client secret, and so on. Also, the tests may not be able to access the authentication endpoint in the test environment. If the tests depend on the authentication endpoint, it increases the complexity of the tests.</li>
<li>Create a<a id="_idIndexMarker1056"/> helper method to generate the access token. Then add the access token to the <code>Authorization</code> header of the HTTP request. This approach does not need to call the authentication endpoint in the test. However, it means that we need to know how to generate the access token. If the authentication logic is provided by a third-party provider, we may not be able to make the same implementation in the test. So, it is only available if we have full control of the authentication logic.</li>
<li>Use <code>WebApplicationFactory</code> to set up the authentication and authorization and create a custom <code>AuthenticationHandler</code> to simulate the authentication and authorization process. This approach is more practical because it does not need to call the authentication endpoint in the test. Also, it does not need to duplicate the authentication logic in the test project.</li>
</ul>
<p>As we have the source code of the sample application, which includes the authentication logic, we can demonstrate how to use the second approach, and then we will sh<a id="_idTextAnchor428"/>ow you how to use the third approach.</p>
<h3>Generating the access token in the test</h3>
<p>The code we use to <a id="_idIndexMarker1057"/>generate the access token is from the <code>AccountController</code> class, which is the authentication endpoint. We can find a <code>GenerateToken</code> method in the <code>AccountController</code> class. This method is invoked when the user successfully logs in. Create a new method in the <code>IntegrationTestsFixture</code> class:</p>
<pre class="source-code">
public string? GenerateToken(string userName){
    using var scope = Services.CreateScope();
    var configuration = scope.ServiceProvider.GetRequiredService&lt;IConfiguration&gt;();
    var secret = configuration["JwtConfig:Secret"];
    var issuer = configuration["JwtConfig:ValidIssuer"];
    var audience = configuration["JwtConfig:ValidAudiences"];
    // Omitted for brevity
    var securityToken = tokenHandler.CreateToken(tokenDescriptor);
    var token = tokenHandler.WriteToken(securityToken);
    return token;
}</pre>
<p>In the <a id="_idIndexMarker1058"/>preceding method, we use the <code>IConfiguration</code> service to get the secret, issuer, and audience from the configuration. Then we copy the code from the <code>GenerateToken()</code> method in the <code>AccountController</code> class to generate the access token. Note that the configuration comes from the <code>appsettings.json</code> file in the main web API project. As we did not change the configuration of the test web host, the configuration is the same as that in the main web API project. But if you need to use a different configuration for the tests, please add proper code to the <code>ConfigureWebHost</code> method in the <code>IntegrationTestsFixture</code> class to apply any changes, as we introduced in the <em class="italic">Creating a test </em><em class="italic">fixture</em> section.</p>
<p>Next, we can use the <code>GenerateToken</code> method in the <code>AuthTest</code> class. Create a new test method in the test class:</p>
<pre class="source-code">
[Fact]public async Task GetWeatherForecast_ShouldReturnOk_WhenAuthorized()
{
    // Arrange
    var token = fixture.GenerateToken("TestUser");
    var client = fixture.CreateClient();
    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
    // Act
    var response = await client.GetAsync("/weatherforecast");
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    // Omited for brevity
}</pre>
<p>In this <a id="_idIndexMarker1059"/>test method, we call the <code>GenerateToken()</code> method to generate an access token, and then add the access token to the <code>Authorization</code> header of the HTTP request. Because the logic we use to generate the token is the same as the authen<a id="_idTextAnchor429"/>tication endpoint, the test should pass.</p>
<h3>Using a custom authentication handler</h3>
<p>Another <a id="_idIndexMarker1060"/>way to test the authorized API endpoints is to use a custom authentication handler. A custom authentication handler can simulate the authentication and authorization process. So, we can use it to test the authorized API endpoints without calling the authentication endpoint. This is the recommended approach to test the authorized API endpoints because it does not need any other dependencies, nor does it need to duplicate the authentication logic in the test project.</p>
<p>In the actual authentication process, we need to generate a JWT token that includes the claims of the authenticated user and add it to the <code>Authorization</code> header of the HTTP request. If we use a custom authentication handler, we can skip the process of generating the JWT token, but we still need to find a way to define the claims that we need and pass them to the custom authentication handler. We can simply add the claims in the request headers and then read the values in the custom authentication handler to create the <code>ClaimsPrincipal</code> object. Let us demonstrate how to do this.</p>
<p>To use a<a id="_idIndexMarker1061"/> custom authentication handler, first create a new class named <code>TestAuthHandler</code>, which inherits from the <code>AuthenticationHandler</code> class:</p>
<pre class="source-code">
public class TestAuthHandler : AuthenticationHandler&lt;AuthenticationSchemeOptions&gt;{
    public const string AuthenticationScheme = "TestScheme";
    public const string UserNameHeader = "UserName";
    public const string CountryHeader = "Country";
    public const string AccessNumberHeader = "AccessNumber";
    public const string DrivingLicenseNumberHeader = "DrivingLicenseNumber";
    public TestAuthHandler(IOptionsMonitor&lt;AuthenticationSchemeOptions&gt; options, ILoggerFactory logger,
        UrlEncoder encoder, ISystemClock clock) : base(options, logger, encoder, clock)
    {
    }
    protected override Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        return Task.FromResult(result);
    }
}</pre>
<p>In the preceding code, we define the authentication scheme name as <code>TestScheme</code>, which is an alternative name to the actual scheme name, <code>Bearer</code>. You can find the definition in the <code>Program</code> class. Also, we define a few names for HTTP headers, which we will use to pass the claims to the custom authentication handler. The <code>HandleAuthenticateAsync()</code> method is the method that we need to override to implement the authentication logic. We will implement it in the following code.</p>
<p>The idea is<a id="_idIndexMarker1062"/> that when we create the request in the test, we simply add the claims to the request headers. So that the custom authentication handler can read the values from the request headers, update the <code>HandleAuthenticateAsync()</code> method as follows:</p>
<pre class="source-code">
protected override Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync(){
    var claims = new List&lt;Claim&gt;();
    if (Context.Request.Headers.TryGetValue(UserNameHeader, out var userName))
    {
        claims.Add(new Claim(ClaimTypes.Name, userName[0]));
    }
    if (Context.Request.Headers.TryGetValue(CountryHeader, out var country))
    {
        claims.Add(new Claim(ClaimTypes.Country, country[0]));
    }
    if (Context.Request.Headers.TryGetValue(AccessNumberHeader, out var accessNumber))
    {
        claims.Add(new Claim(AppClaimTypes.AccessNumber, accessNumber[0]));
    }
    if (Context.Request.Headers.TryGetValue(DrivingLicenseNumberHeader, out var drivingLicenseNumber))
    {
        claims.Add(new Claim(AppClaimTypes.DrivingLicenseNumber, drivingLicenseNumber[0]));
    }
    // You can add more claims here if you want
    var identity = new ClaimsIdentity(claims, AuthenticationScheme);
    var principal = new ClaimsPrincipal(identity);
    var ticket = new AuthenticationTicket(principal, AuthenticationScheme);
    var result = AuthenticateResult.Success(ticket);
    return Task.FromResult(result);
}</pre>
<p>Instead of getting claims from the JWT token, we get the claims from the request headers. If the values exist, we add them to the <code>ClaimsIdentity</code> object. Then we create the <code>ClaimsPrincipal</code> object and the <code>AuthenticationTicket</code> object. Finally, we return the <code>AuthenticateResult</code> object with the <code>Success</code> status. This method simulates the authentication process, which avoids the need to generate the JWT token, but it still creates the <code>ClaimsPrincipal</code> object that we need to test the authorized API endpoints.</p>
<p>Next, we<a id="_idIndexMarker1063"/> can test the authorized API endpoints by using the custom authentication handler. In the <code>WeatherForecastController</code> class, we can find a <code>GetDrivingLicense</code> method, which is an authorized API endpoint that needs the <code>DrivingLicenseNumber</code> claim. We can create a new test method in the <code>AuthTest</code> class as follows:</p>
<pre class="source-code">
[Fact]public async Task GetDrivingLicense_ShouldReturnOk_WhenAuthorizedWithTestAuthHandler()
{
    // Arrange
    var client = fixture.WithWebHostBuilder(builder =&gt;
    {
        builder.ConfigureTestServices(services =&gt;
        {
            services.AddAuthentication(options =&gt;
                {
                    options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
                    options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
                    options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
                })
                .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
                    options =&gt; { });
        });
    }).CreateClient();
    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(TestAuthHandler.AuthenticationScheme);
    client.DefaultRequestHeaders.Add(TestAuthHandler.UserNameHeader, "Test User");
    client.DefaultRequestHeaders.Add(TestAuthHandler.CountryHeader, "New Zealand");
    client.DefaultRequestHeaders.Add(TestAuthHandler.AccessNumberHeader, "123456");
    client.DefaultRequestHeaders.Add(TestAuthHandler.DrivingLicenseNumberHeader, "12345678");
    // Act
    var response = await client.GetAsync("/weatherforecast/driving-license");
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    response.Content.Headers.ContentType.Should().NotBeNull();
    response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
}</pre>
<p>In this<a id="_idIndexMarker1064"/> test method, we specify the test web host of SUT with the <code>WithWebHostBuilder</code> method and then call the <code>AddAuthentication</code> method to specify the authentication scheme. Then we call the <code>AddScheme</code> method to apply the <code>TestAuthHandler</code> authentication handler to the authentication service. With this customized test web host, we can create a new HTTP client. Before we send the request using this HTTP client, we need to add the <code>Authorization</code> header that specifies the authentication scheme. We also add the claims to the request headers for simplicity, so that the custom authentication handler can read the values from the request headers and create the <code>ClaimsPrincipal</code> object.</p>
<p>Then we can call the <code>GetAsync</code> method to send the HTTP request to the API endpoint. Finally, we can verify the response status code and the response content type to ensure the request was successful.</p>
<p>The preceding test method is for a happy path. To test the unauthorized scenario, we can create a new test method that does not add the <code>DrivingLicenseNumberHeader</code> header to the request, and verify that the response status code is <code>401 Unauthorized</code>:</p>
<pre class="source-code">
[Fact]public async Task GetDrivingLicense_ShouldReturnForbidden_WhenRequiredClaimsNotProvidedWithTestAuthHandler()
{
    // Arrange
    var client = fixture.WithWebHostBuilder(builder =&gt;
    {
        builder.ConfigureTestServices(services =&gt;
        {
            services.AddAuthentication(options =&gt;
                {
                    options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
                    options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
                    options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
                })
                .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
                    options =&gt; { });
        });
    }).CreateClient();
    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(TestAuthHandler.AuthenticationScheme);
    client.DefaultRequestHeaders.Add(TestAuthHandler.UserNameHeader, "Test User");
    client.DefaultRequestHeaders.Add(TestAuthHandler.CountryHeader, "New Zealand");
    client.DefaultRequestHeaders.Add(TestAuthHandler.AccessNumberHeader, "123456");
    // Act
    var response = await client.GetAsync("/weatherforecast/driving-license");
    // Assert
    response.StatusCode.Should().Be(HttpStatusCode.Forbidden);
}</pre>
<p>In the preceding test method, we do not add the <code>DrivingLicenseNumberHeader</code> header to the request. So, the custom authentication handler cannot find the <code>DrivingLicenseNumber</code> claim, and it will return the <code>Forbidden</code> status code.</p>
<p>Now, we<a id="_idIndexMarker1065"/> found that there is some duplicated code in the preceding test methods. If we need to set up the test web host and create the HTTP client for each test method, we can move the code to the <code>IntegrationTestsFixture</code> class. Create a method called <code>CreateClientWithAuth</code> in the <code>IntegrationTestsFixture</code> class:</p>
<pre class="source-code">
public HttpClient CreateClientWithAuth(string userName, string country, string accessNumber, string drivingLicenseNumber){
    var client = WithWebHostBuilder(builder =&gt;
    {
        builder.ConfigureTestServices(services =&gt;
        {
            services.AddAuthentication(options =&gt;
                {
                    options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
                    options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
                    options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
                })
                .AddScheme&lt;AuthenticationSchemeOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
                    options =&gt; { });
        });
    }).CreateClient();
    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(TestAuthHandler.AuthenticationScheme);
    client.DefaultRequestHeaders.Add(TestAuthHandler.UserNameHeader, userName);
    client.DefaultRequestHeaders.Add(TestAuthHandler.CountryHeader, country);
    client.DefaultRequestHeaders.Add(TestAuthHandler.AccessNumberHeader, accessNumber);
    client.DefaultRequestHeaders.Add(TestAuthHandler.DrivingLicenseNumberHeader, drivingLicenseNumber);
    return client;
}</pre>
<p>The <code>CreateClientWithAuth()</code> method accepts the claims as parameters and then creates the <code>HttpClient</code> with the customized test web host. In this way, we can easily control the claims for each test method. Then we can update the test methods to use this<a id="_idIndexMarker1066"/> method. For example, the test methods for the <code>GetCountry</code> endpoint can be updated as follows:</p>
<pre class="source-code">
[Fact]public async Task GetCountry_ShouldReturnOk_WhenAuthorizedWithTestAuthHandler()
{
    // Arrange
    var client = fixture.CreateClientWithAuth("Test User", "New Zealand", "123456", "12345678");
    // Act
    var response = await client.GetAsync("/weatherforecast/country");
    // Assert
    response.EnsureSuccessStatusCode(); // Status Code 200-299
    response.Content.Headers.ContentType.Should().NotBeNull();
    response.Content.Headers.ContentType!.ToString().Should().Be("application/json; charset=utf-8");
}
[Fact]
public async Task GetCountry_ShouldReturnForbidden_WhenRequiredClaimsNotProvidedWithTestAuthHandler()
{
    // Arrange
    // As we don't provide the country claim, the request will be forbidden
    var client = fixture.CreateClientWithAuth("Test User", "", "123456", "12345678");
    // Act
    var response = await client.GetAsync("/weatherforecast/country");
    // Assert
    response.StatusCode.Should().Be(HttpStatusCode.Forbidden);
}</pre>
<p>Now <a id="_idIndexMarker1067"/>we can verify that the test methods are still working as expected.</p>
<div><div><img alt="Figure 10.1 – The test methods pass as expected in VS 2022" src="img/B18971_10_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The test methods pass as expected in VS 2022</p>
<p>Note that you can also customize the <code>AuthenticationSchemeOptions</code> class if you need to. For example, you can define a <code>TestAuthHandlerOptions</code> class that inherits from the <code>AuthenticationSchemeOptions</code> class, as follows:</p>
<pre class="source-code">
public class TestAuthHandlerOptions : AuthenticationSchemeOptions{
    public string UserName { get; set; } = string.Empty;
}</pre>
<p>You can then configure <code>TestAuthHandlerOptions</code> in the <code>ConfigureTestServices</code> method:</p>
<pre class="source-code">
var client = fixture.WithWebHostBuilder(builder =&gt;{
    builder.ConfigureTestServices(services =&gt;
    {
        services.Configure&lt;TestAuthHandlerOptions&gt;(options =&gt;
        {
            options.UserName = "Test User";
        });
        services.AddAuthentication(options =&gt;
            {
                options.DefaultAuthenticateScheme = TestAuthHandler.AuthenticationScheme;
                options.DefaultChallengeScheme = TestAuthHandler.AuthenticationScheme;
                options.DefaultScheme = TestAuthHandler.AuthenticationScheme;
            })
            .AddScheme&lt;TestAuthHandlerOptions, TestAuthHandler&gt;(TestAuthHandler.AuthenticationScheme,
                options =&gt; { });
    });
}).CreateClient();</pre>
<p>The <code>TestAuthHandler</code> class <a id="_idIndexMarker1068"/>should now be updated as follows:</p>
<pre class="source-code">
public class TestAuthHandler : AuthenticationHandler&lt;TestAuthHandlerOptions&gt;{
    public readonly string _userName;
    public TestAuthHandler(IOptionsMonitor&lt;TestAuthHandlerOptions&gt; options, ILoggerFactory logger,
    UrlEncoder encoder, ISystemClock clock) : base(options, logger, encoder, clock)
    {
        // Get the user name from the options
        _userName = options.CurrentValue.UserName;
    }
}</pre>
<p>The <code>TestAuthHandler</code> class can now get the username from the <code>TestAuthHandlerOptions</code> class. You can also define other properties in the <code>TestAuthHandlerOptions</code> class, and then use them in the <code>TestAuthHandler</code> class.</p>
<p>If your<a id="_idIndexMarker1069"/> project does not use claim-based authorization, you can also define a custom authorization handler to implement the authorization logic. Please check the official document for more information: <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/</a>.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor431"/>Code coverage</h1>
<p>Now we have covered the unit tests and integration tests in ASP.NET Core. In this section, we will <a id="_idIndexMarker1070"/>discuss <strong class="bold">code coverage</strong>, which is a metric that measures the extent to which the source code of the application is covered by the test suite during testing.</p>
<p>Code coverage is a very important metric for software quality. If the code coverage is low, it means that there are many parts of the code that are not covered by the tests. In this case, we are not confident that the code is working as expected. Also, when we make changes or refactor the code, we are not sure whether the changes will break the existing code.</p>
<p>Code coverage <a id="_idIndexMarker1071"/>provides insights into which parts of the code are covered (or not covered) by the tests. It can help us identify areas that may require additional testing and ensure that the code is tested thoroughly.</p>
<p>Code coverage plays a vital role in assessing the effectiveness and reliability of the testing process. By analyzing code coverage, we can gain confidence in the quality of the code and identify potential areas of weakness or untested code. Adequate code coverage is essential to improve the quality of the code and reduce the risks of bugs and defects.</p>
<p>It is important to note that code coverage is not the sole indicator of code quality. While high code coverage is desirable, achieving 100% code coverage does not guarantee that the code is bug-free. Code coverage should be accompanied by other factors such as effective test design, code reviews, static analysis, manual testing, and so on. Additionally, factors such as code design, architecture, and development practices also play a role in the quality of the code. We need to find a balance between code coverage and other factors.</p>
<p>To analyze the code coverage, we have two steps:</p>
<ul>
<li><strong class="bold">Collecting test data</strong>: The data collector can monitor the test execution and collect the code coverage data during test runs. It can report code coverage data in different formats, such as XML or JSON.</li>
<li><strong class="bold">Generating the report</strong>: The report generator can read the collected data and generate the code coverage report, often in HTML format.</li>
</ul>
<p>Let us see how to use the data collector and report generator. We will use the <code>InvoiceApp</code> project as an example. You can find the sample project in the <code>chapte<a id="_idTextAnchor432"/>r10\IntegrationTestsDemo\IntegrationTest-v1</code> folder.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor433"/>Using data collectors</h2>
<p>To use <a id="_idIndexMarker1072"/>data collectors, we can use <strong class="bold">Coverlet</strong>. Coverlet is<a id="_idIndexMarker1073"/> a cross-platform code coverage framework for .NET, with support for line, branch, and method coverage. It can be used either as a .NET Core global tool or a NuGet package. For more information, please check the Coverlet repo on<a id="_idIndexMarker1074"/> GitHub: <a href="https://github.com/coverlet-coverage/coverlet">https://github.com/coverlet-coverage/coverlet</a>.</p>
<p>The xUnit project template already includes the Coverlet package. If your test project does not include the Coverlet package, you can install it by running the following command in the Package Manager Console:</p>
<pre class="console">
dotnet add package coverlet.collector</pre> <p>To get coverage data, navigate to the test project folder, and run the following command:</p>
<pre class="console">
dotnet test --collect:"XPlat Code Coverage"</pre> <p>The <code>--collect:"XPlat Code Coverage"</code> option tells the <code>dotnet test</code> command to<a id="_idIndexMarker1075"/> collect the code coverage data. The <code>XPlat Code Coverage</code> parameter is a friendly name for the collector. You can use any name you like but note that it is case insensitive. The code coverage data will be saved in the <code>TestResults</code> folder. You can find the code coverage data in the <code>coverage.cobertura.xml</code> file. The folder structure is <code>/TestResults/{GUID}/coverage.cobertura.xml</code>.</p>
<p>Here is a sample of the <code>coverage.cobertura.xml</code> file:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;coverage line-rate="0.1125" branch-rate="0.1875" version="1.9" timestamp="1685100267" lines-covered="108" lines-valid="960" branches-covered="6" branches-valid="32"&gt;
  &lt;sources&gt;
    &lt;source&gt;C:\dev\web-api-with-asp-net\example_code\chapter9\IntegrationTestsDemo\IntegrationTest-v1\InvoiceApp\InvoiceApp.WebApi\&lt;/source&gt;
  &lt;/sources&gt;
  &lt;packages&gt;
    &lt;package name="InvoiceApp.WebApi" line-rate="0.1125" branch-rate="0.1875" complexity="109"&gt;
      &lt;classes&gt;
      ...
        &lt;class name="InvoiceApp.WebApi.Services.EmailService" filename="Services\EmailService.cs" line-rate="1" branch-rate="1" complexity="2"&gt;
          &lt;methods&gt;
            &lt;method name="GenerateInvoiceEmail" signature="(InvoiceApp.WebApi.Models.Invoice)" line-rate="1" branch-rate="1" complexity="1"&gt;
              &lt;lines&gt;
                &lt;line number="19" hits="1" branch="False" /&gt;
                &lt;line number="20" hits="1" branch="False" /&gt;
                &lt;line number="21" hits="1" branch="False" /&gt;
                &lt;!-- ... --&gt;
                &lt;line number="37" hits="1" branch="False" /&gt;
                &lt;line number="38" hits="1" branch="False" /&gt;
              &lt;/lines&gt;
            &lt;/method&gt;
            &lt;method name=".ctor" signature="(Microsoft.Extensions.Logging.ILogger`1&amp;lt;InvoiceApp.WebApi.Interfaces.IEmailService&amp;gt;,InvoiceApp.WebApi.Interfaces.IEmailSender)" line-rate="1" branch-rate="1" complexity="1"&gt;
              &lt;lines&gt;
                &lt;line number="12" hits="3" branch="False" /&gt;
                &lt;line number="13" hits="3" branch="False" /&gt;
                &lt;line number="14" hits="3" branch="False" /&gt;
                &lt;line number="15" hits="3" branch="False" /&gt;
                &lt;line number="16" hits="3" branch="False" /&gt;
              &lt;/lines&gt;
            &lt;/method&gt;
          &lt;/methods&gt;
          &lt;lines&gt;
            &lt;line number="19" hits="1" branch="False" /&gt;
            &lt;line number="20" hits="1" branch="False" /&gt;
            &lt;line number="21" hits="1" branch="False" /&gt;
            &lt;!-- ... --&gt;
            &lt;line number="37" hits="1" branch="False" /&gt;
            &lt;line number="38" hits="1" branch="False" /&gt;
            &lt;line number="12" hits="3" branch="False" /&gt;
            &lt;line number="13" hits="3" branch="False" /&gt;
            &lt;line number="14" hits="3" branch="False" /&gt;
            &lt;line number="15" hits="3" branch="False" /&gt;
            &lt;line number="16" hits="3" branch="False" /&gt;
          &lt;/lines&gt;
        &lt;/class&gt;
        ...
      &lt;/classes&gt;
    &lt;/package&gt;
  &lt;/packages&gt;
&lt;/coverage&gt;</pre>
<p>In this code, we can<a id="_idIndexMarker1076"/> see the following information:</p>
<ul>
<li><code>line-rate</code>: This is the percentage of lines covered by tests</li>
<li><code>branch-rate</code>: This is the percentage of branches covered by tests</li>
<li><code>lines-covered</code>: This is the number of lines covered by tests</li>
<li><code>lines-valid</code>: This is the number of lines in the source code</li>
<li><code>branches-covered</code>: This is the number of branches covered by tests</li>
<li><code>branches-valid</code>: This is the number of branches in the source code</li>
</ul>
<p>You can also use Coverlet as a .NET global tool. To do this, you can run the following command to install Coverlet as a .NET global tool:</p>
<pre class="console">
dotnet tool install --global coverlet.console</pre> <p>Then you can use it as follows:</p>
<pre class="source-code">
coverlet /path/to/InvoiceApp.UnitTests.dll --target "dotnet" --targetargs "test /path/to/test-project --no-build"</pre> <p>Please <a id="_idIndexMarker1077"/>update the paths in the preceding command to match your project structure. The <code>--no-build</code> option is used to skip building the test project, which is useful if you have already built the test project.</p>
<p>Now we have the code coverage data. However, the <code>coverage.cobertura.xml</code> file is not human-readable. So, we must generate a human-read<a id="_idTextAnchor434"/>able report, which we will introduce in the next section.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor435"/>Generating a code coverage report</h2>
<p>To better <a id="_idIndexMarker1078"/>understand the coverage data, we can generate a code coverage report. To do this, we can use the <code>ReportGenerator</code> NuGet package. <strong class="bold">ReportGenerator</strong> is a<a id="_idIndexMarker1079"/> tool that can convert coverage data generated by Coverlet into human-readable reports. It also supports other coverage<a id="_idIndexMarker1080"/> formats, such <a id="_idIndexMarker1081"/>as <strong class="bold">OpenCover</strong>, <strong class="bold">dotCover</strong>, <strong class="bold">NCover</strong>, and<a id="_idIndexMarker1082"/> so on.</p>
<p>To install ReportGenerator, we can run the following command:</p>
<pre class="console">
dotnet tool install -g dotnet-reportgenerator-globaltool</pre> <p>Then we can run the following command to generate a code coverage report:</p>
<pre class="console">
reportgenerator "-reports:/path/to/coverage.cobertura.xml" "-targetdir:coveragereport" "-reporttypes:Html;HtmlSummary"</pre> <p>Please update the paths in the preceding command to match your project structure.</p>
<p>If the command runs successfully, you will see the generated HTML report in the <code>coveragereport</code> folder. You can open the <code>index.html</code> file in the browser to view the report. The report looks like this:</p>
<div><div><img alt="Figure 10.2 – Code coverage report" src="img/B18971_10_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Overview of the code coverage report</p>
<p>You can <a id="_idIndexMarker1083"/>check each class to see the code coverage details, as shown in <em class="italic">Figure 10</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 10.3 – Code coverage details" src="img/B18971_10_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Overview of the code coverage details</p>
<p>In <em class="italic">Figure 10</em><em class="italic">.4</em>, we <a id="_idIndexMarker1084"/>can see that some lines are not covered by tests:</p>
<div><div><img alt="Figure 10.4 – Lines not covered by tests highlighted in red" src="img/B18971_10_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Overview of the lines not covered by tests highlighted in red</p>
<p>Sadly, the<a id="_idIndexMarker1085"/> code coverage in our sample project is awful. But luckily, it is just a sample project. In real-world projects, we should try our best to improve the code coverage!</p>
<p>In this section, we have learned how to use Coverlet and ReportGenerator to generate code coverage data and reports. Code coverage is an essential aspect of effective software testing. By leveraging these reports, developers and quality assurance teams can gain insights into the quality of their tests and the quality of their code, which can ultimately enhance the reliability and stability <a id="_idTextAnchor436"/>of the application and also help us confidently refactor code.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor437"/>Summary</h1>
<p>In this chapter, we discussed how to write integration tests for ASP.NET Core web API applications. We learned how to create a test fixture to set up the test web host, and how to use the test fixture in the test class. We also learned how to test authorized endpoints and generate code coverage data and reports.</p>
<p>As a good developer, it is important to write tests for your code. Writing tests is not only a beneficial practice but also a beneficial habit to form. You may find that you spend more time writing tests than writing features, but the effort is worth it. To ensure your ASP.NET web API applications are functioning correctly, make sure to write both unit tests and integration tests. Doing so will help to ensure your code is reliable and secure.</p>
<p>In the next chapter, we will explore another aspect of web APIs: gRPC, which is a high-performance, open-source, universal RPC framework.</p>
</div>
</body></html>