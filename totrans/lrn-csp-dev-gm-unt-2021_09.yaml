- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Basic AI and Enemy Behavior
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本AI和敌人行为
- en: Virtual scenarios need conflicts, consequences, and potential rewards to feel
    real. Without these three things, there's no incentive for the player to care
    about what happens to their in-game character, much less continue to play the
    game. And while there are plenty of game mechanics that deliver on one or more
    of these conditions, nothing beats an enemy that will seek you out and try to
    end your session.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟场景需要冲突、后果和潜在奖励才能感觉真实。没有这三样东西，玩家就没有理由关心他们在游戏中的角色会发生什么，更不用说继续玩游戏了。虽然有很多游戏机制能够满足一个或多个这些条件，但没有什么能比得上一个会主动寻找你并试图结束你游戏会话的敌人。
- en: Programming an intelligent enemy is no easy task, and often goes hand in hand
    with long working hours and frustration. However, Unity has built-in features,
    components, and classes we can use to design and implement AI systems in a more
    user-friendly way. These tools will push the first playable iteration of *Hero
    Born* over the finish line and provide a springboard for more advanced C# topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程一个智能敌人并不容易，这通常与长时间的工作和挫败感相伴。然而，Unity内置了功能、组件和类，我们可以使用它们以更用户友好的方式设计和实现AI系统。这些工具将推动*英雄诞生*的第一个可玩迭代冲过终点线，并为更高级的C#主题提供一个跳板。
- en: 'In this chapter, we''ll focus on the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: The Unity navigation system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity导航系统
- en: Static objects and navigation meshes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态对象和导航网格
- en: Navigation agents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航代理
- en: Procedural programming and logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化编程和逻辑
- en: Taking and dealing damage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受和处理伤害
- en: Adding a loss condition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加失败条件
- en: Refactoring and keeping it DRY
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构并保持DRY（不要重复自己）
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Navigating 3D space in Unity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中导航3D空间
- en: When we talk about navigation in real life, it's usually a conversation about
    how to get from point A to point B. Navigating around virtual 3D space is largely
    the same, but how do we account for the experiential knowledge we humans have
    accumulated since the day we first started crawling? Everything from walking on
    a flat surface to climbing stairs and jumping off of curbs is a skill we learned
    by doing; how can we possibly program all that into a game without going insane?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论现实生活中的导航时，这通常是一段关于如何从A点到B点的对话。在虚拟3D空间中的导航在很大程度上是相同的，但我们如何解释自我们第一次开始爬行以来我们所积累的经验知识呢？从在平坦表面上行走到爬楼梯和跳下人行道，这些都是我们通过实践学习到的技能；我们怎么可能在不发疯的情况下将这些全部编程到游戏中呢？
- en: Before you can answer any of these questions, you'll need to know what navigation
    components Unity has to offer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够回答这些问题之前，你需要了解Unity提供了哪些导航组件。
- en: Navigation components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航组件
- en: 'The short answer is that Unity has spent a lot of time perfecting its navigation
    system and delivering components that we can use to govern how playable and non-playable
    characters can get around. Each of the following components comes as standard
    with Unity and has complex features already built in:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是，Unity花费了大量时间来完善其导航系统，并提供了我们可以用来控制可玩和非可玩角色如何移动的组件。以下每个组件都是Unity的标准组件，并已经内置了复杂的功能：
- en: A **NavMesh** is essentially a map of the walkable surfaces in a given level;
    the NavMesh component itself is created from the level geometry in a process called
    baking. Baking a NavMesh into your level creates a unique project asset that holds
    the navigation data.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavMesh**基本上是给定关卡中可通行表面的地图；NavMesh组件本身是通过称为烘焙的过程从关卡几何形状中创建的。将NavMesh烘焙到你的关卡中会创建一个独特的项目资产，该资产包含导航数据。'
- en: If a **NavMesh** is the level map, then a **NavMeshAgent** is the moving piece
    on the board. Any object with a NavMeshAgent component attached will automatically
    avoid other agents or obstacles it comes into contact with.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**NavMesh**是关卡地图，那么**NavMeshAgent**就是棋盘上的移动棋子。任何附加了NavMeshAgent组件的对象都会自动避开它接触到的其他代理或障碍物。
- en: The navigation system needs to be aware of any moving or stationary objects
    in the level that could cause a NavMeshAgent to alter their route. Adding NavMeshObstacle
    components to those objects lets the system know that they need to be avoided.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航系统需要了解关卡中任何移动或静止的对象，这些对象可能会使NavMeshAgent改变它们的路线。将这些对象添加NavMeshObstacle组件可以让系统知道它们需要被避开。
- en: While this description of the Unity navigation system is far from complete,
    it's enough for us to move forward with our enemy behavior. For this chapter,
    we'll be focusing on adding a NavMesh to our level, setting up the Enemy Prefab
    as a NavMeshAgent, and getting the Enemy Prefab to move along a predefined route
    in a seemingly intelligent way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对Unity导航系统的描述远未完整，但这足以让我们继续前进，实现敌人的行为。对于本章，我们将专注于在我们的关卡中添加NavMesh，设置敌人预制件为NavMeshAgent，并让敌人预制件以看似智能的方式沿着预定义的路线移动。
- en: 'We''ll only be using the NavMesh and NavMeshAgent components in this chapter,
    but if you want to spice up your level, take a look at how to create obstacles
    here: [https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html](https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们只使用NavMesh和NavMeshAgent组件，但如果你想让你的关卡更加生动，可以查看如何创建障碍物：[https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html](https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html)。
- en: 'Your first task in setting up an "intelligent" enemy is to create a NavMesh
    over the arena''s walkable areas. Let''s set up and configure our level''s NavMesh:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置“智能”敌人时，你的第一个任务是创建覆盖竞技场可通行区域的NavMesh。让我们设置并配置我们关卡中的NavMesh：
- en: Select the **Environment** GameObject, click on the arrow icon next to **Static**
    in the **Inspector** window, and choose **Navigation Static**:![](img/B17573_09_01.png)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**环境**GameObject，在**检查器**窗口中点击**静态**旁边的箭头图标，并选择**导航静态**:![](img/B17573_09_01.png)
- en: 'Figure 9.1: Setting objects to Navigation Static'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1：将对象设置为导航静态
- en: Click **Yes, change children** when the dialog window pops up to set all the
    **Environment** child objects to **Navigation Static**:![](img/B17573_09_02.png)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当弹出对话框时，点击**是，更改子对象**，将所有**环境**子对象设置为**导航静态**:![](img/B17573_09_02.png)
- en: 'Figure 9.2: Changing all child objects'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2：更改所有子对象
- en: Go to **Window** | **AI** | **Navigation** and select the **Bake** tab. Leave
    everything set to their default values and click **Bake**. Once baking is finished,
    you'll see a new folder inside the **Scenes** folder with lighting, navigation
    mesh, and reflection probe data:![](img/B17573_09_03.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口** | **AI** | **导航**，并选择**烘焙**选项卡。保持所有设置为默认值，然后点击**烘焙**。一旦烘焙完成，你将在**场景**文件夹内看到一个新文件夹，其中包含光照、导航网格和反射探针数据:![](img/B17573_09_03.png)
- en: 'Figure 9.3: Baking navigation mesh'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：烘焙导航网格
- en: Every object in our level is now marked as **Navigation Static**, which means
    that our newly baked NavMesh has evaluated their accessibility based on its default
    NavMeshAgent settings. Everywhere you can see a light blue overlay in the preceding
    screenshot is a walkable surface for any object with a NavMeshAgent component
    attached, which is your next task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关卡中的每个对象现在都被标记为**导航静态**，这意味着我们新烘焙的NavMesh已经根据其默认NavMeshAgent设置评估了它们的可访问性。在前面的截图中所见到的任何地方都可以看到浅蓝色叠加，这是任何带有NavMeshAgent组件的对象的可通行表面，这是你的下一个任务。
- en: Setting up enemy agents
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置敌人代理
- en: 'Let''s register the Enemy Prefab as a NavMeshAgent:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将敌人预制件注册为NavMeshAgent：
- en: Select the Enemy Prefab in the **Prefabs** folder, click **Add Component** in
    the **Inspector** window, and search for **NavMesh Agent**:![](img/B17573_09_04.png)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**预制件**文件夹中选择敌人预制件，在**检查器**窗口中点击**添加组件**，并搜索**NavMesh Agent**:![](img/B17573_09_04.png)
- en: 'Figure 9.4: Adding a NavMeshAgent component'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4：添加NavMeshAgent组件
- en: 'Click **+** **|** **Create Empty** from the **Hierarchy** window and name the
    GameObject `Patrol_Route`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从**层次结构**窗口中点击**+** **|** **创建空对象**，并将GameObject命名为`Patrol_Route`:'
- en: Select `Patrol_Route`, click **+** **|** **Create Empty** to add a child GameObject,
    and name it `Location_1`. Position `Location_1` in one of the corners of the level:![](img/B17573_09_05.png)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择`Patrol_Route`，点击**+** **|** **创建空对象**以添加子GameObject，并将其命名为`Location_1`。将`Location_1`放置在关卡的一个角落中:![](img/B17573_09_05.png)
- en: 'Figure 9.5: Creating an empty patrol route object'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.5：创建空巡逻路线对象
- en: Create three more empty child objects in `Patrol_Route`, name them `Location_2`,
    `Location_3`, and `Location_4`, respectively, and position them in the remaining
    corners of the level to form a square:![](img/B17573_09_06.png)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Patrol_Route`中创建另外三个空子对象，分别命名为`Location_2`、`Location_3`和`Location_4`，并将它们放置在关卡剩余的角落中形成一个正方形:![](img/B17573_09_06.png)
- en: 'Figure 9.6: Creating all empty patrol route objects'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6：创建所有空巡逻路线对象
- en: Adding a NavMeshAgent component to the Enemy tells the NavMesh component to
    take notice and register it as an object that has access to its autonomous navigation
    features. Creating the four empty game objects in each corner of the level lays
    out the simple route we want our enemies to eventually patrol; grouping them in
    an empty parent object makes it easier to reference them in code and makes for
    a more organized Hierarchy window. All that's left is the code to make the enemy
    walk the patrol route, which you'll add in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将 NavMeshAgent 组件添加到敌人中，告诉 NavMesh 组件注意并将其注册为具有访问其自主导航功能的对象。在每个角落创建四个空的游戏对象，规划出我们希望敌人最终巡逻的简单路线；将它们组合在一个空父对象中，使得在代码中引用它们更容易，并且使
    **Hierarchy** 窗口更加有序。剩下的只是编写让敌人沿着巡逻路线行走的代码，你将在下一节中添加它。
- en: Moving enemy agents
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动敌人代理
- en: 'Our patrol locations are set and the Enemy Prefab has a NavMeshAgent component,
    but now we need to figure out how to reference those locations and get the enemy
    moving on its own. To do that, we''ll first need to talk about an important concept
    in the world of software development: procedural programming.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的巡逻位置已设置，敌人预制体有一个 NavMeshAgent 组件，但现在我们需要弄清楚如何引用这些位置并让敌人自动移动。为此，我们首先需要讨论软件开发领域中的一个重要概念：过程式编程。
- en: Procedural programming
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程式编程
- en: Even though it's in the name, the idea behind procedural programming can be
    elusive until you get your head around it; once you do, you'll never see a code
    challenge the same way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个名字里包含了，直到你真正理解了它，过程式编程背后的想法也可能难以捉摸；一旦你明白了，你就再也不会以同样的方式看待代码挑战了。
- en: Any task that executes the same logic on one or more sequential objects is the
    perfect candidate for procedural programming. You already did a little procedural
    programming when you debugged arrays, lists, and dictionaries with `for` and `foreach`
    loops. Each time those looping statements were executed, you performed the same
    call to `Debug.Log()`, iterating over each item sequentially. The idea now is
    to use that skill to get a more useful outcome.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在单个或多个连续对象上执行相同逻辑的任务都是过程式编程的完美候选者。当你使用 `for` 和 `foreach` 循环调试数组、列表和字典时，你已经进行了一点点过程式编程。每次这些循环语句执行时，你都会对
    `Debug.Log()` 执行相同的调用，按顺序遍历每个项目。现在的想法是利用这项技能来获得更有用的结果。
- en: One of the most common uses of procedural programming is adding items from one
    collection to another, often modifying them along the way. This works great for
    our purposes since we want to reference each child object in the `Patrol_Route`
    parent and store them in a list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 过程式编程最常见的一种用途是将一个集合中的项目添加到另一个集合中，通常在过程中修改它们。这对于我们的目的来说非常适用，因为我们想引用 `Patrol_Route`
    父对象中的每个子对象并将它们存储在列表中。
- en: Referencing the patrol locations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用巡逻位置
- en: 'Now that we understand the basics of procedural programming, it''s time to
    get a reference to our patrol locations and assign them to a usable list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了过程式编程的基础，是时候获取我们的巡逻位置并将它们分配给一个可用的列表了：
- en: 'Add the following code to `EnemyBehavior`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `EnemyBehavior`：
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select `Enemy` and drag the `Patrol_Route` object from the **Hierarchy** window
    onto the **Patrol Route** variable in `EnemyBehavior`:![](img/B17573_09_07.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Enemy`，并将 **Hierarchy** 窗口中的 `Patrol_Route` 对象拖动到 `EnemyBehavior` 中的 **Patrol
    Route** 变量上：![img/B17573_09_07.png](img/B17573_09_07.png)
- en: 'Figure 9.7: Dragging Patrol_Route to the enemy script'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7：将 Patrol_Route 拖动到敌人脚本中
- en: Hit the arrow icon next to the **Locations** variable in the **Inspector** window
    and run the game to see the list populate:![](img/B17573_09_08.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Inspector** 窗口中 **Locations** 变量旁边的箭头图标，并运行游戏以查看列表填充：![img/B17573_09_08.png](img/B17573_09_08.png)
- en: 'Figure 9.8: Testing procedural programming'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.8：测试过程式编程
- en: 'Let''s break down the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a variable for storing the `PatrolRoute` empty parent GameObject.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个用于存储 `PatrolRoute` 空父 GameObject 的变量。
- en: Then, it declares a `List` variable to hold all the child `Transform` components
    in `PatrolRoute`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它声明了一个 `List` 变量来存储 `PatrolRoute` 中的所有子 `Transform` 组件。
- en: After that, it uses `Start()` to call the `InitializePatrolRoute()` method when
    the game begins.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它使用 `Start()` 在游戏开始时调用 `InitializePatrolRoute()` 方法。
- en: 'Next, it creates `InitializePatrolRoute()` as a private utility method to procedurally
    fill `Locations` with `Transform` values:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它创建了一个名为 `InitializePatrolRoute()` 的私有实用方法，以过程式地填充 `Locations` 中的 `Transform`
    值：
- en: Remember that not including an access modifier makes variables and methods `private`
    by default.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，如果不包含访问修饰符，变量和方法默认为 `private`。
- en: 'Then, we use a `foreach` statement to loop through each child GameObject in
    `PatrolRoute` and reference its Transform component:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`foreach`语句遍历`PatrolRoute`中的每个子GameObject并引用其Transform组件：
- en: Each Transform component is captured in the local `child` variable declared
    in the `foreach` loop.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Transform组件都被捕获在`foreach`循环中声明的局部`child`变量中。
- en: 'Finally, we add each sequential `child` `Transform` component to the list of
    locations using the `Add()` method as we loop through the child objects in `PatrolRoute`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在遍历`PatrolRoute`中的子对象时，使用`Add()`方法将每个连续的`child` `Transform`组件添加到位置列表中：
- en: This way, no matter what changes we make in the **Hierarchy** window, `Locations`
    will always be filled in with all the `child` objects under the `PatrolRoute`
    parent.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样，无论我们在**Hierarchy**窗口中做出什么更改，`Locations`都将始终填充`PatrolRoute`父对象下的所有`child`对象。
- en: While we could have assigned each location GameObject to `Locations` by dragging
    and dropping them directly from the **Hierarchy** window into the **Inspector**
    window, it's easy to lose or break these connections; making changes to the location
    object names, object additions or deletions, or project updates can all throw
    a wrench into a class's initialization. It's much safer, and more readable, to
    procedurally fill GameObject lists or arrays in the `Start()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过直接从**Hierarchy**窗口拖放每个位置GameObject到**Inspector**窗口来将每个位置GameObject分配给`Locations`，但很容易丢失或破坏这些连接；更改位置对象名称、对象添加或删除，或项目更新都可能破坏一个类的初始化。在`Start()`方法中程序化填充GameObject列表或数组要安全得多，也更易于阅读。
- en: Due to that reasoning, I also tend to use `GetComponent()` in the `Start()`
    method to find and store component references attached to a given class instead
    of assigning them in the **Inspector** window.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我也倾向于在`Start()`方法中使用`GetComponent()`来查找并存储附加到给定类的组件引用，而不是在**Inspector**窗口中分配它们。
- en: Now, we need the enemy object to follow the patrol route we laid out, which
    is your next task.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让敌人对象跟随我们设定的巡逻路线，这是你的下一个任务。
- en: Moving the enemy
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动敌人
- en: With a list of patrol locations initialized on `Start()`, we can grab the enemy
    NavMeshAgent component and set its first destination.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start()`方法中初始化巡逻位置列表后，我们可以获取敌人的NavMeshAgent组件并设置其第一个目的地。
- en: 'Update `EnemyBehavior` with the following code and hit play:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`EnemyBehavior`并播放：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it adds the `UnityEngine.AI` `using` directive so that `EnemyBehavior`
    has access to Unity's navigation classes, in this case, `NavMeshAgent`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它添加了`UnityEngine.AI` `using`指令，这样`EnemyBehavior`就可以访问Unity的导航类，在这种情况下是`NavMeshAgent`。
- en: Then, it declares a variable to keep track of which patrol location the enemy
    is currently walking toward. Since `List` items are zero-indexed, we can have
    the Enemy Prefab move between patrol points in the order they are stored in `Locations`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它声明一个变量来跟踪敌人当前正在走向哪个巡逻位置。由于`List`项是零索引的，我们可以让敌人预制体按`Locations`中存储的顺序在巡逻点之间移动。
- en: Next, it declares a variable to store the NavMeshAgent component attached to
    the Enemy GameObject. This is `private` because no other classes should be able
    to access or modify it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它声明一个变量来存储附加到Enemy GameObject的NavMeshAgent组件。这是`private`的，因为其他类不应该能够访问或修改它。
- en: After that, it uses `GetComponent()` to find and return the attached NavMeshAgent
    component to the agent.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它使用`GetComponent()`来查找并返回附加到代理的NavMeshAgent组件。
- en: Then, it calls the `MoveToNextPatrolLocation()` method on `Start()`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它在`Start()`上调用`MoveToNextPatrolLocation()`方法。
- en: 'Finally, it declares `MoveToNextPatrolLocation()` as a private method and sets
    `_agent.destinat``ion`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它声明`MoveToNextPatrolLocation()`为一个私有方法并设置`_agent.destinat``ion`：
- en: '`destination` is a `Vector3` position in 3D space.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destination`是3D空间中的`Vector3`位置。'
- en: '`Locations[_locationIndex]` grabs the Transform item in `Locations` at a given
    index.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Locations[_locationIndex]`在`Locations`中获取给定索引的Transform项。'
- en: Adding `.position` references the Transform component's `Vector3` position.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`.position`引用Transform组件的`Vector3`位置。
- en: Now, when our scene starts, locations are filled with patrol points and `MoveToNextPatrolLocation()`
    is called to set the destination position of the NavMeshAgent component to the
    first item at `_locationIndex 0` in the list of locations. The next step is to
    have the enemy object move from the first patrol location to all the other locations
    in sequence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的场景开始时，位置被巡逻点填充，并调用`MoveToNextPatrolLocation()`来设置NavMeshAgent组件的目标位置为位置列表中第一个项目`_locationIndex
    0`。下一步是让敌人对象按顺序从第一个巡逻位置移动到所有其他位置。
- en: Our enemy moves to the first patrol point just fine, but then it stops. What
    we want is for it to continually move between each sequential location, which
    will require additional logic in `Update()` and `MoveToNextPatrolLocation()`.
    Let's create this behavior.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敌人的敌人移动到第一个巡逻点没有问题，但然后它就停了下来。我们想要的它是在每个连续位置之间不断移动，这需要在`Update()`和`MoveToNextPatrolLocation()`中添加额外的逻辑。让我们创建这种行为。
- en: 'Add the following code to `EnemyBehavior` and hit play:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`EnemyBehavior`中并播放：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s break down the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: 'First, it declares the `Update()` method and adds an `if` statement to check
    whether two different conditions are true:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了`Update()`方法并添加了一个`if`语句来检查两个不同的条件是否为真：
- en: '`remainingDistance` returns how far the NavMeshAgent component currently is
    from its set destination`,` so we''re checking if that is less than 0.2.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remainingDistance`返回NavMeshAgent组件当前距离其设定目的地的距离，所以我们在检查它是否小于0.2。'
- en: '`pathPending` returns a `true` or `false` Boolean, depending on whether Unity
    is computing a path for the NavMeshAgent component.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathPending`返回一个`true`或`false`布尔值，具体取决于Unity是否正在为NavMeshAgent组件计算路径。'
- en: If _`agent` is very close to its destination, and no other path is being computed,
    the `if` statement returns `true` and calls `MoveToNextPatrolLocation()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`_agent`非常接近其目的地，并且没有其他路径正在计算，则`if`语句返回`true`并调用`MoveToNextPatrolLocation()`。
- en: 'Here, we added an `if` statement to make sure that `Locations` isn''t empty
    before the rest of the code in `MoveToNextPatrolLocation()` is executed:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`if`语句，以确保在执行`MoveToNextPatrolLocation()`中的其余代码之前，`Locations`不为空：
- en: If `Locations` is empty, we use the `return` keyword to exit the method without
    continuing.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Locations`为空，我们使用`return`关键字退出方法而不继续执行。
- en: This is referred to as defensive programming, and, coupled with refactoring,
    it is an essential skill to have in your arsenal as you move toward more intermediate
    C# topics. We will consider refactoring at the end of the chapter.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这被称为防御性编程，并且，与重构相结合，这是你在向更高级的C#主题迈进时必须具备的一项基本技能。我们将在本章末尾考虑重构。
- en: 'Then, we set `_locationIndex` to its current value, `+1`, followed by the modulo
    (`%`) of `Locations.Count`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`_locationIndex`设置为它的当前值，`+1`，然后是`Locations.Count`的取模（`%`）：
- en: This will increment the index from 0 to 4 and then restart it at 0 so that our
    Enemy Prefab moves in a continuous path.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将使索引从0增加到4，然后重新开始从0开始，这样我们的敌人预制体就可以在连续的路径上移动。
- en: The modulo operator returns the remainder of two values being divided—2 divided
    by 4 has a remainder of 2 when the result is an integer, so 2 % 4 = 2\. Likewise,
    4 divided by 4 has no remainder, so 4 % 4 = 0.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取模运算符返回两个值相除的余数——当结果为整数时，2除以4的余数为2，所以2 % 4 = 2。同样，4除以4没有余数，所以4 % 4 = 0。
- en: Dividing an index by the maximum number of items in a collection is a quick
    way to always find the next item. If you're rusty on the modulo operator, revisit
    *Chapter 2*, *The Building Blocks of Programming*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引除以集合中最大项目数是一种快速找到下一个项目的方法。如果你对取模运算符不太熟悉，请回顾*第2章*，*编程的基石*。
- en: We now need to check that the enemy is moving toward its set patrol location
    every frame in `Update()`; when it gets close, `MoveToNextPatrolLocation()` is
    fired, which increments `_locationIndex` and sets the next patrol point as the
    destination.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要检查敌人是否在每一帧的`Update()`中向其设定的巡逻位置移动；当它接近时，`MoveToNextPatrolLocation()`被触发，这将增加`_locationIndex`并将下一个巡逻点设置为目的地。
- en: 'If you drag the **Scene** view down next to the **Console** window, as shown
    in the following screenshot, and hit play, you can watch the Enemy Prefab walk
    around the corners of the level in a continuous loop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将**场景**视图拖到**控制台**窗口旁边，如图下所示，并播放，你可以看到敌人预制体在关卡角落处连续循环行走：
- en: '![](img/B17573_09_09.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_09_09.png)'
- en: 'Figure 9.9: Testing the enemy patrol route'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：测试敌人巡逻路线
- en: The enemy now follows the patrol route around the outside of the map, but it
    doesn't seek out the player and attack when it's within a preset range. You'll
    use the NavAgent component to do just that in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人现在沿着地图外部的巡逻路线移动，但它不会在预设范围内寻找玩家并攻击。你将在下一节中使用NavAgent组件来完成这个动作。
- en: Enemy game mechanics
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人游戏机制
- en: Now that our enemy is on a continuous patrol circuit, it's time to give it some
    interaction mechanics of its own; there wouldn't be much risk or reward if we
    left it walking around with no way to act against us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们敌人的巡逻路线是连续的，是时候给它一些自己的交互机制了；如果我们让它无动于衷地四处走动，那么风险和回报都不会很大。
- en: 'Seek and destroy: changing the agent''s destination'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找并摧毁：改变代理的目标
- en: In this section, we'll be focusing on switching the target of the enemies' NavMeshAgent
    component when the player gets too close and dealing damage if a collision occurs.
    When the enemy successfully lowers the player's health, it will return to its
    patrol route until its next run-in with the player.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注当玩家太近时切换敌人NavMeshAgent组件的目标，并在发生碰撞时造成伤害。当敌人成功降低玩家的生命值时，它将返回到其巡逻路线，直到下一次与玩家的遭遇。
- en: However, we're not going to leave our player helpless; we'll also add in code
    to track enemy health, detect when an enemy is successfully hit with one of the
    player's bullets, and when an enemy needs to be destroyed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会让我们的玩家无助；我们还会添加代码来跟踪敌人生命值，检测当敌人被玩家的子弹成功击中时，以及当敌人需要被摧毁时。
- en: Now that the Enemy Prefab is moving around on patrol, we need to get a reference
    to the player's position and change the destination of NavMeshAgent if it gets
    too close.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人预制件正在巡逻移动，我们需要获取玩家的位置引用并更改NavMeshAgent的目标，如果它太近的话。
- en: 'Add the following code to `EnemyBehavior`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`EnemyBehavior`中：
- en: '[PRE3]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a `public` variable to hold the `Player` capsule's `Transform`
    value.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个`public`变量来保存`Player`胶囊的`Transform`值。
- en: 'Then, we use `GameObject.Find("Player")` to return a reference to the player
    object in the scene:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`GameObject.Find("Player")`来返回场景中玩家对象的引用：
- en: Adding `.transform` directly references the object's `Transform` value in the
    same line.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一行中添加`.transform`直接引用对象的`Transform`值。
- en: Finally, we set `_agent.destination` to the player's `Vector3` position in `OnTriggerEnter()`
    whenever the player enters the enemies' attack zone that we set up earlier with
    a Collider component.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`OnTriggerEnter()`中，我们将`_agent.destination`设置为玩家的`Vector3`位置，每当玩家进入我们之前使用Collider组件设置的敌人攻击区域时。
- en: If you play the game now and get too close to the patrolling enemy, you'll see
    that it breaks from its path and comes straight for you. Once it reaches the player,
    the code in the `Update()` method takes over again and the Enemy Prefab resumes
    its patrol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏并且离巡逻的敌人太近，你会看到它从其路径上断开并直接向你冲来。一旦它到达玩家，`Update()`方法中的代码就会接管，敌人预制件继续巡逻。
- en: We still need the enemy to be able to hurt the player in some way, which we'll
    learn how to do in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要敌人能够以某种方式伤害玩家，我们将在下一节中学习如何做到这一点。
- en: Lowering player health
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低玩家生命值
- en: While our enemy mechanic has come a long way, it's still anti-climactic to have
    nothing happen when the Enemy Prefab collides with the player Prefab. To fix this,
    we'll tie in the new enemy mechanics with the game manager.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的敌人机制已经取得了很大的进步，但当敌人预制件与玩家预制件碰撞时没有任何事情发生仍然令人失望。为了解决这个问题，我们将新的敌人机制与游戏管理器联系起来。
- en: 'Update `PlayerBehavior` with the following code and hit play:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`PlayerBehavior`并播放：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s break down the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a `private` variable to hold the reference to the instance
    of `GameBehavior` we have in the scene.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个`private`变量来保存场景中`GameBehavior`实例的引用。
- en: 'Then, it finds and returns the `GameBehavior` script that''s attached to the
    `Game Manager` object in the scene:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它找到并返回场景中`Game Manager`对象附加的`GameBehavior`脚本：
- en: Using `GetComponent()` on the same line as `GameObject.Find()` is a common way
    to cut down on unnecessary lines of code.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GameObject.Find()`的同一行上使用`GetComponent()`是一种常见的减少不必要的代码行数的方法。
- en: Since our player is the object being collided with, it makes sense to declare
    `OnCollisionEnter()` in `PlayerBehavior`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的玩家是被碰撞的对象，因此在`PlayerBehavior`中声明`OnCollisionEnter()`是有意义的。
- en: Next, we check for the name of the colliding object; if it's the Enemy Prefab,
    we execute the body of the `if` statement.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查碰撞对象的名称；如果是敌人预制件，我们执行`if`语句的主体。
- en: Finally, we subtract `1` from the public `HP` variable using the `_gameManager`
    instance.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`_gameManager`实例从公共`HP`变量中减去`1`。
- en: Whenever the enemy now tracks and collides with the player, the game manager
    will fire the set property on HP. The UI will update with a new value for player
    health, which means we have an opportunity to put in some additional logic for
    the loss condition later on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的敌人现在跟踪并碰撞到玩家时，游戏管理器将触发HP的设置属性。UI将更新为玩家健康的新值，这意味着我们有机会在稍后添加一些额外的逻辑来处理损失条件。
- en: Detecting bullet collisions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测子弹碰撞
- en: Now that we have our loss condition, it's time to add in a way for our player
    to fight back and survive enemy attacks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了失败条件，是时候添加一种让我们的玩家能够反击并生存下来对抗敌人攻击的方法了。
- en: 'Open up `EnemyBehavior` and modify it with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`EnemyBehavior`并使用以下代码进行修改：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s break down the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a `private int` variable called `_lives` with a `public`
    backing variable called `EnemyLives`. This will let us control how `EnemyLives`
    is referenced and set, just like in `GameBehavior`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为`_lives`的`private int`变量，以及一个名为`EnemyLives`的`public`辅助变量。这将使我们能够控制如何引用和设置`EnemyLives`，就像在`GameBehavior`中一样。
- en: Then, we set the `get` property to always return `_lives`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`get`属性设置为始终返回`_lives`。
- en: Next, we use `private set` to assign the new value of `EnemyLives` to `_lives`
    to keep them both in sync.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`private set`将`EnemyLives`的新值分配给`_lives`，以保持它们同步。
- en: We haven't seen `private get` or `set` before, but they can have their access
    modifiers, just like any other executable code. Declaring `get` or `set` as `private`
    means that only the parent class has access to their functionality.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们之前没有见过`private get`或`set`，但它们可以有它们的访问修饰符，就像任何其他可执行代码一样。将`get`或`set`声明为`private`意味着只有父类可以访问它们的功能。
- en: 'Then, we add an `if` statement to check whether `_lives` is less than or equal
    to 0, meaning that the enemy should be dead:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`if`语句来检查`_lives`是否小于或等于0，这意味着敌人应该死了：
- en: When that's the case, we destroy the `Enemy` GameObject and print out a message
    to the console.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们销毁`Enemy` GameObject并在控制台打印出一条消息。
- en: Because `Enemy` is the object getting hit with bullets, it's sensible to include
    a check for those collisions in `EnemyBehavior` with `OnCollisionEnter()`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Enemy`是子弹击中的对象，因此在`EnemyBehavior`中包含`OnCollisionEnter()`检查这些碰撞是有意义的。
- en: Finally, if the name of the colliding object matches a bullet clone object,
    we decrement `EnemyLives` by `1` and print out another message.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果碰撞对象的名称与子弹克隆对象匹配，我们将`EnemyLives`减`1`并打印出另一条消息。
- en: Notice that the name we're checking for is `Bullet(Clone)`, even though our
    bullet Prefab is named `Bullet`. This is because Unity adds the `(Clone)` suffix
    to any object created with the `Instantiate()` method, which is how we made them
    in our shooting logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在检查的名称是`Bullet(Clone)`，尽管我们的子弹Prefab命名为`Bullet`。这是因为Unity会将`(Clone)`后缀添加到使用`Instantiate()`方法创建的任何对象上，这是我们射击逻辑中创建它们的方式。
- en: You can also check for the GameObjects' tag, but since that's a Unity-specific
    feature, we're going to leave the code as-is and do things with pure C#.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以检查GameObject的标签，但由于这是一个Unity特定的功能，我们将保持代码不变，并使用纯C#进行操作。
- en: Now, the player can fight back when the enemy tries to take one of its lives
    by shooting it three times and destroying it. Again, our use of the `get` and
    `set` properties to handle additional logic proves to be a flexible and scalable
    solution. With that done, your final task is to update the game manager with a
    loss condition.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当敌人试图夺走玩家的一条生命时，玩家可以通过射击敌人三次并摧毁它来进行反击。再次，我们使用`get`和`set`属性来处理附加逻辑，这证明是一个灵活且可扩展的解决方案。完成这些后，你的最终任务是更新游戏管理器以包含失败条件。
- en: Updating the game manager
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏管理器
- en: 'To fully implement the loss condition, we need to update the manager class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全实现失败条件，我们需要更新管理器类：
- en: 'Open up `GameBehavior` and add the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameBehavior`并添加以下代码：
- en: '[PRE6]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the **Hierarchy** window, right-click on **Win Condition**, choose **Duplicate**,
    and name it **Loss Condition**:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，右键单击**胜利条件**，选择**复制**，并将其命名为**失败条件**：
- en: Click the arrow to the left of **Loss Condition** to expand it, select the **Text**
    object, and change the text to **You lose...**
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**失败条件**左侧的箭头以展开它，选择**文本**对象，并将其文本更改为**你输了...**
- en: Select **Game_Manager** in the **Hierarchy** window and drag **Loss Condition**
    into the **Loss Button** slot in the **Game Behavior (Script)** component:![](img/B17573_09_11.png)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**Game_Manager**，并将**失败条件**拖放到**游戏行为（脚本）**组件中的**失败按钮**槽位中！![img/B17573_09_11.png]
- en: 'Figure 9.10: Game behavior script with text and button variables completed
    in the Inspector pane'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.10：在检查器面板中完成文本和按钮变量后的游戏行为脚本
- en: 'Let''s break down the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, we declare a new button that we want to show when the player loses the
    game.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明一个新按钮，当玩家输掉游戏时我们将显示它。
- en: 'Then, we add in an `if` statement to check when `_playerHP` drops below `0`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`if`语句来检查`_playerHP`是否低于`0`：
- en: If it's `true`, `ProgessText` and `Time.timeScale` are updated and the loss
    button is activated.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是`true`，则`ProgessText`和`Time.timeScale`会更新，并且损失按钮会被激活。
- en: 'If the player is still alive following an enemy collision, `ProgessText` shows
    a different message: "Ouch… that''s got to hurt.".'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在遭遇敌人碰撞后仍然存活，`ProgessText`会显示不同的信息：“哎哟……这肯定很疼。”。
- en: Now, change _`playerHP` to 1 in `GameBehavior.cs` and get the Enemy Prefab to
    collide with you and observe what happens.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`GameBehavior.cs`中将`_playerHP`改为1，并让敌人预制体与你发生碰撞，观察会发生什么。
- en: That's a wrap! You've successfully added a "smart" enemy that can damage the
    player and be damaged right back, as well as a loss screen through the game manager.
    Before we finish this chapter, there's one more important topic that we need to
    discuss, and that's how to avoid repeating code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经成功添加了一个“智能”敌人，它可以伤害玩家并反过来被伤害，以及通过游戏管理器实现的损失屏幕。在我们完成这一章之前，还有一个更重要的话题需要讨论，那就是如何避免重复代码。
- en: Repeated code is the bane of all programmers, so it makes sense that you learn
    how to keep it out of your projects early on!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的代码是所有程序员的噩梦，因此你很早就学会如何避免它在你的项目中出现是有意义的！
- en: Refactoring and keeping it DRY
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构和保持DRY
- en: 'The **Don''t Repeat Yourself** (**DRY**) acronym is the software developer''s
    conscience: it tells you when you''re in danger of making a bad or questionable
    decision, and gives you a feeling of satisfaction after a job well done.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY**（不要重复自己）这个缩写是软件开发者的良心：它告诉你何时你可能会做出错误或可疑的决定，并在工作完成后给你一种满足感。'
- en: In practice, repeated code is part of programming life. Trying to avoid it by
    constantly thinking ahead will put up so many roadblocks in your project that
    it won't seem worthwhile carrying on. A more efficient—and sane—approach to dealing
    with repeating code is to quickly identify it when and where it occurs and then
    look for the best way to remove it. This task is called refactoring, and our `GameBehavior`
    class could use a little of its magic right now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，重复的代码是编程生活的一部分。试图通过不断思考来避免它，会在你的项目中设置许多障碍，以至于继续下去似乎不值得。处理重复代码的一个更有效且理智的方法是快速识别它何时何地发生，然后寻找最佳方法来移除它。这项任务被称为重构，而我们的`GameBehavior`类现在正需要一点它的魔力。
- en: You may have noticed that we set the progress text and timescale in two separate
    places, but we could easily make ourselves a utility method to do this for us
    in a single place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在两个不同的地方设置了进度文本和时间范围，但我们可以轻松地为自己创建一个工具方法，在单个地方完成这项工作。
- en: 'To refactor the existing code, you''ll need to update `GameBehavior.cs` as
    follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要重构现有代码，你需要按照以下方式更新`GameBehavior.cs`：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: We declared a new method called `UpdateScene`, which takes in a string parameter
    that we want to assign to `ProgressText` and sets `Time.timeScale` to `0`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`UpdateScene`的新方法，它接受一个字符串参数，我们希望将其分配给`ProgressText`，并将`Time.timeScale`设置为`0`。
- en: We deleted our first instance of duplicated code and used our new method to
    update our scene when the game is won.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了第一个重复代码的实例，并使用我们的新方法在游戏胜利时更新场景。
- en: We deleted our second instance of duplicated code and update the scene when
    the game is lost.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了第二个重复代码的实例，并在游戏失败时更新场景。
- en: There's always more to refactor if you look in the right places.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找对了地方，总还有更多可以重构的地方。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, our enemy and player interactions are complete. We can dish out damage
    as well as take it, lose lives, and fight back, all while updating the on-screen
    GUI. Our enemies use Unity's navigation system to walk around the arena and change
    to attack mode when within a specified range of the player. Each GameObject is
    responsible for its behavior, internal logic, and object collisions, while the
    game manager keeps track of the variables that govern the game's state. Lastly,
    we learned about simple procedural programming and how much cleaner code can be
    when repeated instructions are abstracted out into their methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的敌人和玩家交互已经完成。我们可以造成伤害，也可以承受伤害，失去生命，并反击，同时更新屏幕上的GUI。我们的敌人使用Unity的导航系统在竞技场周围行走，并在达到玩家指定范围内时切换到攻击模式。每个GameObject负责其行为、内部逻辑和对象碰撞，而游戏管理器则跟踪控制游戏状态的变量。最后，我们学习了简单的过程式编程以及当重复指令被抽象到方法中时代码可以多么简洁。
- en: You should feel a sense of accomplishment at this point, especially if you started
    this book as a total beginner. Getting up to speed with a new programming language
    while building a working game is no easy trick. In the next chapter, you'll be
    introduced to some intermediate topics in C#, including new type modifiers, method
    overloading, interfaces, and class extensions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该感到一种成就感，尤其是如果你是作为一个完全的初学者开始这本书的。在构建一个可工作的游戏的同时掌握一门新的编程语言并非易事。在下一章中，你将接触到
    C# 的一些中级主题，包括新的类型修饰符、方法重载、接口和类扩展。
- en: Pop quiz – AI and navigation
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验 - 人工智能与导航
- en: How is a NavMesh component created in a Unity scene?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 场景中如何创建 NavMesh 组件？
- en: What component identifies a GameObject to a NavMesh?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个组件将 GameObject 识别为 NavMesh？
- en: Executing the same logic on one or more sequential objects is an example of
    which programming technique?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个或多个连续对象上执行相同的逻辑是哪种编程技术的例子？
- en: What does the DRY acronym stand for?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRY 这个缩写代表什么？
- en: JOIN us on Discord!
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C# 专家和哈里森·费罗尼一起阅读这本书。提问，为其他读者提供解决方案，通过 *问我任何问题* 会话与作者聊天等等。
- en: Join Now!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加入我们！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
