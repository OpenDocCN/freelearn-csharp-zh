<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer092">
<h1 class="chapter-number" id="_idParaDest-218"><a id="_idTextAnchor238"/>14</h1>
<h1 id="_idParaDest-219"><a id="_idTextAnchor239"/>Troubleshooting and Debugging Tips</h1>
<p>Congratulations on making it this far in your journey to mastering the MVVM pattern in .NET MAUI! By now, you’ve learned about the intricacies of data binding, dependency injection, converters, and various other components that make up your <em class="italic">Recipes!</em> app. However, as any seasoned developer will tell you, even the most experienced experts encounter roadblocks from time <span class="No-Break">to time.</span></p>
<p>MVVM, with all its benefits, can sometimes feel like navigating a complex maze. When you encounter issues, it’s not always obvious where to find the root cause or how to fix it. That’s where this chapter comes in. In this short but invaluable chapter, we’ll shine a light on common pitfalls and challenges you may face during your <span class="No-Break">MVVM journey.</span></p>
<p>We’ll explore three areas where issues often tend <span class="No-Break">to occur:</span></p>
<ul>
<li>Common data <span class="No-Break">binding issues</span></li>
<li>Services and Dependency <span class="No-Break">Injection pitfalls</span></li>
<li>Frequent custom control and <span class="No-Break">converter problems</span></li>
</ul>
<p>Let’s get started on our journey through these common stumbling blocks. By the end of this chapter, you’ll be better equipped to troubleshoot and conquer the challenges that MVVM in .NET MAUI may throw <span class="No-Break">your way.</span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor240"/>Technical requirements</h1>
<p>To ensure you’re in sync with the upcoming content, make your way to our GitHub repository at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter14">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter14</a>. Kick off with the materials in the <strong class="source-inline">Start</strong> folder. And remember, if you’re ever in need of a consolidated reference, the <strong class="source-inline">Finish</strong> folder holds the final, refined code at the <span class="No-Break">chapter’s close.</span></p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor241"/>Common data binding issues</h1>
<p>One of the cornerstones<a id="_idIndexMarker919"/> of the MVVM pattern is data binding. It forms the link between your View and ViewModel, ensuring seamless communication between them. While data binding offers powerful capabilities, it’s also an area where developers often face challenges. This section aims to shed light on common data binding and ViewModel issues and how to <span class="No-Break">troubleshoot them:</span></p>
<ul>
<li><strong class="bold">Typos and mismatched names</strong>: One of the simplest yet surprisingly common issues developers encounter is typos or mismatched property names. A small typo in your XAML markup or ViewModel code can disrupt the entire data <span class="No-Break">binding process.</span></li>
<li><strong class="bold">Incorrect binding modes</strong>: Data binding supports various modes such as <strong class="source-inline">OneWay</strong>, <strong class="source-inline">TwoWay</strong>, and <strong class="source-inline">OneTime</strong>, each with its own purpose, as we’ve seen in <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .NET MAUI</em>. Using the wrong mode can lead to unexpected behavior in <span class="No-Break">your app.</span></li>
<li><strong class="bold">Binding incompatible data types</strong>: Obviously, binding a property of type <strong class="source-inline">int</strong> to a property of type <strong class="source-inline">Color</strong> on a UI control won’t work, despite XAML supporting implicit type conversion in <span class="No-Break">certain cases.</span></li>
<li><strong class="bold">PropertyChanged event not fired</strong>: ViewModel properties must notify the view of changes by raising <strong class="source-inline">PropertyChanged</strong> events. What happens when these events don’t trigger as expected? The View will not be updated to reflect the changes in the <span class="No-Break">ViewModel’s data.</span></li>
<li><strong class="bold">Updating collections</strong>: More or less related to the previous point, handling collections in MVVM is often misunderstood, especially when working with <strong class="source-inline">ObservableCollection</strong>. Make sure your collections update correctly and avoid the pitfall of inadvertently assigning a <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">ObservableCollection</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Data binding scope confusion</strong>: When you bind data within a <strong class="source-inline">ListView</strong> or <strong class="source-inline">CollectionView</strong>, keep in mind that each item in the collection creates its own data binding scope. This means that when attempting to bind a property or command that resides in the ViewModel rather than the individual item, you’ll need to use techniques such as relative or element binding to correctly reference the <span class="No-Break">desired context.</span></li>
<li><strong class="bold">Data binding in behaviors</strong>: Behaviors exist outside the visual tree, which means they do not have the same capability for locating ancestors as other UI <span class="No-Break">elements do.</span></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Some of these pitfalls, such as typos in property names and binding incompatible data types, can be avoided by leveraging compiled bindings, as stipulated in <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .</em><span class="No-Break"><em class="italic">NET MAUI</em></span><span class="No-Break">.</span></p>
<p>As you can see, a lot of issues<a id="_idIndexMarker920"/> related to data binding can arise. Luckily, some of them aren’t that hard to spot and fix, as long as you know where to look. Let’s start off by looking at some tools in <span class="No-Break">Visual Studio.</span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor242"/>Checking the Output and XAML Binding Failures window</h2>
<p>With both the <strong class="bold">Output</strong> window and <strong class="bold">XAML Binding Failures</strong> window<a id="_idIndexMarker921"/> in Visual Studio, typos or mismatched<a id="_idIndexMarker922"/> property names<a id="_idIndexMarker923"/> can easily<a id="_idIndexMarker924"/> be spotted. <span class="No-Break">Here’s how:</span></p>
<ol>
<li>Let’s first introduce two faulty data binding statements in our code. On <strong class="source-inline">RecipesOverviewPage</strong>, update the <strong class="source-inline">Image</strong> and <strong class="source-inline">Label</strong> elements in the <strong class="source-inline">CollectionView</strong>’s <strong class="source-inline">ItemTemplate</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;CollectionView.ItemTemplate&gt;
    &lt;DataTemplate&gt;
        ...
            &lt;Image
                Aspect="AspectFill"
                HorizontalOptions="Fill"
                <strong class="bold">Source="{Binding IsFavorite}"</strong>
                VerticalOptions="Fill" /&gt;
            ...
            &lt;Label
                Grid.Row="1"
                Margin="20,5,20,40"
                FontSize="16"
                HorizontalOptions="Fill"
                HorizontalTextAlignment="Start"
                MaxLines="2"
                <strong class="bold">Text="{Binding Titel}"</strong>
                TextColor="Black"
                VerticalOptions="Center" /&gt;
        ...
    &lt;/DataTemplate&gt;
&lt;/CollectionView.ItemTemplate&gt;</pre></li> <li>Run the app. While the app<a id="_idIndexMarker925"/> is running, head<a id="_idIndexMarker926"/> over to Visual Studio<a id="_idIndexMarker927"/> and open up the <strong class="bold">Output</strong> window. If it’s not already open, you can open<a id="_idIndexMarker928"/> it through <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Output</strong>. Notice <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">[0:] Microsoft.Maui.Controls.Xaml.Diagnostics.Binding</strong>
<strong class="bold">Diagnostics: Warning: 'False' cannot be converted to</strong>
<strong class="bold">type 'Microsoft.Maui.Controls.ImageSource'</strong>
<strong class="bold">[0:] Microsoft.Maui.Controls.Xaml.Diagnostics.Binding</strong>
<strong class="bold">Diagnostics: Warning: 'Titel' property not found on</strong>
<strong class="bold">'Recipes.Client.Core.ViewModels.RecipeListItemView</strong>
<strong class="bold">Model', target property: 'Microsoft.Maui</strong>
<strong class="bold">.Controls.Label.Text'</strong></pre><p class="list-inset">See how the <strong class="bold">Output</strong> window warns us about two things. The first warning notifies us about an incompatible data type: a <strong class="source-inline">bool</strong> value cannot be converted to an <strong class="source-inline">ImageSource</strong> type. The second warning signals that a property named <strong class="source-inline">Titel</strong> cannot be found on the <strong class="source-inline">RecipeListItemViewModel</strong>. That, of course, is <span class="No-Break">a typo!</span></p></li> <li>Alternatively, let’s have a look at the <strong class="bold">XAML Binding Failures</strong> window in Visual Studio. This can be opened through <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> | <strong class="bold">XAML Binding Failures</strong>. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.1</em> shows what this window <span class="No-Break">looks like:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 14.1: XAML Binding Failures window" height="303" src="image/B20941_14_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: XAML Binding Failures window</p>
<p class="list-inset">This window gives us the same information as the <strong class="bold">Output</strong> window. Additionally, it shows extra information such as where the failing binding statement is located and how many times this issue has occurred. The best thing about this window? When clicking on an item in this list, Visual Studio will open the XAML file where the faulty binding statement is located and will put the pointer on the exact data binding statement that contains <span class="No-Break">the error.</span></p>
<p>Whenever you have<a id="_idIndexMarker929"/> a binding failure<a id="_idIndexMarker930"/> in your application, the <strong class="bold">XAML Binding Failures</strong> window and the <strong class="bold">Output</strong> window in Visual Studio<a id="_idIndexMarker931"/> will provide information<a id="_idIndexMarker932"/> about what went wrong. The <strong class="bold">XAML Binding Failures</strong> window, especially, provides immediate insight into typos, missing properties, or data type issues. Always keep an eye on this window when developing <span class="No-Break">your views.</span></p>
<p>Another way to troubleshoot or debug data binding issues is by creating and leveraging a specialized converter. Let’s have <span class="No-Break">a look!</span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor243"/>Debugging with a DoNothingConverter</h2>
<p>A <strong class="source-inline">DoNothingConverter</strong> is an invaluable tool <a id="_idIndexMarker933"/>for debugging. By placing it in your binding pipeline, you can inspect<a id="_idIndexMarker934"/> the values being passed during the binding process. If you see unexpected values or none at all, it can help pinpoint where the breakdown occurs. Here’s the implementation of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">DoNothingConverter</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public class DoNothingConverter : IValueConverter
{
    public object Convert(object value,
        Type targetType, object parameter,
        CultureInfo culture)
    {
        // Break here to inspect value during debugging
        return value;
    }
    public object ConvertBack(object value,
        Type targetType, object parameter,
        CultureInfo culture)
    {
        // Break here to inspect value during debugging
        return value;
    }
}</pre> <p>To add and use this converter in your binding statements, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Add a <strong class="source-inline">DoNothingConverter</strong> to the <strong class="source-inline">Resources</strong> of the page where you want to debug a binding statement. Here’s how<a id="_idIndexMarker935"/> we can add<a id="_idIndexMarker936"/> it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipesOverviewPage</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;ContentPage
    x:Class="Recipes.Mobile.RecipesOverviewPage"
    ...
    <strong class="bold">xmlns:conv="clr-namespace:</strong>
<strong class="bold">      Recipes.Mobile.Converters"</strong>
    ... &gt;
    &lt;ContentPage.Resources&gt;
        ...
        <strong class="bold">&lt;conv:DoNothingConverter</strong>
<strong class="bold">            x:Key="doNothingConverter" /&gt;</strong>
    &lt;/ContentPage.Resources&gt;
    ...
&lt;/ContentPage&gt;</pre></li> <li>Add the converter to the binding statement you want to debug, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;Image
    ...
    <strong class="bold">Source="{Binding IsFavorite,</strong>
<strong class="bold">    Converter={StaticResource doNothingConverter}}"</strong>
    VerticalOptions="Fill" /&gt;
...
&lt;Label
    ...
    <strong class="bold">Text="{Binding Titel,</strong>
<strong class="bold">    Converter={StaticResource doNothingConverter}}"</strong>
    TextColor="Black"
    VerticalOptions="Center" /&gt;</pre></li> <li>Insert a breakpoint in the <strong class="source-inline">Convert</strong> or <strong class="source-inline">ConvertBack</strong> method of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">DoNothingConverter</strong></span><span class="No-Break">.</span></li>
<li>If the breakpoint is hit during runtime, it indicates a successful binding to an existing property on the ViewModel. You’ll notice that the breakpoint in the <strong class="source-inline">Convert</strong> method will not be hit for the <strong class="source-inline">Titel</strong> binding as this property <span class="No-Break">doesn’t exist.</span></li>
<li>If the breakpoint isn’t hit on subsequent updates of the property value, check the binding mode of the statement and ensure that the <strong class="source-inline">PropertyChanged</strong> method is triggered when the property <span class="No-Break">gets updated.</span></li>
<li>When the breakpoint<a id="_idIndexMarker937"/> is hit, you can easily inspect the bound<a id="_idIndexMarker938"/> value and compare it to <span class="No-Break">your expectations.</span></li>
<li>You can also examine the <strong class="source-inline">targetType</strong> parameter, which represents the type of the target property. Keep in mind that while XAML supports implicit type conversion in certain cases, it’s essential to be aware of the specific <span class="No-Break">conversions supported.</span></li>
<li>The <strong class="source-inline">ConvertBack</strong> method should be called when the property on the UI controls is updated and the binding mode is set to <strong class="source-inline">TwoWay</strong> or <strong class="source-inline">OneWayToSource</strong>. If you expect this to work but the <strong class="source-inline">ConvertBack</strong> method is not called, check the binding statement’s <span class="No-Break">binding mode.</span></li>
</ol>
<p>By following these steps and utilizing the <strong class="source-inline">DoNothingConverter</strong> tool, you can effectively troubleshoot<a id="_idIndexMarker939"/> data binding issues<a id="_idIndexMarker940"/> in your <span class="No-Break">MVVM application.</span></p>
<p>Let’s discuss another cause of potential data binding <span class="No-Break">issues: collections.</span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor244"/>Troubleshooting collections</h2>
<p>When working with<a id="_idIndexMarker941"/> collections, especially <strong class="source-inline">ObservableCollection</strong>, developers frequently<a id="_idIndexMarker942"/> encounter challenges related to updates <span class="No-Break">and bindings.</span></p>
<p>If you’re using an <strong class="source-inline">ObservableCollection</strong> or any collection implementing the <strong class="source-inline">INotifyCollectionChanged</strong> interface, it’s usually assigned once during the initialization of your ViewModel. Here’s an important nuance to keep in mind: the setter for this property doesn’t trigger the <strong class="source-inline">PropertyChanged</strong> event. Instead, when you add or remove items from the collection, it triggers the <strong class="source-inline">CollectionChanged</strong> event on the collection instance. This event, in turn, updates the bound control, assuming it supports binding to <strong class="source-inline">ObservableCollection</strong>. To verify whether a specific control works well with the <strong class="source-inline">INotifyCollectionChanged</strong> interface, consult the <span class="No-Break">control’s documentation.</span></p>
<p>However, there’s a critical point to be aware of: if the <strong class="source-inline">ObservableCollection</strong> is assigned anew, the binding will effectively be <em class="italic">lost</em>, unless, of course, the <strong class="source-inline">PropertyChanged</strong> event is properly raised. This means that if you reassign the entire collection with a new instance of <strong class="source-inline">ObservableCollection</strong>, you need to ensure that the <strong class="source-inline">PropertyChanged</strong> event is correctly triggered. To check whether this event is effectively raised, you can utilize <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">DoNothingConverter</strong></span><span class="No-Break">.</span></p>
<p>In contrast, when you’re working with a collection that doesn’t implement <strong class="source-inline">INotifyCollectionChanged</strong> (as in the case of a standard <strong class="source-inline">List</strong> or similar collections), adding or removing items won’t be automatically detected by the UI layer. In this scenario, the <strong class="source-inline">PropertyChanged</strong> event must be explicitly triggered when items are added to or removed from the collection. Consequently, the entire list will be re-rendered in the UI when you <span class="No-Break">make changes.</span></p>
<p>When troubleshooting issues related to collections, pay close attention to whether you’re using <strong class="source-inline">ObservableCollection</strong> or non-observable collections, and ensure that you trigger the appropriate events to keep your ViewModel and UI in sync. Understanding these dynamics will help you navigate the complexities of collections in your MVVM application more effectively and prevent <span class="No-Break">potential issues.</span></p>
<p>When working with collections, remember that you don’t need to trigger a <strong class="source-inline">PropertyChanged</strong> event on the collection itself when a property of an item within the collection changes. Instead, the key lies in raising the <strong class="source-inline">PropertyChanged</strong> event on the instance of the specific item that underwent modification. This ensures that the UI is notified of changes at the item level and reflects the updated state accurately. In essence, you’re focusing the update<a id="_idIndexMarker943"/> event precisely where it matters, minimizing unnecessary updates<a id="_idIndexMarker944"/> to the <span class="No-Break">entire collection.</span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor245"/>The data binding pitfall on Behaviors</h2>
<p>It’s very easy to oversee<a id="_idIndexMarker945"/> this while writing XAML, but relative source binding<a id="_idIndexMarker946"/> won’t work on Behaviors. That is because Behaviors exist outside the visual tree. In fact, a Behavior can even be reused by multiple UI elements, hence a relative source binding won’t be able to retrieve a parent object. When applying relative source binding to a Behavior, your app will crash, preceded by an exception of type <strong class="source-inline">System.InvalidOperationException</strong>. The exception states the following: <strong class="bold">Operation is not valid due to the current state of the object</strong>. This exception alongside this message should be an indication that there is a faulty data binding statement defined on a Behavior. There will be no further indication in the exception or in the <strong class="bold">Output</strong> window whatsoever. The only thing you can do is systematically go through the Behaviors in your code and look at their <span class="No-Break">binding statements.</span></p>
<p>In many cases, the relative source binding can be replaced by element binding, as <span class="No-Break">demonstrated here:</span></p>
<pre class="source-code">
&lt;!-- RelativeSource binding fails on Behaviors! --&gt;
&lt;toolkit:IconTintColorBehavior
    TintColor="{Binding IsFavorite,
    <strong class="bold">Source={RelativeSource AncestorType={x:Type local:</strong>
<strong class="bold">      FavoriteControl}</strong>}, Converter=..." /&gt;</pre> <p>This code snippet will fail because of the usage of <strong class="source-inline">RelativeSource</strong> binding in the <strong class="source-inline">IcontTintColorBehavior</strong>. This can be bypassed<a id="_idIndexMarker947"/> by leveraging element binding, as shown<a id="_idIndexMarker948"/> in the next <span class="No-Break">code block:</span></p>
<pre class="source-code">
&lt;ContentView
    ...
    <strong class="bold">x:Name="root"</strong>&gt;
    ...
        &lt;toolkit:IconTintColorBehavior
            TintColor="{Binding IsFavorite,
            <strong class="bold">Source={x:Reference root}</strong>,
            Converter=...}" /&gt;
    ...
&lt;/ContentView&gt;</pre> <p>Next, let’s discuss the things to look out for when workin<a id="_idTextAnchor246"/><a id="_idTextAnchor247"/>g with <span class="No-Break">Dependency Injection.</span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor248"/>Services and Dependency Injection pitfalls</h1>
<p>In your MVVM journey, DI plays<a id="_idIndexMarker949"/> a crucial role in providing essential functionality to your application. However, even in the world of DI, there can be pitfalls waiting to catch you off guard. This section is dedicated to unveiling the most common pitfalls and equipping you with the knowledge to navigate <span class="No-Break">them effectively.</span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor249"/>Unable to resolve service for type</h2>
<p>A <strong class="source-inline">System.InvalidOperationException</strong> stating <strong class="bold">Unable to resolve service for type </strong>… is one of the most frequent exceptions<a id="_idIndexMarker950"/> when working with DI. The cause is pretty simple: we ask the DI container to resolve an instance of an object that has some dependencies that can’t be resolved. In other words, we haven’t registered all dependencies for this class. <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.2</em> shows what this exception would look like if we didn’t register the <strong class="source-inline">RecipesOverviewViewModel</strong> in the <span class="No-Break">DI container:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="Figure 14.2: InvalidOperationException thrown" height="514" src="image/B20941_14_02.jpg" width="1089"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2: InvalidOperationException thrown</p>
<p>The exception gives you all the information you need as it clearly states what type is missing while trying to create a <span class="No-Break">particular type.</span></p>
<p>Registering the missing<a id="_idIndexMarker951"/> dependency in the <strong class="source-inline">MauiProgram</strong> class (or anywhere you do your registrations) should fix <span class="No-Break">the issue.</span></p>
<p>Let’s have a look at another common exception in the context <span class="No-Break">of DI.</span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor250"/>No parameterless constructor defined for type</h2>
<p>A <strong class="source-inline">System.MissingMethodException</strong> can be thrown in the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker952"/></span><span class="No-Break"> scenario:</span></p>
<ul>
<li>Shell is used to <span class="No-Break">perform navigation</span></li>
<li>The BindingContext (a ViewModel) of a page is injected through the <span class="No-Break">page’s constructor</span></li>
<li>The page isn’t registered in the <span class="No-Break">DI container</span></li>
</ul>
<p>As long as a page doesn’t have any dependencies that need to be injected through the constructor, it doesn’t need to be registered in the DI container, as its default constructor is being used by Shell to instantiate the page. However, when the page has one or more dependencies, we need to register it in the DI container. That way, Shell can ask the container<a id="_idIndexMarker953"/> to resolve an instance of the <span class="No-Break">needed page.</span></p>
<p>Registering the page in the DI container solves <span class="No-Break">this issue.</span></p>
<p>A much more subtle pitfall when it comes to DI is not registering the services appropriately. Let’s have <span class="No-Break">a look.</span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor251"/>Incorrect service registration</h2>
<p>In the context of DI, one common pitfall<a id="_idIndexMarker954"/> stems from improperly registering services, leading to issues that can affect <a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>your <span class="No-Break">application’s functionality:</span></p>
<ul>
<li><strong class="bold">Resource intensiveness</strong>: If you register a service as transient when it should be a singleton, you may encounter resource-intensive behavior. This occurs because a new instance of the service is created every time it’s requested. For services that involve resource-intensive operations, such as establishing database connections or managing file handles, this frequent creation can lead to performance bottlenecks and resource exhaustion. Such issues can significantly impact your applica<a id="_idTextAnchor254"/><a id="_idTextAnchor255"/>tion’s performance <span class="No-Break">and stability.</span></li>
<li><strong class="bold">Unintended shared state</strong>: Conversely, if you mistakenly register a service as a singleton when it should be transient, you may inadvertently introduce an unintended shared state. In this scenario, changes made to the service’s state or properties affect all parts of your application that depend on that service. This shared state can lead to unpredictable behavior and make debugging challenging, as the source of the problem may not be immediately apparent. It’s crucial to align the service’s registration with its intended usage to avoid <span class="No-Break">such pitfalls.</span></li>
</ul>
<p>To mitigate these issues, carefully consider the intended scope and usage of each service during registration. Ensure that services requiring a single shared instance across your application are registered as singletons, while services that should have unique instances for each request are registered as transient. By making informed decisions about service registration, you can prevent these common pitfalls and ensure your application functions<a id="_idIndexMarker955"/> <span class="No-Break">as intended.</span></p>
<p>In the final section, let’s have a look at common problems around custom controls and <span class="No-Break">value converters.</span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor256"/>Frequent custom control and converter problems</h1>
<p>Most of the issues<a id="_idIndexMarker956"/> that arise when working with custom controls regularly have to do with bindable properties. Often, a small typo or a little oversight might cause your custom control to not react as expected or to display the <span class="No-Break">wrong data.</span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor257"/>Troubleshooting bindable properties</h2>
<p>On a custom control, there is a lot of ceremony<a id="_idIndexMarker957"/> needed to define bindable properties. It’s very easy to make a mistake<a id="_idIndexMarker958"/> that is very hard to spot when troubleshooting. Here are a couple of things to look <span class="No-Break">out for:</span></p>
<ul>
<li>The <strong class="source-inline">propertyName</strong> parameter in the <strong class="source-inline">Create</strong> method: Make sure the <strong class="source-inline">propertyName</strong> parameter matches the exact naming of <span class="No-Break">the property:</span><pre class="source-code">
public static readonly BindableProperty
  IsFavoriteProperty =
    BindableProperty.Create(<strong class="bold">nameof(IsFavorite)</strong>, …);
public bool <strong class="bold">IsFavorite</strong>
{
    ...
}</pre><p class="list-inset">As this code sample shows, it is advised to use the <strong class="source-inline">nameof</strong> expression to <span class="No-Break">prevent typos!</span></p></li> <li>The <strong class="source-inline">returnType</strong> parameter in the <strong class="source-inline">Create</strong> method: The second parameter of the <strong class="source-inline">BindableProperty</strong>’s <strong class="source-inline">Create</strong> method is the <strong class="source-inline">returnType</strong>, which must match the type of <span class="No-Break">the property:</span><pre class="source-code">
public static readonly BindableProperty
  IsFavoriteProperty =
    BindableProperty.Create(nameof(IsFavorite),
    <strong class="bold">typeof(bool)</strong>, …);
public <strong class="bold">bool</strong> IsFavorite
{
    ...
}</pre></li> <li>The <strong class="source-inline">declaringType</strong> parameter<a id="_idIndexMarker959"/> in the <strong class="source-inline">Create</strong> method: This parameter should be the type of the class<a id="_idIndexMarker960"/> where the property <span class="No-Break">is defined:</span><pre class="source-code">
public partial class <strong class="bold">FavoriteControl</strong> : ContentView
{
    public static readonly BindableProperty
      IsFavoriteProperty =
            BindableProperty.Create(...
                <strong class="bold">typeof(FavoriteControl)</strong>,...);
public bool IsFavorite
{
    ...
}</pre></li> <li>It’s also important to make sure the getter and setter of the property call the <strong class="source-inline">GetValue</strong> and <strong class="source-inline">SetValue</strong>, passing in the <span class="No-Break">correct </span><span class="No-Break"><strong class="source-inline">BindableProperty</strong></span><span class="No-Break">:</span><pre class="source-code">
public static readonly BindableProperty <strong class="bold">IsFavoriteProperty</strong> = ...
public bool IsFavorite
{
    get =&gt; (bool)GetValue(<strong class="bold">IsFavoriteProperty</strong>);
    set =&gt; SetValue(<strong class="bold">IsFavoriteProperty</strong>, value);
}</pre></li> </ul>
<p>Whenever there is a discrepancy between the provided values in the <strong class="source-inline">BindableProperty</strong>’s <strong class="source-inline">Create</strong> method and the values on the control itself, or when the property doesn’t get or set the value<a id="_idIndexMarker961"/> correctly on the <strong class="source-inline">BindableProperty</strong>, the bindable property<a id="_idIndexMarker962"/> will not work as expected. So, it’s crucial to double-check <span class="No-Break">these values!</span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor258"/>Binding to the BindingContext</h2>
<p>As already stipulated in <a href="B20941_11.xhtml#_idTextAnchor182"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Creating MVVM-Friendly Controls,</em> it is crucial that custom controls don’t depend<a id="_idIndexMarker963"/> on their <strong class="source-inline">BindingContext</strong>! The reason is that you can’t control that, as it is inherited from the parent the custom control is used on. Instead, you should<a id="_idIndexMarker964"/> only bind to the (bindable) properties that you’ve defined on the control itself. This can easily be achieved by leveraging relative or element binding, just like we did with <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;Image
        HeightRequest="{Binding HeightRequest,
            <strong class="bold">Source={x:Reference icon}</strong>}"
        IsVisible="{Binding IsInteractive,
            <strong class="bold">Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">                local:FavoriteControl}}</strong>}"
        ... /&gt;</pre> <p>Any binding statements on a custom control that don’t have an explicit source set will bind to the <strong class="source-inline">BindingContext</strong> of the parent, which we don’t control. When a custom control works in one place but not in the other, chances are high that there is some binding going on that is not relative<a id="_idIndexMarker965"/> to the control itself. So, always double-check<a id="_idIndexMarker966"/> the binding statements in your <span class="No-Break">custom control!</span></p>
<p>Finally, let’s have a quick look at the issues that might arise when working with <span class="No-Break">value converters.</span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor259"/>Value converter issues</h2>
<p>Converters play a crucial<a id="_idIndexMarker967"/> role in data transformation<a id="_idIndexMarker968"/> within your app. However, their logic might not always behave as expected. It’s a seemingly trivial issue, but one that is frequently underestimated. The solution? Simple yet powerful: write unit tests! In <a href="B20941_13.xhtml#_idTextAnchor223"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Unit Testing,</em> we’ve highlighted how easy it is to unit test value converters. Paying attention to the logic within converters, testing them rigorously, and handling special cases will ensure that your converters <span class="No-Break">perform reliably.</span></p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor260"/>Summary</h1>
<p>Now that we’ve reached the end of this short chapter, I hope you’ve gained valuable insights and tips for effectively troubleshooting issues that can arise in an MVVM context. Remember, the road to mastering MVVM is an ongoing journey, and troubleshooting and debugging are indispensable companions on this path. These challenges, though sometimes frustrating, are valuable teachers that will deepen your understanding and proficiency in MVVM. Embrace them as opportunities to grow, and in doing so, you’ll become a more proficient and confident MVVM developer. Your journey doesn’t end here; it evolves with each issue <span class="No-Break">you resolve.</span></p>
<p>As we wrap up this final chapter, I want to extend my heartfelt congratulations to you for completing this book’s journey into the world of MVVM in .NET MAUI. Throughout this book, you’ve delved into the intricacies of the MVVM pattern, explored the capabilities of .NET MAUI, and built your very own <span class="No-Break"><em class="italic">Recipes!</em></span><span class="No-Break"> app.</span></p>
<p>Once again, congratulations on your accomplishment, and may your MVVM and .NET MAUI journey continue to be rewarding and filled with <span class="No-Break">exciting projects!</span></p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor261"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resource:</span></p>
<p><em class="italic">XAML data binding </em><span class="No-Break"><em class="italic">diagnostics</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/visualstudio/xaml-tools/xaml-data-binding-diagnostics?view=vs-2022"><span class="No-Break">https://learn.microsoft.com/en-us/visualstudio/xaml-tools/xaml-data-binding-diagnostics?view=vs-2022</span></a></p>
</div>
</div></body></html>