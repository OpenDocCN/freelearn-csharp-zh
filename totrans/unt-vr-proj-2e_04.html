<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Gaze-Based Control</h1>
                </header>
            
            <article>
                
<p class="calibre3">Right now, our diorama is a third-person virtual reality experience. When you go into it, you're like an observer or a third-person camera. Sure, you can look around and add controls that let you move the camera's viewpoint. However, any action in the scene is from a third-person perspective.</p>
<p class="calibre3">In this chapter, we'll pretty much stay in the third-person mode, but we'll get a little more personally involved. We will explore techniques that can be used to control objects in your virtual world by looking and staring. Our character, Ethan, will be under your control, responding to where you look. Furthermore, we'll start programming the Unity scripts. Along the way, we will discuss the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Adding <strong class="calibre1">AI</strong> (short for <strong class="calibre1">artificial intelligence</strong>) and <strong class="calibre1">NavMesh</strong> to our third-person character, Ethan</li>
<li class="calibre12">Unity programming in C#</li>
<li class="calibre12">Using our gaze to move a 3D cursor</li>
<li class="calibre12">Shooting and killing Ethan, the zombie, to good effect</li>
</ul>
<p class="calibre3">Most intros to Unity development tip-toe you through the easy stuff and maybe never even get to the more interesting, although more complex, things. We're going to mix things up in this chapter, throwing you into a few different 3D graphics topics, some a little advanced. If it's new to you, think of this as a survey tutorial. Nonetheless, we go through it step by step so you should be able to follow along and have a lot of fun too!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ethan, the walker</h1>
                </header>
            
            <article>
                
<p class="calibre3">Gaming is a common application of virtual reality. So, we might as well start out from there, too! We are going to give our character, Ethan, a life of his own. Well, sort of (or not), because he's going to become a zombie!</p>
<p class="calibre3">We left off at the diorama, with Ethan hanging out. You can make him run around the scene if you have a hand controller with a thumbstick or touchpad, but that is not guaranteed on some VR devices. In fact, if you're viewing the scene with a Google Cardboard, it's pretty unlikely that you'll have a handheld controller (notwithstanding the Bluetooth game controllers). In the next chapter, <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em>, we will go into handheld input controllers. For now, we will consider another way to make him move around, using the direction of your gaze while wearing your VR headset.</p>
<p class="calibre3">Before we attempt this, we'll first transform Ethan into a zombie and have him walk around aimlessly without any user control. We'll do this by giving him some AI and writing a script that sends him to random target locations.</p>
<div class="packttip"><em class="calibre2">AI controllers</em> and <em class="calibre2">N</em><em class="calibre2">avMesh</em> are somewhat advanced topics in Unity, but we're going to throw you into it just for fun. Besides, it's not as scary as zombies.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Artificially intelligent Ethan</h1>
                </header>
            
            <article>
                
<p class="calibre3">To start, we want to replace the <kbd class="calibre13">ThirdPersonController</kbd> prefab that we used initially with Unity's AI character, <kbd class="calibre13">AIThirdPersonController</kbd>, using the following steps. Unity uses the word <em class="calibre14">artificial intelligence</em> loosely to mean <em class="calibre14">script-driven</em>. Perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Open the Unity project from the previous chapters with the <kbd class="calibre13">Diorama</kbd> scene, and have the <kbd class="calibre13">Characters</kbd> package imported from <kbd class="calibre13">Standard Assets</kbd>.</li>
<li class="calibre12">In the <span>Project</span> panel, open the <kbd class="calibre13">Standard Assets/Characters/ThirdPersonCharacter/Prefabs</kbd> folder and drag <kbd class="calibre13">AIThirdPersonController</kbd> into the scene. Name it <kbd class="calibre13">Ethan</kbd>.</li>
<li class="calibre12">In the <span>Hierarchy</span> panel (or in <span>Scene</span>), select the previous <kbd class="calibre13">ThirdPersonController</kbd>, (the old Ethan). Then, in the <span>Inspector</span> panel's <span>Transform</span> pane, choose the <em class="calibre2">gear</em> icon on the upper right of the <span>Transform</span> pane and select <span>Copy Component</span>.</li>
<li class="calibre12">Select the new <kbd class="calibre13">Ethan</kbd> object (from the <span>Hierarchy</span> panel or <span>Scene</span>). Then, in the <span>Inspector</span> panel's <span>Transform</span> pane, choose the <em class="calibre2">gear</em> icon and select <span>Paste Component Values</span>.</li>
<li class="calibre12">Now, you can delete the old <kbd class="calibre13">Ethan</kbd> object by selecting it from the <span>Hierarchy</span> panel, right-clicking to open options, and clicking on <span>Delete</span>.</li>
</ol>
<div class="packttip">If you cannot find the <kbd class="calibre26">Characters</kbd> package to import, you may not have installed <kbd class="calibre26">Standard Assets</kbd> when you installed Unity. To get them now, you will need to run the <kbd class="calibre26">UnityDownloadAssistant</kbd> again as described at the beginning of <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre20">Chapter 2</a>, <em class="calibre2">Content, Objects, and Scale</em> (and it may already be in your Downloads folder).</div>
<p class="calibre3">Note that this controller has a <kbd class="calibre13">NavMesh Agent</kbd> component and an <kbd class="calibre13">AICharacterControl</kbd> script. The NavMesh Agent has parameters for how Ethan will move around the scene. The <kbd class="calibre13">AICharacterControl</kbd> script takes a target object where Ethan will walk to. Let's populate that, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Add an empty game object to the <span>Hierarchy</span> panel, and rename it<span> </span><kbd class="calibre13">WalkTarget</kbd>.</li>
<li class="calibre12">Reset its <span>Transform</span> values to position (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>) (using the gear icon in upper-right of the Transform pane).</li>
<li class="calibre12">Select Ethan and drag <kbd class="calibre13">WalkTarget</kbd> into the <span>Target</span> property in the <span>Inspector</span> panel's <span>AI Character Control</span> pane, as shown here:</li>
</ol>
<div class="mce-root1"><img src="assets/2a9356ba-90ad-4be3-84d2-f815b39dc149.png" class="calibre24"/></div>
<p class="calibre3">At this point, we have an AI character in the scene (<kbd class="calibre13">Ethan</kbd>), an empty game object that will be used as a navigation target (<kbd class="calibre13">WalkTarget</kbd>) initially in the center of our scene, and we told the AI Character Controller to use this target object. When we run the game, wherever <kbd class="calibre13">WalkTarget</kbd> is, Ethan will go there. But not yet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NavMesh bakery</h1>
                </header>
            
            <article>
                
<p class="calibre3">Ethan cannot just go walking around without being told where he's allowed to roam! We need to define a <em class="calibre14">NavMesh</em>-a simplified geometrical plane that enables a character to plot its path around obstacles.</p>
<p class="calibre3">In our scene, Ethan is an agent. Where he's allowed to walk is the <em class="calibre14">navmesh</em>. Note that he has a <strong class="calibre5">NavMesh Agent</strong> component and an <kbd class="calibre13">AICharacterControl</kbd> script. The NavMesh Agent has parameters for how Ethan will move around the scene.</p>
<p class="calibre3">Create a <kbd class="calibre13">NavMesh</kbd> by first identifying the objects in the scene that affect navigation by marking them <span class="calibre6">Navigation Static</span>, and then baking the NavMesh, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the <span>Navigation</span> panel. If it's not already a tab in your editor, open the <span>Navigation</span> window from the main menu by navigating to <span>Window</span> | <span>Navigation</span>.</li>
<li class="calibre12">Select its <span><strong class="calibre1">Object</strong></span> tab.</li>
<li class="calibre12">Select the <span>Ground Plane</span> in <span>Hierarchy</span>, then in the <span>Navigation</span> window's Object pane, check the <span>Navigation Static</span> checkbox. (Alternatively, you can use the object's Inspector window Static dropdown list.)</li>
<li class="calibre12">Repeat step 3 for each of the objects that should get in his way: the cubes and the sphere. An example is shown for the sphere.</li>
<li class="calibre12">In the Navigation window, select the <span>Bake</span> tab, and click on the <span>Bake</span> <span><span>button at the bottom of the panel:</span></span></li>
</ol>
<div class="mce-root1"><img src="assets/a01bed04-a01e-45fb-b9bb-d09bcbbdc4c1.png" class="calibre24"/></div>
<p class="calibre3">The <span class="calibre6">Scene</span> view should now show a blue overlay where the NavMesh is defined, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="assets/82919baf-4059-475f-9f5f-02d831ccae58.png" class="calibre41"/></div>
<p class="calibre3">Let's test this out. Ensure that the <span class="calibre6">Game</span> panel's <span class="calibre6">Maximize on Play</span> is deselected. Click on the <em class="calibre14">Play</em> mode button (the triangle at the top of editor). In the <span class="calibre6">Hierarchy</span> panel, select the <kbd class="calibre13">WalkTarget</kbd> object and ensure that the Translate gizmo is active in the <span class="calibre6">Scene</span> panel (press the <span class="calibre6">W</span> key on keyboard). Now, drag the red (<span class="calibre6">x</span>) and/or the blue (<span class="calibre6">z</span>) arrow handles on the <kbd class="calibre13">WalkTarget</kbd> object to move it around the floor plane. As you do, Ethan should follow! Click on <em class="calibre14">Play</em> again to stop <span class="calibre6">Play Mode</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A random walker in the town</h1>
                </header>
            
            <article>
                
<p class="calibre3">Now, we'll write a script that moves the <kbd class="calibre13">WalkTarget</kbd> object to random places.</p>
<p class="calibre3">Writing scripts is an important part of developing with Unity. If you've done anything more that tinker with Unity, you've probably already written at least some scripts. We're going to use the C# programming language.</p>
<div class="packtinfobox">If you are new to programming, don't panic! We provide a more detailed introduction to Unity scripting at the end of this chapter. You can skip to that now and come back, or just follow along.</div>
<p class="calibre3">For this first script, we'll take it slow. We will attach the script to the <kbd class="calibre13">WalkTarget</kbd> object, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">WalkTarget</kbd> object in the <span>Hierarchy</span> panel or the <span>Scene</span> view.</li>
<li class="calibre12">In its <span>Inspector</span> panel, click on the <span>Add Component</span> button.</li>
<li class="calibre12">Select <span>New Script</span> (you many need to scroll down to find it).</li>
<li class="calibre12">Name it <kbd class="calibre13">RandomPosition</kbd>.</li>
<li class="calibre12">Ensure that the <span>C Sharp</span> language is selected.</li>
<li class="calibre12">Click on <span>Create and Add</span>.</li>
<li class="calibre12">This should create a script component on the <kbd class="calibre13">WalkTarget</kbd> object. Double-click on the <kbd class="calibre13">RandomPosition</kbd> script in the slot to the right of <span>Script</span> in the <span>Inspector</span> pane to open it in your code editor.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The RandomPosition script</h1>
                </header>
            
            <article>
                
<p class="calibre3">We want to move the <kbd class="calibre13">WalkTarget</kbd> object to a random location so that Ethan will head in that direction, wait a few seconds, and move the <kbd class="calibre13">WalkTarget</kbd> object again. That way, he'll appear to be wandering around aimlessly. We can do this with a script. Rather than developing the script incrementally, I'm presenting the finished version first, and we'll go through it line by line. The <kbd class="calibre13">RandomPosition.cs</kbd> script looks like this:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class RandomPosition : MonoBehaviour { 
 
  void Start () { 
    StartCoroutine (RePositionWithDelay()); 
  } 
 
  IEnumerator RePositionWithDelay() { 
    while (true) { 
      SetRandomPosition(); 
      yield return new WaitForSeconds (5); 
    } 
  } 
 
  void SetRandomPosition() { 
    float x = Random.Range (-5.0f, 5.0f); 
    float z = Random.Range (-5.0f, 5.0f); 
    Debug.Log ("X,Z: " + x.ToString("F2") + ", " + <br class="title-page-name"/>       z.ToString("F2")); 
    transform.position = new Vector3 (x, 0.0f, z); 
  } 
} </pre>
<p class="calibre3">This script defines a <kbd class="calibre13">MonoBehaviour</kbd> sub-class named <kbd class="calibre13">RandomPosition</kbd>. The first thing we do when defining the class is declare any variables that we'll be using. A variable is a placeholder for a value. The value can be initialized here or assigned elsewhere, just as long as it has a value before the script uses it.</p>
<p class="calibre3">The meat of the script is further down, the function named <kbd class="calibre13">SetRandomPosition()</kbd>. Let's see what that does.</p>
<p class="calibre3">If you recall, the <kbd class="calibre13">GroundPlane</kbd> plane is 10 units square, with the origin in the middle. So, any (<span class="calibre6">x</span>, <span class="calibre6">z</span>) location on the plane will be within a range from <kbd class="calibre13">-5</kbd> to <kbd class="calibre13">5</kbd> along each axis. The line <kbd class="calibre13">float x = Random.Range (-5.0f, 5.0f)</kbd> picks a random value within the given range and assigns it to a new <kbd class="calibre13">float x</kbd> variable. We do the same thing to get a random <em class="calibre14"><span class="calibre6">z</span></em> value. (Usually, I discourage <em class="calibre14">hardcoding</em> constant values like this instead of using variables, but I'm keeping things simple for illustration purposes.)</p>
<p class="calibre3">The line <kbd class="calibre13">Debug.Log ("X,Z: " + x.ToString("F2") + ", " + z.ToString("F2"))</kbd> prints the <kbd class="calibre13">x</kbd> and <kbd class="calibre13">z</kbd> values in the <span class="calibre6">Console</span> panel when the game is running. It'll output something like <kbd class="calibre13">X, Z: 2.33, -4.02</kbd> because <kbd class="calibre13">ToString("F2")</kbd> says round up to two decimal places. Note that we're using plus signs to combine the parts of the output string together.</p>
<p class="calibre3">We actually move the target to the given location with the line <kbd class="calibre13">transform.position = new Vector3 (x, 0.0f, z);</kbd>. We're setting the transform position of the object that this script is attached to. In Unity, values that have an X, Y, and Z are represented by the <kbd class="calibre13">Vector3</kbd> objects. So, we create a new one with the <kbd class="calibre13">x</kbd> and <kbd class="calibre13">z</kbd> values that we generated. We give <kbd class="calibre13">y=0</kbd> so that it sits on <kbd class="calibre13">GroundPlane</kbd>.</p>
<p class="calibre3">Each <kbd class="calibre13">MonoBehaviour</kbd> class has a built-in variable called <kbd class="calibre13">this</kbd>, which refers to the object that the script is attached to. That is, when the script is a component of an object and appears in its <span class="calibre6">Inspector</span> panel, the script can refer to its object as <kbd class="calibre13">this</kbd>. In fact, <kbd class="calibre13">this</kbd> is so obvious, if you want to call functions on the <kbd class="calibre13">this</kbd> object, you don't even need to say it. We could have said <kbd class="calibre13">this.transform.position = ...</kbd>, but the <kbd class="calibre13">this</kbd> object is implied and is normally omitted. On the other hand, if you had a variable for some other object (for example, <kbd class="calibre13">GameObject</kbd> that;), then you'd need to say that when you set its position, like <kbd class="calibre13">that.transform.position = ...</kbd>.</p>
<p class="calibre3">The last mysterious bit is how we handle time delays in Unity, using co-routines. This is a somewhat advanced coding technique, but very handy. In our case, the transform position should get changed once every five seconds. It's solved in several parts:</p>
<ol class="calibre15">
<li class="calibre12">In the <kbd class="calibre13">Start()</kbd> function, there's the line <kbd class="calibre13">StartCoroutine (RePositionWithDelay());</kbd>. A <strong class="calibre1">co-routine</strong> is a piece of code that runs separately from the function from which it was called. So, this line kicks off the <kbd class="calibre13">RePositionWithDelay()</kbd> function in a co-routine.</li>
<li class="calibre12">Inside that, there's a <kbd class="calibre13">while (true)</kbd> loop, which as you might guess, runs forever (as long as the game is running).</li>
<li class="calibre12">It calls the <kbd class="calibre13">SetRandomPosition()</kbd> function, which actually repositions the object.</li>
</ol>
<p class="calibre3"> </p>
<ol start="4" class="calibre15">
<li class="calibre12">Then, at the bottom of this loop, we do a <kbd class="calibre13">yield return new WaitForSeconds (5);</kbd> statement, which basically says to Unity, <em class="calibre2">hey, go do what you want for five seconds and then come back here so that I can go through my loop again</em>.</li>
<li class="calibre12">For all of this to work, the <kbd class="calibre13">RePositionWithDelay</kbd> co-routine must be declared as the <kbd class="calibre13">IEnumerator</kbd> type (because the documentation says so).</li>
</ol>
<p class="calibre3">This co-routine/yield mechanism, although an advanced programming topic, is a common pattern in time-sliced programs such as Unity.</p>
<p class="calibre3">Our script should be saved to a file named <kbd class="calibre13">RandomPosition.cs</kbd>.</p>
<p class="calibre3">We are now good to go. In the Unity editor, click on <em class="calibre14">Play</em>. Ethan is running from one place to another like a madman!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">"Zombie-ize" Ethan!</h1>
                </header>
            
            <article>
                
<p class="calibre3">OK, that's pretty random. Let's adjust the NavMesh steering parameters to slow him down to a nice zombie-like pace. For that, perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Select <kbd class="calibre13">Ethan</kbd> in the <span>Hierarchy</span> panel</li>
<li class="calibre12">Navigate to <span>Inspector</span> | <span>Nav Mesh Agent</span> | <span>Steering</span> and set the following:
<ul class="calibre40">
<li class="calibre12"><span>Speed</span>: <kbd class="calibre13">0.3</kbd></li>
<li class="calibre12"><span>Angular Speed</span>: <kbd class="calibre13">60</kbd></li>
<li class="calibre12"><span>Acceleration</span>: <kbd class="calibre13">2</kbd></li>
</ul>
</li>
</ol>
<p class="calibre3">Play again. He has slowed down. That's better.</p>
<p class="calibre3">One more finishing touch: let's turn him into a zombie. I have a texture image named <kbd class="calibre13">EthanZombie.png</kbd> that will help (included with this book). Perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">From the <span>Assets</span> tab on the main menu, select <span>Import New Asset...</span>. Navigate to the files folder with the assets that came with this book.</li>
<li class="calibre12">Select the <kbd class="calibre13">EthanZombie.png</kbd> file.</li>
<li class="calibre12">Click on <span>Import</span>. For tidiness, ensure that it resides in the <kbd class="calibre13">Assets/Textures</kbd> folder. (Alternatively, you can just drag and drop the file from Windows Explorer into the <span>Project</span> panel Assets/Textures folder.)</li>
<li class="calibre12">In the <span>Hierarchy</span> panel, unfold the <kbd class="calibre13">Ethan</kbd> object (click on the triangle) and select <kbd class="calibre13">EthanBody</kbd>.</li>
</ol>
<p class="calibre3"> </p>
<ol start="5" class="calibre15">
<li class="calibre12">In the <kbd class="calibre13">Inspector</kbd> panel, unfold the <kbd class="calibre13">EthanGray</kbd> shader by clicking on the triangle icon to the left of <span>Shader</span>.</li>
<li class="calibre12">Select the <kbd class="calibre13">EthanZombie</kbd> texture from the <kbd class="calibre13">Project Assets/Textures</kbd> folder.</li>
<li class="calibre12">Drag it onto the <span>Albedo</span> texture map. It's a small square just to the left of the <span>Albedo</span> label under <span>Main Maps</span>.</li>
<li class="calibre12">In the <span>Hierarchy</span> panel, select <kbd class="calibre13">EthanGlasses</kbd> and uncheck it to disable glasses in the <span>Inspector</span> panel. After all, zombies don't need glasses!</li>
</ol>
<p class="calibre3">His portrait is featured below. <em class="calibre14">What'd you say? That's not a scary enough zombie??</em> Well, maybe he's just recently turned. Go ahead and make a better one yourself. Use Blender, Gimp, or Photoshop and paint your own (or even import a whole different zombie humanoid model to replace <kbd class="calibre13">EthanBody</kbd> itself):</p>
<div class="mce-root1"><img src="assets/a8c9774a-a357-4cd9-8c99-92a6e52f56f8.png" class="calibre42"/></div>
<p class="calibre3">Now, build the project and try it in VR.</p>
<p class="calibre3">We're looking from a third-person perspective. You can look around and watch what's going on. It's kind of fun, and it's pretty interesting. And it's passive. Let's get more active.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go where I'm looking</h1>
                </header>
            
            <article>
                
<p class="calibre3">In this next script, instead of being random, we'll send Ethan to wherever we look. In Unity, this is accomplished by using <strong class="calibre5">ray casting. </strong>It's like shooting a ray from the camera and seeing what it hits (for more information, visit <a href="http://docs.unity3d.com/Manual/CameraRays.html" class="calibre10"><span>http://docs.unity3d.com/Manual/CameraRays.html</span></a>).</p>
<p class="calibre3">We're going to create a new script, which will be attached to <kbd class="calibre13">WalkTarget</kbd> like before, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">WalkTarget</kbd> object in the <span>Hierarchy</span> panel or the <span>Scene</span> view.</li>
<li class="calibre12">In its <span>Inspector</span> panel, click on the <span>Add Component</span> button.</li>
<li class="calibre12">Select <span>New Script</span>.</li>
<li class="calibre12">Name it <kbd class="calibre13">LookMoveTo</kbd>.</li>
<li class="calibre12">Ensure that the <span>C Sharp</span> language is selected.</li>
<li class="calibre12">Click on <span>Create</span> and <span>Add</span>.</li>
</ol>
<p class="calibre3">This should create a script component on the <kbd class="calibre13">WalkTarget</kbd> object. Double-click on it to open it in your code editor.</p>
<div class="packttip">This <kbd class="calibre26">LookMoveTo</kbd> script replaces the <kbd class="calibre26">RandomPosition</kbd> one we created before. Disable the <kbd class="calibre26">RandomPosition</kbd> component of <kbd class="calibre26">WalkTarget</kbd> before proceeding.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The LookMoveTo script</h1>
                </header>
            
            <article>
                
<p class="calibre3">In our script, each time <kbd class="calibre13">Update()</kbd> is called, we'll read where the camera is pointing (by using its transform position and rotation), cast a ray in that direction, and ask Unity to tell us where it hits the ground plane. Then, we'll use this location to set the <kbd class="calibre13">WalkTarget</kbd> object's position.</p>
<p class="calibre3">Here's the full <kbd class="calibre13">LookMoveTo.cs</kbd> script:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class LookMoveTo : MonoBehaviour { 
  public GameObject ground; 
 
  void Update () { 
    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit hit; 
    GameObject hitObject; 
 
    Debug.DrawRay (camera.position, 
      camera.rotation * Vector3.forward * 100.0f); 
 
    ray = new Ray (camera.position, 
      camera.rotation * Vector3.forward); 
    if (Physics.Raycast (ray, out hit)) { 
      hitObject = hit.collider.gameObject; 
      if (hitObject == ground) { 
        Debug.Log ("Hit (x,y,z): " + hit.point.ToString("F2")); 
        transform.position = hit.point; 
      } 
    } 
  } 
 
} </pre>
<p class="calibre3">Let's go through the script a bit at a time.</p>
<pre class="calibre18">public GameObject ground; </pre>
<p class="calibre3">The first thing the script does is declare a variable for the <kbd class="calibre13">GroundPlane</kbd> object.<br class="calibre7"/>
Since it's <kbd class="calibre13">public</kbd>, we can use the Unity editor to assign the actual object:</p>
<pre class="calibre18">  void Update () { 
    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit hit; 
    GameObject hitObject; </pre>
<p class="calibre3">Inside <kbd class="calibre13">Update()</kbd>, we define a few local variables, <kbd class="calibre13">camera</kbd>, <kbd class="calibre13">ray</kbd>, <kbd class="calibre13">hit</kbd>, and <kbd class="calibre13">hitObject</kbd>, which have datatypes that are required by the Unity functions that we're going to use.</p>
<p class="calibre3"><kbd class="calibre13">Camera.main</kbd> is the current active camera object (that is, tagged as <kbd class="calibre13">MainCamera</kbd>). We get its current transform, which will be assigned to the camera variable:</p>
<pre class="calibre18">    ray = new Ray (camera.position, 
      camera.rotation * Vector3.forward); </pre>
<p class="calibre3">Ignoring the handy <kbd class="calibre13">Debug</kbd> statements for a moment, we first determine the ray from the camera using <kbd class="calibre13">new Ray()</kbd>.</p>
<p class="calibre3">A <strong class="calibre5">ray</strong> can be defined by a starting position in the <span class="calibre6">x</span>, <span class="calibre6">y</span>, and <span class="calibre6">z</span> space and a direction vector. A <strong class="calibre5">direction vector</strong> can be defined as the relative offsets from a 3D starting point to some other point in space. The forward direction, where <span class="calibre6">z</span> is positive, is (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>). Unity will do the math for us. So, if we take a unit vector (<kbd class="calibre13">Vector3.forward</kbd>), multiply it by a three-axis rotation (<kbd class="calibre13">camera.rotation</kbd>), and scale it by a length (<kbd class="calibre13">100.0f</kbd>), we'll get a ray pointing in the same direction as the camera, measuring 100 units long:</p>
<pre class="calibre18">if (Physics.Raycast (ray, out hit)) {</pre>
<p class="calibre3">Then, we cast the ray and see if it hit anything. If so, the <kbd class="calibre13">hit</kbd> variable will<br class="calibre7"/>
now contain more details about what was hit, including the specific object in<br class="calibre7"/>
<kbd class="calibre13">hit.collider.gameObject</kbd>. (The <kbd class="calibre13">out</kbd> keyword means that the <kbd class="calibre13">hit</kbd> variable value is filled in by the <kbd class="calibre13">Physics.Raycast()</kbd> function.)</p>
<pre class="calibre18">      if (hitObject == ground) { 
        transform.position = hit.point; 
      } </pre>
<p class="calibre3">We check whether the ray hit the <kbd class="calibre13">GroundPlane</kbd> object and if so, we'll assign that as the position to move the <kbd class="calibre13">WalkTarget</kbd> object to the <kbd class="calibre13">hit</kbd> location.</p>
<div class="packttip">The <kbd class="calibre26">==</kbd>compare operator should not to be confused with <kbd class="calibre26">=</kbd>, which is the assignment operator.</div>
<p class="calibre3">This script contains two <kbd class="calibre13">Debug</kbd> statements, which are a useful way to monitor what's going on while a script is running in Play Mode. <kbd class="calibre13">Debug.DrawRay()</kbd> will draw the given ray in the <span class="calibre6">Scene</span> view so that you can actually see it, and <kbd class="calibre13">Debug.Log()</kbd> will dump the current hit position to the console if and when there's a hit.</p>
<p class="calibre3">Save the script, switch into the Unity editor, and perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">WalkTarget</kbd> selected, in the <kbd class="calibre13">Inspector</kbd> panel, the <kbd class="calibre13">LookMoveTo</kbd> script component now has a field for the <kbd class="calibre13">GroundPlane</kbd> object.</li>
<li class="calibre12">From the <span>Hierarchy</span> panel, select and drag the <kbd class="calibre13">GroundPlane</kbd> game object onto the <span>Ground</span> field.</li>
</ol>
<p class="calibre3">Save the scene. The script pane looks like this:</p>
<div class="mce-root1"><img src="assets/d3c0f63f-6c1d-4304-a55c-8bde8c46f55e.png" class="calibre24"/></div>
<p class="calibre3">Then, click the <em class="calibre14">Play</em> button. Ethan should follow our gaze (at his own pace).</p>
<div class="packtinfobox">In projects with more than a few objects with colliders, in order to optimize the performance of your raycast, it is advised to place the objects on a specific layer (for example, named "Raycast") and then add that layer mask to the Raycast call. For example, if "Raycast" is layer 5, <kbd class="calibre26">int layerMask = 1 &lt;&lt; 5</kbd>, then <kbd class="calibre26">Physics.Raycast(ray, out hit, maxDistance, layerMask);</kbd>. See <a href="https://docs.unity3d.com/ScriptReference/Physics.Raycast.html" class="calibre20">https://docs.unity3d.com/ScriptReference/Physics.Raycast.html</a> and <a href="https://docs.unity3d.com/Manual/Layers.html" class="calibre20">https://docs.unity3d.com/Manual/Layers.html</a> for details and examples.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a feedback cursor</h1>
                </header>
            
            <article>
                
<p class="calibre3">Given it's not always obvious where your gaze is hitting the ground plane, we'll now add a cursor to the scene. It's really easy because what we've been doing is moving around an invisible, empty <kbd class="calibre13">WalkTarget</kbd> object. If we give it a mesh by using the following steps, it'll be visible:</p>
<ol class="calibre15">
<li class="calibre12">In the <span>Hierarchy</span> panel, select the <kbd class="calibre13">WalkTarget</kbd> object.</li>
<li class="calibre12">Right-click on the mouse and navigate to <span>3D Object</span> | <span>Cylinder</span>. This will create a cylindrical object parented by <kbd class="calibre13">WalkTarget</kbd>. (Alternatively, you can use the <span>GameObject</span> tab on the main menu bar, and then drag and drop the object onto <kbd class="calibre13">WalkTarget</kbd>.)</li>
<li class="calibre12">Ensure that we're starting with the reset values of transform by clicking on <span>Reset</span> from the <em class="calibre2">gear</em> icon menu in the <span>Transform</span> pane.</li>
<li class="calibre12">Select the new cylinder and in its <span>Inspector</span> panel, change the <span>Scale</span> to (<kbd class="calibre13">0.4</kbd>, <kbd class="calibre13">0.05</kbd>, <kbd class="calibre13">0.4</kbd>). This will create a flat disk with a diameter of <kbd class="calibre13">0.4</kbd>.</li>
<li class="calibre12">Disable its <span>Capsule Collider</span> by unchecking that checkbox.</li>
<li class="calibre12">As a performance optimization, in <span>Mesh Renderer</span> you can also disable <span>Cast Shadows</span>, <span>Receive Shadows</span>, <span>Use Light Probes</span>, and <span>Reflection Probes</span>.</li>
</ol>
<p class="calibre3">Now, try to play again. The cursor disk follows our gaze.</p>
<p class="calibre3">If you want, decorate the disk better with a colored material. Better yet, find an appropriate texture. For example, we used a grid texture in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10"><span>Chapter 2</span></a>, <em class="calibre14">Content, Objects, and Scale</em>, for the <kbd class="calibre13">GridProjector</kbd> file (<kbd class="calibre13">Standard Assets/Effects/Projectors/Textures/Grid.psd</kbd>). The <kbd class="calibre13">CircleCrossHair.png</kbd> <span class="calibre6">file</span><span class="calibre6"> </span><span class="calibre6">is provided with the files for this book. Drop the texture onto the cylinder cursor. When you do, set its </span><span class="calibre6">Shader</span> to <span class="calibre6">Standard</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observing through obstacles</h1>
                </header>
            
            <article>
                
<p class="calibre3">In this project, we got Ethan to follow where we're looking by moving the <kbd class="calibre13">WalkTarget</kbd> object to a position on the ground plane determined by raycasting from the camera and seeing where it intersected that plane.</p>
<p class="calibre3">You may have noticed that the cursor seems to get <em class="calibre14">stuck</em> when we slide our gaze over the cube and sphere. That's because the <strong class="calibre5">physics engine</strong> has determined which object is hit first, never getting to the ground plane. In our script, we have the conditional statement <kbd class="calibre13">if (hitObject == ground)</kbd> before moving <kbd class="calibre13">WalkTarget</kbd>. Without it, the cursor would float over any object in 3D space where the cast ray hits something. Sometimes, that's interesting, but in our case, it is not. We want to keep the cursor on the ground. However now, if the ray hits something other than the ground, it doesn't get repositioned and seems <em class="calibre14">stuck</em>. Can you think of a way around it? Here's a hint: look up <kbd class="calibre13">Physics.RaycastAll</kbd>. Alright, I'll show you. Replace the body of <kbd class="calibre13">Update()</kbd> with the following code:</p>
<pre class="calibre18">    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit[] hits; 
    GameObject hitObject; 
     
    Debug.DrawRay (camera.position, camera.rotation * <br class="title-page-name"/>       Vector3.forward * 100.0f);<br class="title-page-name"/>    ray = new Ray (camera.position, camera.rotation * <br class="title-page-name"/>       Vector3.forward); 
    hits = Physics.RaycastAll (ray); 
    for (int i = 0; i &lt; hits.Length; i++) { 
      RaycastHit hit = hits [i]; 
      hitObject = hit.collider.gameObject; 
      if (hitObject == ground) { 
        Debug.Log ("Hit (x,y,z): " + <br class="title-page-name"/>           hit.point.ToString("F2")); 
        transform.position = hit.point; 
      } 
    } </pre>
<p class="calibre3">On calling <kbd class="calibre13">RaycastAll</kbd>, we get back a list, or an array, of hits. Then, we loop<br class="calibre7"/>
through each one looking for a ground hit anywhere along the path of the ray<br class="calibre7"/>
vector. Now our cursor will trace along the ground, whether or not there's another object in between.</p>
<div class="packtinfobox"><strong class="calibre1">Extra challenge</strong>: Another more efficient solution is to use the <em class="calibre2">layer system</em>. Create a new layer, assign it to the plane, and pass it as an argument to <kbd class="calibre26">Physics.raycast()</kbd>. Can you see why that's much more efficient?</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">If looks could kill</h1>
                </header>
            
            <article>
                
<p class="calibre3">We got this far. We might as well try to kill Ethan (haha!). Here are the specifications for this new feature:</p>
<ul class="calibre11">
<li class="calibre12">Looking at Ethan hits him with our line-of-sight raygun</li>
<li class="calibre12">Sparks are emitted when the gun hits its target</li>
<li class="calibre12">After 3 seconds of being hit, Ethan is killed</li>
<li class="calibre12">When he's killed, Ethan explodes (we get a point) and then he respawns at a new location</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The KillTarget script</h1>
                </header>
            
            <article>
                
<p class="calibre3">This time, we'll attach the script to a new empty <kbd class="calibre13">GameController</kbd> object by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create an empty game object and name it <kbd class="calibre13">GameController</kbd>.</li>
<li class="calibre12">Attach a new C# script to it, using <span>Add Component</span>, named <kbd class="calibre13">KillTarget</kbd>.</li>
<li class="calibre12">Open the script in MonoDevelop.</li>
</ol>
<p class="calibre3">Here's the completed <kbd class="calibre13">KillTarget.cs</kbd> script:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class KillTarget : MonoBehaviour { 
  public GameObject target; 
  public ParticleSystem hitEffect; 
  public GameObject killEffect; 
  public float timeToSelect = 3.0f; 
  public int score; 
 
  private float countDown; 
 
  void Start () { 
    score = 0; 
    countDown = timeToSelect; 
  } </pre>
<pre class="calibre18">void Update () { 
    Transform camera = Camera.main.transform; 
    Ray ray = new Ray (camera.position, camera.rotation * <br class="title-page-name"/>       Vector3.forward); 
    RaycastHit hit; 
    if (Physics.Raycast (ray, out hit) &amp;&amp; (hit.collider.gameObject <br class="title-page-name"/>       == target)) { 
      if (countDown &gt; 0.0f) { 
        // on target 
        countDown -= Time.deltaTime; 
        // print (countDown); 
        hitEffect.transform.position = hit.point; 
        hitEffect.Play(); 
      } else { 
        // killed 
        Instantiate( killEffect, target.transform.position, <br class="title-page-name"/>           target.transform.rotation ); 
        score += 1; 
        countDown = timeToSelect; 
        SetRandomPosition(); 
      } 
    } else { 
      // reset 
      countDown = timeToSelect; 
      hitEffect.Stop(); 
    } 
  } 
 
  void SetRandomPosition() { 
    float x = Random.Range (-5.0f, 5.0f); 
    float z = Random.Range (-5.0f, 5.0f); 
    target.transform.position = new Vector3 (x, 0.0f, z); 
  } 
} </pre>
<p class="calibre3">Let's go through this. First, we declare a number of public variables, as follows:</p>
<pre class="calibre18">  public GameObject target; 
  public ParticleSystem hitEffect; 
  public GameObject killEffect; 
  public float timeToSelect = 3.0f; 
  public int score; </pre>
<p class="calibre3">Like we did in the previous <kbd class="calibre13">LookMoveTo</kbd> script, our target will be Ethan. We're also adding a <kbd class="calibre13">hitEffect</kbd> particle emitter, a <kbd class="calibre13">killEffect</kbd> explosion, and a start value for the countdown timer, <kbd class="calibre13">timeToSelect</kbd>. Lastly, we'll keep track of our kills in the <kbd class="calibre13">score</kbd> variable.</p>
<p class="calibre3">The <kbd class="calibre13">Start()</kbd> method, which is called at the start of the gameplay, initializes the score to zero and sets the <kbd class="calibre13">countDown</kbd> timer to its starting value.</p>
<p class="calibre3">Then, in the <kbd class="calibre13">Update()</kbd> method, like in the <kbd class="calibre13">LookMoveTo</kbd> script, we cast a ray from the camera and check whether it hits our target, Ethan. When it does, we check the <kbd class="calibre13">countDown</kbd> timer.</p>
<p class="calibre3">If the timer is still counting, we decrement its value by the amount of time that's gone by since the last time <kbd class="calibre13">Update()</kbd> was called, using <kbd class="calibre13">Time.deltaTime</kbd>, and make sure that <kbd class="calibre13">hitEffect</kbd> is emitting at the hit point.</p>
<p class="calibre3">If the ray is still on its target and the timer is done counting down, Ethan is killed. We explode, bump up the score by one, reset the timer to its starting value, and move (respawn) Ethan to a random new location.</p>
<p class="calibre3">For an explosion, we'll use one of Unity's standard assets found in the <kbd class="calibre13">ParticleSystems</kbd> package. To activate it, <kbd class="calibre13">killEffect</kbd> should be set to the prefab named <kbd class="calibre13">Explosion</kbd>. Then, the script <em class="calibre14">instantiates</em> it. In other words, it makes it an object in the scene (at a specified transform), which kicks off its awesome scripts and effects.</p>
<p class="calibre3">Lastly, if the ray did not hit Ethan, we reset the counter and turn off the particles.</p>
<p class="calibre3">Save the script and go into the Unity Editor.</p>
<div class="packtinfobox"><strong class="calibre1">Extra challenge</strong>: Refactor the script to use co-routines to manage the delay timing, like we did in the <kbd class="calibre26">RandomPosition</kbd> script at the start of this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding particle effects</h1>
                </header>
            
            <article>
                
<p class="calibre3">Now, to populate the <kbd class="calibre13">public</kbd> variables, we will perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">First, we need the <kbd class="calibre13">ParticleSystems</kbd> package that comes with Unity standard assets. If you do not have them, navigate to <span>Assets</span> | <span>Import Package</span> | <span>ParticleSystems</span>, choose <span>All</span>, and then click on <span>Import</span>.</li>
<li class="calibre12">Select <kbd class="calibre13">GameController</kbd> from the <span>Hierarchy</span> panel and go to the <span>Kill Target (Script)</span> pane in the <span>Inspector</span> panel.</li>
<li class="calibre12">Drag the <kbd class="calibre13">Ethan</kbd> object from the <span>Hierarchy</span> panel onto the <span>Target</span> field.</li>
<li class="calibre12">From the main menu bar, navigate to <span>GameObject</span> | <span>Effects</span> | <span>Particle System</span> and name it <kbd class="calibre13">SparkEmitter</kbd>.</li>
</ol>
<p class="calibre3"> </p>
<ol start="5" class="calibre15">
<li class="calibre12">Reselect <kbd class="calibre13">GameController</kbd> and drag <kbd class="calibre13">SparkEmitter</kbd> onto the <span>Hit Effect</span> field.</li>
<li class="calibre12">In the <span>Project</span> panel, find the <kbd class="calibre13">Explosion</kbd> prefab in <kbd class="calibre13">Assets/Standard Assets/ParticleSystems/Prefabs</kbd> and drag the <kbd class="calibre13">Explosion</kbd> prefab onto the <span>Kill Effect</span> field.</li>
</ol>
<p class="calibre3">The script pane looks like the following screenshot:</p>
<div class="mce-root1"><img src="assets/b918629c-942d-4dc1-a14b-adfbbddfc55e.png" class="calibre24"/></div>
<p class="calibre3">We created a default particle system that will be used as the spark emitter. We need to set that up to our liking. I'll get you started, and you can play with it as you desire, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select <kbd class="calibre13">SparkEmitter</kbd> from the <span>Hierarchy</span> panel.</li>
<li class="calibre12">And in its <span>Inspector</span> panel, under <span>Particle System</span>, set the following values:
<ul class="calibre40">
<li class="calibre12"><span>Start Size</span>: <kbd class="calibre13">0.15</kbd></li>
<li class="calibre12"><span>Start Color</span>: pick a red/orange color</li>
<li class="calibre12"><span>Start Lifetime</span>: <kbd class="calibre13">0.3</kbd></li>
<li class="calibre12"><span>Max Particles</span>: <kbd class="calibre13">50</kbd></li>
</ul>
</li>
<li class="calibre12">Under <span>Emission</span>, set <span>Rate over Time</span>: <kbd class="calibre13">100</kbd></li>
<li class="calibre12">Under <span>Shape</span>, set <span>Shape</span>: <span>Sphere</span> and <span>Radius</span>: <kbd class="calibre13">0.01</kbd></li>
</ol>
<p class="calibre3">Here's what my <span class="calibre6">Scene</span> view looks like as I run Play Mode and zap Ethan in the chest:</p>
<div class="mce-root1"><img src="assets/2b8034be-eab0-4897-ab40-875301f2ada0.png" class="calibre43"/></div>
<p class="calibre3">When Ethan is shot, the <kbd class="calibre13">hitEffect</kbd> particle system is activated. After 3 seconds (or whatever value you set in the <kbd class="calibre13">TimeToSelect</kbd> variable), his <em class="calibre14">health</em> is depleted, the explosion effect is instantiated, the score is incremented, and he respawns at a new location. In  <a href="36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml" target="_blank" class="calibre10">Chapter 6</a><em class="calibre14">, World Space UI</em>, we'll see how we can show the current score to the player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleaning up</h1>
                </header>
            
            <article>
                
<p class="calibre3">One last thing before we're done: let's clean up the <kbd class="calibre13">Assets</kbd> folder a bit and move all the scripts into an <kbd class="calibre13">Assets/Scripts/</kbd> subfolder. Select the Project Assets folder in Project, create a folder, name it Scripts, and drag all your scripts into it.</p>
<p class="calibre3"> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Short intro to Unity C# programming</h1>
                </header>
            
            <article>
                
<p class="calibre3">As we just saw, Unity does a lot of things: it manages objects, renders them, animates them, calculates the physics of those objects, and so on. Unity itself is a program. It's made of code. Probably a lot of good code written by some very smart people. This internal Unity code can be accessed by you, the game developer, through the Unity Editor point-and-click interface that we've already been using. Within the Unity Editor, scripts are manifested as configurable components. However, it's also made more directly accessible to you through the Unity scripting API.</p>
<p class="calibre3"><strong class="calibre5">API</strong><span class="calibre6"> </span>(short for <strong class="calibre5"><span class="calibre6">A</span>pplication Programming Interface</strong>), refers to published software functions that you can access from your own scripts. Unity's API is very rich and nicely designed. That's one reason why people have written amazing applications and plugin add-ons for Unity.</p>
<p class="calibre3">There are many programming languages in the world. Unity has chosen to support the C# language from Microsoft. Computer languages have a specific syntax that must be obeyed. Otherwise, the computer will not understand your script. In Unity, script errors (and warnings) appear in the<span class="calibre6"> </span><span class="calibre6">Console</span><span class="calibre6"> </span>panel of the editor as well as in the bottom footer of the app window.</p>
<p class="calibre3">The default script editor for Unity is an integrated development environment, or an IDE, called<span class="calibre6"> </span><strong class="calibre5">MonoDevelop</strong>. You can configure a different editor or an IDE if you want, such as Microsoft's Visual Studio. MonoDevelop has some nice features such as autocompletion and pop-up help that understand the Unity documentation. C# scripts are text files that are named with a<span class="calibre6"> </span><kbd class="calibre13">.cs</kbd><span class="calibre6"> </span>extension.</p>
<p class="calibre3">In a Unity C# script, some of the words and symbols are a part of the C# language itself, some come from the Microsoft .NET Framework, and others are provided by the Unity API. And then there's the code that you write.</p>
<p class="calibre3">An empty default Unity C# script looks like this:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class RandomPosition : MonoBehaviour { 
 
  // Use this for initialization 
  void Start () { 
 
  } 
 
  // Update is called once per frame 
  void Update () { 
 
  } 
}</pre>
<p class="calibre3">Let's dissect it.</p>
<p class="calibre3">The first two lines indicate that this script needs some other stuff to run. The<span class="calibre6"> </span><kbd class="calibre13">using</kbd><span class="calibre6"> </span>keyword belongs to the C# language. The line using <kbd class="calibre13">UnityEngine</kbd> says that we'll be using the<span class="calibre6"> </span><kbd class="calibre13">UnityEngine</kbd><span class="calibre6"> </span>API. The line using<span class="calibre6"> </span><kbd class="calibre13">System.Collections</kbd> says that we also might use a library of functions named<span class="calibre6"> </span><kbd class="calibre13">Collections</kbd><span class="calibre6"> </span>to access lists of objects.</p>
<p class="calibre3">In C#, each line of code ends with a semicolon. Double slashes (<kbd class="calibre13">//</kbd>) indicate comments in the code, and anything from there to the end of that line will be ignored.</p>
<p class="calibre3">This Unity script defines a class named<span class="calibre6"> </span><kbd class="calibre13">RandomPosition</kbd>.<span class="calibre6"> </span><strong class="calibre5">Classes</strong><span class="calibre6"> </span>are like code templates with their own properties (variables) and behavior (functions). Classes derived from the<span class="calibre6"> </span><kbd class="calibre13">MonoBehaviour</kbd><span class="calibre6"> </span>base class are recognized by Unity and used when your game runs. For example, in the first script we wrote at the top of this chapter, the line <kbd class="calibre13">public class RandomPosition : MonoBehaviour</kbd><span class="calibre6"> </span>basically says<span class="calibre6"> </span><em class="calibre14">we are defining a new public class named</em> <kbd class="calibre13">RandomPosition</kbd><em class="calibre14">," which inherits all the abilities of the</em> <kbd class="calibre13">MonoBehaviour</kbd><em class="calibre14"> Unity base class</em>, including the capabilities of the<span class="calibre6"> </span><kbd class="calibre13">Start()</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">Update()</kbd><span class="calibre6"> </span>functions. The body of the class is enclosed in a pair of curly braces (<kbd class="calibre13">{}</kbd>).</p>
<p class="calibre3">When something is<span class="calibre6"> </span><kbd class="calibre13">public</kbd>, it can be seen by other code outside this specific script file. When it's<span class="calibre6"> </span><kbd class="calibre13">private</kbd>, it can only be referenced within this file. We want Unity to see the<span class="calibre6"> </span><kbd class="calibre13">RandomPosition</kbd><span class="calibre6"> </span>class.</p>
<p class="calibre3">Classes define variables and functions. A<span class="calibre6"> </span><strong class="calibre5">variable</strong><span class="calibre6"> </span>holds data values of a specific type, such as<span class="calibre6"> </span><kbd class="calibre13">float</kbd>,<span class="calibre6"> </span><kbd class="calibre13">int</kbd>,<span class="calibre6"> </span><kbd class="calibre13">boolean</kbd>,<span class="calibre6"> </span><kbd class="calibre13">GameObject</kbd>,<span class="calibre6"> </span><kbd class="calibre13">Vector3</kbd>, and so on.<span class="calibre6"> </span><strong class="calibre5">Functions</strong><span class="calibre6"> </span>implement logic (step-by-step instructions). Functions can receive<span class="calibre6"> </span><em class="calibre14">arguments</em>-variables enclosed in a parenthesis used by its code-and can return new values when it's done.</p>
<p class="calibre3">Numeric<span class="calibre6"> </span><kbd class="calibre13">float</kbd><span class="calibre6"> </span>constants, such as<span class="calibre6"> </span><kbd class="calibre13">5.0f</kbd>, require an<span class="calibre6"> </span><kbd class="calibre13">f</kbd><span class="calibre6"> </span>at the end in C# to ensure<br class="calibre7"/>
that the data type is a<span class="calibre6"> </span><em class="calibre14">simple</em><span class="calibre6"> </span>floating point value and not a<span class="calibre6"> </span><em class="calibre14">double-precision</em><span class="calibre6"> </span>floating point value.</p>
<p class="calibre3">Unity will automatically call some special functions if you've defined them <kbd class="calibre13">Start()</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">Update()</kbd><span class="calibre6"> </span>are two examples. Empty versions of these are provided in the default C# script. The datatype in front of a function indicates the type of value returned.<span class="calibre6"> </span><kbd class="calibre13">Start()</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">Update()</kbd><span class="calibre6"> </span>do not return values, so they're<span class="calibre6"> </span><kbd class="calibre13">void</kbd>.</p>
<p class="calibre3">Each<span class="calibre6"> </span><kbd class="calibre13">Start()</kbd><span class="calibre6"> </span>function from all<span class="calibre6"> </span><kbd class="calibre13">MonoBehaviour</kbd><span class="calibre6"> </span>scripts in your game is called before the gameplay begins. It's a good place for data initialization. All the<span class="calibre6"> </span><kbd class="calibre13">Update()</kbd><span class="calibre6"> </span>functions are called during each time slice, or frame, while the game is running. This is where most of the action lies.</p>
<p class="calibre3">Once you've written or modified a script in the MonoDevelop or Visual Studio editor, save it. Then, switch to the Unity Editor window. Unity will automatically recognize that the script has changed and will reimport it. If errors are found, it will report them right away in the<span class="calibre6"> </span><span class="calibre6">Console</span><span class="calibre6"> </span>panel.</p>
<p class="calibre3">This is just a cursory introduction to Unity programming. As we work through the projects in this book, I will explain additional bits as they're introduced.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre3">In this chapter, we explored the relationship between the VR camera and objects in the scene. We first made Ethan (the zombie) walk randomly around the scene and enabled him to move by using a NavMesh, but then we directed his wanderings using a 3D cursor on the <span class="calibre6">x</span>, <span class="calibre6">z</span> ground plane. This cursor follows our gaze as we look around the scene in virtual reality. Lastly, we also used our gaze to shoot a ray at Ethan, causing him to lose health and eventually explode.</p>
<p class="calibre3">These look-based techniques can be used in non-VR games, but in VR, it's very common and almost essential. We'll be using them more in the later chapters of this book too.</p>
<p class="calibre3">In the next chapter, we will use our hands to interact with the virtual scene. We will learn about Unity Input events, as well as input systems for SteamVR, Oculus, and Windows Mixed Reality, to name a few. As this can get complicated, we'll write our own VR input event system to keep our application independent of the specific VR devices.</p>


            </article>

            
        </section>
    </body></html>