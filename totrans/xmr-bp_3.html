<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Building a GPS Locator Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building a GPS Locator Application</h1></div></div></div><p>In this chapter, we will delve deeper into code sharing. We will build a <code class="literal">Xamarin.Forms</code> application that integrates native GPS location services and Google Maps APIs. We will cover more content on IoC containers, the <code class="literal">Xamarin.Forms.Maps</code> library, and techniques for c-sharp <code class="literal">async</code> and background tasks.</p><p>Expected knowledge:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Web services</li><li class="listitem" style="list-style-type: disc">JSON</li><li class="listitem" style="list-style-type: disc">Google Maps</li><li class="listitem" style="list-style-type: disc">Google Geocoding APIs (it helps to have a Google Developer account)</li></ul></div><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Core location and GPS</li><li class="listitem" style="list-style-type: disc">Navigation with <code class="literal">Xamarin.Forms</code></li><li class="listitem" style="list-style-type: disc">Google Maps integration</li><li class="listitem" style="list-style-type: disc">Integrating Google Maps with <code class="literal">Xamarin.Forms.Maps</code></li><li class="listitem" style="list-style-type: disc">Reactive extensions</li><li class="listitem" style="list-style-type: disc">Core location with iOS and the <code class="literal">CLLocationManager</code> Library</li><li class="listitem" style="list-style-type: disc">Android and the <code class="literal">LocationManager</code></li><li class="listitem" style="list-style-type: disc">Creating our Windows project</li><li class="listitem" style="list-style-type: disc">Core location services with Windows Phone</li><li class="listitem" style="list-style-type: disc">The Application class</li><li class="listitem" style="list-style-type: disc">Web services and data contracts</li><li class="listitem" style="list-style-type: disc">Integrating with a Google APIs</li><li class="listitem" style="list-style-type: disc">Creating the Geocoding web service controller</li><li class="listitem" style="list-style-type: disc"><code class="literal">Newtonsoft.Json</code> and Microsoft HTTP client libraries</li><li class="listitem" style="list-style-type: disc"><code class="literal">ModernHttpClient</code> and client message handlers</li><li class="listitem" style="list-style-type: disc">Feeding JSON data into the <code class="literal">IObservable</code> framework more reactive extensions</li><li class="listitem" style="list-style-type: disc">Resource (RESX) files</li><li class="listitem" style="list-style-type: disc">Using the Geocoding web server controller</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnNavigatedTo</code> and <code class="literal">OnShow</code></li><li class="listitem" style="list-style-type: disc">Pythagoras equirectangular projection</li></ul></div><div class="section" title="Core location and GPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Core location and GPS</h1></div></div></div><p>All mobile phone platforms have access to core location services. These services are background tasks that run in the background and update the latitude and longitude values at certain intervals indefinitely until the service is stopped. 99% of smart phones come with a built-in GPS tracker, allowing you to integrate these latitude and longitude values with your application.</p><div class="section" title="Project setup"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Project setup</h2></div></div></div><p>Let's jump straight into project setup and create a new <code class="literal">Xamarin.Forms</code> application. We are going to start by setting up an IoC container with <span class="strong"><strong>Autofac</strong></span>, exactly the same as the previous project, import <span class="strong"><strong>Autofac</strong></span> into all three projects (PCL, Android, and iOS). We can reuse a lot of the PCL code from the IoC container implementation in the previous project.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The more apps you build, the more problems you solve; why reinvent the wheel over and over? Eventually, when you have built multiple applications, future apps will be built mostly from piecing parts of different projects together.</p></div></div><p>Copy in the <code class="literal">IoC</code>, <code class="literal">Pages</code>, and <code class="literal">ViewModels</code> folders, and let's start building our <code class="literal">MainPage</code>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ContentPage   &#13;
      &#13;
    x:Class="Locator.Pages.MainPage" &#13;
    BackgroundColor="White" &#13;
    Title="Welcome"&gt; &#13;
 &#13;
    &lt;ContentPage.Content&gt; &#13;
 &#13;
    &lt;Grid x:Name="Grid" RowSpacing="10" Padding="10, 10, 10, 10" VerticalOptions="Center"&gt; &#13;
        &lt;Grid.RowDefinitions&gt; &#13;
            &lt;RowDefinition Height="*"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
            &lt;RowDefinition Height="Auto"/&gt; &#13;
        &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
        &lt;Grid.ColumnDefinitions&gt; &#13;
            &lt;ColumnDefinition Width="*"/&gt; &#13;
        &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
        &lt;Image x:Name="Image" Source="map.png" HeightRequest="120" WidthRequest="120"  &#13;
                Grid.Row="0" Grid.Column="0"/&gt; &#13;
 &#13;
        &lt;Label x:Name="DesciptionLabel" Text="{Binding DescriptionMessage}" HorizontalOptions="Center" Font="Arial, 20" Grid.Row="1" Grid.Column="0"&gt; &#13;
            &lt;Label.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Black" &#13;
                    WinPhone="Black" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Label.TextColor&gt; &#13;
        &lt;/Label&gt; &#13;
 &#13;
        &lt;Button x:Name="LocationButton" Text="{Binding LocationTitle}" Command="{Binding LocationCommand}" BackgroundColor="Silver" Grid.Row="2" Grid.Column="0"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt; &#13;
 &#13;
        &lt;Button x:Name="ExitButton" Text="{Binding ExitTitle}" Command="{Binding ExitCommand}" BackgroundColor="Silver" Grid.Row="3" Grid.Column="0"&gt; &#13;
            &lt;Button.TextColor&gt; &#13;
                &lt;OnPlatform x:TypeArguments="Color" &#13;
                    Android="Navy" &#13;
                    WinPhone="Blue" &#13;
                    iOS="Black"&gt; &#13;
                &lt;/OnPlatform&gt; &#13;
            &lt;/Button.TextColor&gt; &#13;
        &lt;/Button&gt;  &#13;
    &lt;/Grid&gt; &#13;
 &#13;
    &lt;/ContentPage.Content&gt; &#13;
 &#13;
&lt;/ContentPage&gt; &#13;
</pre><p>This is very much the same as the previous <code class="literal">MainPage</code>, but this time we are adding two <code class="literal">Buttons</code>, a <code class="literal">Label</code>, and an <code class="literal">Image</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Before reading any further, have a look at the properties bounded to each element. See if you can build the properties for the view model.</p></div></div></div><div class="section" title="Navigation with Xamarin.Forms"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Navigation with Xamarin.Forms</h2></div></div></div><p>Before we start building any view models we are going to build our navigation system. <code class="literal">Xamarin.Forms</code> comes complete with navigation control for all platforms, so you won't have to worry about it. But as we always like to do things the hard way, we are going to show you a technique to separate our cross-platform structure a little more, in order to keep things more modular. Using one PCL project to contain both view models and views is great, but what if we could separate our views from view models into two PCL projects?</p></div><div class="section" title="Why would we do this?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Why would we do this?</h2></div></div></div><p>One small issue we have with the current PCL is that it relies completely on <code class="literal">Xamarin.Forms</code>. Only our XAML sheets and user interfaces rely on <code class="literal">Xamarin.Forms</code>; our view models do not. Then let's move the view models from the <code class="literal">Xamarin.Forms</code> PCL into an even lower-level PCL project that only relies on c-sharp libraries.</p><p>This is a good technique to keep the PCL projects completely separated. Developing a modular system is advantageous when it comes to code sharing. For example, we are building a new app that requires a login screen, a list view screen, and other similar screens most apps include. As we already have the view models that handle all the web services, JSON processing, and property bindings, do we really need to change much? Now that we have a low-level project that simply has the view models, let's just extract the ones we need, design our user interfaces for the view models, and bind them together. Not only can we reuse these view models for other apps, but if we wanted to develop an entirely separated application (for example, a WPF application), we can just compare the required screens, take the related view models, create new user interfaces, and bind them together. Keeping everything completely separated allows for complete plug-and-play capability, which will dramatically decrease the development time required to build similar applications.</p><p>Let's approach this pattern by creating a new PCL project and copying in the view models; call it <span class="strong"><strong>Locator.Portable</strong></span>:</p><div class="mediaobject"><img src="graphics/B05293_03_01.jpg" alt="Why would we do this?"/></div><p>We also want to copy over the <code class="literal">IoC</code> folder as well.</p></div><div class="section" title="Building the navigation control"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Building the navigation control</h2></div></div></div><p>Our first step is to create a folder called <code class="literal">enum</code>, add the <code class="literal">PageNames.cs</code> file, and copy in the following:</p><pre class="programlisting">public enum PageNames &#13;
{ &#13;
    MainPage, &#13;
 &#13;
    MapPage &#13;
} &#13;
</pre><p>Now let's add a new folder called <code class="literal">UI</code> and create a new file called <code class="literal">INavigationService.cs</code>:</p><pre class="programlisting">public interface INavigationService &#13;
{ &#13;
    Task Navigate(PageNames pageName); &#13;
} &#13;
</pre><p>Then we create a new folder in the <code class="literal">Xamarin.Forms</code> PCL (Locator) project called <code class="literal">UI</code>, and create a new file called <code class="literal">NavigationService.cs</code>. The <code class="literal">NavigationService</code> class will inherit the <code class="literal">INavigationService</code> interface:</p><pre class="programlisting">    public class NavigationService : INavigationService &#13;
    { &#13;
        #region INavigationService implementation &#13;
 &#13;
        public async Task Navigate (PageNames pageName) &#13;
        { &#13;
        } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Simple, right? Navigate will be used whenever we want the stack to navigate to a page. In making an abstracted interface, as we have done for navigation, this allows us to control navigation way down in the lower-level PCL. Now, fill in the rest:</p><pre class="programlisting">        public async Task Navigate (PageNames pageName, IDictionary&lt;string, object&gt; navigationParameters) &#13;
        { &#13;
            var page = GetPage (pageName); &#13;
 &#13;
            if (page != null)  &#13;
            { &#13;
                var navigablePage = page as INavigableXamarinFormsPage; &#13;
 &#13;
                if (navigablePage != null)  &#13;
                { &#13;
                    await IoC.Resolve&lt;NavigationPage&gt; ().PushAsync (page); &#13;
                    navigablePage.OnNavigatedTo (navigationParameters); &#13;
                } &#13;
            } &#13;
        } &#13;
 &#13;
        private Page GetPage(PageNames page) &#13;
        { &#13;
            switch(page) &#13;
            { &#13;
                case PageNames.MainPage: &#13;
                    return IoC.Resolve&lt;MainPage&gt; (); &#13;
                case PageNames.MapPage: &#13;
                    return IoC.Resolve&lt;MapPage&gt; (); &#13;
                default: &#13;
                    return null; &#13;
            } &#13;
        } &#13;
</pre><p>Firstly, look more closely at the private function <code class="literal">GetPage</code>; this will be called every time the <code class="literal">Navigate</code> function is called to retrieve the correct <code class="literal">ContentPage</code> object (which is registered in the <code class="literal">IoC</code> container) based upon the <code class="literal">PageName </code><code class="literal">enum</code> passed to it, and if we have found the correct page, push it onto the navigation stack.</p><p>Finally, let's build our new <code class="literal">XamFormsModule</code> for registering the pages and navigation service:</p><pre class="programlisting">public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;MainPage&gt; ().SingleInstance(); &#13;
            builer.RegisterType&lt;MapPage&gt; ().SingleInstance(); &#13;
 &#13;
            builer.Register (x =&gt; new NavigationPage(x.Resolve&lt;MainPage&gt;())).AsSelf().SingleInstance(); &#13;
 &#13;
            builer.RegisterType&lt;NavigationService&gt; ().As&lt;INavigationService&gt;().SingleInstance(); &#13;
        } &#13;
</pre><p>We are registering one navigation page throughout the entire life of the application, and we set the starting page to the one main page item we registered before.</p><p>Now open up the <code class="literal">App.cs</code> file and update it accordingly:</p><pre class="programlisting">public App () &#13;
        { &#13;
            MainPage = IoC.Resolve&lt;NavigationPage&gt; (); &#13;
        } &#13;
</pre><p>Making sense now?</p><p>IoC is a very powerful pattern for cross-platform applications.</p></div><div class="section" title="View model navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>View model navigation</h2></div></div></div><p>Now let's get back to our <code class="literal">MainPageViewModel</code> and update and modify the previous chapter's <code class="literal">MainPageViewModel</code> with the properties required for the data-bindings on <code class="literal">MainPage.xaml</code> shown previously. Firstly, let's implement the <code class="literal">private</code> properties:</p><pre class="programlisting">public class MainPageViewModel : ViewModelBase &#13;
    { &#13;
                #region Private Properties &#13;
     &#13;
        private readonly IMethods _methods; &#13;
 &#13;
        private string _descriptionMessage = "Find your location"; &#13;
 &#13;
        private string _locationTitle = "Find Location"; &#13;
 &#13;
        private string _exitTitle = "Exit"; &#13;
 &#13;
        private ICommand _locationCommand; &#13;
 &#13;
        private ICommand _exitCommand; &#13;
 &#13;
        #endregion &#13;
 &#13;
} &#13;
</pre><p>Now for the <code class="literal">Public</code> properties:</p><pre class="programlisting">#region Public Properties &#13;
 &#13;
        public string DescriptionMessage &#13;
        { &#13;
            get &#13;
            { &#13;
                return _descriptionMessage; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_descriptionMessage)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _descriptionMessage = value; &#13;
                OnPropertyChanged("DescriptionMessage"); &#13;
            } &#13;
        } &#13;
 &#13;
        public string LocationTitle &#13;
        { &#13;
            get &#13;
            { &#13;
                return _locationTitle; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_locationTitle)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _locationTitle = value; &#13;
                OnPropertyChanged("LocationTitle"); &#13;
            } &#13;
        } &#13;
 &#13;
        public string ExitTitle &#13;
        { &#13;
            get &#13;
            { &#13;
                return _exitTitle; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_exitTitle)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _exitTitle = value; &#13;
                OnPropertyChanged("ExitTitle"); &#13;
            } &#13;
        } &#13;
 &#13;
        public ICommand LocationCommand &#13;
        { &#13;
            get &#13;
            { &#13;
                return _locationCommand; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_locationCommand)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _locationCommand = value; &#13;
                OnPropertyChanged("LocationCommand"); &#13;
            } &#13;
        } &#13;
 &#13;
        public ICommand ExitCommand &#13;
        { &#13;
            get &#13;
            { &#13;
                return _exitCommand; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_exitCommand)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _exitCommand = value; &#13;
                OnPropertyChanged("ExitCommand"); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Are we starting to see the same pattern here?</p><p>Now add the constructor, which is going to use the navigation service interface that we abstracted earlier through the <code class="literal">IoC</code> container:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public MainPageViewModel (INavigationService navigation) : base (navigation) &#13;
        { &#13;
 &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Now it's time to show you another trick using the IoC container. In our constructor, we need to be able to create a new <code class="literal">Command </code>object from the <code class="literal">Xamarin.Forms</code> library. We are lucky here, because since commands from <code class="literal">Xamarin.Forms</code> inherit the <code class="literal">ICommand </code>interface from <code class="literal">System.Windows.Input</code>, we are able to register this object in the IoC container. Open up <code class="literal">XamFormsModule.cs</code> and update the <code class="literal">Register</code> function to include the following:</p><pre class="programlisting">builer.RegisterType&lt;Xamarin.Forms.Command&gt; ().As&lt;ICommand&gt;().InstancePerDependency(); &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>Take note that we are registering this type as an <code class="literal">InstancePerDependency</code> because we want an independent instance every time we create a command in the view model constructors.</p></div></div><p>Now let's create a new command through the constructor of <code class="literal">MainPageViewModel</code>; update the constructor like this:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public MainPageViewModel (INavigationService navigation, Func&lt;Action, ICommand&gt; commandFactory) : base (navigation) &#13;
        { &#13;
            _locationCommand = commandFactory (() =&gt; Navigation.Navigate(PageNames.MapPage)); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>In the constructor, we are pulling a <code class="literal">Func</code> out of the <code class="literal">IoC</code> container, which takes an Action and returns an <code class="literal">ICommand</code> object, because we have registered this interface to a <code class="literal">Xamarin.FormsCommand</code> object, we will be left with a new <code class="literal">Command</code> with the action passed in the constructor as follows:</p><pre class="programlisting">  locationCommand = commandFactory (() =&gt; Navigation.Navigate(PageNames.MapPage)); &#13;
</pre><p>This is exactly the same as doing this if we were using the <code class="literal">Xamarin.Forms</code> library:</p><pre class="programlisting">  locationCommand = new Command (() =&gt; Navigation.Navigate(PageNames.MapPage)); &#13;
</pre><p>Now we have a new <code class="literal">Command</code> set with and <code class="literal">Action </code>to push a new <code class="literal">MapPage</code> onto the stack when the button is pressed:</p><pre class="programlisting">    public class PortableModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;MainPageViewModel&gt; ().SingleInstance(); &#13;
           &#13;
        } &#13;
    } &#13;
</pre><p>Now to register our new view model with the <code class="literal">IoC</code> container. Create a new folder called <code class="literal">Modules</code> for the portable <code class="literal">IoC</code> module. Create a new file called <code class="literal">PortableModule.cs</code> and paste in the preceding code into it.</p></div><div class="section" title="Integrating Google Maps using Xamarin.Forms.Maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Integrating Google Maps using Xamarin.Forms.Maps</h2></div></div></div><p>Our next step is to implement the <code class="literal">MapPage</code>; this page will show a panel that will display Google Maps. Underneath this panel, we will also display the location information (latitude, longitude, address, and so on) retrieved from our native platform core location services. To access these native services, we need to import <code class="literal">Xamarin.Forms.Maps</code>:</p><div class="mediaobject"><img src="graphics/B05293_03_02.jpg" alt="Integrating Google Maps using Xamarin.Forms.Maps"/></div><p>Now that we have imported the <code class="literal">Xamarin.Forms.Maps</code> library, we can access the native Google Maps services. We can now create the <code class="literal">Map</code> user interface element via <code class="literal">MapPage.xaml</code>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;ContentPage   &#13;
      &#13;
       &#13;
    x:Class="Locator.Pages.MapPage" &#13;
    BackgroundColor="White" &#13;
    Title="Map"&gt; &#13;
 &#13;
    &lt;ContentPage.Content&gt; &#13;
 &#13;
        &lt;Grid x:Name="Grid" RowSpacing="10" Padding="10, 10, 10, 10"&gt; &#13;
            &lt;Grid.RowDefinitions&gt; &#13;
                &lt;RowDefinition Height="*"/&gt; &#13;
                &lt;RowDefinition Height="80"/&gt; &#13;
                &lt;RowDefinition Height="60"/&gt; &#13;
                &lt;RowDefinition Height="60"/&gt; &#13;
            &lt;/Grid.RowDefinitions&gt; &#13;
 &#13;
            &lt;Grid.ColumnDefinitions&gt; &#13;
                &lt;ColumnDefinition Width="*"/&gt; &#13;
            &lt;/Grid.ColumnDefinitions&gt; &#13;
 &#13;
            &lt;maps:Map x:Name="MapView" IsShowingUser="true" Grid.Row="0" Grid.Column="0"/&gt; &#13;
 &#13;
            &lt;Label x:Name="AddressLabel" Text="{Binding Address}" TextColor="Black" Grid.Row="1" Grid.Column="0"/&gt; &#13;
 &#13;
            &lt;Button x:Name="GeolocationButton" Text="{Binding GeolocationButtonTitle}"  &#13;
                Command="{Binding GeolocationCommand}" Grid.Row="2" Grid.Column="0"/&gt; &#13;
 &#13;
            &lt;Button x:Name="NearestAddressButton" Text="Find Nearest Address"  &#13;
                Command="{Binding NearestAddressCommand}" Grid.Row="3" Grid.Column="0"/&gt; &#13;
        &lt;/Grid&gt; &#13;
 &#13;
    &lt;/ContentPage.Content&gt; &#13;
 &#13;
&lt;/ContentPage&gt; &#13;
</pre><p>See at the top how we imported the <code class="literal">Xamarin.Forms.Maps</code> library?</p><p>We have created four rows in the <code class="literal">Grid</code>, one for the <code class="literal">Map</code> (this will cover most of the screen), one for a label that will display the address, and two buttons for starting/stopping location updates and finding the closest location out of a list of addresses.</p><p>So where does the address come from?</p><p>We now need to implement the core location service; this is a background service that will send position information based upon your location. The information returned is very detailed; we can depict exact longitude and latitude values, as well as addresses.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Core location services can drain device battery life, so when using core location, we must manage the usage and turn it on and off when required. As this is a background service, when the app is placed in the background, the location service will still be running.</p></div></div><p>To begin our core location implementation, we are going to create an abstracted geolocation interface called <span class="strong"><strong>IGeolocator</strong></span>, but first we are going to add another library for processing our location updates.</p></div><div class="section" title="Reactive Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Reactive Extensions</h2></div></div></div><p>If you haven't heard of the RX framework before, you are about to enter a never-ending rabbit hole of asynchrony. RX gives developers the ability to use LINQ-style query operations for processing objects in observable sequences. It allows for full control over event-based operations between different elements of an application.</p><p>In our project, we are going to use a <span class="strong"><strong>Subject</strong></span> for handling location events received on the native side. In cross-platform development, because we work in both PCL and native-level projects, it involves passing data and events up and down the project structure.</p><p>We could use the <code class="literal">event</code> framework, which is standard in c-sharp, but instead we are going to use a <code class="literal">Subject</code> to push events into an observable sequence, while we subscribe to the subject at a lower level to receive and handle these events.</p><p>Let's start by importing the <span class="strong"><strong>Reactive Extensions</strong></span> interface in our native and PCL projects:</p><div class="mediaobject"><img src="graphics/B05293_03_03.jpg" alt="Reactive Extensions"/></div><p>Now let's create our <code class="literal">IGeolocator</code> class:</p><pre class="programlisting">    public interface IGeolocator &#13;
    { &#13;
        Subject&lt;IPosition&gt; Positions { get; set; }  &#13;
 &#13;
        void Start(); &#13;
 &#13;
        void Stop(); &#13;
    } &#13;
</pre><p>Notice the interface <code class="literal">IPosition</code>? We must also create a new interface, which is going to store all the location information:</p><pre class="programlisting">public interface IPosition &#13;
    { &#13;
        double Latitude {get; set;} &#13;
 &#13;
        double Longitude {get; set;} &#13;
    } &#13;
</pre><p>The interface is designed to return these variables to be used for the <code class="literal">Xamarin.Forms</code> geolocator, so we can pull down address information. This information is returned by <code class="literal">CLLocationManager</code> with every position update.</p><p>Why do we need to create an interface for the position information?</p><p>As this information comes from different native services, we want to create our own object to contain the information we need in the lower-level projects.</p></div><div class="section" title="Core location with iOS and the CLLocationManager library"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Core location with iOS and the CLLocationManager library</h2></div></div></div><p><code class="literal">CLLocationManager</code> is used for the delivery of location and heading events; we must use this object in our Geolocator implementation, so let's begin:</p><pre class="programlisting">    public class GeolocatorIOS : IGeolocator &#13;
    { &#13;
        public Subject&lt;IPosition&gt; Positions { get; set; }  &#13;
    } &#13;
</pre><p>From our interface, we must include the <code class="literal">Subject</code>. Now let's instantiate <code class="literal">CLLocationManager</code>. First, we must import the <code class="literal">CoreLocation</code> library:</p><pre class="programlisting">    using CoreLocation; &#13;
</pre><p>Now we instantiate <code class="literal">CLLocationManager</code> in the constructor when this is created through the IoC container. According to iOS standards, since changes to iOS 9 and iOS 8, we must implement a few separate calls to allow the location manager to begin sending location events:</p><pre class="programlisting">public GeolocatorIOS() &#13;
        { &#13;
            Positions = new Subject&lt;IPosition&gt; (); &#13;
         &#13;
            locationManager = new CLLocationManager(); &#13;
            locationManager.PausesLocationUpdatesAutomatically = false;  &#13;
 &#13;
            // iOS 8 has additional permissions requirements &#13;
            if (UIDevice.CurrentDevice.CheckSystemVersion (8, 0))  &#13;
            { &#13;
                locationManager.RequestWhenInUseAuthorization (); &#13;
            } &#13;
 &#13;
            if (UIDevice.CurrentDevice.CheckSystemVersion (9, 0))  &#13;
            { &#13;
                locationManager.AllowsBackgroundLocationUpdates = true; &#13;
            } &#13;
        } &#13;
</pre><p>This is nothing major; in iOS 8 we must request the authorization before using the location manager. For iOS 9, we can also set some conditional settings. For our example, we have used this:</p><pre class="programlisting">AllowsBackgroundLocationUpdates = true &#13;
</pre><p>This allows the location manager to keep sending events, even when the app is in the background. We can also do this:</p><pre class="programlisting">if (UIDevice.CurrentDevice.CheckSystemVersion (8, 0))  &#13;
            { &#13;
                locationManager.RequestWhenInUseAuthorization (); &#13;
            }  &#13;
</pre><p>This will only allow events from <code class="literal">CLLocationManager</code> when the app is in the foreground. There are multiple settings that can be changed, between controlling location events in the foreground and background when using location services. We want to know whether our app is going to keep updates running in the background/foreground. Most of the time, we want location updates when the app is in the foreground to reduce battery consumption, but there are scenarios where updates should continue in the background.</p><p>Now for the rest of the class; let's begin handling the location events:</p><pre class="programlisting">        private void handleLocationsUpdated (object sender, CLLocationsUpdatedEventArgs e) &#13;
        { &#13;
            var location = e.Locations.LastOrDefault (); &#13;
            if (location != null) &#13;
            { &#13;
                Console.WriteLine ("Location updated, position: " + location.Coordinate.Latitude + "-" + location.Coordinate.Longitude); &#13;
 &#13;
                // fire our custom Location Updated event &#13;
                Positions.OnNext(new Position() &#13;
                    { &#13;
                        Latitude = location.Coordinate.Latitude, &#13;
                        Longitude = location.Coordinate.Longitude, &#13;
                    }); &#13;
            } &#13;
        } &#13;
</pre><p>The previous function is called every time we receive a location update from <code class="literal">CLLocationManager</code>. From the event argument <code class="literal">CLLocationsUpdatedEventArgs</code>, we pull out a list of locations; as sometimes the <code class="literal">CLLocationManager</code> receives multiple updates at one time, we always want to take the very last location. Then once we create a new <code class="literal">Position</code>, assign the latitude and longitude values, and by calling the <code class="literal">OnNext</code> function, we push a new event into the observable sequence.</p><p>Our next step is to add some small additions to the <code class="literal">info.plist</code> file.</p><p>Let's add the following keys:</p><pre class="programlisting">  &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &#13;
  &lt;string&gt;Can we use your location&lt;/string&gt; &#13;
  key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &#13;
  &lt;string&gt;We are using your location&lt;/string&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The preceding code is from the source of the <code class="literal">info.plist</code> file.</p></div></div><p>The <code class="literal">NSLocationAlwaysUsageDescription</code> and <code class="literal">NSLocationWhenInUseUsageDescription</code> keys will be displayed to the user in the alert that requests location data access. We must also add the background modes for the location in which we can set the iOS project properties:</p><div class="mediaobject"><img src="graphics/B05293_03_04.jpg" alt="Core location with iOS and the CLLocationManager library"/></div><p>Now we must implement the <code class="literal">Start</code> and <code class="literal">Stop</code> functions:</p><pre class="programlisting">        public void Start() &#13;
        { &#13;
            if (CLLocationManager.LocationServicesEnabled)  &#13;
            { &#13;
                locationManager.DesiredAccuracy = 1; &#13;
                locationManager.LocationsUpdated += handleLocationsUpdated; &#13;
                locationManager.StartUpdatingLocation(); &#13;
            } &#13;
        } &#13;
 &#13;
        public void Stop() &#13;
        { &#13;
            locationManager.LocationsUpdated -= handleLocationsUpdated; &#13;
            locationManager.StopUpdatingLocation(); &#13;
        } &#13;
</pre><p>The <code class="literal">Start</code> function will check whether location services have been enabled, assign the <code class="literal">LocationsUpdated</code> event, and start the location updates:</p><pre class="programlisting">public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;GeolocatorIOS&gt;().As&lt;IGeolocator&gt;().SingleInstance(); &#13;
        } &#13;
</pre><p>The <code class="literal">Stop</code> function will do nothing more than stop the location updates and remove the event handler. That's all for the iOS geolocator. Next, we must register this interface through the IoC container.</p></div></div></div>
<div class="section" title="Handling location updates"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Handling location updates</h1></div></div></div><p>Our next step is to build the <code class="literal">MapPageViewModel</code>; this view model will contain the <code class="literal">IGeolocator</code> we just built. We will also be listening for location updates from the observable sequence and processing latitude and longitude values to gather address details.</p><p>Let's begin with the constructor:</p><pre class="programlisting">public MapPageViewModel (INavigationService navigation, IGeolocator geolocator, Func&lt;Action, ICommand&gt; commandFactory,  &#13;
            IGeocodingWebServiceController geocodingWebServiceController) : base (navigation) &#13;
        { &#13;
            _geolocator = geolocator; &#13;
            _geocodingWebServiceController = geocodingWebServiceController; &#13;
 &#13;
            _nearestAddressCommand = commandFactory(() =&gt; FindNearestSite()); &#13;
            _geolocationCommand = commandFactory(() =&gt; &#13;
            { &#13;
                if (_geolocationUpdating) &#13;
                { &#13;
                    geolocator.Stop(); &#13;
                } &#13;
                else &#13;
                { &#13;
                    geolocator.Start(); &#13;
                } &#13;
 &#13;
                GeolocationButtonTitle = _geolocationUpdating ? "Start" : "Stop"; &#13;
                _geolocationUpdating = !_geolocationUpdating; &#13;
            }); &#13;
 &#13;
            _positions = new List&lt;IPosition&gt; (); &#13;
 &#13;
            LocationUpdates = new Subject&lt;IPosition&gt; (); &#13;
            ClosestUpdates = new Subject&lt;IPosition&gt; (); &#13;
        } &#13;
</pre><p>Our constructor will retrieve the navigation service and the geolocator. Notice how we assign the <code class="literal">geolocator</code> class:</p><pre class="programlisting">_geolocator = geolocator; &#13;
</pre><p>The constructor will also be responsible for creating the commands for the two buttons on our map page. Any view models that require objects from the IoC container are usually assigned as read-only properties because they will never change. We want the property name to be the exact same as the item in the constructor argument:</p><pre class="programlisting">private readonly IGeolocator _geolocator; &#13;
</pre><p>Now let's create our private properties:</p><pre class="programlisting">#region Private Properties &#13;
     &#13;
private IDisposable _subscriptions; &#13;
 &#13;
private readonly IGeolocator _geolocator; &#13;
 &#13;
private string _address; &#13;
 &#13;
#endregion &#13;
</pre><p>We have a new object, the <code class="literal">IDisposable</code> interface, which is used to take control of unmanaged resources, meaning we can release objects that have no control over memory disposal. In our case, we are going to be setting up a subscription to the events received via the observable sequence (<code class="literal">Subject</code>).</p><p>Let's look at this technique more closely:</p><pre class="programlisting">        public void OnAppear() &#13;
        { &#13;
            _subscriptions = _geolocator.Positions.Subscribe (x =&gt;  &#13;
                { &#13;
                    _currentPosition = x; &#13;
                    LocationUpdates.OnNext(x); &#13;
                }); &#13;
        }  &#13;
 &#13;
 &#13;
 &#13;
        public void OnDisppear() &#13;
        { &#13;
            geolocator.Stop (); &#13;
 &#13;
            if (subscriptions != null)  &#13;
            { &#13;
                subscriptions.Dispose (); &#13;
            } &#13;
        } &#13;
</pre><p>We are going to use these functions to be called when the <code class="literal">MapPage</code> appears and disappears. The <code class="literal">OnAppear</code> function will create a subscription to the <code class="literal">Subject</code>, so whenever a new position is pushed onto the observable sequence, we will receive an item on the other side where we subscribed. In this case, we will be calling the <code class="literal">OnNext</code> function on a different subject, meaning we are passing the item of the observable sequence into another observable sequence.</p><p>What a pointless function. We will show you why soon.</p><p>We are also assigning the subscription to our <code class="literal">IDisposable</code>. A subscription is an unmanaged resource, meaning that without the use of an <code class="literal">IDisposable</code>, we can't control the release of the subscription.</p><p>Why do we need to worry about disposing of the subscription?</p><p>Sometimes our observable streams may be propagating events to a user interface on the main UI thread. If we change pages, and the previous page's view model is still receiving events to update the previous page's interface, this means the events will be changing the user interface on a different thread from the main UI thread, which will break the application. This is just one example, but cleaning up subscriptions when we aren't using them is a good practice to control unwanted application processing.</p><p>Now for the <code class="literal">public</code> properties:</p><pre class="programlisting">#region Public Properties &#13;
 &#13;
        public string Address &#13;
        { &#13;
            get &#13;
            { &#13;
                return address; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(address)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                address = value; &#13;
                OnPropertyChanged("Address"); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>All we need is a string that will be bound to <code class="literal">MapPageLabel</code> under the map item. It will be used to display the address of the current location. Now we must create a label on <code class="literal">MapPage</code>:</p><pre class="programlisting">&lt;Label x:Name="AddressLabel" Text="{Binding Address}" Grid.Row="1" Grid.Column="0"/&gt;  &#13;
</pre><p>Our next step is to make use of the latitude and longitude values that we receive from <code class="literal">CLLocationManager</code>. We are going to use the <code class="literal">Geocoder</code> class to get address information from our positions. A <code class="literal">Geocoder</code> class is used to convert positions (latitudes and longitudes) into address information. We could actually do this conversion on the native side, but the idea of this exercise is to show you what is available in <code class="literal">Xamarin.Forms</code> to share between the different platforms.</p><p>Now let's get back to answering the questions about passing events between two observable sequences.</p><p>Let's start building the <code class="literal">MapPage.xaml.cs</code> sheet:</p><pre class="programlisting">private MapPageViewModel viewModel; &#13;
 &#13;
        private IDisposable locationUpdateSubscriptions; &#13;
 &#13;
        private IDisposable closestSubscriptions; &#13;
 &#13;
        private Geocoder geocoder; &#13;
 &#13;
 &#13;
        public MapPage () &#13;
        { &#13;
            InitializeComponent (); &#13;
        } &#13;
 &#13;
        public MapPage (MapPageViewModel model) &#13;
        { &#13;
            viewModel = model; &#13;
            BindingContext = model; &#13;
            InitializeComponent (); &#13;
 &#13;
            Appearing += handleAppearing; &#13;
            Disappearing += handleDisappearing; &#13;
 &#13;
            geocoder = new Geocoder (); &#13;
        } &#13;
</pre><p>Here we create another two <code class="literal">IDisposables</code> for handling the events from the view-model. We will also be subscribing to and disposing on the page's appearing and disappearing events, so now add the <code class="literal">HandleAppearing</code> and <code class="literal">HandleDisappearing</code> functions:</p><pre class="programlisting">        private void HandleDisappearing (object sender, EventArgs e) &#13;
        { &#13;
            viewModel.OnDisppear (); &#13;
 &#13;
            if (locationUpdateSubscriptions != null)  &#13;
            { &#13;
                locationUpdateSubscriptions.Dispose (); &#13;
            } &#13;
 &#13;
            if (closestSubscriptions != null)  &#13;
            { &#13;
                closestSubscriptions.Dispose (); &#13;
            } &#13;
        } &#13;
 &#13;
        private void HandleAppearing (object sender, EventArgs e) &#13;
        { &#13;
            viewModel.OnAppear (); &#13;
 &#13;
            locationUpdateSubscriptions = viewModel.LocationUpdates.Subscribe (LocationChanged); &#13;
        } &#13;
</pre><p>We also create a new <code class="literal">Geocoder</code>, so every time we receive an event from the observable sequence in the view model, we use this position to retrieve the address information from <code class="literal">Geocoder</code> via the following function:</p><pre class="programlisting">private void LocationChanged (IPosition position) &#13;
        { &#13;
            try  &#13;
            { &#13;
                var formsPosition = new Xamarin.Forms.Maps.Position(position.Latitude, position.Longitude); &#13;
 &#13;
                geocoder.GetAddressesForPositionAsync(formsPosition) &#13;
                        .ContinueWith(_ =&gt; &#13;
                        { &#13;
                            var mostRecent = _.Result.FirstOrDefault(); &#13;
                            if (mostRecent != null) &#13;
                            { &#13;
                                viewModel.Address = mostRecent; &#13;
                            } &#13;
                        }) &#13;
                        .ConfigureAwait(false); &#13;
            } &#13;
            catch (Exception e)  &#13;
            { &#13;
                System.Diagnostics.Debug.WriteLine ("MapPage: Error with moving map region - " + e); &#13;
            } &#13;
        } &#13;
</pre><p>That is everything we need to retrieve our latitude and longitude positions, as well as update the current address. The last step of our iOS version is to update the position on the map; we want the map view to zoom in to our current position and place the blue marker on the map. Next, we add the following to the end of <code class="literal">LocationChanged</code> function:</p><pre class="programlisting">MapView.MoveToRegion (MapSpan.FromCenterAndRadius (formsPosition, Distance.FromMiles (0.3))); &#13;
</pre><p>The <code class="literal">MoveToRegion</code> function requires a <code class="literal">MapSpan</code>; a <code class="literal">MapSpan</code> is created from the latitude, longitude point and the radius from the position point. A circle will be drawn from the point to give the view radius to be shown on the map; in our case the radius is 0.3 miles around the latitude and longitude position.</p><p>The <code class="literal">ContinueWith</code> function is used to execute some extra work as soon as the task finishes. As soon as we have retrieved all the possible address names, we wake the first on the list and assign it to the <code class="literal">Address</code> property of the variable.</p><p>Our final step is to complete the rest of the project; we must first create an iOS module for registering the geolocator class:</p><pre class="programlisting">    public class IOSModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;GeolocatorIOS&gt;().As&lt;IGeolocator&gt;().SingleInstance(); &#13;
        } &#13;
    } &#13;
</pre><p>Then finally we add the extras to the <code class="literal">AppDelegate.cs</code> file (exactly the same as the previous example iOS project):</p><pre class="programlisting">[Register ("AppDelegate")] &#13;
    public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate &#13;
    { &#13;
        public override bool FinishedLaunching (UIApplication app, NSDictionary options) &#13;
        { &#13;
            global::Xamarin.Forms.Forms.Init (this, bundle); &#13;
            global::Xamarin.FormsMaps.Init (this, bundle); &#13;
 &#13;
            initIoC (); &#13;
 &#13;
            LoadApplication (new App ()); &#13;
 &#13;
            return base.FinishedLaunching (app, options); &#13;
        } &#13;
 &#13;
        private void initIoC() &#13;
        { &#13;
            IoC.CreateContainer (); &#13;
            IoC.RegisterModule (new IOSModule()); &#13;
            IoC.RegisterModule (new XamFormsModule()); &#13;
            IoC.RegisterModule (new PortableModule()); &#13;
            IoC.StartContainer (); &#13;
        } &#13;
    } &#13;
</pre><p>Excellent! Let's run the project and click on the <span class="strong"><strong>Find Location</strong></span> button. Watch the map update with the address shown in the preceding label.</p><p>Let's move on to the Android project and implement the same features.</p><div class="section" title="Android and the LocationManager"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Android and the LocationManager</h2></div></div></div><p>The Android <code class="literal">LocationManager</code> works like the <code class="literal">CLLocationManager</code>, but we will use an observable sequence to handle location updates. When a location update is received, a new Position object is instantiated with the latitude and longitude values from the location update. Then the resulting Position is pushed on to the Geolocator's Subject.</p><p>First we create the <code class="literal">Geolocator</code> implementation. It must also inherit the <code class="literal">ILocationListener</code> interface:</p><pre class="programlisting">public class GeolocatorDroid : IGeolocator, ILocationListener &#13;
    { &#13;
        private string provider = string.Empty; &#13;
 &#13;
        public Subject&lt;IPosition&gt; Positions { get; set; } &#13;
 &#13;
        #region ILocationListener implementation &#13;
 &#13;
        public void OnLocationChanged (Location location) &#13;
        { &#13;
            Positions.OnNext (new Position ()  &#13;
                { &#13;
                    Latitude = location.Latitude, &#13;
                    Longitude = location.Longitude &#13;
                }); &#13;
        } &#13;
 &#13;
        public void OnProviderDisabled (string provider) &#13;
        { &#13;
            Console.WriteLine (provider + " disabled by user"); &#13;
        } &#13;
 &#13;
        public void OnProviderEnabled (string provider) &#13;
        { &#13;
            Console.WriteLine (provider + " disabled by user"); &#13;
        } &#13;
 &#13;
        public void OnStatusChanged (string provider, Availability status, Bundle extras) &#13;
        { &#13;
            Console.WriteLine (provider + " disabled by user"); &#13;
        } &#13;
 &#13;
        #endregion &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>You may have noticed the <code class="literal">#define</code> keywords. These are useful for separating different sections and for referencing locations in code sheets, making code more readable.</p></div></div><p>The only one we are concerned about is the <code class="literal">OnLocationChanged</code> function; whenever a location update is received by the location manager, the listener function will be called with the latitude and longitude values, and we will then use these values to push into the observable sequence for the <code class="literal">Geocoder</code> and <code class="literal">MapSpan</code>.</p><p>We also have to implement the extra requirements for the <code class="literal">ILocationListener</code> interface. Since this interface inherits the <code class="literal">IJavaObject</code> interface, we are required to implement the <code class="literal">Dispose</code> function and the <code class="literal">IntPtr </code>object.</p><p>To save time, we can have the class inherit the <code class="literal">Java.Lang.Object</code> class like this:</p><pre class="programlisting">public class GeolocatorDroid : Object, IGeolocator, ILocationListener &#13;
</pre><p>Next, we add the constructor:</p><pre class="programlisting">private LocationManager locationManager; &#13;
 &#13;
        public GeolocatorDroid() &#13;
        { &#13;
            Positions = new Subject&lt;IPosition&gt; (); &#13;
         &#13;
            locationManager = (LocationManager)Application.Context.GetSystemService(Context.LocationService); &#13;
            provider = LocationManager.NetworkProvider; &#13;
        } &#13;
</pre><p>In the constructor, we pull out the required system service using the <code class="literal">GetSystemService</code> function for the location service. The line underneath simply retrieves the <code class="literal">NetworkProvider</code> of the <code class="literal">LocationManager</code>; we need to use this for starting the location updates. There are further configurations we can set for retrieving correct providers (mainly logging purposes), but in this example we aren't going to bother too much as we are only interested in retrieving location positions.</p><p>Now it's time to implement the other required functions of the <code class="literal">IGeolocator</code> interface:</p><pre class="programlisting">public void Start() &#13;
        { &#13;
            if (locationManager.IsProviderEnabled(provider)) &#13;
            { &#13;
                locationManager.RequestLocationUpdates (provider, 2000, 1, this); &#13;
            } &#13;
            else &#13;
            { &#13;
                Console.WriteLine(provider + " is not available. Does the device have location services enabled?"); &#13;
            } &#13;
        } &#13;
             &#13;
        public void Stop() &#13;
        { &#13;
            locationManager.RemoveUpdates (this); &#13;
        } &#13;
</pre><p>The <code class="literal">Start</code> function will first check whether we have these services enabled, then by calling the <code class="literal">RequestLocationUpdates</code> function, we pass in the provider, the minimum time between locations updates, the minimum location distance between updates, and the pending intent to be called on each location update; in our case, this is the geolocator (the same class that started the location updates) as we have implemented the <code class="literal">ILocationListener</code> class.</p><p>The <code class="literal">Stop</code> function simply removes the updates from the <code class="literal">Geolocator</code>, which in turn will stop the location updates from the location manager. Our next step in implementing the Android <code class="literal">Geolocator</code> is to create the Android IoC module, and register this implementation in the IoC container:</p><pre class="programlisting">        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;GeolocatorDroid&gt;().As&lt;IGeolocator&gt;().SingleInstance(); &#13;
        } &#13;
</pre><p>Our final step is to set up the <code class="literal">MainActivity</code> class, which is exactly the same as the previous project:</p><pre class="programlisting">[Activity (Label = "Locator.Droid", Icon = "@drawable/icon", MainLauncher = true, ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)] &#13;
    public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsApplicationActivity &#13;
    { &#13;
        protected override void OnCreate (Bundle bundle) &#13;
        { &#13;
            base.OnCreate (bundle); &#13;
 &#13;
            global::Xamarin.Forms.Forms.Init (this, bundle); &#13;
            global::Xamarin.FormsMaps.Init (this, bundle); &#13;
 &#13;
            LoadApplication (new App ()); &#13;
        } &#13;
 &#13;
        private void initIoC() &#13;
        { &#13;
            IoC.CreateContainer (); &#13;
            IoC.RegisterModule (new DroidModule()); &#13;
            IoC.RegisterModule (new XamFormsModule()); &#13;
            IoC.RegisterModule (new PortableModule()); &#13;
            IoC.StartContainer (); &#13;
        } &#13;
    } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>Take note of how much code we are starting to reuse from previous projects. Why reinvent the wheel when we can save a lot of time by pulling from similar problems that have already been solved in other projects?</p></div></div><p>The last step in the Android project is to apply some Android permissions to allow your app to use location services. Open up the <code class="literal">Mainfest.xml</code> and add the following:</p><pre class="programlisting">        &lt;application android:label="Locator"&gt; &#13;
        &lt;meta-data android:name="com.google.android.maps.v2.API_KEY" android:value="YOUR-API-KEY" /&gt; &#13;
        &lt;meta-data android:name="com.google.android.gms.version" android:value="@integer/google_play_services_version" /&gt; &#13;
    &lt;/application&gt; &#13;
 &#13;
    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &#13;
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &#13;
    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;  &#13;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &#13;
</pre><p>Inside the <code class="literal">&lt;application&gt;</code> tag, we have to place <code class="literal">API_KEY</code>, which is generated from the Google APIs platform (we will be doing this later). We then have to add the <code class="literal">ACCESS_FINE_LOCATION</code>, <code class="literal">ACCESS_COARSE_LOCATION</code>, and <code class="literal">ACCESS_NETWORK_STATE</code> permissions for <span class="strong"><strong>LocationManager</strong></span> to work. We can switch these permissions on through the <span class="strong"><strong>Application</strong></span> window:</p><div class="mediaobject"><img src="graphics/B05293_03_05.jpg" alt="Android and the LocationManager"/></div></div><div class="section" title="Creating an exit point"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Creating an exit point</h2></div></div></div><p>You may have noticed the extra button added on the starting page for exiting the application. We will have to go ahead and create an abstracted object for exiting the application. Start by creating a new folder called <code class="literal">Extras</code>, then create a new file for the <code class="literal">IMethods</code> interface:</p><pre class="programlisting">    public interface IMethods &#13;
    { &#13;
        void Exit(); &#13;
    } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>Before moving on with the tutorial, have a go at implementing the native side for each project on your own.</p></div></div><p>Let's begin with the iOS version:</p><pre class="programlisting">    public class IOSMethods &#13;
    { &#13;
        public void Exit() &#13;
        { &#13;
            UIApplication.SharedApplication.PerformSelector(new ObjCRuntime.Selector("terminateWithSuccess"), null, 0f); &#13;
        } &#13;
    } &#13;
</pre><p>For the iOS version, we must dig into the <code class="literal">SharedApplication</code> object and perform a selector method <code class="literal">terminateWithSuccess</code>. We must then register this new object in our iOS module:</p><pre class="programlisting">         &#13;
public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;GeolocatorIOS&gt;().As&lt;IGeolocator&gt;().SingleInstance(); &#13;
            builer.RegisterType&lt;IOSMethods&gt;().As&lt;IMethods&gt;().SingleInstance(); &#13;
        } &#13;
</pre><p>Now the Android implementation:</p><pre class="programlisting">    &#13;
 public class DroidMethods &#13;
    { &#13;
        public void Exit() &#13;
        { &#13;
            Android.OS.Process.KillProcess(Android.OS.Process.MyPid()); &#13;
        } &#13;
    } &#13;
</pre><p>Using the Android operating system namespace, we use the static item <code class="literal">Process</code> to call the function <code class="literal">KillProcess</code> on the main process. Again, we also register this within the IoC container:</p><pre class="programlisting">public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;GeolocatorDroid&gt;().As&lt;IGeolocator&gt;().SingleInstance(); &#13;
            builer.RegisterType&lt;DroidMethods&gt;().As&lt;IMethods&gt;().SingleInstance(); &#13;
        } &#13;
</pre><p>Finally, we use the <code class="literal">IMethods</code> interface in our <code class="literal">MainPageViewModel</code> to call the exit function:</p><pre class="programlisting">public MainPageViewModel (INavigationService navigation, Func&lt;Action, ICommand&gt; commandFactory, &#13;
            IMethods methods) : base (navigation) &#13;
        { &#13;
            exitCommand = commandFactory (() =&gt; methods.Exit()); &#13;
            locationCommand = commandFactory (() =&gt; Navigation.Navigate(PageNames.MapPage)); &#13;
        } &#13;
</pre><p>Looking at this more closely, we are using the command factory to initialize the exit command to a new <code class="literal">Xamarin.Forms Command</code>, and when this command is executed, it will call the <code class="literal">Exit</code> method from the <code class="literal">IMethods</code> interface.</p><p>Our last step is to create an API key using the Google APIs for our Android version.</p></div><div class="section" title="Creating an API key for Android"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Creating an API key for Android</h2></div></div></div><p>In order for us to create an API key, we will have to access the Google API portal. Android requires this extra step when configuring Google Maps:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>You will need a Google Developer account to complete this section.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Visit the following link to create a new project in the API portal: <a class="ulink" href="https://console.developers.google.com/iam-admin/projects">https://console.developers.google.com/iam-admin/projects</a>.<div class="mediaobject"><img src="graphics/B05293_03_06.jpg" alt="Creating an API key for Android"/></div></li><li class="listitem">Select <span class="strong"><strong>Create Project</strong></span> from the top menu and call the project <code class="literal">Locator</code>:<div class="mediaobject"><img src="graphics/B05293_03_07.jpg" alt="Creating an API key for Android"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>For more information on setting up an API key, visit this link: <a class="ulink" href="https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key">https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key</a>.</p></div></div></li><li class="listitem">Once we have our new project, visit the API Manager and select the <span class="strong"><strong>Google Maps Android API</strong></span>:<div class="mediaobject"><img src="graphics/B05293_03_08.jpg" alt="Creating an API key for Android"/></div></li><li class="listitem">Select the <span class="strong"><strong>Enable</strong></span> button, then click <span class="strong"><strong>Credentials</strong></span> from the left-hand menu. We want to create a new <span class="strong"><strong>API key</strong></span> from the drop-down list:<div class="mediaobject"><img src="graphics/B05293_03_09.jpg" alt="Creating an API key for Android"/></div></li><li class="listitem">Make sure we select an <span class="strong"><strong>Android key</strong></span>:<div class="mediaobject"><img src="graphics/B05293_03_10.jpg" alt="Creating an API key for Android"/></div></li><li class="listitem">We are going to leave the name as <code class="literal">Android key 1</code>. Now click the <span class="strong"><strong>Create</strong></span> button:<div class="mediaobject"><img src="graphics/B05293_03_11.jpg" alt="Creating an API key for Android"/></div></li><li class="listitem">Finally, let's select our Android key and place it in the <code class="literal">AndroidManifest.xml</code> file where it states <code class="literal">YOUR-API-KEY</code>:<div class="mediaobject"><img src="graphics/B05293_03_12.jpg" alt="Creating an API key for Android"/></div></li></ol></div><p>Congratulations, we have now integrated the iOS and Android location services with Google Maps.</p><p>Now let's move on to the Windows Phone version.</p></div><div class="section" title="Creating our Windows project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Creating our Windows project</h2></div></div></div><p>Moving on to Visual Studio once again, let start by creating a new c-shape universal Windows project and calling it <code class="literal">Locator.WinRT</code>:</p><div class="mediaobject"><img src="graphics/B05293_03_13.jpg" alt="Creating our Windows project"/></div><p>We can remove the Windows store and shared projects. Before you remove the shared projects, move the <code class="literal">app.xaml</code> files into the Windows Phone project.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>The <code class="literal">Map</code> object from <code class="literal">Xamarin.Forms.Maps</code> is not usable in Windows Phone 8.1. We have to use the universal platform instead.</p></div></div><p>For our Windows Phone version, we need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Windows Phone module for registering the geolocator and methods interfaces</li><li class="listitem" style="list-style-type: disc">To implement the geolocator interface</li><li class="listitem" style="list-style-type: disc">To implement the methods interface</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Have a think about that for a second...</p><p><span class="strong"><strong>That's all we have to do to replicate the application for Windows Phone?</strong></span> Think how much extra work would be involved if we were to rebuild this app from scratch entirely on the Windows platform.</p></div></div><p>Next, add the three folders, <code class="literal">Modules</code>, <code class="literal">Location</code>, and <code class="literal">Extras</code>, and create a new <code class="literal">.cs</code> file for each folder and name them accordingly: <code class="literal">WinPhoneModule.cs</code>, <code class="literal">GeolocatorWinPhone.cs</code>, and <code class="literal">WinPhoneMethods.cs</code>.</p><p>Firstly, we have to change the targets of the PCL projects to be compatible with the Windows Phone frameworks. Select the <span class="strong"><strong>Windows Phone 8.1</strong></span> target for both PCL projects, then the Windows project can reference the two PCL projects:</p><div class="mediaobject"><img src="graphics/B05293_03_14.jpg" alt="Creating our Windows project"/></div><p>We must also import the <code class="literal">Xamarin.Forms</code>, <code class="literal">Xamarin.Forms.Maps</code>, and <code class="literal">Autofacnuget</code> packages.</p></div><div class="section" title="Core Location Services with Windows Phone"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Core Location Services with Windows Phone</h2></div></div></div><p>Now for the exciting part. Let's integrate the core location services. First, we must turn on certain permissions. Open up the <code class="literal">package.appmanifest</code> file, select the <span class="strong"><strong>Capabilities</strong></span> tab, and select the <span class="strong"><strong>Location</strong></span> checkbox:</p><div class="mediaobject"><img src="graphics/B05293_03_15.jpg" alt="Core Location Services with Windows Phone"/></div><p>Secondly, open the <code class="literal">GeolocatorWinPhone.cs</code> file, and let's start building the Windows Phone locator class.</p><p>Let's start by creating the constructor:</p><pre class="programlisting">public class GeolocatorWinPhone : IGeolocator &#13;
        { &#13;
            public Subject&lt;IPosition&gt; Positions { get; set; } &#13;
 &#13;
            Geolocator _geolocator; &#13;
 &#13;
            public GeolocatorWinPhone() &#13;
            { &#13;
                Positions = new Subject&lt;IPosition&gt;(); &#13;
 &#13;
                geolocator = new Geolocator(); &#13;
                _geolocator.DesiredAccuracyInMeters = 50; &#13;
            } &#13;
        } &#13;
</pre><p>We are implementing a native <code class="literal">Geolocator</code> from the interface <code class="literal">IGeolocator</code>, meaning we need to create an observable sequence for the positions. We also need a <code class="literal">Geolocator</code> object to receive location updates, which we will use to push events into the sequence. With all native locators, we can set accuracy for location points, which is what we are doing with the following line:</p><pre class="programlisting">geolocator.DesiredAccuracyInMeters = 50; &#13;
</pre><p>Our next step is to implement the <code class="literal">Start</code> and <code class="literal">Stop</code> functions:</p><pre class="programlisting">public async void Start() &#13;
        { &#13;
            try &#13;
            { &#13;
               var geoposition = await _geolocator.GetGeopositionAsync( &#13;
                    maximumAge: TimeSpan.FromMinutes(5), &#13;
                    timeout: TimeSpan.FromSeconds(10) &#13;
                ); &#13;
 &#13;
                _geolocator.PositionChanged += geolocatorPositionChanged; &#13;
 &#13;
                // push a new position into the sequence &#13;
                Positions.OnNext(new Position() &#13;
                    { &#13;
                        Latitude = geoposition.Coordinate.Latitude, &#13;
                        Longitude = geoposition.Coordinate.Longitude &#13;
                    }); &#13;
            } &#13;
            catch (Exception ex) &#13;
            { &#13;
                Console.WriteLine("Error retrieving geoposition - " + ex); &#13;
            } &#13;
 &#13;
        } &#13;
</pre><p>The <code class="literal">Start</code> function uses <code class="literal">Geolocator</code> to retrieve the positions with the asynchronous function <code class="literal">GetGeopositionAsync</code>. The function will take the maximum age of a location, meaning once the time period is passed, the location will update again. The request for this location will cancel when the timeout value is reached during a location update. We also listen on the event handler <code class="literal">PositionChanged</code> via the following function:</p><pre class="programlisting">        private void GeolocatorPositionChanged(Geolocator sender, PositionChangedEventArgs args) &#13;
        { &#13;
            // push a new position into the sequence &#13;
            Positions.OnNext(new Position () &#13;
                { &#13;
                    Latitude = args.Position.Coordinate.Latitude, &#13;
                    Longitude = args.Position.geoposition.Coordinate.Longitude &#13;
                }); &#13;
        } &#13;
</pre><p>We actually have two places, which will push a new geoposition's latitude and longitude into the observable sequence.</p><p>Now we add the <code class="literal">Stop</code> function:</p><pre class="programlisting">        public void Stop() &#13;
        { &#13;
            // remove event handler &#13;
            _geolocator.PositionChanged -= GeolocatorPositionChanged; &#13;
        } &#13;
</pre><p>All this does is remove the event handler function that we assigned in the <code class="literal">Start</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>You should be noticing the development patterns with this project, how we implement abstracted interfaces, generate modules, register types, and so on. The processes are all the same, no matter what platform.</p></div></div><p>That's all for the <code class="literal">Geolocator</code> class; we can now get on to the <code class="literal">WinPhoneModule</code>:</p><pre class="programlisting">    public class WinPhoneModule : IModule &#13;
    { &#13;
        public void Register(ContainerBuilder builer) &#13;
        { &#13;
            builer.RegisterType&lt;GeolocatorWinPhone&gt;().As&lt;IGeolocator&gt;().SingleInstance(); &#13;
            builer.RegisterType&lt;WinPhoneMethods&gt;().As&lt; IMethods&gt;().SingleInstance(); &#13;
        } &#13;
    } &#13;
</pre><p>Now let's get to the <code class="literal">WinPhoneMethods</code> class. We only need to implement the one function, <code class="literal">Exit</code>.</p></div><div class="section" title="The Application class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>The Application class</h2></div></div></div><p>The static class <code class="literal">Application</code> plays a similar role to the iOS <code class="literal">UIApplication</code> class. We simply reference the current application, and terminate:</p><pre class="programlisting"> public class WinPhoneMethods : IMethods &#13;
        { &#13;
            public void Exit() &#13;
            { &#13;
                Application.Current.Terminate(); &#13;
            } &#13;
        } &#13;
</pre><p>Now we simply build the remaining elements with the <code class="literal">MainPage.xaml</code> page:</p><pre class="programlisting">&lt;forms:WindowsPhonePage &#13;
    x:Class="Locator.WinPhone.MainPage" &#13;
     &#13;
     &#13;
     &#13;
     &#13;
     &#13;
     &#13;
    mc:Ignorable="d" &#13;
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt; &#13;
&lt;/forms:WindowsPhonePage&gt; &#13;
</pre><p>And we do it for the <code class="literal">MainPage.xaml.cs</code> file:</p><pre class="programlisting">public MainPage() &#13;
    { &#13;
        InitializeComponent(); &#13;
 &#13;
        InitIoC(); &#13;
 &#13;
        NavigationCacheMode = NavigationCacheMode.Required; &#13;
        LoadApplication(new Locator.App()); &#13;
    } &#13;
 &#13;
    private void InitIoC() &#13;
    { &#13;
        IoC.CreateContainer(); &#13;
            IoC.RegisterModule(new WinPhoneModule()); &#13;
            IoC.RegisterModule(new SharedModule(true)); &#13;
            IoC.RegisterModule(new XamFormsModule()); &#13;
            IoC.RegisterModule(new PortableModule()); &#13;
            IoC.StartContainer(); &#13;
 &#13;
    } &#13;
</pre><p>Exactly the same as the previous chapter, we are starting the <code class="literal">IoC</code> container, adding our modules, and loading the <code class="literal">Xamarin.Forms.App</code> object. The only difference is the <code class="literal">SharedModule</code>, as we pass in true so the <code class="literal">NativeMessageHandler</code> is used.</p><p>Finally, we have one more issue to address. Since <code class="literal">Xamarin.Forms</code> 1.5, only Windows Phone Silverlight is supported for using Google Maps. We have to add an additional library to use maps in Windows Phone 8.1.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Personal thanks to <span class="emphasis"><em>Peter Foot</em></span> for addressing this issue.</p></div></div><p>Luckily, an open source library is available to address this issue. We must install the nuget package <code class="literal">InTheHand.Forms.Maps</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>This library is only available up to <code class="literal">Xamarin.Forms</code> 2.1.0.6529, meaning this entire example must stick to this version of <code class="literal">Xamarin.Forms</code>.</p></div></div><p>Then, inside <code class="literal">App.xaml.cs</code>, we need to initialize <code class="literal">Xamarin.Forms</code> and <code class="literal">Xamarin.Forms.Maps</code>. The <code class="literal">Xamarin.Forms.Maps</code> framework is initialized through the library <code class="literal">InTheHand.Forms.Maps</code> like this:</p><pre class="programlisting">if (rootFrame == null) &#13;
        { &#13;
            rootFrame = new Frame(); &#13;
 &#13;
            rootFrame.CacheSize = 1; &#13;
 &#13;
            if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) &#13;
            { &#13;
            } &#13;
 &#13;
            Xamarin.Forms.Forms.Init(e); &#13;
            InTheHand.FormsMaps.Init("YOUR-API-KEY"); &#13;
 &#13;
            Window.Current.Content = rootFrame; &#13;
        } &#13;
</pre><p>Just like that, we now have the application on Windows Phone. Now that we have core location services running with Google Maps, let's take things one step further with the Google API platforms.</p></div><div class="section" title="Web services and data contracts"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Web services and data contracts</h2></div></div></div><p>We are now going to look at creating a web service controller to access web services provided by Google. These are useful implementations for downloading JSON data, deserializing it, and feeding this data in observable sequences for processing. With a web service controller, we get to use more of the <code class="literal">IObservable</code> interface. These sequences will be used to take in deserialized JSON objects from a web source, and feed these into our view models.</p><p>Our web service controller will be kept inside the <span class="strong"><strong>Locator.Portable</strong></span> project. Remember, we can share this work across the different platforms as all use some form of HTTP client to connect to a web URL.</p></div><div class="section" title="What about data contracts?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>What about data contracts?</h2></div></div></div><p>Your data contract is a JSON object that is used to absorb the elements of the deserialized objects, so whenever we pull down raw JSON data, your contract will be the deserialized object or objects.</p><p>So the next question is, what data are we pulling to our application?</p><p>We are going to use the Google <code class="literal">Geocoder</code> API to turn address information into latitude and longitude positions. We are going to pull down a list of addresses, calculate their latitude and longitude positions, calculate the closest address to our current position, and place a pin on the map.</p><p>Our first step is to create a new folder called <code class="literal">WebServices</code> in <code class="literal">Locator.Portable</code>. Inside this folder, we want to create another folder called <code class="literal">GeocodingWebServiceController</code>, and another folder inside this called <code class="literal">Contracts</code>. Let's first implement our contracts. A nice quick easy way to implement your JSON objects is to use an online application like this one: <a class="ulink" href="http://json2csharp.com/">http://json2csharp.com/</a>.</p><p>When we are pulling down JSON data, it takes time to look through the text and find all the properties required for your JSON object. This provides a nice way is to call the web service URL, retrieve some sample JSON data, and paste this JSON data into the box here:</p><div class="mediaobject"><img src="graphics/B05293_03_16.jpg" alt="What about data contracts?"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>Personal thanks to <span class="strong"><strong>Jonathan Keith</strong></span> for saving us time.</p></div></div><p>This application creates c-sharp JSON objects based on the JSON data you entered. Now let's get our sample JSON data to paste in the box, but before we can do this we have to access the <span class="strong"><strong>Google API</strong></span>.</p></div><div class="section" title="Creating another API key for geocoding"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Creating another API key for geocoding</h2></div></div></div><p>Log back in to the Google Developer console, and our first step is to enable to the Geocoding API from the API manager:</p><div class="mediaobject"><img src="graphics/B05293_03_17-1.jpg" alt="Creating another API key for geocoding"/></div><p>We then select the project <code class="literal">Locator</code> we created earlier, and this time we are going to create a browser key to access the Geocoding API via HTTP requests:</p><div class="mediaobject"><img src="graphics/B05293_03_18-1.jpg" alt="Creating another API key for geocoding"/></div><p>Call the key <code class="literal">Geocoding Key</code> and click <span class="strong"><strong>Create</strong></span>. We are now going to use this key for every HTTP request passed to the Geocoding API:</p><div class="mediaobject"><img src="graphics/B05293_03_19-1.jpg" alt="Creating another API key for geocoding"/></div></div><div class="section" title="Creating GeocodingWebServiceController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Creating GeocodingWebServiceController</h2></div></div></div><p>Our first step creating <code class="literal">GeocodingWebServiceController</code> is to hit the web URL using your API key to pull down some sample JSON data; here is a test link: <code class="literal">https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY</code>.</p><p>Where it says <code class="literal">YOUR_API_KEY</code>, replace this text with your newly created API key, and then paste this link into the browser. You should get JSON results like this:</p><pre class="programlisting">{ &#13;
   "results" : [ &#13;
      { &#13;
         "address_components" : [ &#13;
            { &#13;
               "long_name" : "1600", &#13;
               "short_name" : "1600", &#13;
               "types" : [ "street_number" ] &#13;
            }, &#13;
            { &#13;
               "long_name" : "Amphitheatre Parkway", &#13;
               "short_name" : "Amphitheatre Pkwy", &#13;
               "types" : [ "route" ] &#13;
            }, &#13;
            { &#13;
               "long_name" : "Mountain View", &#13;
               "short_name" : "Mountain View", &#13;
               "types" : [ "locality", "political" ] &#13;
            }, &#13;
            { &#13;
               "long_name" : "Santa Clara County", &#13;
               "short_name" : "Santa Clara County", &#13;
               "types" : [ "administrative_area_level_2", "political" ] &#13;
            }, &#13;
</pre><p>We are going to copy and paste the entire resulting JSON into <span class="strong"><strong>Json2Sharp</strong></span> to create our c-sharp objects:</p><div class="mediaobject"><img src="graphics/B05293_03_20.jpg" alt="Creating GeocodingWebServiceController"/></div><p>There are quite a few JSON objects, so in the <code class="literal">Contracts</code> folder, create the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">AddressComponentContract.cs</li><li class="listitem" style="list-style-type: disc">GeocodingContract.cs</li><li class="listitem" style="list-style-type: disc">GeocodingResultContract.cs</li><li class="listitem" style="list-style-type: disc">GeometryContract.cs</li><li class="listitem" style="list-style-type: disc">LocationContract.cs</li><li class="listitem" style="list-style-type: disc">NortheastContract.cs</li><li class="listitem" style="list-style-type: disc">SouthwestContract.cs</li><li class="listitem" style="list-style-type: disc">ViewportContract.cs</li></ul></div><p>Let's begin with <code class="literal">AddressComponentContract.cs</code>:</p><pre class="programlisting">public sealed class AddressComponentContract &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public string long_name { get; set; } &#13;
 &#13;
        public string short_name { get; set; } &#13;
 &#13;
        public List&lt;string&gt; types { get; set; } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Make sure we keep all these contracts in the namespace <code class="literal">Locator.Portable.GeocodingWebServiceController.Contracts</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Namespaces should be named according to the folder hierarchy.</p></div></div><p>Now for the <code class="literal">GeocodingContract</code>:</p><pre class="programlisting">    public sealed class GeocodingContract &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public List&lt;GeocodingResultContract&gt; results { get; set; } &#13;
 &#13;
        public string status { get; set; } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>The rest of the files are exactly the same; we simply copy the c-sharp objects created by <span class="strong"><strong>Json2Sharp</strong></span>. Now it's time to complete the others:</p><pre class="programlisting">    public sealed class GeocodingResultContract &#13;
    { &#13;
        #region Public Properties &#13;
 &#13;
        public List&lt;AddressComponentContract&gt; address_components { get; set; } &#13;
 &#13;
        public string formatted_address { get; set; } &#13;
 &#13;
        public GeometryContract geometry { get; set; } &#13;
 &#13;
        public string place_id { get; set; } &#13;
 &#13;
        public List&lt;string&gt; types { get; set; } &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>Make sure you double-check the property names are exactly the same as the JSON properties, otherwise the values inside the JSON string will not be deserialized correctly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>We are not going to paste in every contract, as this should be enough direction for you to build the others.</p></div></div><p>Now that we have our geocoding contracts, let's create the interface for the <code class="literal">GeocodingWebServiceController</code>:</p><pre class="programlisting">public interface IGeocodingWebServiceController &#13;
    { &#13;
        #region Methods and Operators &#13;
 &#13;
        IObservable&lt;GeocodingContract&gt; GetGeocodeFromAddressAsync (string address, string city, string state); &#13;
 &#13;
        #endregion &#13;
    } &#13;
</pre><p>This is only a small interface; we only have one function, <code class="literal">GetGeocodeFromAddressAsync</code>. The function requires three arguments to build the parameters in the web URL.</p><p>Now let's implement this interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>A good practice with object-oriented and abstract coding is to declare interfaces before implementing the class which coincides; it will help you build the class quicker.</p></div></div></div><div class="section" title="Newtonsoft.Json and Microsoft HTTP client libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Newtonsoft.Json and Microsoft HTTP client libraries</h2></div></div></div><p>As we are going to be deserializing JSON, we will need to import a JSON framework library. Newtonsoft is one of the most commonly used frameworks, so let's import this library into our <span class="strong"><strong>Locator.Portable</strong></span> project:</p><div class="mediaobject"><img src="graphics/B05293_03_21.jpg" alt="Newtonsoft.Json and Microsoft HTTP client libraries"/></div><p>We will also need to import the HTTP client libraries for our web service controller to access online web services:</p><div class="mediaobject"><img src="graphics/B05293_03_22.jpg" alt="Newtonsoft.Json and Microsoft HTTP client libraries"/></div><p>Now that we have all the extra libraries for our <span class="strong"><strong>Locator.Portable</strong></span> project, before we implement the <code class="literal">IGeocodingWebServiceController</code>, we have to make some additions to the project structure:</p><div class="mediaobject"><img src="graphics/B05293_03_23.jpg" alt="Newtonsoft.Json and Microsoft HTTP client libraries"/></div><p>Right-click on the <span class="strong"><strong>Locator</strong></span> and create a new shared project called <span class="strong"><strong>Locator.Shared</strong></span>:</p><div class="mediaobject"><img src="graphics/B05293_03_24.jpg" alt="Newtonsoft.Json and Microsoft HTTP client libraries"/></div></div><div class="section" title="ModernHttpClient and client message handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>ModernHttpClient and client message handlers</h2></div></div></div><p>In this project, we will be creating a shared module to register a <code class="literal">HttpClientHandler</code> class in the IoC container. <code class="literal">HttpClientHandler</code> is a message handler class that receives a HTTP request and returns a HTTP response. Message handlers are used on both the client and server side for handling/delegating requests between different end points.</p><p>In our example, we are interested in the client side, as we are calling the server; our client handler will be used to handle our HTTP messages sent from the HTTP client.</p><p>Let's begin by adding the <code class="literal">ModernHttpClient</code> library to our <span class="strong"><strong>Locator</strong></span> (we will refer to this project as the <code class="literal">Xamarin.Forms</code> project) and all native projects:</p><div class="mediaobject"><img src="graphics/B05293_03_25.jpg" alt="ModernHttpClient and client message handlers"/></div><p>We also want to add the Microsoft Client Libraries package to all native projects.</p><p>In our shared project, remember we can't import libraries; these projects are only used to share code sheets. In this project, we want to create a folder called <code class="literal">Modules</code>. In the <code class="literal">Modules</code> folder, create a new file called <code class="literal">SharedModule.cs</code> and implement the following:</p><pre class="programlisting">public sealed class SharedModule : IModule &#13;
    { &#13;
        #region Fields &#13;
 &#13;
        private bool isWindows; &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Constructors and Destructors &#13;
 &#13;
        public SharedModule(bool isWindows) &#13;
        { &#13;
            isWindows = isWindows; &#13;
        } &#13;
 &#13;
        #endregion &#13;
 &#13;
        #region Public Methods and Operators &#13;
 &#13;
        public void Register(ContainerBuilder builder) &#13;
        { &#13;
            HttpClientHandler clientHandler = isWindows ? new HttpClientHandler() : new NativeMessageHandler(); &#13;
            clientHandler.UseCookies = false; &#13;
            clientHandler.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip; &#13;
            builder.Register(cb =&gt; clientHandler).As&lt;HttpClientHandler&gt;().SingleInstance(); &#13;
        } &#13;
             &#13;
        #endregion &#13;
    } &#13;
</pre><p>One thing to notice is the minor change we have to make between the iOS and Android projects, and the Windows Phone project. Windows must use <code class="literal">NativeMessageHandler</code> for the <code class="literal">HttpClientHandler</code> in the IoC container. In iOS and Android, we can use a default <code class="literal">HttpClientHandler</code>.</p><p>We tell the client handler that we not going to be using cookies, and we allow for automatic decompression on the data being pulled through the client handler (<span class="strong"><strong>GZIP</strong></span> is a common form of JSON data compression).</p><p>Now let's focus our attention on the constructor. We simply pass in a <code class="literal">bool</code> to determine whether we are using Windows to register the correct type of message handler for the current platform.</p><p>Now let's add this module to the registration in the <code class="literal">AppDelegate</code> and <code class="literal">MainActivity</code> file; it must be called before the <code class="literal">LoadApplication</code> function:</p><pre class="programlisting">private void InitIoC() &#13;
        { &#13;
            IoC.CreateContainer (); &#13;
            IoC.RegisterModule (new IOSModule()); &#13;
            IoC.RegisterModule (new SharedModule(false)); &#13;
            IoC.RegisterModule (new XamFormsModule()); &#13;
            IoC.RegisterModule (new PortableModule()); &#13;
            IoC.StartContainer (); &#13;
        } &#13;
</pre><p>Excellent! We now have access to our HTTP client handler in the IoC container, so let's start building the <code class="literal">GeocodingWebServiceController</code> class:</p><pre class="programlisting">public sealed class GeocodingWebServiceController : IGeocodingWebServiceController &#13;
    { &#13;
        #region Fields &#13;
 &#13;
        /// &lt;summary&gt; &#13;
        /// The client handler. &#13;
        /// &lt;/summary&gt; &#13;
        private readonly HttpClientHandler clientHandler; &#13;
 &#13;
        #endregion &#13;
 &#13;
         &#13;
 &#13;
#region Constructors and Destructors &#13;
 &#13;
        public GeocodingWebServiceController (HttpClientHandler clientHandler) &#13;
        { &#13;
            clientHandler = clientHandler; &#13;
        } &#13;
 &#13;
        #endregion  &#13;
 &#13;
     } &#13;
</pre></div><div class="section" title="Feeding JSON data into the IObservable framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Feeding JSON data into the IObservable framework</h2></div></div></div><p>As we are going to be registering this web service controller in the IoC container, we can pull out the client handler we just created and registered in the <code class="literal">SharedModule</code> class. Now we must implement the function we defined in the interface:</p><pre class="programlisting">#region Public Methods  &#13;
 &#13;
        public IObservable&lt;GeocodingContract&gt; GetGeocodeFromAddressAsync(string address, string city, string state) &#13;
        { &#13;
            var authClient = new HttpClient(_clientHandler); &#13;
 &#13;
            var message = new HttpRequestMessage(HttpMethod.Get, new Uri(string.Format(ApiConfig.GoogleMapsUrl, address, city, state))); &#13;
 &#13;
            return Observable.FromAsync(() =&gt; authClient.SendAsync(message, new CancellationToken(false))) &#13;
                .SelectMany(async response =&gt; &#13;
                    { &#13;
                        if (response.StatusCode != HttpStatusCode.OK) &#13;
                        { &#13;
                            throw new Exception("Respone error"); &#13;
                        } &#13;
 &#13;
                        return await response.Content.ReadAsStringAsync(); &#13;
                    }) &#13;
                .Select(json =&gt; JsonConvert.DeserializeObject&lt;GeocodingContract&gt;(json)); &#13;
        } &#13;
 &#13;
 &#13;
        #endregion &#13;
</pre><p>It may look a bit daunting at first, but let's break it down. Our web service controller is going to pull down data, deserialize the data into our main JSON object <code class="literal">GeocodingContract</code>, and create contracts in an observable sequence.</p><p>When we instantiate a new <code class="literal">HttpClient</code>, we must pass in our registered client handler to delegate the request messages being sent from the HTTP client. We then create a new <code class="literal">Http.Get</code> message; this will be sent from the <code class="literal">HttpClient</code> and delegated through the message handler (<code class="literal">HttpClientHandler</code>), which in turn will receive a JSON response.</p><p>This is where it gets tricky. Look at the <code class="literal">Observable.FromAsync</code> function; this method takes an asynchronous function, will run and await the function, and will return data as an observable sequence. The asynchronous function must return an <code class="literal">IObservable</code>.</p><p>The function we are passing is the <code class="literal">SendAsync</code> function of the <code class="literal">HttpClient</code>; we then use the RX function <code class="literal">SelectMany</code> to take all the response objects. If each response object incurs a HTTP status code <code class="literal">200</code> (<code class="literal">OK</code>), we return the response content as a string. Notice the <code class="literal">async</code> keyword in front of the expression; we have to use an asynchronous function to await the <code class="literal">ReadAsAsync</code> function and return the response content as a JSON string.</p><p>Finally, we use the RX function <code class="literal">Select</code> to take each response string and return the deserialized <code class="literal">GeocodingContract</code>. This contract will be fed into the observable sequence and returned to the original caller <code class="literal">Observable.FromAsync</code>, which in turn will be the data returned from the function.</p></div><div class="section" title="More Reactive Extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>More Reactive Extensions</h2></div></div></div><p>Before we move on, let's talk more about the RX functions we just used. The <code class="literal">Select</code> function is used for iterating over any <code class="literal">List</code>, <code class="literal">Enumerable</code>, or <code class="literal">IObservable</code>, and taking the value of each item to create a new observable sequence.</p><p>Say we have a list of objects with a string property <code class="literal">Name</code>, and we do the following:</p><pre class="programlisting">var newObservable = list.Select (x =&gt; x);  &#13;
</pre><p>We are simply returning the same sequence of items, but then we do something like this:</p><pre class="programlisting">var newObservable = list.Select (x =&gt; x.Name);  &#13;
</pre><p>Our new sequence would be a stream of just the <code class="literal">Name</code> property for each object. These functions are very useful for filtering streams and lists.</p></div><div class="section" title="Resource (RESX) files"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Resource (RESX) files</h2></div></div></div><p>Notice in our <code class="literal">GetGeocodeFromAddressAsync</code> function we are referencing a static class, <code class="literal">ApiConfig</code>:</p><pre class="programlisting">ApiConfig.GoogleMapsUrl &#13;
</pre><p>This is a technique for containing your application's resources, such as strings, URLs, constant variables, settings properties, and so on. It is also used for languages in which we have different constant variable values, based on language settings. This is normally how you would make your app multilingual.</p><p>Let's create a new folder called <code class="literal">Resources</code> inside the <span class="strong"><strong>Locator.Portable</strong></span> project:</p><div class="mediaobject"><img src="graphics/B05293_03_26.jpg" alt="Resource (RESX) files"/></div><p>In the <code class="literal">ApiConfig.Designer.cs</code> file, we must have the namespace set according to the folder hierarchy. In this example, it is <span class="strong"><strong>Locator.Portable</strong></span> | <span class="strong"><strong>Resources</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p><span class="strong"><strong>Locator.Portable</strong></span> is the name assigned to our assembly. We must know the assembly name to reference where the folders will be stored when the app is built. To find out the name of your assembly, visit the properties page, shown in the next screenshot.</p></div></div><div class="mediaobject"><img src="graphics/B05293_03_27.jpg" alt="Resource (RESX) files"/></div><p>Now that we have our <code class="literal">ApiConfig.resx</code> file, let's add a variable for the <code class="literal">GoogleMapsUrl</code> property; paste the following in the <code class="literal">ApiConfig.resx</code> file:</p><pre class="programlisting">  &lt;!-- url --&gt; &#13;
  &lt;data name="GoogleMapsUrl" xml:space="preserve"&gt; &#13;
    &lt;value&gt;https://maps.googleapis.com/maps/api/geocode/json?address={0},+{1},+{2}&amp;amp;key={YOUR-BROSWER-API-KEY}&lt;/value&gt; &#13;
  &lt;/data&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>When you save this file, you will notice the <code class="literal">ApiConfig.Designer.resx</code> file is automatically generated, meaning the namespace may change to incorrect folder paths. Sometimes we have to manually change the folder path every time this file regenerates.</p></div></div></div><div class="section" title="Using GeocodingWebServiceController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Using GeocodingWebServiceController</h2></div></div></div><p>Now that we have set up our web service controller, let's integrate it with our <code class="literal">MapPageViewModel</code>. Our first step is to register the web service controller inside the IoC container; open up <code class="literal">PortableModule.cs</code> and add the following to the <code class="literal">Register</code> function:</p><pre class="programlisting">builer.RegisterType&lt;GeocodingWebServiceController&gt; ().As&lt;IGeocodingWebServiceController&gt;().SingleInstance();  &#13;
</pre><p>Now we update the constructor inside <code class="literal">MapPageViewModel</code> to use <code class="literal">GeocodingWebServiceController</code> from the IoC container:</p><pre class="programlisting">        #region Constructors &#13;
 &#13;
        public MapPageViewModel (INavigationService navigation, IGeolocator geolocator,  &#13;
            IGeocodingWebServiceController geocodingWebServiceController) : base (navigation) &#13;
        { &#13;
            _geolocator = geolocator; &#13;
            _geocodingWebServiceController= geocodingWebServiceController; &#13;
 &#13;
            LocationUpdates = new Subject&lt;IPosition&gt; (); &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>Our next step is to add an array of static addresses as a dictionary:</p><pre class="programlisting">        #region Constants &#13;
 &#13;
        private IDictionary&lt;int, string[]&gt; addresses = new Dictionary&lt;int, string[]&gt;() &#13;
        { &#13;
            {0, new string[] { "120 Rosamond Rd", "Melbourne", "Victoria" }}, &#13;
            {1, new string[] { "367 George Street", "Sydney", "New South Wales" }}, &#13;
            {2, new string[] { "790 Hay St", "Perth", "Western Australi" }}, &#13;
            {3, new string[] { "77-90 Rundle Mall", "Adelaide", "South Australia" }}, &#13;
            {4, new string[] { "233 Queen Street", "Brisbane", "Queensland" }}, &#13;
        }; &#13;
 &#13;
        #endregion  &#13;
</pre><p>We are going to use the geocoder API to determine latitude and longitude positions of all these address locations, and from your current location, determine which one is closer.</p></div><div class="section" title="OnNavigatedTo and OnShow"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>OnNavigatedTo and OnShow</h2></div></div></div><p>Before we go any further with the Geocoding API, we need to make some additions to the navigation setup. Let's begin by implementing the <code class="literal">OnNavigatedTo</code> function for all content pages. Create a new file called <code class="literal">INavigableXamFormsPage.cs</code> and paste in the following:</p><pre class="programlisting">    internal interface INavigableXamarinFormsPage &#13;
    { &#13;
        void OnNavigatedTo(IDictionary&lt;string, object&gt; navigationParameters); &#13;
    } &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>Notice the <code class="literal">internal</code> keyword; this is because this class will never leave the <code class="literal">Xamarin.Forms</code> project.</p></div></div><p>Now we want every page to inherit this interface and create the <code class="literal">OnNavigatedTo</code> function:</p><pre class="programlisting">public partial class MainPage : ContentPage, INavigableXamarinFormsPage  &#13;
    { &#13;
        public void OnNavigatedTo(IDictionary&lt;string, object&gt; navigationParameters) &#13;
        { &#13;
        } &#13;
    } &#13;
 &#13;
public partial class MapPage : ContentPage, INavigableXamarinFormsPage &#13;
    { &#13;
        public void OnNavigatedTo(IDictionary&lt;string, object&gt; navigationParameters) &#13;
        { &#13;
        } &#13;
    } &#13;
</pre><p>Now we want to call the <code class="literal">OnNavigatedTo</code> function every time a page is navigated to. First, let's update our interface for the <code class="literal">NavigationService</code>:</p><pre class="programlisting">    public interface INavigationService &#13;
    { &#13;
        Task Navigate (PageNames pageName, IDictionary&lt;string, object&gt; navigationParameters); &#13;
    } &#13;
</pre><p>Now open up the <code class="literal">NavigationService</code> class and update the <code class="literal">Navigate</code> function:</p><pre class="programlisting">        #region INavigationService implementation &#13;
 &#13;
        public async Task Navigate (PageNames pageName, IDictionary&lt;string, object&gt; navigationParameters) &#13;
        { &#13;
            var page = getPage (pageName); &#13;
 &#13;
            if (page != null)  &#13;
            { &#13;
                var navigablePage = page as INavigableXamarinFormsPage; &#13;
 &#13;
                if (navigablePage != null)  &#13;
                { &#13;
                    await IoC.Resolve&lt;NavigationPage&gt; ().PushAsync (page); &#13;
                    navigablePage.OnNavigatedTo (); &#13;
                } &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
</pre><p>After the page is pushed, we then call the <code class="literal">OnNavigatedTo</code> function.</p><p>Now we want to do a similar thing with page view models. In your <code class="literal">ViewModelBase</code> class, add the following:</p><pre class="programlisting">        public void OnShow(IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
            LoadAsync(parameters).ToObservable().Subscribe( &#13;
                result =&gt; &#13;
                { &#13;
                    // we can add things to do after we load the view model &#13;
                },  &#13;
                ex =&gt; &#13;
                { &#13;
                    // we can handle any areas from the load async function &#13;
                }); &#13;
        } &#13;
 &#13;
        protected virtual async Task LoadAsync(IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
        } &#13;
</pre><p>The <code class="literal">OnShow</code> function will take in the navigation parameters from the coinciding page's <code class="literal">OnNavigatedTo</code> function.</p><p>Notice that the RX approach with handling asynchronous functions when the <code class="literal">LoadAsync</code> has finished?</p><p>We have options to handle results and errors from the <code class="literal">LoadAsync</code> function. You may have also noticed the short expressions used with arrows. This type of syntax is known as lambda expressions, a very common c-sharp syntax for abbreviating functions, arguments, and delegates. Our <code class="literal">LoadAsync</code> is also virtual, which means any page view model that implements this interface can override this function.</p><p>Now let's make some extra additions to the <code class="literal">Xamarin.Forms</code> project (<code class="literal">Locator</code>). Create a new file in the <code class="literal">UI</code> folder and call it <code class="literal">XamarinNavigationExtensions.cs</code>. Now for the implementation:</p><pre class="programlisting">public static class XamarinNavigationExtensions &#13;
    { &#13;
        #region Public Methods and Operators &#13;
 &#13;
        // for ContentPage &#13;
        public static void Show(this ContentPage page, IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
            var target = page.BindingContext as ViewModelBase; &#13;
            if (target != null) &#13;
            { &#13;
                target.OnShow(parameters); &#13;
            } &#13;
        } &#13;
 &#13;
        #endregion &#13;
 &#13;
    } &#13;
</pre><p>Looking at this more closely, we are actually making extension functions for all <code class="literal">ContentPage</code> types. The <code class="literal">OnShow</code> function for a <code class="literal">ContentPage</code> will extract the binding context as a <code class="literal">ViewModelBase</code> and call the <code class="literal">OnShow</code> function of the view model, which in turn will call <code class="literal">LoadAsync</code>. Finally, we make the changes to <code class="literal">MapPage.xaml.cs</code> and <code class="literal">MainPage.xaml.cs</code>:</p><pre class="programlisting">        public void OnNavigatedTo(IDictionary&lt;string, object&gt; navigationParameters) &#13;
        { &#13;
            this.Show (navigationParameters); &#13;
        } &#13;
</pre><p>Well done! What we just implemented is a Windows Phone principle. We know that when the <code class="literal">OnNavigatedTo</code> function is called, our layout for the <code class="literal">XAML</code> sheet is already sized accordingly. The advantage of having this is we can now retrieve x, y, height, and width figures from the page inside this function.</p></div><div class="section" title="Pythagoras equirectangular projection"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Pythagoras equirectangular projection</h2></div></div></div><p>Now back to the Geocoding API. We are going to implement the math behind calculating the closest address to a latitude and longitude (current position).</p><p>For our first step, we need to add some properties for <code class="literal">MapPageViewModel</code>:</p><pre class="programlisting">#region Private Properties &#13;
     &#13;
private IList&lt;IPosition&gt; _positions; &#13;
 &#13;
private Position _currentPosition; &#13;
 &#13;
private string _closestAddress; &#13;
 &#13;
private int _geocodesComplete = 0; &#13;
 &#13;
#endregion &#13;
</pre><p>Now for the extra <code class="literal">public</code> property, which will hold the string address of the closest position:</p><pre class="programlisting">public string ClosestAddress &#13;
        { &#13;
            get &#13;
            { &#13;
                return _closestAddress; &#13;
            } &#13;
 &#13;
            set &#13;
            { &#13;
                if (value.Equals(_closestAddress)) &#13;
                { &#13;
                    return; &#13;
                } &#13;
 &#13;
                _closestAddress = value; &#13;
                OnPropertyChanged("ClosestAddress"); &#13;
            } &#13;
        } &#13;
</pre><p>Now we have to add another <code class="literal">Subject</code> sequence for when the closet position changes:</p><pre class="programlisting">#region Subjects &#13;
 &#13;
public Subject&lt;IPosition&gt; ClosestUpdates { get; set; }  &#13;
 &#13;
#endregion &#13;
</pre><p>This must be initialized in the constructor:</p><pre class="programlisting">ClosestUpdates = new Subject&lt;IPosition&gt; (); &#13;
</pre><p>Now for the fun part.</p></div><div class="section" title="How are we going to calculate the closest position?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>How are we going to calculate the closest position?</h2></div></div></div><p>Let's start with the first private function, which will get the positions from the address:</p><pre class="programlisting">        public async Task GetGeocodeFromAddress(string address, string city, string state) &#13;
        { &#13;
            var geoContract = await _geocodingWebServiceController.GetGeocodeFromAddressAsync(address, city, state); &#13;
 &#13;
            if (geoContract != null &amp;&amp; geoContract.results != null &amp;&amp; geoContract.results.Count &gt; 0) &#13;
            { &#13;
                var result = geoContract.results.FirstOrDefault(); &#13;
 &#13;
                if (result != null &amp;&amp; result.geometry != null &amp;&amp; result.geometry.location != null) &#13;
                { &#13;
                    _geocodesComplete++; &#13;
 &#13;
                    _positions.Add(new Position() &#13;
                        { &#13;
                            Latitude = result.geometry.location.lat, &#13;
                            Longitude = result.geometry.location.lng, &#13;
                            Address = string.Format("{0}, {1}, {2}", address, city, state) &#13;
                        }); &#13;
 &#13;
                    // once all geocodes are found, find the closest &#13;
                    if ((_geocodesComplete == _positions.Count) &amp;&amp; _currentPosition != null) &#13;
                    { &#13;
                        FindNearestSite(); &#13;
                    } &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>In this function, we finally get to use our <code class="literal">GeocodingWebServiceController</code>.</p><p>See how we pass in the variables that will make up the web service URL?</p><p>For each address, we must ping this API call to get the latitude and longitudes required to calculate the closest position. Then we do a bunch of checks on the values in the data contracts to make sure they aren't null, until we get the <code class="literal">GeometryContract</code> values; we will then use these to create a new position and add it to the list.</p><p>Now let's make a small change to the <code class="literal">Position</code> class and interface:</p><pre class="programlisting">    public class Position : IPosition &#13;
    { &#13;
        public string Address {get; set;} &#13;
    } &#13;
 &#13;
    public interface IPosition &#13;
    { &#13;
        double Latitude {get; set;} &#13;
 &#13;
        double Longitude {get; set;} &#13;
 &#13;
        public string Address {get; set;} &#13;
    } &#13;
</pre><p>Add the <code class="literal">Address</code> property so we can record the address string for the closest property. We need to record this in the position because as we fire off so many requests to the API, they will not necessarily finish in order so we can't expect to use index referencing to obtain the position index in the list, to be the coinciding address in the array.</p><p>Now let's add the mathematical functions for calculating distances using the <code class="literal">PythagorasEquirectangular</code> projection. It uses angular projection to calculate the distance between two coordinates on a map plane. We also need a <code class="literal">DegreesToRadians</code> conversion for the <code class="literal">PythagorasEquirectangular</code> function:</p><pre class="programlisting">private double DegreesToRadians(double deg)  &#13;
        { &#13;
            return deg * Math.PI / 180; &#13;
        } &#13;
 &#13;
 &#13;
        private double PythagorasEquirectangular  &#13;
 (double lat1, double lon1, double lat2, double lon2) &#13;
        { &#13;
            lat1 = DegreesToRadians(lat1); &#13;
            lat2 = DegreesToRadians(lat2); &#13;
            lon1 = DegreesToRadians(lon1); &#13;
            lon2 = DegreesToRadians(lon2); &#13;
 &#13;
            // within a 10km radius &#13;
            var radius = 10; &#13;
            var x = (lon2 - lon1) * Math.Cos((lat1 + lat2) / 2); &#13;
            var y = (lat2 - lat1); &#13;
            var distance = Math.Sqrt(x * x + y * y) * radius; &#13;
 &#13;
            return distance; &#13;
        } &#13;
</pre><p>If the distance falls outside the radius value, it will not be used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/>Tip</h3><p>Try playing around with this setting to see the results you get.</p></div></div><p>Now for the <code class="literal">FindNearestSite</code> function:</p><pre class="programlisting">private void FindNearestSite() &#13;
        { &#13;
            if (_geolocationUpdating) &#13;
            { &#13;
                _geolocationUpdating = false; &#13;
                _geolocator.Stop(); &#13;
                GeolocationButtonTitle = "Start"; &#13;
            } &#13;
 &#13;
            double mindif = 99999; &#13;
            IPosition closest = null; &#13;
            var closestIndex = 0; &#13;
            var index = 0; &#13;
 &#13;
            if (_currentPosition != null) &#13;
            { &#13;
                foreach (var position in _positions) &#13;
                { &#13;
                    var difference = PythagorasEquirectangular(_currentPosition.Latitude, _currentPosition.Longitude, &#13;
                        position.Latitude, position.Longitude); &#13;
 &#13;
                    if (difference &lt; mindif) &#13;
                    { &#13;
                        closest = position; &#13;
                        closestIndex = index; &#13;
                        mindif = difference; &#13;
                    } &#13;
 &#13;
                    index++; &#13;
                } &#13;
 &#13;
                if (closest != null) &#13;
                { &#13;
                    var array = _addresses[closestIndex]; &#13;
                    Address = string.Format("{0}, {1}, {2}", array[0], array[1], array[2]); &#13;
                    ClosestUpdates.OnNext(closest); &#13;
                } &#13;
            } &#13;
        } &#13;
</pre><p>We will call this when all the geocodes for the address have been obtained and added to the positions list. We then go through all the positions and compare each to our current position, determine which coordinate difference is the smallest, and use this as our closest position. Then we push a new position onto the <code class="literal">ClosestUpdates</code> observable sequence, which we will subscribe to on the <code class="literal">MapPage</code>.</p><p>Our last step on the <code class="literal">MapPageViewModel</code> is to override the <code class="literal">LoadAsync</code> function:</p><pre class="programlisting">        protected override async Task LoadAsync (IDictionary&lt;string, object&gt; parameters) &#13;
        { &#13;
            var index = 0; &#13;
 &#13;
            for (int i = 0; i &lt; 5; i++) &#13;
            { &#13;
                var array = _addresses [index]; &#13;
                index++; &#13;
 &#13;
                GetGeocodeFromAddress(array[0], array[1], array[2]).ConfigureAwait(false); &#13;
            } &#13;
        }  &#13;
 &#13;
</pre><p>This is where everything will kick off; when the page loads, it will iterate through every address and download the geocode, then once we count the entire count of the address list, we find the nearest positions and push onto the <code class="literal">ClosestUpdates</code> sequence. We also want to run the <code class="literal">GetGeocodeFromAddress</code> function in parallel for each address; this is why we have <code class="literal">ConfigureAwait</code> set to false.</p><p>Now let's make changes to the <code class="literal">MapPage</code>. We are going to use two <code class="literal">IDisposables</code> now for the <code class="literal">MapPage</code>, one for each subject in the view model:</p><pre class="programlisting">private IDisposable _locationUpdateSubscriptions; &#13;
 &#13;
private IDisposable _closestSubscriptions;  &#13;
</pre><p>Now we update the <code class="literal">OnAppear</code> and <code class="literal">OnDisappear</code> functions to handle the subscribing to and disposing of the <code class="literal">Subjects</code>:</p><pre class="programlisting">private void HandleDisappearing (object sender, EventArgs e) &#13;
        { &#13;
            _viewModel.OnDisppear (); &#13;
 &#13;
            if (_locationUpdateSubscriptions != null)  &#13;
            { &#13;
                _locationUpdateSubscriptions.Dispose (); &#13;
            } &#13;
 &#13;
            if (_closestSubscriptions != null)  &#13;
            { &#13;
                _closestSubscriptions.Dispose (); &#13;
            } &#13;
        } &#13;
 &#13;
        private void HandleAppearing (object sender, EventArgs e) &#13;
        { &#13;
            _viewModel.OnAppear (); &#13;
 &#13;
            _locationUpdateSubscriptions = _viewModel.LocationUpdates.Subscribe (LocationChanged); &#13;
            _closestSubscriptions = _viewModel.ClosestUpdates.Subscribe (ClosestChanged); &#13;
        } &#13;
</pre><p>And our final touch is to add the function that is called every time for the <code class="literal">ClosetUpdates</code> observable sequence:</p><pre class="programlisting">private void ClosestChanged (IPosition position) &#13;
        { &#13;
            try &#13;
            { &#13;
                var pin = new Pin() &#13;
                { &#13;
                    Type = PinType.Place, &#13;
                    Position = new Xamarin.Forms.Maps.Position (position.Latitude, position.Longitude), &#13;
                    Label = "Closest Location", &#13;
                    Address = position.Address &#13;
                }; &#13;
 &#13;
                MapView.Pins.Add(pin); &#13;
 &#13;
                MapView.MoveToRegion(MapSpan.FromCenterAndRadius(new Xamarin.Forms.Maps.Position(position.Latitude, position.Longitude) &#13;
                                                                 , Distance.FromMiles(0.3))); &#13;
            } &#13;
            catch (Exception e)  &#13;
            { &#13;
                System.Diagnostics.Debug.WriteLine ("MapPage: Error with moving pin - " + e); &#13;
            } &#13;
        } &#13;
</pre><p>We are creating a pin to place on the map. This pin will also show the address information when we click on the pin. We then move to the region on the map to show this pin, using the <code class="literal">MoveToRegion</code> function.</p><p>That is everything; we have now integrated with Google Maps and Geocoding.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we discussed development with <code class="literal">Xamarin.Forms</code> and <code class="literal">Xamarin.Forms.Maps</code>. We learned how to implement location services on each platform, handling backgrounding location update events and using latitudes and longitudes to calculate positions. Have a play around with the application on all three platforms, and watch how the location updates and nearest positions update the regions on the map. In the next chapter, we will jump back into native development, and build an application that will control a sound file like an audio player.</p></div></body></html>