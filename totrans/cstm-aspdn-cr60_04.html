<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-40"><em class="italic"><a id="_idTextAnchor066"/>Chapter 4</em>: Configuring and Customizing HTTPS with Kestrel</h1>
			<p>In <strong class="bold">ASP.NET</strong> <strong class="bold">Core</strong>, <strong class="bold">HTTPS</strong> is on by default, and it is a first-class feature. On Windows, the certificate that is needed to enable HTTPS is loaded from the Windows certificate store. If you create a project on <strong class="bold">Linux</strong> or <strong class="bold">Mac</strong>, the certificate is loaded from a certificate file.</p>
			<p>Even if you want to create a project to run it behind an <strong class="bold">IIS</strong> or an <strong class="bold">NGINX</strong> web server, HTTPS is enabled. Usually, you would manage the certificate on the IIS or NGINX web server in that case. Having HTTPS enabled here shouldn't be a problem, however, so don't disable it in the ASP.NET Core settings.</p>
			<p>Managing the certificate within the ASP.NET Core application directly makes sense if you run services behind the firewall, services that are not accessible from the internet, services such as background services for a microservice-based application, or services in a self-hosted ASP.NET Core application.</p>
			<p>There are also some scenarios on Windows where it makes sense to load the certificate from a file. This could be in an application that you will run on <strong class="bold">Docker</strong> for Windows or Linux. Personally, I like the flexible way of loading the certificate from a file.</p>
			<p>Only two topics will be covered in this short chapter:</p>
			<ul>
				<li>Introducing Kestrel</li>
				<li>Setting up Kestrel</li>
			</ul>
			<p>The topics in this chapter refer to the hosting layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_4.1_B17996.jpg" alt="Figure 4.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new mvc -n HttpSample -o HttpSample</p>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<p class="source-code">cd HttpSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor068"/>Introducing Kestrel</h1>
			<p><strong class="bold">Kestrel</strong> is a newly <a id="_idIndexMarker045"/>implemented HTTP server that is the hosting engine of ASP.NET Core. Every ASP.NET Core application will run on the Kestrel server. Classic ASP.NET <a id="_idIndexMarker046"/>applications (running on <strong class="bold">.NET</strong> <strong class="bold">Framework</strong>) usually run directly <a id="_idIndexMarker047"/>on the IIS. With ASP.NET Core, Microsoft was inspired by <strong class="bold">Node.js</strong>, which also ships <a id="_idIndexMarker048"/>an HTTP server called <strong class="bold">libuv</strong>. In the first version of ASP.NET Core, Microsoft also used libuv, and then it added a layer on top called Kestrel. At that time, Node.js and ASP.NET Core shared the same HTTP server. </p>
			<p>Since the .NET Core <a id="_idIndexMarker049"/>framework has grown and <strong class="bold">.NET sockets</strong> have been implemented on it, Microsoft has built its own HTTP server based on .NET sockets and <a id="_idIndexMarker050"/>removed libuv, which was a dependency they don't own and control. Now, Kestrel is a full-featured HTTP server that runs ASP.NET Core applications.</p>
			<p>The IIS acts as a reverse proxy that forwards the traffic to Kestrel and manages the Kestrel process. On Linux, usually NGINX is used as a reverse proxy for Kest<a id="_idTextAnchor069"/><a id="_idTextAnchor070"/>rel.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor071"/>Setting up Kestrel</h1>
			<p>As we did in the <a id="_idIndexMarker051"/>first two chapters of this book, we need to override the default <strong class="source-inline">WebHostBuilder</strong> a little bit to set up Kestrel. With ASP.NET Core 3.0 and later, it is possible to replace the default Kestrel base configuration with a custom configuration. This means that the Kestrel web server is configured to the host builder. Let's look at the steps to set up: </p>
			<ol>
				<li>You will be able to add and configure Kestrel manually simply by using it. The following code shows what happens when you call the <strong class="source-inline">UseKestrel()</strong> method on <strong class="source-inline">IwebHostBuilder</strong>. Let's now see how this fits into the <strong class="source-inline">CreateWebHostBuilder</strong> method:<p class="source-code">public class Program</p><p class="source-code">{</p><p class="source-code">    public static void Main(string[] args)</p><p class="source-code">    {</p><p class="source-code">        CreateWebHostBuilder(args).Build().Run();</p><p class="source-code">    }</p><p class="source-code">    public static IHostBuilder </p><p class="source-code">      CreateHostBuilder(string[] args) =&gt;</p><p class="source-code">        Host.CreateDefaultBuilder(args)</p><p class="source-code">            .ConfigureWebHostDefaults(webBuilder =&gt;</p><p class="source-code">            {</p><p class="source-code">                webBuilder</p><p class="source-code">                    .UseKestrel(options =&gt;</p><p class="source-code">                    {</p><p class="source-code">                    })</p><p class="source-code">                    .UseStartup&lt;Startup&gt;();</p><p class="source-code">            }</p><p class="source-code">}</p><p>The preceding <a id="_idIndexMarker052"/>code shows how the <strong class="source-inline">Program.cs</strong> looked until ASP.NET Core 5.0. In ASP.NET Core 6.0, the new minimal API approach is used to configure your application:</p><p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">builder.WebHost.UseKestrel(options =&gt;</p><p class="source-code">{</p><p class="source-code">});</p><p class="source-code">// Add services to the container.</p><p class="source-code">builder.Services.AddControllersWithViews();</p><p class="source-code">var app = builder.Build();</p><p class="source-code">// the rest of this file is not relevant</p><p>We'll focus on the <strong class="source-inline">UseKestrel()</strong> method for the rest of this chapter. The <strong class="source-inline">UseKestrel()</strong> method accepts an action to configure the Kestrel web server.</p></li>
				<li>What we <em class="italic">actually</em> need to do is configure the addresses and ports that the web server is <a id="_idIndexMarker053"/>listening on. For the HTTPS port, we also need to configure how the certificate should be loaded:<p class="source-code">builder.WebHost.UseKestrel(options =&gt;</p><p class="source-code">{</p><p class="source-code">    options.Listen(IPAddress.Loopback, 5000);</p><p class="source-code">    options.Listen(IPAddress.Loopback,  5001, </p><p class="source-code">      listenOptions  =&gt;</p><p class="source-code">    {</p><p class="source-code">        listenOptions.UseHttps("certificate.pfx", </p><p class="source-code">          "topsecret");</p><p class="source-code">    });</p><p class="source-code">});</p><p>Don't forget to add a using statement to the <strong class="source-inline">System.Net</strong> namespace to resolve the <strong class="source-inline">IPAddress</strong>.</p><p>In this snippet, we add the addresses and ports to listen on. The configuration is defined as a secure endpoint configured to use HTTPS. The <strong class="source-inline">UseHttps()</strong> method is overloaded multiple times in order to load certificates from the Windows certificate store as well as from files. In this case, we will use a file called <strong class="source-inline">certificate.pfx</strong> located in the project folder.</p></li>
				<li>To create a certificate file to just play around with this configuration, open the certificate store and export the development certificate created by Visual Studio. It is located in the current user certificates under the personal certificates:</li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_4.2_B17996.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Certificates</p>
			<p>Right-click this entry. In the context menu, go to <strong class="bold">All Tasks</strong> and click <strong class="bold">Export</strong>. In the <strong class="bold">Certificate Export Wizard</strong>, click <strong class="bold">Next</strong> and then click <strong class="bold">Yes, export the private key</strong>, then click <strong class="bold">Next</strong>. Now, choose the <strong class="bold">.PFX </strong>format in the next screen and click <strong class="bold">Next</strong>. Here, you need to set a password. This is the exact same password <a id="_idIndexMarker054"/>you will need to use in the code, as seen in the following code example. Choose a filename and a location to store the file, and then click <strong class="bold">Next</strong>. The last screen will show a summary. Click <strong class="bold">Finish</strong> to save the certificate to <a id="_idTextAnchor072"/><a id="_idTextAnchor073"/>a file.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor074"/>For your safety</h2>
			<p>Use the following line <em class="italic">only</em> to play around with this configuration:</p>
			<p class="source-code">listenOptions.UseHttps("certificate.pfx", "topsecret");</p>
			<p>To clarify why – the problem is the hardcoded password. Never, <em class="italic">ever</em> store a password in a code <a id="_idIndexMarker055"/>file that gets pushed to any source code repository. Ensure that you load the password from the configuration API of ASP.NET Core. Use the user secrets on your local development machine and use environment variables on a server. On <strong class="bold">Azure</strong>, use the application settings to store the passwords. Passwords will be hidden on the Azure portal UI if they are marked as pa<a id="_idTextAnchor075"/>sswords.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor076"/>Summary</h1>
			<p>This is just a small customization, but it should help if you want to share the code between different platforms, or if you want to run your application on Docker and don't want to worry about certificate stores, and so on.</p>
			<p>Usually, if you run your application behind a web server such as an IIS or NGINX, you don't need to care about certificates in your ASP.NET Core 6.0 application. However, if you host your application inside another application, on Docker, or without an IIS or NGINX, you will need to.</p>
			<p>In the next chapter, we're going to talk about how to configure the hosting of ASP.NET Core web applications.</p>
		</div>
	</body></html>