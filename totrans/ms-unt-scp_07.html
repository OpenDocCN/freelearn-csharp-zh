<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Artificial Intelligence</h1></div></div></div><p>This chapter takes a highly practical and specialized focus. Here, we'll cover the development of a single Unity project from start to finish in creating a maze scene that features enemy characters with<a id="id526" class="indexterm"/> <strong>Artificial Intelligence</strong> (<strong>AI</strong>); these characters have the ability to search for and chase us, attack us, and also flee from us while looking for health-restore potions. The following screenshot shows the maze scene in Unity:</p><div><img src="img/0655OT_07_01.jpg" alt="Artificial Intelligence"/><div><p>The maze scene</p></div></div><div><div><h3 class="title"><a id="tip48"/>Tip</h3><p>The AI project for this book can be found in the book's companion files (code bundle) in the <code class="literal">ai</code> folder of this chapter.</p></div></div><p>In creating this project, we'll apply nearly all the concepts and ideas seen so far in an isolated and pure form, looking at how they come together in the project, alongside a unique range of AI concepts, such as <a id="id527" class="indexterm"/>
<strong>Finite State Machines</strong> (<strong>FSMs</strong>), navigation meshes, line of sight, and more. To follow this chapter and get the most from it, I recommend that you create a new and blank <a id="id528" class="indexterm"/>Unity project and take each step from start to finish. The final, completed project arrived at by the end of this chapter can be found in the book's companion files (code bundle) in the <code class="literal">ai</code> folder of this chapter.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Artificial Intelligence in games</h1></div></div></div><p>The concept of intelligence can be understood in many senses: psychological, scientific, philosophical, spiritual, sociological, and others. Many of them are profound. However, in video games, it's primarily<a id="id529" class="indexterm"/> about appearances, namely, the appearance of intelligence. Perhaps, this is why the word "artificial" enters the title. The idea is that video games are primarily about having fun and interesting experiences. This means that the believability <a id="id530" class="indexterm"/>of a game for the gamer rests on how engaged they are with the events actually happening in the game. Thus, whenever a <strong>non-player character</strong> (<strong>NPC</strong>), such<a id="id531" class="indexterm"/> as an enemy wizard in an RPG, does something "silly" (like walking through solid walls for no good reason or aimlessly walking back and forth as though stuck), then the gamer perceives that something is wrong. They regard the characters as not acting intelligently just because the character's behavior, in those specific circumstances, is not appropriate and cannot be explained reasonably with reference to anything else happening in the game. The "mistake" or "silliness" of the character's behavior forces the player to recognize a glitch, and in doing so, the gamer is removed from the experience, becoming aware that it's just a game. The upshot of this is that for games, AI largely consists of making characters respond appropriately to their situation whenever the gamer is looking. In games where AI is for enemies or opponents, this consists largely of tweaking difficulty, that is, not making the AI too easy or too hard. Seen in this way, AI is not about building a mathematical model of the human mind and consciousness that simulates what happens to us while thinking from an inward or internal perspective. It's only about creating behaviors, making characters act as we'd expect them to under those specific conditions, as shown in the following screenshot. Consequently, there's something "hollow" about AI for games, but this philosophical observation need not concern us here any further.</p><div><img src="img/0655OT_07_02.jpg" alt="Artificial Intelligence in games"/><div><p>The enemy AI character to be created using the Unity constructor mesh</p></div></div><p>In this chapter, we'll create a first-person sample game set inside a maze environment. Here, the player can attack enemies, and enemies can attack the player. The enemy mesh itself is based on the animated constructor character that ships with Unity and features the walk, run, and jump animations. The <a id="id532" class="indexterm"/>constructor character (not class constructors) will search the<a id="id533" class="indexterm"/> environment, look for the player, and when they are found, chase and attack them. The constructor can also be attacked, and when attacked, they will flee and search for power-ups if their health runs low. So, let's get started!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Starting the project</h1></div></div></div><p>To start, create a blank, new Unity project with a new scene. For this sample, I've imported several Unity <a id="id534" class="indexterm"/>asset packages via the file menu command by selecting the <strong>Import Package</strong> option from <strong>Asset</strong>. The packages are <strong>Character</strong> <strong>Controller</strong>, <strong>Skyboxes</strong>, and <strong>Particles</strong>, as shown in the following screenshot. <strong>Character Controllers</strong> features the constructor mesh and animations, as well as a first-person controller prefab.</p><p>The <strong>Skyboxes</strong> package adds some eye candy for a sky that the camera will see, and the <strong>Particles</strong> package will be used to create a teleporter device, as we'll see.</p><div><img src="img/0655OT_07_03.jpg" alt="Starting the project"/><div><p>Importing assets into the project</p></div></div><p>Also, add a first-person controller and the maze mesh to the scene (the mesh is included in the book's companion files in the <code class="literal">assets</code> folder of this chapter) and create some lighting and light <a id="id535" class="indexterm"/>mapping to make things look good initially. The mesh was created in a 3D modeling program, in<a id="id536" class="indexterm"/> this case, Blender (<a class="ulink" href="http://www.blender.org/">http://www.blender.org/</a>).None of these assets are, however, critical to AI per se, but they create a presentable gray-box scenario with which you can work. Lightmapping details are outside the scope of this book, but Lightmapping features can be accessed by selecting <strong>Lightmapping</strong> in the <strong>Window</strong> option from the application menu, as shown in the following screenshot.</p><p>More details <a id="id537" class="indexterm"/>on Lightmapping can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Lightmapping.html">http://docs.unity3d.com/Manual/Lightmapping.html</a>.</p><div><img src="img/0655OT_07_04.jpg" alt="Starting the project"/><div><p>Creating the initial scene</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Baking a navigation mesh</h1></div></div></div><p>The enemy to be created needs to walk intelligently around the level to find and chase the player as well as to find health-restore power-ups. The AI cannot simply walk in a straight line between any <a id="id538" class="indexterm"/>two points, as there might be intervening obstacles such as walls and other characters. The AI should instead navigate around these objects when they're encountered. To achieve this in the long term, a navigation mesh should be used. This is an invisible mesh asset that Unity generates automatically to approximate all walkable, horizontal surfaces in the level, that is, surfaces classified as a floor. The navigation mesh itself contains no AI. It does not make anything walk. The navigation mesh is rather a mathematical model that contains all the necessary data that allows AI units to successfully calculate and travel a path that avoids obstacles as and when required. To generate a navigation mesh for the level, select the <strong>Navigation</strong> option from the <strong>Window</strong> tab of the application menu. This displays the <strong>Navigation Mesh</strong> tab, which can be docked into the Object Inspector.</p><div><div><h3 class="title"><a id="tip49"/>Tip</h3><p>For the basics on<a id="id539" class="indexterm"/> navigation mesh baking, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Navmeshes.html">http://docs.unity3d.com/Manual/Navmeshes.html</a>.</p></div></div><p>When baking a navigation mesh, there are some additional details to keep in mind, as shown in the following screenshot:</p><div><img src="img/0655OT_07_05.jpg" alt="Baking a navigation mesh"/><div><p>Preparing to bake a navigation mesh</p></div></div><p>First, the <strong>Radius</strong> setting will likely require adjusting from its default. In short, this setting defines an imaginary circle around the feet of your characters; this circle indicates their approximate size as walking<a id="id540" class="indexterm"/> agents. If the radius is too large, the navigation mesh appears broken or fractured, and if it is too small, the mesh takes a long time to generate, and additionally, your agents will penetrate through walls while walking. A certain degree of trial and error and refinement lets you reach a value that works best for your project. For this sample, a value of 0.2 works best. If the radius is too high, your navigation mesh will fracture in narrow areas, which is not good because agents cannot travel across gaps, as shown in the following screenshot:</p><div><img src="img/0655OT_07_06.jpg" alt="Baking a navigation mesh"/><div><p>Navigation mesh fracture in narrow areas</p></div></div><p>Second, a navigation mesh (once generated) might appear raised above or offset upwards, away from the true mesh floor. If this happens, you could reduce the <strong>Height Inaccuracy %</strong> setting to <code class="literal">1</code> from<a id="id541" class="indexterm"/> the <strong>Advanced</strong> group, as shown in the following screenshot. This prevents your agents from appearing to hover in midair. Remember that after adjusting any settings, you need to rebake the navigation mesh to apply the changes.</p><div><img src="img/0655OT_07_07.jpg" alt="Baking a navigation mesh"/><div><p>Reducing Height Inaccuracy % moves the generated navigation mesh closer to the true floor</p></div></div><p>From the figures, you can see that the maze scene features two separate maze areas (left and right) with no connecting mesh between them that allows the creation of a path. For this sample, the intelligent agents should be able to move freely between each section using a teleporter to transport them from one area to another, if required.</p><p>To achieve a connection like this between a break in the navigation mesh that allows the AI to compute valid paths<a id="id542" class="indexterm"/> across surfaces, we could use off-mesh links. Add a new mesh to the level that should act as a teleporter pad or platform when stepped upon. For this example, I used a standard box mesh with a particle system for enhanced effect, but this is not essential. Then, attach an off-mesh link component to the mesh object, as shown here:</p><div><img src="img/0655OT_07_08.jpg" alt="Baking a navigation mesh"/><div><p>Creating a teleporter pad using off-mesh links</p></div></div><p>Repeat the procedure for the destination teleporter pad. For each teleporter, assign the object's transform to the <strong>Start</strong> field of the off-mesh link component. This indicates the selected teleporter as the start point. Then, for the <strong>End</strong> field, assign the destination transform. This establishes a connection between the two teleporters that creates a path between them. When the connection is established, a connection arrow should be drawn in-between the scene viewport when the <strong>Navigation</strong> panel is open and active in the editor, as shown in the following screenshot. You can also generate <a id="id543" class="indexterm"/>off-mesh links automatically. For more information, visit <a class="ulink" href="https://www.youtube.com/watch?v=w3-sSozYph4">https://www.youtube.com/watch?v=w3-sSozYph4</a>.</p><div><img src="img/0655OT_07_09.jpg" alt="Baking a navigation mesh"/><div><p>Defining a connection between off-mesh links</p></div></div><div><div><h3 class="title"><a id="tip50"/>Tip</h3><p>The starting <a id="id544" class="indexterm"/>project for this chapter, ready for AI coding, can be found in the book's companion files (code bundle) in the <code class="literal">Start</code> folder of this chapter.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Starting an NPC agent</h1></div></div></div><p>Now, let's create an AI agent for the level, something that can interact with the player. First, the agent needs a<a id="id545" class="indexterm"/> physical mesh representation in the scene. For this, I used the <code class="literal">Constructor</code> mesh, which is part of the Unity <strong>Character Controllers</strong> package imported earlier. Drag-and-drop this from the <strong>Project</strong> panel into the scene and then remove any animator component that might be created, as shown in the following screenshot. The animations will be important, but a custom-made animator controller will be created later.</p><div><img src="img/0655OT_07_10.jpg" alt="Starting an NPC agent"/><div><p>Adding a constructor mesh for the enemy character</p></div></div><div><div><h3 class="title"><a id="tip51"/>Tip</h3><p>Remember that we're not using the third-person controller prefab; it's just the constructor mesh alone.</p></div></div><p>Next, add a <code class="literal">NavMeshAgent</code> component to the object by navigating to <strong>Component</strong> | <strong>Navigation</strong> | <strong>Nav Mesh Agent</strong>. This allows the object to work with the navigation mesh, and it is able to find and travel paths when instructed. Set both the <strong>Radius</strong> and <strong>Height</strong> values of the component to<a id="id546" class="indexterm"/> match the dimensions of the mesh. Set the <strong>Stopping Distance</strong> to <code class="literal">2</code>; this controls how close to a destination that the player should reach before stopping, as shown in the following screenshot. Of course, for your own projects, the <strong>Stopping Distance</strong> value will probably need to be edited.</p><div><img src="img/0655OT_07_11.jpg" alt="Starting an NPC agent"/><div><p>Configuring a NavMeshAgent component for pathfinding</p></div></div><p>Now, add a <code class="literal">Rigidbody</code> component and enable the <strong>Is Kinematic</strong> checkbox, as shown in the following screenshot. This allows the object to enter trigger volumes and be a part of the physics system by both <a id="id547" class="indexterm"/>causing and receiving physics events. However, with <strong>Is Kinematic</strong> checked, Unity will not override the object's transformation (position, rotation, and scale). This allows the <code class="literal">NavMeshAgent</code> exclusively to control the movement of the character.</p><div><img src="img/0655OT_07_12.jpg" alt="Starting an NPC agent"/><div><p>Configuring a Rigidbody component for physics</p></div></div><p>Now, add a <code class="literal">BoxCollider</code> component to the object and enable the <strong>Is Trigger</strong> checkbox to convert it into a trigger volume, that is, a volume that allows physical objects to pass through as opposed to blocking them. This will be used by the AI to approximate an agent's field of view or viewing area. It will follow the agent, and only other objects entering its field are classified as worthy of further consideration. To size the volume to the agent's field of view, use the <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> size fields, as shown here:</p><div><img src="img/0655OT_07_13.jpg" alt="Starting an NPC agent"/><div><p>Using a BoxCollider component to configure the field of view for an enemy agent</p></div></div><p>Finally, create a new C# script file, <code class="literal">AI_Enemy.cs</code>, in the project to define the enemy intelligence. This script will encapsulate the complete AI for the enemy character and will be developed over the course of this chapter. Once the file is initially created, attach it to the enemy object<a id="id548" class="indexterm"/> in the scene. We're now ready to jump into the AI coding and graph building! We'll start by creating FSMs and their attendant states that specify how the enemy should behave.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Finite State Machines in Mecanim</h1></div></div></div><p>From this point onwards, we'll <a id="id549" class="indexterm"/>concentrate mainly on coding AI for the enemy character both in C# and in terms of visual coding for a Mecanim graph. Mecanim refers<a id="id550" class="indexterm"/> to the Unity's Animation System (<a class="ulink" href="http://docs.unity3d.com/Manual/MecanimAnimationSystem.html">http://docs.unity3d.com/Manual/MecanimAnimationSystem.html</a>). In the upcoming sections, we'll piece together a complete class that looks at and discusses specific sections of code, and the <a id="id551" class="indexterm"/>full class source code will be pieced together as we go along. It can be viewed in the completed project in the <code class="literal">AI_Enemy.cs</code> file.</p><p>To start, let's examine FSMs conceptually. When thinking about the enemy character, we can observe in them a specific set of behaviors. The enemy begins the scene by standing idle and then proceeds to wander around on patrol. During their patrol, they might see the player character. If they do so, they'll chase the player until the player comes into attack range. When the player enters attack range, they'll attack the player. Now, the only exception to these rules is if the enemy sustains serious health damage that brings them close to death. On reaching critical levels like this, the enemy will, instead of acting aggressively, flee and search for a health-restore potion until their health level is returned to normal.</p><p>In summarizing the enemy behavior sets like this, we've identified a number of discrete and critical states for enemy intelligence. These are idle, patrol, chase, attack, and flee. The enemy can be in one and only one of these states at any one time, and each state determines how the enemy will behave. To implement this logic, we can use an FSM design. This refers not to a specific class or object type (such as <code class="literal">MonoBehaviour</code> or <code class="literal">ScriptableObject</code>) but rather to a design pattern, a way of coding. An FSM begins with a finite set of states (idle, patrol, chase, and so on, as mentioned earlier) and then manages how the states are connected to one another logically. This determines when and how one state changes to another. The enemy for our situation here will depend, in fact, on two-state machines under the hood: one in C# code and the other in a Mecanim animator graph. The latter controls only the animation that should play for the enemy mesh during each state. Let's build the Mecanim graph first.</p><p>Right-click on the <strong>Project</strong> panel and create a new <strong>Animator Controller</strong> asset. Open the asset inside the <strong>Animator</strong> window that is accessible by selecting the <strong>Animator</strong> option in <strong>Window</strong> from the application main menu, as shown here:</p><div><img src="img/0655OT_07_14.jpg" alt="Finite State Machines in Mecanim"/><div><p>Accessing the animation graph</p></div></div><p>The<a id="id552" class="indexterm"/> Mecanim animator graph defines all the possible animation states for the mesh, and these should correspond to the enemy states already outlined, namely, idle, patrol, chase, attack, and flee. To <a id="id553" class="indexterm"/>configure the animations for these <a id="id554" class="indexterm"/>states, select the <strong>Constructor</strong> mesh asset in the <strong>Project</strong> panel and make all animations loopable by enabling the <strong>Loop Time</strong> and <strong>Loop Pose</strong> checkboxes in the Object Inspector, as shown in the following screenshot. This prevents the character animations from stopping after playing only once:</p><div><img src="img/0655OT_07_15.jpg" alt="Finite State Machines in Mecanim"/><div><p>Preparation of animation assets for a Mecanim FSM</p></div></div><p>Now, let's add animation states to the graph, one animation per state. For the <strong>Idle</strong> state, the idle animation should play. For the <strong>Patrol</strong> state, the walk animation should play as the character should be walking around. For the <strong>Chase</strong> and <strong>Flee</strong> states, the run animation should play, and<a id="id555" class="indexterm"/> for the <strong>Attack</strong> state, the jump animation should play. The <strong>Constructor</strong> model lacks a dedicated animation for<a id="id556" class="indexterm"/> attacks, so (for this sample) the jump animation will suffice as an attack animation.</p><p>Go ahead and add these to the graph by dragging-and-dropping each animation from the <strong>Project</strong> panel into the Graph Editor, and name each state as appropriate, as shown here:</p><div><img src="img/0655OT_07_16.jpg" alt="Finite State Machines in Mecanim"/><div><p>Building an FSM in the Animator window</p></div></div><p>In addition to the standard animation states added so far, let's add an additional empty state too. This will be the initial and default state of the enemy; this state plays no animation and<a id="id557" class="indexterm"/> represents, effectively, a stateless state until we explicitly put the enemy into a specific state at level startup. To create an empty<a id="id558" class="indexterm"/> and default state, right-click on the empty space inside the Graph Editor and choose the <strong>Empty</strong> option in <strong>Create State</strong> from the context menu (rename it appropriately to <code class="literal">Start</code> or <code class="literal">Init</code>), and then make it the default state by right-clicking on the state and choosing <strong>Set As Default</strong>, as shown here:</p><div><img src="img/0655OT_07_17.jpg" alt="Finite State Machines in Mecanim"/><div><p>Setting the empty node as the default state</p></div></div><p>The graph now features one animation per state for the character, but the states are not connected; each<a id="id559" class="indexterm"/> state is isolated. Specifically, there's no logic that governs the conditions by which one state <a id="id560" class="indexterm"/>moves to another. To fix this, create five new triggers using the <strong>Parameters</strong> box in the bottom-left corner of the Mecanim window. A trigger variable is a special Boolean type that Unity will automatically reset to <code class="literal">false</code>; every time it's made <code class="literal">true</code>, it allows behaviors to be initiated once, such as state changes. The triggers, as we'll see, can be accessed in C# code.</p><p>For now, create five triggers: <strong>Idle</strong>, <strong>Patrol</strong>, <strong>Chase</strong>, <strong>Attack</strong>, and <strong>SeekHealth</strong>, as shown here:</p><div><img src="img/0655OT_07_18.jpg" alt="Finite State Machines in Mecanim"/><div><p>Creating a Trigger variable for each animation state</p></div></div><p>With both the states and triggers created, the connection between the states in the graph can now be defined more precisely. Specifically, the <strong>Idle</strong> state should change to the <strong>Patrol</strong> state when<a id="id561" class="indexterm"/> the trigger <strong>Patrol</strong> is activated, the <strong>Patrol</strong> to the <strong>Chase</strong> state when trigger <strong>Chase</strong> is activated, the <strong>Chase</strong> state to the <strong>Attack</strong> state <a id="id562" class="indexterm"/>when trigger <strong>Attack</strong> is activated, and so on. In addition, there's a two-way linkage between most states: <strong>Patrol</strong> can transition to <strong>Chase</strong> (such as when the enemy sees the player) and <strong>Chase</strong> can transition back to <strong>Patrol</strong> (when the enemy loses sight of the player). To create connections between states, right-click on a state, select <strong>Make Transition</strong> from the context menu, and then click on the destination state to which a connection should be made.</p><div><img src="img/0655OT_07_19.jpg" alt="Finite State Machines in Mecanim"/><div><p>Setting the condition for a state transition</p></div></div><p>The graph now defines a complete animation state machine (FSM) for an enemy object. Attaching this to<a id="id563" class="indexterm"/> the enemy object in the scene is<a id="id564" class="indexterm"/> simple.</p><p>Add an <strong>Animator</strong> component to the object and then drag-and-drop the <strong>Animator</strong> controller from the <strong>Project</strong> panel into the <strong>Controller</strong> field on the <strong>Animator</strong> component, as shown here:</p><div><img src="img/0655OT_07_20.jpg" alt="Finite State Machines in Mecanim"/><div><p>Attaching Animator to an enemy object</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Finite State Machines in C# – getting started</h1></div></div></div><p>Now that the FSM for animation is completed, we should turn our attention to an FSM in C# that governs the<a id="id565" class="indexterm"/> behavior of the enemy as well as initiates our triggers in the Mecanim graph to play the appropriate animations (walk and run) at the right time. To begin the implementation, add the following public enumeration to the top <a id="id566" class="indexterm"/>of the <code class="literal">AI_Enemy.cs</code> script file, as shown in the following code sample 7-1. This enumeration defines all the possible states in the FSM for the enemy, and each state is assigned its unique string hash code; that is, the <code class="literal">IDLE</code> state is assigned the value of <code class="literal">2081823275</code>, which is the hash code for the string <code class="literal">IDLE</code>, and so on. This will be important later to work with Mecanim and specifically to initiate triggers. You can retrieve the hash code for a string using the <code class="literal">StringToHash</code> function<a id="id567" class="indexterm"/> of the <code class="literal">Animator</code> class, as shown here:</p><div><pre class="programlisting">//Define possible states for enemy
public enum AI_ENEMY_STATE {IDLE = 2081823275,
                            PATROL=207038023,
                            CHASE= 1463555229,
                            ATTACK=1080829965,
                            SEEKHEALTH=-833380208};</pre></div><div><div><h3 class="title"><a id="tip52"/>Tip</h3><p>More information<a id="id568" class="indexterm"/> can be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html">http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html</a>.</p></div></div><p>On the basis of the enumeration <code class="literal">AI_ENEMY_STATE</code>, the <code class="literal">AI_Enemy</code> class will maintain a public variable <code class="literal">CurrentState</code>, which expresses the active state of the enemy object right now. This variable will change over time as the states change, as shown in the following code:</p><div><pre class="programlisting">//Current state of enemy
public AI_ENEMY_STATE CurrentState = AI_ENEMY_STATE.IDLE;</pre></div><p>Like most objects, the class <code class="literal">AI_Enemy</code> features an<a id="id569" class="indexterm"/> <code class="literal">Awake</code> function to retrieve cached component references to other components, including the <code class="literal">NavMeshAgent</code> and the local <code class="literal">Transform</code>, as well as to <a id="id570" class="indexterm"/>other objects in the scene, such as the <code class="literal">Player</code> object. These references will be used elsewhere in the script, as shown in the<a id="id571" class="indexterm"/> following code sample 7-2:</p><div><pre class="programlisting">//Get Animator
ThisAnimator = GetComponent&lt;Animator&gt;();
 
//Get Navigation Mesh Agent
ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
 
//Get Transform Component
ThisTransform = transform;
 
//Get Player Transform
PlayerTransform = GameObject.FindGameObjectWithTag("Player").transform;
 
//Get Collider
ThisCollider = GetComponent&lt;BoxCollider&gt;();</pre></div><div><div><h3 class="title"><a id="tip53"/>Tip</h3><p>This code uses cached variables: <code class="literal">ThisAnimator</code>, <code class="literal">ThisTransform</code>, <code class="literal">ThisAgent</code>, and <code class="literal">ThisCollider</code>. This lets us retrieve immediate and direct references to attached components at level startup, which saves us from having to call C# property functions (<code class="literal">get</code> and <code class="literal">set</code>) every time we need access to an object. Thus, <code class="literal">This.Transform</code> carries a greater performance overhead than the optimized, cached variable, <code class="literal">ThisTransform</code>.</p></div></div><p>Each state in the FSM will be coded as a separate Coroutine, one Coroutine per state. The Coroutine will loop infinitely and exclusively as long as the state is active, defining all behaviors for the enemy in that state. The primary job of the state machine is to select and initiate the<a id="id572" class="indexterm"/> appropriate state under the correct conditions. Let's start by<a id="id573" class="indexterm"/> creating the <code class="literal">Idle</code> state—the default or normal state for the enemy.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Creating the Idle state</h1></div></div></div><p>The enemy object begins in the <code class="literal">Idle</code> state (a "doing nothing" state), which is primarily transitional. In this <a id="id574" class="indexterm"/>state, the enemies stand where they are, playing the idle animation. The state is entered once at scene startup, but we'll also return to it when exiting some other states, as an intermediary step before moving onto a new state. Effectively, in this state, the enemy should always play the idle animation just once and then leave the state when the animation is completed. The enemy can further move to the <code class="literal">Patrol</code> state automatically, where they begin searching the scene for the player. This involves a two-step process. First, we'll need to start playing the idle animation as the <code class="literal">Idle</code> state begins. Second, we'll need to be notified when the idle animation has completed, to initiate a change to the <code class="literal">Patrol</code> state. Refer to the following code sample 7-3 for the <code class="literal">Idle</code> state:</p><div><pre class="programlisting">01 //--------------------------------------------------
02 //This coroutine runs when object is in idle state
03 public IEnumerator State_Idle()
04 {
05       //Set current state
06       CurrentState = AI_ENEMY_STATE.IDLE;
07 
08       //Activate idle state with Mecanim
09       ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.IDLE);
10 
11       //Stop nav mesh agent movement 
12        ThisAgent.Stop();
13  
14       //Loop forever while in idle state
15       while(CurrentState == AI_ENEMY_STATE.IDLE)
16        {
17              //Check if we can see player
18              if(CanSeePlayer)
19              {
20                    // can see player?, chase to attack
21                    StartCoroutine(State_Chase());
22                    yield break;
23               }
24 
25              //Wait for next frame
26              yield return null;
27        }
28 }
29 //--------------------------------------------------</pre></div><p>The following are the comments for code sample 7-3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 03</strong>: <code class="literal">State_Idle</code> is coded as a Coroutine. For more information on Coroutines, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html">http://docs.unity3d.com/Manual/Coroutines.html</a>. In short, a Coroutine<a id="id575" class="indexterm"/> works like an asynchronous function (as a code block that runs in the background, parallel to other functions). For this reason, the infinite loop in line 15 will not cause a crash because a Coroutine runs like a separate thread. Coroutines always return type <code class="literal">IEnumerator</code> and always feature a yield statement somewhere within their body.</li><li class="listitem" style="list-style-type: disc"><strong>Line 09</strong>: The<a id="id576" class="indexterm"/> animator <a id="id577" class="indexterm"/><code class="literal">SetTrigger</code> function is called in this line; it passes the hash code for the string <code class="literal">Idle</code> as an argument to set the <code class="literal">Idle</code> trigger in the Mecanim graph, initiating a playback of the idle animation. This links the C# FSM to the Mecanim FSM. Notice that in line 12, the <code class="literal">Stop</code> function is called for the <code class="literal">NavMeshAgent</code> component to stop any movement that the object might have been performing. This is because while the idle animation is playing, the enemy should not be moving.</li><li class="listitem" style="list-style-type: disc"><strong>Line 15</strong>: Here, the<a id="id578" class="indexterm"/> <code class="literal">State_Idle</code> function enters an infinite loop; that is, it'll loop frame by frame as long as the enemy is in an <code class="literal">Idle</code> state. While the <code class="literal">Idle</code> state is active, everything within the loop executes every frame that allows the object to update and change its behavior over time.</li><li class="listitem" style="list-style-type: disc"><strong>Line 18</strong>: One exit condition for the <code class="literal">Idle</code> state, other than waiting for the idle animation to complete, is if the player is seen in the interim. Player visibility is determined by the Boolean variable <code class="literal">CanSeePlayer</code> (the details of line of sight are considered later). If <code class="literal">CanSeePlayer</code> is <code class="literal">true</code>, the <code class="literal">Chase</code> state is activated using the<a id="id579" class="indexterm"/> <code class="literal">StartCoroutine</code> function, and the <code class="literal">Idle</code> state is terminated with a call to yield break.</li></ul></div><p>The <code class="literal">Idle</code> state, as implemented so far, loops infinitely and never changes to another state unless the player is seen. However, the <code class="literal">Idle</code> state should only be temporary; the idle animation should play once and then notify us of its completion. To achieve this playback notification, we can use Animation Events. To configure this, select the <strong>Constructor</strong> character mesh in the <strong>Project</strong> panel and open the <strong>Animation</strong> tab to examine the idle animation in the Object Inspector. From here, open the <strong>Events</strong> tab, as shown in the following screenshot:</p><div><img src="img/0655OT_07_21.jpg" alt="Creating the Idle state"/><div><p>Expanding the Events tab in the Object Inspector</p></div></div><p>Then, double-click <a id="id580" class="indexterm"/>on the animation timeline at time <strong>1</strong> (at the end) to insert a function call at that time. This sends a message to the enemy object when the animation completes, as shown in the following screenshot. For this purpose, I've coded a method <code class="literal">OnIdleAnimCompleted</code> inside the <code class="literal">AI_Enemy</code> class:</p><div><img src="img/0655OT_07_22.jpg" alt="Creating the Idle state"/><div><p>Calling a function at animation end</p></div></div><p>The function <code class="literal">OnIdleAnimCompleted</code> is called automatically by Unity when the idle animation completes. The following<a id="id581" class="indexterm"/> code sample 7-4 shows how this method is implemented:</p><div><pre class="programlisting">   //Event called when Idle animation is completed
   public void OnIdleAnimCompleted()
   {
         //Stop active Idle state
         StopAllCoroutines();
<strong>         StartCoroutine(State_Patrol());</strong>
   }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Creating the Patrol state</h1></div></div></div><p>In the <code class="literal">Patrol</code> state, the enemy should wander the environment and look for the player. This state can be entered <a id="id582" class="indexterm"/>from the <code class="literal">Idle</code> state, after the idle animation is completed, and also from the <code class="literal">Chase</code> state, if the enemy loses sight of the player during a chase. Patrol involves a looping logic. Specifically, the enemy should pick a random destination somewhere on the navigation mesh and then travel to that destination. When the destination is reached, the process should repeat and so on. The only condition that causes the enemy to leave this state is a sighting of the player, which demands a <code class="literal">Chase</code> state.</p><p>Though simple to explain, this state relies on two more complex issues: first, a random location must be selected and second, a player visibility check should be performed. First, let's consider the random location selection.</p><p>In the <strong>Scene</strong> tab, I created a collection of waypoints (empty game objects) that are tagged <strong>Waypoint</strong> and do nothing but mark locations on the <code class="literal">NavMesh</code> floor. Together, these represent all the possible<a id="id583" class="indexterm"/> locations to which an enemy could travel during a patrol. The enemy, therefore, needs to randomly select one of these destinations, as shown here:</p><div><img src="img/0655OT_07_23.jpg" alt="Creating the Patrol state"/><div><p>Creating Waypoint destinations in the Scene tab</p></div></div><p>To implement the destination selection for a <code class="literal">Patrol</code> state, the <code class="literal">Awake</code> function of <code class="literal">AI_Enemy</code> will first retrieve a list of all waypoints in the scene to be used later. We can do this using <code class="literal">Linq</code>, as shown in the following code sample 7-5. This example code retrieves a static array of all transforms for waypoints in the scene, in a private variable named <code class="literal">Waypoints</code>:</p><div><pre class="programlisting">01 //Find all gameobjects with waypoint
02 GameObject[] Waypoints = GameObject.FindGameObjectsWithTag("Waypoint");
03 
04 //Select all transform components from waypoints using Linq
05 WayPoints = (from GameObject GO in Waypoints
06                   select GO.transform).ToArray();</pre></div><p>Having retrieved a list of all waypoints, the <code class="literal">Patrol</code> state can be coded, as shown in the following code sample 7-6, which regularly selects waypoints as move new targets:</p><div><pre class="programlisting">01 //--------------------------------------------------
02 //This coroutine runs when object is in patrol state
03 public IEnumerator State_Patrol()
04 {
05 //Set current state
06 CurrentState = AI_ENEMY_STATE.PATROL;
07 
08 //Set Patrol State
09 ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.PATROL);
10 
11 //Pick a random waypoint
<strong>12 Transform RandomDest = WayPoints[Random.Range(0, WayPoints.Length)];</strong>
13 
14 //Go to destination
15 ThisAgent.SetDestination(RandomDest.position);
16 
17 //Loop forever while in patrol state
<strong>18 while(CurrentState == AI_ENEMY_STATE.PATROL)</strong>
19 {
20        //Check if we can see player
21        if(CanSeePlayer)
22        {
23             //If we can see player, then chase to attack 
24             StartCoroutine(State_Chase());
25             yield break;
26        }
27 
<strong>28        //Check if we have reached destination</strong>
29        if(Vector3.Distance(ThisTransform.position, RandomDest.position) &lt;= DistEps)

30        {
31              //Reached destination. Changed state back to Idle
32              StartCoroutine(State_Idle());
33              yield break;
34        }
35 
36        //Wait for next frame
37        yield return null;
38 }
39 }
40 //--------------------------------------------------</pre></div><p>The following are the <a id="id584" class="indexterm"/>comments for code sample 7-6:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 12</strong>: Here, the<a id="id585" class="indexterm"/> <code class="literal">Random.Range</code> function selects a random destination from the <code class="literal">Waypoints</code> array. This is passed as a destination argument to the <code class="literal">SetDestination</code> function of the <code class="literal">NavMeshAgent</code> component that sends the enemy to the destination.</li><li class="listitem" style="list-style-type: disc"><strong>Line 28</strong>: The function <code class="literal">Vector3.Distance</code> is used to determine whether the agent has reached the destination. This does not check for equality between the enemy position and destination position, because floating-point inaccuracy means we cannot guarantee that the two will ever be the same. Instead, it checks whether the enemy has come within a specified distance of the destination (<code class="literal">DistEps</code>), classifying that as having arrived.</li><li class="listitem" style="list-style-type: disc"><strong>Line 32</strong>: If the destination is reached, the enemy would return to <code class="literal">Idle</code>. After waiting for one cycle of the idle animation, the enemy would again enter into the <code class="literal">Patrol</code> state.</li><li class="listitem" style="list-style-type: disc"><strong>Line 21</strong>: Again, the <code class="literal">Patrol</code> state depends on whether the player is visible to the enemy. If so, they enter the <code class="literal">Chase</code> state.</li></ul></div><p>The Boolean variable <code class="literal">CanSeePlayer</code> indicates, for any frame, whether the player is currently visible to the <a id="id586" class="indexterm"/>enemy. This variable is updated on each frame. The process for this begins inside the <code class="literal">Update</code> function, as shown in the following code sample 7-7:</p><div><pre class="programlisting">01 void Update()
02 {
03 //Assume we cannot see player
04 CanSeePlayer = false;
05 
06 //If player not inside bounds then exit
07 if(!ThisCollider.bounds.Contains(PlayerTransform.position)) return;

08 
09 //Player is inside bounds, update line of sight
10 CanSeePlayer = HaveLineSightToPlayer(PlayerTransform);
11 }</pre></div><p>The key question for the <code class="literal">Update</code> function<a id="id587" class="indexterm"/> is whether the player is inside the box collider attached to the enemy; this box collider represents the enemy's view or range. If the player is inside that box, the player could possibly be visible to the enemy. In this case, further checks are required to be sure. This is where the <a id="id588" class="indexterm"/>
<code class="literal">HaveLineSightToPlayer</code> function is essential. This function returns a Boolean (<code class="literal">true</code>/<code class="literal">false</code>) value that indicates whether the player is visible to the enemy, as shown in the following code sample 7-8:</p><div><pre class="programlisting">//Function to return whether player can be seen right now
private bool HaveLineSightToPlayer(Transform Player)
{
//Get angle between enemy sight and player
float Angle = Mathf.Abs(Vector3.Angle(ThisTransform.forward, (Player.position-ThisTransform.position).normalized));

 
    //If angle is greater than field of view, we cannot see player
    if(Angle &gt; FieldOfView) return false;
 
    //Check with raycast- make sure player is not on other side of wall
    if(Physics.Linecast(ThisTransform.position, Player.position, SightMask)) return false;
 
    //We can see player
    return true;
 }</pre></div><p>As we saw in the earlier chapters, visibility is determined by a two-stage process. First, the angle between the enemy look at vector and the normalized vector, which points from the enemy to the player, decides the visibility. If the angle is less than the enemy's field-of-view angle, then the<a id="id589" class="indexterm"/> player would be in front of the enemy and they would be seen, provided no obstacles, such as walls, lie between the enemy and the player. The second test, performed by <code class="literal">Physics.Linecast</code>, determines whether an unbroken line can be drawn between the enemy and the player. If it can, then no obstacle would exist between them and the player would be seen.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec79"/>Creating the Chase state</h1></div></div></div><p>If the player is seen by the enemy and is not within attacking distance, the enemy would run to attack the player. This state, in which the enemy runs towards the player with hostile intent, is<a id="id590" class="indexterm"/> the <code class="literal">Chase</code> state. There are two main exit conditions for this state. If the enemy reaches attacking distance, they should change from the <code class="literal">Chase</code> state to the <code class="literal">Attack</code> state. In contrast, if the player disappears from sight, the enemy should continue to chase as best as they can for a while and then give up the chase if, after an interval, the player still cannot be sighted. Refer to the following code sample 7-9:</p><div><pre class="programlisting">01 //This coroutine runs when object is in chase state
02 public IEnumerator State_Chase()
03 {
04 //Set current state
05 CurrentState = AI_ENEMY_STATE.CHASE;
06 
07 //Set Chase State
08 ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.CHASE);
09 
10 //Loop forever while in chase state
11 while(CurrentState == AI_ENEMY_STATE.CHASE)
12 {
13        //Set destination to player
14        ThisAgent.SetDestination(PlayerTransform.position);
15 
16       //If we lose sight of player, keep chasing 
17       if(!CanSeePlayer)
18       {
19              //Begin time out
20              float ElapsedTime = 0f;
21 
22              //Continue to chase
23              while(true)
24              {
25                    //Increment time
26                    ElapsedTime += Time.deltaTime;
27 
28                    //Set destination to player
29 ThisAgent.SetDestination( PlayerTransform.position);
30 
31                   //Wait for next frame
32                   yield return null;
33 
34                   //Has timeout expired?
35                   if(ElapsedTime &gt;= ChaseTimeOut)
36                   {
37                          //If cannot see player, change to idle
38                          if(!CanSeePlayer)
39                          {
40                                //Change to idle 
41                                StartCoroutine(State_Idle());
42                                yield break;
43                          }
44                          else
45                                break; //can see player again
46                   }
47              }
48        }
49 
50        //If we have reached player then attack
51 if(Vector3.Distance(ThisTransform.position, PlayerTransform.position) &lt;= DistEps)

52        {
53              //We have reached distance, now attack
54              StartCoroutine(State_Attack());
55              yield break;
56        }
57 
58        //Wait until next
59        yield return null;
60 }
61 }</pre></div><p>The following are the comments for code sample 7-9:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Lines 17-48</strong>: During this phase, the <code class="literal">State</code> loop determines that the player visibility has been lost. When this happens, the enemy will continue to chase the player for a period of <code class="literal">ChaseTimeOut</code>. After this time elapses, the enemy checks for player <a id="id591" class="indexterm"/>visibility again. If the player is sighted at that time, the chase resumes as it did earlier. Otherwise, the enemy changes to the <code class="literal">Idle</code> state, ready to begin a new patrol in search of the player again.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 51-59</strong>: Here, the <code class="literal">Chase</code> state checks whether the enemy has come within the attack range (<code class="literal">DistEps</code>). If so, the FSM would enter <code class="literal">State_Attack</code>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec80"/>Creating the Attack state</h1></div></div></div><p>In the <code class="literal">Attack</code> state, the enemy continually attacks the player as long as they're visible. After an attack, the enemy must recover before launching a new attack. The only exit condition for this state is losing sight of the player. When this happens, the enemy returns to the <code class="literal">Chase</code> state <a id="id592" class="indexterm"/>and, from there, they either go back to the attack state or into <code class="literal">Idle</code>, depending on whether the player has been found, as shown in the following code sample 7-10:</p><div><pre class="programlisting">//This coroutine runs when object is in attack state
 public IEnumerator State_Attack()
 {
    //Set current state
    CurrentState = AI_ENEMY_STATE.ATTACK;
 
    //Set Chase State
    ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.ATTACK);
     //Stop nav mesh agent movement
<strong>    ThisAgent.Stop();</strong>
 
    //Set up timer for attack interval
    float ElapsedTime = 0f;
 
    //Loop forever while in attack state
    while(CurrentState == AI_ENEMY_STATE.ATTACK)
    {
         //Update timer
         ElapsedTime += Time.deltaTime;
 
        //Check if player has passed beyond the attack distance
if(!CanSeePlayer || Vector3.Distance(ThisTransform.position, PlayerTransform.position) &gt; DistEps)
          {
               //Change to chase
               StartCoroutine(State_Chase());
               yield break;
          }

          //Check attack delay
          if(ElapsedTime &gt;= AttackDelay)
          {
                //Reset counter
                ElapsedTime = 0f;
 
               //Launch attack
               PlayerTransform.SendMessage("ChangeHealth", -AttackDamage, SendMessageOptions.DontRequireReceiver);
          }
 
          //Wait until next frame
          yield return null;
    }
 }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec81"/>Creating the Seek-Health (or flee) state</h1></div></div></div><p>The <code class="literal">Seek-Health</code> state occurs when the enemy runs low on health and can restore it by collecting a medikit. This state is unlike most others, in that, it can be reached or entered from any state. The<a id="id593" class="indexterm"/> entering of this state doesn't depend on its relationship to others, but only on the player's health. Specifically, this state should be entered when the enemy's health is reduced beyond a minimum floor. As a result of this configuration, be sure to hook up the <code class="literal">Seek-Health</code> animation state in the Mecanim graph to the <strong>Any State</strong> node that allows the run animation to be triggered in any state, as shown here:</p><div><img src="img/0655OT_07_24.jpg" alt="Creating the Seek-Health (or flee) state"/><div><p>The Seek-Health state can be accessed from Any State</p></div></div><p>Each enemy maintains a <code class="literal">Health</code> variable; this variable is adjusted either up or down, depending on whether<a id="id594" class="indexterm"/> the enemy finds a medikit or is attacked. The change occurs inside the <a id="id595" class="indexterm"/>method <code class="literal">ChangeHealth</code>, and this is where we can determine whether a <code class="literal">SeekHealth</code> state must be initiated. The <code class="literal">ChangeHealth</code> function<a id="id596" class="indexterm"/> is public; it allows <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> to trigger it as an event, if required, as shown in the following code sample 7-11:</p><div><pre class="programlisting">//Event called health changed
 public void ChangeHealth(float Amount)
 {
    //Reduce health
    Health += Amount;
 
    //Should we die?
    if(Health &lt;= 0)
    {
          StopAllCoroutines();
          Destroy(gameObject);
          return;
    }
 
    //Check health danger level
    if(Health &gt; HealthDangerLevel) return;
 
    //Health is less than or equal to danger level, now seek health restores, if available
    StopAllCoroutines();
<strong>    StartCoroutine(State_SeekHealth());</strong>
 }</pre></div><p>The <code class="literal">State_SeekHealth</code> method can be coded, as shown in the following code sample 7-12:</p><div><pre class="programlisting">01 //This coroutine runs when object is in seek health state
02 public IEnumerator State_SeekHealth()
03 {
04 //Set current state
05 CurrentState = AI_ENEMY_STATE.SEEKHEALTH;
06 
07 //Set Chase State
08 ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.SEEKHEALTH);
09 
10 //This is the nearest health restore
11 HealthRestore HR = null;
12 
13 //Loop forever while in seek health state
14 while(CurrentState == AI_ENEMY_STATE.SEEKHEALTH)
15 {
16        //If health restore is not valid, then get nearest
17        <strong>if(HR == null) HR = GetNearestHealthRestore(ThisTransform);</strong>
18 
19        //There is an active health restore, so move there
20        ThisAgent.SetDestination(HR.transform.position);
21 
22        //If HR is null, then no more health restore, go to idle
23        if(HR == null || Health &gt; HealthDangerLevel)
24        {
25              //Change to idle
26              StartCoroutine(State_Idle());
27              yield break;
28 	      }
29 
30       //Wait until next frame
31       yield return null;
32 }
33 }</pre></div><p>The following are the comments for code sample 7-12:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 17</strong>: The <code class="literal">Health-Seek</code> state begins by finding the nearest medikit in the scene and uses it for<a id="id597" class="indexterm"/> the agent destination. This is, in a sense, cheating, because (of course) without remote viewing powers, the enemy should not be able to know where the nearest medikit is. However, remember that what matters is not what the enemy really knows but how it appears to the gamer. If the gamer doesn't know about this logic and cannot learn about it from appearances, then it would be of no significance. Also note that it's possible for the player or another enemy to collect the medikit before the enemy arrives at the destination. For this reason, on each frame, the enemy must determine whether the destination medikit is still valid, and if not, they must pick the next, nearest one.</li><li class="listitem" style="list-style-type: disc"><strong>Line 23</strong>: If there is no medikit available or the health has been restored to safe limits, the<a id="id598" class="indexterm"/> enemy would return to the <code class="literal">Idle</code> state.</li></ul></div><p>The <code class="literal">SeekHealth</code> state demands that we find and retrieve a reference to the nearest medikit in the scene. This is achieved using a <a id="id599" class="indexterm"/>
<code class="literal">GetNearestHealthRestore</code> method, as shown in the following code sample 7-13:</p><div><pre class="programlisting">01 //Function to get nearest health restore to Target in scene
02 private HealthRestore GetNearestHealthRestore(Transform Target)
03 {
04 //Get all health restores
05 HealthRestore[] Restores = Object.FindObjectsOfType&lt;HealthRestore&gt;();

06 
07 //Nearest
08 float DistanceToNearest = Mathf.Infinity;
09 
10 //Selected Health Restore
11 HealthRestore Nearest = null;
12 
13 //Loop through all health restores
14 foreach(HealthRestore HR in Restores)
15 {
16        //Get distance to this health restore
17 float CurrentDistance = Vector3.Distance(Target.position, HR.transform.position);

18 
19        //Found nearer health restore, so update
20        if(CurrentDistance &lt;= DistanceToNearest)
21        {
22              Nearest = HR;
23              DistanceToNearest = CurrentDistance;
24        }
25 }
26 
27 //Return nearest or null
28 return Nearest;
29 }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec82"/>Summary</h1></div></div></div><p>The complete AI project created in this chapter can be found in the book's companion files (code bundle) in the <code class="literal">ai</code> folder of this chapter. I recommend that you open it and then test it out. Using the first-person controller, the player can navigate the level, avoid enemies, and also attack when enemies are in range using the Space bar, as shown here:</p><div><img src="img/0655OT_07_25.jpg" alt="Summary"/><div><p>Testing the AI_Enemy class</p></div></div><p>There are, nonetheless, many ways in which the project can be improved further, for example, by adding multiple enemy types as well as varied strategies for each type, from taking cover to playing dead, and so on. However, nonetheless, we've come a long way and have developed Artificial Intelligence that relies on both a C# FSM as well as on a Mecanim FSM for animation playback.</p><p>In the next chapter, we'll leap out of the world of AI and into the world of editor customization to make game development smoother!</p></div></body></html>