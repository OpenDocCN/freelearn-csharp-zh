<html><head></head><body>
<div><h1 class="chapterNumber">5</h1>
<h1 class="chapterTitle" id="_idParaDest-103">Creating Advanced Blazor Components</h1>
<p class="normal">In the last chapter, we learned all the basics of creating a component. This chapter will teach us how to take our components to the next level.</p>
<p class="normal">This chapter will focus on some of the features that will make our components reusable, which will enable us to save time and also give us an understanding of how to use reusable components made by others.</p>
<p class="normal">We will also look at some built-in components that will help you by adding additional functionality (compared to using HTML tags) when you build your Blazor app.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Exploring binding</li>
<li class="bulletList">Actions and EventCallback</li>
<li class="bulletList">Using RenderFragment</li>
<li class="bulletList">Exploring the new built-in components</li>
</ul>
<h1 class="heading-1" id="_idParaDest-104">Technical requirements</h1>
<p class="normal">In this chapter, we will start building our components. For this, you’ll need the code we developed in <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>. You are good to go if you have followed the instructions in the previous chapters. If not, then make sure you clone/download the repository. The starting point for this chapter can be found in the <code class="inlineCode">chapter04</code> folder, and the finished <code class="inlineCode">chapter</code> is in <code class="inlineCode">chapter05</code>.</p>
<p class="normal">You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05</a>.</p>
<h1 class="heading-1" id="_idParaDest-105">Exploring binding</h1>
<p class="normal">When building applications, data<a id="_idIndexMarker213"/> is important, and we can use binding to show or change data. By using binding, you can connect variables within a component (so that it updates automatically) or by setting a component attribute. Perhaps the most fantastic thing is that by using binding, Blazor understands when it should update the UI and the variable (if the data changes in the UI).</p>
<p class="normal">In Blazor, there are two different ways that we can bind values to components, as follows:</p>
<ul>
<li class="bulletList">One-way binding</li>
<li class="bulletList">Two-way binding</li>
</ul>
<p class="normal">By using binding, we can send information between components and make sure we can update a value when we want to.</p>
<h2 class="heading-2" id="_idParaDest-106">One-way binding</h2>
<p class="normal">We have already discussed one-way binding<a id="_idIndexMarker214"/> in <em class="chapterRef">Chapter 4</em>, <em class="italic">Creating Basic Blazor Components</em>. Let’s<a id="_idIndexMarker215"/> look at the component again and continue building on it in this section.</p>
<p class="normal">In this section, we will combine parameters and binding.</p>
<p class="normal">The <code class="inlineCode">Counter.razor</code> example looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/counter" @rendermode InteractiveAuto
&lt;PageTitle&gt;Counter&lt;/PageTitle&gt;
&lt;h1&gt;Counter&lt;/h1&gt;
&lt;p role="status"&gt;Current count: @currentCount&lt;/p&gt;
&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;
@code {
    private int currentCount = 0;
    private void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre>
<p class="normal">The component will show the current count and a button that will increment the current count. This is one-way binding. Even though the button can change the value of <code class="inlineCode">currentCount</code>, it only flows in one direction to the screen.</p>
<p class="normal">Since this part is designed to demonstrate the functionality and theory and is not part of the finished project we are building, you don’t have to write or run this code. The source code for these components is available on GitHub.</p>
<p class="normal">We can add a parameter to the <code class="inlineCode">Counter</code> component. The code will then look like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/counterwithparameter"
@rendermode InteractiveAuto
&lt;h1&gt;Counter&lt;/h1&gt;
&lt;p&gt;Current count: @CurrentCount&lt;/p&gt;
&lt;button class="btn btn-primary" @onclick="IncrementCount"&gt;Click me&lt;/button&gt;
@code {
    [Parameter]
    public int IncrementAmount { get; set; } = 1;
    [Parameter]
    public int CurrentCount { get; set; } = 0;
    private void IncrementCount()
    {
        CurrentCount+=IncrementAmount;
    }
}
</code></pre>
<p class="normal">The code sample has <a id="_idIndexMarker216"/>two parameters, one for <code class="inlineCode">CurrentCount</code> and one for <code class="inlineCode">IncrementAmount</code>. By adding parameters to the components, we can change their <a id="_idIndexMarker217"/>behavior. This sample is, of course, a bit silly. The chances are that you won’t have any use for a component like this that just counts up when pressing a button. But it illustrates the idea very well.</p>
<p class="normal">We can now take the component and add it to another component. This is how we can create a reusable component and change its behavior by changing the value of the parameters.</p>
<p class="normal">We change its behavior like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/parentcounter"
@rendermode InteractiveAuto
&lt;CounterWithParameter IncrementAmount="@incrementamount" CurrentCount="@
currentcount"/&gt;
The current count is: @currentcount
@code {
    int incrementamount = 10;
    int currentcount = 0;
}
</code></pre>
<p class="normal">In this sample, we have two variables, <code class="inlineCode">incrementamount</code> and <code class="inlineCode">currentcount</code>, that we pass into our <code class="inlineCode">CounterWithParameter</code> component.</p>
<p class="normal">If we were to<a id="_idIndexMarker218"/> run this, we would see a <code class="inlineCode">Counter</code> component that <a id="_idIndexMarker219"/>counts in increments of <code class="inlineCode">10</code>. However, the <code class="inlineCode">currentcount</code> variable will not be updated since it is only a one-way binding (one direction).</p>
<p class="normal">To help us with that, we can implement two-way binding so that our parent component will be notified of any changes.</p>
<h2 class="heading-2" id="_idParaDest-107">Two-way binding</h2>
<p class="normal"><strong class="keyWord">Two-way binding</strong> binds values in<a id="_idIndexMarker220"/> both directions, and our <code class="inlineCode">Counter</code> component will be able <a id="_idIndexMarker221"/>to notify our parent component of any changes. In the next chapter, <em class="chapterRef">Chapter 6</em>, <em class="italic">Building Forms with Validation</em>, we will talk even more about two-way binding.</p>
<p class="normal">To make our <code class="inlineCode">CounterWithParameter</code> component bind in two directions, we need to add an <code class="inlineCode">EventCallback</code>. The name must consist of the parameter’s name followed by <code class="inlineCode">Changed</code>. This way, Blazor will update the value if it changes. In our case, we would need to name it <code class="inlineCode">CurrentCountChanged</code>. The code would then look like this:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter]
public EventCallback&lt;int&gt; CurrentCountChanged { get; set; }
private async Task IncrementCount()
{
    CurrentCount += IncrementAmount;
    await CurrentCountChanged.InvokeAsync(CurrentCount);
}
</code></pre>
<p class="normal">By merely using that naming convention, Blazor knows that <code class="inlineCode">CurrentCountChanged</code> is the event that will get triggered when a change to <code class="inlineCode">CurrentCount</code> occurs.</p>
<p class="normal"><code class="inlineCode">EventCallback</code> cannot be <code class="inlineCode">null</code>, so there is no reason to do a null check (more on that in the next section).</p>
<p class="normal">We also need to change how we listen for changes:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CounterWithParameterAndEvent IncrementAmount="@incrementamount" @bind-CurrentCount="currentcount"/&gt;
</code></pre>
<p class="normal">We need to add <code class="inlineCode">@bind-</code> before the <code class="inlineCode">CurrentCount</code> binding. You can also use the following syntax to set the name of the event:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;CounterWithParameterAndEvent IncrementAmount="@incrementamount" @bind-CurrentCount="currentcount" @bind-CurrentCount:event="CurrentCountChanged"/&gt;
</code></pre>
<p class="normal">By using <code class="inlineCode">:event</code>, we can tell Blazor<a id="_idIndexMarker222"/> exactly what event we want to use; in this <a id="_idIndexMarker223"/>case, the <code class="inlineCode">CurrentCountChanged</code> event.</p>
<p class="normal">In the next chapter, <em class="chapterRef">Chapter 6</em>, <em class="italic">Building Forms with Validation</em>, we will continue to look at binding with input/form components.</p>
<p class="normal">We can, of course, also create events using <strong class="keyWord">EventCallback</strong>.</p>
<h1 class="heading-1" id="_idParaDest-108">Actions and EventCallback</h1>
<p class="normal">To communicate changes, we can use <strong class="keyWord">EventCallback</strong>, as shown in the <em class="italic">Two-way binding</em> section. <code class="inlineCode">EventCallback&lt;T&gt;</code> differs a bit from <a id="_idIndexMarker224"/>what we might be used to in .NET. <code class="inlineCode">EventCallback&lt;T&gt;</code> is a class that is specially made for Blazor to be able to have the event callback exposed as a parameter for the component.</p>
<p class="normal">In .NET, in general, you can add multiple listeners to an event (multi-cast), but with <code class="inlineCode">EventCallback&lt;T&gt;</code>, you will only be able to add one listener (single-cast).</p>
<p class="normal">It is worth mentioning that you can use events the way you are used to from .NET in Blazor. However, you probably want to use <code class="inlineCode">EventCallback&lt;T&gt;</code> because there are many upsides to using <code class="inlineCode">EventCallback</code> over traditional .NET events, as follows:</p>
<ul>
<li class="bulletList">.NET events use classes, and <code class="inlineCode">EventCallback</code> uses structs. This means that in Blazor, we don’t have to perform a null check before calling <code class="inlineCode">EventCallback</code> because a struct cannot be null.</li>
<li class="bulletList"><code class="inlineCode">EventCallback</code> is asynchronous and can be awaited. When <code class="inlineCode">EventCallback</code> has been called, Blazor will automatically execute <code class="inlineCode">StateHasChanged</code> on the consuming component to ensure the component updates (if it needs to be updated).</li>
</ul>
<p class="normal">So, if you require multiple listeners, you can use <code class="inlineCode">Action&lt;T&gt;</code>. Otherwise, it would be best if you used <code class="inlineCode">EventCallback&lt;T&gt;</code>.</p>
<p class="normal">Some event types have event arguments that we can access. They are optional, so you don’t need to add them in most cases.</p>
<p class="normal">You can add them by specifying them in a method, or you can use a lambda expression like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;button @onclick="@((e)=&gt;message=$"x:{e.ClientX} y:{e.ClientY}")"&gt;Click me&lt;/button&gt;
</code></pre>
<p class="normal">When the <code class="inlineCode">button</code> is clicked, it will set a variable called <code class="inlineCode">message</code> to a string containing the mouse coordinates. The lambda has one parameter, <code class="inlineCode">e</code>, of the <code class="inlineCode">MouseArgs</code> type. However, you don’t have to specify the type, and the compiler understands what type the parameter is.</p>
<p class="normal">Now that we have added actions and <a id="_idIndexMarker225"/>used <strong class="keyWord">EventCallback</strong> to communicate changes, we will see how we can execute <strong class="keyWord">RenderFragment</strong> in the next section.</p>
<h1 class="heading-1" id="_idParaDest-109">Using RenderFragment</h1>
<p class="normal">To make our components <a id="_idIndexMarker226"/>even more reusable, we can supply them with a piece of Razor syntax. In Blazor, you can specify <strong class="keyWord">RenderFragment</strong>, which is a fragment of Razor syntax that you can execute and show.</p>
<p class="normal">There are two types of render elements, <code class="inlineCode">RenderFragment</code> and <code class="inlineCode">RenderFragment&lt;T&gt;</code>.<code class="inlineCode"> RenderFragment</code> is simply a Razor fragment without any input parameters, and <code class="inlineCode">RenderFragment&lt;T&gt;</code> has an input parameter that you can use inside the Razor fragment code by using the <code class="inlineCode">context</code> keyword. We won’t go into depth about how to use this now, but later in this chapter, we will talk about a component (<strong class="keyWord">Virtualize</strong>) that uses <code class="inlineCode">RenderFragment&lt;T&gt;</code>, and in the next chapter, <em class="chapterRef">Chapter 6</em>, <em class="italic">Building Forms with Validation</em>, we will implement a component using <code class="inlineCode">RenderFragment&lt;T&gt;</code>.</p>
<p class="normal">We can make <code class="inlineCode">RenderFragment</code> the default content inside of the component tags as well as giving it a default value. We will explore this next and build a component using these features.</p>
<p class="normal">When using components in a list, it can add some overhead. It needs to execute the whole lifetime cycle for each component. Here is where render fragments come to the rescue. We can create a method that returns a render fragment without the overhead of a component. Take this example:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/RenderFragmentTest"
@for (int i = 0; i &lt; 10; i++)
{
    @Render(i)
}
@code
{
    private RenderFragment Render(int number) 
    {
         return @&lt;p&gt;This is a render fragment @number&lt;/p&gt;;
    }
}
</code></pre>
<p class="normal">We have a component with a method that returns a render fragment. </p>
<p class="normal">The method could <a id="_idIndexMarker227"/>be static if we needed to use it in other components as well. When doing a loop like this, it will boost performance and will have a lower impact on memory consumption compared to having a component reference.</p>
<div><p class="normal"><strong class="keyWord">GRID COMPONENT</strong></p>
<p class="normal">If you want to dig deeper into render fragments, please check out <strong class="keyWord">Blazm.Components</strong>, which have a grid component that heavily uses <code class="inlineCode">RenderFragment&lt;T&gt;</code>. </p>
<p class="normal">You can find it on GitHub here: <a href="https://github.com/EngstromJimmy/Blazm.Components">https://github.com/EngstromJimmy/Blazm.Components</a>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-110">ChildContent</h2>
<p class="normal">By naming the <a id="_idIndexMarker228"/>render fragment <code class="inlineCode">ChildContent</code>, Blazor will automatically use whatever is between the component tags as content. This only works, however, if you are using a single render fragment; if you are using more than one, you will have to specify the <code class="inlineCode">ChildComponent</code> tag as well. We will build a component <a id="_idIndexMarker229"/>using a <code class="inlineCode">childcontent</code> render fragment in the next section.</p>
<h2 class="heading-2" id="_idParaDest-111">Default value</h2>
<p class="normal">We can supply <code class="inlineCode">RenderFragment</code> with a <a id="_idIndexMarker230"/>default value or set it in code by using an <code class="inlineCode">@</code> symbol:</p>
<pre class="programlisting code"><code class="hljs-code">@&lt;b&gt;This is a default value&lt;/b&gt;;
</code></pre>
<h2 class="heading-2" id="_idParaDest-112">Building an alert component</h2>
<p class="normal">To better understand how to use <a id="_idIndexMarker231"/>render fragments, let’s build an alert component that will use render fragments. The built-in templates use Bootstrap, so we will do the same for this component. Bootstrap has many components that are easy to import to Blazor. When working on big projects with multiple developers, building components is an easy way to ensure that everyone in a team is writing code the same way.</p>
<p class="normal">Let’s build a simple alert component based on Bootstrap:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a folder by right-clicking on <code class="inlineCode">SharedComponents project</code><strong class="screenText"> </strong>| <strong class="screenText">Add </strong>| <strong class="screenText">New folder</strong> and name the folder <code class="inlineCode">ReusableComponents</code>.</li>
<li class="numberedList">Create a new Razor component and name it <code class="inlineCode">Alert.razor</code>.</li>
<li class="numberedList">Replace the content with the following code in the <code class="inlineCode">Alert.razor</code> file:
        <pre class="programlisting code"><code class="hljs-code">&lt;div class="alert alert-primary" role="alert"&gt;
    A simple primary alert—check it out!
&lt;/div&gt;
</code></pre>
<p class="normal">The code is taken from Bootstrap’s web page, <a href="http://getbootstrap.com">http://getbootstrap.com</a>, and it shows an alert that looks like this:</p>
<figure class="mediaobject"><img alt="Figure 5.1 – The default look of a Bootstrap alert component " src="img/B21849_05_01.png"/></figure>
<p class="packt_figref">Figure 5.1: The default look of a Bootstrap alert component</p>
<p class="normal">There are two ways in which we could customize this <code class="inlineCode">alert</code> component. We could add a <code class="inlineCode">string</code> parameter for the message.</p>
<p class="normal">However, since this is a section on render fragments, we will explore the second option – yes, you guessed it, <em class="italic">render fragments</em>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Add a code section with a <code class="inlineCode">RenderFragment</code> property called <code class="inlineCode">ChildContent</code> and replace the alert text with the new property:
        <pre class="programlisting code"><code class="hljs-code">&lt;div class="alert alert-primary" role="alert"&gt;
    @ChildContent
&lt;/div&gt;
@code{
    [Parameter]
    public RenderFragment ChildContent { get; set; } =@&lt;b&gt;This is a default value&lt;/b&gt;;
}
</code></pre>
<p class="normal">Now we have a <code class="inlineCode">RenderFragment</code> and set a default value, displaying the fragment between <a id="_idIndexMarker232"/>the <code class="inlineCode">div</code> tags. We also want to add an <code class="inlineCode">enum</code> for the different ways you can style the alert box.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In the <code class="inlineCode">code</code> section, add an <code class="inlineCode">enum</code> containing the different styles available:
        <pre class="programlisting code"><code class="hljs-code">public enum AlertStyle
{
    Primary,
    Secondary,
    Success,
    Danger,
    Warning,
    Info,
    Light,
    Dark
}
</code></pre>
</li>
<li class="numberedList">Add a parameter/property for the <code class="inlineCode">enum</code> style:
        <pre class="programlisting code"><code class="hljs-code">[Parameter]
public AlertStyle Style { get; set; }
</code></pre>
</li>
<li class="numberedList">The final step is to update the <code class="inlineCode">class</code> attribute for <code class="inlineCode">div</code>. Change the <code class="inlineCode">class</code> attribute to look like this:
        <pre class="programlisting code"><code class="hljs-code">&lt;div class="@($"alert alert-{Style.ToString().ToLower()}")" role="alert"&gt;
</code></pre>
</li>
<li class="numberedList">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">Pages</code> folder, create a new razor component and name it <code class="inlineCode">AlertTest.razor</code>.
    <p class="normal">Replace the code with the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/alerttest"
@using SharedComponents.ReusableComponents
&lt;Alert Style="Alert.AlertStyle.Danger"&gt;
    This is a test
&lt;/Alert&gt;
&lt;Alert Style="Alert.AlertStyle.Success"&gt;
&lt;ChildContent&gt;
        This is another test
    &lt;/ChildContent&gt;
&lt;/Alert&gt;
&lt;Alert Style="Alert.AlertStyle.Success"/&gt;
</code></pre>
<p class="normal">The page shows three alert components:</p>
<p class="normal">The first one has the <code class="inlineCode">Danger</code> style, and we are not specifying what property to set for the <code class="inlineCode">This is a test</code> text, but by convention, it will use the property called <code class="inlineCode">ChildContent</code>.</p>
<p class="normal">In the <a id="_idIndexMarker233"/>second one, we have specified the <code class="inlineCode">ChildContent</code> property. If you use more render fragments in your component, you must set them like this, with full names.</p>
<p class="normal">In the last one, we didn’t specify anything that will give the property the default render fragment we specified in the component.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Run the <code class="inlineCode">BlazorServer</code> project and navigate to <code class="inlineCode">/AlertTest</code> to see the test page:</li>
</ol>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" src="img/B21849_05_02.png"/></figure>
<p class="packt_figref">Figure 5.2: Screenshot of the test page</p>
<p class="normal">We have <a id="_idIndexMarker234"/>finished our first reusable component!</p>
<p class="normal">Creating reusable components is how I prefer to make my Blazor sites because I don’t have to write the same code twice. This becomes even more apparent if you are working in a larger team. It makes it easier for all developers to produce the same code and end result, and with that, they can get a higher code quality and require fewer tests.</p>
<p class="normal">When we upgraded to the latest Bootstrap version, a few CSS classes were deprecated and replaced by others. Thankfully, we followed this approach by making reusable components, so we only had to change a handful of places. There were a couple of places where we still had some old code base (not using components), and it became very apparent that creating components was worth the effort.</p>
<p class="normal">Blazor has a bunch of built-in components. In the next section, we will dig deeper into what they are and how to use them.</p>
<p class="normal">When it comes to reusable components, we really invest some time in that. If you find yourself writing the same code twice, you might want to add that into a component. At my old job, we started using <code class="inlineCode">Radzen</code>, an open-source component library (among other things). At my current job, we use <code class="inlineCode">MudBlazor</code>. We use <code class="inlineCode">Progress Telerik</code> on our stream. Using third-party components can speed up the development, but often, these components are built for many different users. They can do a lot of things. This means that every single developer on our team now has access to all that power. With great power comes great responsibility.</p>
<p class="normal">In one of my presentations, I had that quote with a picture of Batman and text saying “Superman.” I didn’t get a single reaction. I have never failed with a joke like that. But joking aside, this means that all developers need to keep in mind how to use the components. Otherwise, the UI might look different depending on which developer uses the components. I put a lot of time into designing reusable components that help the team to be productive. Hiding the parameters we don’t use, giving the components reasonable default values. So, even if you use third-party components, try to figure out what you are using and perhaps create an abstraction on top of the third-party components. If you don’t know, the quote is from Spiderman, or Uncle Ben, to be precise. But it did remind me of one of my favorite puns. Do you know why Spiderman always has such witty comebacks? Because with great power comes great response-ability. I will show myself out.</p>
<h1 class="heading-1" id="_idParaDest-113">Exploring the new built-in components</h1>
<p class="normal">When Blazor first came out, there<a id="_idIndexMarker235"/> were a couple of things that were hard to do, and, in some cases, we needed to involve JavaScript to solve the challenge. In this section, we will look at some of the new components we got in .NET 5, all the way to .NET 8.</p>
<p class="normal">We will take a look at the following new components or functions:</p>
<ul>
<li class="bulletList">Setting the focus of the UI</li>
<li class="bulletList">Influencing the HTML head</li>
<li class="bulletList">Component virtualization</li>
<li class="bulletList">Error boundaries</li>
<li class="bulletList">Sections</li>
</ul>
<h2 class="heading-2" id="_idParaDest-114">Setting the focus of the UI</h2>
<p class="normal">One of my first <a id="_idIndexMarker236"/>Blazor blog posts was about how to set the focus on a<a id="_idIndexMarker237"/> UI element, but now this is built into the framework. The previous solution involved JavaScript calls to change the focus on a UI element.</p>
<p class="normal">By using <code class="inlineCode">ElementReference</code>, you can now set the focus on the element.</p>
<p class="normal">Let’s build a component to test the behavior of this new feature:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">Pages</code> folder, add a new Razor component, and name it <code class="inlineCode">SetFocus.razor</code>.</li>
<li class="numberedList">Open <code class="inlineCode">SetFocus.razor</code> and add a <code class="inlineCode">page</code> directive:
        <pre class="programlisting code"><code class="hljs-code">@page "/setfocus" @rendermode InteractiveAuto
</code></pre>
</li>
<li class="numberedList">Add an element reference:
        <pre class="programlisting code"><code class="hljs-code">@code {
    ElementReference textInput;
}
</code></pre>
<p class="normal"><code class="inlineCode">ElementReference</code> is precisely what it sounds like, a reference to an element. In this case, it is an input textbox.</p>
<p class="normal">In the <code class="inlineCode">_Imports</code> file, add the following line:</p>
<pre class="programlisting code"><code class="hljs-code">@using static Microsoft.AspNetCore.Components.Web.RenderMode
</code></pre>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Add the textbox and a button:
        <pre class="programlisting code"><code class="hljs-code">&lt;input @ref="textInput" /&gt;
&lt;button @onclick="() =&gt; textInput.FocusAsync()"&gt;Set focus&lt;/button&gt;
</code></pre>
<p class="normal">Using <code class="inlineCode">@ref</code>, we specify<a id="_idIndexMarker238"/> a reference to any type<a id="_idIndexMarker239"/> of component or tag that we can use to access the input box. The <code class="inlineCode">button onclick</code> method will execute the <code class="inlineCode">FocusAsync()</code> method and set the focus on the textbox.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Press <em class="keystroke">F5</em> to run the project and then navigate to <code class="inlineCode">/setfocus</code>.</li>
<li class="numberedList">Press the <strong class="screenText">Set focus</strong> button and notice how the textbox gets its focus.</li>
</ol>
<p class="normal">It could seem like a silly example since this only sets the focus, but it is a handy feature, and the <code class="inlineCode">autofocus</code> HTML attribute won’t work for Blazor. It would make more sense to call <code class="inlineCode">FocusAsync</code> in the <code class="inlineCode">OnAfterRender</code> method to get the focus change when we load the page, but that wouldn’t make it as cool a demo.</p>
<p class="normal">In my blog post, I had another approach. My goal was to set the focus of an element without having to use code. In the upcoming chapter, <em class="chapterRef">Chapter 6</em>, <em class="italic">Building Forms with Validation</em>, we will implement the <code class="inlineCode">autofocus</code> feature from my blog post but use the new .NET features instead.</p>
<p class="normal">The release of .NET 5 solves many things we previously had to write with JavaScript; setting the focus is one example. In .NET 6, we have a way to influence the HTML head.</p>
<h2 class="heading-2" id="_idParaDest-115">Influencing the HTML head</h2>
<p class="normal">Sometimes, we want <a id="_idIndexMarker240"/>to set our page’s title or change the social network<a id="_idIndexMarker241"/> meta tags. The <code class="inlineCode">head</code> tag is located in the <code class="inlineCode">App</code> component, and that part of the page isn’t reloaded/rerendered (only the components within the routes component are rerendered). In previous versions of Blazor, you had to write code for that yourself using JavaScript.</p>
<p class="normal">But .NET has a new component called <code class="inlineCode">HeadOutlet</code> that can solve that.</p>
<p class="normal">To use these components, we will create a page to view one of our blog posts. And we will use many of the techniques we have learned:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">Home.razor</code>.</li>
<li class="numberedList">Change the <code class="inlineCode">foreach</code> loop to look like this:
        <pre class="programlisting code"><code class="hljs-code">&lt;li&gt;&lt;a href="/Post/@p.Id"&gt;@p.Title&lt;/a&gt;&lt;/li&gt;
</code></pre>
<p class="normal">We added a link to the title to look at one blog post. Notice how we can use the <code class="inlineCode">@</code> symbol inside the <code class="inlineCode">href</code> attribute to get the ID of the post.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">In the Pages folder, add a Razor component, and name it <code class="inlineCode">Post.razor</code>.</li>
<li class="numberedList">In the <code class="inlineCode">code</code> section, add a parameter that will hold the ID of the post:
        <pre class="programlisting code"><code class="hljs-code">[Parameter]
public string BlogPostId { get; set; }
</code></pre>
<p class="normal">This will hold the ID of the blog post that comes from the URL.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Add a <code class="inlineCode">page</code> directive to get the set, the URL, and the ID:
        <pre class="programlisting code"><code class="hljs-code">@page "/post/{BlogPostId}"
</code></pre>
<p class="normal">The <code class="inlineCode">page</code> directive will set the URL for our blog post to <code class="inlineCode">/post/</code>, followed by the ID of the post. We don’t have to add a <code class="inlineCode">using</code> statement to all our components. Instead, open <code class="inlineCode">_Imports.razor</code> and add the following namespaces:</p>
<pre class="programlisting code"><code class="hljs-code">@using Data.Models.Interfaces
@using Data.Models
</code></pre>
<p class="normal">This will ensure that all our components will have these namespaces by default.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Open <code class="inlineCode">Post.razor</code> again and, just beneath the <code class="inlineCode">page</code> directive, inject the API (the namespace is now supplied from <code class="inlineCode">_Imports.razor</code>):
        <pre class="programlisting code"><code class="hljs-code">@inject IBlogApi _api
@inject NavigationManager _navman
</code></pre>
<p class="normal">Our API will now be injected into the component, and we can retrieve our blog post. We also have access to a navigation manager.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">In the <code class="inlineCode">code</code> section, add a property for our blog post:
        <pre class="programlisting code"><code class="hljs-code">public BlogPost? BlogPost { get; set; }
</code></pre>
<p class="normal">This will contain the blog post we want to show on the page.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">To load the blog <a id="_idIndexMarker242"/>post, add the following <a id="_idIndexMarker243"/>code:
        <pre class="programlisting code"><code class="hljs-code">protected async override Task OnParametersSetAsync()
{
    BlogPost=await _api.GetBlogPostAsync(BlogPostId);
    await base.OnParametersSetAsync();
}
</code></pre>
<p class="normal">In this case, we are using the <code class="inlineCode">OnParametersSetAsync()</code> method. This is to make sure that the parameter is set when we get data from the database and that the content updates when the parameter changes.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">We must also show the post and add the necessary <code class="inlineCode">meta</code> tags. To do that, add the following code just above the <code class="inlineCode">code</code> section:
        <pre class="programlisting code"><code class="hljs-code">@if (BlogPost != null)
{
    &lt;PageTitle&gt;@BlogPost.Title&lt;/PageTitle&gt;
&lt;HeadContent&gt;
&lt;meta property="og:title"
 content="@BlogPost.Title" /&gt;
&lt;meta property="og:description" content="@(new
      string(BlogPost.Text.Take(100).ToArray()))" /&gt;
&lt;meta property="og:image" content=
 "@($"{_navman.BaseUri}/pathtoanimage.png")" /&gt;
&lt;meta property="og:url" content="@_navman.Uri" /&gt;
&lt;meta name="twitter:card" content="@(new string(BlogPost.Text.Take(100).ToArray()))" /&gt;
&lt;/HeadContent&gt;
&lt;h2&gt;@BlogPost.Title&lt;/h2&gt;
    @((MarkupString)BlogPost.Text)
    
}
</code></pre>
<p class="normal">When the<a id="_idIndexMarker244"/> page is first loaded, the <code class="inlineCode">BlogPost</code> parameter can be null, so we first need to check whether we should show the content at all.</p>
<p class="normal">By adding the <code class="inlineCode">Title</code> component, Blazor will set the title of our site to, in this instance, the title of our blog post.</p>
<p class="normal">According to the<a id="_idIndexMarker245"/> information I <a id="_idIndexMarker246"/>gathered on <strong class="keyWord">Search Engine Optimization</strong> (<strong class="keyWord">SEO</strong>), the meta tags we have added are the bare minimum to use with Facebook and X (formerly known as Twitter). We don’t have an image for each blog post, but we can have one that is site-wide (for all blog posts) if we would like. Just change <code class="inlineCode">Pathtoanimage.png</code> to the name of the image and put the image in the <code class="inlineCode">wwwroot</code> folder.</p>
<p class="normal">If the blog post is loaded, then show an <code class="inlineCode">H3</code> tag with the title and the text beneath that. You might remember <code class="inlineCode">MarkupString</code> from <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>. This will output the string from our blog post without changing the HTML (not escaping the HTML).</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">Run the project by pressing <em class="keystroke">F5</em> and navigate to a blog post to see the title change:</li>
</ol>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" src="img/B21849_05_03.png"/></figure>
<p class="packt_figref">Figure 5.3: Blog post screenshot</p>
<p class="normal">Our blog is <a id="_idIndexMarker247"/>starting to take form. We have a list of blog posts, and <a id="_idIndexMarker248"/>can view a single post; we are far from done but we’re well on our way.</p>
<h2 class="heading-2" id="_idParaDest-116">Component virtualization</h2>
<p class="normal"><strong class="keyWord">Virtualize</strong> is a <a id="_idIndexMarker249"/>component in Blazor that will make sure that it only renders the <a id="_idIndexMarker250"/>components or rows that can fit the screen. If you have a large list of items, rendering all of them will have a big impact on memory.</p>
<p class="normal">Many third-party component vendors offer grid components with the same virtualization function. The <code class="inlineCode">Virtualize</code> component was, in my opinion, the most exciting thing in the .NET 5 release.</p>
<p class="normal">The <code class="inlineCode">Virtualize</code> component will calculate how many items can fit on the screen (based on the size of the window and the height of an item). Blazor will add a <code class="inlineCode">div</code> tag before and after the content list if you scroll the page, ensuring that the scrollbar is showing the correct position and scale (even though there are no items rendered).</p>
<p class="normal">The <code class="inlineCode">Virtualize</code> component works just like a <code class="inlineCode">foreach</code> loop.</p>
<p class="normal">The following is the code we currently have in our <code class="inlineCode">Home.razor</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ul&gt;
    @foreach (var p in posts)
    {
        &lt;li&gt;&lt;a href="/Post/@p.Id"&gt;@p.Title&lt;/a&gt;&lt;/li&gt;
    }
&lt;/ul&gt;
</code></pre>
<p class="normal">Right now, it will show all our blog posts in our database in a long list. Granted, we only have a few right now, but we might have many posts one day.</p>
<p class="normal">We can change the code (don’t change the code just yet) to use the new <code class="inlineCode">Virtualize</code> component by changing it to the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Virtualize Items="posts" Context="p"&gt;
&lt;li&gt;&lt;a href="/Post/@p.Id"&gt;@p.Title&lt;/a&gt;&lt;/li&gt;
&lt;/Virtualize&gt;
</code></pre>
<p class="normal">Instead of the <code class="inlineCode">foreach</code> loop, we use the <code class="inlineCode">Virtualize</code> component and add a render fragment that shows how each item should be rendered. The <code class="inlineCode">Virtualize</code> component uses <code class="inlineCode">RenderFragment&lt;T&gt;</code>, which, by default, will send in an item of type <code class="inlineCode">T</code> to the render fragment. In the case of the <code class="inlineCode">Virtualize</code> component, the object will be one blog post (since items are <code class="inlineCode">List&lt;T&gt;</code> of blog posts). We access each post with the variable named <code class="inlineCode">context</code>. However, we can use the <code class="inlineCode">Context</code> property on the <code class="inlineCode">Virtualize</code> component to specify another name, so instead of <code class="inlineCode">context</code>, we are now using <code class="inlineCode">p</code>.</p>
<p class="normal">The <code class="inlineCode">Virtualize</code> component is<a id="_idIndexMarker251"/> even more powerful than this, as we will<a id="_idIndexMarker252"/> see in the next feature that we implement:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">Home.razor</code>.</li>
<li class="numberedList">Delete the <code class="inlineCode">OnInitializedAsync</code> method and <code class="inlineCode">protected List&lt;BlogPost&gt; posts = new List&lt;BlogPost&gt;()</code>; we don’t need them anymore.</li>
<li class="numberedList">Change the loading of the post to <code class="inlineCode">Virtualize</code>:
        <pre class="programlisting code"><code class="hljs-code">&lt;ul&gt;
&lt;Virtualize ItemsProvider="LoadPosts" Context="p"&gt;
&lt;li&gt;&lt;a href="/Post/@p.Id"&gt;@p.Title&lt;/a&gt;&lt;/li&gt;
&lt;/Virtualize&gt;
&lt;/ul&gt;
</code></pre>
<p class="normal">In this case, we are using the <code class="inlineCode">ItemsProvider</code> delegate, which will take care of getting posts from our API.</p>
<p class="normal">We pass in a method called <code class="inlineCode">LoadPosts</code>, which we also need to add to the file.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Now, let’s add the <code class="inlineCode">LoadPosts</code> method by adding the following code:
        <pre class="programlisting code"><code class="hljs-code">public int totalBlogposts { get; set; }
private async ValueTask&lt;ItemsProviderResult&lt;BlogPost&gt;&gt; LoadPosts(ItemsProviderRequest request)
{
    if (totalBlogposts == 0)
    {
        totalBlogposts = await _api.GetBlogPostCountAsync();
    }
    var numblogposts = Math.Min(request.Count, totalBlogposts - request.StartIndex);
    var blogposts= await _api.GetBlogPostsAsync(numblogposts,request.StartIndex);
    return new ItemsProviderResult&lt;BlogPost&gt;(blogposts, totalBlogposts);
}
</code></pre>
</li>
</ol>
<p class="normal">We will add a <code class="inlineCode">totalBlogposts</code> property <a id="_idIndexMarker253"/>where we store how many posts we currently have<a id="_idIndexMarker254"/> in our database. The <code class="inlineCode">LoadPost</code> method returns <code class="inlineCode">ValueTask</code> with <code class="inlineCode">ItemsProviderResult&lt;Blogpost&gt;</code>. The method has <code class="inlineCode">ItemsProviderRequest</code> as a parameter, which contains the number of posts the <code class="inlineCode">Virtualize</code> component wants and how many it wants to skip.</p>
<p class="normal">If we don’t know how many total posts we have, we need to retrieve that information from our API by calling the <code class="inlineCode">GetBlogPostCountAsync</code> method. Then, we need to figure out how many posts we should get; either we get as many posts as we need, or we get all the remaining posts (whatever value is the smallest).</p>
<p class="normal">Then, we call our API to get the actual posts by calling <code class="inlineCode">GetBlogPostsAsync</code> and returning <code class="inlineCode">ItemsProviderResult</code>.</p>
<p class="normal">We have implemented a <code class="inlineCode">Virtualize</code><strong class="keyWord"> </strong>component that will load and render only the number of blog posts needed to fill the screen. But this is an interactive component that needs interactivity to work. If you try to run the project now, you will notice that the screen is blank. If we add <code class="inlineCode">@rendermode InteractiveServer</code> to the <code class="inlineCode">Home</code> component, it starts to work again. Right now, <code class="inlineCode">InteractiveServer</code> is the only thing we can use. This is the only scenario we have everything set up for when it comes to DI.</p>
<h2 class="heading-2" id="_idParaDest-117">Error boundaries</h2>
<p class="normal">In .NET 6, we have a very handy component to handle errors called <strong class="keyWord">ErrorBoundary</strong>.</p>
<p class="normal">We can surround the component <a id="_idIndexMarker255"/>with an <code class="inlineCode">ErrorBoundary</code> component; if an <a id="_idIndexMarker256"/>error occurs, it will show an error message instead of the whole page failing:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ErrorBoundary&gt;
&lt;ComponentWithError /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
<p class="normal">This component takes two render fragments. By specifying it as in the previous example, we only set the <code class="inlineCode">ChildContent</code> render fragment. This is the default.</p>
<p class="normal">We can also supply a custom error message like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ErrorBoundary&gt;
&lt;ChildContent&gt;
&lt;ComponentWithError /&gt;
&lt;/ChildContent&gt;
&lt;ErrorContent&gt;
&lt;h1 style="color: red;"&gt;Oops… something broke&lt;/h1&gt;
&lt;/ErrorContent&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
<p class="normal">In this sample, we specify <code class="inlineCode">ChildContent</code>, which makes it possible for us to specify more than one property, as is the case with <code class="inlineCode">ErrorContent</code>. This is a great component to extend and create your own functionality. You can get access to the exception by using the <code class="inlineCode">context</code> parameter (as we did with <code class="inlineCode">virtualize</code>):</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ErrorBoundary Context="ex"&gt;
&lt;ChildContent&gt;
&lt;p&gt;@(1/zero)&lt;/p&gt;
&lt;/ChildContent&gt;
&lt;ErrorContent&gt;
       An error occurred
       @ex.Message
    &lt;/ErrorContent&gt;
&lt;/ErrorBoundary&gt;
@code {
    int zero = 0;
}
</code></pre>
<p class="normal">This is a great way to handle errors in the UI.</p>
<h2 class="heading-2" id="_idParaDest-118">Sections</h2>
<p class="normal">.NET 8 gives us the ability to add sections. You might remember a similar feature of <code class="inlineCode">WebForms</code>.</p>
<p class="normal">We can use the <code class="inlineCode">SectionOutlet</code> component <a id="_idIndexMarker257"/>to define an area in a layout component where <a id="_idIndexMarker258"/>we want to insert content. Then, inside our components, we can add a <code class="inlineCode">SectionContent</code> where we add the content we want to appear in the outlet.</p>
<p class="normal">If we have more than one <code class="inlineCode">SectionContent</code> referencing the <code class="inlineCode">SectionOutlet</code>, it will render the latest <code class="inlineCode">SectionContent</code>. We can refer to a <code class="inlineCode">SectionOutlet</code> by using a section name or a section ID. A section name is simply a string that we can use. The ID is an object, so we can get a nicer syntax to keep track of our sections.</p>
<p class="normal">We can add a section to the layout file and add content to that section from our components. It’s a layout thing. Let’s say we want to add contextual menus. For example, that way, we could change a menu that is in a completely different component.</p>
<p class="normal">Let’s look at some code.</p>
<p class="normal">First, we might need to add this namespace:</p>
<pre class="programlisting code"><code class="hljs-code">Microsoft.AspNetCore.Components.Sections;
</code></pre>
<p class="normal">Preferably in the _imports.razor file (since this is one of the build-in components.</p>
<p class="normal">In a layout component, we add an outlet like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;SectionOutlet SectionName="top-header"/&gt;
</code></pre>
<p class="normal">Then, in our component, we can add a <code class="inlineCode">SectionContent</code> like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;SectionContent SectionName="top-header"&gt;
&lt;b&gt;Test&lt;/b&gt;
&lt;/SectionContent&gt;
</code></pre>
<p class="normal">If we instead want to use the section ID, we can do it like this: In the layout file, let’s assume it is called <code class="inlineCode">MainLayout</code>.</p>
<pre class="programlisting code"><code class="hljs-code">&lt;SectionOutlet SectionId="MainLayout.TopHeader"/&gt;
</code></pre>
<p class="normal">In the code section of <code class="inlineCode">MainLayout</code>:</p>
<pre class="programlisting code"><code class="hljs-code">@code
{
    public static SectionOutlet TopHeader = new()
}
</code></pre>
<p class="normal">Then, inside the <a id="_idIndexMarker259"/>component, we<a id="_idIndexMarker260"/> change it to this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;SectionContent SectionId="Layout.MainLayout.TopHeader"&gt;
&lt;b&gt;Using SectionId&lt;/b&gt;
&lt;/SectionContent&gt;
</code></pre>
<p class="normal">This is a great way to change the layout files. By doing this, we can create more advanced layouts that work with every page/component. We can move more of the layout to the layout file instead of putting it in each component. I love this feature. This will clean up so much code.</p>
<h1 class="heading-1" id="_idParaDest-119">Summary</h1>
<p class="normal">In this chapter, we looked at more advanced scenarios for building components. Building components is what Blazor is all about. Components also make it easy to make changes along the way because there is only one point where you must implement the change. We also implemented our first reusable component, which will help maintain the same standard across the team and reduce duplicated code.</p>
<p class="normal">We also used some Blazor features to load and display data.</p>
<p class="normal">In the next chapter, we will look at forms and validation to start building the administration part of our blog.</p>
<h1 class="heading-1" id="_idParaDest-120">Join our community on Discord </h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/WebDevBlazor3e">https://packt.link/WebDevBlazor3e</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code2668029180838459906.png"/></p>
</div>
</body></html>