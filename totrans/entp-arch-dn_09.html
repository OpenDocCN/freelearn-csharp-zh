<html><head></head><body>
<div id="_idContainer082">
<h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.2.1">Exploring Domain-Driven Design and Semantics</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The previous chapter ended with a promise to provide a method to deal with a pivotal format and the design of an evolution-ready, functionally correct entity when no standard exists in this precise domain. </span><span class="koboSpan" id="kobo.3.2">This is the subject of our </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">present chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In order to reach this objective, a very important prerequisite is to keep thinking in </span><em class="italic"><span class="koboSpan" id="kobo.6.1">functional terms</span></em><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">I know most of you will certainly have a technical background and may wonder when we are finally going to get to the code. </span><span class="koboSpan" id="kobo.7.3">Having you wait this long without doing anything technical has been done on purpose and is part of the pedagogical journey provided by the reading of this book. </span><span class="koboSpan" id="kobo.7.4">You have to stick to functional and business-related concepts as long as you can because, as soon as you transform this knowledge into software, it gets solidified and way harder to modify afterward. </span><span class="koboSpan" id="kobo.7.5">I promise that, as soon as the next chapter, we will start getting our hands dirty with some technical decisions. </span><span class="koboSpan" id="kobo.7.6">Then, in a few chapters, we will put some code together to actually show in very concrete terms what all this translates into. </span><span class="koboSpan" id="kobo.7.7">But for now, let’s stick to business functions only and think about our format without any relationship to anything technical, just like we are taught by clean architecture. </span><span class="koboSpan" id="kobo.7.8">This is the main guarantee we have to build the right information system. </span><span class="koboSpan" id="kobo.7.9">Actually, if you remember only one thing from this whole book, I would love it to be this practice: think as long as you need to understand your problem from the functional point of view, and only then start thinking about how to deal with it from a technical point of view. </span><span class="koboSpan" id="kobo.7.10">Delay implementation as much as possible; think of data, not databases; think of models and business rules, not attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and methods.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">If you do so, you will soon have some questions about the vocabulary used in the business domain. </span><span class="koboSpan" id="kobo.9.2">A technical approach has the huge drawback of constraining the approach. </span><span class="koboSpan" id="kobo.9.3">But we should at least recognize that it pushes us into being extremely precise, as computers are as dumb as a box of rocks, so they oblige us to be explicit in information designation. </span><span class="koboSpan" id="kobo.9.4">Considering semantics and using a method called </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">DDD</span></strong><span class="koboSpan" id="kobo.13.1">) will</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.14.1"> help us to be precise in functional terms, but without depending on anything technical that would hinder our evolution later on; this way, we get the best of </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">both worlds.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Once the principles of this method are understood, again, we will turn back to our long-run example and apply DDD to our sample information system in order to draw its bounded contexts and describe its ubiquitous language (we will soon explain these two </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">important concepts).</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">Finally, the chapter will explain how all of this applies to clean information systems as we try to design them, and what the links to the concepts of service and API are, which we have exposed in the previous chapter. </span><span class="koboSpan" id="kobo.18.2">There, we will talk about the importance of the life cycle analysis of a business entity and discuss a few recent orientations in information </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">systems architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">A functional approach to a </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">functional problem</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">The importance </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">of semantics</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">DDD</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Application to clean information </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">system architecture</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Link to the API </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">and services</span></span><a id="_idTextAnchor320"/></li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.31.1">A functional approach to a functional problem</span></h1>
<p><span class="koboSpan" id="kobo.32.1">As</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.33.1"> explained in the introduction, it is of utmost importance to use a functional approach to solve the problem of designing a pivotal format. </span><span class="koboSpan" id="kobo.33.2">In the four-layer CIGREF map, all layers are a consequence of the one above. </span><span class="koboSpan" id="kobo.33.3">Hence, starting with layer 3 (software) without having a correct design of the context studied in layer 2 (business capabilities) is bound to create malfunctioning software. </span><span class="koboSpan" id="kobo.33.4">This is made much worse by the fact that once turned into software, the error will be fixed in code and possibly shared through APIs used by many users and machines all over your information system or external ones, which may make it almost impossible to correct the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">design error.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">The vast majority of IT problems come from this lack of business alignment that we have talked about a lot and, right now, we are at the root of the problem: the design of the business entities. </span><span class="koboSpan" id="kobo.35.2">When we do not have any dedicated standard to rely on and spare us of a complex reasoning process, filled with risks of misunderstandings that may have important consequences, we will have to pay particular attention to any details, which, in practice, means extensive and guaranteed access to experts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">business domain.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">A standard </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.38.1">is generally expressed in technical terms in order to be extremely precise and irrefutable, but it represents, in a shared, acknowledged way, a functional concept. </span><span class="koboSpan" id="kobo.38.2">For example, RFC 7519 describes what a JSON Web Token is, and what the issuer, subject, expiration time, and all other attributes are for, but it does so in a very constrained way (with a precise definition of </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">must</span></strong><span class="koboSpan" id="kobo.40.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">should</span></strong><span class="koboSpan" id="kobo.42.1">, for example, in the dedicated RFC 2119, which indeed makes it an RFC about how to write other RFCs) and with very concrete translations, such as the exact name of the JSON attribute, which must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">iss</span></strong><span class="koboSpan" id="kobo.44.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">sub</span></strong><span class="koboSpan" id="kobo.46.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">exp</span></strong><span class="koboSpan" id="kobo.48.1">, for the information we have cited previously. </span><span class="koboSpan" id="kobo.48.2">This way, we can say that a norm both lives in layers 2 and 3 of the CIGREF map and binds them together. </span><span class="koboSpan" id="kobo.48.3">This is why norms and standards are so important because they are the concrete actors of business/IT alignment. </span><span class="koboSpan" id="kobo.48.4">To give a second example, OpenAPI is also a great illustration of how norms and standards bridge the potential gap between functional and software approaches, by providing a list of all functions that should be accessible through an API on a given business domain, while, at the same time, giving a precise JSON or YAML-based technical description of what this means in the data streams that will be exchanged </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">between servers.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">A pivotal format should aim at the same result by joining the functional aspect and the technical representation of it. </span><span class="koboSpan" id="kobo.50.2">This is why it is important to describe it with technical means, whatever they are. </span><span class="koboSpan" id="kobo.50.3">These technical means can be XML Schema or DTD if you are using SOAP web services, or OpenAPI if you are designing API and their components; they can even be a simple Excel file showing the exact names and structures of the data messages you intend to move around your system. </span><span class="koboSpan" id="kobo.50.4">The only important thing is that it is technically written, but not </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">technically restrictive.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">The phrase “technically written, but not technically restrictive,” may seem paradoxical, so, let me explain this. </span><span class="koboSpan" id="kobo.52.2">The technical writing of the norm is important because it ensures preciseness (nobody wants a vague description of something important). </span><span class="koboSpan" id="kobo.52.3">This is why a new API has got to be described in an OpenAPI contract. </span><span class="koboSpan" id="kobo.52.4">This way, there is no place for argument over how an attribute is written, with capital letters or not, or only the first one; for example, it is written in computerized text in the OpenAPI JSON or YAML, so there is no possible discussion. </span><span class="koboSpan" id="kobo.52.5">However, at the same time, attention should be paid to the fact that the pivotal format (like any norm) should never be constrained by any technical issues. </span><span class="koboSpan" id="kobo.52.6">We all agree that a norm to represent, say, countries, would not make any sense if the authors of the norm used some Java primitives that would make it difficult to use the norm with another platform. </span><span class="koboSpan" id="kobo.52.7">It would be a limited, technical way of doing it, but definitely not a real norm. </span><span class="koboSpan" id="kobo.52.8">The same should be applied to your pivotal format design and it should never expose anything from your technical implementation, even if it is expressed in a </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">functional way.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">By the way, this</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.55.1"> is yet another reason for always designing from the functional point of view before thinking of software. </span><span class="koboSpan" id="kobo.55.2">If you force yourself during this period to let go of the database choice, for example, you reduce the possibility of creating a pivotal format that is bound to your database orientation. </span><span class="koboSpan" id="kobo.55.3">I understand this might sound a bit unrealistic and you might wonder how someone could bind the design of data to a database. </span><span class="koboSpan" id="kobo.55.4">Well, the devil lies in details and there are sadly many ways—some subtler than others—to fall into </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">this trap:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.57.1">One might express data attributes with types that are only available in some databases and not others. </span><span class="koboSpan" id="kobo.57.2">If we are used to talking about </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">VARCHAR(n)</span></strong><span class="koboSpan" id="kobo.59.1">, for example, we might imply in our data design that there is a limit to the size of an attribute, though it is not justified from the functional point of view. </span><span class="koboSpan" id="kobo.59.2">Everyone has seen an application that truncates family names when they are too long, although this creates an incorrect </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">data value.</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">The same can happen for date formats. </span><span class="koboSpan" id="kobo.61.2">The norm-referenced ISO 8601 (also nicknamed as ISO-Time) makes a clear difference between administrative dates and instants, but most databases do not. </span><span class="koboSpan" id="kobo.61.3">If we think in SQL terms, we might miss this </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">essential difference.</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">Identifiers can be badly influenced by the well-known standard database mechanisms. </span><span class="koboSpan" id="kobo.63.2">The autogeneration of identifiers by SQL databases, based on counters, is quite practical but these identifiers scale very poorly and are one cause for the lack of distribution of such databases. </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">Globally unique identifiers</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">GUIDs</span></strong><span class="koboSpan" id="kobo.67.1">) are </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.68.1">better and, quite often, used by more modern systems such as NoSQL databases. </span><span class="koboSpan" id="kobo.68.2">However, both will definitely be the wrong choice if you need to assign a unique identifier for an entity representing a patient in a health information system since the largely acknowledged (and sometimes legally required) identifier in this particular case is a national </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">security number.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.70.1">There are actually so many other cases where some technical knowledge can waste the design of a pivotal format that I have personally formed the habit of always designing them by animating groups only made of Product Owners, even going as far as detecting those with a technical background and excluding them from the design group in some cases. </span><span class="koboSpan" id="kobo.70.2">I still could badly influence the process, as I have a technical approach, but I generally help </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.71.1">design pivotal formats on business domains I do have not much experience with, so, it is easy to play the role of a complete beginner, knowing nothing about the business domain and then focusing only on this comprehension. </span><span class="koboSpan" id="kobo.71.2">Also, I know from experience how early technical thinking can have a negative impact, so I always think of what could go wrong because </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">of this.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Sometimes, the coupling can be extremely subtle. </span><span class="koboSpan" id="kobo.73.2">For example, let’s take a URL such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">https://demoeditor.com/library/books/978-2409002205</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">It sounds like a great identifier, since it is based on norms only (URLs, ISBNs for books, and a DNS for the host) and there is apparently nothing else. </span><span class="koboSpan" id="kobo.75.3">However, one could argue that prefixing with the (</span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">https://</span></strong><span class="koboSpan" id="kobo.77.1">) scheme is already a hint for how we are going to technically access these functional entities, in this case, through web-based APIs. </span><span class="koboSpan" id="kobo.77.2">Luckily, a solution always exists and, in this case, this</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.78.1"> is through resorting to </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">URNs</span></strong><span class="koboSpan" id="kobo.80.1"> (short for, </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Uniform Resource Names</span></strong><span class="koboSpan" id="kobo.82.1">) instead of URLs (both are types of Uniform Resource Identifiers). </span><span class="koboSpan" id="kobo.82.2">Our example entity could then be identified extremely precisely but without any reference to technical implementation by </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">urn:com:demoeditor:library:books:978-2409002205</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">At this point in the book, you should hopefully be convinced that taking the functional point of view on a problem is always the best option and that the technical aspects should come afterward. </span><span class="koboSpan" id="kobo.86.2">This being said we need some method to analyze a problem from a functional point of view only, and this is how semantics can </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">be</span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.88.1"> used.</span></span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.89.1">The importance of semantics</span></h1>
<p><span class="koboSpan" id="kobo.90.1">In the </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.91.1">previous section, we demonstrated how to use a technically-backed but not technically-coupled approach to define entity formats that will be precise. </span><span class="koboSpan" id="kobo.91.2">However, we have not yet touched upon the functional analysis itself and, looking at our example URN, </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">urn:com:demoeditor:library:books:978-2409002205</span></strong><span class="koboSpan" id="kobo.93.1">, we can spot what needs further analysis in the different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the string:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">urn</span></strong><span class="koboSpan" id="kobo.96.1">: This is the scheme of the URI. </span><span class="koboSpan" id="kobo.96.2">It is here just to state that this is a unified </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">resource name.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">com:demoeditor</span></strong><span class="koboSpan" id="kobo.99.1">: This is the reverse of </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">demoeditor.com</span></strong><span class="koboSpan" id="kobo.101.1">, the domain name of our sample company. </span><span class="koboSpan" id="kobo.101.2">The information is there to serve as a prefix to differentiate the entities from another vendor that would have entities with the same name, and it is reversed in order to keep the information in a logical reading order from the coarsest to the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">most granular.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">978-2409002205</span></strong><span class="koboSpan" id="kobo.104.1">: This is a sample ISBN. </span><span class="koboSpan" id="kobo.104.2">Again, as soon as we can, and this is essential inside pivotal formats, we turn it back to an existing standard. </span><span class="koboSpan" id="kobo.104.3">There are norms for virtually every single piece </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">of information!</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">library</span></strong><span class="koboSpan" id="kobo.107.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">books</span></strong><span class="koboSpan" id="kobo.109.1"> are the parts of the URN that bear some functional value and we have not yet explained where they come from. </span><span class="koboSpan" id="kobo.109.2">Let’s say for now that </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">library</span></strong><span class="koboSpan" id="kobo.111.1"> is the domain (the management unit of books and other entities related) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">books</span></strong><span class="koboSpan" id="kobo.113.1"> is the chosen name to talk about these resources that </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">DemoEditor</span></strong><span class="koboSpan" id="kobo.115.1"> manages. </span><span class="koboSpan" id="kobo.115.2">We will come back later </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">to this.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.117.1">Semantics</span></strong><span class="koboSpan" id="kobo.118.1"> is the </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.119.1">science of relating meaning to words. </span><span class="koboSpan" id="kobo.119.2">In our case, since we have to represent existing real-world concepts in a software-based, virtual world, semantics is what is going to relate the concepts written as text in the IT applications to the </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.120.1">concepts we need to manage. </span><span class="koboSpan" id="kobo.120.2">Of course, using the right semantics will be important not only so that IT reflects the right business concepts, but also for actors of the IT system to share knowledge based on applications and databases. </span><span class="koboSpan" id="kobo.120.3">This is more important than the first argument because, as far as computers are concerned, you could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">x24b72</span></strong><span class="koboSpan" id="kobo.122.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">books</span></strong><span class="koboSpan" id="kobo.124.1"> and they would not mind at all; whereas introducing misunderstanding in the terms used by your information system is bound to create problems at </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">some point.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Let me tell you of an anecdote on this: I was consulting at a company in the information domain and one of the workshops I had with them was about designing a pivotal format around the people who bought the information. </span><span class="koboSpan" id="kobo.126.2">Marketing people and salespersons were there and, at some point, their voices started to rise as they disagreed on terms that were used differently. </span><span class="koboSpan" id="kobo.126.3">Their argument was about the relationship between a </span><em class="italic"><span class="koboSpan" id="kobo.127.1">prospect</span></em><span class="koboSpan" id="kobo.128.1"> and a </span><em class="italic"><span class="koboSpan" id="kobo.129.1">customer</span></em><span class="koboSpan" id="kobo.130.1">. </span><span class="koboSpan" id="kobo.130.2">Marketing explained that customers are the best prospects since they already know the company, whereas the salespersons replied that the commercial pipe was quite clear concerning the fact that a cold lead becomes a hot lead, then a prospect, and then a customer if he buys something, leaving—by definition—the status of prospect. </span><span class="koboSpan" id="kobo.130.3">In fact, they both were right and something was simply missing in the model: the fact that “customer” and “prospect” are not names of entities, but business rules. </span><span class="koboSpan" id="kobo.130.4">If one includes in the model the notion of product proposition, then things get clearer: a customer of a given product is indeed a great prospect for another product in the catalog of the same company, but they are still not a customer for this </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">second product.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Reading this, you</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.133.1"> might say that this situation was benign and that no harm was done since the discussion cleared out the problem. </span><span class="koboSpan" id="kobo.133.2">This would lead to ignoring two things. </span><span class="koboSpan" id="kobo.133.3">First, this misunderstanding created some real tensions between marketing and commerce and incomplete future sales reports, which lasted for months before I had the chance to spot the problem in the workshop organized by the CTO of the company. </span><span class="koboSpan" id="kobo.133.4">Second, when there is just an oral misunderstanding, this is indeed fine, but the real problem is that this mistake has been solidified into the information system (remember that you should never start working on layer 3 before having a good understanding of the analysis context in layer 2). </span><span class="koboSpan" id="kobo.133.5">If this was just a mistake in a single company, that would not be so bad, but even ERP editors (I will not cite any names) make the same mistake right into their default database models! </span><span class="koboSpan" id="kobo.133.6">Several of them sport data tables named </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">customers</span></strong><span class="koboSpan" id="kobo.135.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">suppliers</span></strong><span class="koboSpan" id="kobo.137.1">, which can cause lots </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">of trouble.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.139.1"><img alt="Figure 9.1 – Bad semantics" src="image/B21293_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.140.1">Figure 9.1 – Bad semantics</span></p>
<p><span class="koboSpan" id="kobo.141.1">What happens in</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.142.1"> this case when a given company you work with is not only one of your customers but also one of your suppliers? </span><span class="koboSpan" id="kobo.142.2">This happens very often in the negotiation market, and, generally, people would not make this mistake. </span><span class="koboSpan" id="kobo.142.3">However, in this ERP, which I will not cite, the editor clearly did not do the job of understanding all of the markets they wanted to address and tried to propose a generic model that was not adapted to any company where this situation would happen. </span><span class="koboSpan" id="kobo.142.4">Of course, how do you think the consultants handled the problem when discovered? </span><span class="koboSpan" id="kobo.142.5">You got it: they tried to compensate for the layer 2 problem using layer 3 tricks. </span><span class="koboSpan" id="kobo.142.6">In a particular case, I remember, the consultants first started creating a database trigger that, when a customer changed address or bank coordinates, would replicate the modified information into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">suppliers</span></strong><span class="koboSpan" id="kobo.144.1"> data table. </span><span class="koboSpan" id="kobo.144.2">Then, a few months later since the problem happened, they implemented the same trigger to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">customers</span></strong><span class="koboSpan" id="kobo.146.1"> data table when a supplier was the modifier and created an infinite loop that crashed </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">the database!</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">Things would have </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.149.1">been so much easier if the data tables had been designed with a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">actors</span></strong><span class="koboSpan" id="kobo.151.1"> data table (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">individuals</span></strong><span class="koboSpan" id="kobo.153.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">organizations</span></strong><span class="koboSpan" id="kobo.155.1"> if you only deal with this kind of actors; again, semantics matters). </span><span class="koboSpan" id="kobo.155.2">The notion of a customer would simply arise from a business rule that states that an </span><em class="italic"><span class="koboSpan" id="kobo.156.1">actor</span></em><span class="koboSpan" id="kobo.157.1"> is a </span><em class="italic"><span class="koboSpan" id="kobo.158.1">customer</span></em><span class="koboSpan" id="kobo.159.1"> if a record exists in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">orders</span></strong><span class="koboSpan" id="kobo.161.1"> data table pointing at this actor, and with a value date not older than 18 months. </span><span class="koboSpan" id="kobo.161.2">The same would be applicable to a supplier, which would be a business rule stating that an </span><em class="italic"><span class="koboSpan" id="kobo.162.1">actor</span></em><span class="koboSpan" id="kobo.163.1"> is a </span><em class="italic"><span class="koboSpan" id="kobo.164.1">supplier</span></em><span class="koboSpan" id="kobo.165.1"> if a record exists in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">incoming-orders</span></strong><span class="koboSpan" id="kobo.167.1"> data table linked to this actor, or if an entry in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">equipment</span></strong><span class="koboSpan" id="kobo.169.1"> data table has a guaranteed owner pointing at </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">this actor.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 9.2 – Correct semantics" src="image/B21293_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 9.2 – Correct semantics</span></p>
<p><span class="koboSpan" id="kobo.173.1">Those business rules are, of course, purely arbitrary ones, but notice that the entity schema does not change a bit if the rules evolve. </span><span class="koboSpan" id="kobo.173.2">This may be the most important thing in this model. </span><span class="koboSpan" id="kobo.173.3">If, at some point, marketing decides that the rule should be that the customers list </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.174.1">contains only the actors with whom we have done business in the past 12 months instead of 18, what will happen? </span><span class="koboSpan" id="kobo.174.2">Here starts the real problems in the bad design, as you will have to create a migration routine to get your customers out of the table and activate the archive procedure. </span><span class="koboSpan" id="kobo.174.3">Since you may have orders pending, the risk is to lose a pointer to the right data and so many other things can go awry. </span><span class="koboSpan" id="kobo.174.4">With the right model design, on the other hand, what should we do? </span><span class="koboSpan" id="kobo.174.5">Well, simply modify the business rule! </span><span class="koboSpan" id="kobo.174.6">If it is in code, you can change </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">18</span></strong><span class="koboSpan" id="kobo.176.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">12</span></strong><span class="koboSpan" id="kobo.178.1"> and recompile. </span><span class="koboSpan" id="kobo.178.2">If you were careful enough beforehand, this business rule is in a custom property somewhere and you will not even have to recompile or deploy anything. </span><span class="koboSpan" id="kobo.178.3">Also, if you had a reporting API producing the list of customers, then it is your lucky day: you modify this implementation and, without any other action, the behavior is changed everywhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">your system!</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">You might think that these examples are too easy and that this approach will not stand the complexity of a real system; it is actually quite the contrary because this approach is based on designing the business complexity in the software model. </span><span class="koboSpan" id="kobo.180.2">In the preceding example, for instance, we could very well have a different business definition of the addresses and the owner of the information system could decide that addresses should not be shared between customers and suppliers, or maybe only in some cases. </span><span class="koboSpan" id="kobo.180.3">For example, some addresses would be used only for the customers, such as the delivery address. </span><span class="koboSpan" id="kobo.180.4">No problem: we would adjust the model by keeping the addresses separate from the actors, and then add the “type” information to them, in order for the delivery address to be pointed at by the actors only when they are customers. </span><span class="koboSpan" id="kobo.180.5">We could even add some authorization rules on this to ensure that this address is never even read when the actor is seen as a supplier! </span><span class="koboSpan" id="kobo.180.6">Again, a good design would have allowed all this to be smooth but you have to get this clean design. </span><span class="koboSpan" id="kobo.180.7">Also, this happens to be one of the hardest bits of your architect job – gathering domain experts and coming up with something close to perfection. </span><span class="koboSpan" id="kobo.180.8">Fortunately, methods exist to structure this job. </span><span class="koboSpan" id="kobo.180.9">It is time to </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">int</span><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.182.1">roduce DDD.</span></span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.183.1">DDD</span></h1>
<p><span class="koboSpan" id="kobo.184.1">DDD (please note the last </span><em class="italic"><span class="koboSpan" id="kobo.185.1">D</span></em><span class="koboSpan" id="kobo.186.1"> is </span><em class="italic"><span class="koboSpan" id="kobo.187.1">not</span></em><span class="koboSpan" id="kobo.188.1"> for </span><em class="italic"><span class="koboSpan" id="kobo.189.1">development</span></em><span class="koboSpan" id="kobo.190.1">, but indeed </span><em class="italic"><span class="koboSpan" id="kobo.191.1">design</span></em><span class="koboSpan" id="kobo.192.1">) is a complete method for</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.193.1"> functional design that has been created and documented by Eric Evans, in his foundational book, </span><em class="italic"><span class="koboSpan" id="kobo.194.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.195.1">, released in 2003 and, since then, has been famously known as </span><em class="italic"><span class="koboSpan" id="kobo.196.1">the blue book</span></em><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">This important piece of work has influenced many software designers, despite it being quite a difficult read. </span><span class="koboSpan" id="kobo.197.3">Through its hundreds of pages, this book dispenses lots of best practices in modeling data and functional design. </span><span class="koboSpan" id="kobo.197.4">It is oriented</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.198.1"> towards software but everything it says can help, even before the first line of code, and it is a wealth of advice for understanding your business functions before you even start thinking about automating them through </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">IT solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">That being said, our goal here is not to talk too much about the book, or to unroll the complete method. </span><span class="koboSpan" id="kobo.200.2">You have to read it yourself if you want to get the full advantage of such a seminal work, or watch Eric Evans’ excellent presentation at </span><a href="https://youtu.be/lE6Hxz4yomA"><span class="koboSpan" id="kobo.201.1">https://youtu.be/lE6Hxz4yomA</span></a><span class="koboSpan" id="kobo.202.1">, where the expert explains the essentials of the method, which are </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.204.1">Creative collaboration of domain experts and </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">software experts</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">Exploration </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">and experimentation</span></span></li>
<li><span class="koboSpan" id="kobo.208.1">Emerging models shaping and reshaping the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">ubiquitous language</span></span></li>
<li><span class="koboSpan" id="kobo.210.1">Explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">context boundaries</span></span></li>
<li><span class="koboSpan" id="kobo.212.1">Focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">core domain</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.214.1">What we will now do is show how some tools from the book can be used in order to help our design of a pivotal format, aiming at a nice business/IT alignment. </span><span class="koboSpan" id="kobo.214.2">Going back to our sample company, how could we describe what we are doing from a general point of view? </span><span class="koboSpan" id="kobo.214.3">One could say we are in the business domain called </span><em class="italic"><span class="koboSpan" id="kobo.215.1">book edition</span></em><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">We need a subdomain for authoring and another one for selling. </span><span class="koboSpan" id="kobo.216.3">These two can be considered core domains since this is the bread and butter of our sample company: supervising the writing of books and selling them. </span><span class="koboSpan" id="kobo.216.4">There will also be some supporting subdomains such as human resources or accounting: those are not directly implicated in the core value-addition work of the company but are nonetheless absolutely necessary for it to </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">work correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">The word “edition” here refers to literature in general but editors and salespeople do not have the same vocabulary for books: the former talk about a </span><em class="italic"><span class="koboSpan" id="kobo.219.1">work</span></em><span class="koboSpan" id="kobo.220.1"> and the latter about a </span><em class="italic"><span class="koboSpan" id="kobo.221.1">product</span></em><span class="koboSpan" id="kobo.222.1">. </span><span class="koboSpan" id="kobo.222.2">Still, this is a similar entity. </span><span class="koboSpan" id="kobo.222.3">Also, they will not use the same attributes. </span><span class="koboSpan" id="kobo.222.4">Editors will be very interested in the number of chapters, the progress made in the writing, and other such attributes of a book, which is mostly a work in progress for them (when they go to sales, their job is basically done). </span><span class="koboSpan" id="kobo.222.5">On the other hand, a salesperson will check attributes such as the price of the book and maybe even the weight to calculate the transportation fees. </span><span class="koboSpan" id="kobo.222.6">Again, there are attributes, however, that are of interest for both roles: the number of pages, the ISBN of the book, the date of publication, and </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">To solve these apparent paradoxes in the naming and potential difficulties in the separated management of attributes, DDD proposes </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">two concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">The first one </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.227.1">is the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">ubiquitous language</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">DDD</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.230.1"> recognizes that different names can be used in different contexts for the same functional entity, and thus can account for local jargon while keeping a unique name shared between all actors of the information system. </span><span class="koboSpan" id="kobo.230.2">In our example, that could be “books,” which is something sufficiently significant and still widely accepted to designate what editors call “works” and salespeople call “products.” </span><span class="koboSpan" id="kobo.230.3">To be perfectly clear, DDD does not recommend finding a single expression for each concept and abandoning all others, but rather deciding on a given expression that will be shared by all actors of the model (hence the ubiquitous qualification). </span><span class="koboSpan" id="kobo.230.4">Local jargons are not forbidden, because they are generally useful for fast communication inside a given context, but the </span><em class="italic"><span class="koboSpan" id="kobo.231.1">standard</span></em><span class="koboSpan" id="kobo.232.1"> expression should be used every time there is the slightest risk related </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">to misunderstanding.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">The second concept introduced by </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.235.1">DDD is the </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">bounded context</span></strong><span class="koboSpan" id="kobo.237.1">, which is the perimeter containing entities and business rules, inside of which the vocabulary is consistent. </span><span class="koboSpan" id="kobo.237.2">We talked about this context in which the alternate vocabulary can be used without causing trouble if limited to the actors of this context only; this context is indeed what is called the bounded context. </span><span class="koboSpan" id="kobo.237.3">Finding the bounded context in a complete business domain is important because it helps define where the interactions are and, as a consequence, where it is most important to be perfectly clear on the language. </span><span class="koboSpan" id="kobo.237.4">Bounded contexts can be aligned to business subdomains, but this is not mandatory. </span><span class="koboSpan" id="kobo.237.5">As we will see in the next chapter, the question of the entity life cycle has to be taken into account </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">To summarize this graphically, see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.240.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.241.1">.3</span></em><span class="koboSpan" id="kobo.242.1"> for bounded contexts for our </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">edition domain:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 9.3 – Bounded contexts in Edition DDD" src="image/B21293_09_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 9.3 – Bounded contexts in Edition DDD</span></p>
<p><span class="koboSpan" id="kobo.246.1">Since we</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.247.1"> obey an </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Agile approach</span></strong><span class="koboSpan" id="kobo.249.1"> to the design and development </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.250.1">of our sample information system, we will not go further into the design than this very first step for now. </span><span class="koboSpan" id="kobo.250.2">Once we have applied this first level of knowledge to the creation of a first version of the data referential (see </span><a href="B21293_10.xhtml#_idTextAnchor344"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.251.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.252.1">), we will dig a bit deeper as needed. </span><span class="koboSpan" id="kobo.252.2">Indeed, trying to cover the whole business domain would take too long and too many pages without adding anything to the understanding of the method. </span><span class="koboSpan" id="kobo.252.3">Before we move on, let us refresh our knowledge of </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">data referential</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">Data referential is </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.255.1">a service that is dedicated to handling data for a particular functional entity but also metadata, data history, authorization, governance, and many other functions as a complement to the traditional database that only handles persistence. </span><span class="koboSpan" id="kobo.255.2">Data referential is the basis for good </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">maste</span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.257.1">r </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.258.1">data management</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.260.1">Application to clean information system architecture</span></h1>
<p><span class="koboSpan" id="kobo.261.1">Now that we</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.262.1"> are clear on the semantics </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.263.1">and the domain decomposition of our business model, we can take a step forward in the design (though technical questions will only be introduced in the next chapter) and start envisioning how these entities are going to be introduced to the IT system. </span><span class="koboSpan" id="kobo.263.2">Until now, everything we said could be applied to a non-software-based information system. </span><span class="koboSpan" id="kobo.263.3">Starting from this section, we will admit the reality of there not being any such </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.264.1">information systems in design anymore and that </span><em class="italic"><span class="koboSpan" id="kobo.265.1">every </span></em><span class="koboSpan" id="kobo.266.1">company is now a software company. </span><span class="koboSpan" id="kobo.266.2">Since we </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.267.1">are talking about entities, and their pivotal format is considered as designed, the next step is to talk about the way they will be manipulated—and thus stored—by t</span><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.268.1">he </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">information system.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.270.1">Using entities in referential applications</span></h2>
<p><span class="koboSpan" id="kobo.271.1">The </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.272.1">very first question about storing and manipulating functional entities is about their decomposition. </span><span class="koboSpan" id="kobo.272.2">Since complex business attributes may have hundreds of attributes to qualify them, it is of course necessary to at least categorize them, and, if possible, create a tree-like structure to classify them. </span><span class="koboSpan" id="kobo.272.3">Entities always have some base attributes that are used by everyone in the information system, and the rest of the data attributes are mostly related to one subdomain, or, at least, one of these domains can be selected for each as the ideal maintainer of the data quality. </span><span class="koboSpan" id="kobo.272.4">This decomposition is often used to represent data referential as flowers (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.273.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.274.1">.4</span></em><span class="koboSpan" id="kobo.275.1">), with the core of the flower containing the shared data and the petals around the core containing the subdomain-related data. </span><span class="koboSpan" id="kobo.275.2">As a petal is always attached to the core, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.276.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.277.1">.4</span></em><span class="koboSpan" id="kobo.278.1"> shows that peripheral data has no meaning without identifying the core data of an entity. </span><span class="koboSpan" id="kobo.278.2">It also states that petals can be independent and that a flower without some of the petals might still be useful to some users. </span><span class="koboSpan" id="kobo.278.3">Finally, the metaphor shows that, if the core of the flower is thrown away, the petals go away </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">The application of this approach to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">book</span></strong><span class="koboSpan" id="kobo.282.1"> entity should be quite obvious, following what we had </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">said before:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.284.1"><img alt="Figure 9.4 – Metaphor of a flower for referential" src="image/B21293_09_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.285.1">Figure 9.4 – Metaphor of a flower for referential</span></p>
<p><span class="koboSpan" id="kobo.286.1">Though we had</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.287.1"> only talked about the two main petals before, there might be some others around the flower, such as the one about the physical production of the books, and the one about </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.288.1">the storage of the printed units. </span><span class="koboSpan" id="kobo.288.2">Again, since this book is about the method and not about designing an IT system for a real book editing company, we will not go into these details; but you should definitely at least get to know all the petals in an entity flower when you design one for real, even if you do not get all the details of each petals</span><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.289.1"> in your </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">first analysis.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.291.1">Managing the life cycle of entities</span></h2>
<p><span class="koboSpan" id="kobo.292.1">Also, since </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.293.1">we question the design of the storage, it is important to include time in the equation, as was explained in </span><a href="B21293_04.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.294.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">A common mistake once an entity is designed is to think that we need to store and manipulate the data attributes that have appeared during this phase. </span><span class="koboSpan" id="kobo.295.3">However, there are many other things around the entity that have an impact on storage. </span><span class="koboSpan" id="kobo.295.4">Time is, of course, the first one and an important entity generally needs to have all its states in time persisted and not the last known one. </span><span class="koboSpan" id="kobo.295.5">In some cases, versions and branches of entities might have to be handled. </span><span class="koboSpan" id="kobo.295.6">Metadata on the entity (who created it, which state it is in, etc.) might be seen as a dedicated </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.296.1">petal for history, but it generally is a complete set of data attached to the entity and available for all petals while still not being at the core of the flower, since it is not always necessary to have </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">this metadata.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">If we stick to</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.299.1"> time, traceability of the data change is, of course, the obvious thing we think about, but taking time into account is much more than just storing the changes of each attribute each time they are modified: it is about modeling the evolution of the entity in time as an element of business</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.300.1"> knowledge as well and making it possible to understand not only how the data changed (addresses an array with index 1 removed and another entity added) but what was the functional reason behind it (e.g., the person moved out and recorded their change of address). </span><span class="koboSpan" id="kobo.300.2">This is what</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.301.1"> is called the </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">entity life cycle</span></strong><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">Designing it is harder than listing the attributes of an entity because it is not a usual design activity and also because there are many ways to introduce time, each one complementary to the others. </span><span class="koboSpan" id="kobo.303.3">For example, it may be used to think of the statuses the entity will go through in its lifetime (created, draft, valid, etc., until it reaches the archived state). </span><span class="koboSpan" id="kobo.303.4">However, there may be times when having a design closer to what would be the business process centered on an important entity will be easier </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">to communicate.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.305.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.306.1">.5</span></em><span class="koboSpan" id="kobo.307.1"> shows how the time criteria could be introduced on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">book</span></strong><span class="koboSpan" id="kobo.309.1"> entity and what the life cycle would look like if we start from different steps in the life of a book, from the edition domain point of view (not the reader, of course, as this would lead to a completely different </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">information system):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 9.5 – The life cycle of a book" src="image/B21293_09_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 9.5 – The life cycle of a book</span></p>
<p><span class="koboSpan" id="kobo.313.1">As you can see, the top part of the diagram shows what will happen in the lifetime of the book in the editing company. </span><span class="koboSpan" id="kobo.313.2">It always starts from an idea, even if this phase is extremely short, such as the idea coming from a meeting with a candidate author. </span><span class="koboSpan" id="kobo.313.3">In this case, the process will directly jump to the second phase. </span><span class="koboSpan" id="kobo.313.4">Phases look quite linear here, but that does not mean they have to be. </span><span class="koboSpan" id="kobo.313.5">For example, when a second edition is created, the writing and correcting phase will start again, but generally speaking, this diagram helps to envision the entity not only as the sum of data attributes but as a living object in the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">information system.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The evolution </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.316.1">of an entity in time, of</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.317.1"> course, has an impact on many aspects of its data, but also on the business rules that apply to it. </span><span class="koboSpan" id="kobo.317.2">In the diagram, I only showed a few examples of </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">such impact:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.319.1">Tags associated with the book in order to categorize them will evolve at first, but soon will be fixed and cannot evolve afterward, as it would create problems if the subject of a book evolved too much once the salespersons have started talking about it on salons, social media or </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">to resellers.</span></span></li>
<li><span class="koboSpan" id="kobo.321.1">Actors working on a book will, of course, evolve throughout its life cycle: marketing will create the vision of the book, editors will help the authors create it, and at some point, after the content is reviewed and validated, the main actors will be the salespersons, until the book reaches archiving, when editors will work a bit on the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">book again.</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">An example of a business rule has been provided, though there are always many in an important entity of the information system. </span><span class="koboSpan" id="kobo.323.2">In this diagram, I showed that the business rule is </span><em class="italic"><span class="koboSpan" id="kobo.324.1">public</span></em><span class="koboSpan" id="kobo.325.1">, which is false as long as the book is not validated by the reviewers and becomes true after, with the particular case (not shown here) that, once public, a book cannot go back to being private, as people have been informed </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">about it.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.327.1">The notion of </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">status</span></strong><span class="koboSpan" id="kobo.329.1"> is one that should be analyzed with particular care, as confusion often arises from the fact that it is often understood as data when it in fact is a business rule coming from complex business-related conditions. </span><span class="koboSpan" id="kobo.329.2">To give an example on the domain we have chosen as an exercise of application, the </span><em class="italic"><span class="koboSpan" id="kobo.330.1">ready to publish</span></em><span class="koboSpan" id="kobo.331.1"> status on a book may seem like the value of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">status</span></strong><span class="koboSpan" id="kobo.333.1"> attribute that an editor would change on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">book</span></strong><span class="koboSpan" id="kobo.335.1"> entity instance. </span><span class="koboSpan" id="kobo.335.2">But it may also be bound to a business rule stating that a book can become </span><em class="italic"><span class="koboSpan" id="kobo.336.1">ready to publish</span></em><span class="koboSpan" id="kobo.337.1"> once the following tasks have </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">been completed:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.339.1">Its main editor or two editors have given their vote </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">for it.</span></span></li>
<li><span class="koboSpan" id="kobo.341.1">The author has signed their contract and, in particular, the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">financial amendments.</span></span></li>
<li><span class="koboSpan" id="kobo.343.1">The printing company has approved the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">provided files.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.345.1">Business rules </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.346.1">can also cascade on each</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.347.1"> other. </span><span class="koboSpan" id="kobo.347.2">For example, we could authorize payment of an author only if their bank details have been validated for less than three months, which means verifying the bank owning the account, which means, in turn, checking the SWIFT number is correct, and </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Finally, all of this is complicated further by the fact that some business rules may be stabilized as data at some point. </span><span class="koboSpan" id="kobo.349.2">This happens for performance reasons, where the computations are so long that it becomes acceptable that the result of the calculation is not always up-to-date (which happens when reading the value is more frequent than computing its result anew). </span><span class="koboSpan" id="kobo.349.3">There might also be some functional reasons as to why a state evolves against business rules and then gets fixed, without the possibility of going back for regulatory reasons (typically, this is what happens when an entity reaches an </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">archived</span></strong><span class="koboSpan" id="kobo.351.1"> state: its content is then removed from the database and placed in archives, so, returning to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">active</span></strong><span class="koboSpan" id="kobo.353.1"> state is not possible, since the data is now only accessible by archivists). </span><span class="koboSpan" id="kobo.353.2">In this case, the state overrides the business rule itself (or the business rule starts reading the recorded state and continues calculations if it i</span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.354.1">s not overridden by </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">this state).</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.356.1">Relation between subdomains and time</span></h2>
<p><span class="koboSpan" id="kobo.357.1">This notion</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.358.1"> of a life cycle is also important because it helps define important entities, and thus subdomains, in your information system. </span><span class="koboSpan" id="kobo.358.2">For example, a book is definitely a major entity in the domain because, as we have shown, it has a life cycle. </span><span class="koboSpan" id="kobo.358.3">Authors also have a life cycle in the information system because, as they are created in it, their contact data will change, they will hopefully write several books, and, at some point, will be erased from the database after a given time of inactivity (under which there is certainly a regulatory business rule, such as the GDPR in Europe, for example). </span><span class="koboSpan" id="kobo.358.4">However, tags are not an important entity, as they do not have a life cycle outside of books. </span><span class="koboSpan" id="kobo.358.5">Sure, a tag might disappear, but this will only be a result of there being no more books in this category. </span><span class="koboSpan" id="kobo.358.6">It is even </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.359.1">easier to decide that the addresses of authors are definitely not a major entity, as they will never exist outside of an author, and they will always disappear with their </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">parent entity.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">The definition </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.362.1">of the entity itself can evolve over time, which is completely natural in an Agile approach where we do not try to have everything conceptualized at first as we know that things </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.363.1">will get clearer in time, and we should just prepare for the changes that will be added in the next versions (while still knowing enough of the business to ensure compatibility and smooth evolution of the system). </span><span class="koboSpan" id="kobo.363.2">The cutting of subdomains should normally never evolve in time. </span><span class="koboSpan" id="kobo.363.3">Additional domains may appear following a change of strategy of the company owning the information system, but there should be something majorly important to justify such a </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">low-level change.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Now that we have seen DDD in action and its relation to a correctly structured information system, we are going to talk more specifically about the consequence of all of </span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.366.1">this in the design of </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">API contracts.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.368.1">Link to the API and services</span></h1>
<p><span class="koboSpan" id="kobo.369.1">We </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.370.1">spent a lot of time talking about the entity from the point of view of its evolution and not with a data focus, but this is done on purpose because we generally take too much time defining the attributes and not enough thinking about the business entity as a whole, living object. </span><span class="koboSpan" id="kobo.370.2">Now that this is done, let’s use the final section of this chapter to come back to the notion of services and API that we h</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.371.1">ave detailed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">previous chapter.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.373.1">Including time in an API</span></h2>
<p><span class="koboSpan" id="kobo.374.1">One of the first consequences of thinking about the entity as a whole, including its history, is that the writing methods on a corresponding API should not work exactly the same. </span><span class="koboSpan" id="kobo.374.2">As reading methods, they are similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">GET on /api/entity</span></strong><span class="koboSpan" id="kobo.377.1">: This is used to read the list </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">of entities</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">GET on /api/entity/{id}</span></strong><span class="koboSpan" id="kobo.380.1">: This is used to read a </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">given entity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.382.1">However, if you want to take action and be able to access history, you should add some methods such as </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">GET on /api/entity/{id}?valuedate={date}</span></strong><span class="koboSpan" id="kobo.385.1">: This is used to read a given entity state at a </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">given date</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">GET on /api/entity/{id}/history</span></strong><span class="koboSpan" id="kobo.388.1">: This is used to read the full history of a </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">given entity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">Changes</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.391.1"> should also be made to the writing parts of the API, with one method that does </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">not change:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">POST on /api/entity</span></strong><span class="koboSpan" id="kobo.394.1">: This will always be about creating an entity instance. </span><span class="koboSpan" id="kobo.394.2">(Do not forget to follow the standards and send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">201</span></strong><span class="koboSpan" id="kobo.396.1"> HTTP status code, together with a </span><em class="italic"><span class="koboSpan" id="kobo.397.1">Location</span></em><span class="koboSpan" id="kobo.398.1"> response header containing the URL of the resource </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">just created.)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.400.1">However, the traditional calls for an API are limited when you think in terms of a complete </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">life cycle:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">PUT on /api/entity/{id}</span></strong><span class="koboSpan" id="kobo.403.1">: This should not be allowed as it destroys the eventual consistency and the ability to avoid locks, as was </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">explained before.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">DELETE on /api/entity/{id}</span></strong><span class="koboSpan" id="kobo.406.1">: This should also be adjusted, not in its exposition but in how it works. </span><span class="koboSpan" id="kobo.406.2">Most of the time, since the resource is not really removed but only made unavailable by reaching an </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">archived</span></strong><span class="koboSpan" id="kobo.408.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">disabled</span></strong><span class="koboSpan" id="kobo.410.1"> status, the equivalent modification call could be used in the same way and be </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">more explicit.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.412.1">Also, an existing but lesser-known verb should be used in order to act on the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">the entity:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">PATCH on /api/entity/{id}</span></strong><span class="koboSpan" id="kobo.415.1">: This together with a request body content, following </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">RFC 6902</span></strong><span class="koboSpan" id="kobo.417.1"> (JSON Patch), should be used to write the data in a progressive, eventually consistent, and lock-free way (optimistic and pessimistic locks have been explained in </span><a href="B21293_05.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.418.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.419.1">)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">PATCH on /api/entity/{id}?valuedate={date}</span></strong><span class="koboSpan" id="kobo.421.1">: This can also be allowed in some cases where the history of the entity does not strictly follow the flow of orders in the API server, and the value date should be taken </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">into account</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.423.1">We will come</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.424.1"> back to these definitions in the next chapter, </span><em class="italic"><span class="koboSpan" id="kobo.425.1">Master Data Managemen</span><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.426.1">t</span></em><span class="koboSpan" id="kobo.427.1">, and show the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">of them.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.429.1">Aligning an API to subdomains and the consequences</span></h2>
<p><span class="koboSpan" id="kobo.430.1">If you use a</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.431.1"> strict service architecture, all major entities, and thus all business subdomains, should have their dedicated process. </span><span class="koboSpan" id="kobo.431.2">However, since we said they should have their own API (minor entities will be under the major entities of the domain they are related to; for example, addresses will be in </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">/api/authors/{id}/addresses</span></strong><span class="koboSpan" id="kobo.433.1">), which equates to the fact that one API should always have its own process. </span><span class="koboSpan" id="kobo.433.2">Also, if you follow the rule of one process in one Docker container, you will have the equivalence of one API to one Docker service (scalability taken into account, as a service is a set of Docker containers of the </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">same image).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.435.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.436.1">Docker is the most known implementation of the principle of containerization for software installation. </span><span class="koboSpan" id="kobo.436.2">This technology allows the deployment of instances of self-contained </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">black boxes</span></strong><span class="koboSpan" id="kobo.438.1"> of </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.439.1">software, which contain every dependency needed and remain isolated from other instances, while not necessitating a heavy mechanism such </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">as virtualization.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">If you consider that all calls should go through an API since they are the guarantee of unique business rules management and source of truth for a given API, then that means that nobody but the API exposition will ever access the application layer. </span><span class="koboSpan" id="kobo.441.2">In this case, why bother to separate these two layers? </span><span class="koboSpan" id="kobo.441.3">In the next chapter, we will follow this simple rule and implement API business codes directly inside the ASP.NET controllers. </span><span class="koboSpan" id="kobo.441.4">If you’re wondering about validations and how they can be done as soon as possible, then deserialization will take care of a good part of all this, and preconditions inside the implementation code will do </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">the rest.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">We will, of</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.444.1"> course, keep things separated for everything that is a dependency, such as persistence and logging. </span><span class="koboSpan" id="kobo.444.2">However, as far as the business behavior is concerned, everything will be handled in the API code itself, in just one big block. </span><span class="koboSpan" id="kobo.444.3">This might seem like something that is not obvious given the principle of clear separation of responsibilities, but this has been done on purpose in this book and in particular in the code associated with it. </span><span class="koboSpan" id="kobo.444.4">It does not mean that cutting down into layers, as explained at </span><a href="https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer"><span class="koboSpan" id="kobo.445.1">https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer</span></a><span class="koboSpan" id="kobo.446.1">, is useless, but simply that the first versions of a sound and evolving information system can very well start with a very simple implementation of a restricted API, leaving it to future versions to evolve to an extended API content and something </span><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.447.1">more sophisticated for </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">its implementation.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.449.1">API testability</span></h2>
<p><span class="koboSpan" id="kobo.450.1">One last</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.451.1"> thing on the API and its alignment with entities: nothing beats a nice Postman collection for manually testing the content of an API and then using these requests as the basis for a set of automated tests. </span><span class="koboSpan" id="kobo.451.2">There sure are other tools for specialized testing purposes but, in my personal experience, I have not yet found something as versatile as Postman for API discovery </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">and testing.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.453.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.454.1">Postman is the reference tool for API testing. </span><span class="koboSpan" id="kobo.454.2">A collection is a set of HTTP calls that can be tested manually or in an automatic, </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">sequential way.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">If you can gather what your clients, internal team, and partners, external or public, do specifically with your API and integrate their </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.457.1">code into your </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">quality assurance</span></strong><span class="koboSpan" id="kobo.459.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.460.1">QA</span></strong><span class="koboSpan" id="kobo.461.1">) Postman collections, then this is definitely the best way to ensure non-regression and backward compatibility. </span><span class="koboSpan" id="kobo.461.2">Sure, it will not replace unit tests and integration tests, but the former is a development tool, and the latter a QA tool. </span><span class="koboSpan" id="kobo.461.3">Everything in between will be beautifully held at </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.462.1">the API level, which then becomes your interaction level but unifies with the testing interface of your model since it is aligned with the API. </span><span class="koboSpan" id="kobo.462.2">Whatever your level of interop, regression testing is best done at the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">API level.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">If you completely follow the preceding principles, you end up with a perfect alignment of </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.466.1">One </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">business subdomain</span></span></li>
<li><span class="koboSpan" id="kobo.468.1">One </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">major entity</span></span></li>
<li><span class="koboSpan" id="kobo.470.1">One API contract (in </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">OpenAPI format)</span></span></li>
<li><span class="koboSpan" id="kobo.472.1">One Git repository for the code implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">this API</span></span></li>
<li><span class="koboSpan" id="kobo.474.1">One process for the delivery of </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">this code</span></span></li>
<li><span class="koboSpan" id="kobo.476.1">One Docker image for </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the deployment</span></span></li>
<li><span class="koboSpan" id="kobo.478.1">One orchestrator service for the running of API calls in a </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">coordinated way</span></span></li>
<li><span class="koboSpan" id="kobo.480.1">On</span><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.481.1">e Postman collection for the tests of </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">the API</span></span></li>
</ul>
<h1 id="_idParaDest-198"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.483.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.484.1">Here we are, finally reaching the point where we will get into the code! </span><span class="koboSpan" id="kobo.484.2">The previous chapters paved the way for a global understanding of most of the constraints of creating an evolution-capable, feature-rich information system. </span><span class="koboSpan" id="kobo.484.3">In this chapter, we saw how we should enter details about the data of entities and also their life cycle to create a clean and future </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">ready architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">DDD and the method shown previously using semantics will hopefully help you find the best way to structure important entities in your information system. </span><span class="koboSpan" id="kobo.486.2">The right schema makes exposing these entities through APIs easier and more loaded with functional value. </span><span class="koboSpan" id="kobo.486.3">This approach also allows the evolution of the system in the smoothest possible way, as technical evolutions and functional ones should be separated if the design has been correct. </span><span class="koboSpan" id="kobo.486.4">This way, not only is the information system better in its current form but it will also be much easier </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">to evolve.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">In the next chapter, we will see how the functional entities that we have designed are going to be implemented in the technical layers. </span><span class="koboSpan" id="kobo.488.2">We will not go into the code details right away, but we will start with how the data will be organized in the logical servers, how the entity life cycle that we talked about will be implemented in the software applications that will be put in place, and why master data management and data governance are important for ensuring that these nice functionally correct pivotal formats we designed in this chapter are </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">efficiently exploited.</span></span></p>
</div>
</body></html>