<html><head></head><body>
<div><h1 class="chapterTitle" id="_idParaDest-489">Answers</h1>
<h1 class="heading-1" id="_idParaDest-490">Chapter 1</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">A software architect needs to be aware of any technology that can help them solve problems faster and ensure they can create better quality software.</li>
<li class="numberedList">Azure helps software architects by providing scalable cloud infrastructure, diverse development tools, and services for building, deploying, and managing enterprise applications efficiently, with strong support for security and compliance.</li>
<li class="numberedList">The best software development process model depends on the kind of project, team, and budget you have. As a software architect, you need to consider all these variables and understand different process models so that you can fit the environment’s needs.</li>
<li class="numberedList">A software architect pays attention to any user or system requirement that can influence performance, security, usability, system architecture, structure, organization, and so on.</li>
<li class="numberedList">A software architect should verify both functional and non-functional requirements, with a special focus on system architecture, performance, scalability, security, maintainability, and compatibility in the requirements specification.</li>
<li class="numberedList">Design thinking and design sprint help a software architect to understand user needs deeply and rapidly prototyping solutions, ensuring the requirements gathered align closely with user expectations and project goals.</li>
<li class="numberedList">User stories are good when we want to define functional requirements. They can be written quickly and commonly deliver not only the feature required but also the acceptance criteria for the solution.</li>
<li class="numberedList">Effective techniques for developing high-performance software include optimizing code, using efficient algorithms, leveraging parallel processing, and implementing effective memory management.</li>
<li class="numberedList">To check that the implementation is correct, a software architect compares it with models and prototypes that have already been designed and validated.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-491">Chapter 2</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Vertically and horizontally.</li>
<li class="numberedList">Yes, you can deploy automatically to an already-defined web app or create a new one directly using Visual Studio.</li>
<li class="numberedList">To take advantage of available hardware resources by minimizing the time they remain idle.</li>
<li class="numberedList">Code behavior is deterministic, so it is easy to debug. The execution flow mimics the flow of sequential code, which means it is easier to design and understand.</li>
<li class="numberedList">Because the right order minimizes the number of gestures that are needed to fill in a form.</li>
<li class="numberedList">Because it allows for the manipulation of path files in a way that is independent of the operating system.</li>
<li class="numberedList">It can be used with several .NET Core versions, as well as with several versions of the classic .NET Framework.</li>
<li class="numberedList">Console, .NET Core, .NET (5+), and .NET Standard class libraries; ASP.NET Core, test projects, microservices, and much more.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-492">Chapter 3</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">No, it is available for several platforms.</li>
<li class="numberedList">Automatic, manual, and load test plans.</li>
<li class="numberedList">Yes, they can – through Azure DevOps feeds.</li>
<li class="numberedList">To manage requirements and organize the whole development process.</li>
<li class="numberedList">Epic work items represent higher-level system subparts that are made up of several features.</li>
<li class="numberedList">A parent-child relationship.</li>
<li class="numberedList">They can organize projects using the same concept we have in Azure DevOps.</li>
<li class="numberedList">Both options are great tools for running agile projects. The best option depends on your team’s experience.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-493">Chapter 4</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Maintainability gives you the opportunity to deliver the software you designed quickly. It also allows you to fix bugs easily.</li>
<li class="numberedList">Cyclomatic complexity is a measure of code complexity based on the control flow graph. It detects the number of nodes a method has. The higher the number, the worse the effect.</li>
<li class="numberedList">A version control system will guarantee the integrity of your source code, giving you the opportunity to analyze the history of each modification that you’ve made. It offers the possibility of branching your code development, then merging different branches, and much more.</li>
<li class="numberedList">A garbage collector is a system in .NET Core, .NET (5+), and .NET Framework that monitors your application and detects objects that you aren’t using anymore. It disposes of these objects to free up memory.</li>
<li class="numberedList">The <code class="inlineCode">IDisposable</code> interface is important firstly because it is a good pattern for deterministic cleanup. Secondly, it is required in classes that instantiate objects that need to be disposed of by the programmer, since the garbage collector cannot dispose of them.</li>
<li class="numberedList">.NET 8 encapsulates some key design patterns in some of its libraries, such as dependency injection and the Builder pattern, in a way that can guarantee safer, more reliable code.</li>
<li class="numberedList">Well-written code is code that any person skilled in that programming language can handle, modify, and evolve.</li>
<li class="numberedList">Roslyn is the .NET compiler that’s used for code analysis inside Visual Studio.</li>
<li class="numberedList">Code analysis is a practice that considers the way code is written to detect bad practices before compilation.</li>
<li class="numberedList">Code analysis can find problems that happen even with apparently good software, such as memory leaks and bad programming practices.</li>
<li class="numberedList">Roslyn is an engine that provides an API that enables analyzers to inspect your code for style, quality, maintainability, design, and other issues. This is done during design time, so you can check the mistakes before compiling your code.</li>
<li class="numberedList">Visual Studio extensions are tools that have been programmed to run inside Visual Studio. These tools can help you out in some cases where the Visual Studio IDE doesn’t have the appropriate feature for you to use.</li>
<li class="numberedList"><code class="inlineCode">SonarLint</code> and the <code class="inlineCode">SonarAnalyzer.CSharp</code> NuGet package.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-494">Chapter 5</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Copy-and-paste is an inadequate form of code reuse, since it leads to duplicated code, making maintenance and updates more difficult. In fact, there is no safe way to discover all duplicates, and then it is very difficult to modify all of them.</li>
<li class="numberedList">The best approaches for code reuse are creating libraries, using generics, object-oriented inheritance, and more.</li>
<li class="numberedList">Yes. You can find components that have already been created in the libraries you’ve created before, and then you increase these libraries by creating new components that can be reused in the future.</li>
<li class="numberedList">.NET Standard is a specification that allows compatibility across different .NET frameworks, from .NET Framework to Unity. .NET Core is one .NET implementation of .NET and is open source.</li>
<li class="numberedList">By creating a .NET Standard library, you will be able to use it in different .NET implementations, such as .NET Core, .NET, .NET Framework, and Xamarin.</li>
<li class="numberedList">You can enable code reuse using object-oriented principles (e.g., inheritance, encapsulation, abstraction, and polymorphism).</li>
<li class="numberedList">Generics is a sophisticated implementation that simplifies how objects with the same characteristics are treated, by defining a placeholder that will be replaced with the specific type at compile time.</li>
<li class="numberedList">The answer to this question is well explained by Immo Landwerth on the .NET blog: <a href="https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/">https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/</a>. The basic answer is that .NET versions 5 and above need to be thought of as the foundation for sharing code moving forward.</li>
<li class="numberedList">The challenges related to refactoring include ensuring that changes don’t introduce bugs, maintaining the functionality and performance of code, and improving readability and maintainability without altering the external behavior of software components.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-495">Chapter 6</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Design patterns are good solutions to common problems in software development.</li>
<li class="numberedList">While design patterns give you code implementation for typical problems we face in development, design principles help you select the best options when it comes to implementing the software architecture.</li>
<li class="numberedList">The Builder pattern will help you generate sophisticated objects without the need to define them in the class you are going to use them in.</li>
<li class="numberedList">The Factory pattern is useful in situations where you have multiple kinds of objects from the same abstraction, and you don’t know which of them needs to be created at compile time.</li>
<li class="numberedList">The Singleton pattern is useful when you need a class that has only one instance during the software’s execution.</li>
<li class="numberedList">The Proxy pattern is used when you need to provide an object that controls access to another object.</li>
<li class="numberedList">The Command pattern is used when you need to execute a command that will affect the behavior of an object.</li>
<li class="numberedList">The Publisher/Subscriber pattern is useful when you need to provide information about an object to a group of other objects.</li>
<li class="numberedList">The DI pattern is useful if you want to implement the Inversion of Control principle. Instead of creating instances of the objects that the component depends on, you just need to define their dependencies, declare their interfaces, and enable the reception of the objects by injection. Typically, you can do this by using the constructor of the class to receive the objects, tagging some class properties to receive the objects, or defining an interface with a method to inject all the necessary components.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-496">Chapter 7</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Changes in the language used by experts and changes in the meaning of words.</li>
<li class="numberedList">Context mapping is the main tool used to coordinate the development of a separate bounded context, helping to define and manage interactions between different contexts.</li>
<li class="numberedList">No; the whole communication passes through the entity, that is, the aggregate root.</li>
<li class="numberedList">There is a single aggregate root in a part-subpart hierarchy to ensure the consistency of and enforce rules across all elements of the aggregate, acting as the main entry point for external interactions.</li>
<li class="numberedList">Just one, since repositories are aggregate-centric.</li>
<li class="numberedList">The application layer manipulates repository interfaces. Repository implementations are registered in the dependency injection engine.</li>
<li class="numberedList">To coordinate operations on several aggregates in single transactions.</li>
<li class="numberedList">The specifications for updates and queries are usually quite different, especially in simple <strong class="keyWord">CRUD</strong> systems. The reason for its strongest form is mainly the optimization of query response times.</li>
<li class="numberedList">Dependency injection.</li>
<li class="numberedList">No; a serious impact analysis must be performed so that we can adopt it.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-497">Chapter 8</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">DevOps is the approach of delivering value to the end user continuously. To do this with success, continuous integration, continuous delivery, and continuous feedback must be undertaken.</li>
<li class="numberedList"><strong class="keyWord">Continuous integration</strong> (<strong class="keyWord">CI</strong>) allows you to check the quality of the software you are delivering every single time you commit a change. You can implement this by turning on this feature in Azure DevOps.</li>
<li class="numberedList"><strong class="keyWord">Continuous delivery</strong> (<strong class="keyWord">CD</strong>) allows you to deploy a solution once you are sure that all the quality checks have passed the tests you designed. Azure DevOps helps you with that by providing you with relevant tools.</li>
<li class="numberedList">Yes, you can have DevOps separately and then enable <strong class="keyWord">CI</strong> later. You can also have CI enabled without <strong class="keyWord">CD</strong> enabled. Your team and process need to be ready and attentive for this to happen.</li>
<li class="numberedList">You might confuse <strong class="keyWord">CI</strong> with a CD process, which could cause damage to your production environment. In the worst-case scenario, for example, a feature that is not ready might be deployed, causing disruptions at inconvenient times for your customers, or you could even suffer a bad collateral effect due to an incorrect fix.</li>
<li class="numberedList">A multi-stage environment protects production from bad releases when fully automated build and deployment pipelines are in place.</li>
<li class="numberedList">Automated tests anticipate bugs and bad behaviors in preview scenarios.</li>
<li class="numberedList">Pull requests allow code reviews before commits are made in the master branch.</li>
<li class="numberedList">No; pull requests can help you in any development approach where you have Git as your source control.</li>
<li class="numberedList">Continuous feedback is the adoption of tools in the DevOps life cycle that enable fast feedback when it comes to performance, usability, and other aspects of the application you are developing.</li>
<li class="numberedList">The build pipeline will let you run tasks to build and test your application, while the release pipeline will give you the opportunity to define how the application will be deployed in each scenario.</li>
<li class="numberedList">Application Insights is a helpful tool for monitoring the health of the system you’ve deployed, which makes it a fantastic continuous feedback tool.</li>
<li class="numberedList">Test and Feedback is a tool that allows stakeholders to analyze the software you are developing and enables a connection with Azure DevOps to open tasks and even bugs.</li>
<li class="numberedList">The main goal of service design thinking is to enhance user experience and satisfaction by optimizing the service’s usability, efficiency, and effectiveness in meeting user needs.</li>
<li class="numberedList">Azure DevOps is a tool that can automate the whole application life cycle when it comes to software development. However, many software architects tend to also use GitHub to do so, and Microsoft has developed the platform a lot in the last few years.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-498">Chapter 9</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Because most of the tests must be repeated after any software change occurs.</li>
<li class="numberedList">Because the probability of the same error occurring in a unit test and its associated application code is very low.</li>
<li class="numberedList"><code class="inlineCode">[Theory]</code> is used when the test method defines several tests, while <code class="inlineCode">[Fact]</code> is used when the test method defines just one test.</li>
<li class="numberedList">Assert.</li>
<li class="numberedList"><code class="inlineCode">Setup</code>, <code class="inlineCode">Returns</code>, and <code class="inlineCode">ReturnsAsync</code>.</li>
<li class="numberedList">Yes, with <code class="inlineCode">ReturnAsync</code>.</li>
<li class="numberedList">No; it depends on the complexity of the user interface and how often it changes.</li>
<li class="numberedList">The ASP.NET Core pipeline isn’t executed, but inputs are passed directly to controllers.</li>
<li class="numberedList">Usage of the <code class="inlineCode">Microsoft.AspNetCore.Mvc.Testing</code> NuGet package.</li>
<li class="numberedList">Usage of the <code class="inlineCode">AngleSharp</code> NuGet package.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-499">Chapter 10</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">IaaS is a good option when you are migrating from an on-premises solution or if you have an infrastructure team.</li>
<li class="numberedList">PaaS is the best option for fast and safe software delivery in systems where the team is focused on software development.</li>
<li class="numberedList">If the solution you intend to deliver is provided by a well-known player, such as a SaaS, you should consider using it.</li>
<li class="numberedList">Serverless is an option when you are building a new system if you don’t have people who specialize in infrastructure and you don’t want to worry about it for scaling.</li>
<li class="numberedList">Azure SQL Database can be up in minutes, and you will have all the power of Microsoft SQL Server afterward. Moreover, Microsoft will handle the database server infrastructure.</li>
<li class="numberedList">Azure provides a set of services called Azure Cognitive Services. These services provide solutions for vision, speech, language, search, and knowledge.</li>
<li class="numberedList">In a hybrid scenario, you have the flexibility to decide on the best solution for each part of your system, while respecting the solution’s development path in the future.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-500">Chapter 11</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">The modularity of code and deployment modularity.</li>
<li class="numberedList">No. Other important advantages include handling the development team and the whole <strong class="keyWord">CI</strong>/<strong class="keyWord">CD</strong> cycle well, and the possibility of mixing heterogeneous technologies easily and effectively.</li>
<li class="numberedList">A library that helps us implement resilient communication.</li>
<li class="numberedList">Once you’ve installed Docker on your development machine, you can develop, debug, and deploy Dockerized .NET applications. You can also add Docker images to Service Fabric applications that are handled with Visual Studio.</li>
<li class="numberedList">Orchestrators are software that manages microservices and nodes in microservice clusters. Azure supports two relevant orchestrators: Azure Kubernetes Service and Azure Service Fabric.</li>
<li class="numberedList">Because it decouples the actors that take place in a communication.</li>
<li class="numberedList">A message broker. It takes care of service-to-service communication and events.</li>
<li class="numberedList">The same message can be received several times because the sender doesn’t receive confirmation of reception before its time-out period, so the sender resends the message again. Therefore, the effect of receiving a single message once or several times must be the same.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-501">Chapter 12</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Redis is a distributed in-memory storage based on key-value pairs and supports distributed queuing. Its most well-known usage is for distributed caching, but it can be used as an alternative to relational databases, since it is able to persist data to disk.</li>
<li class="numberedList">Yes, they are. Most of this chapter’s sections are dedicated to explaining why.</li>
<li class="numberedList">Write operations.</li>
<li class="numberedList">The main weaknesses of NoSQL databases are their consistency and transactions, while their main advantage is performance, especially when it comes to handling distributed writes.</li>
<li class="numberedList">Eventual, Consistency Prefix, Session, Bounded Staleness, and Strong.</li>
<li class="numberedList">No, they are not efficient in a distributed environment. GUID-based strings perform better, since their uniqueness is automatic and doesn’t require synchronization operations.</li>
<li class="numberedList"><code class="inlineCode">OwnsMany</code> and <code class="inlineCode">OwnsOne</code>.</li>
<li class="numberedList">Yes, they can. Once you use <code class="inlineCode">SelectMany</code>, indices can be used to search for nested objects.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-502">Chapter 13</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">With the help of database-dependent providers.</li>
<li class="numberedList">Either by calling them <code class="inlineCode">Id</code> or by decorating them with the <code class="inlineCode">Key</code> attribute. This can also be done with a fluent configuration approach.</li>
<li class="numberedList">With the <code class="inlineCode">MaxLength</code> and <code class="inlineCode">MinLength</code> attributes, or with their equivalent fluent configuration methods.</li>
<li class="numberedList">With something similar to <code class="inlineCode">builder.Entity&lt;Package&gt;().HasIndex(m =&gt; m.Name);</code>.</li>
<li class="numberedList">With something similar to the following:
        <pre class="programlisting code"><code class="hljs-code">builder.Entity&lt;Destination&gt;()
.HasMany(m =&gt; m.Packages)
.WithOne(m =&gt; m.MyDestination)
.HasForeignKey(m =&gt; m.DestinationId)
.OnDelete(DeleteBehavior.Cascade);
</code></pre>
</li>
<li class="numberedList">With <code class="inlineCode">Add-Migration</code> and <code class="inlineCode">Update-Database</code> in the package-manager console, or with <code class="inlineCode">dotnet ef migrations</code> <code class="inlineCode">add</code> and <code class="inlineCode">dotnet</code> <code class="inlineCode">ef</code> <code class="inlineCode">database</code> <code class="inlineCode">update</code> in the operating system console.</li>
<li class="numberedList">No, but you can forcefully include them with the <code class="inlineCode">Include</code> <code class="inlineCode">LINQ</code> clause or by using the <code class="inlineCode">UseLazyLoadingProxies</code> option when configuring your <code class="inlineCode">DbContext</code>. With Include, related entities are loaded together with the main entities, while with <code class="inlineCode">UseLazyLoadingProxies</code>, related entities are lazy-loaded; that is, they are loaded as soon as they are required.</li>
<li class="numberedList">Yes, it is, thanks to the <code class="inlineCode">Select LINQ</code> clause.</li>
<li class="numberedList">By calling <code class="inlineCode">context.Database.Migrate()</code>.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-503">Chapter 14</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Because using queues are the only way to avoid time-consuming blocking calls.</li>
<li class="numberedList">With the <code class="inlineCode">import</code> declaration.</li>
<li class="numberedList">With the standard <code class="inlineCode">Duration</code> message.</li>
<li class="numberedList">Version compatibility and interoperability while maintaining good performance.</li>
<li class="numberedList">Better horizontal scalability, and support for the Publisher/Subscriber pattern.</li>
<li class="numberedList">For two reasons. The operation is very fast, and the insertion in the first queue of a communication path must necessarily be a blocking operation. At least one blocking operation is always necessary to store the message in some permanent storage (usually a queue), so it can be recovered if the ongoing processing might fail for some reason.</li>
<li class="numberedList">With the following XML code:
        <pre class="programlisting code"><code class="hljs-code">&lt;ItemGroup&gt;
&lt;Protobuf Include="Protos\file1.proto" GrpcServices="Server/Client" /&gt;
&lt;Protobuf Include="Protos\file2.proto" GrpcServices="Server/Client" /&gt;
   ...
&lt;/ItemGroup&gt;
</code></pre>
</li>
</ol>
<p class="normal">Where <code class="inlineCode">Protos\file1.proto</code> and <code class="inlineCode">Protos\file2.proto</code> must be replaced with the actual paths to the <code class="inlineCode">ProtoBuf</code> files within our project. Moreover, the <code class="inlineCode">GrpcServices</code> attribute must be set to <code class="inlineCode">"Server"</code> or <code class="inlineCode">"Client"</code>, depending on whether the <code class="inlineCode">proto</code> file describes a server or not.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">With <code class="inlineCode">channel.BasicPublish(…)</code>.</li>
<li class="numberedList">With <code class="inlineCode">channel.WaitForConfirmsOrDie(timeout)</code>.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-504">Chapter 15</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">No, since this would violate the principle that a service reaction to a request must depend on the request itself, and not on other messages/requests that had previously been exchanged with the client.</li>
<li class="numberedList">No, implementing a service with a custom communication protocol is generally not good practice because it compromises interoperability, increases development and maintenance complexity, and isolates the service from widely used standards and tools. Standard protocols such as HTTP/REST, <code class="inlineCode">gRPC</code>, and others are preferred for their broad support, ease of integration, and community backing.</li>
<li class="numberedList">Yes, it can. The primary action of a POST must be creation, but deletion can be performed as a side effect. The HTTP verb to use is determined by the virtual table named in the URL (in our case, a POST, since the operation is an addition), but other operations can be performed on other virtual tables that are not mentioned in the URL as side effects.</li>
<li class="numberedList">Three; they are <code class="inlineCode">Base64</code> encoding of the header, <code class="inlineCode">Base64</code> encoding of the body, and the signature.</li>
<li class="numberedList">From the request body.</li>
<li class="numberedList">The <code class="inlineCode">ApiController</code> attribute sets up some default behaviors that help in the implementation of REST services.</li>
<li class="numberedList">The <code class="inlineCode">ProducesResponseType</code> attribute.</li>
<li class="numberedList">When using API controllers, they are declared with the <code class="inlineCode">Route</code> and <code class="inlineCode">Http&lt;verb&gt;</code> attributes. When using a minimal API, they are declared in the first argument of <code class="inlineCode">MapGet</code>, <code class="inlineCode">MapPost</code>, <code class="inlineCode">…</code> <code class="inlineCode">Map{Http verb}</code>.</li>
<li class="numberedList">By adding something like <code class="inlineCode">builder.Services.AddHttpClient&lt;MyProxy&gt;()</code> in the dependency injection part of the host configuration.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-505">Chapter 16</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Azure Functions is an Azure PaaS component that allows you to implement FaaS solutions.</li>
<li class="numberedList">You can program Azure Functions in different languages, such as C#, F#, PHP, Python, and Node.js. You can also create functions using the Azure portal and Visual Studio Code. Additional stacks can be used by using custom handlers: <a href="https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers">https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers</a>.</li>
<li class="numberedList">There are two plan options in Azure Functions. The first plan is the Consumption Plan, where you are charged according to the amount you use. The second plan is the App Service Plan, where you share your App Service resources with the function’s needs.</li>
<li class="numberedList">The process of deploying functions in Visual Studio is the same as in web app deployment.</li>
<li class="numberedList">There are lots of ways we can trigger Azure Functions, such as using Blob Storage, Cosmos DB, Event Grid, Event Hubs, HTTP, Microsoft Graph Events, Queue Storage, Service Bus, Timer, and Webhooks.</li>
<li class="numberedList">Azure Functions v1 needs the .NET Framework Engine, whereas v2 needs .NET Core 2.2, and v3 needs .NET Core 3.1 and .NET 5-6. v4 is the current version for .NET 6, 7, and 8.</li>
<li class="numberedList">The execution of every Azure function can be monitored by Application Insights. Here, you can check the time it took to process, resource usage, errors, and exceptions that happened in each function call.</li>
<li class="numberedList">They are functions that will let us write stateful workflows, managing the state behind the scenes.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-506">Chapter 17</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Typical middleware modules scaffolded by Visual Studio in an ASP.NET Core project include a developer exception page, request routing, static file serving, HTTPS redirection, authentication, and authorization.</li>
<li class="numberedList">No.</li>
<li class="numberedList">False. Several tag helpers can be invoked on the same tag.</li>
<li class="numberedList"><code class="inlineCode">ModelState.IsValid</code>.</li>
<li class="numberedList"><code class="inlineCode">@RenderBody()</code>.</li>
<li class="numberedList">We can use <code class="inlineCode">@RenderSection("Scripts", required: false)</code>.</li>
<li class="numberedList">We can use <code class="inlineCode">return View("viewname", ViewModel)</code>.</li>
<li class="numberedList">Three providers are included in ASP.NET Core, but they must be configured. If different providers are needed, they must be implemented by the developers and added to the providers list.</li>
<li class="numberedList">No, <code class="inlineCode">ViewModels</code> are not the only way for controllers to communicate with views in ASP.NET Core. Controllers can also use <code class="inlineCode">ViewData</code>, <code class="inlineCode">ViewData</code>, and <code class="inlineCode">TempData</code> to pass data to views.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-507">Chapter 18</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">API gateways work as interfaces for API microservices, while frontends take care of building web pages’ HTML.</li>
<li class="numberedList">Robust web servers optimize the whole request/response handling and ensure the needed level of security.</li>
<li class="numberedList">Because they have an impact on performance that is usually unacceptable for high-traffic microservices.</li>
<li class="numberedList">When transactions are quite fast and the probability of collision between transactions is low.</li>
<li class="numberedList">A better decoupling of the aggregates and commands methods.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-508">Chapter 19</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">It is a W3C standard: the assembly of a virtual machine running in W3C-compliant browsers.</li>
<li class="numberedList">A web UI where dynamic HTML is created in the browser itself.</li>
<li class="numberedList">Selecting a page based on the current browser URL.</li>
<li class="numberedList">A Blazor component with routes attached to it. For this reason, the Blazor router can select it.</li>
<li class="numberedList">Defining the .NET namespace of a Blazor component class.</li>
<li class="numberedList">A local service that takes care of storing and handling all form-related information, such as validation errors and changes in HTML inputs.</li>
<li class="numberedList">Either <code class="inlineCode">OnInitialized</code> or <code class="inlineCode">OnInitializedAsync</code>.</li>
<li class="numberedList">Callbacks and services.</li>
<li class="numberedList">Blazor’s way to interact with JavaScript.</li>
<li class="numberedList">Getting a reference to a component or HTML element instance.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-509">Chapter 20</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Services are needed to dispatch communication to pods, since a pod has no stable IP address.</li>
<li class="numberedList">Kubernetes offers higher-level entities called Ingresses that are built on top of services, empowering clusters with all the advanced capabilities offered by a web server, such as routing HTTP/HTTPS URLs from outside the cluster to internal service URLs inside the cluster.</li>
<li class="numberedList">Helm charts are a way to organize the templating and installation of complex Kubernetes applications that contain several <code class="inlineCode">.yaml</code> files.</li>
<li class="numberedList">Yes, with the <code class="inlineCode">---</code> separator.</li>
<li class="numberedList">Kubernetes detects container faults through liveness and readiness probes that check the health and availability of containers, ensuring they run as expected.</li>
<li class="numberedList">Because Pods, having no stable location, can’t rely on the storage of the node where they are currently running.</li>
<li class="numberedList"><code class="inlineCode">StatefulSet</code> is assumed to have state and achieve write/update parallelism through sharding, while <code class="inlineCode">ReplicaSet</code> has no state, so as it is indistinguishable, it can achieve parallelism by splitting the load.</li>
</ol>
<h1 class="heading-1" id="_idParaDest-510">Chapter 21</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">It is because it doesn’t support TCP/IP communications.</li>
<li class="numberedList">Visual Studio’s recommended tool to debug Kubernetes applications.</li>
<li class="numberedList">No, it works with any Kubernetes cluster that has been configured as the default cluster in the local Kubectl installation.</li>
<li class="numberedList">With something like <code class="inlineCode">minikube</code> <code class="inlineCode">image</code> <code class="inlineCode">load</code> <code class="inlineCode">grpcmicroservice:latest</code>.</li>
<li class="numberedList">It is enough to start Minikube, and Minikube’s start procedure will do it for you.</li>
</ol>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>