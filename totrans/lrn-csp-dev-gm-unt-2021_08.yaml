- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting Game Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we focused on using code to move the player and camera,
    with a trip into Unity physics on the side. However, controlling a playable character
    isn't enough to make a compelling game; in fact, it's probably the one area that
    remains fairly constant across different titles.
  prefs: []
  type: TYPE_NORMAL
- en: A game's unique spark comes from its core mechanics, and the feeling of power
    and agency those mechanics give to the players. Without fun and engrossing ways
    to affect the virtual environment you've created, your game doesn't stand a chance
    of repeat play, to say nothing of fun. As we venture into implementing the game's
    mechanics, we'll also be upgrading our knowledge of C# and its intermediate-level
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will build on the *Hero Born* prototype by focusing on individually
    implemented game mechanics, as well as the basics of system design and **user
    interfaces** (**UIs**). You''ll be diving into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding jumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooting projectiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a game manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding jumps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember from the last chapter that Rigidbody components add simulated real-world
    physics to GameObjects, and Collider components interact with each other using
    Rigidbody objects.
  prefs: []
  type: TYPE_NORMAL
- en: Another great thing that we didn't discuss in the previous chapter about using
    a Rigidbody component to control player movement is that we can easily add in
    different mechanics that rely on applied force, such as jumping. In this section,
    we'll get our player jumping and write our first utility function.
  prefs: []
  type: TYPE_NORMAL
- en: A utility function is a class method that performs some kind of grunt work so
    that we don't clutter up gameplay code—for instance, wanting to check whether
    the player capsule is touching the ground to jump.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, you'll need to get acquainted with a new data type called enumerations,
    which you'll do in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By definition, an enumeration type is a set, or collection, of named constants
    that belong to the same variable. These are useful when you want a collection
    of different values, but with the added benefit of them all being of the same
    parent type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easier to show rather than tell with enumerations, so let''s take a look
    at their syntax in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down how this works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` keyword declares the type followed by the variable name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different values an enum can have are written inside curly brackets, separated
    by a comma (except for the last item).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enum` has to end with a semicolon, just like all other data types we've
    worked with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we're declaring a variable called `PlayerAction`, of type `enum`,
    which can be set to one of three values—`Attack`, `Defend`, or `Flee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare an enumeration variable, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can break this down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The type is set as `PlayerAction`, since our enumeration is just like any other
    type, like a string or integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable is named `currentAction` and set equal to a `PlayerAction` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each enum constant can be accessed using dot notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our c`urrentAction` variable is now set to `Defend`, but it can be changed to
    `Attack` or `Flee` at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations may look simple at first glance, but they are extremely powerful
    in the right situations. One of their most useful features is the ability to store
    underlying types, which is the next subject you'll be jumping into.
  prefs: []
  type: TYPE_NORMAL
- en: Underlying types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enums come with an *underlying type*, meaning that each constant inside the
    curly brackets has an associated value. The default underlying type is `int` and
    starts at 0, just like arrays, with each sequential constant getting the next
    highest number.
  prefs: []
  type: TYPE_NORMAL
- en: Not all types are created equal—underlying types for enumerations are limited
    to `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`. These
    are called integral types, which are used to specify the size of numeric values
    that a variable can store.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a bit advanced for this book, but you''ll be using `int` in most cases.
    More information on these types can be found here: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our `PlayerAction` enumeration values right now are listed as
    follows, even though they aren''t explicitly written out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no rule that says underlying values need to start at `0`; in fact,
    all you have to do is specify the first value and then C# increments the rest
    of the values for us, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `Defend` equals `6`, and `Flee` equals `7` automatically.
    However, if we wanted the `PlayerAction` enum to hold non-sequential values, we
    could explicitly add them in, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even change the underlying type of `PlayerAction` to any of the approved
    types by adding a colon after the enum name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving an enum''s underlying type takes an explicit conversion, but we''ve
    already covered those, so the following syntax shouldn''t be a surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since `CurrentAction` is set to `Attack`, `ActionCost` would be `10` in the
    above example code.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations are extremely powerful tools in your programming arsenal. Your
    next challenge is to use your knowledge of enumerations to gather more specific
    user input from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic grasp of enumeration types, we can capture keyboard
    input using the `KeyCode` enum. Update the `PlayerBehavior` script with the following
    highlighted code, save it, and hit play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down this code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create two new variables—a public variable to hold the amount of applied
    jump force we want and a private boolean to check if our player should be jumping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the value of `_isJumping` to the `Input.GetKeyDown()` method, which returns
    a `bool` value depending on whether a specified key is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `|=` operator to set `_isJumping`, which is the logical `or` condition.
    This operator makes sure that we don't have consecutive input checks override
    each other when the player is jumping.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The method accepts a key parameter as either a `string` or a `KeyCode`, which
    is an enumeration type. We specify that we want to check for `KeyCode.Space`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for inputs in `FixedUpdate` can sometimes lead to input loss or even
    double inputs because it doesn't run once per frame. This is why we're checking
    for inputs in `Update` and then applying force or setting the velocity in `FixedUpdate`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We use an `if` statement to check if `_isJumping` is true, and trigger the jump
    mechanic if it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we already have the Rigidbody component stored, we can pass the `Vector3`
    and `ForceMode` parameters to `RigidBody.AddForce()` and make the player jump.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify that the vector (or applied force) should be in the `up` direction,
    multiplied by `JumpVelocity`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ForceMode` parameter determines how the force is applied and is also an
    enumeration type. `Impulse` delivers an instant force to an object while taking
    its mass into account, which is perfect for a jump mechanic.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other `ForceMode` choices can be useful in different situations, all of which
    are detailed here: [https://docs.unity3d.com/ScriptReference/ForceMode.html](https://docs.unity3d.com/ScriptReference/ForceMode.html).'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: At the end of every `FixedUpdate` frame, we reset `_isJumping` to false so the
    input check knows a complete jump and the landing cycle has been completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play the game now, you'll be able to move around and jump when you hit
    the spacebar. However, the mechanic allows you to keep jumping indefinitely, which
    isn't what we want. We'll work on limiting our jump mechanic to one at a time
    in the next section, using something called a layer mask.
  prefs: []
  type: TYPE_NORMAL
- en: Working with layer masks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of layer masks as invisible groups that a GameObject can belong to, used
    by the physics system to determine anything from navigation to intersecting collider
    components. While more advanced uses of layer masks are outside the scope of this
    book, we'll create and use one to perform a simple check—whether the player capsule
    is touching the ground, in order to limit the player to one jump at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can check that the player capsule is touching the ground, we need
    to add all the environment objects in our level to a custom layer mask. This will
    let us perform the actual collision calculation with the Capsule Collider component
    that''s already attached to the player. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select any environment GameObject in the **Hierarchy** and in the corresponding
    **Inspector** pane, click on **Layer** | **Add Layer...**, as illustrated in the
    following screenshot:![](img/B17573_08_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.1: Selecting layers in the Inspector pane'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a new layer called `Ground` by typing the name into the first available
    slot, which is Layer 6\. Layers 0-5 are reserved for Unity's default layers, even
    though Layer 3 is empty, as illustrated in the following screenshot:![](img/B17573_08_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.2: Adding layers in the Inspector pane'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Environment** parent GameObject in the **Hierarchy**, click on
    the **Layer** dropdown, and select **Ground**.![](img/B17573_08_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.3: Setting a custom layer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After you have selected the **Ground** option shown in the following screenshot,
    click **Yes, change children** when a dialog appears asking you if you want to
    change all child objects. Here, you've defined a new layer called **Ground** and
    assigned every child object of **Environment** to that layer.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, all the objects on the **Ground** layer can be checked to see
    if they intersect with a specific object. You'll use this in the following challenge
    to make sure the player can perform a jump if it's on the ground; no unlimited
    jump hacks here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we don''t want code cluttering up the `Update()` method, we''ll do our
    layer mask calculations in a utility function and return a `true` or `false` value
    based on the outcome. To do so, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to `PlayerBehavior` and play the scene again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `PlayerBehavior` script selected, set **Ground Layer** in the **Inspector**
    pane to **Ground** from the **Ground Layer** dropdown, as illustrated in the following
    screenshot:![](img/B17573_08_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.4: Setting the Ground Layer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s break down the preceding code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new variable for the distance we'll check between the player Capsule
    Collider and any **Ground Layer** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `LayerMask` variable that we can set in the **Inspector** and use
    for the collider detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a variable to store the player's Capsule Collider component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `GetComponent()` to find and return the Capsule Collider attached to
    the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We update the `if` statement to check whether `IsGrounded` returns `true` and
    the spacebar is pressed before executing the jump code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare the `IsGrounded()` method with a `bool` return type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a local `Vector3` variable to store the position at the bottom of
    the player's Capsule Collider, which we'll use to check for collisions with any
    objects on the **Ground** layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All Collider components have a `bounds` property, which gives us access to the
    min, max, and center positions of its *x*, *y*, and *z* axes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom of the collider is the 3D point at center *x*, min *y*, and center
    *z*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create a local `bool` to store the result of the `CheckCapsule()` method
    that we call from the `Physics` class, which takes in the following five arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The start of the capsule, which we set to the middle of the Capsule Collider
    since we only care about checking whether the bottom touches the ground.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The end of the capsule, which is the `capsuleBottom` position we've already
    calculated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The radius of the capsule, which is the `DistanceToGround` already set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The layer mask we want to check collisions on, set to `GroundLayer` in the **Inspector**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The query trigger interaction, which determines whether the method should ignore
    colliders that are set as triggers. Since we want to ignore all triggers, we used
    the `QueryTriggerInteraction.Ignore` enum.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We could also use the `Distance` method from the `Vector3` class to determine
    how far we are from the ground since we know the height of the player capsule.
    However, we're going to stick with using the `Physics` class since that's the
    focus of this chapter.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We return the value stored in `grounded` at the end of the calculation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could have done the collision calculation manually, but that would require
    more complex 3D math than we have time to cover here. However, it's always a good
    idea to use built-in methods when available.
  prefs: []
  type: TYPE_NORMAL
- en: That was an involved piece of code that we just added into `PlayerBehavior`,
    but when you break it down, the only new thing we did was use a method from the
    `Physics` class. In plain English, we supplied `CheckCapsule()` with a start and
    endpoint, a collision radius, and a layer mask. If the endpoint gets closer than
    the collision radius to an object on the layer mask, the method returns `true`—meaning
    the player is touching the ground. If the player is in a mid-jump position, `CheckCapsule()`
    returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're checking `IsGround` in the `if` statement every frame in `Update()`,
    our player's jump skills are only allowed when touching the ground.
  prefs: []
  type: TYPE_NORMAL
- en: That's all you're going to do with the jump mechanic, but the player still needs
    a way to interact and defend themself against the hordes of enemies that will
    eventually populate the arena. In the following section, you'll fix that gap by
    implementing a simple shooting mechanic.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting projectiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shooting mechanics are so common that it's hard to think of a first-person game
    without some variation present, and *Hero Born* is no different. In this section,
    we'll talk about how to instantiate GameObjects from Prefabs while the game is
    running, and use the skills we've learned to propel them forward using Unity physics.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of instantiating a GameObject in the game is similar to instantiating
    an instance of a class—both require starting values so that C# knows what kind
    of object we want to create and where it needs to be created. To create objects
    in the scene at runtime, we use the `Instantiate()` method and provide a Prefab
    object, a starting position, and a starting rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we can tell Unity to create a given object with all its components
    and scripts at this spot, looking in this direction, and then manipulate it as
    needed once it's born in the 3D space. Before we instantiate an object, you'll
    need to create the object Prefab itself, which is your next task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can shoot any projectiles, we''ll need a Prefab to use as a reference,
    so let''s create that now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **+** | **3D** **Object** | **Sphere** in the **Hierarchy** panel and
    name it `Bullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its **Scale** to 0.15 in the *x*, *y*, and *z* axes in the **Transform**
    component.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **Bullet** in the **Inspector** and use the **Add Component** button
    at the bottom to search for and add a **Rigidbody** component, leaving all default
    properties as they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new material in the `Materials` folder using **Create** | **Material**,
    and name it `Bullet_Mat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Albedo** property to a deep yellow.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag and drop the material from the **Materials** folder onto the `Bullet` GameObject
    in the **Hierarchy** pane.![](img/B17573_08_05.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.5: Setting projectile properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Bullet** in the **Hierarchy** panel and drag it into the `Prefabs`
    folder in the **Project** panel. Then, delete it from the **Hierarchy** to clean
    up the scene:![](img/B17573_08_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.6: Creating a projectile Prefab'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You created and configured a **Bullet** Prefab GameObject that can be instantiated
    as many times as we need in the game and updated as needed. This means you're
    ready for the next challenge—shooting projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the shooting mechanic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a Prefab object to work with, we can instantiate and move
    copies of the Prefab whenever we hit the left mouse button to create a shooting
    mechanic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `PlayerBehavior` script with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **Inspector**, drag the **Bullet** Prefab from the **Project** panel
    into the **Bullet** property of `PlayerBehavior`, as illustrated in the following
    screenshot:![](img/B17573_08_07.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.7: Setting the Bullet Prefab'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Play the game and use the left mouse button to fire projectiles in the direction
    the player is facing!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two variables: one to store the Bullet Prefab, the other to hold
    the Bullet speed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like our jumping mechanic, we use a boolean in the `Update` method to check
    if our player should be shooting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the value of `_isShooting` using the `or` logical operator and `Input.GetMouseButtonDown()`,
    which returns `true` if we're pushing the specified button, just like with `Input.GetKeyDown()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetMouseButtonDown()` takes an `int` parameter to determine which mouse button
    we want to check for; `0` is the left button, `1` is the right button, and `2`
    is the middle button or scroll wheel.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we check if our player is supposed to be shooting using the `_isShooting`
    input check variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a local GameObject variable every time the left mouse button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `Instantiate()` method to assign a GameObject to `newBullet` by passing
    in the `Bullet` Prefab. We also use the player capsule's position to place the
    new `Bullet` Prefab in front of the player to avoid any collisions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We append it as a `GameObject` to explicitly cast the returned object to the
    same type as `newBullet`, which in this case is a GameObject.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `GetComponent()` to return and store the Rigidbody component on `newBullet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We set the `velocity` property of the Rigidbody component to the player''s
    `transform.forward` direction multiplied by `BulletSpeed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing the `velocity` instead of using `AddForce()` ensures that gravity doesn't
    pull our bullets down in an arc when fired.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set the `_isShooting` value to `false` so our shooting input is
    reset for the next input event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, you've significantly upgraded the logic the player script is using. You
    should now be able to use the mouse to shoot projectiles that fly straight out
    from the player's position.
  prefs: []
  type: TYPE_NORMAL
- en: However, the problem now is that your game scene, and hierarchy, are flooded
    with spent Bullet objects. Your next task is to clean those objects up once they've
    been fired, to avoid any performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Managing object build-up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you're writing a completely code-based application or a 3D game, it's
    important to make sure that unused objects are regularly deleted to avoid overloading
    the program. Our bullets don't exactly play an important role after they are shot;
    they sort of just keep existing on the floor near whatever wall or object they
    collided with.
  prefs: []
  type: TYPE_NORMAL
- en: With a mechanic such as shooting, this could result in hundreds, if not thousands,
    of bullets down the line, which is something we don't want. Your next challenge
    is to destroy each bullet after a set delay time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this task, we can take the skills we''ve already learned and make the bullets
    responsible for their self-destructive behavior, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Scripts` folder and name it `BulletBehavior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop the `BulletBehavior` script onto the `Bullet` Prefab in the `Prefabs`
    folder and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down this code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a `float` variable to store how long we want the Bullet Prefabs to
    remain in the scene after they are instantiated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `Destroy()` method to delete the GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Destroy()` always needs an object as a parameter. In this case, we use the
    `this` keyword to specify the object that the script is attached to.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destroy()` can optionally take an additional `float` parameter as a delay,
    which we use to keep the bullets on screen for a short amount of time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Play the game again, shoot some bullets, and watch as they are deleted from
    the **Hierarchy** by themselves in the scene after a specific delay. This means
    that the bullet executes its defined behavior, without another script having to
    tell it what to do, which is an ideal application of the *Component* design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our housekeeping is done, you're going to learn about a key component
    of any well-designed and organized project—the manager class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common misconception when learning to program is that all variables should
    automatically be made public, but in general, this is not a good idea. In my experience,
    variables should be thought of as protected and private from the start, and only
    made public if necessary. One way you'll see experienced programmers protect their
    data is through manager classes, and since we want to build good habits, we'll
    be following suit. Think of manager classes as a funnel where important variables
    and methods can be accessed safely.
  prefs: []
  type: TYPE_NORMAL
- en: When I say safely, I mean just that, which might seem unfamiliar in a programming
    context. However, when you have different classes communicating and updating data
    with each other, things can get messy. That's why having a single contact point,
    such as a manager class, can keep this to a minimum. We'll get into how to do
    that effectively in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking player properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Hero Born* is a simple game, so the only two data points we need to keep track
    of are how many items the player has collected and how much health they have left.
    We want these variables to be private so that they can only be modified from the
    manager class, giving us control and safety. Your next challenge is to create
    a game manager for *Hero Born* and populate it with helpful functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Game manager classes will be a constant facet of any project you develop in
    the future, so let''s learn how to properly create one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Scripts` folder and name it `GameBehavior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually, this script would be named `GameManager`, but Unity reserves that name
    for its own scripts. If you ever create a script and a cogwheel icon shows up
    next to its name instead of the C# file icon, that tells you it's restricted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new empty game object in the **Hierarchy** by using **+** | **Create
    Empty**, and name it `Game_Manager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `GameBehavior.cs` script from the **Scripts** folder onto
    the `Game_Manager` object, as illustrated in the following screenshot:![](img/B17573_08_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.8: Attaching the game manager script'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Manager scripts, and other non-game files, are set up on empty objects to put
    them in the scene, even though they don't interact with the actual 3D space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to `GameBehavior.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's break down this code. We added two new `private` variables to hold the
    number of items picked up and how many lives the player has left; these are `private`
    because they should only be modifiable in this class. If they were made `public`,
    other classes could change them at will, which could lead to the variables storing
    incorrect or concurrent data.
  prefs: []
  type: TYPE_NORMAL
- en: Having these variables declared as `private` means that you are responsible
    for how they are accessed. The following topic on `get` and `set` properties will
    introduce you to a standard, safe way to accomplish this task going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The get and set properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've got our manager script and private variables set up, but how do we access
    them from other classes if they're private? While we could write separate public
    methods in `GameBehavior` to handle passing new values to the private variables,
    let's see whether there is a better way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, C# provides all variables with `get` and `set` properties, which
    are perfectly suited to our task. Think of these as methods that are automatically
    fired by the C# compiler whether we explicitly call them or not, similar to how
    `Start()` and `Update()` are executed by Unity when a scene starts.
  prefs: []
  type: TYPE_NORMAL
- en: '`get` and `set` properties can be added to any variable, with or without an
    initial value, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using them like this doesn''t add any additional benefits; for that,
    you need to include a code block for each property, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `get` and `set` properties are set up to execute additional logic,
    depending on where it's needed. We're not done yet though, as we still need to
    handle the new logic.
  prefs: []
  type: TYPE_NORMAL
- en: Every `get` code block needs to return a value, while every `set` block needs
    to
  prefs: []
  type: TYPE_NORMAL
- en: 'assign a value; this is where having a combination of a private variable, called
    a backing variable, and a public variable with `get` and `set` properties comes
    into play. The private variable remains protected, while the public variable allows
    controlled access from other classes, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can `return` the value stored in the private variable from the `get` property
    anytime another class needs it, without actually giving that outside class direct
    access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can update the private variable any time an outside class assigns a new value
    to the public variable, keeping them in sync.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `value` keyword is a stand-in for whatever new value is assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can seem a little esoteric without an actual application, so let's update
    `GameBehavior` with public variables with getter and setter properties to go along
    with our existing private variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the syntax of the `get` and `set` property accessors,
    we can implement them in our manager class for greater efficiency and code readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the code in `GameBehavior`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a new `public` variable called `Items` with `get` and `set` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `get` property to `return` the value stored in `_itemsCollected`
    whenever `Items` are accessed from an outside class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `set` property to assign `_itemsCollected` to the new `value` of
    `Items` whenever it's updated, with an added `Debug.LogFormat()` call to print
    out the modified value of `_itemsCollected`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set up a `public` variable called `HP` with `get` and `set` properties to
    complement the private `_playerHP` backing variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both private variables are now readable, but only through their public counterparts;
    they can only be changed in `GameBehavior`. With this setup, we ensure that our
    private data can only be accessed and modified from specific contact points. This
    makes it easier to communicate with `GameBehavior` from our other mechanical scripts,
    as well as to display the real-time data in the simple UI we'll create at the
    end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test this out by updating the `Items` property when we successfully interact
    with an item pickup in the arena.
  prefs: []
  type: TYPE_NORMAL
- en: Updating item collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our variables set up in `GameBehavior`, we can update `Items`
    every time we collect an `Item` in the scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the `ItemBehavior` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hit play and collect the pickup item to see the new console log print out from
    the manager script, as illustrated in the following screenshot:![](img/B17573_08_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.9: Collecting a pickup item'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new variable of the `GameBehavior` type to store a reference to
    the attached script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `Start()` to initialize `GameManager` by looking it up in the scene with
    `Find()` and adding a call to `GetComponent()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see this kind of code done in a single line quite often in Unity documentation
    and community projects. This is done for simplicity, but if you feel more comfortable
    writing out the `Find()` and `GetComponent()` calls separately, go right ahead;
    there's nothing wrong with clear, explicit formatting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We increment the `Items` property in the `GameManager` class in `OnCollisionEnter()`
    after the Item Prefab is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we already set up `ItemBehavior` to take care of collision logic, it's
    easy to modify `OnCollisionEnter()` to communicate with our manager class when
    an item is picked up by the player. Keep in mind that separating functionality
    like this is what makes the code more flexible and less likely to break as you
    make changes during development.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece *Hero Born* is missing is some kind of interface that displays
    game data to the player. In programming and game development, this is called a
    UI. Your final task in this chapter is to familiarize yourself with how Unity
    creates and handles the UI code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have several scripts working together to give players access
    to movement, jumping, collecting, and shooting mechanics. However, we're still
    missing any kind of display or visual cue that shows our player's stats, as well
    as a way to win and lose the game. We'll focus on these two topics as we close
    out this last section.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying player stats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UIs are the visual components of any computer system. The mouse cursor, folder
    icons, and programs on your laptop are all UI elements. For our game, we want
    a simple display to let our players know how many items they've collected, their
    current health, and a textbox to give them updates when certain events happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'UI elements in Unity can be added in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly from the **+** menu in the **Hierarchy** panel, like with any other
    GameObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the built-in GUI class in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're going to stick with the first option, since the built-in GUI classes are
    part of the Unity legacy UI system, and we want to stay current, right? This isn't
    to say that you can't do everything programmatically, but for our prototype, the
    newer UI systems are a better fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re curious about programmatic UI in Unity, take a look at the documentation
    yourself: [https://docs.unity3d.com/ScriptReference/GUI.html](https://docs.unity3d.com/ScriptReference/GUI.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Your next task is to add a simple UI to the game scene that displays the items
    collected, player health, and progress information variables that are stored in
    `GameBehavior.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create three text objects in our scene. User interfaces in Unity
    work off of a canvas, which is exactly what it sounds like. Think of the canvas
    as a blank painting that you can draw on that Unity will render on top of the
    game world for you. Whenever you create your first UI element in the **Hierarchy**
    panel, a **Canvas** parent object is created along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** panel and select **UI** | **Text** and name
    the new object **Health**. This will create a **Canvas** parent object and the
    new **Text** object all at once:![](img/B17573_08_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.10: Creating a Text element'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To see the canvas correctly, select **2D** mode at the top of the **Scene**
    tab. From this view, our entire level is that tiny white line in the lower-left
    hand corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even though the **Canvas** and level don't overlap in the scene, when the game
    plays Unity will automatically overlay them correctly.![](img/B17573_08_11.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.11: Canvas in the Unity editor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you select the **Health** object in the **Hierarchy**, you'll see that the
    new text object was created in the lower-left corner of the canvas by default,
    and it has a whole list of customizable properties, like text and color, in the
    **Inspector** pane:![](img/B17573_08_12.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.12: Text element on the Unity Canvas'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the **Health** object selected in the **Hierarchy** pane, click on the
    **Anchor** presets in the **Rect Transform** component of the **Inspector** and
    choose **Top Left**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anchors set a UI element's point of reference on the canvas, meaning that whatever
    the size of the device screen, our health points will always be anchored to the
    top left of the screen:![](img/B17573_08_13.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.13: Setting anchor presets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Inspector** pane, change the **Rect Transform** position to **100**
    on the **X** axis and **–30** on the **Y** axis to position the text in the upper-right
    corner. Also change the **Text** property to say **Player Health:**. We'll be
    setting the actual value in code in a later step:![](img/B17573_08_14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.14: Setting text properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Repeat steps 1-5 to create a new UI **Text** object and name it **Items**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the anchor presets to **Top Left**, the **Pos X** to **100**, and the **Pos
    Y** to **–60**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Text** to **Items Collected:**![](img/B17573_08_15.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.15: Creating another Text element'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Repeat *steps 1-5* to create a new UI **Text** object and name it **Progress**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the anchor presets to **Bottom Center**, the **Pos X** to **0**, the **Pos
    Y** to **15**, and the **Width** to **280**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Text** to **Collect all the items and win your freedom!**![](img/B17573_08_16.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.16: Creating a progress text element'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our UI set up, let''s connect the variables we already have
    in our game manager script. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `GameBehavior` with the following code to collect an item and display
    on-screen text when items are collected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select **Game_Manager** in the **Hierarchy** and drag over our three text objects
    one by one into their corresponding `GameBehavior` script fields in the **Inspector**:![](img/B17573_08_17.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.17: Dragging text elements to script components'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the game and take a look at our new onscreen GUI boxes, shown in the following
    screenshot:![](img/B17573_08_18.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.18: Testing UI elements in play mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `UnityEngine.UI` namespace so we have access to the **Text** variable
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new public variable for the max number of items in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create three new **Text** variables, which we connect in the **Inspector**
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `Start` method to set the initial values of our health and
    items text using the **+=** operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time an item is collected, we update the `text` property of **ItemText**
    to show the updated `items` count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare an `if` statement in the set property of `_itemsCollected`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player has gathered more than or equal to `MaxItems`, they've won, and
    `ProgressText.text` is updated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, `ProgressText.text` shows how many items are still left to collect.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player's health is damaged, which we'll cover in the next chapter,
    we update the `text` property of `HealthText` with the new value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we play the game now, our three UI elements show up with the correct values;
    when an Item is collected, the `ProgressText` and `_itemsCollected` counts update,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_08_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Updating the UI text'
  prefs: []
  type: TYPE_NORMAL
- en: Every game can either be won or lost. In the last section of this chapter, your
    task is to implement those conditions and the UI that goes along with them.
  prefs: []
  type: TYPE_NORMAL
- en: Win and loss conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve implemented our core game mechanics and a simple UI, but *Hero Born*
    is still missing an important game design element: its win and loss conditions.
    These conditions will manage how the player wins or loses the game and execute
    different code depending on the situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the game document from *Chapter 6*, *Getting Your Hands Dirty with
    Unity*, we set out our win and loss conditions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting all items in the level with at least 1 health point remaining to
    win
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking damage from enemies until health points are at 0 to lose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These conditions are going to affect both our UI and game mechanics, but we've
    already set up `GameBehavior` to handle this efficiently. Our `get` and `set`
    properties will handle any game-related logic and changes to the UI when a player
    wins or loses.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to implement the win condition logic in this section because we
    have the pickup system already in place. When we get to the enemy AI behavior
    in the next chapter, we'll add in the loss condition logic. Your next task is
    to determine when the game is won in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We always want to give players clear and immediate feedback, so we''ll start
    by adding in the logic for a win condition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `GameBehavior` to match the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right-click in the **Hierarchy** and select **UI** | **Button**, then name
    it **Win Condition**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win Condition** and set the **Pos X** and **Pos Y** to **0**, its **Width**
    to **225**, and its **Height** to **115**.![](img/B17573_08_20.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.20: Creating a UI button'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the arrow to the right of the **Win Condition** button to expand its
    text child object, then change the text to say **You won!**:![](img/B17573_08_21.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.21: Updating button text'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Win Condition** parent object again and click the checkmark icon
    in the upper right of the **Inspector**.![](img/B17573_08_22.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.22: Deactivating the game object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will hide the button until we''ve won the game:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_08_23.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.23: Testing the hidden UI button'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Game_Manager** in the **Hierarchy** and drag the **Win Condition**
    button from the **Hierarchy** to the **Game Behavior (Script)** in the **Inspector**,
    just like we did with the text objects:![](img/B17573_08_24.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.24: Dragging the UI button onto the script component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change **Max Items** to `1` in the **Inspector** to test out the new screen,
    as illustrated in the following screenshot:![](img/B17573_08_25.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.25: Showing the win screen'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a UI button variable to connect to our Win Condition button in the
    **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we set the Win Condition button as **Hidden** when the game starts, we
    reactivate it when the game is won.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Max Items** set to `1`, the **Win** button will show up on collecting
    the only `Pickup_Item` in the scene. Clicking the button doesn't do anything right
    now, but we'll address that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and restarting the game with using directives and namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, our win condition works as expected, but the player still has control
    over the capsule and doesn't have a way of restarting the game once it's over.
    Unity provides a property in the `Time` class called `timeScale`, which when set
    to `0` freezes the game scene. However, to restart the game, we need access to
    a **namespace** called `SceneManagement` that isn't accessible from our classes
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: A namespace collects and groups a set of classes under a specific name to organize
    large projects and avoid conflicts between scripts that may share the same names.
    A `using` directive needs to be added to a class to access a namespace's classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'All C# scripts created from Unity come with three default `using` directives,
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These allow access to common namespaces, but Unity and C# offer plenty more
    that can be added with the `using` keyword followed by the name of the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Since our game will need to be paused and restarted when a player wins or loses,
    this is a good time to use a namespace that isn't included in new C# scripts by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `GameBehavior` and play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select **Win Condition** from the **Hierarchy**, scroll down in the **Inspector**
    to the **OnClick** section of the **Button** component, and hit the plus icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every UI button has an **OnClick** event, which means you can assign a method
    from a script to execute when the button is pushed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have multiple methods fire when a button is clicked, but we only need
    one in this case:![](img/B17573_08_26.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8.26: OnClick section of the button'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the **Hierarchy**, drag the **Game_Manager** into the slot underneath **Runtime**
    to tell the button we want to choose a method from our manager script to fire
    when the button is pushed:![](img/B17573_08_27.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.27: Setting the game manager object in On Click'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **No Function** dropdown and choose **GameBehavior** | **RestartScene
    ()** to set the method we want the button to execute:![](img/B17573_08_28.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.28: Choosing the restart method for the button click'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to **Window** | **Rendering** | **Lighting** and select **Generate Lighting**
    at the bottom. Make sure **Auto Generate** is not selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step is necessary to address a Unity issue that reloads scenes without
    any lighting.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_08_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.29: Lighting panel in the Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `SceneManagement` namespace with the `using` keyword, which handles
    all scene-related logic like creating loading scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set `Time.timeScale` to `0` to pause the game when the win screen is displayed,
    which disables any input or movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a new method called `RestartScene` and call `LoadScene()` when the
    win screen button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LoadScene()` takes in a scene index as an `int` parameter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because there is only one scene in our project, we use index `0` to restart
    the game from the beginning.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We reset `Time.timeScale` to the default value of `1` so that when the scene
    restarts, all controls and behaviors will be able to execute again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you collect an item and click on the win screen button, the level
    restarts, with all scripts and components restored to their original values and
    set up for another round!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! *Hero Born* is now a playable prototype. We implemented jumping
    and shooting mechanics, managed physics collisions and spawning objects, and added
    in a few basic UI elements to display feedback. We even got as far as resetting
    the level when the player wins.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of new topics were introduced in this chapter, and it's important to go
    back and make sure you understand what went into the code we wrote. Pay special
    attention to our discussions on enumerations, `get` and `set` properties, and
    namespaces. From here on in, the code is only going to get more complex as we
    dive further into the possibilities of the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start working on getting our enemy GameObjects to
    take notice of our player when we get too close, resulting in a follow-and-shoot
    protocol that will up the stakes for our player.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – working with mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of data do enumerations store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you create a copy of a Prefab GameObject in an active scene?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which variable properties allow you to add functionality when their value is
    referenced or modified?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Unity method displays all UI objects in the scene?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  prefs: []
  type: TYPE_IMG
