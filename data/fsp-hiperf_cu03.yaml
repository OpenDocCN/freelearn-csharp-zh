- en: Chapter 3. Optimizing Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。优化数据结构
- en: It is common in many applications to leverage all kind of objects that are used
    as data. The types of data can be primitive, object reference, and collection
    types. F# itself has its own unique types, especially collection types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，利用所有用作数据的对象是很常见的。数据类型可以是原始类型、对象引用和集合类型。F#本身也有其独特的类型，特别是集合类型。
- en: These types, especially when doing many computing-intensive operations, are
    crucial. Optimizations need not only relate to the location of the value of data
    stored according to the types, but also how we access them can have a big impact
    on overall performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型，尤其是在进行大量计算密集型操作时，至关重要。优化不仅需要与数据存储的类型值的位置相关，而且我们如何访问它们也会对整体性能产生重大影响。
- en: The deciding factors determining the best types to use, besides the memory locations,
    can vary. This is why it is quite hard to measure qualitatively. Measuring quantitatively
    can be tricky, although the statistical numbers may be informative.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 决定最佳使用类型的决定因素，除了内存位置外，可能各不相同。这就是为什么很难进行定性测量。虽然统计数据可能具有参考价值，但定量测量可能很棘手。
- en: We shall use the knowledge gained in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement* relating to the
    qualitative understanding of the internals of running F# code (the IL, tooling,
    and the GC) and have quantitative measures (the execution durations using timers
    and unit tests) as a gentle requirement for this chapter and the rest of this
    book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第2章](fsp-hiperf_cu02.html#aid-K0RQ2 "第2章。性能测量")中获得的关于性能测量的知识，即对运行F#代码内部（IL、工具和GC）的定性理解，以及使用计时器和单元测试的执行持续时间作为本章以及本书其余部分的温和要求。
- en: The knowledge of IL assembly and the fundamentals of .NET GC will help us to
    understand the internal working of .NET and F#'s unique data structures. Then
    we can optimize them by deciding the best use cases and the best types to choose
    for our specific needs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 了解IL汇编和.NET GC的基本原理将帮助我们理解.NET和F#独特数据结构的内部工作原理。然后我们可以通过决定最佳用例和为特定需求选择最佳类型来优化它们。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A basic knowledge of .NET 4 BCL types and collections (including those that
    shipped out of band/OOB, such as immutable collections) is needed. There should
    be no easy way of thinking or taking shortcuts when using a type/collection for
    all cases, for example, using .NET advanced collection such as `BindingList<T>`
    explicitly for all collections that are only meant to be read and forwarded instead
    of `IEnumerable<T>` or `List<T>`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解.NET 4 BCL类型和集合（包括那些带外/OOB发布的，如不可变集合）的基本知识。在使用类型/集合时，不应存在任何简单思维或走捷径的方法，例如，对于仅用于读取和转发的集合，明确使用.NET高级集合如`BindingList<T>`，而不是`IEnumerable<T>`或`List<T>`。
- en: 'This chapter provides an overview of the available types in F# and the best
    practices to choose, use, and optimize. The data structure optimization is covered
    in the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了F#中可用的类型以及选择、使用和优化的最佳实践。数据结构优化将在以下主题中介绍：
- en: Overview of the types to store specific data in F# and their best usages (including
    structs, classes, and records)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F#中存储特定数据类型的概述及其最佳使用方法（包括结构体、类和记录）
- en: Best practices in using F# collections, with a comparison to .NET collections
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用F#集合的最佳实践，与.NET集合的比较
- en: Best practices in choosing an evaluation strategy (lazy or eager)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择评估策略（懒加载或急加载）的最佳实践
- en: Overview and best practices of types in F#
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F#类型概述和最佳实践
- en: To store a value as data, every value needs to have a type, especially for static
    typed languages such as F#, C#, and VB. Many modern programming languages after
    the year 2000 put emphasis on types as the type of value of the data, instead
    of using the simple term of *data structure*. The types here also mean the types
    that are not just concrete types, but also generic types when used in conjunction
    with concrete types.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值作为数据存储，每个值都需要有一个类型，尤其是对于像F#、C#和VB这样的静态类型语言。2000年之后的许多现代编程语言都将类型作为数据值的类型，而不是使用简单的术语“数据结构”。这里的类型也意味着不仅包括具体类型，还包括与具体类型一起使用时的泛型类型。
- en: Static typing versus dynamic typing
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类型与动态类型
- en: F# by default has no built-in support for defining and optimizing types to store
    data as dynamic types on top of **Dynamic Language Runtime** (**DLR**). This dynamic
    type support is available in the form of a library from the F# FSSF open source
    project communities, the *FSharp.Interop.Dynamic*. This is available at [https://github.com/fsprojects/FSharp.Interop.Dynamic](https://github.com/fsprojects/FSharp.Interop.Dynamic).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: F# 默认情况下没有内置支持来定义和优化类型，以便在 **动态语言运行时**（**DLR**）之上存储数据作为动态类型。这种动态类型支持以库的形式存在于
    F# FSSF 开源项目社区中，名为 *FSharp.Interop.Dynamic*。该库可在以下网址找到：[https://github.com/fsprojects/FSharp.Interop.Dynamic](https://github.com/fsprojects/FSharp.Interop.Dynamic)。
- en: This library is also available as a NuGet package as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此库也作为 NuGet 包提供。
- en: DLR is basically an extension that runs on top of CLR to provide an infrastructure
    for dynamically typed languages such as Python, Ruby, and JavaScript that have
    no restriction on type definition. This means that any type is typed as dynamic
    in the beginning at the compile time, and the type resolution is resolved at the
    runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DLR 基本上是一个在 CLR 之上运行的扩展，为没有类型定义限制的动态类型语言（如 Python、Ruby 和 JavaScript）提供基础设施。这意味着任何类型在编译时都被视为动态类型，类型解析在运行时解决。
- en: The impact of this dynamic type resolution has decreased performance at the
    initial runtime, as the type has to be resolved at runtime instead of compile
    time. Therefore, the use of dynamic types is not recommended, although F# can
    support dynamic type interoperability by having interop with DLR as demonstrated
    by *FSharp.Interop.Dynamic* library..
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态类型解析对初始运行时性能产生了影响，因为类型必须在运行时解析而不是编译时。因此，不建议使用动态类型，尽管 F# 可以通过与 DLR 的互操作来支持动态类型互操作性，如
    *FSharp.Interop.Dynamic* 库所示。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since .NET Framework 4.0 (and CLR 4.0), DLR is included in the framework, and
    not as a separate download anymore. The original DLR repository is hosted in CodePlex,
    but the rest of the DLR development in .NET 4.0 is continued in Microsoft's .NET
    GitHub repo of .NET CLR.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 .NET Framework 4.0（以及 CLR 4.0）以来，DLR 已包含在框架中，不再作为单独的下载。原始 DLR 仓库托管在 CodePlex，但
    .NET 4.0 中 DLR 的其余开发工作继续在 Microsoft 的 .NET GitHub 仓库的 .NET CLR 中进行。
- en: For more information about DLR, visit the following landing page of MSDN at [https://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 DLR 的信息，请访问以下 MSDN 的着陆页面：[https://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd233052(v=vs.110).aspx)。
- en: In functional programming languages, it is also implicitly required to have
    static typing because it's also part of the requirements of having a type inference
    feature. Having type inference is very crucial, as functional programming needs
    to be as concise and as close as possible to mathematical function syntaxes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程语言中，隐式地需要静态类型，因为这也是类型推断功能要求的一部分。类型推断非常重要，因为函数式编程需要尽可能简洁，并且尽可能接近数学函数语法。
- en: The use of dynamic type is against the common best practices of functional programming
    languages. Types are inferred statically and therefore resolved at compile time.
    Inferring type statically also gives us the ability to compose functions and values
    intuitively without worrying about casting and boxing at runtime. The nature of
    easily composing functions (operations in OOP) is one of the *main traits* (or
    required features) of functional programming languages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态类型违反了函数式编程语言的常见最佳实践。类型是静态推断的，因此会在编译时解析。静态类型推断还赋予我们直观地组合函数和值的能力，而无需担心运行时的类型转换和装箱。易于组合函数（面向对象中的操作）是函数式编程语言的主要特性（或必需功能）之一。
- en: 'Static typing has these following advantages over dynamic typing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型相对于动态类型有以下优势：
- en: Type resolutions are solved at compile time. All of the inconsistencies of invalid
    value assignments or casts always give compile errors. A compile error is easier
    to fix than a runtime error.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型解析在编译时解决。所有无效值赋值或转换的不一致性都会导致编译错误。编译错误比运行时错误更容易修复。
- en: Because of the type resolution at the compile time, the compile time is slower
    than the compile time of the dynamic type. Because the type resolution may add
    overheads when compiling, a slower performance is to be expected. Because the
    type resolution itself is in action, this is closely related to the F# compile
    phases of lexing and parsing. The compiler can perform more optimization by having
    incremental compilation as the background process under the infrastructure of
    Visual Studio tooling.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于编译时进行类型解析，因此编译时间比动态类型的编译时间要慢。因为类型解析在编译时可能会增加开销，所以预期性能会较慢。由于类型解析本身正在执行，这与其紧密相关F#的编译阶段，包括词法分析和解析。在Visual
    Studio工具集的增量编译作为后台进程的架构下，编译器可以通过这种方式进行更多的优化。
- en: Static type is also more reasonable to reason about the code, since all of the
    variables and functions have types that flow nicely.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型也更合理地推理代码，因为所有变量和函数都有类型，并且类型流动得很好。
- en: Having the knowledge of static type gives innovative and useful features such
    as code completion when accessing F# modules and functions, including the function
    parameter's type resolutions and XML summary documentation.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解静态类型提供了创新和有用的功能，例如在访问F#模块和函数时进行代码完成，包括函数参数的类型解析和XML摘要文档。
- en: The term *code completion* is also called statement completion in Microsoft's
    MSDN Library. It means that when we code in the IDE, the language service will
    provide richer information about the type and its members (properties, function/methods,
    and events) and display it to us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*代码完成*在微软的MSDN库中也称为语句完成。这意味着当我们使用IDE进行编码时，语言服务将提供有关类型及其成员（属性、函数/方法、事件）的更丰富信息，并将其显示给我们。
- en: Visual Studio since Visual Studio 5.0 has a robust feature called **Intellisense**
    that shows automatically the information about the type as we type `.` (dot) after
    the variable name.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Visual Studio 5.0以来，Visual Studio就有一个强大的功能，称为**Intellisense**，它会在我们输入变量名后的`.`（点）自动显示类型信息。
- en: 'This picture of F# code being edited shows Intellisense in action:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这张F#代码编辑的图片显示了Intellisense正在工作：
- en: '![Static typing versus dynamic typing](img/image00285.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![静态类型与动态类型对比](img/image00285.jpeg)'
- en: Intellisense is active by default, and it is highly recommended to keep the
    setting as active. It adds little overhead on loading type information in the
    background as the compiler runs in the background, but it definitely increases
    productivity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Intellisense默认是激活的，强烈建议保持此设置为激活状态。它在后台加载类型信息时几乎不增加开销，因为编译器在后台运行，但它确实提高了生产力。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although called statement completion by Microsoft, its use is not just for the
    code's statement completion. It is used in a broader sense in statements, class/module
    members including functions/methods, and public/protected/internal properties.
    Intellisense is also helpful in decreasing compiler errors because the full metadata
    becomes available at the frontend, minimizing compiler errors because of incorrect
    type names or syntax errors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微软称之为语句完成，但其用途不仅限于代码的语句完成。它在更广泛的意义上用于语句、类/模块成员（包括函数/方法）以及公共/受保护/内部属性。Intellisense还有助于减少编译错误，因为完整的元数据在前端变得可用，从而最小化了由于类型名称或语法错误导致的编译错误。
- en: The technique of having type resolution at compile time is often called **early
    bound**, compared to the **late bound** nature of dynamic typing solved at runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时具有类型解析的技术通常被称为**早期绑定**，与在运行时解决的动态类型**晚期绑定**特性相对。
- en: 'This is related to one of the main traits of functional programming: function
    and data are the same first-class citizens of the functional programming language
    itself. To maintain this inseparable concept as a function and data, type inference
    must flow nicely. And type inference explicitly requires that the type must have
    a definition and must have strong type support as well.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这与函数式编程的主要特性之一相关：函数和数据是函数式编程语言本身的第一等公民。为了保持函数和数据不可分割的概念，类型推断必须流畅。并且类型推断明确要求类型必须有一个定义，并且必须有强大的类型支持。
- en: 'For more details about the traits of functional programming languages, we can
    check out F#''s documentation from MSDN. MSDN has simple but concise definitions
    of the required features of functional programming in F#:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数式编程语言的特性更详细的介绍，我们可以查看MSDN上的F#文档。MSDN对F#中函数式编程所需特性的定义简单而简洁：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/functions-as-first-class-values-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/functions-as-first-class-values-%5bfsharp%5d)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/functions-as-first-class-values-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/functions-as-first-class-values-%5bfsharp%5d)'
- en: Therefore, we will not discuss further the dynamic type support in F# because
    it's not recommended in the sense of the functional programming perspective and
    the performance at runtime. Throughout the rest of this book, we will only focus
    on the static typing of F#.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会进一步讨论 F# 中的动态类型支持，因为在函数式编程视角和运行时性能方面并不推荐。在这本书的其余部分，我们将只关注 F# 的静态类型。
- en: Quick introduction to types in F#
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 中类型的快速介绍。
- en: 'Types in F# are basically categorized as two types: types in .NET BCL and types
    that are only available in F#. Although there are types specific to F#, these
    F# types can be used in C#/VB because basically all F# types are implemented on
    top of .NET CLR.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的类型基本上分为两种类型：.NET BCL 中的类型和仅在 F# 中可用的类型。尽管有特定的 F# 类型，但这些 F# 类型可以在 C#/VB
    中使用，因为基本上所有 F# 类型都是基于 .NET CLR 实现的。
- en: 'Based on .NET CLI standard partition I section I.8.2 about value types and
    reference types, the documentation is divided into two kinds of types:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 .NET CLI 标准分区 I 部分 I.8.2 关于值类型和引用类型的说明，文档分为两种类型的类型：
- en: '**Value type**: The values described by a value type are self-contained (each
    can be understood without reference to other values). It is using one of the basic,
    built-in data types or a user-defined structure. The exception of this built-in
    type is a string; it is reference type. In F#/C#/VB, this value type is also known
    as a structure or struct.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值类型**：由值类型描述的值是自包含的（每个都可以在不参考其他值的情况下理解）。它使用基本、内置的数据类型或用户定义的结构。这个内置类型的例外是一个字符串；它是引用类型。在
    F#/C#/VB 中，这种值类型也被称为结构或 struct。'
- en: '**Reference type**: The value denotes the location of another value. The location
    is actually a pointer to a location of a value.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考类型**：该值表示另一个值的定位。实际上，该定位是一个指向值位置的指针。'
- en: 'There are four kinds of reference type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的引用类型：
- en: An object type is a reference type of a self-describing value. Some object types
    (for example, abstract classes) are only a partial description of a value.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类型是自描述值的引用类型。一些对象类型（例如，抽象类）只是值的部分描述。
- en: An interface type is always a partial description of a value, potentially supported
    by many object types.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口类型始终是值的部分描述，可能由许多对象类型支持。
- en: A pointer type is a compile-time description of a value whose representation
    is a machine address of a location. Pointers are divided into managed and unmanaged.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针类型是对值的表示为机器地址的位置的编译时描述。指针分为托管和非托管。
- en: Built-in reference types.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的引用类型。
- en: There is also support for generic parameterized types built in the fabric of
    CIL/CLR. The notation of a generic type in CIL/CLR is also enriched with covariance/contravariance
    support. It is mandatory for all of static programming languages run on top of
    CIL/CLR to have at least support for basic generic type, although covariance/contravariance
    may not be supported at language level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CIL/CLR 的结构中也支持泛型参数化类型。CIL/CLR 中泛型类型的表示法也通过协变/逆变支持得到了丰富。对于所有在 CIL/CLR 上运行的静态编程语言来说，至少支持基本泛型类型是强制性的，尽管在语言级别可能不支持协变/逆变。
- en: By further looking at the CLS rule of CIL/CLR, we shall see that covariance/contravariance
    support is not mandatory. For further information, we can check the CLS rule starting
    at section I.7.3 of CIL/CLR ECMA-335 standard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进一步查看 CIL/CLR 的 CLS 规则，我们将看到协变/逆变支持不是强制性的。有关更多信息，我们可以查看 CIL/CLR ECMA-335 标准的
    I.7.3 节的 CLS 规则。
- en: Quick overview of generic type support in F#
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 中泛型类型支持的快速概述。
- en: F# has generic type as the parameterized type support, just as in C#/VB, and
    all have the same concept and similar semantics, although F# goes further by allowing
    type generalizations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有泛型类型作为参数化类型支持，就像在 C#/VB 中一样，并且它们都有相同的概念和相似的语义，尽管 F# 通过允许类型泛化更进一步。
- en: 'For example, in F#, to declare a type that has a generic type parameter in
    use:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 F# 中，要声明一个具有泛型类型参数的类型：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the parameter is used in code, the parameter of the generic type must be
    filled in, such as in this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码中使用参数，则必须填写泛型类型的参数，例如在这个例子中：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our last example, the generic type becomes specialized as `int`. The `List`
    is a sample of a concrete type that has a generic type as the type parameter.
    This concept is also similar to the semantics in C#/VB.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后的例子中，泛型类型变成了 `int` 的特化。`List` 是一个具有泛型类型作为类型参数的具体类型的示例。这个概念也与 C#/VB 中的语义相似。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, the types in F# that support the generic type such as
    F# `List`, `Map`, `Set`, and `Array` will use the same notation as F# types in
    the MSDN Library, although the complete compilation name may differ. For example,
    F# `Map` type is known as `FSharpMap` from outside of F#'s scope (when used in
    other languages such as C#/VB).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，支持泛型的 F# 类型，如 F# 的 `List`、`Map`、`Set` 和 `Array`，将使用与 MSDN 图书馆中 F# 类型相同的符号，尽管完整的编译名称可能不同。例如，F#
    的 `Map` 类型在 F# 范围之外被称为 `FSharpMap`（当在 C#/VB 等其他语言中使用时）。
- en: 'There is also a unique way in F# to treat generics: the statically resolved
    generic. According to the F# documentation in the MSDN Library:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中处理泛型还有独特的方法：静态解析泛型。根据 MSDN 图书馆中的 F# 文档：
- en: '*"Statically resolved generic is a type parameter that is replaced with an
    actual type at compile time instead of at run time. They are preceded by a caret
    (^) symbol."*'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"静态解析泛型是一个在编译时而不是在运行时用实际类型替换的类型参数。它们前面有一个 caret (^) 符号。"*'
- en: 'Using a statically resolved generic type parameter is more efficient than the
    normal generic type, but there is one caveat: it cannot be used on functions or
    methods that are not inline. It is also orthogonal at the normal generic type:
    normal generic type cannot be used on inline functions. The usage of statically
    resolved generics is discussed further in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimizations*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态解析泛型类型参数比普通泛型类型更高效，但有一个缺点：它不能用于非内联的函数或方法。它也与普通泛型类型正交：普通泛型类型不能用于内联函数。静态解析泛型的使用在
    [第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化") *语言特性和结构优化* 中进一步讨论。
- en: 'For official information on the F# statically resolved type, please consult
    the MSDN Library:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 F# 静态解析类型的官方信息，请参考 MSDN 图书馆：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/statically-resolved-type-parameters-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/statically-resolved-type-parameters-%5Bfsharp%5D)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/statically-resolved-type-parameters-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/statically-resolved-type-parameters-%5Bfsharp%5D)'
- en: F# can use the available types in .NET and the types specific to F#. F# has
    its own types because F# has supports for functional programming related types,
    including DU.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: F# 可以使用 .NET 中的可用类型和 F# 特有的类型。F# 有自己的类型，因为 F# 支持与函数式编程相关的类型，包括 DU。
- en: 'The documentation of types in F# is available from MSDN at the following URL:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中类型的文档可以在以下 URL 获取：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-types](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-types)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-types](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-types)'
- en: The basic summary and syntaxes of F# types are also available at the MSDN Library.
    We are now focusing on the type itself as the data structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: F# 类型的基本摘要和语法也可在 MSDN 图书馆中找到。我们现在专注于类型本身作为数据结构。
- en: 'These are the types in F#:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 F# 中的类型：
- en: '**Primitive types**: These are the same as .NET primitive types such as `Int32`,
    `Boolean`, `Single`, `Double`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始类型**：这些与 .NET 的原始类型相同，如 `Int32`、`Boolean`、`Single`、`Double`。'
- en: '**Unit type**: This is equal to `void` in C# and `Nothing` in Visual Basic'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元类型**：这等于 C# 中的 `void` 和 Visual Basic 中的 `Nothing`。'
- en: '**Options**: These are special types in F# that describe a type that may contain
    a value or empty.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：这些是 F# 中特殊的类型，用于描述可能包含值或空的类型。'
- en: '**Structures**: These are the same concept and semantics as `struct` in C#/VB.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构体**：这些与 C#/VB 中的 `struct` 概念和语义相同。'
- en: '**Classes**: These are the same concept as `class` in C#/VB.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：这些与 C#/VB 中的 `class` 概念相同。'
- en: '**Records**: These are unique in F#.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**：这些在 F# 中是独特的。'
- en: '**Discriminated unions**: These are unique in F#.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区分联合**：这是 F# 中独特的。'
- en: '**F# collections**: such as `Array`, `List`, and `Sequence.` All of F# collections
    are immutable by default, but the implementations of these collections are different
    in semantics from the BCL in .NET as used in C#/VB.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F#集合**：例如`Array`、`List`和`Sequence`。所有F#集合默认情况下都是不可变的，但与在C#/VB中使用的.NET BCL中的集合在语义上有所不同。'
- en: '**Functions**: These are specific to the F# function. The F# function is also
    implemented as `FSharpFunc` delegate.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：这些是F#特有的函数。F#函数也实现了`FSharpFunc`委托。'
- en: '**Delegates**: These delegates support include F#''s own delegates and .NET
    delegates. F# delegates have the same concept as delegate in .NET, but the semantic
    is implemented differently due to F# particular `FSharpFunc` implementation.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：这些委托支持F#自有的委托和.NET委托。F#委托与.NET中的委托概念相同，但由于F#特有的`FSharpFunc`实现，其语义实现不同。'
- en: '**Attributes**: These are the same as attributes in .NET BCL, therefore they
    are the same as attributes in C#/VB.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这些与.NET BCL中的属性相同，因此它们与C#/VB中的属性相同。'
- en: Throughout this chapter, we will focus on types that are specific to F#, such
    as options, structures (because of the difference in semantics), records, discriminated
    unions, F#'s specific collections, and functions. Class will be discussed as well
    because it's also a F# OOP feature but we are going to focus on the semantic differences
    and the way F# treats classes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于F#特有的类型，例如选项、结构（由于语义上的差异）、记录、区分联合、F#特定的集合和函数。也会讨论类，因为类也是F#的面向对象特性之一，但我们将会关注语义差异以及F#处理类的方式。
- en: Discriminated union (DU) is one of F#'s unique types and a feature that is also
    part of the functional programming language's commonly used types. It is also
    available in Haskell and Scala, among others.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合（DU）是F#的独特类型之一，也是函数式编程语言中常用类型的一部分。它还可在Haskell和Scala等语言中使用。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: DU is one of the unique feature of types in a functional programming language.
    In fact, DU is quite similar in Haskell's algebraic data types, although Haskell's
    algebraic data types are richer than F#'s DU. Scala uses combinations of traits
    and case classes and is more verbose. But the concept is the same in Scala.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DU是函数式编程语言类型中的独特特性之一。实际上，DU与Haskell的代数数据类型非常相似，尽管Haskell的代数数据类型比F#的DU更丰富。Scala使用特性和案例类的组合，并且更加冗长。但在Scala中概念是相同的。
- en: Overall runtime strategy of handling data types
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数据类型的整体运行时策略
- en: Before diving further into the optimization of types to store specific data
    structures, we need to know the basic understanding of how the F# types are implemented
    in the resulting (compiled) generated code. The compiler may handle different
    types differently, although there could be compiler-specific optimizations later
    on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步探讨优化特定数据结构存储类型之前，我们需要了解F#类型在生成的（编译后的）代码中的实现基本原理。编译器可能会以不同的方式处理不同的类型，尽管之后可能会有针对特定编译器的优化。
- en: Introduction to memory storage allocation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存存储分配简介
- en: 'The type of storage in memory to store the data value according to the CLI
    standard specification basically falls into these three storage categories (from
    fastest to slowest):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CLI标准规范存储数据值的内存存储类型基本上分为这三个存储类别（从最快到最慢）：
- en: Register
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器
- en: Stack
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Heap
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: Register
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器
- en: Register is the fastest to access, because it does not have memory allocation
    overheads compared to stack and heap. The concept of register is similar to the
    processor's register. This register is not the same as stack and heap; it is related
    to how the value is stored in the code. Usage of register in CLR is translated
    into any of the processor's registers, and depends on the platform used. For example,
    when running on x86/x64 processors, Intel's general purpose register of EAX, EBX,
    ECX, EDX will be used.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是最快的访问方式，因为它与栈和堆相比没有内存分配开销。寄存器的概念类似于处理器的寄存器。这个寄存器与栈和堆不同；它与值在代码中的存储方式有关。在CLR中寄存器的使用会被转换成处理器的任何一个寄存器，这取决于所使用的平台。例如，在x86/x64处理器上运行时，将使用Intel的通用寄存器EAX、EBX、ECX、EDX。
- en: Stack
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: 'The nature of stack is **LIFO**, abbreviated from **last in first out**. It
    means that data is stored not in a first come, first served basis, but the last
    one stored is the first one that can be read, as data is stored from the bottom
    to the highest layer of stacked fixed locations. This is why it is simply called
    stack. The analogy can be seen when we wash dishes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的本质是**LIFO**，即**后进先出**。这意味着数据不是按照先来先服务的顺序存储，而是最后存储的数据是第一个可以读取的，因为数据是从底部存储到栈的顶层固定位置。这就是为什么它简单地被称为栈。当我们洗碗时可以看到这种类比：
- en: The first dish is the first stack on the lowest stack.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一道菜是放在最低层的栈上的第一层。
- en: The second dish is put onto the first stack.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二道菜被放在了第一层栈上。
- en: The next one is put on the second stack, and this process is the same for the
    following dishes.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个则放在第二层，后续的菜品也是如此处理。
- en: To wash the dishes, we have to take the highest stack on the top of the stack
    first before we go to the first one. So the last stack is the first one to be
    washed because the last stack is located at the highest layer. This mechanism
    is the main reason why it is called LIFO.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要洗碗，我们必须先从栈顶的顶层开始洗，然后再洗第一层。所以最后一层是第一个被洗的，因为最后一层位于最高层。这种机制是它被称为LIFO的主要原因。
- en: In the world of computer science, the act of storing or putting the data onto
    a stack is called *push*, and the act of taking the data out from a stack is called
    *pop*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学的世界里，将数据存储或放入栈中的行为被称为*push*，而从栈中取出数据的行为被称为*pop*。
- en: The terms push and pop on stack are also the same concept in .NET CLR, and they
    are quite similar in semantics although the implementation detail is *virtualized*
    by the .NET CLR. The actual machine assembly code after AOT or JIT in the Debug
    mode is translated into the related processor's `PUSH` and `POP` instructions.
    In the context of .NET CLR on the x86 (32-bit) or x64 (64-bit) platform, these
    `PUSH` and `POP` instructions will be translated into a one or more calls to machine
    assembly of `PUSH` and `POP`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上的push和pop术语在.NET CLR中也是同样的概念，尽管实现细节被.NET CLR虚拟化了，它们的语义上相当相似。在AOT或JIT调试模式之后，实际的机器汇编代码会被翻译成相关处理器的`PUSH`和`POP`指令。在x86（32位）或x64（64位）平台上，这些`PUSH`和`POP`指令将被翻译成对机器汇编`PUSH`和`POP`的调用。
- en: The virtualization of data and the operations are important, as .NET CLR has
    its own isolations to help to prevent intentional manual memory allocation of
    pointers, subroutines, and data to be mixed. It is quite common for the virtualization
    to have its own mechanism of disposing unused objects (for example, out of scope
    when a method/function has finished executing) or an object that is explicitly
    disposed. Modern virtualization often has its own garbage collector for these
    unused/disposed objects. The isolations, garbage collections, and the sequence
    of garbage collections (Gen-0, Gen-1, Gen-2) are actually part of the .NET CLR
    memory management, and this is called *managed memory management*. This is the
    reason why the code running on top of CLR is called managed code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的虚拟化和操作非常重要，因为.NET CLR有其自身的隔离机制来帮助防止指针、子程序和数据被有意手动混合分配内存。虚拟化通常有其自己的机制来处理未使用的对象（例如，当方法/函数执行完毕时超出作用域）或显式释放的对象。现代虚拟化通常为其未使用/释放的对象拥有自己的垃圾回收器。隔离、垃圾回收以及垃圾回收的顺序（Gen-0、Gen-1、Gen-2）实际上是.NET
    CLR内存管理的一部分，这被称为*托管内存管理*。这就是为什么在CLR上运行的代码被称为托管代码。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of virtualization in CLR is quite similar to the concept of virtualization
    in *Java Virtual Machine* (JVM). The concept of having garbage collection is also
    part of the virtualized environment nature of CLR and JVM.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CLR中的虚拟化概念与*Java虚拟机*（JVM）中的虚拟化概念非常相似。拥有垃圾回收的概念也是CLR和JVM虚拟化环境特性的一部分。
- en: Details on the raw flow of machine assembly of `PUSH` and `POP` are out of the
    scope of this book, as we are not dealing with machine assembly instructions directly.
    For more information on assembly language, please consult Intel's landing page
    of the software developer manual on Intel processors at [http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `PUSH` 和 `POP` 的机器汇编原始流程的详细信息超出了本书的范围，因为我们没有直接处理机器汇编指令。有关汇编语言的更多信息，请参阅英特尔软件开发者手册在英特尔处理器的着陆页[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)。
- en: 'The following diagram illustrates storing or pushing data:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了存储或压入数据的过程：
- en: '![Stack](img/image00286.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![栈](img/image00286.jpeg)'
- en: Getting out or popping data from stack is done by accessing the last of the
    data pushed. The operation goes from top (the last pushed) to bottom.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从栈中取出或弹出数据是通过访问最后压入的数据来完成的。操作是从顶部（最后压入的）到底部。
- en: 'The advantages of using stack are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用栈的优点如下：
- en: Stacks are fast to store, the act of pushing data onto stack is just adding
    data consecutively. It does not require a pointer allocation.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈存储速度快，将数据压入栈的操作只是连续添加数据。它不需要指针分配。
- en: There is no fragmentation, because the order of filling stack is always contiguous.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于填充栈的顺序总是连续的，因此没有碎片。
- en: 'These are the disadvantages:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是缺点：
- en: Stacks take a predefined length of the number of data stored and cannot be allocated
    dynamically. This is intentional, as stack is allocated up front and it is also
    bound to the limits imposed by the processor and the size of memory (RAM).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈的长度是预先定义的，存储的数据数量，并且不能动态分配。这是故意的，因为栈是在一开始就分配的，并且它也受限于处理器和内存（RAM）的大小。
- en: Each stack has a predefined length for each slot of data. Therefore, stack is
    not ideally suited for variable lengths of data such as strings.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个栈为每个数据槽都有一个预定义的长度。因此，栈并不适合存储变长数据，如字符串。
- en: Stacks are often quickly exhausted as most stack size is limited and always
    less than the allocated heap. For example, stack is often used to store the initial
    pointer of recursive function calls, which is why every recursive call means pushing
    a pointer of the location of the initial call. After a function finishes its operations,
    it pops the last pointer to go to the caller. If the recursive calls are too deep,
    the stack is exhausted and this condition is often called *stack overflow*.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈通常很快就会被耗尽，因为大多数栈的大小是有限的，并且总是小于分配的堆。例如，栈通常用于存储递归函数调用的初始指针，这就是为什么每次递归调用都意味着将初始调用位置的指针压入栈中。当函数完成其操作后，它会弹出最后一个指针以返回调用者。如果递归调用太深，栈就会被耗尽，这种情况通常被称为“栈溢出”。
- en: 'The stack overflow is usually thrown as a `System.StackOverflowException`.
    Starting with .NET Framework 2.0, we can''t catch `StackOverflowException` directly
    as this is not allowed. The CLR/CIL 2.0 also implies this as well. For more information,
    please consult the `StackOverflowException` documentation at MSDN Library:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 栈溢出通常以 `System.StackOverflowException` 的形式抛出。从 .NET Framework 2.0 开始，我们无法直接捕获
    `StackOverflowException`，因为这不被允许。CLR/CIL 2.0 也暗示了这一点。有关更多信息，请参阅 MSDN 库中的 `StackOverflowException`
    文档：
- en: '[https://msdn.microsoft.com/en-us/library/system.stackoverflowexception(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.stackoverflowexception(v=vs.110).aspx)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.stackoverflowexception(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.stackoverflowexception(v=vs.110).aspx)'
- en: For the case of recursive function calls, F# has optimized most recursive function
    calls by translating them into a loop in the IL. This loop optimization guarantees
    that the function will not take lots of stack allocations and therefore prevents
    stack overflow caused by deeply nested recursive function calls.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归函数调用的情形，F# 通过将它们转换为 IL 中的循环来优化了大多数递归函数调用。这种循环优化保证了函数不会进行大量的栈分配，从而防止了由深度嵌套的递归函数调用引起的栈溢出。
- en: To allocate storage dynamically, the only way is to use heap.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态分配存储空间，唯一的方法是使用堆。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term heap is not to be confused with *heap as data structure*. Heap in a
    data structure is rarely used, as it's actually a specialized tree.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “堆”这个术语不要与“堆作为数据结构”混淆。在数据结构中，堆很少被使用，因为它实际上是一种特殊的树。
- en: Heap
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆
- en: Heap is simply a pool of large memory; usually it's in a form of virtual memory
    space. It can be allocated and deallocated dynamically on demand. The term allocate
    means the act of reserving a portion of memory. The term deallocate means freeing
    the resource (portion of memory) that was previously allocated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 堆只是一个大内存池；通常它以虚拟内存空间的形式存在。它可以根据需求动态地分配和释放。术语分配意味着保留内存的一部分。术语释放意味着释放之前已分配的资源（内存部分）。
- en: 'Heap is used to allocate memory for storing these kind of variables:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 堆用于为存储这类变量分配内存：
- en: Reference types
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: Unsafe methods
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的方法
- en: Weak reference methods
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱引用方法
- en: Reference unsafe pointers and managed pointers
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用不安全指针和管理指针
- en: Best practices of types for storing and accessing data
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和访问数据的类型最佳实践
- en: 'When discussing best practices of types to use to store data, we must consider
    these conditions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论存储数据的最佳类型实践时，我们必须考虑以下条件：
- en: The form of the value of the data. We can simply define this as the form of
    the data, or the semantics of the data value as the type of the value. The precision
    of the data is also part of the form of the data.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据值的形态。我们可以简单地将这定义为数据的形态，或者将数据值的语义视为值的类型。数据的精度也是数据形态的一部分。
- en: The use of the data is manipulated in the code. Is the data manipulated inside
    a function lambda or not as part of a function lambda? It is also important as
    this is implementation-specific in F# and .NET CLR.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的使用在代码中被操作。数据是在函数lambda内部操作，还是作为函数lambda的一部分进行操作？这在F#和.NET CLR中是特定实现的，因此也很重要。
- en: The nature of the lifetime of the data. This later will define where and how
    the data is stored in the memory, and we will discuss this in detail.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据生命周期的本质。这将在以后定义数据在内存中的存储位置和方式，我们将对此进行详细讨论。
- en: The final decision regarding implementation in the generated IL may vary as
    well. This is compiler-specific but it is still closely related to the first point
    about the form and the second point about the lifetime of the data.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于在生成的IL中实现最终决策可能也会有所不同。这是编译器特定的，但它仍然与第一个关于形态和第二个关于数据生命周期的观点密切相关。
- en: Let's discuss each of the previous points and the relations between them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论前述各点及其相互关系。
- en: The easiest one to understand is the form of the value of the data. To understand
    more about the form of the value, it is common to approach the form as the type
    of the value. For example, the numeric value, the `Boolean` value, and the `String`
    value. A type must be attached to each value, as this is a basic requirement of
    a static typed language such as F#.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易理解的是数据值的形态。要了解更多关于数据值形态的信息，通常会将形态视为值的类型。例如，数值类型、`Boolean`类型和`String`类型。每个值都必须附加一个类型，因为这是静态类型语言（如F#）的基本要求。
- en: CLR itself implies that all values *must* have defined types, because there
    are explicit type declarations in the IL which must be easily seen. The types
    are usually declared in the return type of the method, the method parameter signatures,
    and the `.locals` section in the IL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: CLR本身意味着所有值*必须*有定义的类型，因为在IL中有显式的类型声明，这些声明必须容易看到。类型通常在方法的返回类型、方法参数签名和IL中的`.locals`部分中声明。
- en: Let's look at some sample cases of these in the generated IL from F# compiler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看F#编译器生成的IL中这些类型的样本案例。
- en: 'For example, the `fact` function in the FSConsole01 in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement* has these type
    declarations for return type, parameter, and each variable used in the function
    body:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第2章](fsp-hiperf_cu02.html#aid-K0RQ2 "第2章。性能测量")的FSConsole01中的`fact`函数，*性能测量*有这些类型声明用于返回类型、参数以及函数体中使用的每个变量：
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The variables are given a local name as `v_0`, `a`, and `v_2` respectively.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 变量分别被赋予局部名称`v_0`、`a`和`v_2`。
- en: In this IL, the `.maxstack` directive defines how much the stack is allocated.
    The stack is allocated to use five slots of stack to store five values for this
    function to operate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此IL中，`.maxstack`指令定义了栈分配多少空间。栈被分配以使用五个栈槽来存储五个值，以便此函数操作。
- en: 'There are the stack operations beginning with `IL_0001` to `IL_0004` line segment:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从`IL_0001`到`IL_0004`行段有这些栈操作：
- en: '[PRE3]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The operations for those four lines of IL are:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些四行IL的操作是：
- en: The IL `ldarg.0` means load argument with index `0` (the first argument/parameter
    of the fact function) onto stack. This means pushing the value of the parameter
    onto stack.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IL `ldarg.0` 的意思是将索引 `0`（事实函数的第一个参数/参数）的参数加载到栈中。这意味着将参数的值压入栈中。
- en: The IL `stloc.0` means the pops value from stack to the local variable. The
    popped value is the value from the previous IL, the `ldarg.0` instruction.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IL `stloc.0` 的意思是将栈中的值弹出到局部变量中。弹出的值是上一个 IL 指令的值，即 `ldarg.0` 指令。
- en: The IL `ldloc.0` means load the local variable onto stack. This means pushing
    the value of the local variable to stack. The local variable is the index `0`,
    the first local variable declared in the `.locals` section.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IL `ldloc.0` 的意思是将局部变量加载到栈中。这意味着将局部变量的值压入栈中。局部变量是索引 `0`，在 `.locals` 部分中声明的第一个局部变量。
- en: The IL `ldc.i4.1` means push value `1` onto stack with the type as `Int32`.
    All of the IL of `ldc.x` means pushing a numerical constant with the desired type,
    whereas the `i4` means `Int32`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IL `ldc.i4.1` 的意思是将值 `1` 以 `Int32` 类型压入栈中。所有 `ldc.x` 的 IL 都意味着以期望的类型压入一个数值常量，而
    `i4` 则表示 `Int32`。
- en: For more information about these ILs, please consult partition III of ECMA-335
    about the CIL standard. The availability of `ldc.i4.1` IL also means that the
    value must have the type declared explicitly. This is further proof that .NET
    CLR implies static typed, even at the IL level.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些中间语言（ILs）的更多信息，请参考 ECMA-335 的第三部分，关于 CIL 标准的内容。`ldc.i4.1` IL 的可用性也意味着值必须显式声明类型。这进一步证明了
    .NET CLR 假定静态类型，即使在 IL 层级也是如此。
- en: 'There are two kinds of types that are used in F# from the perspective of programming
    language features: primitive types and non-primitive types.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程语言特性的角度来看，F# 使用两种类型的类型：原始类型和非原始类型。
- en: Primitive types are types that are available built-in as language features,
    and they are often types that are the easiest to construct (initialize) and manipulate.
    To maintain a higher compatibility with CLR and .NET BCL, the primitive types
    of F# support all of the primitive types in .NET BCL with the additional F# unique
    primitive type, `unit`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型是作为语言特性内置的类型，它们通常是构建（初始化）和操作最简单的类型。为了与 CLR 和 .NET BCL 保持更高的兼容性，F# 的原始类型支持
    .NET BCL 中的所有原始类型，以及额外的 F# 独有原始类型 `unit`。
- en: 'The priority order of feature support from the base to the top on F# is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: F# 从基础到顶端的特性支持优先级顺序是：
- en: .NET CLR (runtime) support
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET CLR（运行时）支持
- en: .NET BCL support (including `BigInteger`, as this is not explicitly supported
    in CLR)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET BCL 支持（包括 `BigInteger`，因为 CLR 中没有明确支持）
- en: F# unique types
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: F# 独有类型
- en: CLR type support must come first, as all of the primitive types must support
    CLR types first, especially all of the value types in CLR. This mandatory requirement
    is also part of official F# 4.0 Language Specification.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 类型支持必须首先考虑，因为所有原始类型都必须首先支持 CLR 类型，特别是 CLR 中的所有值类型。这个强制要求也是 F# 4.0 语言规范的一部分。
- en: For an official list of F# primitive types, visit the MSDN Library at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/primitive-types-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/primitive-types-%5bfsharp%5d).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 F# 原始类型的官方列表，请访问 MSDN 图书馆中的[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/primitive-types-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/primitive-types-%5bfsharp%5d)。
- en: Let's start by using the .NET original type name instead of using F# keyword,
    as it's also easier to understand based on the list of primitive types. For example,
    it's easier to use `Int32` as F# int because we might misunderstand *int* as `Int16`
    instead of `Int32`. This is quite common in programming languages, because of
    different implementations of how a language specification defines basic integer
    length. Fortunately, F# int is the same as C# `int` and VB Integer, as they both
    have the same length of 32 bits (4 bytes). But this symmetry might not be the
    same for C++ and other languages, although they may have support running on .NET
    CLR.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 .NET 原始类型名称而不是使用 F# 关键字开始，因为这根据原始类型的列表更容易理解。例如，使用 `Int32` 作为 F# 的 int
    更容易，因为我们可能会误解 *int* 为 `Int16` 而不是 `Int32`。这在编程语言中很常见，因为不同语言规范对基本整数长度的实现不同。幸运的是，F#
    的 int 与 C# 的 `int` 和 VB 的 Integer 相同，因为它们都具有相同的 32 位（4 字节）长度。但对称性可能对于 C++ 和其他语言并不相同，尽管它们可能支持在
    .NET CLR 上运行。
- en: If the value is a primitive type that has fixed length and it is also directly
    related to IL types such as `Char`, `SByte`, `Int16`, `Int32`, `Int64`, `Boolean`,
    `Single`, `Double`, or even an unsigned numeric such as `Byte`, `UInt32`, then
    the compiler will mostly store this on stack. `Char`, although it's not a numeric,
    is stored as a numeric.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值是具有固定长度且与IL类型直接相关的原始类型，例如`Char`、`SByte`、`Int16`、`Int32`、`Int64`、`Boolean`、`Single`、`Double`，甚至是无符号数值如`Byte`、`UInt32`，则编译器通常会将其存储在堆栈上。`Char`虽然不是数值类型，但作为数值存储。
- en: String does not have a fixed length, and it is also a composite type, because
    it is not a type that is standalone (it is not a type that contains other types).
    It is a type that contains other types as a collection. This is obvious because
    the declaration of `String` class in .NET BCL implements an object that implements
    `IEnumerable<Char>.` Therefore, string is composed as collection of `Char`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串没有固定长度，它也是一个复合类型，因为它不是一个独立的类型（它不是包含其他类型的类型）。它是一个包含其他类型作为集合的类型。这很明显，因为.NET
    BCL中`String`类的声明实现了一个实现`IEnumerable<Char>`的对象。因此，字符串由`Char`的集合组成。
- en: Because of the nature of a collection, the length may vary. It is also quite
    normal to assume that a string literal will always vary in length. Therefore,
    string is treated differently from other primitive types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合的性质，其长度可能会有所不同。假设字符串字面量始终会变化长度也是非常正常的。因此，字符串与其他原始类型被区别对待。
- en: 'To push a string constant value onto stack, the IL instruction is `ldstr`.
    To illustrate this, let''s revisit our `FSConsole01` project. It has as its entry
    point the `main` method. Let''s see the IL of `main`: (`IL_0006` and `IL_000b`
    are omitted):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串常量值推入堆栈，IL指令是`ldstr`。为了说明这一点，让我们回顾一下我们的`FSConsole01`项目。它的入口点是`main`方法。让我们看看`main`的IL代码：（省略了`IL_0006`和`IL_000b`）：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Hello F# world` string is treated as a string constant value, and it is
    pushed by `ldstr` at the beginning. At the end of `main`, before returning `0`
    as the successful running code, it removes the string value from stack using the
    `pop` IL.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello F# world`字符串被视为字符串常量值，并在开始时由`ldstr`推入。在`main`方法结束之前，在返回表示成功运行的代码`0`之前，它使用`pop`
    IL从堆栈中移除字符串值。'
- en: This shows that string has its representative in CIL as well. It is typed as
    `string`, mapped to `System.String` in .NET BCL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明字符串在CIL中也有其代表。它被类型化为`string`，映射到.NET BCL中的`System.String`。
- en: For more information, please see partition I section I.8.2.2 of the CIL standard
    (ECMA-335) to check all of the CIL types of .NET BCL primitive type mappings.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅CIL标准（ECMA-335）分区I第I.8.2.2节，以检查.NET BCL原始类型映射的所有CIL类型。
- en: Any primitive types, by default are stored in the memory using stack as its
    container storage. It is a bad practice to always assume that all of the uses
    of value typed will always be stored on stack, especially when the code that uses
    the data is implemented.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有原始类型都使用堆栈作为其容器存储在内存中。始终假设所有值类型的用法都存储在堆栈上是一种不好的做法，尤其是在使用数据的代码实现时。
- en: This is subjective to the internal implementation of F# compiler, but this technique
    is quite common in C#/VB compiler as well. F# has to conform to Common Language
    Specification rules as governed by the CIL standard, not just C#/VB. Therefore,
    it is intuitive by default in the normal code (without any closure that is common
    in lambda functions) that all of the primitive types of CIL will be stored onto
    stack.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于F#编译器的内部实现，但这种技术在C#/VB编译器中也很常见。F#必须遵守由CIL标准规定的通用语言规范规则，而不仅仅是C#/VB。因此，在正常代码中（没有在lambda函数中常见的闭包）默认情况下，所有CIL的原始类型都将存储到堆栈上。
- en: Any constant string value is always pushed on stack, as shown in the sample
    `main` method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 任何常量字符串值都始终推入堆栈，如示例`main`方法所示。
- en: Other than that, string can be stored in stack or heap, depending on the actual
    implementation of the code and the use of data manipulated in the code. Any variable
    used in the code can be implemented differently, according to the code. The storage
    location depends on the location of the closure as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，字符串可以根据代码的实际实现和数据在代码中的使用情况存储在堆栈或堆中。代码中使用的任何变量都可以根据代码的不同实现方式。存储位置还取决于闭包的位置。
- en: A *closure* is simply a technique to capture a variable that is scoped outside
    a lambda function. Closure is a very useful feature in many programming languages,
    although it is mostly used when we use lambda functions. The way closure works
    in F# is the same as in C#/VB.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包*是一种捕获作用域在lambda函数之外的变量的技术。闭包是许多编程语言中一个非常有用的特性，尽管它主要在我们使用lambda函数时使用。F#中闭包的工作方式与C#/VB相同。'
- en: 'F# can be used to treat the function scoped variable to be the reference type
    for the inner function, although the type of the variable is the struct/value
    type. This is also a rule of the restriction of the F#: variable used for the
    closure that is going to be mutated/changed; it must have a reference type on
    its value, whether the type of the variable is a struct or not.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: F#可以将函数作用域变量视为内函数的引用类型，尽管变量的类型是结构体/值类型。这也是F#限制的一个规则：将要被修改/改变的闭包变量；它必须在其值上具有引用类型，无论变量的类型是结构体还是不是。
- en: 'For example consider:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如考虑：
- en: '[PRE5]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line that declares the `count` variable uses the `ref` keyword to define
    that it is not just a passing value; it is also passing references as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`count`变量的那行代码使用了`ref`关键字来定义它不仅仅是一个传递值；它还传递引用。
- en: The use of immutable data captured as closure will be stored on stack, but this
    is actually an implementation detail of F# compiler.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为闭包捕获的不可变数据的存储将在栈上，但这实际上是F#编译器的实现细节。
- en: The point regarding the lifetime of the data concerns how long the data in a
    variable is used throughout the flow of the code. It is also related to closure
    implementation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据生命周期的观点涉及变量在代码流中使用的时间长度。这也与闭包实现有关。
- en: 'To fully recap and understand the relations of the form of the data and the
    lifetime of the data, these are the rules of treating the data based on the lifetime
    of the data used:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面回顾和理解数据形式与数据生命周期之间的关系，以下是基于数据使用生命周期的数据处理规则：
- en: If the data is used many times as a closure but it is immutable, this can be
    defined as having a short lifetime. The data is stored on stack.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据作为闭包被多次使用但它是不可变的，这可以定义为具有短生命周期。数据存储在栈上。
- en: The string constant value is always considered as short-lived data. Therefore,
    it is stored on stack and this is also the main implementation detail of the CIL/CLR
    `ldstr` instruction.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串常量值始终被视为短生命周期数据。因此，它存储在栈上，这也是CIL/CLR `ldstr`指令的主要实现细节。
- en: All of the mutable/immutable variables that are scoped locally in a function/method
    that are not used as a closure will always be stored on stack, because this function/method
    scoped variable is defined to be short-lived. It is only used within the scope
    of the function/method.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在函数/方法中局部作用域的可变/不可变变量，如果不作为闭包使用，将始终存储在栈上，因为这个函数/方法作用域变量被定义为短生命周期的。它仅在函数/方法的范围内使用。
- en: All the value type (struct) is by default stored on stack. There are some special
    cases that the value type will be stored on stack. When the value type is referenced
    within `System.WeakReference<T>`, the value will be stored on heap along with
    the `System.WeakReference<T>` container. Also the use of `ref` when assigning
    the function scoped variable will mostly put the value on heap.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有值类型（结构体）默认情况下都存储在栈上。有一些特殊情况，值类型将存储在栈上。当值类型在`System.WeakReference<T>`内部引用时，值将随`System.WeakReference<T>`容器一起存储在堆上。此外，在分配函数作用域变量时使用`ref`通常会将值放在堆上。
- en: If the data as closure is intended as a mutable reference type, it will be stored
    on heap.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将作为闭包的数据意图为可变引用类型，它将被存储在堆上。
- en: If the data is part of public properties of a class/record, the data is stored
    on the heap of the container class/record. For example, a `public` property member
    of a class is stored on heap.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据是类/记录的公共属性的一部分，数据将存储在容器类/记录的堆上。例如，类的`public`属性成员存储在堆上。
- en: Long-lived data is always stored on heap.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期数据总是存储在堆上。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`WeakReference` is useful because we can use it to enforce GC not to do garbage
    collection on the data upon which the type is parameterized. The data is contained
    in this `WeakReference`. Any other type of reference will always be garbage collected
    at any Gen-0 or Gen-1 phase.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakReference`很有用，因为我们可以用它来强制GC不要在类型参数化的数据上执行垃圾回收。数据包含在这个`WeakReference`中。任何其他类型的引用在Gen-0或Gen-1阶段都会被垃圾回收。'
- en: For more information about `WeakReference` usage, consult the MSDN Library at [https://msdn.microsoft.com/en-us/library/gg712738(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/gg712738(v=vs.110).aspx).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`WeakReference`使用的更多信息，请参阅MSDN库中的[https://msdn.microsoft.com/en-us/library/gg712738(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/gg712738(v=vs.110).aspx)。
- en: Based on the rules, it is recommended to use immutable closure instead of mutable,
    especially when it is marked to be a reference type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规则，建议使用不可变闭包而不是可变闭包，特别是当它被标记为引用类型时。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The most common best practice still holds: allocating stack is faster than
    allocating data on heap. It is quite obvious that the immutable closure is recommended
    and better than reference typed closure.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然是最常见的最佳实践：在堆栈上分配比在堆上分配数据更快。很明显，不可变闭包被推荐，并且比引用类型闭包更好。
- en: To simply recap, the choice is often choosing between struct and class (including
    record, DU) in F#. All of record, DU are implemented as classes in the IL, and
    therefore they are basically specialized types of classes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾，选择通常是在F#中选择结构体和类（包括记录、DU）之间。所有记录、DU在IL中实现为类，因此它们基本上是类的特殊类型。
- en: 'The strategy is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 策略如下：
- en: Always know the difference of value type and reference type. But never assume
    that the value type is always stored on stack.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是了解值类型和引用类型的区别。但永远不要假设值类型总是存储在栈上。
- en: Prefer value types instead of classes.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用值类型而不是类。
- en: Use object pool to contain the most used types and put them in a collection.
    This will prevent GC from always automatically performing garbage collection each
    time the variable is used. But this strategy is not recommended if the variable
    used is mostly short-lived and the intention is mostly for a quick calculation
    that is repeated in parallel.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象池来包含最常用的类型并将它们放入集合中。这将防止GC在每次变量使用时都自动执行垃圾收集。但如果使用的变量大多是短命的，且目的是进行快速计算，这些计算在并行中重复，则不建议使用此策略。
- en: Run garbage collection when the code is running idly after processing inputs
    or after ending all of the long running processes. This will increase the efficiency
    of garbage collection to minimize overheads instead of doing GC when the code
    is busy doing computations or even side-effect computations. Although the overhead
    of Gen-0, Gen-1 may impact the memory deallocation and allocation process, having
    garbage collection run on idle times will minimize overheads when the collection
    happens on heavy computations (especially when performing recursive operations
    in parallel).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理输入后代码空闲运行或结束所有长时间运行的过程后运行垃圾收集。这将提高垃圾收集的效率，以最小化开销，而不是在代码忙于计算或进行副作用计算时进行GC。尽管Gen-0、Gen-1的开销可能会影响内存的分配和释放过程，但在空闲时间运行垃圾收集将最小化在重计算（尤其是在并行执行递归操作时）发生时的开销。
- en: Use `WeakReference` for an object that has a tendency to be long lived but used
    frequently to decrease the GC overhead.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有长期存活但频繁使用的倾向的对象，请使用`WeakReference`以减少GC开销。
- en: Use an immutable value when capturing the value inside a function lambda. Immutable
    values when captured in lambda are always stored on stack.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数lambda中捕获值时，请使用不可变值。在lambda中捕获的不可变值始终存储在栈上。
- en: The distinction details of the value type and the reference type, and how they
    behave in memory, especially in the stages of garbage collection, are described
    in detail in the CIL/CLR ECMA-335 standard.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型的区分细节，以及它们在内存中的行为，特别是在垃圾收集阶段的行为，在CIL/CLR ECMA-335标准中有详细描述。
- en: 'Actually, these F# rules are also applied for C#/VB. Eric Lippert (former developer
    of the C# compiler) has discussed this in a detailed explanation on his MSDN blog:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些F#规则也适用于C#/VB。Eric Lippert（C#编译器的前开发者）在他的MSDN博客上对此进行了详细的解释：
- en: '[https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/](https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/](https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/)'
- en: Again, although this is mostly hidden from us as F# developers, these implementation
    details will help us to understand and avoid misconceptions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管这些实现细节对我们F#开发者来说大多隐藏，但这些细节将帮助我们理解和避免误解。
- en: The current discussion has different semantics depending on whether or not a
    collection of data is used in the implementation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现中是否使用数据集合时，当前讨论有不同的语义。
- en: Best practices in using F# collections
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用F#集合的最佳实践
- en: The F# types are mostly describing types that are not collection types. F# has
    its own unique collection types as well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: F#类型大多描述的是非集合类型。F#也有其独特的集合类型。
- en: 'The F# collection features are mostly implemented as modules, with the namespace
    of `Microsoft.FSharp.Collections`. The following are the F# collection modules:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: F#集合的功能大多以模块的形式实现，命名空间为`Microsoft.FSharp.Collections`。以下是一些F#集合模块：
- en: 'Module `Array`: Basic operations on arrays'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Array`：对数组的基操作
- en: 'Module `Array2D`: Basic operations on two-dimensional arrays'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Array2D`：对二维数组的基操作
- en: 'Module `Array3D`: Basic operations on rank 3 arrays'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Array3D`：对三维数组的基操作
- en: 'Module `Array4D`: Basic operations on rank 4 arrays'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Array4D`：对四维数组的基操作
- en: 'Module `ComparisonIdentity`: Common notions of comparison identity used with
    sorted data structures'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`ComparisonIdentity`：与排序数据结构一起使用的比较身份的常见概念
- en: 'Module `HashIdentity`: Common notions of value identity used with hash tables'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`HashIdentity`：与哈希表一起使用的值身份的常见概念
- en: 'Module `List`: Basic operations on lists'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`List`：对列表的基本操作
- en: 'Module `Map`: Functional programming operators related to the `Map` type'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Map`：与`Map`类型相关的函数式编程运算符
- en: 'Module `Seq`: Basic operations on enumerable collections'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Seq`：对可枚举集合的基本操作
- en: 'Module `Set`: Functional programming operators related to the `Set` type'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块`Set`：与`Set`类型相关的函数式编程运算符
- en: '`List`, `Map`, and `Set` are unique to F#.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`、`Map`和`Set`是F#独有的。'
- en: 'For more information about F# collections, please consult the MSDN Library
    at: [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-collection-types](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-collection-types).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如需有关F#集合的更多信息，请参阅MSDN库：[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-collection-types](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-collection-types)。
- en: The page shows the list of types and also the computation complexity or algorithmic
    speed (*big O notation*) of each function of the collection. It is recommended
    that you should pay close attention to the number of computation complexities
    of each function and use them carefully.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面显示了类型列表以及每个集合函数的计算复杂度或算法速度（*大O记号*）。建议您密切关注每个函数的计算复杂度，并谨慎使用。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Big O notation* is originally coming from the realm of basic computer science.
    It is almost non-trivial in the programming world. But it''s crucial to understanding
    the abstract performance in the terms of computation complexity, as it is always
    having has a direct relation on the overall performance. Simpler computation complexity
    such as *O(1)* or *O(log n)* is always better than *O(n)*.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*大O记号*最初来源于基础计算机科学领域。在编程世界中，它几乎是非平凡的。但是，它对于理解计算复杂度方面的抽象性能至关重要，因为它始终与整体性能有直接关系。简单的计算复杂度，如*O(1)*或*O(log
    n)*，总是比*O(n)*更好。'
- en: 'For example consider:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: 'The function `tryPick` in `Array`, `List`, and `Seq` is *O(n)* and in `Map`
    it is *O(log N)*. This means the `tryPick` in `Map` is faster when the number
    of elements are very large, such as more than `1000`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`、`List`和`Seq`中的`tryPick`函数是*O(n)*，而在`Map`中是*O(log N)*。这意味着当元素数量非常大时，例如超过`1000`，`Map`中的`tryPick`更快：'
- en: '[PRE6]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whereas *O(n)* for `1000` elements means:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 而*O(n)*对于`1000`个元素意味着：
- en: '[PRE7]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some concrete operations are often quite trivial to spot or to deduce quickly;
    for example, loops that run a definite n number of times are always at least *O(n)*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一些具体操作通常很容易发现或快速推断；例如，运行固定n次循环的循环总是至少*O(n)*。
- en: There's no simple way to reduce running times further, unless the loop is executed
    within a parallel flow of a parallel loop. Parallelism is actually also one way
    to have optimization as part of the concurrency support/features of F#. We will
    discuss concurrency further in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#* and [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2
    "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency Support
    in F#*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法可以进一步减少运行时间，除非循环在并行流的并行循环中执行。并行性实际上也是将优化作为F#并发支持/功能的一部分的一种方式。我们将在[第4章](fsp-hiperf_cu04.html#aid-11C3M2
    "第4章。F#并发简介")，*F#并发简介*和[第5章](fsp-hiperf_cu05.html#aid-164MG2 "第5章。F#高级并发支持")，*F#高级并发支持*中进一步讨论并发。
- en: For more information about big O, please refer to the MIT computer science course
    overview at [http://web.mit.edu/16.070/www/lecture/big_o.pdf](http://web.mit.edu/16.070/www/lecture/big_o.pdf).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大 O 的更多信息，请参阅麻省理工学院计算机科学课程概述[http://web.mit.edu/16.070/www/lecture/big_o.pdf](http://web.mit.edu/16.070/www/lecture/big_o.pdf)。
- en: The complexity scales value in terms of big O is better in `Map` than in `Array`,
    `List`, and `Seq`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在大 O 的复杂度方面，`Map` 比 `Array`、`List` 和 `Seq` 更好。
- en: The big O notation may break or may not be valid anymore when the code runs
    in parallel because there's no exact guarantee of the number of executions that
    actually happen when the code runs in parallel.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码并行运行时，大 O 符号可能会失效或不再有效，因为没有确切保证在并行运行时实际发生的执行次数。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting from this chapter, we will enrich our perspective on measuring performance
    by the quantitative and qualitative methods we learned in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement* combined with
    the necessary big O notation, to understand performance optimization in the perspective
    of computation complexity. The use of big O should come after having quantitative
    and qualitative measurements first, as big O often shows no real quantitative
    data when measuring concurrency in action.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将通过我们在 [第 2 章](fsp-hiperf_cu02.html#aid-K0RQ2 "第 2 章。性能测量") 中学习到的定量和定性方法来丰富我们对性能测量的视角，即结合必要的
    big O 符号，从计算复杂性的角度理解性能优化。在使用 big O 之前，应先进行定量和定性测量，因为 big O 在实际测量并发时通常不显示真实的数据。
- en: But the use of `Map` is not always the best option for all cases. `Map` behaves
    like the .NET `Dictionary`, as it stores elements that have pairs of keys and
    values in it. The semantics of `Map` are different from `Dictionary`, as will
    be explained later.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不是所有情况下使用 `Map` 都是最佳选择。`Map` 的行为类似于 .NET 的 `Dictionary`，因为它在其中存储具有键值对元素的元素。`Map`
    的语义与 `Dictionary` 不同，这将在后面进行解释。
- en: 'These are the conceptual mappings of the F# collection to .NET BCL:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 F# 集合到 .NET BCL 的概念映射：
- en: '| **F#** | **.NET BCL** | **Notes** |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **F#** | **.NET BCL** | **注意** |'
- en: '| `Seq` (sequence) | `IEnumerable<T>` | F# `Seq` is an alias of `IEnumerable<''T>`.
    Therefore it is also valid and safe to use `Seq` for all operations that leverage
    `IEnumerable` and `IEnumerable<''T>,` and they are eagerly evaluated by default.
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `Seq` (序列) | `IEnumerable<T>` | F# 的 `Seq` 是 `IEnumerable<''T>` 的别名。因此，对于所有利用
    `IEnumerable` 和 `IEnumerable<''T>` 的操作，使用 `Seq` 也是有效和安全的，并且默认情况下它们是急切求值的。|'
- en: '| `List` | `List<T>` | F# `List` is implemented as single linked list. To have
    only immutability parity, .NET BCL has `ReadOnlyCollection<T>` type that is equal
    to the immutability feature.F# `List` is also thread safe. The equivalent of `List<T>`
    that has a thread safe feature in .NET BCL is the `SynchronizedCollection<T>`
    in the System.Collections.Generic namespace, and this collection is not immutable.So
    currently there is no equivalent type of F# `List` in .NET 4/4.5.4.6.1 BCL that
    is both immutable and thread safe. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `List<T>` | F# 的 `List` 实现为单链表。为了只有不可变性，.NET BCL 有 `ReadOnlyCollection<T>`
    类型，它与不可变特性相同。F# 的 `List` 也是线程安全的。在 .NET BCL 中具有线程安全特性的 `List<T>` 的等效类型是 `System.Collections.Generic`
    命名空间中的 `SynchronizedCollection<T>`，而这个集合不是不可变的。因此，目前 .NET 4/4.5/4.6.1 BCL 中没有既是不可变又是线程安全的
    F# `List` 的等效类型。|'
- en: '| `Array` | Implicitly implemented as implementation of `IEnumerable<T>` but
    it is restricted to being a single variant, not a covariant. | F# `Array` is a
    single variant. Both the F# `Array` and .NET BCL `Array` have a fixed length.
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `Array` | 隐式实现为 `IEnumerable<T>` 的实现，但它被限制为单变体，不是协变的。 | F# 的 `Array` 是一个单变体。F#
    的 `Array` 和 .NET BCL 的 `Array` 都有固定长度。|'
- en: '| `Map` | `Dictionary<TKey,TValue>` | Both `Map` and `Dictionary<TKey,TValue>`
    implement the `IDictionary<TKey,TValue>` interface. Therefore, in the conceptual
    perspective, it is the same but not in the semantic perspective.F# `Map` is just
    immutable by default. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | `Dictionary<TKey,TValue>` | `Map` 和 `Dictionary<TKey,TValue>` 都实现了
    `IDictionary<TKey,TValue>` 接口。因此，从概念上看，它们是相同的，但在语义上则不同。F# 的 `Map` 默认是不可变的。|'
- en: '| `Set` | No equal type. | There''s no equal type of `Set` in .NET BCL. The
    `Set` is actually a container of items but the item in the elements of the set
    must be unique. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `Set` | 没有相等类型。 | .NET BCL 中没有 `Set` 的相等类型。实际上，`Set` 是一个项的容器，但集合中的元素必须是唯一的。|'
- en: For more information about the .NET BCL collection types, please consult the
    starting page of `System.Collections` at [https://msdn.microsoft.com/en-us/library/mt481475(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/mt481475(v=vs.110).aspx).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 .NET BCL 集合类型的更多信息，请参阅 `System.Collections` 的起始页面 [https://msdn.microsoft.com/en-us/library/mt481475(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/mt481475(v=vs.110).aspx)。
- en: 'The F# sequence can create an infinite collection by initializing `Seq` using
    the `seq.initInfinite` function. A sequence will always be evaluated lazily. The
    consequence of this is the efficiency: the operation is applied as necessary to
    regenerate the elements of the sequence.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: F# 序列可以通过使用 `seq.initInfinite` 函数初始化 `Seq` 来创建一个无限集合。序列始终是惰性求值的。这一点的结果是效率：操作仅在必要时应用以重新生成序列的元素。
- en: There is no compiler or runtime trick for this infinite sequence. The F# infinite
    sequence is also available for use in C#/VB.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个无限序列，没有编译器或运行时技巧。F# 的无限序列也可以在 C#/VB 中使用。
- en: Comparing F# List to .NET List<T>
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较 F# `List` 与 .NET `List<T>`
- en: The `List` is similar to .NET `List`, because they both have indexes and the
    same methods as well, although the semantics are different.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 与 .NET `List` 类似，因为它们都有索引和相同的方法，尽管语义不同。'
- en: The `List` is implemented as a single linked list, not as the `List<T>` in .NET
    BCL. This linked list implementation is faster than `List<T>`. The `List` can
    be stored recursively by easily using F# `head::tail` syntax.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 被实现为一个单链表，而不是 .NET BCL 中的 `List<T>`。这种链表实现比 `List<T>` 更快。`List` 可以通过简单地使用
    F# 的 `head::tail` 语法递归存储。'
- en: 'A single linked list means that each element of the list contains a portion
    of property that points to the next element of the list, as illustrated here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表意味着列表中的每个元素都包含指向列表下一个元素的属性的一部分，如图所示：
- en: '![Comparing F# List to .NET List<T>](img/image00287.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![比较 F# List 与 .NET List<T>](img/image00287.jpeg)'
- en: F# `List` is efficient and faster than `List<T>` in a sense that a single linked
    list always guarantees that any operations that access only the head of the list
    are *O(1)*, and element access is *O(n)*. It is ordered that each element can
    have a pointer to the next element.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，F# `List` 比 `List<T>` 效率和更快，因为单链表总是保证对只访问列表头部的任何操作都是 *O(1)*，而元素访问是 *O(n)*。每个元素都可以有一个指向下一个元素的指针。
- en: 'The apparent advantages of F# `List` over .NET `List<T>` are as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: F# `List` 相比于 .NET `List<T>` 的明显优势如下：
- en: F# `List` is immutable. It can be considered as a persistent data structure
    when combining with `List`.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与 `List` 结合使用时，F# `List` 是不可变的。它可以被视为持久数据结构。
- en: The nature of a linked list of the F# `List` means that it is efficient when
    combining lists using concatenation, as explained later.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# `List` 的链表性质意味着在通过连接操作合并列表时效率很高，这一点将在后面进行解释。
- en: It has efficient access to the recursive nature of `head::tail`, which can then
    be used in recursive functions. This is common in functional programming languages,
    as the recursive nature is deeply implemented not just on functions, but on data
    structures as well.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对 `head::tail` 的递归性质有高效的访问，这可以用于递归函数。这在函数式编程语言中很常见，因为递归性质不仅深入到函数中，也深入到数据结构中。
- en: 'For an example of a recursive `head::tail` in a recursive function, let''s
    look at the following sample code from F# MSDN of the F# `List` documentation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个递归 `head::tail` 在递归函数中的示例，让我们看看 F# MSDN 中 `List` 文档的以下样本代码：
- en: '[PRE8]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sum` function will call the `sum` function again with the parameter of
    the rest of the elements (`tail`) after the first element (`head`). The recursive
    nature of `head::tail` will continue automatically on the next recursive call
    as the next `head::tail` will contain the list of the resulting previous `head::tail`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum` 函数将在第一个元素（`head`）之后，使用剩余元素（`tail`）的参数再次调用 `sum` 函数。`head::tail` 的递归性质将在下一个递归调用中自动继续，因为下一个
    `head::tail` 将包含之前 `head::tail` 的结果列表。'
- en: The `head::tail` syntax in the previous code sample can be leveraged to recursively
    access the head and the rest of data on the tail. There is no comparable feature
    for this in C#/VB. If there is any, the implementation would be less efficient
    when `List<T>` is used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码示例中的 `head::tail` 语法可以用来递归地访问头部和尾部上的其余数据。在 C#/VB 中没有类似的功能。如果有，当使用 `List<T>`
    时，实现将效率较低。
- en: 'As linked lists, concatenating F# `List`s are also faster than concatenating
    a .NET `List<T>`. Concatenating between two or more `List` items is done in the
    following way:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 作为链表，F# `List` 的连接比连接 .NET `List<T>` 更快。两个或多个 `List` 项之间的连接按以下方式完成：
- en: Create a new `List` that has the total capacity of all `List` items.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `List`，其总容量为所有 `List` 项的总和。
- en: Copy the source `List` structurally (not referentially).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构化地复制源 `List`（不是引用地）。
- en: The tail link of the source is linked to the head of the destination list, and
    the rest of the destination lists are copied structurally.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源的尾链接被链接到目标列表的头部，其余的目标列表被结构化地复制。
- en: The process is repeated until all the participant lists have been copied and
    linked.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到所有参与者列表都已复制并链接。
- en: The operations do not (visibly) update the structure in place, but instead always
    yield a new updated structure.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些操作不会（明显地）就地更新结构，而是始终产生一个新的更新后的结构。
- en: F# has a convenient operator to concatenate `List`, using the `@` operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有一个方便的运算符用于连接 `List`，即 `@` 运算符。
- en: 'For example consider:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如考虑：
- en: '[PRE9]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `list3` will contain the concatenation of `list1` and `list2`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`list3` 将包含 `list1` 和 `list2` 的连接。'
- en: Comparing F# Map to Dictionary<TKey,TValue>
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较F# Map与Dictionary<TKey,TValue>
- en: F# `Map` is equal to .NET BCL `Dictionary<TKey,TValue>` conceptually because
    they both implement .NET `IDictionary<TKey,TValue>`. But F# `Map` is semantically
    different from `Dictionary<TKey,TValue>`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，F# `Map` 等于 .NET BCL `Dictionary<TKey,TValue>`，因为它们都实现了 .NET `IDictionary<TKey,TValue>`。但
    F# `Map` 在语义上与 `Dictionary<TKey,TValue>` 不同。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please do not confuse F# `Map` as type with F# `Map` as a module. F# `Map` as
    a module is called `Map`. From outside, it is called by referencing to the namespace
    of `FSharp.Collection.Map` module. The F# `Map` as a type is available from outside
    F#. The name is called `FSharpMap`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要混淆 F# `Map` 作为类型与 F# `Map` 作为模块。F# `Map` 作为模块被称为 `Map`。从外部，它通过引用 `FSharp.Collection.Map`
    模块的命名空间来调用。F# `Map` 作为类型在 F# 外部也是可用的。其名称为 `FSharpMap`。
- en: From the performance perspective, it is still faster because of its immutability
    behavior.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，由于其不可变性行为，它仍然更快。
- en: From the correctness perspective, F# `Map` is enforcing us to be more correct
    because of the constrained key and value of the generic type parameter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从正确性的角度来看，由于泛型类型参数的键和值被约束，F# `Map` 迫使我们更加正确。
- en: 'Let''s look at the type definition signature of F# `Map`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 F# `Map` 的类型定义签名：
- en: '[PRE10]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is actually translated into this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上翻译成这样：
- en: '`Map` has two generic type parameters: `Key` and `Value`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 有两个泛型类型参数：`Key` 和 `Value`'
- en: '`Key` is marked with `EqualityConditionalOnAttribute`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key` 被标记为 `EqualityConditionalOnAttribute`'
- en: '`Key` is constrained to be derived from the comparison'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key` 被约束为从比较派生'
- en: Value is marked with `EqualityConditionalOnAttribute` and `ComparisonConditionalOnAttribute`
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值被标记为 `EqualityConditionalOnAttribute` 和 `ComparisonConditionalOnAttribute`
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ComparisonConditionalOnAttribute` means that the generic parameter type
    satisfies the generic comparison constraint if and only if the type satisfies
    this constraint.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComparisonConditionalOnAttribute` 表示如果且仅当类型满足此约束时，泛型参数类型满足泛型比较约束。'
- en: The `EqualityConditionalOnAttribute` means the generic parameter type satisfies
    the F# equality constraint only if a generic argument also satisfies this constraint.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`EqualityConditionalOnAttribute` 表示只有当泛型参数类型满足 F# 相等性约束时，泛型参数也满足此约束。'
- en: '`Map` has the default constructor that accepts parameter of the comparer and
    the tree is the base collection for bespoke comparison.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 有一个接受比较器参数的默认构造函数，其树是专用比较的基础集合。'
- en: The comparer parameter is constrained implementing `IComparer`. Although F#
    has no support for covariance/contravariance, implementing `IComparer` for the
    comparer parameter means that it is also implicitly covariant. This is quite obvious
    because `IComparer` has the signature of `IComparer<in T>`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 比较参数被约束为实现 `IComparer`。尽管 F# 不支持协变/逆变，但实现 `IComparer` 对于比较参数意味着它也是隐式协变的。这非常明显，因为
    `IComparer` 的签名是 `IComparer<in T>`。
- en: 'These additional attributes might add a little overhead when doing comparisons
    and equality checks, but are necessary because of these correctness rules:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的属性在执行比较和相等性检查时可能会增加一点开销，但出于这些正确性规则的需要是必要的：
- en: The `Key` must be able to be checked for equality, because the key must be unique.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key` 必须能够检查相等性，因为键必须是唯一的。'
- en: The `Value` must be able to be checked for equality and comparison. This is
    also important, as the value must be able to be sorted later (having a sorting
    operation is optional).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`必须能够进行等性和比较检查。这也是很重要的，因为值必须在以后能够被排序（排序操作是可选的）。'
- en: 'The deciding considerations in choosing `Map` or `Dictionary` are:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Map`或`Dictionary`的决定性考虑因素是：
- en: If you just want to have a collection that has keys and values but needs immutability,
    use `Map`. The net effect of checking the equality of the values is not bigger
    than the usefulness of immutability.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只是想要一个具有键和值的集合，但需要不可变性，请使用`Map`。检查值相等性的净效果并不大于不可变性的有用性。
- en: If you just want to have a collection that has keys and values without worrying
    about the order of the values and need immutability, use `Map`.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只是想要一个具有键和值的集合，无需担心值的顺序，并且需要不可变性，请使用`Map`。
- en: If you just want to have an immutable implementation of `Dictionary` with sorted
    `Keys`, use `Map` with `Keys` that have been sorted by sorting the map's keys.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只是想要一个具有排序`键`的不可变`字典`实现，请使用`Map`，并通过排序映射的键来排序`键`。
- en: If you need a mutable `Dictionary`, use `Dictionary<TKey,TValue>` instead of
    `Map`. It is better to use `Dictionary<TKey,TValue>` directly for mutable purposes
    than marking a `Map` instance as *mutable*. Marking a `Map` instance value as
    mutable means we are using `Map` but treating it as mutable. This simple hack
    may break interoperability with other languages such as C#/VB, because `Map` is
    supposed to be kept as immutable but the integrity is broken as mutable. The intention
    of correctness is also broken.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一个可变的`字典`，请使用`Dictionary<TKey,TValue>`而不是`Map`。直接使用`Dictionary<TKey,TValue>`进行可变操作比将`Map`实例标记为`mutable`更好。将`Map`实例值标记为可变意味着我们正在使用`Map`，但将其视为可变。这种简单的技巧可能会破坏与其他语言（如C#/VB）的互操作性，因为`Map`本应保持不可变，但其完整性被破坏了。正确性的意图也被破坏了。
- en: If you want to have a mutable `Dictionary` sorted by keys, use `SortedDictionary`
    instead. It is thread safe, unless you inherit `SortedDictionary` and implement
    your own sorted `Dictionary` because there is no further guarantee that on your
    own custom sorted dictionary, the thread safety will not be violated or overridden.
    Furthermore, referential transparency is not guaranteed to be the same or not
    broken.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要一个按键排序的可变`字典`，请使用`SortedDictionary`。它是线程安全的，除非你继承`SortedDictionary`并实现自己的排序`字典`，因为无法保证在你的自定义排序字典中，线程安全性不会被违反或覆盖。此外，引用透明性也不能保证相同或不会破坏。
- en: By considering these scenarios, we should use F# `Map` as the main consideration.
    Marking `Map` as mutable to cheat on the mutability is not recommended. This applies
    also to the other collection types such as F#'s `List` and `Set`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑这些场景，我们应该将F#的`Map`作为主要考虑因素。将`Map`标记为可变以欺骗可变性是不推荐的。这也适用于其他集合类型，如F#的`List`和`Set`。
- en: Choosing a value evaluation strategy
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择值评估策略
- en: We know that F# collections have support for lazy evaluation, not just eager
    evaluation. Almost all of F# collections are lazy, except the operations that
    require modifications on the order of the elements. The collections in F# that
    do not have a lazy feature are F# `Array` and `Set`, as the semantics are similar
    to the .NET BCL array.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道F#集合支持延迟评估，而不仅仅是即时评估。几乎所有的F#集合都是延迟的，除了需要对元素顺序进行修改的操作。在F#中没有延迟功能的集合是F#的`Array`和`Set`，因为它们的语义与.NET
    BCL数组类似。
- en: 'Collection modules on F# are not all lazily evaluated. The same behavior is
    applied on these modules: `Array`, `List`, and `Sequence`. The F# developer team
    is working hard to end the feature disparity by making relevant functions to be
    available for all modules.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: F#的集合模块并不都是延迟评估的。这些模块也应用了相同的行为：`Array`、`List`和`Sequence`。F#的开发团队正在努力通过提供相关函数来结束功能差异。
- en: 'For a more complete list of F#''s progress on narrowing feature disparity (focusing
    on what''s new in F# releases) visit:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看F#在缩小功能差异（重点关注F#版本中的新功能）方面的更完整列表，请访问：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/whats-new-in-visual-fsharp](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/whats-new-in-visual-fsharp)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/whats-new-in-visual-fsharp](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/whats-new-in-visual-fsharp)'
- en: For example, `map` and `filter` do not require modification of the order of
    the elements; sort (`orderby` in LINQ) and `groupby` require modifications.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`map` 和 `filter` 不需要修改元素的顺序；排序（LINQ 中的 `orderby`）和 `groupby` 需要修改。
- en: The real reasons why we could deduce that all of the operations of the functions
    that modify or reorder the content of a collection make it lazy is almost impossible
    because of the way these operations work, especially when considering operations
    that relate to category theory and relational algebra, subjects borrowed from
    the realm of mathematics. All of the function implementation of map, filter, fold,
    and unfold are actually based on relational algebra.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些操作的工作方式，特别是考虑到与范畴论和关系代数相关的操作，以及从数学领域借用的主题，我们几乎无法推断出所有修改或重新排序集合内容的函数操作都是延迟的，这是几乎不可能的。所有
    map、filter、fold 和 unfold 的函数实现实际上都是基于关系代数的。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Category theory deals with how the function compositions work, especially when
    the chaining of functions has to be composable. Relational algebra deals with
    operations of map, reduce, filter, fold, and unfold on a collection of elements.
    Relational algebra and category theory are the foundations of how F# collection
    operations work, and they are quite commonly known in other functional programming
    languages as basic features.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论处理函数组合的工作方式，特别是当函数链必须可组合时。关系代数处理对元素集合执行映射、归约、过滤、折叠和展开等操作。关系代数和范畴论是 F# 集合操作的基础，在其他函数式编程语言中作为基本特性相当常见。
- en: The topics of category theory and relational algebra are beyond the scope of
    this book, although it is recommended to understand the basics of these mathematical
    disciplines.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论和关系代数的主题超出了本书的范围，尽管建议了解这些数学学科的基本知识。
- en: 'To learn more about relational algebra, please check one of this sample course
    from MIT:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于关系代数的信息，请查看麻省理工学院提供的以下课程样本之一：
- en: '[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-830-database-systems-fall-2010/](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-830-database-systems-fall-2010/)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[麻省理工学院开放课程](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-830-database-systems-fall-2010/)'
- en: Category theory is the foundation knowledge of functional constructs composition
    such as Monad and Monoid, and it is also the base theory behind lambda calculus
    and higher order functions. Lambda calculus and higher order functions are part
    of the common functional programming features.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是函数结构组合（如 Monad 和 Monoid）的基础知识，也是 lambda 演算和高阶函数的基础理论。Lambda 演算和高阶函数是函数式编程的常见特性。
- en: The terms lazy or eager evaluation are based on the evaluation strategies of
    the programming language.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: “延迟”或“主动”求值的术语基于编程语言的求值策略。
- en: Lazy evaluation means expressions are only evaluated once and then only if the
    evaluation is actually needed. It is also called on-demand evaluation or deferred
    execution (the operation is deferred to be executed later).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟求值意味着表达式只计算一次，并且仅在实际上需要计算时才计算。它也被称为按需计算或延迟执行（操作被延迟到稍后执行）。
- en: Eager evaluation means expressions are evaluated as soon as the computation
    expression is bound to a variable. F# by default is using eager evaluation for
    any variable assignment, unless the assignment has explicit lazy expressions.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 主动求值意味着表达式在计算表达式绑定到变量时立即计算。F# 默认情况下对任何变量赋值都使用主动求值，除非赋值具有显式的延迟表达式。
- en: As a consequence of having lazy evaluation, the type must be aligned and well
    defined before being lazily evaluated. Otherwise, type casting or invalid argument
    exceptions may occur. This is one of the main reasons why static typing is mandatory
    in functional programming languages such as F#.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于延迟求值的存在，类型必须在延迟求值之前对齐和明确定义。否则，可能会发生类型转换或无效参数异常。这是为什么在像 F# 这样的函数式编程语言中静态类型是强制性的主要原因之一。
- en: In F#, lazy evaluation can be applied on a type and can also be implemented
    as functions on collections such as `Seq` and `List`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，延迟求值可以应用于类型，也可以作为 `Seq` 和 `List` 等集合上的函数实现。
- en: On collection, the resulting collection from the operations that have lazy evaluation
    are executed when the collection is going to be read in iteration, including evaluating
    `head::tail`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合操作中，具有延迟求值的操作的结果集合将在迭代中读取集合时执行，包括评估 `head::tail`。
- en: When applied on a type, F# has a `lazy` keyword to denote lazy computation to
    enclose the operation to be lazy. The result is a variable that has an operation
    to be executed and evaluated later when the evaluation to read is needed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于类型时，F# 有一个 `lazy` 关键字来表示惰性计算，以封装要延迟执行的操作。结果是，一个变量具有要执行的操作，在需要读取评估时才会执行和评估。
- en: 'This is an example of lazy computation in action when used as standalone type
    (not a collection):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用独立类型（非集合）时惰性计算的实际示例。
- en: '[PRE11]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we put a debugger breakpoint on the second line, the result is not yet having
    a value and stepping over the line will not execute the `x + 10` operation. After
    stepping over line 3, the result will have a value. This will ensure on-demand
    execution or computation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第二行设置断点，结果尚未具有值，并且跨过该行不会执行 `x + 10` 操作。在跨过第 3 行之后，结果将具有值。这将确保按需执行或计算。
- en: By default, when operating on a type, F# will always do eager evaluation unless
    a lazy computation is applied. Using a lazy evaluation on all of operations or
    expressions will increase stack allocation overheads, and these overheads will
    exhaust stacks as well.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当操作类型时，F# 总是会进行急切评估，除非应用了惰性计算。对所有操作或表达式使用惰性评估会增加堆栈分配开销，并且这些开销会耗尽堆栈。
- en: It is recommended to only apply lazy computation on a type if the expression
    is reused at in many methods, because applying lazy means the operation within
    the lazy computation will only be executed once and then the result will be used
    many times.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式在许多方法中重复使用，则建议仅在类型上应用惰性计算，因为应用惰性意味着惰性计算内的操作只会执行一次，然后结果会被多次使用。
- en: 'For more information about lazy computation on types, visit the following MSDN
    documentation:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于类型上惰性计算的信息，请访问以下 MSDN 文档：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/lazy-computations-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/lazy-computations-%5Bfsharp%5D)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/lazy-computations-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/lazy-computations-%5Bfsharp%5D)'
- en: 'There is also a language construct that implements lazy evaluation implicitly
    as a state machine: using `yield` as an iterator efficiently on a F# `Sequence`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种语言结构，它隐式地将惰性求值作为状态机实现：在 F# 的 `Sequence` 上使用 `yield` 作为迭代器进行高效操作。
- en: 'For example consider:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 例如考虑：
- en: '[PRE12]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another sample that saves `yield` into a variable is:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将 `yield` 保存到变量的示例是：
- en: '[PRE13]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Internally, `yield` is implemented as a state machine, which lazily computes
    the operation if the sequence is read or iterated. The F# `yield` is similar to
    the C#/VB `yield` although the actual semantics are different. It is similar in
    terms of the state machine based on a common design pattern of iterator.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`yield` 被实现为一个状态机，当读取或迭代序列时会惰性计算操作。F# 的 `yield` 与 C#/VB 的 `yield` 类似，尽管实际的语义不同。它在基于迭代器常见设计模式的状态机方面相似。
- en: 'For more internal details of how an iterator works, check Microsoft''s developer
    blog entry written by Raymond Chen:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于迭代器如何工作的内部细节，请查看由 Raymond Chen 撰写的微软开发者博客条目：
- en: '[https://blogs.msdn.microsoft.com/oldnewthing/20080812-00/?p=21273](https://blogs.msdn.microsoft.com/oldnewthing/20080812-00/?p=21273)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/oldnewthing/20080812-00/?p=21273](https://blogs.msdn.microsoft.com/oldnewthing/20080812-00/?p=21273)'
- en: His blog has a series to describe iterators from an abstract as syntactic sugar
    to the raw implementation, although he describes the yield iterator from the perspective
    of the C# yield iterator specific implementation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 他的博客有一系列文章，从抽象的语法糖到原始实现，描述了迭代器，尽管他描述的是 C# `yield` 迭代器的特定实现。
- en: The use of yield in F# is actually a syntactic sugar that translates into a
    complex state machine as described in Raymond Chen's article. We should not worry
    about the implementation detail of this yield, because next releases of F# may
    change the implementation details of yield.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中使用 `yield` 实际上是一种语法糖，它转换成如 Raymond Chen 文章中描述的复杂状态机。我们不必担心这个 `yield` 的实现细节，因为
    F# 的后续版本可能会改变 `yield` 的实现细节。
- en: Note
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The yield and lazy are sample features of F# that hide the implementation details
    of the complex machinery of state machine. This will let us focus on what we are
    going to have as the result, instead of worrying about how we compute the result.
    This is often called a declarative instead of purely imperative. The declarative
    aspect of F# does not stop here; many concurrency constructs such as the async
    computation are declarative as well.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`和惰性是F#的样本特性，它们隐藏了复杂状态机机制的实现细节。这将使我们能够专注于我们想要的结果，而不是担心如何计算结果。这通常被称为声明式而不是纯粹命令式。F#的声明式方面并不止于此；许多并发构造，如异步计算，也是声明式的。'
- en: Most performance characteristics of lazy evaluation are better than eager evaluation,
    especially when the expression captured and evaluated lazily is used many times.
    The total net effect of using a lazy expression is noticeable, because of the
    execution on demand.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值的多数性能特征都优于急切求值，尤其是在捕获和惰性求值多次使用的表达式时。使用惰性表达式的总净效果是显著的，因为它是按需执行的。
- en: From the perspective of the F# unique approach as a functional programming language
    is not pure. F# is not doing all the aspects of language constructs lazily. For
    example, not all operations of `Seq` implement lazy evaluation. If we compare
    F# to other pure functional programming languages such as Haskell, Haskell has
    emphasized lazy evaluation on almost all cases, including comprehensive type resolutions,
    collection iterators, and even encapsulating side effects such as I/O lazily.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从F#作为函数式编程语言的独特方法的角度来看，它并不纯粹。F#并不是在语言构造的所有方面都采用惰性求值。例如，`Seq`操作不是所有操作都实现惰性求值。如果我们把F#与其他纯函数式编程语言（如Haskell）进行比较，Haskell几乎在所有情况下都强调了惰性求值，包括全面的类型解析、集合迭代器，甚至将副作用（如I/O）也以惰性方式封装。
- en: 'There are some disadvantages of having all expressions and functions to be
    lazy:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表达式和函数都采用惰性求值有一些缺点：
- en: Compile times will always slower than eager evaluation.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时间将始终慢于急切求值。
- en: If all operations are having lazy evaluation implemented, all of the complex
    state machines must be implemented for each case for all operations. This will
    result in a long compile time, including translating to state machines at the
    IL level.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有操作都实现了惰性求值，所有复杂的有限状态机都必须为每个操作案例实现。这将导致编译时间变长，包括在IL级别转换为状态机。
- en: There is no guarantee that having all expressions and functions as lazily evaluated
    will not exhaust stack.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有保证所有表达式和函数作为惰性求值不会耗尽栈空间。
- en: The detail of the possibility of scenarios for lazy evaluations is described
    in the next section.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值的场景可能性细节将在下一节中描述。
- en: Scenarios involving evaluation strategy and memory allocations
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涉及评估策略和内存分配的场景
- en: Lazy evaluation always consumes stack to allocate the metadata, the pointer
    to the expression. The expression evaluated may also be stored on stack if the
    expression is simple and no reference type (for example, usage of string or having
    a value captured in `WeakReference`) is used.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值总是消耗栈空间来分配元数据，即表达式的指针。如果表达式简单且没有引用类型（例如，使用字符串或在`WeakReference`中捕获值），则求值的表达式也可能存储在栈上。
- en: 'We must consider these scenarios:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑以下场景：
- en: Always use lazy evaluation whenever possible when doing operations on collections,
    especially when using a collection that only does forward-only features such as
    `Sequence` or `IEnumerable`, including `IEnumerable<T>` as well.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对集合进行操作时，尽可能总是使用惰性求值，尤其是在使用仅具有单向功能（如`Sequence`或`IEnumerable`）的集合时，包括`IEnumerable<T>`。
- en: For more complex recursive expressions or computation, lazy evaluation will
    consume stack rapidly, especially when combining complex lazy evaluation within
    recursive functions. Eager evaluation is preferred for this scenario, as the result
    of recursive functions always stored on stack as a stack frame with the last pointer
    of the previous same function call. If the lazy operation inside a recursive function
    is guaranteed to be simple and only calculating value types, then we can use lazy
    evaluation quite safely without consuming too much stack.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更复杂的递归表达式或计算，惰性求值会迅速消耗栈空间，尤其是在递归函数中结合复杂的惰性求值时。在这种情况下，更倾向于使用急切求值，因为递归函数的结果总是以栈帧的形式存储在栈上，作为前一个相同函数调用的最后一个指针。如果递归函数内部的惰性操作保证是简单的并且只计算值类型，那么我们可以相当安全地使用惰性求值，而不会消耗过多的栈空间。
- en: When the lazy operation involves a reference type, an overhead of going back
    and forth between allocating stack and heap will always occur and this will result
    in having poor performance in terms of memory consumptions and time consumed during
    roundtrips of memory allocation between stack and heap. GC overhead will always
    occur during this heavy round trip, because GC cannot be guaranteed to collect
    at the right time after a recursive call function is finished and returned to
    its previous recursive function call. At first, stack will always be garbage collected
    first but mixed stack and heap will make GC slower to collect as stack needs to
    detach any references to heap allocation before being popped and garbage collected.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当延迟操作涉及引用类型时，在堆栈和堆之间来回分配的开销总是会发生，这会导致在堆栈和堆之间内存分配往返时的内存消耗和时间消耗性能较差。在这次重头戏中，GC开销总是会发生，因为GC不能保证在递归调用函数完成后返回到其之前的递归函数调用时能够及时收集。起初，堆栈总是首先被垃圾回收，但混合的堆栈和堆会使GC收集速度变慢，因为堆栈在被弹出和垃圾回收之前需要断开对堆分配的任何引用。
- en: If our function is used in parallel, any atomic expression inside the function
    should be implemented lazily, as this is more efficient especially when the function
    will be running many times. Unless the function is implemented as a recursive
    function that has lazy operations in parallel it is also consuming stack quite
    rapidly, as described in the second scenario.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的函数在并行中使用，函数内的任何原子表达式都应该实现为延迟的，因为这更有效，尤其是在函数将多次运行时。除非函数实现为具有并行延迟操作的递归函数，否则它也会迅速消耗堆栈，正如第二场景中描述的那样。
- en: Avoid side effects whenever possible. If the lazy evaluation or yield expression
    contains side effects such as I/O, an exception may occur and this is expensive
    in terms of stack trace and stack frame allocation overhead. CPU bound calculation
    is a side effect but this kind of side effect can be ignored, as long as it is
    combined with other concurrency techniques such as parallelism.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何时候都应尽可能避免副作用。如果延迟评估或yield表达式包含副作用，如I/O，可能会发生异常，这在堆栈跟踪和堆栈帧分配开销方面是昂贵的。CPU密集型计算是一种副作用，但这种副作用可以忽略，只要它与其他并发技术（如并行性）结合使用。
- en: It is recommended to avoid lazy evaluation on UI threads. F# and CIL/CLR do
    not allow cross-threads.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议避免在UI线程上进行延迟评估。F#和CIL/CLR不允许跨线程。
- en: Having implementation of async computation workflow inside of a function that
    has lazy evaluation is fine, but we should avoid mixing lazy evaluation with side
    effects based on the fifth point, as usually async may deal with async I/O operations.
    Therefore, the use of eager evaluation when dealing with side effects within async
    computation is recommended. This scenario is one of the subtle scenarios that
    is often not observed well or is badly ignored.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有延迟评估的函数中实现异步计算工作流程是可以的，但我们应该避免根据第五点将延迟评估与副作用混合，因为通常异步可能会处理异步I/O操作。因此，在处理异步计算中的副作用时推荐使用即时评估。这种情况是那些常常观察不到或被忽视的微妙场景之一。
- en: Always pay attention to side effects that may occur, even any subtle side effects
    such as having calls to Windows API invocation. Not just exception needs to be
    handled, but there are some dangers of thread blockings or even deadlock when
    side effect computation is in effect.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是注意可能出现的副作用，即使是像调用Windows API这样的细微副作用。不仅异常需要处理，而且在副作用计算有效时，还可能存在线程阻塞或甚至死锁的危险。
- en: Lazy evaluation inside a computation workflow or quotation has to be treated
    carefully. There is a possibility that lazy evaluation might decrease performance
    of certain computation workflows such as async, as async itself is a complex state
    machine.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算工作流程或引用中的延迟评估必须谨慎处理。存在延迟评估可能会降低某些计算工作流程（如异步）性能的可能性，因为异步本身就是一个复杂的有限状态机。
- en: Any cancellation being handled during async computation that has lazy evaluation
    is fine, because a cancellation handles a side effect computation of the context
    switching of an asynchronous operation in a graceful manner as recommended by
    common pattern in .NET TPL.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有延迟评估的异步计算中处理任何取消操作都是可以的，因为取消操作以.NET TPL中常见模式推荐的方式优雅地处理异步操作上下文切换的副作用计算。
- en: Do not perform synchronized lock within a lazy computation, as the execution
    context may behave unexpected side effects. A chance of deadlock may occur if
    the lazy computation contains a lock that locks a complex object. Lock is also
    not recommended within normal running F# code.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在惰性计算中执行同步锁，因为执行上下文可能会产生意外的副作用。如果惰性计算包含锁定复杂对象的锁，可能会发生死锁。在正常的 F# 代码运行中也不建议使用锁。
- en: These scenarios may not cover all of the cases of choosing evaluation strategy,
    but they are quite common in implementing functions that combine lazy and eager
    evaluations. Therefore, lazy evaluation is not a single bullet for all kinds of
    performance optimizations in the value evaluation strategy.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景可能并不涵盖选择评估策略的所有情况，但在实现结合惰性和急切评估的函数时相当常见。因此，惰性评估并不是在值评估策略中针对所有类型的性能优化的万能解决方案。
- en: More detailed scenarios that may cause unexpected behavior or unexpected results
    when dealing with concurrency, are discussed in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#.*
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](fsp-hiperf_cu04.html#aid-11C3M2 "第 4 章。F# 并发简介")，*F# 并发简介*中，讨论了更多可能导致处理并发时出现意外行为或结果的具体场景。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Data structures are not just a crucial feature of any programming language,
    they play very important part in our codes, regardless whatever programming language
    we use. Understanding data structures in .NET are also the foundation of any programming
    language that runs on .NET CLR, including F# data structures.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构不仅是任何编程语言的关键特性，它们在我们的代码中扮演着非常重要的角色，无论我们使用的是哪种编程语言。理解 .NET 中的数据结构也是运行在 .NET
    CLR 上的任何编程语言的基础，包括 F# 数据结构。
- en: We now not just have enough understanding of F# data structures, but we can
    leverage F# data structures by applying and combining with best practices. The
    best practices that we have covered in this chapter are not just best practices
    of using the existing F# data structures, but we also have best practices of optimizing
    the data structures.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不仅对 F# 数据结构有了足够的理解，而且可以通过应用和结合最佳实践来利用 F# 数据结构。本章中我们讨论的最佳实践不仅包括使用现有 F# 数据结构的最佳实践，还包括优化数据结构的最佳实践。
- en: This data structure optimization understanding can be brought into deeper understanding
    of concurrency in F# in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to concurrency in F#*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据结构优化理解可以应用于对 F# 并发的更深入理解，在 [第 4 章](fsp-hiperf_cu04.html#aid-11C3M2 "第 4
    章。F# 并发简介")，*F# 并发简介*中。
