- en: Playing and Manipulating Sounds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放并操作声音
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Playing different one-off sound effects with a single AudioSource
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个**AudioSource**播放不同的单次声音效果
- en: Playing and controlling different sounds each with their own AudioSource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放并控制各自带有自己的**AudioSource**的不同声音
- en: Creating just-in-time AudioSource components at runtime through C# scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过C#脚本在运行时创建即时**AudioSource**组件
- en: Delaying before playing a sound
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在播放声音前延迟
- en: Preventing an Audio Clip from restarting if it is already playing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止正在播放的音频剪辑重新开始
- en: Waiting for audio to finish playing before auto-destructing an object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象自动销毁前等待音频播放完成
- en: Creating a metronome through the precise scheduling of sounds with dspTime
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过dspTime的精确调度创建节拍器
- en: Matching the audio pitch to the animation speed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将音频音调与动画速度匹配
- en: Simulating acoustic environments with Reverb Zones
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混响区域模拟声学环境
- en: Adding volume control with Audio Mixers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用音频混音器添加音量控制
- en: Making a dynamic soundtrack with Snapshots
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快照制作动态配乐
- en: Balancing in-game audio with Ducking
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ducking 平衡游戏中的音频
- en: Audio visualization from sample spectral data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从样本频谱数据中进行音频可视化
- en: Synchronizing simultaneous and sequential music to create a simple 140 bpm music-loop
    manager
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步同时和顺序音乐以创建简单的140 bpm音乐循环管理器
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Sound is a very important part of the gaming experience. In fact, it can't be
    stressed enough how crucial it is to the player's immersion in a virtual environment.
    Just think of the engine running in your favorite racing game, the distant urban
    buzz in a simulator game, or the creeping noises in horror games. Think of how
    these sounds transport you into the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是游戏体验的重要组成部分。实际上，无法过分强调它对玩家沉浸于虚拟环境中的重要性。想想你最喜欢的赛车游戏中引擎的轰鸣声，模拟游戏中的遥远城市嘈杂声，或者恐怖游戏中的缓慢声音。想想这些声音如何将你带入游戏。
- en: The big picture
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体概念
- en: 'Before getting on with the recipes, let''s first review how the different sound
    features work in Unity. A project with audio needs one or more audio files, which
    are called **AudioClips** in Unity, and these sit in your **Project** folders.
    At the time of writing, Unity 2017 supports four audio file formats: `.wav`, `.ogg`,
    `.mp3`, and `.aif`. Files in these types are re-encoded when Unity builds for
    a target platform. It also supports tracker modules in four formats: .xm, **.mod**,
    **.****it**, and **.s3m**.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续介绍食谱之前，让我们首先回顾一下Unity中不同的声音功能是如何工作的。需要音频的项目需要一个或多个音频文件，在Unity中称为**AudioClips**，这些文件位于你的**项目**文件夹中。在撰写本文时，Unity
    2017支持四种音频文件格式：`.wav`、`.ogg`、`.mp3`和`.aif`。这些类型的文件在Unity为目标平台构建时会被重新编码。它还支持四种格式的跟踪模块：.xm、**.mod**、**.****it**和**.s3m**。
- en: A scene or prefab GameObject can have an **AudioSource** component – which can
    be linked to an **AudioClip** sound file at Design-Time, or through scripting
    at Run-Time. At any time in a scene, there is one active **AudioListener** component
    inside a GameObject. When you create a new scene, there is one added automatically
    for you in the *Main Camera*. One can think of an **AudioListener** as a simulated
    digital '"ear," since the sounds Unity plays are based on the relationship between
    playing **AudioSources** and the active **AudioListener**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个场景或预制GameObject可以拥有一个**AudioSource**组件——该组件可以在设计时链接到一个**AudioClip**声音文件，或者在运行时通过脚本进行链接。在任何场景中，都有一个GameObject内的活动**AudioListener**组件。当你创建一个新的场景时，其中一个自动添加到*Main
    Camera*中。可以将**AudioListener**想象成一个模拟的数字“耳朵”，因为Unity播放的声音是基于播放的**AudioSources**和活动**AudioListener**之间的关系。
- en: Simple sounds, such as pickup effects and background soundtrack music, can be
    defined as as **2D sound**. However, Unity supports **3D sounds**, which means
    that the location and distance between playing **AudioSources** and the active
    **AudioListener** determine the way the sound is perceived in terms of loudness
    and the left/right balance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的声音，如拾取效果和背景配乐音乐，可以定义为**2D声音**。然而，Unity支持**3D声音**，这意味着播放的**AudioSources**和活动**AudioListener**之间的位置和距离决定了声音在响度和左右平衡方面的感知方式。
- en: You can also engineer synchronized sound playing and scheduling through `AudioSettings.dspTime` –
    a value based on the samples in the audio system, so it is much more precise than
    the `Time.time` value. Also, `dspTime` will pause/suspend with the scene, so no
    logic is required for rescheduling when using `dspTime`. Several recipes in this
    chapter illustrate this approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过`AudioSettings.dspTime`来设计同步声音播放和调度——这是一个基于音频系统样本的值，因此它比`Time.time`值要精确得多。此外，`dspTime`将与场景一起暂停/挂起，因此在使用`dspTime`时无需重新安排逻辑。本章中的一些食谱展示了这种方法。
- en: 'In recent years, Unity has added a powerful new feature to game audio: the
    **AudioMixer**. The **AudioMixer** radically changes the way in which sound elements
    can be experienced by players and worked with by game developers. It allows us
    to mix and arrange audio pretty much in the same way that musicians and producers
    do in their **Digital Audio Workstations** (**D.A.W.**), such as **GarageBand**
    or **ProTools**. It allows you to route **AudioSource** clips into specific channels
    that can have their volumes individually adjusted and processed by customized
    effects and filters. You can work with multiple **AudioMixers**, send a mixer''s
    output to a parent mixer, and save mix preferences as **Snapshots**. Also, you
    can access mixer parameters from scripting. The following figure represents the
    main Unity audio mixing concepts and their relationships:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Unity为游戏音频添加了一个强大的新功能：**AudioMixer**。**AudioMixer**彻底改变了玩家体验声音元素以及游戏开发者与之交互的方式。它允许我们以与音乐家和制作人他们在数字音频工作站（**D.A.W.**）中（如**GarageBand**或**ProTools**）相同的方式混音和排列音频。它允许您将**AudioSource**剪辑路由到特定通道，这些通道可以单独调整音量并经过定制效果和滤波器处理。您可以使用多个**AudioMixers**，将混音器的输出发送到父混音器，并将混音偏好保存为**快照**。您还可以从脚本中访问混音器参数。以下图表示了Unity音频混音的主要概念及其关系：
- en: '![](img/aeb76899-3541-4772-bfae-f4fe02750351.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aeb76899-3541-4772-bfae-f4fe02750351.png)'
- en: 'The figure above represents the main Unity audio mixing concepts and their
    relationships:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表示了Unity音频混音的主要概念及其关系：
- en: Taking advantage of the new AudioMixer feature in many example projects, this
    chapter is filled with recipes that will hopefully help you implement a better
    and more efficient sound design for your projects, augmenting the player's sense
    of immersion, transporting them into the game environment, and even improving
    the gameplay.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 利用许多示例项目中新的AudioMixer功能，本章充满了希望帮助您为项目实现更好、更高效的声音设计的食谱，增强玩家的沉浸感，将他们带入游戏环境，甚至改善游戏玩法。
- en: Future audio features
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来音频功能
- en: The recipes demonstrate both scripted and Unity audio system approaches to managing
    audio and introducing dynamic effects at runtime. Games can become much more engaging
    when the audio environment of effects and music can subtly change based on the
    context of what is happening in the game – whether you chose effects such as reverb
    zones, ducking to de-emphasize some sounds for a while, or allow the user to control
    the audio volumes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些食谱展示了在运行时管理音频和引入动态效果的脚本和Unity音频系统方法。当效果和音乐的音频环境可以根据游戏中的上下文微妙地改变时，游戏可以变得更加引人入胜——无论您选择的效果是混响区域、降低某些声音的音量以暂时降低其重要性，还是允许用户控制音频音量。
- en: 'Finally, what is possible with special audio is now getting even more interesting,
    with the introduction of Ambisonic Audio when playing 3D VR games – allowing rich
    audio experiences based on whether sounds are above or below the listener, as
    well as their distance from an audio source. Some reference sources for ambisonic
    audio include:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着3D VR游戏播放时引入环绕声音频，特殊音频的可行性现在变得更加有趣——根据声音是在听者上方还是下方，以及它们与音频源的距离，提供丰富的音频体验。环绕声音频的一些参考资源包括：
- en: Wikipedia offers some history of ambisonics: [https://en.wikipedia.org/wiki/Ambisonics](https://en.wikipedia.org/wiki/Ambisonics).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科提供了一些关于环绕声的历史：[https://en.wikipedia.org/wiki/Ambisonics](https://en.wikipedia.org/wiki/Ambisonics)。
- en: Learn about Unity and ambisonic audio in the Unity docs:[ https://docs.unity3d.com/Manual/AmbisonicAudio.html](https://docs.unity3d.com/Manual/AmbisonicAudio.html).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity文档中了解Unity和环绕声音频：[ https://docs.unity3d.com/Manual/AmbisonicAudio.html](https://docs.unity3d.com/Manual/AmbisonicAudio.html)。
- en: Google's reference pages about special audio and ambisonics: [https://developers.google.com/vr/concepts/spatial-audio](https://developers.google.com/vr/concepts/spatial-audio).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google关于特殊音频和环绕声的参考页面：[https://developers.google.com/vr/concepts/spatial-audio](https://developers.google.com/vr/concepts/spatial-audio)。
- en: Occulus reference pages about special audio and ambisonics: [https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/](https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于特殊音频和环绕声的Occulus参考页面：[https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/](https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/)。
- en: Robert Hernadez has published a great article at Medium.com disambiguating how
    to record and edit ambisonic audio: [https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca](https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robert Hernadez在Medium.com上发表了一篇很好的文章，解释了如何记录和编辑环绕声音频：[https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca](https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca)。
- en: Playing different one-off sound effects with a single AudioSource component
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单个**AudioSource**组件播放不同的单次音效
- en: The basics of playing a sound are very straightforward in Unity (adding an **AudioSource**
    component to a GameObject and linking it to an **AudioClip** sound file). For
    simple sound effects such as short, one-off plays of pickup confirmation noises,
    it's useful to have a single **AudioSource** component and reuse it to play different
    sound effects – which is what we'll do in this recipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中播放声音的基本操作非常简单（将**AudioSource**组件添加到GameObject并链接到**AudioClip**音效文件）。对于简单的音效，如短暂的拾取确认声音，有一个单一的**AudioSource**组件并重复使用它来播放不同的音效非常有用——这正是本食谱中我们将要做的。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Try this with any short audio clip that is less than one second in duration.
    We have included some classic Pacman game sound clips inside the `04_01` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用任何时长小于一秒的短音频片段。我们在`04_01`文件夹中包含了几个经典的《吃豆人》游戏音效剪辑。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To play multiple sounds using the same **AudioSource** component, do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用相同的**AudioSource**组件播放多个声音，请执行以下操作：
- en: Create a new Unity 2D project and import the sound clip files.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目并导入音效剪辑文件。
- en: 'Create a C# script class, `PlaySound`s, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the **Main
    Camera**:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹`_Scripts`中创建一个名为`PlaySound`s的C#脚本类，并添加以下代码，然后将其实例作为脚本组件添加到**主相机**：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that the **MainCamera** GameObject is selected in the **Hierarchy**.
    Then, in the **Inspector** panel, drag the Pacman Eating Cherry sound clip from
    the **Project** panel into the public Pacman Eating Cherry **AudioClip** variable in
    the `PlaySounds (Script)` scripted component. Repeat this procedure for the Pacman
    Extra Life sound clip. These steps are illustrated in the screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择**主相机**GameObject。然后，在**检查器**面板中，将**项目**面板中的Pacman Eating Cherry音效剪辑拖动到`PlaySounds
    (Script)`脚本组件中的公共Pacman Eating Cherry **AudioClip**变量中。为Pacman Extra Life音效剪辑重复此步骤。这些步骤在截图中有说明：
- en: '![](img/288ddefa-548e-4662-b08d-2adeb64b8360.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/288ddefa-548e-4662-b08d-2adeb64b8360.png)'
- en: Run the scene, and press the *UP* and *DOWN* arrow keys to play the different
    sound effects.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景，并按*上*和*下*箭头键播放不同的音效。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created a C# script class, `PlaySounds`. The script class includes
    a `RequireComponent` attribute declaring that any GameObject containing a scripted
    object component of this class must have a sibling AudioSource component (and
    one will be automatically added if such a component does not exist when the scripted
    component is added).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了一个C#脚本类`PlaySounds`。该脚本类包含一个`RequireComponent`属性，声明任何包含此类脚本对象组件的GameObject必须有一个兄弟`AudioSource`组件（如果脚本组件添加时不存在此类组件，则会自动添加一个）。
- en: 'The `PlaySounds` script class has two public **AudioClip** properties: `Pacman
    Eating Cherry` and `Pacman Extra Life`. At **Design-Time**, we associated **AudioClip**
    sound files from the **Project** panel with these public properties.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaySounds`脚本类有两个公共`AudioClip`属性：`Pacman Eating Cherry`和`Pacman Extra Life`。在**设计时**，我们将**项目**面板中的`AudioClip`音效文件与这些公共属性关联。'
- en: At runtime, the `Update()` method is executed in every frame. This method checks
    for the *UP* and *DOWN* array keys being pressed, and if so, plays the Eat Cherry
    or Extra Life sounds correspondingly – sending the **AudioSource** component a
    `PlayOneShot()` message with the appropriate **AudioClip** sound file link.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`Update()`方法在每一帧都会执行。此方法检查*上*和*下*数组键是否被按下，如果是，则相应地播放吃樱桃或额外生命的声音——向**AudioSource**组件发送一个带有适当`AudioClip`音效文件链接的`PlayOneShot()`消息。
- en: 'NOTE: Cannot pause/interrogate sounds played with **PlayOneShot**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用**PlayOneShot**播放的声音无法暂停/查询
- en: While great for short, one-off sound effects, a limitation of the `PlayOneShot()`
    method is that you cannot then interrogate the status of the playing sound (has
    it finished, at what point is it playing, and so on). Nor can you pause/restart
    a sound played with `PlayOneShot()`. For such detailed control of sounds, each
    sound needs its own AudioSource component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`PlayOneShot()`方法非常适合短时、单次音效，但其局限性在于无法查询播放中的声音状态（是否已结束，播放到什么位置等）。也无法暂停/重新播放使用`PlayOneShot()`播放的声音。对于这种详细的声音控制，每个声音都需要自己的AudioSource组件。
- en: Learn more about the `PlayOneShot()` method in the Unity documentation: [https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html](https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity文档中了解更多关于`PlayOneShot()`方法的信息：[https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html](https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html)。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Play a sound at a static point in 3D world space
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D世界空间中的静态点播放声音
- en: 'Similar to `PlayOneShot()` is the `PlayClipAtPoint()` **AudioSource** method.
    This allows you to play a sound clip for an **AudioSource** created at a specific
    point in 3D World Space. Note that this is a static class method – so that you
    don''t need an **AudioSource** component to use this method – an **AudioSource**
    component is created (at the location you give), and will exist as long as the
    **AudioClip** sound is playing. The **AudioSource** component will automatically
    be removed by Unity once the sound has finished playing. All you need is a `Vector3`
    (x,y,z) position object, and a reference to the **AudioClip** file to be played:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与`PlayOneShot()`类似的是`PlayClipAtPoint()` **AudioSource**方法。这允许你在3D世界空间中的特定点播放声音剪辑。请注意，这是一个静态类方法
    - 因此你不需要**AudioSource**组件来使用此方法 - **AudioSource**组件将在你给出的位置创建，并且只要**AudioClip**声音在播放，它就会存在。Unity将在声音播放完毕后自动删除**AudioSource**组件。你所需要的只是一个`Vector3`（x,y,z）位置对象，以及要播放的**AudioClip**文件的引用：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Playing and controlling different sounds each with their own AudioSource component
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放和控制具有各自AudioSource组件的不同声音
- en: While the approach in the previous recipe (using `PlayOneShot(...)` with a single
    **AudioSource**) is fine for one-off sound effects, when further control may be
    required over a playing sound, each sound will needs to be played in its own **AudioSource**
    component. In this recipe, we'll create two separate **AudioSource** components
    and pause/resume each with different arrow keys.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在先前的配方（使用单个**AudioSource**的`PlayOneShot(...)`）中对于单次音效来说是个不错的选择，但当需要进一步控制播放中的声音时，每个声音都需要在它自己的**AudioSource**组件中播放。在这个配方中，我们将创建两个独立的**AudioSource**组件，并使用不同的箭头键暂停/恢复每个。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Try this with two audio clips that are several seconds long. We have included
    two free music clips inside folder `04_02`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用两个几秒钟长的音频剪辑。我们在文件夹`04_02`中包含了两个免费的音乐剪辑。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To play different sounds each with their own AudioSouce component, do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放不同的声音，每个声音都有自己的AudioSource组件，请执行以下操作：
- en: Create a new Unity 2D project and import the sound clip files.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目并导入音频剪辑文件。
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the 186772__dafawe__medieval **AudioClip**. This can be done in a single step
    by dragging the music clip from the **Project** panel into either the **Hierarchy**
    or **Scene** panels. Rename this new GameObject to music1_medieval.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个包含**AudioSource**组件的GameObject，该组件链接到186772__dafawe__medieval **AudioClip**。这可以通过将音乐剪辑从**Project**面板拖动到**Hierarchy**或**Scene**面板来完成。将这个新GameObject重命名为music1_medieval。
- en: Repeat the previous step to create another GameObject named music2_arcade, containing
    an **AudioSource** linked to 251461__joshuaempyre__arcade-music-loop.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤创建另一个名为music2_arcade的GameObject，其中包含一个**AudioSource**组件，链接到251461__joshuaempyre__arcade-music-loop。
- en: For both AudioSources created, uncheck the Play Awake property – so these sounds
    do not begin playing as soon as the scene is loaded.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于创建的两个AudioSources，取消选中Play Awake属性 - 因此这些声音不会在场景加载时立即播放。
- en: Create an empty GameObject named Manager.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Manager的空GameObject。
- en: 'Create a C# script class, MusicManager, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the Manager
    GameObject:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`_Scripts`的新文件夹中创建一个C#脚本类，名为MusicManager，包含以下代码，并将其实例作为脚本组件添加到Manager GameObject中：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ensure that the **Manager** GameObject is selected in the **Hierarchy**. In
    the **Inspector** panel, drag the music1_medieval **GameObject** from the Scene
    panel into the public **Audio Source Medieval** AudioSource variable in the `MusicManager
    (Script)` scripted component. Repeat this procedure, dragging GameObject music2_arcade
    into the public Audio Source Arcade variable.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选中了**Manager**游戏对象。在**检查器**面板中，将场景面板中的music1_medieval **游戏对象**拖动到`MusicManager
    (脚本)`脚本组件中的公共`Audio Source Medieval` AudioSource变量中。重复此步骤，将GameObject music2_arcade拖动到公共`Audio
    Source Arcade`变量中。
- en: Run the scene, and press the *UP* and *DOWN* arrow keys to start/resume and
    pause the medieval sound clip. Press the *RIGHT* and *LEFT* arrow keys to start/resume
    and pause the arcade sound clip.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景，并按*上*和*下*箭头键以开始/恢复和暂停中世纪声音片段。按*右*和*左*箭头键以开始/恢复和暂停街机声音片段。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a C# script class, `MusicManager`, and added an instance of this
    class as a component to the Manager GameObject. You also created two **GameObjects**,
    named music1_medieval and music2_arcade, in the scene, each containing an **AudioSource**
    component linked to a different music clip.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个C#脚本类，`MusicManager`，并将此类的实例作为组件添加到Manager游戏对象中。您还在场景中创建了两个**游戏对象**，分别命名为music1_medieval和music2_arcade，每个都包含一个与不同音乐片段链接的**AudioSource**组件。
- en: 'The script class has two public **AudioSource** properties: `Music Medieval`
    and `Music Arcade`. At **Design-Time**, we associated the **AudioSource** components
    of **GameObjects** music1_medieval and music2_arcade with these public properties.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类有两个公共**AudioSource**属性：`Music Medieval`和`Music Arcade`。在**设计时**，我们将**游戏对象**music1_medieval和music2_arcade的**AudioSource**组件与这些公共属性关联。
- en: At Run-Time, the `Update()` method is executed in every frame. This method checks
    for the *UP/DOWN/RIGHT/LEFT* array keys being pressed. If the *UP* arrow key is
    detected, the medieval music audio source is sent a `Play()` or `UnPause()` message.
    The `Play()` message is sent if the clip is not already playing (its time property
    is zero). If the DOWN arrow key is pressed, the medieval music audio source is
    sent a `Pause()` message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**运行时**，`Update()`方法在每一帧执行。此方法检查*上/下/右/左*数组键是否被按下。如果检测到*上*箭头键，则向中世纪音乐音频源发送`Play()`或`UnPause()`消息。如果片段尚未播放（其时间属性为零），则发送`Play()`消息。如果按下*下*箭头键，则向中世纪音乐音频源发送`Pause()`消息。
- en: The arcade music clip is controlled in a corresponding way through detection
    of the RIGHT/LEFT array keys.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检测RIGHT/LEFT数组键来以相应的方式控制街机音乐片段。
- en: Each **AudioClip** sound file being associated with its own **AudioSource**
    component allows simultaneous playing, and managing of each sound independently.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个与自己的**AudioSource**组件关联的**AudioClip**声音文件允许同时播放和管理每个声音。
- en: Creating just-in-time AudioSource components at runtime through C# scripting
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过C#脚本在运行时创建即时AudioSource组件
- en: In the previous recipe, for each sound clip we wanted to manage, in the scene
    we had to manually create **GameObjects** with **AudioSource** components at Design-Time.
    However, using C# scripting, we can create our own **GameObjects** that contain **AudioSources**
    at **Run-Time**, just when they are needed. This method is similar to the built-in
    **AudioSource PlayClipAtPoint()** method, but the created **AudioSource** component
    is completely under our programmatic control – although we then have to be responsible
    for destroying this component when it is no longer needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，对于每个我们想要管理的声音片段，在场景中我们必须在**设计时**手动创建带有**AudioSource**组件的**游戏对象**。然而，使用C#脚本，我们可以在**运行时**创建自己的包含**AudioSources**的**游戏对象**，正好在它们需要的时候。这种方法类似于内置的**AudioSource
    PlayClipAtPoint()**方法，但创建的**AudioSource**组件完全受我们的程序控制——尽管我们随后必须负责在不再需要时销毁此组件。
- en: This code was inspired by some of the code posted in 2011 in the online **Unity
    Answers** forum by user Bunny83\. Unity has a great online community helping each
    other and posting interesting ways of adding features to games. Learn more about
    that post at [http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html](http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码受到了2011年在在线**Unity Answers**论坛中由用户Bunny83发布的部分代码的启发。Unity有一个伟大的在线社区，互相帮助并分享添加游戏功能的有意思的方法。了解更多关于这篇帖子，请访问[http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html](http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html)。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱是对上一个菜谱的改进。因此，请复制用于上一个菜谱的项目，并在这个副本上工作。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create just-in-time AudioSource components at run time through C# scripting
    do the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 C# 脚本在运行时创建即时 AudioSource 组件，请执行以下操作：
- en: Delete the music1_medieval and music-loop GameObjects from the scene – we'll
    be creating these at **Run-Time** in this recipe!
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除 music1_medieval 和 music-loop GameObjects – 在这个菜谱中，我们将在 **运行时** 创建这些对象！
- en: 'Refactor the `MusicManager` C# script class to read as follows (note that the
    `Update()` method is unchanged):'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MusicManager` C# 脚本类重构如下（注意，`Update()` 方法未更改）：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ensure that the `MainCamera` **GameObject** is selected in the **Hierarchy**.
    In the Inspector panel, drag the **AudioClip** 186772__dafawe__medieval sound
    clip from the Project panel into the public Clip Medieval **AudioClip** variable
    in the `MusicManager (Script)` scripted component. Repeat this procedure with
    **AudioClip** 251461__joshuaempyre__arcade-music-loop for the Clip Arcade variable.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **Hierarchy** 中选择了 `MainCamera` **GameObject**。在 **Inspector** 面板中，将项目面板中的
    **AudioClip** 186772__dafawe__medieval 声音剪辑拖放到 `MusicManager (Script)` 脚本组件中的公共
    `Clip Medieval` **AudioClip** 变量中。使用 **AudioClip** 251461__joshuaempyre__arcade-music-loop
    对 `Clip Arcade` 变量重复此过程。
- en: Run the scene, and press the *UP* and *DOWN* arrow keys to start/resume and
    pause the medieval sound clip. Press the *RIGHT* and *LEFT* arrow keys to start/resume
    and pause the arcade sound clip.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景，并按 *UP* 和 *DOWN* 箭头键以开始/恢复和暂停中世纪声音剪辑。按 *RIGHT* 和 *LEFT* 箭头键以开始/恢复和暂停街机声音剪辑。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key feature of this recipe is the new `CreateAudioSource(...)` method.
    This method takes input as a reference to a sound clip file and a Boolean true/false
    value as to whether the sound should start playing immediately. The method does
    the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的关键特性是新的 `CreateAudioSource(...)` 方法。该方法接受一个声音剪辑文件的引用和一个布尔值（true/false），表示声音是否应该立即开始播放。该方法执行以下操作：
- en: Creates a new **GameObject** (with the same parent, and at the same location
    as the **GameObject** doing the creating)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 **GameObject**（与创建它的 GameObject 具有相同的父级和位置）
- en: Adds a new **AudioSource** component to the new **GameObject**
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的 **GameObject** 中添加一个新的 **AudioSource** 组件
- en: Sets the audio clip of the new AudioSource component to the provided AudioClip
    parameter
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新 AudioSource 组件的音频剪辑设置为提供的 AudioClip 参数
- en: If the Boolean parameter was true, the **AudioSource** component is immediately
    sent a `Play()` message to start it playing the sound clip
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果布尔参数为 true，则立即向 **AudioSource** 组件发送 `Play()` 消息以开始播放声音剪辑
- en: A reference to the AudioSource component is returned
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 AudioSource 组件的引用
- en: The rest of the `MusicManager` script class is very similar to that in the previous
    recipe. There are two public `AudioClip` variables, `clipMedieval` and `clipArcade`,
    which are set through drag-and-drop at **Design-Time** to link to the sound clip
    files in **Sounds Project** folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`MusicManager` 脚本类的其余部分与上一个菜谱中的非常相似。有两个公共 `AudioClip` 变量，`clipMedieval` 和 `clipArcade`，它们在
    **设计时** 通过拖放设置，以链接到 **Sounds Project** 文件夹中的声音剪辑文件。'
- en: The `audioSourceMedieval` and `audioSourceArcade AudioSource` variables are
    now private. These values are set up in the `Awake(`) method, by calling and storing
    values returned by the `CreateAudioSource(...)` method with the **clipMedieval**
    and `clipArcade` AudioClip variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`audioSourceMedieval` 和 `audioSourceArcade AudioSource` 变量现在是私有的。这些值在 `Awake(`)
    方法中设置，通过调用并存储由 `CreateAudioSource(...)` 方法返回的值，使用 **clipMedieval** 和 `clipArcade`
    AudioClip 变量。'
- en: To illustrate how the Boolean parameter works, the medieval music **AudioSource**
    is created to play immediately, while the arcade music won't start playing until
    the *UP* arrow key is pressed. Playing/Resuming/Pausing the two audio clips is
    just the same as in the previous recipe – via the arrow-key detection logic in
    the (unchanged) `Update()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明布尔参数的工作方式，中世纪音乐的 **AudioSource** 被创建为立即播放，而街机音乐将在按下 *UP* 键后才开始播放。播放/恢复/暂停两个音频剪辑与上一个菜谱中的相同
    – 通过在（未更改的）`Update()` 方法中的箭头键检测逻辑。
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Adding the CreateAudioSource(...) method as an extension to the MonoBehavior
    class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 CreateAudioSource(...) 方法作为对 MonoBehavior 类的扩展
- en: Since the `CreateAudioSource(...)` method is a general-purpose method that could
    be used by many different game script classes, it doesn't naturally sit within
    the `MusicManager` class. The best place for general-purpose generative methods
    such as this is to add them as static (class) methods to the component class they
    work with – in this case it would be great if we could add this method to `MonoBehavior` class
    itself – so any scripted component could create **AudioSource** GameObjects on
    the fly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CreateAudioSource(...)`方法是一个通用方法，可以被许多不同的游戏脚本类使用，它自然不会位于`MusicManager`类中。此类通用生成方法的最佳位置是将它们作为静态（类）方法添加到它们工作的组件类中 –
    在这种情况下，如果能将此方法添加到`MonoBehavior`类本身中那就太好了 – 这样任何脚本组件都可以在运行时创建**AudioSource** GameObject。
- en: 'All we have to do is create a class (usually named `ExtensionMethods`) with
    a static method, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是创建一个类（通常命名为`ExtensionMethods`），其中包含一个静态方法，如下所示：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we can see, we add an extra first parameter to the extension method, stating
    which class we are adding this method to. Since we have added this to the `MonoBehavior`
    class, we can now use this method in our scripted classes as if it were built-in.
    So our `Awake()` method in our `MusicManager` class looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在扩展方法中添加了一个额外的第一个参数，指定我们要将此方法添加到哪个类。由于我们已经将其添加到`MonoBehavior`类中，因此现在我们可以在我们的脚本类中使用此方法，就像它是内置的。因此，我们的`MusicManager`类中的`Awake()`方法如下所示：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it – we can now remove the method from our `MusicManager` class and use
    this method in any of our `MonoBehavior` scripted classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样 – 我们现在可以从`MusicManager`类中删除该方法，并在任何我们的`MonoBehavior`脚本类中使用此方法。
- en: Delaying before playing a sound
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在播放声音之前延迟
- en: Sometimes we don't want to play a sound immediately, but after a short delay.
    For example, we might want to wait a second or two before playing a sound to indicate
    the slightly delayed onset of a poison drunk or having walked into a spell that
    weakens the player. For such cases, **AudioSource** offers the `PlayDelayed(...)`
    method. This recipe illustrates a simple approach for such cases where we do not
    wish to immediately start playing a sound.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不想立即播放声音，而是在短暂的延迟后播放。例如，我们可能想要等待一秒钟或两秒钟再播放声音，以表示毒药的效果稍微延迟或玩家进入了一个削弱玩家的法术。对于此类情况，**AudioSource**提供了`PlayDelayed(...)`方法。这个配方说明了对于我们不希望立即开始播放声音的情况的一个简单方法。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Try this with two audio clips that are several seconds long. We have included
    two free music clips inside the `04_04` folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用两个几秒钟长的音频剪辑。我们在`04_04`文件夹中包含了两个免费的音频剪辑。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To schedule a sound to play after a given delay, do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要安排在给定延迟后播放声音，请执行以下操作：
- en: Create a new Unity 2D project and import the sound clip files.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目并导入音频剪辑文件。
- en: Create a **GameObject** in the scene containing an **AudioSource** component
    linked to the **Pacman Opening Song** **AudioClip**. This can be done in a single
    step by dragging the music clip from the Project panel into either the **Hierarchy**
    or **Scene** panels.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个包含**AudioSource**组件的**GameObject**，该组件连接到**Pacman 开场曲**的**AudioClip**。这可以通过一次操作完成，即从项目面板拖动音乐剪辑到**Hierarchy**或**Scene**面板中。
- en: Repeat the previous step to create another **GameObject**, containing an **AudioSource**
    linked to the Pacman Dies clip.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤创建另一个**GameObject**，其中包含一个连接到**Pacman 死亡**剪辑的**AudioSource**。
- en: For both **AudioSources** created, uncheck the Play Awake property – so these
    sounds do not begin playing as soon as the scene is loaded.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于创建的两个**AudioSources**，取消选中“Play Awake”属性 – 因此这些声音不会在场景加载时立即播放。
- en: Create a **UI Button** named **Button-music** on the screen, changing its text
    to Play Music Immediately.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上创建一个名为**Button-music**的**UI Button**，将其文本更改为“立即播放音乐”。
- en: Create a **UI Button** named **Button-dies** on the screen, changing its text
    to Play Dies Sound After 1 second.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上创建一个名为**Button-dies**的**UI Button**，将其文本更改为“1秒后播放死亡声音”。
- en: Create an empty **GameObject** named SoundManager.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为SoundManager的空**GameObject**。
- en: 'Create a C# script class, DelayedSoundManager, in a new folder, `_Scripts`,
    containing the following code, and add an instance as a scripted component to
    the SoundManager **GameObject**:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹`_Scripts`中创建一个名为`DelayedSoundManager`的C#脚本类，包含以下代码，并将其作为脚本组件添加到SoundManager
    **GameObject**：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the Button-music **GameObject** selected in the Hierarchy panel, create
    a new on-click event-handler, dragging the SoundsManager **GameObject** into the
    Object slot, and selecting the ACTION_PlayMusicNow() method.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中选择 Button-music **GameObject**，创建一个新的点击事件处理程序，将 SoundsManager **GameObject**
    拖入对象槽，并选择 ACTION_PlayMusicNow() 方法。
- en: With the Button-dies GameObject selected in the Hierarchy panel, create a new
    on-click event-handler, dragging the SoundsManager GameObject into the Object
    slot, and selecting the ACTION_PlayDiesSoundAfterDelay() method.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中选择 Button-dies GameObject，创建一个新的点击事件处理程序，将 SoundsManager GameObject
    拖入对象槽，并选择 ACTION_PlayDiesSoundAfterDelay() 方法。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You add two **GameObjects** to the scene, containing `AudioSources` linked to
    music and dying sound clips. You created a C# script class, `DelayedSoundManager`,
    and added an instance to an empty **GameObject**. You associated the two AudioSources
    in your **GameObjects** with the two public variables in your scripted component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您向场景中添加了两个 **GameObjects**，包含连接到音乐和死亡音效剪辑的 `AudioSources`。您创建了一个 C# 脚本类，`DelayedSoundManager`，并将其实例添加到一个空
    **GameObject** 中。您将您的脚本组件中的两个公共变量与您的 **GameObjects** 中的两个 `AudioSources` 关联起来。
- en: 'You created two buttons:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了两个按钮：
- en: Button-music, with a click action to invoke the `DelayedSoundManager.ACTION_PlayMusicNow()`
    method
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮音乐，点击动作用于调用 `DelayedSoundManager.ACTION_PlayMusicNow()` 方法
- en: Button-dies, with a click action to invoke the `DelayedSoundManager.PlayDiesSoundAfterDelay()`
    method.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮失效，点击动作用于调用 `DelayedSoundManager.PlayDiesSoundAfterDelay()` 方法。
- en: The `DelayedSoundManager.ACTION_PlayMusicNow()` method immediately sends a Play()
    message to the audio source linked to the **Pacman Opening Song AudioClip**. However,
    the `DelayedSoundManager.PlayDiesSoundAfterDelay()` method sends a PlayDelayed(...)
    message to the audio source linked to the **Pacman Dies AudioClip**, passing a
    value of 1.0, making Unity wait 1 second before playing the sound clip.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayedSoundManager.ACTION_PlayMusicNow()` 方法立即向连接到 **Pacman 开场曲 AudioClip**
    的音频源发送 Play() 消息。然而，`DelayedSoundManager.PlayDiesSoundAfterDelay()` 方法向连接到 **Pacman
    死亡 AudioClip** 的音频源发送 PlayDelayed(...) 消息，传递值为 1.0，使 Unity 等待 1 秒后再播放音频片段。'
- en: Preventing an Audio Clip from restarting if it is already playing
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止音频片段在播放时重新启动
- en: In a game, there may be several different events that cause a particular sound
    effect to start playing. If the sound is already playing, then in almost all cases,
    we won't wish to restart the sound. This recipe includes a test, so that an Audio
    Source component is only sent a `Play()` message if it is currently not playing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，可能有多个不同的事件会导致特定的声音效果开始播放。如果声音已经在播放，那么在几乎所有情况下，我们都不希望重新启动声音。这个配方包括一个测试，以确保只有当音频源组件当前未播放时，才会发送
    `Play()` 消息。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Try this with any audio clip that is one second or longer in duration. We have
    included the engineSound audio clip inside the `04_05` folder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用任何时长为一秒或更长的音频片段。我们已将 engineSound 音频剪辑包含在 `04_05` 文件夹中。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To prevent an **AudioClip** from restarting, follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止 **AudioClip** 重新启动，请按照以下步骤操作：
- en: Create a new Unity 2D project and import the sound clip file.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目并导入音频剪辑文件。
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the `AudioClip engineSound`. This can be done in a single step by dragging
    the music clip from the Project panel into either the Hierarchy or Scene panels.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个包含 **AudioSource** 组件的 GameObject，该组件连接到 `AudioClip engineSound`。这可以通过从项目面板拖动音乐剪辑到层次结构或场景面板的单一步骤完成。
- en: Uncheck the Play Awake property for the **AudioSource** component of the engineSound GameObject –
    so this sound does not begin playing as soon as the scene is loaded.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中 engineSound GameObject 的 **AudioSource** 组件的 Play Awake 属性 - 因此，当场景加载时，此声音不会开始播放。
- en: Create a UI button named **Button-play-sound**, changing its text to Play Sound.
    Position the button in the center of the screen by setting its Rect **Transform**
    property position to middle-center.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **Button-play-sound** 的 UI 按钮，将其文本更改为播放声音。通过设置其 Rect **Transform** 属性位置为中间中心，将按钮放置在屏幕中央。
- en: 'Create a C# script class, `WaitToFinishBeforePlaying`, in a new folder, `_Scripts`,
    containing the following code, and add an instance as a scripted component to
    the Main Camera GameObject:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `_Scripts` 的新文件夹中创建一个 C# 脚本类 `WaitToFinishBeforePlaying`，包含以下代码，并将其作为脚本组件添加到
    Main Camera GameObject 中：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With Main Camera selected in the **Hierarchy** panel, drag engineSound into
    the Inspector panel for the public Audio Source variable, and drag the Text child
    of Button-play-sound for the public ButtonText.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择主摄像机，将engineSound拖动到检查器面板中的公共Audio Source变量，并将Button-play-sound的Text子组件拖动到公共ButtonText。
- en: With Button-play-sound selected in the Hierarchy panel, create a new on-click
    event-handler, dragging the Main Camera into the Object slot, and selecting the
    `ACTION_PlaySoundIfNotPlaying()` function.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择Button-play-sound，创建一个新的on-click事件处理器，将Main Camera拖动到对象槽中，并选择`ACTION_PlaySoundIfNotPlaying()`函数。
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '**Audio Source** components have a public readable property, **isPlaying**,
    which is a Boolean true/false flag, indicating whether the sound is currently
    playing. In this recipe, the text of the button is set to display Play Sound when
    the sound is not playing, and (`sound playing`) when it is. When the button is
    clicked, the `ACTION_PlaySoundIfNotPlaying()` method is called. This method uses
    an `if` statement, ensuring that a `Play()` message is only sent to the Audio
    Source component if its **isPlaying** is false, and updates the button''s text
    as appropriate.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Audio Source**组件有一个公共可读属性，**isPlaying**，它是一个布尔值true/false标志，指示声音是否正在播放。在本配方中，当声音未播放时，按钮文本设置为显示播放声音，当正在播放时显示（`sound
    playing`）。当按钮被点击时，会调用`ACTION_PlaySoundIfNotPlaying()`方法。此方法使用`if`语句，确保只有当Audio
    Source组件的**isPlaying**为false时，才向Audio Source组件发送`Play()`消息，并适当地更新按钮的文本。'
- en: See also
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Waiting for the audio to finish playing before auto-destructing an object*
    recipe in this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中关于**在音频播放完成后自动销毁对象**的配方。
- en: Waiting for the audio to finish playing before auto-destructing an object
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象自动销毁前等待音频播放完成
- en: An event may occur (such as an object pickup or the killing of an enemy) that
    we wish to notify to the player of by playing an audio clip, and an associated
    visual object (such as an explosion particle system, or a temporary object in
    the location of the event). However, as soon as the clip has finished playing,
    we will want the visual object to be removed from the scene. This recipe provides
    a simple way to link the ending of a playing audio clip with the automatic destruction
    of its containing object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生某些事件（例如拾取对象或杀死敌人），我们希望通过播放音频片段并关联一个视觉对象（例如爆炸粒子系统或事件位置的临时对象）来通知玩家。然而，一旦音频片段播放完成，我们希望将视觉对象从场景中移除。本配方提供了一种简单的方法，将播放音频片段的结束与包含对象的自动销毁链接起来。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Try this with any audio clip that is a second or more in duration. We have included
    the `engineSound` audio clip inside the `04_06` folder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用任何时长为一秒或更长的音频片段。我们已在`04_06`文件夹中包含了`engineSound`音频片段。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To wait for audio to finish playing before destroying its parent GameObject,
    follow these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在销毁其父GameObject之前等待音频播放完成，请按照以下步骤操作：
- en: Create a new Unity 2D project and import the sound clip file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目并导入音频片段文件。
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the **AudioClip** **engineSound**. This can be done in a single step by dragging
    the music clip from the Project panel into either the **Hierarchy** or **Scene**
    panels. Rename this the AudioObject GameObject.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个包含**AudioSource**组件并链接到**AudioClip** `engineSound`的GameObject。这可以通过将音乐片段从项目面板拖动到**层次结构**或**场景**面板中一步完成。将此GameObject重命名为AudioObject。
- en: Uncheck the Play Awake property for the AudioSource component of the **GameObject**
    engineSound – so this sound does not begin playing as soon as the scene is loaded.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选**engineSound** GameObject的AudioSource组件的Play Awake属性，这样当场景加载时，这个声音不会立即开始播放。
- en: 'Create a C# script class, `AudioDestructBehaviour`, in a new folder, `_Scripts`,
    containing the following code, and add an instance as a scripted component to
    the AudioObject GameObject:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹`_Scripts`中创建一个C#脚本类，名为`AudioDestructBehaviour`，并包含以下代码，然后将其实例作为脚本组件添加到AudioObject
    GameObject中：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the **Inspector** panel, disable (uncheck) the `AudioDestructBehaviour`
    scripted component of AudioObject (when needed, it will be re-enabled via C# code):'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中禁用（取消选中）AudioObject的`AudioDestructBehaviour`脚本组件（当需要时，将通过C#代码重新启用）：
- en: '![](img/ea58c4f8-5e25-4d9e-9dbc-1584ab99cb18.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea58c4f8-5e25-4d9e-9dbc-1584ab99cb18.png)'
- en: 'Create a C# script class, `ButtonActions`, in the `_Scripts` folder, containing
    the following code, and add an instance as a scripted component to the Main Camera
    GameObject:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_Scripts` 文件夹中创建一个名为 `ButtonActions` 的 C# 脚本类，包含以下代码，并将其实例作为脚本组件添加到主摄像机 GameObject
    中：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With Main Camera selected in the **Hierarchy** panel, drag AudioObject into
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择主摄像机，将 AudioObject 拖入
- en: the **Inspector** panel for the public Audio Source variable.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Inspector** 面板中的公共音频源变量。'
- en: With Main Camera selected in the **Hierarchy** panel, drag AudioObject into
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择主摄像机，将 AudioObject 拖入
- en: the **Inspector** panel for the public Audio Destruct Scripted Object variable.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Inspector** 面板中的公共音频销毁脚本对象变量。'
- en: Create a UI button named **Button-play-sound**, changing its text to Play Sound.
    Position the button in the center of the screen by setting its **Rect Transform**
    property to middle-center.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个名为 **Button-play-sound** 的 UI 按钮，将其文本更改为 Play Sound。通过设置其 **Rect Transform**
    属性为中间中心，将按钮放置在屏幕中央。 '
- en: With Button-play-sound selected in the **Hierarchy** panel, create a new on-click
    event-handler, dragging the Main Camera into the Object slot, and selecting the
    `ACTION_PlaySound()` function.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择 Button-play-sound，创建一个新的点击事件处理器，将主摄像机拖入对象槽中，并选择 `ACTION_PlaySound()`
    函数。
- en: Create a second UI button named Button-destroy-when-finished-playing, changing
    its text to Destroy When Sound Finished. Position the button in the center of
    the screen (just below the other button) by setting its **Rect Transform** property
    to middle-center and then drag the button down a little.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个 UI 按钮，命名为 Button-destroy-when-finished-playing，将其文本更改为 Destroy When Sound
    Finished。通过将按钮的 **Rect Transform** 属性设置为中间中心，并将按钮向下拖动一点，将按钮放置在屏幕中央（位于另一个按钮下方）。
- en: With Button-destroy-when-finished-playing selected in the **Hierarchy** panel,
    create a new on-click event-handler, dragging the Main Camera into the Object
    slot, and selecting the `ACTION_ DestroyAfterSoundStops()` function.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 面板中选择 Button-destroy-when-finished-playing，创建一个新的点击事件处理器，将主摄像机拖入对象槽中，并选择
    `ACTION_DestroyAfterSoundStops()` 函数。
- en: Run the scene. Clicking the Play Sound button will play the engine sound each
    time. However, once the Destroy When Sound Finished button has been clicked, as
    soon as the engineSound finished playing, you'll see the AudioObject GameObject disappear
    from the **Hierarchy** panel, since the GameObject has destroyed itself.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。点击 **Play Sound** 按钮将每次播放引擎声音。然而，一旦点击了 **Destroy When Sound Finished**
    按钮，一旦引擎声音播放完毕，你将看到 AudioObject GameObject 从 **Hierarchy** 面板中消失，因为该 GameObject
    已经自我销毁。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a ButtonActions script class and added an instance as a component
    to the Main Camera **GameObject**. This has two public variables, one to an **AudioSource**
    and one to an instance of the AudioDestructBehaviour scripted component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个名为 ButtonActions 的脚本类，并将其实例作为一个组件添加到了主摄像机 **GameObject** 中。这个类有两个公共变量，一个指向
    **AudioSource**，另一个指向 AudioDestructBehaviour 脚本组件的实例。
- en: The GameObject named **AudioObject** contains an **AudioSource** component,
    which stores and manages the playing of the audio clip. **AudioObject** also contains
    a scripted component, which is an instance of the `AudioDestructBehaviour` class.
    This script is initially disabled. When enabled, every frame in this object (via
    its `Update()` method) tests whether the audio source is playing (`!audio.isPlaying`).
    As soon as the audio is found to be not playing, the GameObject is destroyed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 **AudioObject** 的 GameObject 包含一个 **AudioSource** 组件，该组件存储和管理音频剪辑的播放。**AudioObject**
    还包含一个脚本组件，它是 `AudioDestructBehaviour` 类的实例。此脚本最初是禁用的。当启用时，该对象中的每一帧（通过其 `Update()`
    方法）都会测试音频源是否正在播放（`!audio.isPlaying`）。一旦发现音频未播放，该 GameObject 将被销毁。
- en: There are two UI buttons created. The **Button-play-sound** button calls the
    `ACTION_PlaySound()` method of the scripted component in **Main Camera**. This
    method will start playing the audio clip, if it is not already playing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个 UI 按钮。**Button-play-sound** 按钮会调用 **Main Camera** 中脚本组件的 `ACTION_PlaySound()`
    方法。此方法将开始播放音频剪辑，如果它尚未播放的话。
- en: The second button, **Button-destroy-when-finished-playing**, calls the `ACTION_``DestoryAfterSoundStops()` method
    of the scripted component in Main Camera. This method enables the **AudioDestructBehaviour** scripted
    component in the **AudioObject** GameObject – so that the **AudioObject GameObject** will
    be destroyed, once its **AudioSource** sound has finished playing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个按钮，**Button-destroy-when-finished-playing**，调用Main Camera中脚本组件的`ACTION_``DestoryAfterSoundStops()`方法。此方法启用**AudioObject**
    GameObject中的**AudioDestructBehaviour**脚本组件 – 因此**AudioObject GameObject**将在其**AudioSource**声音播放完毕后销毁。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Preventing an Audio Clip from restarting if it is already playing* recipe
    in this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中*防止音频剪辑在播放时重新启动*的配方。
- en: Creating a metronome through the precise scheduling of sounds with dspTime
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过精确安排声音播放时间创建节拍器
- en: 'In cases where we need precise scheduling of when sounds play, we should use
    the `AudioSource.PlayScheduled(...)` method. This method uses the `AudioSettings.dspTime`
    value, which is highly accurate based on the playing of music data through the
    Unity audio system. Another advantage of the `dspTime` value is that is it independent
    of the graphical rendering frame rate:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要精确安排声音播放时间的情况下，我们应该使用`AudioSource.PlayScheduled(...)`方法。此方法使用`AudioSettings.dspTime`值，该值基于通过Unity音频系统播放的音乐数据，非常精确。`dspTime`值的另一个优点是它独立于图形渲染帧率：
- en: '![](img/14fad81a-0b48-4ccc-bb69-4fa176b67d3d.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14fad81a-0b48-4ccc-bb69-4fa176b67d3d.png)'
- en: Note that the `dspTime` value is automatically frozen when a game is paused
    or suspended – so music scheduled using this approach will pause and resume flawlessly
    along with the scene gameplay. In this recipe, we'll create a metronome by precisely
    scheduling when two different sounds will play. Note that this recipe is based
    on some examples from the Unity documentation for the `AudioSource.PlayScheduled(...)`
    method: [https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html](https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当游戏暂停或挂起时，`dspTime`值会自动冻结 – 因此使用此方法安排的音乐将完美地暂停和恢复，与场景游戏玩法同步。在这个配方中，我们将通过精确安排两个不同声音播放的时间来创建节拍器。请注意，这个配方基于Unity文档中`AudioSource.PlayScheduled(...)`方法的某些示例：[https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html](https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html)。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided two metronome sound clips inside the `04_07`
    folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`04_07`文件夹中提供了两个节拍器声音剪辑。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To schedule a sound to play after a given delay, do the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要在给定延迟后播放声音，请执行以下操作：
- en: Create a new Unity 2D project and import the provided sound clip files.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目并导入提供的声音剪辑文件。
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the **metronome_tick AudioClip**. This can be done in a single step by dragging
    the music clip from the Project panel into either the **Hierarchy** or **Scene**
    panels.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个包含与**metronome_tick AudioClip**链接的**AudioSource**组件的GameObject。这可以通过将音乐剪辑从项目面板拖动到**Hierarchy**或**Scene**面板的单个步骤来完成。
- en: Repeat the previous step to create another GameObject, containing an **AudioSource**
    linked to the metronome_tick_accent clip.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤创建另一个GameObject，包含一个与metronome_tick_accent剪辑链接的**AudioSource**。
- en: For both **AudioSources** created, uncheck the Play Awake property – so these
    sounds do not begin playing as soon as the scene is loaded.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于创建的两个**AudioSources**，取消选中Play Awake属性 – 因此这些声音不会在场景加载时立即开始播放。
- en: Create an empty GameObject named MetronomeManager.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为MetronomeManager的空GameObject。
- en: 'Create a C# script class, Metronome, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the MetronomeManager
    GameObject:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的文件夹`_Scripts`中创建一个名为Metronome的C#脚本类，包含以下代码，并将其作为脚本组件添加到MetronomeManager GameObject中：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Select the MetronomeManager GameObject in the Hierarchy. Drag metronome_tick
    from the Hierarchy into the **Inspector** Audio Source Tick Basic public variable,
    for the Metronome (Script) component.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Hierarchy中选择MetronomeManager GameObject。将metronome_tick从Hierarchy拖动到**Inspector**中的Audio
    Source Tick Basic公共变量，用于Metronome (Script)组件。
- en: 'Drag metronome_tick_accent from the Hierarchy into the Inspector Audio Source
    Tick Accent public variable, for the Metronome (Script) component:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将metronome_tick_accent从Hierarchy拖动到Inspector中的Audio Source Tick Accent公共变量，用于Metronome
    (Script)组件：
- en: '![](img/cd68dae0-aece-415a-b050-2e78d38f168e.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd68dae0-aece-415a-b050-2e78d38f168e.png)'
- en: Play the scene. You will see (in the Console) and hear the regular metronome
    sounds, with the first beat of each count playing the accented (and louder) sound.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。你将在（控制台）中看到并听到定时的节拍声，每个计数的第一拍将播放强调（并且更响亮）的声音。
- en: Try changing the Bpm (beats per minute) setting, to speed up or slow down the
    metronome. Or change the number of Beats Per Measure, to count up to 3, 4, or
    6 beats between each accented beat.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改 Bpm（每分钟节拍数）设置，以加快或减慢节拍器的速度。或者更改每个强调节拍之间的节拍数，以计数到 3、4 或 6 个节拍。
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You add to the scene two GameIObjects, containing AudioSources linked to music
    clips for a basic and an accented metronome "tick." You created a Metronome C#
    script class and added an instance to an empty GameObject. You associated the
    two AudioSources in your GameObjects with the two public variables in your scripted
    component.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你在场景中添加了两个 **GameIObjects**，包含与基本和强调节拍器的“tick”音乐剪辑链接的 AudioSources。你创建了一个 Metronome
    C# 脚本类并将其添加到一个空 GameObject 中。你将你的 GameObject 中的两个 **AudioSources** 与脚本组件中的两个公共变量关联起来。
- en: The `Start()` method calculates the duration of each beat (based on bpm), initializes
    the beat count (so the first beat is an accented beat), and then sets `nextTickTime`,
    the time for the next tick to the current dspTime.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法计算每个节拍的持续时间（基于 bpm），初始化节拍计数（因此第一个节拍是强调节拍），然后设置 `nextTickTime`，下一个
    tick 的时间为当前的 dspTime。'
- en: The `IsNearlyTimeForNextTick()` method returns a Boolean true/false value indicating
    if it is nearly time to schedule the next tick. The value returned is based on
    whether the current `dspTime` is within 1/10^(th) of a second of the value of
    `nextTickTime`. If so, then true is returned.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsNearlyTimeForNextTick()` 方法返回一个布尔值 true/false，表示是否接近安排下一个 tick 的时间。返回的值基于当前
    `dspTime` 是否在 `nextTickTime` 的 1/10^(th) 秒内。如果是，则返回 true。'
- en: The `Update()` method is a single if statement. If it's nearly time for the
    next beat, the `BeatAction()` method is invoked.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法是一个单行 if 语句。如果接近下一个节拍的时间，则调用 `BeatAction()` 方法。'
- en: 'The `BeatAction()` method does the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeatAction()` 方法执行以下操作：'
- en: Adds 1 to the number of beats
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将节拍数加 1
- en: Initializes the accentMessage string to be empty (the default)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `accentMessage` 字符串初始化为空（默认值）
- en: 'IF:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IF:'
- en: the next beat should be 1 (the accent), AccentBeatAction() and the string returned
    are stored in accentMessage
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个节拍应该是 1（强调），存储 `AccentBeatAction()` 和返回的字符串在 `accentMessage`
- en: 'ELSE (if not accent next beat):'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELSE（如果不是强调下一个节拍）：
- en: the basic beat sound is scheduled
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安排基本的节拍声音
- en: The next beat time is calculated (current beat time + duration of each beat)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算下一个节拍时间（当前节拍时间 + 每个节拍的持续时间）
- en: It displays the beat count message in Console (including the string for any
    accent message)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在控制台中显示节拍计数信息（包括任何强调信息的字符串）
- en: 'The AccentBeatAction() method does three things: it schedules the accented
    beat sound, it resets the beat count to 1, and it returns a string to be shown
    with the beat message (with text to indicate an accent beat is next: -- ACCENT
    ---).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccentBeatAction()` 方法执行三件事：它安排强调节拍声音，重置节拍计数为 1，并返回一个字符串，与节拍信息一起显示（带有文本表示下一个是强调节拍：--
    ACCENT ---）。'
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Creating just-in-time AudioSource GameObjects for the basic and accented beats
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为基本和强调节拍创建即时 AudioSource GameObjects
- en: We can reduce the Design-Time work for the metronome by making use of the Extension
    method presented in the *Creating just-in-time AudioSource components at runtime
    through C# scripting* recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用在 *Creating just-in-time AudioSource components at runtime through C#
    scripting* 菜谱中提出的扩展方法来减少节拍器的 Design-Time 工作量。
- en: 'First, copy the `ExtensionMethods.cs`  C# script class into your metronome
    project. Next, delete the two GameObjects in the scene containing **AudioSource**
    components, and instead declare two public variables for each `AudioClip ()`.
    Finally, we just need to write an `Awake()` method that will create the required
    GameObjects in the scene containing **AudioSource** basic on the **AudioClip**
    variables (and making the basic beat quieter than the accented one):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `ExtensionMethods.cs` C# 脚本类复制到你的节拍器项目中。然后，删除场景中包含 **AudioSource** 组件的两个
    **GameObjects**，而是为每个 `AudioClip ()` 声明两个公共变量。最后，我们只需要编写一个 `Awake()` 方法，该方法将在场景中创建所需的
    GameObjects，包含基于 **AudioClip** 变量的 **AudioSource**（并且使基本的节拍比强调的节拍更轻）：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating beat sounds through data rather than AudioClips
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过数据而不是 AudioClips 创建节拍声音
- en: The Unity documentation about `dspTime` provides an interesting approach to
    creating the basic and accented beats for a metronome – though editing the audio
    data samples themselves. Check out their scripted metronome at [https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html](https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Unity文档中关于`dspTime`的说明提供了一个有趣的创建节拍器基本和重音节的方法——尽管是编辑音频数据样本本身。查看他们的脚本节拍器在[https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html](https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html)。
- en: Matching the audio pitch to the animation speed
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将音频音调与动画速度匹配
- en: Many artifacts sound higher in pitch when accelerated and lower when slowed
    down. Car engines, fan coolers, a record player... the list goes on. If you want
    to simulate this kind of sound effect in an animated object that can have its
    speed changed dynamically, follow this recipe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在加速时音调更高，在减速时音调更低的文物。汽车引擎、风扇冷却器、唱机...等等。如果你想在可以动态改变速度的动画对象中模拟这种音效，请遵循这个食谱。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need an animated 3D object and an audio clip. Please
    use the `animatedRocket.fbx` and `engineSound.wav` files, available in the `04_08`
    folder.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要一个动画3D对象和一个音频剪辑。请使用`04_08`文件夹中可用的`animatedRocket.fbx`和`engineSound.wav`文件。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To change the pitch of an audio clip according to the speed of an animated
    object, please follow these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据动画对象的速度更改音频剪辑的音调，请按照以下步骤操作：
- en: Create a new Unity 3D project.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: Create a new Models folder in the Project panel, and into this import the provided
    animatedRocket.fbx file.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新的Models文件夹，并将提供的animatedRocket.fbx文件导入到其中。
- en: Create a new Sounds folder in the Project panel, and into this Import the provided
    audio clip, engineSound.wav.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中创建一个新的Sounds文件夹，并将提供的音频剪辑engineSound.wav导入到其中。
- en: 'Select the animatedRocket file in the Project panel. In the Inspector for animatedRocket
    Import Settings, click the Animations button. In Animations select (the only) Take
    001 clip, and make sure to check the Loop Time option. Click on the Apply button
    to save the changes. See the screenshot for these settings:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中选择animatedRocket文件。在animatedRocket导入设置的检查器中，单击动画按钮。在动画中选择（唯一的）Take 001剪辑，并确保选中Loop
    Time选项。单击应用按钮以保存更改。请参阅截图以了解这些设置：
- en: '![](img/287379b6-8649-4823-9ee6-d6dbd243f51d.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/287379b6-8649-4823-9ee6-d6dbd243f51d.png)'
- en: The reason we didn't need to check **Loop Pose** option is because our animation
    already loops in a seamless fashion. If it didn't, we could have checked that
    option to automatically create a seamless transition from the last to the first
    frame of the animation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要检查**Loop Pose**选项的原因是因为我们的动画已经以无缝的方式循环。如果它没有，我们可以检查该选项以自动创建从动画最后一帧到第一帧的无缝过渡。
- en: Add an instance of `animatedRocket` as a GameObject in the scene by dragging
    it from the **Project** panel into the Scene or **Hierarchy** panel.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**项目**面板拖动到场景或**层次结构**面板，将`animatedRocket`的实例添加到场景中的GameObject。
- en: Add an AudioSource component to the engineSound GameObject.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个AudioSource组件添加到engineSound GameObject中。
- en: 'With engineSound selected in the **Hierarchy**, drag the engineSound AudioClip
    file from the **Project** panel into the **Inspector** for the **Audio Clip**
    parameter of the Audio Source component. Ensure the Loop option is checked, and
    the Play On Awake option is unchecked:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择engineSound，将engineSound AudioClip文件从**项目**面板拖动到Audio Source组件的**检查器**中的**音频剪辑**参数。确保选中Loop选项，取消选中Play
    On Awake选项：
- en: '![](img/76e48ab6-4c24-4282-a9ed-7f01865ee829.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76e48ab6-4c24-4282-a9ed-7f01865ee829.png)'
- en: Create an Animator Controller for our model. Select the Models folder in the
    Project panel, and use the Create menu to create a new **Animator** Controller
    file named Rocket Controller.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的模型创建一个Animator Controller。在项目面板中选择Models文件夹，并使用创建菜单创建一个名为Rocket Controller的新**Animator**
    Controller文件。
- en: 'Double-click the Rocket Controller file in the Project panel to open the **Animator**
    panel. Create a new state by choosing menu option: Create State | Empty (as shown
    in the screenshot):'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击项目面板中的Rocket Controller文件以打开**Animator**面板。通过选择菜单选项：创建状态 | 空状态（如图所示）来创建一个新状态：
- en: '![](img/0851aa59-05c6-44b6-a4dd-671a7322b5c6.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0851aa59-05c6-44b6-a4dd-671a7322b5c6.png)'
- en: 'Rename this new state spin (in its **Inspector** properties), and set Take
    001 as its motion in the Motion field:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新状态重命名为spin（在其**检查器**属性中），并在运动字段中将Take 001设置为它的动作：
- en: '![](img/f3bc6c09-492f-46a9-9f72-e6a5830cfb12.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3bc6c09-492f-46a9-9f72-e6a5830cfb12.png)'
- en: 'Select animatedRocket in the **Hierarchy** panel. Drag Rocket Controller from
    the `Models` folder in the Project panel into the Controller parameter for the
    Animator component in the **Inspector**. Ensure that the Apply Root Motion option
    is unchecked in the **Inspector**:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 面板中选择 animatedRocket。从项目面板中的 `Models` 文件夹将 Rocket Controller 拖动到
    **检查器** 中 Animator 组件的控制器参数。确保在 **检查器** 中未选中应用根运动选项：
- en: '![](img/4d01c174-4d66-42a1-b905-887aba4211fa.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d01c174-4d66-42a1-b905-887aba4211fa.png)'
- en: 'Create a C# script class, `ChangePitch`, in the `_Scripts` folder, containing
    the following code, and add an instance as a scripted component to the `animatedRocket`
    GameObject:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_Scripts` 文件夹中创建一个 C# 脚本类 `ChangePitch`，包含以下代码，并将其作为脚本组件添加到 `animatedRocket`
    GameObject 中：
- en: '[PRE12]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Play the scene and change the animation speed by pressing number key 1 (accelerate)
    and 2 (decelerate) on your keyboard. The audio pitch will change accordingly.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景，并通过按键盘上的数字键 1（加速）和 2（减速）来改变动画速度。音调将相应地改变。
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a C# script class, **ChangePitch**, and added an instance to the **animatedRocket**
    GameObject. It declares several variables, the most important of which is `acceleration`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个 C# 脚本类，**ChangePitch**，并将其实例添加到 **animatedRocket** GameObject 中。它声明了几个变量，其中最重要的是
    `acceleration`。
- en: It's `Awake()` method caches references to the Animator and **AudioSource**
    sibling components. The `Start()` method sets the initial speed from the **Animator**,
    and calls the `AccelerateRocket(...)` method, passing 0 to calculate the resulting
    pitch for the Audio Source.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `Awake()` 方法缓存了对 Animator 和 **AudioSource** 兄弟组件的引用。`Start()` 方法从 **Animator**
    设置初始速度，并调用 `AccelerateRocket(...)` 方法，传递 0 来计算音频源的音调。
- en: In each frame, the Update() method tests for keyboard keys 1 and 2\. When detected,
    they call the `AccelerateRocket(...)` method, passing a positive or negative value
    of acceleration as appropriate.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，`Update()` 方法测试键盘键 1 和 2。当检测到时，它们将调用 `AccelerateRocket(...)` 方法，传递适当的加速度的正值或负值。
- en: The `AccelerateRocket(...)` method increments variable speed with the received
    argument. The `Mathf.Clamp()` command limits the new speed value between the minimum
    and maximum speed. Then, it changes the **Animator** speed and **Audio Source**
    pitch according to the new speed absolute (positive) value. The value is then
    clamped a second time to avoid negative numbers. If you wish to reverse the animation,
    check out the code files in the solution provided for this recipe.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccelerateRocket(...)` 方法通过接收到的参数增加变量速度。`Mathf.Clamp()` 命令将新的速度值限制在最小和最大速度之间。然后，它根据新的速度绝对（正值）值改变
    **Animator** 速度和 **Audio Source** 音调。该值随后再次被限制以避免出现负数。如果你希望反转动画，请查看此菜谱提供的解决方案中的代码文件。'
- en: Please note that setting the animation speed, and therefore the sound pitch,
    to 0 will cause the sound to stop, making it clear that stopping the object's
    animation also prevents the engine sound from playing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将动画速度和因此音调设置为 0 将导致声音停止，这清楚地表明停止对象的动画也会阻止引擎声音播放。
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is some information on how to fine-tune and customize this recipe.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于如何微调和自定义这个菜谱的信息。
- en: Changing the Animation/Sound Ratio
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变动画/声音比率
- en: If you want the audio clip pitch to be more or less affected by the animation
    speed, change the value of the public Animation/Sound Ratio parameter in the Inspector.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望音频剪辑的音调更多地或更少地受动画速度的影响，请更改检查器中的公共动画/声音比率参数的值。
- en: Accessing the function from other scripts
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他脚本访问函数
- en: 'The `AccelerateRocket(...)` function was made public so that it can be accessed
    from other scripts. As an example, we have included the `ExternalChangePitch.cs`
    script in the `_Scripts` folder. To illustrate how the **ChangePitch** scripted
    component can be controlled form another script, do the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccelerateRocket(...)` 函数被设置为公共，以便可以从其他脚本访问。例如，我们在 `_Scripts` 文件夹中包含了 `ExternalChangePitch.cs`
    脚本。为了说明如何从另一个脚本控制 **ChangePitch** 脚本组件，请执行以下操作：'
- en: Attach this script to the **Main Camera** GameObject. Drag the **animatedRocket** GameObject
    from the Hierarchy into the public **Change Pitch Scripted Component** variable.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本附加到 **主摄像机** GameObject。从层次结构面板中将 **animatedRocket** GameObject 拖动到公共 **Change
    Pitch Scripted Component** 变量中。
- en: Run the scene.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。
- en: Use the *UP* and *DOWN* arrow keys to control the animation speed (and sound
    pitch).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *上* 和 *下* 方向键来控制动画速度（以及音调）。
- en: Allowing reverse animation (negative speeds!)
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许反向动画（负速度！）
- en: In the Animator panel, create a new Float parameter, **Speed**, initialized
    to 1.0\. With state spin selected in the **Animator** panel, check the **Speed
    Parameter Multiplier** option and choose the **Speed** parameter. In the Inspector,
    set **Min Speed** to -2, to allow negative speeds for animations.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画器面板中，创建一个新的浮点参数，**速度**，初始化为1.0。在**动画器**面板中选择**旋转状态**，勾选**速度参数乘数**选项并选择**速度**参数。在检查器中，将**最小速度**设置为-2，以允许动画使用负速度。
- en: 'In the **ChangePitch** C# script, replace the **AccelerateRocket** method with
    the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ChangePitch** C#脚本中，将**AccelerateRocket**方法替换为以下内容：
- en: '[PRE13]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now when you use key 1 (accelerate) and 2 (decelerate), you can actually decelerate
    to zero and then continue to reverse the animation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你使用键1（加速）和2（减速）时，你实际上可以将速度减速到零然后继续反向动画。
- en: Simulating acoustic environments with Reverb Zones
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reverb Zones模拟声学环境
- en: Once you have created your level's geometry and the scene is looking just the
    way you want it to, you might want your sound effects to correspond to that look.
    Sound behaves differently depending upon the environment in which it is projected,
    so it can be a good idea to make it reverberate accordingly. In this recipe, we
    will address this acoustic effect by using Reverb Zones.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的级别几何形状并且场景看起来正是你想要的，你可能希望你的声音效果与那种外观相匹配。声音的行为取决于其投影的环境，因此使其相应地产生回声可能是一个好主意。在这个菜谱中，我们将通过使用Reverb
    Zones来处理这种声学效果。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the `ReverbZone.unitypackage` file, containing
    a basic level named **reverbScene** and a prefab, Signal. The package can be found
    in the `04_09` folder.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了`ReverbZone.unitypackage`文件，其中包含一个名为**reverbScene**的基本级别和一个预制件，Signal。该包位于`04_09`文件夹中。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to simulate the sonic landscape of a tunnel:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤模拟隧道的声学景观：
- en: Create a new Unity 3D project.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: Import the provided **Unity** package, **ReverbZone**, into your project.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的**Unity**包**ReverbZone**导入到你的项目中。
- en: From the Project panel, open **reverbScene** – it's in the `_Scenes` folder
    in the `ReverbZones` folder. This scene gives you a tunnel, and a controllable
    character (*W A S D* keys and *Shift* to run).
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，打开**reverbScene**——它在`ReverbZones`文件夹中的`_Scenes`文件夹中。这个场景为你提供了一个隧道，和一个可控制的角色（*W
    A S D*键和*Shift*键用于奔跑）。
- en: 'From the Project panel, drag the Signal prefab into the Hierarchy – it''s in
    the `_Prefabs` folder in the `ReverbZones` folder. This will add a sound-emitting
    object to the scene. Place it in the center of the tunnel:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中，将Signal预制件拖放到层次结构中——它在`ReverbZones`文件夹中的`_Prefabs`文件夹中。这将向场景添加一个发声对象。将其放置在隧道的中心：
- en: '![](img/c5f6e601-504a-4af4-a12e-8db352f55463.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5f6e601-504a-4af4-a12e-8db352f55463.png)'
- en: 'Make five copies of the **Signal** GameObject and distribute them throughout
    the tunnel (leaving a copy just outside each entrance):'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Signal**游戏对象复制五次并分布在整个隧道中（在每个入口外留一个副本）：
- en: '![](img/496916f1-7221-4a49-b39c-60114dedfdd3.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/496916f1-7221-4a49-b39c-60114dedfdd3.png)'
- en: In the Hierarchy panel, use the **Create menu** | **Audio** | **Audio Reverb
    Zone** to add a **Reverb Zone** to the scene. Then place this new GameObjct in
    the center of the tunnel.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中，使用**创建菜单** | **音频** | **音频混响区域**来向场景添加一个**混响区域**。然后将这个新游戏对象放置在隧道的中心。
- en: Use menu GameObject | Move To View if there is already a GameObject where you
    want to position another one. Since our Signal GameObject is in the middle of
    the tunnel, we can double-click that GameObject, then single-click Reverb Zone
    and move to view – to move the Reverb Zone object to the same location.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经有一个GameObject位于你想要放置另一个GameObject的位置，请使用菜单GameObject | Move To View。由于我们的Signal
    GameObject位于隧道的中间，我们可以双击该GameObject，然后单击Reverb Zone并移动到视图——将Reverb Zone对象移动到相同的位置。
- en: 'Select the **Reverb Zone** GameObject. In the Inspector panel, change the **Reverb
    Zone** component parameters to these values: **Min Distance** = `6`, **Max Distance**
    = `18`, and **Preset** = `StoneCorridor`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**混响区域**游戏对象。在检查器面板中，将**混响区域**组件参数更改为以下值：**最小距离** = `6`，**最大距离** = `18`，和**预设**
    = `StoneCorridor`：
- en: '![](img/5bd41d25-65a8-4e4f-9c0b-266f32bf832b.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bd41d25-65a8-4e4f-9c0b-266f32bf832b.png)'
- en: Play the scene. As you walk through the tunnel, you will hear the audio reverberate
    when inside the Reverb Zone area.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。当你穿过隧道时，你会在混响区域区域内听到音频回声。
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once positioned, the Audio Reverb Zone applies an audio filter to all audio
    sources within its radius.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定位，音频混响区域将对其半径内的所有音频源应用音频过滤器。
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are more options for you to try.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多选项供您尝试。
- en: Attaching the Audio Reverb Zone component to Audio Sources
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将音频混响区域组件附加到音频源
- en: Instead of creating an Audio Reverb Zone GameObject, you can attach it to the
    sound-emitting object (in our case, Signal) as a component through the **Component**
    | **Audio** | **Audio** **Reverb Zone** menu. In such cases, the Reverb Zone will
    be individually set up around its parent GameObject.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以不创建音频混响区域GameObject，而是通过**组件** | **音频** | **音频混响区域**菜单将其附加到发声对象（在我们的案例中，是Signal）作为组件。在这种情况下，混响区域将围绕其父GameObject单独设置。
- en: Making your own Reverb settings
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的混响设置
- en: Unity comes with several **Reverb Presets**. We have used **StoneCorridor**,
    but your scene can ask for something less intense (such as Room) or more radical
    (such as Psychotic). If these presets still won't be able to recreate the effect
    that you have in mind, change it to User and edit its parameters as you wish.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Unity自带几个**混响预设**。我们使用了**石质走廊**，但您的场景可能需要更不强烈（例如房间）或更激进（例如精神错乱）的预设。如果这些预设仍然无法重现您心中的效果，请将其更改为用户预设，并根据您的意愿编辑其参数。
- en: Adding volume control with Audio Mixers
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频混音器添加音量控制
- en: Sound-volume adjustment can be a very important feature, especially if your
    game is a standalone. After all, it can be very frustrating for players to have
    to access the **Operating System** volume control. In this recipe, we will use
    the Audio Mixer feature to create independent volume controls for Music and Sound
    FX.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 声音音量调整可能是一个非常重要的功能，尤其是如果您的游戏是独立游戏。毕竟，玩家不得不访问**操作系统**音量控制可能会非常令人沮丧。在这个配方中，我们将使用音频混音器功能为音乐和音效创建独立的音量控制。
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided a Unity package named `VolumeControl.unitypackage`,
    containing an initial scene featuring soundtrack music and sound effects. The
    file is available inside the `04_10` folder.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们提供了一个名为`VolumeControl.unitypackage`的Unity包，其中包含一个具有配乐音乐和音效的初始场景。文件位于`04_10`文件夹中。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To add volume control sliders to your scene, follow these steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要将音量控制滑块添加到您的场景中，请按照以下步骤操作：
- en: Create a new Unity 3D project.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: Import the provided **Unity** package, **Volume**, into your project.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的**Unity**包，**音量**，导入到您的项目中。
- en: Open the **Volume** scene from **Project** panel folder, **VolumeControl** |
    `_Scenes`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板文件夹中打开**音量**场景，**音量控制** | `_Scenes`。
- en: 'Play the scene and walk toward the semitransparent green wall in the tunnel,
    using the *W A S D* keys (press *Shift* to run). You will be able to listen to:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景，并使用*W A S D*键（按*Shift*键跑步）走向隧道中半透明的绿色墙。您将能够听到：
- en: A looping music soundtrack
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个循环的音乐配乐
- en: Bells ringing
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钟声响起
- en: A robotic speech whenever the character collides with the wall
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色与墙壁碰撞时发出机器人语音
- en: In the **Project** panel, use the Create menu to add an **Audio Mixer** file.
    Rename this new file MainMixer.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，使用创建菜单添加一个**音频混音器**文件。将此新文件重命名为**主混音器**。
- en: Double-click MainMixer to open the **Audio Mixer** panel.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**主混音器**以打开**音频混音器**面板。
- en: 'In the the **Audio Mixer** panel **Groups** section, highlight **Master** and
    click the + (plus) sign to add a child to the **Master** group. Name this child
    **Music**. Repeat these actions to add a second child of **Master** named FX:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频混音器**面板的**分组**部分，突出显示**主**，然后单击+（加号）以向**主**组添加子项。将此子项命名为**音乐**。重复这些操作以添加名为**FX**的**主**的第二个子项：
- en: '![](img/4e196b5d-9e9f-481b-81dc-4c86d2caf4e2.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e196b5d-9e9f-481b-81dc-4c86d2caf4e2.png)'
- en: In the the Audio Mixer panel Mixers section, highlight MainMixer and click the
    + (plus) sign to add a new item to the Mixers group. Rename this MusicMixer (you
    may need to rename this via the Project panel, since you've created a new Audio
    Mixer file through this process).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频混音器**面板的**混音器**部分，突出显示**主混音器**，然后单击+（加号）以向**混音器**组添加新项。将此重命名为**音乐混音器**（您可能需要通过项目面板重命名，因为您已通过此过程创建了一个新的音频混音器文件）。
- en: Drag MusicMixer onto MainMixer (child it), and select Music as its output in
    the pop-up dialog window.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**音乐混音器**拖放到**主混音器**（将其作为子项），并在弹出对话框窗口中选择音乐作为其输出。
- en: In the the **Audio Mixer** panel Mixers section, highlight **MainMixer** and
    click the + (plus) sign to add a new item to the **Mixers** group. Name this **FxMixer**.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频混音器**面板的**混音器**部分，突出显示**主混音器**，然后单击+（加号）以向**混音器**组添加新项。将此命名为**FxMixer**。
- en: Child (drag) **FxMixer** onto **MainMixer**, and select Fx as its output in
    the pop-up dialog window.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将（拖动）**FxMixer**拖放到**主混音器**上，并在弹出对话框窗口中选择FX作为其输出。
- en: Select MusicMixer. Select its Master group and add a child named Soundtrack.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择MusicMixer。选择其主组并添加一个名为Soundtrack的子项。
- en: 'Select **FxMixer** and add two children to its **Master** group: one named
    Speech, and another named Bells:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**FxMixer**，并为其**主**组添加两个子项：一个命名为Speech，另一个命名为Bells：
- en: '![](img/dbb0f356-94dd-44f5-95cf-cfd45f3d0948.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbb0f356-94dd-44f5-95cf-cfd45f3d0948.png)'
- en: 'Select the **DialogueTrigger** GameObject in the **Hierarchy**. In the **Inspector**,
    change its **Audio Source** component Output track to **FxMixer** | **Speech**:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中选择**DialogueTrigger**GameObject。在**检查器**中，将它的**音频源**组件输出轨道更改为**FxMixer**
    | **Speech**：
- en: '![](img/7707cd89-f690-4463-bfe7-ef346b642c88.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7707cd89-f690-4463-bfe7-ef346b642c88.png)'
- en: Select the **Soundtrack** GameObject in the **Hierarchy**. In the **Inspector**,
    change its Audio Source component **Output** track to **MusicMixer** | **Soundtrack**.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中选择**Soundtrack**GameObject。在**检查器**中，将它的音频源组件**输出**轨道更改为**MusicMixer**
    | **Soundtrack**。
- en: Select **Signal** from the `Prefabs` folder in the **Project** panel. In the
    **Inspector**, change its Audio Source component Output track to FxMixer | Bells.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板的**预制体**文件夹中选择**Signal**。在**检查器**中，将它的音频源组件输出轨道更改为FxMixer | Bells。
- en: 'Select **MainMixer** in the **Audio Mixer** panel, and select its **Master**
    track. In the **Inspector** panel, right-click on Volume in the **Attenuation**
    component. From the pop-up-context menu, select **Expose** **Volume** (of Master)
    to script:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频混合器**面板中选择**主混合器**，并选择其**主**轨道。在**检查器**面板中，右键单击**衰减**组件中的**音量**。从弹出上下文菜单中选择**暴露**（主）**音量**到脚本：
- en: '![](img/8dde7821-a2ce-4bb1-b8af-89bccd79ce27.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8dde7821-a2ce-4bb1-b8af-89bccd79ce27.png)'
- en: Repeat the operation to expose the **Volume** to scripts for both the **Music**
    and FX Groups.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此操作以将**音量**暴露给**音乐**和FX组的脚本。
- en: 'At the top-right of the **Audio Mixer** panel, you should see **Exposed Parameters**
    (three). Click the drop-down icon, and rename them as follows: MyExposedParam
    to OverallVolume; MyExposedParam1 to MusicVolume, and MyExposedParam2 to FxVolume.
    Note the sequence of the three parameters may not match the order you added them,
    so double-check that the greyed-out track names on the right correspond correctly:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频混合器**面板的右上角，你应该看到**暴露参数**（三个）。点击下拉图标，并按以下名称重命名：MyExposedParam为OverallVolume；MyExposedParam1为MusicVolume，MyExposedParam2为FxVolume。注意三个参数的顺序可能不匹配你添加它们的顺序，所以请确保右侧灰色条目的名称正确对应：
- en: '![](img/5337a07a-2550-47f3-854a-05d204563484.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5337a07a-2550-47f3-854a-05d204563484.png)'
- en: 'In the **Hierarchy** panel, use the **Create** drop-down menu to add a **UI
    Panel** to the scene (menu: **Create** | **UI** | **Panel**). Unity will automatically
    add a Canvas parent for this panel.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中，使用**创建**下拉菜单将**UI面板**添加到场景（菜单：**创建** | **UI** | **面板**）。Unity将自动为该面板添加一个Canvas父级。
- en: 'In the **Hierarchy** panel, create a UI Slider to the scene (menu: **Create**
    | **UI** | **Slider**). Make it a child of the **Panel** object. Rename this slider
    as **Slider-overall**. Set the slider''s Min Value to `0.000025` (or `2.5e-05`).'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中，创建一个UI Slider到场景（菜单：**创建** | **UI** | **Slider**）。将其设置为**面板**对象的子项。将此滑块重命名为**Slider-overall**。将滑块的Min
    Value设置为`0.000025`（或`2.5e-05`）。
- en: Duplicate it and rename the new copy to Slider-music. In the **Inspecto**r panel,
    **Rect Transform** component, change its Pos Y parameter to `-40`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制它并将其新副本重命名为Slider-music。在**检查器**面板中，**Rect Transform**组件，将它的Pos Y参数更改为`-40`。
- en: 'Duplicate Slider-music and rename the new copy to **Slider-fx**. Change its
    **Pos Y** parameter to `-70`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Slider-music并将其新副本重命名为**Slider-fx**。将它的**Pos Y**参数更改为`-70`：
- en: '![](img/350f4d6a-fd4c-4b39-8456-96e54abbf58f.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/350f4d6a-fd4c-4b39-8456-96e54abbf58f.png)'
- en: 'Create a C# script class, **VolumeControl**, in the `_Scripts` folder, containing
    the following code, and add an instance as a scripted component to the **Main
    Camera** GameObject:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_Scripts`文件夹中创建一个C#脚本类，**VolumeControl**，包含以下代码，并将其作为脚本组件添加到**主相机**GameObject：
- en: '[PRE14]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With **Main Camera** selected in the **Hierarchy** panel, drag the **Panel**
    GameObject into the Inspector for the public Panel variable.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主相机**选项卡中选择**层级**面板，将**面板**GameObject拖入检查器以设置公共**面板**变量。
- en: With **Main Camera** selected in the **Hierarchy** panel, drag **MainMixer**
    from the Project panel into the **Inspector** for the public My Mixer variable.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**面板中选择**主相机**，将**主混合器**从项目面板拖入检查器以设置公共My Mixer变量。
- en: Select the **OverallSlider** component. Below the **On Value Changed** list,
    click the + sign to add an action. From the **Hierarchy** panel, drag Main Camera
    into the Object slot and using the drop-down menu, choose VolumeControl | ON_CHANGE_OverallVol
    option.  For testing purposes, change the appropriate selector from Runtime Only
    to Editor and Runtime.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**OverallSlider**组件。在**On Value Changed**列表下方，点击加号以添加一个动作。从**Hierarchy**面板中，将Main
    Camera拖入对象槽，并使用下拉菜单选择VolumeControl | ON_CHANGE_OverallVol选项。  为了测试目的，将适当的选择器从仅运行时更改为编辑器和运行时。
- en: Repeat the previous step with MusicSlider and FxSlider, but this time, choose
    the ON_CHANGE_MusicVol and ON_CHANGE_FxVol options, respectively, from the drop-down
    menu.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MusicSlider和FxSlider重复前面的步骤，但这次，从下拉菜单中选择ON_CHANGE_MusicVol和ON_CHANGE_FxVol选项，分别。
- en: Play the scene. You will be able to access the sliders when pressing *ESCAPE*
    on your keyboard and adjust volume settings from there.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。您可以通过按键盘上的*ESCAPE*键来访问滑块，并从那里调整音量设置。
- en: How it works...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **Audio Mixer** feature works in a similar fashion to **Digital Audio Workstations**,
    such as **Logic** and **Sonar**. Through Audio Mixers you can organize and manage
    audio elements by routing them into specific groups that can have individual audio
    tracks you can tweak, allowing adjustments in volume level and sound effects.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**音频混音器**功能的工作方式与**数字音频工作站**类似，例如**Logic**和**Sonar**。通过音频混音器，您可以通过将它们路由到特定的组来组织和管理工作元素，这些组可以具有可以调整的独立音频轨道，从而允许调整音量级别和音效。'
- en: By organizing and routing our audio clips into two groups (Music and FX), we
    established MainMixer as a unified controller for volume. Then, we used the Audio
    Mixer to expose the volume levels for each track of **MainMixer**, making them
    accessible to our script.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的音频剪辑组织并路由到两个组（音乐和音效），我们建立了MainMixer作为音量统一的控制器。然后，我们使用音频混音器公开**MainMixer**中每个轨道的音量级别，使它们可供我们的脚本访问。
- en: 'Also, we have set up a basic UI featuring three sliders that, when in use,
    will pass their float values (between 0.000025 and 1) as arguments to three specific
    functions in our script: ON_CHANGE_MusicVol, ON_CHANGE_FxVol, and ON_CHANGE_OverallVol.
    These functions, on their turn, use the SetFloat command to effectively change
    the volume levels at runtime. However, before passing on the new volume levels,
    the script converts linear values (between 0.000025 and 1) to the decibel levels
    that are used by the Audio Mixer. This conversion is calculated through the log(x)
    * 20 mathematical function.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们设置了一个基本的用户界面，包含三个滑块，当使用时，将它们的浮点值（介于0.000025和1之间）作为参数传递到脚本中的三个特定函数：ON_CHANGE_MusicVol、ON_CHANGE_FxVol和ON_CHANGE_OverallVol。这些函数反过来使用SetFloat命令在运行时有效地更改音量级别。然而，在传递新的音量级别之前，脚本将线性值（介于0.000025和1之间）转换为音频混音器使用的分贝级别。这种转换是通过log(x)
    * 20数学函数计算的。
- en: For a full explanation on issues regarding the conversion of linear values to
    decibel levels and vice-versa, check out Aaron Brown's excellent article at [http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/](http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将线性值转换为分贝级别以及相反的问题的完整解释，请查看Aaron Brown在[http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/](http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/)上的优秀文章。
- en: 'If one of the sliders seems not to work, double-check that the name of the
    first parameter to `SetFloat(...)` matches the exposed parameter in the **AudioMixer** –
    any spelling difference will mean the on-change function will not change values
    in the **Audio Mixer**. For example, if the named exposed parameter was wrongly
    named "**OveralVolume**" (missing an "l"), this statement in response to a slider
    change would not work due to the spelling mismatch:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个滑块似乎不起作用，请检查`SetFloat(...)`的第一个参数名称是否与**AudioMixer**中暴露的参数匹配——任何拼写差异都意味着更改滑块的on-change函数将不会在**Audio
    Mixer**中更改值。例如，如果命名的暴露参数被错误地命名为“**OveralVolume**”（缺少一个“l”），则由于拼写不匹配，此响应滑块更改的语句将不起作用：
- en: '[PRE15]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `VolumeControl` script includes code to enable and disable the UI and the
    **EventSystem**, depending upon whether the player hits the *ESCAPE* key to activate/deactivate
    the volume-control sliders.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`VolumeControl`脚本包含代码，根据玩家是否按*ESCAPE*键激活/停用音量控制滑块来启用和禁用UI和**EventSystem**。'
- en: Since our VolumeControl script sets the maximum volume level for the music and
    Fx tracks, you should not manually change any of the track volumes of the MainMixer
    at Design-Time. For general adjustments, use the secondary MusicMixer and FxMixer
    mixers.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的VolumeControl脚本设置了音乐和效果音轨的最大音量级别，因此在设计时不应手动更改MainMixer的任何音轨音量。对于一般调整，请使用辅助的MusicMixer和FxMixer混音器。
- en: There's more...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here is some extra information on Audio Mixers.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于音频混音器的额外信息。
- en: Playing with Audio Production
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频制作
- en: There are many creative uses for exposed parameters. We can, for instance, add
    effects such as **Distortion**, **Flange**, and **Chorus** to audio channels,
    allowing users to operate virtual sound tables/mixing boards.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公开的参数有许多创意用途。例如，我们可以向音频通道添加效果，如**失真**、**镶边**和**合唱**，使用户能够操作虚拟音表/混音板。
- en: See also
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Making a dynamic soundtrack with Snapshots* recipe in this chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中关于*使用快照制作动态音轨*的配方。
- en: The *Balancing the in-game audio with Ducking* in this chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中关于*在游戏中平衡音频与 ducking*。
- en: Making a dynamic soundtrack with Snapshots
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用快照制作动态音轨
- en: Dynamic soundtracks are the ones that change according to what is happening
    to the player in the game, musically reflecting that place or moment of the character's
    adventure. In this recipe, we will implement a soundtrack that changes twice;
    the first time when entering a tunnel, and the second time when coming out of
    it. To achieve this, we will use the **Snapshot** feature of the **Audio Mixer**.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 动态音轨是根据游戏中玩家发生的情况而变化的音轨，音乐上反映了角色的冒险地点或时刻。在这个配方中，我们将实现一个音轨，它将改变两次；第一次是在进入隧道时，第二次是在出来时。为了实现这一点，我们将使用**音频混音器**的**快照**功能。
- en: Snapshots are a way of saving the state of your **Audio Mixer**, keeping your
    preferences for volume levels, audio effects, and more. We can access these states
    through C# scripting, creating transitions between mixes, and by bringing up the
    desired sonic ambience for each moment of the player's journey.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 快照是一种保存您的**音频混音器**状态的方法，保留音量级别、音频效果等的偏好设置。我们可以通过C#脚本访问这些状态，创建混音之间的过渡，并为玩家旅程的每个时刻提供所需的音效氛围。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we have prepared a basic game level, contained inside the
    Unity package named `DynamicSoundtrack`, and two soundtrack audio clips in the `.ogg`
    format: `Theme01_Percussion` and `Theme01_Synths`. All these files can be found
    in the `04_11` folder.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个基本的游戏关卡，包含在名为`DynamicSoundtrack`的Unity包中，以及两个`.ogg`格式的音轨音频剪辑：`Theme01_Percussion`和`Theme01_Synths`。所有这些文件都可以在`04_11`文件夹中找到。
- en: How to do it...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make a dynamic soundtrack, follow these steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作动态音轨，请遵循以下步骤：
- en: Create a new Unity 3D project.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: Import the provided Unity package, DynamicSoundtrack, and the two `.ogg` files
    into your project.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的Unity包DynamicSoundtrack以及两个`.ogg`文件导入到您的项目中。
- en: Open the Dynamic scene from **Project** panel folder, DynamicSoundtrack | _Scenes.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板文件夹打开Dynamic场景，DynamicSoundtrack | _Scenes。
- en: In the Project panel, use the Create menu to add an Audio Mixer file. Rename
    this new file Mixer-music. Double-click it to open the Audio Mixer panel.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，使用创建菜单添加一个音频混音器文件。将此新文件重命名为Mixer-music。双击它以打开音频混音器面板。
- en: 'In the the Audio Mixer panel Groups section, highlight Master and click the
    + (plus) sign to add a child to the Master group. Name this child Percussion.
    Repeat these actions to add a second child of Master, named Synths:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在音频混音器面板的组部分，突出显示主组并单击+（加号）以向主组添加子项。将此子项命名为Percussion。重复这些操作以向主组添加第二个子项，命名为Synths：
- en: '![](img/ce937ba3-ebb4-43d9-b076-7c6734a3f936.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce937ba3-ebb4-43d9-b076-7c6734a3f936.png)'
- en: From the **Hierarchy** view, create a new **Empty** GameObject. Name it Music.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中创建一个新的**空**GameObject。将其命名为Music。
- en: Create a GameObject in the scene containing an **AudioSource** component linked
    to the Theme01_Percussion **AudioClip**. This can be done in a single step by
    dragging the music clip from the Project panel into either the **Hierarchy** or
    Scene panels. Child this new GameObject to the **Music** GameObject in the **Hierarchy**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个包含**AudioSource**组件的GameObject，该组件链接到Theme01_Percussion **AudioClip**。这可以通过将音乐剪辑从项目面板拖动到**层次结构**或场景面板的单一步骤完成。将此新GameObject作为子对象添加到**Music**GameObject的**层次结构**中。
- en: 'Ensure the Theme01_Percussion GameObject is selected in the **Hierarchy**.
    In the Inspector for the **AudioSource** component, change its Output to Percussion
    (**MusicMixer**), make sure the **Play On Awake** option is checked, check the
    **Loop** option, and make sure its **Spatial Blend** is set to 2D:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了Theme01_Percussion游戏对象。在**音频源**组件的检查器中，将输出更改为Percussion（**音乐混合器**），确保**唤醒时播放**选项被选中，选中**循环**选项，并确保其**空间混合**设置为2D：
- en: '![](img/bc2c2792-bde9-4a45-a330-ca278dc289f1.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc2c2792-bde9-4a45-a330-ca278dc289f1.png)'
- en: Repeat the previous two steps for the Theme01_Synths **AudioClip** – setting
    the **Output** to Synths (**MusicMixer**).
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Theme01_Synths的**AudioClip**重复前两个步骤——将**输出**设置为Synths（**音乐混合器**）。
- en: 'Open the **Audio Mixer** and play the scene. We will now use the mixer to set
    the soundtrack for the start of the scene. With the scene playing, click on the
    **Edit** in Play Mode button, as shown in the screenshot, at the top of the **Audio
    Mixer**. Drop the volume on the **Synths** track down to **-30 dB**:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**音频混合器**并播放场景。我们现在将使用混合器为场景的开始设置音轨。在场景播放时，点击**音频混合器**顶部的**编辑**在播放模式按钮，如图所示。将**合成器**轨道的音量降低到**-30
    dB**：
- en: '![](img/fa270b68-b74b-450d-80ab-68824bd8e401.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa270b68-b74b-450d-80ab-68824bd8e401.png)'
- en: 'Select the Percussion track. Click the Add.. button for **Attenuation**, and
    add a **High-pass** effect. From the **Inspector** view, change the **Cutoff**
    frequency of the **High-pass** effect to **544.00 Hz**:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择打击乐轨道。点击**衰减**的添加..按钮，并添加一个**高通**效果。从**检查器**视图，将**高通**效果的**截止**频率更改为**544.00
    Hz**：
- en: '![](img/c15d7736-a7f2-466f-ab6c-3146f255afd3.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c15d7736-a7f2-466f-ab6c-3146f255afd3.png)'
- en: 'Every change, so far, has been assigned to the current Snapshot. From the Snaphots
    view, right-click on the current Snapshot and rename it to Start. Click the +
    (plus) sign to make a copy of the current snapshot, rename this copy Tunnel:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止的每一次更改，都分配给了当前的快照。从快照视图，在当前快照上右键单击并重命名为Start。点击+（加号）符号以复制当前快照，并将此副本重命名为Tunnel：
- en: '![](img/7adeff53-424e-4a1d-8e8f-e1d64ea92857.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7adeff53-424e-4a1d-8e8f-e1d64ea92857.png)'
- en: 'Select the **Tunnel** snapshot and select the **High-pass** effect of the Percussion
    group. In the Inspector, set property **Cutoff frequency** of **10.00** Hz:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**隧道**快照，并选择打击乐组的**高通**效果。在检查器中，将**截止频率**设置为**10.00** Hz：
- en: '![](img/0b25d80c-50cc-4fe4-bc07-db9ae098fe53.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b25d80c-50cc-4fe4-bc07-db9ae098fe53.png)'
- en: Switch between the **Tunnel** and Start snapshots. You'll be able to hear the
    difference.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**隧道**和**开始**快照之间切换。你将能够听到差异。
- en: Duplicate the **Tunnel** snapshot, rename it **OtherSide**, and select it.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**隧道**快照，将其重命名为**OtherSide**，并选择它。
- en: Raise the volume of the **Synths** track up to 0 dB.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**合成器**轨道的音量提升到0 dB。
- en: Now that we have our three **Snapshots**, it's time to create triggers to make
    transitions among them.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了三个**快照**，是时候创建触发器以在它们之间进行转换了。
- en: Stop running the scene (so changes to the **Hierarchy** will be stored in the
    scene).
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止运行场景（以便将**层次结构**中的更改存储到场景中）。
- en: 'In the **Hierarchy**, create a **Cube** GameObject (menu: **Create** | **3D
    Object** | **Cube**). Name it Cube-tunnel-trigger.'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中创建一个**Cube**游戏对象（菜单：**创建** | **3D对象** | **立方体**）。将其命名为Cube-tunnel-trigger。
- en: 'In the Inspector, access the Cube-tunnel-trigger GameObject''s Box Collider
    component and check the **Is Trigger** option. Uncheck its **Mesh Renderer** component.
    Adjust its size and position to the scene tunnel''s interior. You may find Scene
    Wireframe view useful for the cube collider positioning:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，访问Cube-tunnel-trigger游戏对象的Box Collider组件，并检查**是触发器**选项。取消选中其**网格渲染器**组件。调整其大小和位置以适应场景隧道内部。你可能发现场景线框视图对立方体碰撞器的定位很有用：
- en: '![](img/a23204bd-a7d1-470e-ad44-2a000deabb13.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a23204bd-a7d1-470e-ad44-2a000deabb13.png)'
- en: 'Make two copies of cube Cube-tunnel-trigger and rename them to cube Cube-start-trigger
    and cube Cube-otherside-trigger. Adjust their size and position, so that they
    occupy the areas before the tunnel''s entrance (where the character is) and after
    its exit:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体**Cube-tunnel-trigger**复制两次，并将它们重命名为**cube Cube-start-trigger**和**cube Cube-otherside-trigger**。调整它们的大小和位置，使它们占据隧道入口（人物所在的位置）和出口之后的空间：
- en: '![](img/98f42182-da98-42a3-b7e3-181c33041b26.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98f42182-da98-42a3-b7e3-181c33041b26.png)'
- en: 'Create a C# script class, `SnapshotTrigger`, in the _Scripts folder, containing
    the following code:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在_Scripts文件夹中创建一个C#脚本类，`SnapshotTrigger`，包含以下代码：
- en: '[PRE16]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add an instance of `SnapshotTrigger` to all three trigger cubes (Cube-tunnel-trigger,
    Cube-start-trigger, and Cube-otherside-trigger).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SnapshotTrigger`实例添加到所有三个触发立方体（隧道触发立方体、起点触发立方体和另一侧触发立方体）。
- en: 'Select Cube-tunnel-trigger. From the **Inspector** for the Snapshot Trigger
    (Script) component, set Snapshot to **Tunnel**, and **Crossfade** as 2:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**隧道触发立方体**。从**快照触发器（脚本）组件的**检查器中，将快照设置为**隧道**，并将**交叉淡入**设置为2：
- en: '![](img/9ab0df2e-e1ac-44f5-bf68-3f45524941ef.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ab0df2e-e1ac-44f5-bf68-3f45524941ef.png)'
- en: Make changes to **Cube-start-trigger** and **Cube-otherside-trigger** by setting
    their **Snapshots** to **Start** and **OtherSide**, respectively – also with **Crossfade**
    as `2`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将它们的**快照**分别设置为**开始**和**另一侧**来更改**起点触发立方体**和**另一侧触发立方体**，同时将**交叉淡入**设置为`2`。
- en: Test the scene. The background music will change as the character moves from
    the starting point, through the tunnel, and out the other side.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试场景。背景音乐将在角色从起点移动到隧道，然后从另一侧出来时改变。
- en: How it works...
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Snapshot feature allows you to save **Audio Mixer** states (including all
    volume levels and every filter setting) so that you can change those mixing preferences
    at **Run-Time**, making the audio design more suitable for specific locations
    or gameplay settings. For this recipe, we have created three **Snapshots** for
    different moments in the player''s journey:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 快照功能允许你保存**音频混音器**状态（包括所有音量级别和每个滤波器设置），这样你就可以在**运行时**更改这些混音偏好，使音频设计更适合特定的位置或游戏设置。对于这个菜谱，我们为玩家旅程中的不同时刻创建了三个**快照**：
- en: Before entering the tunnel
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进入隧道之前
- en: Inside the tunnel
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隧道内
- en: Outside the tunnel
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隧道外
- en: We have used the **Highpass** filter to make the initial **Snapshot** less intense.
    We have also turned the Synths track volume up to emphasize the open environment
    outside the tunnel. Our aim is for the changes in the audio mix to help set the
    right mood for the game.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了**高通**滤波器来使初始**快照**不那么强烈。我们还提高了合成音轨的音量，以强调隧道外的开阔环境。我们的目标是让音频混音的变化帮助为游戏设定正确的氛围。
- en: To activate our snapshots, we have placed **trigger** colliders, featuring our
    **Snapshot Trigger** scripted component in which we set the desired Snapshot and
    the time in seconds, that it takes to make the transition (a crossfade) between
    the previous Snapshot and the next. In fact, the function in our script is really
    this straightforward – the line of `snapshot.TransitionTo (crossfade)` code simply
    starts a transition lasting `crossfade` seconds to the desired Snapshot.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活我们的快照，我们放置了**触发**碰撞体，其中包含我们的**快照触发器**脚本组件，我们设置了所需的快照和过渡（交叉淡入）到下一个快照所需的时间（秒）。实际上，我们脚本中的功能非常直接——`snapshot.TransitionTo(crossfade)`代码行简单地开始一个持续`crossfade`秒的过渡到所需的快照。
- en: There's more...
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here is some information on how to fine-tune and customize this recipe.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于如何微调和自定义这个菜谱的信息。
- en: Reducing the need for multiple audio clips
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少对多个音频剪辑的需求
- en: You might have noticed how different the `Theme01_Percussion` audio clip sounds
    when the **Cutoff frequency** of the **High-pass** filter is set as `10.00 Hz`.
    This is because the high-pass filter, as its name suggests, cuts off lower frequencies
    of the audio signal. In this case, it attenuated the bass drum down to inaudible
    levels while keeping the shakers audible. The opposite effect can be achieved
    through the **Lowpass** filter. A major benefit is
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当**高通滤波器的截止频率**设置为`10.00 Hz`时，`Theme01_Percussion`音频剪辑听起来有多么不同。这是因为高通滤波器，正如其名称所暗示的，切断了音频信号的较低频率。在这种情况下，它将低音鼓衰减到不可听见的水平，同时保持摇铃可听。通过**低通滤波器**可以达到相反的效果。一个主要的好处是
- en: the opportunity to have two separate tracks in the same audio clip.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个音频剪辑中拥有两个独立音轨的机会。
- en: Dealing with audio file formats and compression rates
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理音频文件格式和压缩率
- en: To avoid a loss of audio quality, you should import your sound clips using the
    appropriate file format, depending upon your target platform. If you are not sure
    which format to use, check out Unity's documentation on the subject at [http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免音频质量下降，你应该使用适合目标平台的适当文件格式导入你的声音剪辑。如果你不确定使用哪种格式，请查看Unity关于此主题的文档，链接为[http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html)。
- en: Applying Snapshots to background noise
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将快照应用于背景噪声
- en: Although we have applied Snapshots to our music soundtrack, background noise
    can also benefit immensely. If your character travels across places that are significantly
    different, transitioning from open spaces to indoor environments, you should consider
    applying snapshots to your environment audio mix. Be careful, however, to create
    separate **Audio Mixers** for Music and Environment – unless you don't mind having
    musical and ambient
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经将快照应用到我们的音乐音轨上，背景噪音也可以受益匪浅。如果你的角色穿越了显著不同的地方，从开阔空间过渡到室内环境，你应该考虑将快照应用到你的环境音频混音中。但是，请注意为音乐和环境创建单独的**音频混音器**——除非你不在乎音乐和环境的混音。
- en: sound tied to the same Snapshot.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 与同一快照绑定的声音
- en: Getting creative with effects
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用效果进行创意
- en: In this recipe, we have mentioned the High-pass and Low-pass filters. However,
    there are many effects that can make audio clips sound radically different. Experiment!
    Try applying effects such as Distortion, Flange, and Chorus. In fact, we encourage
    you to try every effect, playing with their settings. The creative use of these
    effects can bring out different expressions to a single audio clip.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们提到了高通和低通滤波器。然而，有许多效果可以使音频片段听起来截然不同。实验吧！尝试应用如失真、镶边和合唱等效果。实际上，我们鼓励你尝试每一个效果，玩转它们的设置。这些效果的创意使用可以为单个音频片段带来不同的表现。
- en: See also
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding volume control with Audio Mixers* recipe in this chapter.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的**添加音量控制与音频混音器**菜谱。
- en: The *Balancing soundtrack volume with Ducking* recipe in this chapter.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的**平衡音轨音量与Ducking**菜谱。
- en: Balancing in-game audio with Ducking
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ducking平衡游戏内音频
- en: As much as the background music can be important in establishing the right atmosphere,
    there will be times when other audio clips should be emphasized, and the music
    volume turned down for the duration of that clip. This effect is known as **Ducking**.
    Maybe you will need it for dramatic effect (simulating hearing loss after an explosion
    took place), or maybe you want to make sure that the player listens to a specific
    bit of information presented as an audio speed sound clip. In this recipe, we
    will learn how to emphasize a piece of dialog by ducking the audio whenever a
    specific sound message is played. For that effect, we will use the **Audio Mixer**
    to send information between tracks.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 背景音乐在建立正确氛围方面可能很重要，但有时其他音频片段应该被强调，音乐音量在片段播放期间降低。这种效果被称为** ducking**。你可能需要它来产生戏剧效果（模拟爆炸发生后听力受损），或者你可能想确保玩家听到作为音频速度剪辑呈现的特定信息。在这个菜谱中，我们将学习如何在播放特定声音消息时通过ducking来强调一段对话。为了达到这种效果，我们将使用**音频混音器**在轨道之间传递信息。
- en: Getting ready
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided the `soundtrack.mp3` audio clip and a Unity
    package named Ducking.unitypackage, containing an initial scene. All these files
    are available inside the `04_12` folder.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们提供了`soundtrack.mp3`音频剪辑和一个名为Ducking.unitypackage的Unity包，其中包含一个初始场景。所有这些文件都位于`04_12`文件夹内。
- en: How to do it...
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply Audio Ducking to your soundtrack, follow these steps:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要将音频Ducking应用到你的音轨上，请按照以下步骤操作：
- en: Create a new **Unity 3D** project.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**Unity 3D**项目。
- en: Import the provided **Unity** package,**Ducking**, and the `soundtrack.mp3`
    file into your project.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的**Unity**包**Ducking**和`soundtrack.mp3`文件导入到你的项目中。
- en: Open the Ducking scene from **Project** panel folder, **Ducking** | `_Scenes`.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板文件夹中打开Ducking场景，**Ducking** | `_Scenes`。
- en: Enter Run-Time by playing the scene and walk toward the semitransparent green
    wall in the tunnel, using the *W, A, S,* and *D* keys (by pressing *Shift* to
    run). You will hear the robotDucking speech audio clip play as the character collides
    with the green wall ("This your captain speaking ..."). Then stop the scene playing
    to return to Design-Time.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过播放场景并使用*W、A、S*和*D*键（按*Shift*键跑步）进入运行时，走向隧道中半透明的绿色墙。当角色与绿色墙碰撞时，你会听到机器人Ducking语音音频剪辑播放（“这是你的船长在说话...”）。然后停止场景播放以返回设计时。
- en: Create a **GameObject** in the scene containing an **AudioSource** component
    linked to the soundtrack **AudioClip**. This can be done in a single step by dragging
    the music clip from the **Project** panel into either the **Hierarchy** or **Scene**
    panels.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个**GameObject**，其中包含一个与音轨**AudioClip**链接的**AudioSource**组件。这可以通过将音乐剪辑从**项目**面板拖动到**层次结构**或**场景**面板来完成。
- en: Ensure the GameObject soundtrack is selected in the **Hierarchy**. In the **Inspector**
    for the **Audio Source** component, make sure the Play On Awake option is checked,
    check the Loop option, and make sure its **Spatial Blend** is set to 2D (if necessary,
    see screenshot in the previous recipe for same action on the percussion GameObject).
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择GameObject音轨。在**检查器**中，对于**音频源**组件，确保已勾选**唤醒时播放**选项，勾选**循环**选项，并确保其**空间混合**设置为2D（如果需要，请参阅前一个菜谱中关于打击乐器GameObject相同操作的截图）。
- en: Play the scene again. The soundtrack music should be playing. Then stop the
    scene playing to return to **Design-Time**.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放场景。音轨音乐应该正在播放。然后停止场景播放以返回到**设计时间**。
- en: In the **Project** panel, use the **Create** menu to add an **Audio Mixer**
    file. Rename this new file **MainMixer**.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，使用**创建**菜单添加一个**音频混音器**文件。将这个新文件重命名为**MainMixer**。
- en: Double-click **MainMixer** to open the **Audio Mixer** panel.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**MainMixer**以打开**音频混音器**面板。
- en: 'In the the **Audio Mixer** panel Groups section, highlight **Master** and click
    the + (plus) sign to add a child to the **Master** group. Name this child Music.
    Repeat these actions to add a second child of Master, named FX. Add a third child
    to the **Master** group, named Input:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频混音器**面板的**组**部分，高亮显示**主**并点击+（加号）来向**主**组添加一个子项。将此子项命名为音乐。重复这些操作以添加主组的第二个子项，命名为FX。向**主**组添加第三个子项，命名为输入：
- en: '![](img/51d8ac5b-84a1-4b63-b141-44ca6296f723.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51d8ac5b-84a1-4b63-b141-44ca6296f723.png)'
- en: 'In the Audio Mixers view, add a new **Mixer** by clicking the + (plus) sign
    to add a new **Mixer** to the project. Name it **MusicMixer**. Drag it into the
    **MainMixer** (to become its child) and select the Music group as its Output:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在音频混音器视图中，通过点击+（加号）来添加一个新的**混音器**，将一个新的**混音器**添加到项目中。将其命名为**MusicMixer**。将其拖入**MainMixer**（成为其子项）并选择**音乐**组作为其输出：
- en: '![](img/68ad76d8-b80d-4153-b6f2-d8c360d9e46e.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68ad76d8-b80d-4153-b6f2-d8c360d9e46e.png)'
- en: Repeat the previous step to add another child of **MainMixer**, named **FxMixer**,
    to the project, selecting the FX group as the output.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一步，将另一个名为**FxMixer**的子项添加到项目中，选择FX组作为输出。
- en: 'Select **MusicMixer**. Select its **Master** group and add a child named `Soundtrack`:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**MusicMixer**。选择其**主**组并添加一个名为`Soundtrack`的子项：
- en: '![](img/2cd38a48-a015-46ba-a2d4-2acdf2c61858.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cd38a48-a015-46ba-a2d4-2acdf2c61858.png)'
- en: Select **FxMixer** and add a child named **Bells**.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**FxMixer**并添加一个名为**Bells**的子项。
- en: 'From the **Hierarchy** view, select the **DialogueTrigger GameObject**. In
    the **Inspector**, change the Output track to **MainMixer** | **Input**, for the **Audio
    Source** component:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择**DialogueTrigger GameObject**。在**检查器**中，将输出轨道更改为**MainMixer**
    | **输入**，对于**音频源**组件：
- en: '![](img/865c010c-bab9-49db-9a42-17ca978e8453.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/865c010c-bab9-49db-9a42-17ca978e8453.png)'
- en: Select the **Soundtrack** GameObject. In the **Inspector** for the **Audio**
    **Sourc**e component, change its Output track to **MusicMixer** | **Soundtrack**.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Soundtrack** GameObject。在**检查器**中，对于**音频** **源**组件，将其输出轨道更改为**MusicMixer**
    | **Soundtrack**。
- en: From the **Ducking** | **Prefabs** folder in the Project panel, select the Signal
    prefab. In the Inspector, set its **Audio Source** component **Output** to **FxMixer**
    | **Bells**.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中的**降低音量** | **预制件**文件夹中选择信号预制件。在**检查器**中，将其**音频源**组件**输出**设置为**FxMixer**
    | **Bells**。
- en: 'Open the **Audio Mixer** window. Choose **MainMixer**, select the Music track
    controller, right-click on **Attenuation**, and using the context menu, add the
    **Duck Volume** effect:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**音频混音器**窗口。选择**MainMixer**，选择音乐轨道控制器，右键点击**衰减**，并使用上下文菜单，添加**降低音量**效果：
- en: '![](img/25a69c10-a7ae-4764-8e71-4ce0aeae78da.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25a69c10-a7ae-4764-8e71-4ce0aeae78da.png)'
- en: Select the Input track, right-click on **Attenuation**, and using the context
    menu, add **Send**.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输入轨道，右键点击**衰减**，并使用上下文菜单，添加**发送**。
- en: With the Input track still selected, go to the **Inspector** view and change
    the Receive setting in **Send** to **Music\Duck** Volume and its **Send** level
    to 0.00 db.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择输入轨道的情况下，转到**检查器**视图，并将**发送**中的接收设置更改为**音乐\降低音量**，并将其**发送**级别设置为0.00 db。
- en: 'Select the **Music** track. From the Inspector view, change the settings on
    the **Duck Volume** as follows: **Threshold**: `-``40.00 db`, **Ratio**: `300.00%`, **Attack**
    **Time**: `100.00 ms`, **Release Time**: `200.00 ms`:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**音乐**轨道。从**检查器**视图，按照以下方式更改**降低音量**的设置：**阈值**：`-40.00 db`，**比率**：`300.00%`，**攻击时间**：`100.00
    ms`，**释放时间**：`200.00 ms`：
- en: '![](img/3a0ca160-25e9-43c5-a513-b028d1bf447c.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a0ca160-25e9-43c5-a513-b028d1bf447c.png)'
- en: Test the scene again. Entering the trigger object will cause the soundtrack
    volume to drop considerably, recovering the original volume in two seconds.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次测试场景。进入触发对象将导致配乐音量显著降低，两秒后恢复到原始音量。
- en: How it works...
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have created, in addition to Music and Sound FX, a group
    named Input, to which we have routed the audio clip that triggers the Duck Volume
    effect attached to our music track. The Duck Volume effect changes the track's
    volume whenever it receives an input that is louder than indicated in its Threshold
    setting. In our case, we have sent the Input track as input, and adjusted the
    settings so the volume will be reduced as soon as 0.1 seconds after the input
    had been received, turning back to its original value of 2 seconds after the input
    has ceased. The amount of volume reduction was determined by our Ratio of 300.00%.
    Playing around with the setting values will give you a better idea of how each
    parameter affects the final result. Also, make sure to visualize the graphic as
    the trigger sound is played. You will be able to see how the Input sound passes
    the threshold, triggering the effect.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，除了音乐和音效之外，我们还创建了一个名为“输入”的组，我们将触发鸭音量效果的音频剪辑路由到我们的音乐轨道。鸭音量效果会在接收到比其阈值设置更响亮的输入时改变轨道的音量。在我们的情况下，我们将输入轨道作为输入，并调整设置，以便在接收到输入后的0.1秒内降低音量，在输入停止后的2秒后恢复到原始值。音量降低的量由我们的300.00%比率确定。调整设置值将更好地了解每个参数对最终结果的影响。此外，确保在触发声音播放时可视化图形。您将能够看到输入声音如何通过阈值，触发效果。
- en: The tracks are organized so that the other sound clips (other than speech) will
    not affect the volume of the music – but every music clip will be affected by
    audio clips sent to the input track.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道组织得很好，其他声音剪辑（除语音外）不会影响音乐的音量——但每个音乐剪辑都会受到发送到输入轨道的音频剪辑的影响。
- en: See also
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding volume control with Audio Mixers* recipe in this chapter.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的*使用音频混音器添加音量控制*菜谱。
- en: The *Making a dynamic soundtrack with Snapshots* recipe in this chapter.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的*使用快照制作动态配乐*菜谱。
- en: Audio visualization from sample spectral data
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从样本频谱数据中进行的音频可视化
- en: The Unity audio systems allows us to access the music data – via the `AudioSource.GetSpectrumData(...)`
    method. This gives us the opportunity to use that data to present Run-Time visualization
    of the overall sound being heard (from the **AudioListener**), or the individual
    sound being played by individual **AudioSources**.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Unity音频系统允许我们通过`AudioSource.GetSpectrumData(...)`方法访问音乐数据——这给了我们使用这些数据来展示所听到的整体声音的运行时可视化（来自**AudioListener**），或者由单个**AudioSources**播放的个别声音。
- en: 'The screenshot shows lines drawn using a sample script provided by Unity ([https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html](https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html)):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了使用Unity提供的示例脚本绘制的线条([https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html](https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html))：
- en: '![](img/09aa10c3-5f54-420d-a202-25edf5fcf4a6.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09aa10c3-5f54-420d-a202-25edf5fcf4a6.png)'
- en: However, in that sample code, their use of `Debug.DrawLine()` only appears in
    the Scene panel when running the game in the Unity Editor (not for final builds),
    and so cannot be seen by the game player. In this recipe, we'll take that same
    spectral data, and use it to create a **Run-Time** audio spectral visualization
    in the Game panel. We'll do this by creating a row of 512 small cubes, and then
    changing their heights each frame based on 512 audio data samples for the playing
    **AudioSource** component.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在那段示例代码中，他们使用`Debug.DrawLine()`只会在在Unity编辑器中运行游戏时（不是最终构建）出现在场景面板中，因此游戏玩家看不到。在这个菜谱中，我们将使用相同的频谱数据，并在游戏面板中创建一个**运行时**音频频谱可视化。我们将通过创建一排512个小立方体来实现这一点，然后根据播放的**AudioSource**组件的512个音频数据样本在每个帧中改变它们的高度。
- en: Getting ready
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided several 140 bmp sampled free music clips inside
    the `04_13` folder.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`04_13`文件夹中提供了几个140 bmp采样免费音乐剪辑。
- en: How to do it...
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To schedule a sound to play after a given delay, do the following:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 要安排在给定延迟后播放声音，请执行以下操作：
- en: Create a new 3D project and import the provided sound clip files.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目并导入提供的音频剪辑文件。
- en: In the Inspector, set the Background of the Main Camera to black.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将主相机的背景设置为黑色。
- en: Set the Main Camera Transform Position to (224, 50, -200).
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主相机变换位置设置为（224，50，-200）。
- en: 'Set the Main Camera Camera component to have these settings: Projection = Perspective,
    Field of View 60, and Clipping Planes 0.3 - 300.'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主摄像机 Camera 组件的设置设置为：投影 = 透视，视场角 60，裁剪平面 0.3 - 300。
- en: Add **DirectionalLight** to the scene.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **DirectionalLight** 添加到场景中。
- en: Add a new empty GameObject named visualizer to the scene. Add an **AudioSource**
    component to this GameObject, and set its **AudioClip** to one of the 140 bmp
    loops provided.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的空 GameObject，命名为 visualizer。向此 GameObject 添加 **AudioSource** 组件，并将其
    **AudioClip** 设置为提供的 140 个 bmp 循环之一。
- en: 'Create a C# script class, **SpectrumCubes**, in a new folder, _Scripts, containing
    the following code, and add an instance as a scripted component to the visualizer
    GameObject:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的文件夹 _Scripts 中创建一个 C# 脚本类，**SpectrumCubes**，包含以下代码，并将其作为脚本组件添加到 visualizer
    GameObject 中：
- en: '[PRE17]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the visualizer GameObject selected in the **Hierarchy**, click to choose
    a visualization color from the **Inspector Display Color** public variable for
    the **SpectrumCubes** (Script) component.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中选择 **visualizer** GameObject，点击从 **Inspector Display Color**
    公共变量中选择一个可视化颜色用于 **SpectrumCubes** (脚本) 组件。
- en: Run the scene – you should see the cubes jump up and down, presenting a Run-Time
    visualization of the sound data spectrum for the playing sound.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景——您应该看到立方体上下跳动，展示正在播放的声音的音谱的运行时可视化。
- en: How it works...
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a C# script class, `SpectrumCubes`. You created a GameObject with
    an **AudioSource** component, and an instance of your scripted class. All the
    work is done by the methods in the `SpectrumCues` C# script class, so each of
    these is explained in the following sections.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个 C# 脚本类 `SpectrumCubes`。您创建了一个具有 **AudioSource** 组件的 GameObject，以及您脚本类的实例。所有工作都是由
    `SpectrumCubes` C# 脚本类中的方法完成的，所以以下各节将解释这些方法。
- en: The void Awake() method
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: void Awake() 方法
- en: This method caches references to the sibling **AudioSource** component, and
    then invokes the `CreateCubes()` method.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法缓存了对同级 **AudioSource** 组件的引用，然后调用 `CreateCubes()` 方法。
- en: The void CreateCubes() method
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: void CreateCubes() 方法
- en: This method loops for the number of samples (default is 512), to create a 3D
    Cube GameObject, in a row along the X-axis. Each Cube is created with the name
    "Cube<i>" (where "i" is from 0 to 511) and then parented to the visualizer GameObject (since
    the scripted method is running in this GameObject). Each cube then has the color
    of its renderer set to the value of the public displayColor parameter. The cube
    is then positioned on the X-axis according to the loop number, at the value of
    the public startY parameter (so multiple visualizations can be at different parts
    of the screen), and Z = 0\. Finally, a reference to the new cube GameObject is
    stored in the cubes[] array.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法循环样本数量（默认为 512），沿 X 轴创建一个 3D 立方体 GameObject，逐行排列。每个立方体以 "Cube<i>"（其中 "i"
    从 0 到 511）命名，然后将其作为父对象添加到 visualizer GameObject（因为脚本方法在此 GameObject 中运行）。然后，每个立方体的渲染器颜色设置为公共
    displayColor 参数的值。然后，立方体根据循环次数在 X 轴上定位，位置值为公共 startY 参数（因此多个可视化可以位于屏幕的不同部分），Z
    = 0。最后，将新立方体 GameObject 的引用存储在 cubes[] 数组中。
- en: The void Update() method
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: void Update() 方法
- en: Each frame in this method updates the values inside the spectrum[] array through
    a call to `GetSpectrumData(...)`. In our example, the `FFTWindow.BlackmanHarris`
    frequency window technique is used. Then the `UpdateCubeHeights()` method is invoked.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法中的每一帧通过调用 `GetSpectrumData(...)` 更新 `spectrum[]` 数组中的值。在我们的示例中，使用了 `FFTWindow.BlackmanHarris`
    频率窗口技术。然后调用 `UpdateCubeHeights()` 方法。
- en: The void UpdateCubeHeights() method
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: void UpdateCubeHeights() 方法
- en: This method loops for each cube to set its height to a scaled value of its corresponding
    audio data value in the `spectrum[]` array. The cube has its Y-value scaled by
    the value returned by the `HeightFromSample(spectrum[i])` method. The cube is
    then moved up (its transform position is set) from the value of `startY` by half
    its height – so that all the scaling appears upwards (rather than up and down) –
    this is to have a flat line along the base of our spectrum of cubes.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法循环每个立方体，将其高度设置为对应于 `spectrum[]` 数组中音频数据值的缩放值。立方体的 Y 值通过 `HeightFromSample(spectrum[i])`
    方法返回的值进行缩放。然后，立方体从 `startY` 的值向上移动（其变换位置被设置），移动距离为其高度的一半——这样所有的缩放都会向上（而不是上下）进行——这是为了使我们的立方体光谱的底部保持平坦的线条。
- en: The float HeightFromSample(float) method
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: float HeightFromSample(float) 方法
- en: Method  `HeightFromSample(float)` does a simple calculation (sample value times
    public parameter multiplier), plus minimum value of two added to it. The value
    returned from the function is this result, limited to the maxHeight public parameter (via
    the `Mathf.Clamp(...)` method).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `HeightFromSample(float)` 进行简单的计算（样本值乘以公共参数乘数），然后加上两个最小值之和。函数返回的值是此结果，限制在`maxHeight`公共参数内（通过`Mathf.Clamp(...)`方法）。
- en: There's more...
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are some details that you don't want to miss.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不希望错过。
- en: Adding visualizations to a second AudioSource
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向第二个AudioSource添加可视化
- en: 'The script has been written to be easy to have multiple visualizations in a
    scene. So to create a second visualizer for a second **AudioClip** in the scene,
    do the following:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写得很容易在场景中添加多个可视化。因此，为了在场景中为第二个**AudioClip**创建第二个可视化器，请执行以下操作：
- en: Duplicate the visualizer GameObject.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制可视化GameObject。
- en: Drag a different AudioClip from the **Project** panel into the **Audio Source**
    component of your new GameObject.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将不同的AudioClip从**项目**面板拖动到新GameObject的**音频源**组件中。
- en: Set the Start **Y** public parameter in the **Inspector** to 60 (so the new
    row of cubes will be above the original row).
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**检查器**中的起始**Y**公共参数设置为60（这样新的一行立方体将位于原始行上方）。
- en: 'In the **Inspector**, choose a different Display Color public variable for
    the **SpectrumCubes (Script)** component:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，为**SpectrumCubes (脚本)**组件选择不同的显示颜色公共变量：
- en: '![](img/987f9d56-391c-4727-aa15-b530eaaa2ad9.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/987f9d56-391c-4727-aa15-b530eaaa2ad9.png)'
- en: Try out different FFT (Fast Fourier Transform) window types
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试不同的FFT（快速傅里叶变换）窗口类型
- en: There are several different approaches to frequency analysis of audio data,
    our recipe currently uses the `FFTWindow.BlackmanHarris` version. Learn (and try
    out!) some of the others from the Unity `FFTWindow` documentation page: [https://docs.unity3d.com/ScriptReference/FFTWindow.html](https://docs.unity3d.com/ScriptReference/FFTWindow.html).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音频数据的频率分析，有几种不同的方法，我们的食谱目前使用的是`FFTWindow.BlackmanHarris`版本。从Unity的`FFTWindow`文档页面（[https://docs.unity3d.com/ScriptReference/FFTWindow.html](https://docs.unity3d.com/ScriptReference/FFTWindow.html)）学习（并尝试！）一些其他方法。
- en: Synchronizing simultaneous and sequential music to create a simple 140 bpm music-loop
    manager
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步同时和顺序音乐以创建简单的140 bpm音乐循环管理器
- en: The *Creating a metronome through the precise scheduling of sounds with* `dspTime` recipe
    demonstrated how to create a metronome by scheduling when sounds play using the `AudioSource.PlayScheduled(...)`
    method and the `AudioSettings.dspTime` value. Another situation when we need to
    precisely schedule audio start times is to ensure a smooth transition from one
    music track to another, or to ensure simultaneous music tracks play in time together.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精确调度声音使用`dspTime`食谱创建节拍器，展示了如何通过使用`AudioSource.PlayScheduled(...)`方法和`AudioSettings.dspTime`值来安排声音播放时间，创建节拍器。我们还需要精确调度音频开始时间的另一种情况是确保从一首音乐轨道平滑过渡到另一首，或者确保同时播放的音乐轨道同步进行。
- en: 'In this recipe, we''ll create a simple 4-track 140 bpm music manager that starts
    playing a new sound after a fixed time – the result of which is that the tracks
    fit together perfectly, and those that overlap do so in synchronicity:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个简单的4轨140 bpm音乐管理器，在固定时间后开始播放新的声音——结果是轨道完美匹配，重叠的部分同步进行：
- en: '![](img/47e24a71-b907-4ddf-9aab-99df2b36f208.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47e24a71-b907-4ddf-9aab-99df2b36f208.png)'
- en: Getting ready
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided several 140 bmp sampled free music clips inside
    the `04_14` folder.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`04_14`文件夹中提供了几个140 bmp采样免费音乐片段。
- en: How to do it...
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a music-loop manager, do the following:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个音乐循环管理器，请执行以下操作：
- en: Create a new Unity 3D project and import the provided sound clip files.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目并导入提供的音频剪辑文件。
- en: Create four GameObjects in the scene containing an **AudioSource** component
    linked to different **AudioClip** loops from the 140 bpm files provided. This
    can be done in a single step by dragging the music clip from the **Project** panel
    into either the **Hierarchy** or Scene panels.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建四个包含**AudioSource**组件的GameObject，这些组件连接到140 bpm文件提供的不同**AudioClip**循环。这可以通过从**项目**面板将音乐剪辑拖动到**层次结构**或场景面板的单步操作来完成。
- en: In the Inspector, uncheck the **Play On Awake** parameter for all four **AudioSource**
    components (so they don't start playing until we tell them to).
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，取消选中所有四个**AudioSource**组件的**在唤醒时播放**参数（这样它们就不会在我们告诉它们之前开始播放）。
- en: Add a new empty **GameObject** named **musicScheduler** to the scene.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个新的空**GameObject**，命名为**musicScheduler**。
- en: 'Create a C# script class, **LoopScheduler**, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the **musicScheduler**
    GameObject:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件夹 `_Scripts` 中创建一个C#脚本类 **LoopScheduler**，包含以下代码，并将其作为脚本组件添加到 **musicScheduler**
    GameObject 中：
- en: '[PRE18]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the **musicScheduler** GameObject selected in the **Hierarchy**, drag
    each of the music loop GameObjects into the four available slots for the **AudioSources**
    public array variable in the **Loop Scheduler (Script)** component:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中选择 **musicScheduler** GameObject，将每个音乐循环GameObject拖放到 **Loop
    Scheduler (Script)** 组件中 **AudioSources** 公共数组变量的四个可用槽位中：
- en: '![](img/7718015b-b831-4215-8b4f-8173a251bdea.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7718015b-b831-4215-8b4f-8173a251bdea.png)'
- en: Run the scene – each clips should start in turn after the same time delay. If
    you chose one or two longer clips, they will continue playing while the next clip
    begins – all overlapping perfectly since they are all 140 bpm sound clips.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景 - 每个剪辑应该依次在相同的时间延迟后开始。如果你选择了一个或两个较长的剪辑，它们将在下一个剪辑开始时继续播放 - 由于它们都是140 bpm的声音剪辑，所以它们会完美重叠。
- en: How it works...
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added four **GameObjects** to the scene, containing **AudioSources** linked
    to 140 bpm music clips. You created a C# script class, `LoopScheduler`, and added
    an instance to an empty **GameObject**. You associated the four **AudioSources**
    in your **GameObjects** with the four slots in the public **AudioSource** array
    variable in your scripted component.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你在场景中添加了四个包含与140 bpm音乐片段链接的 `AudioSources` 的 `GameObjects`。你创建了一个C#脚本类 `LoopScheduler`，并将其实例添加到一个空
    `GameObject` 中。你将你的 `GameObjects` 中的四个 `AudioSources` 与脚本组件中公共 `AudioSource` 数组变量的四个槽位关联起来。
- en: The numbers of music clips you use can easily be changed by changing the size
    of the public array variable.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的音乐剪辑的数量可以通过更改公共数组变量的大小来轻松更改。
- en: The `Start()` method counts the length of the array to set the `numLoops` variable.
    It then calculates the number of seconds to delay before starting each clip (this
    is fixed according to the beats-per-minute and beats-per-measure). Finally, it
    sets the current time to be the time to start the first loop.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法计算数组的长度以设置 `numLoops` 变量。然后它计算在开始每个剪辑之前需要延迟的秒数（这是根据每分钟节拍和每小节节拍固定的）。最后，它将当前时间设置为开始第一个循环的时间。'
- en: The `Update()` method decides whether it's time to schedule the next loop, by
    testing whether the current time plus a 1-second look-ahead, is past the time
    to start the next loop. If so, the `StartNextLoop()` method is invoked. Regardless
    of whether we have started the next loop, the `PrintLoopPlayingStatus()` method
    to display to the user which loops are playing or not is printed to the Console.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法决定是否是时候安排下一个循环，通过测试当前时间加上1秒前瞻是否超过了开始下一个循环的时间。如果是这样，就会调用 `StartNextLoop()`
    方法。无论我们是否已经开始下一个循环，都会调用 `PrintLoopPlayingStatus()` 方法将用户正在播放或未播放的循环显示到控制台。'
- en: The `PrintLoopPlayingStatus()` method loops for each **AudioSource** reference
    in the array, creating a string of trues and falses to be then printed out.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintLoopPlayingStatus()` 方法遍历数组中的每个 `AudioSource` 引用，创建一个包含真和假的字符串，然后将其打印出来。'
- en: The `StartNextLoop()` method sends a `PlayScheduled(...)` message to the next
    `AudioSource` to be played, passing the `nextEventTime` value. It then adds the
    time between plays for the next event time. The next value of the loop index is
    then calculated (add one, if past the end of the array, then reset to 0 again).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartNextLoop()` 方法向下一个要播放的 `AudioSource` 发送 `PlayScheduled(...)` 消息，传递 `nextEventTime`
    值。然后它为下一个事件时间添加播放之间的时间。然后计算下一个循环索引的下一个值（如果超过了数组的末尾，则加一，然后再次重置为0）。'
- en: There's more...
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节是你不想错过的。
- en: Adding visualizations to the four playing loops
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为正在播放的四个循环添加视觉呈现
- en: 'It''s great fun to watch the visualization of the loop sounds as they play
    together. To add visualizations to the four AudioSources, all you have to do is:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 观看循环声音的视觉呈现非常有趣。要为四个 `AudioSources` 添加视觉呈现，你只需要做以下几步：
- en: Import the **SpectrumCubes.cs** C# script file from the previous recipe into
    this project.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个菜谱中导入 **SpectrumCubes.cs** C# 脚本文件到这个项目中。
- en: Set the Main Camera Transform Position to (224, 50, -200).
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主相机的变换位置设置为 (224, 50, -200)。
- en: 'Set the **Main Camera Camera component** to have these settings: Projection
    = Perspective, Field of View 60, and Clipping Planes 0.3 - 300.'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主相机的相机组件设置为以下设置：投影 = 投影透视，视野 60，裁剪平面 0.3 - 300。
- en: Add a **Directional Light GameObject** to the scene.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个 **Directional Light GameObject**。
- en: For each of the four **GameObjects** containing your **AudioSources**, add an
    instance of the **SpectrumCubes** script class.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于包含你的**AudioSources**的每个四个**GameObjects**，添加一个Spectrum Cubes脚本类的实例。
- en: In the **Inspector** for the **Spectrum Cubes (Script)** component, change the
    displayColors for each **AudioSource GameObject**.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Spectrum Cubes (脚本)**组件的**检查器**中，更改每个**AudioSource GameObject**的显示颜色。
- en: 'Set the startY values of Spectrum Cubes (Script) components for the four **GameObjects**
    to be -50, 0, 50, 100\. For most screen sizes, this should allow you too see all
    four visualization spectrums:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个**GameObjects**组件的Spectrum Cubes（脚本）的起始Y值设置为-50、0、50、100。对于大多数屏幕尺寸，这应该允许你看到所有四个可视化光谱：
