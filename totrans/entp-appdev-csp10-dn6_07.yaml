- en: '*Chapter 5*: Dependency Injection in .NET 6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：.NET 6 中的依赖注入'
- en: A big issue that an enterprise application can face is the complexity of wiring
    different elements together and managing their lifetimes. To address this, we
    use the **inversion of control** (**IoC**) principle, which recommends removing
    the dependency between objects. By delegating the flow of control, IoC makes the
    program extensible and increases the modularity. Events, callback delegates, the
    observer pattern, and **dependency injection** (**DI**) are some of the ways to
    achieve IoC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序可能面临的一个大问题是将不同元素连接起来并管理它们的生命周期的复杂性。为了解决这个问题，我们使用 **控制反转**（**IoC**）原则，该原则建议移除对象之间的依赖关系。通过委派控制流，IoC
    使程序可扩展并增加了模块化。事件、回调委托、观察者模式和 **依赖注入**（**DI**）是实现 IoC 的几种方法。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: What is DI?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 DI？
- en: DI in ASP.NET Core 6
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 中的 DI
- en: Managing application services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序服务
- en: Using third-party containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: By the end of this chapter, you'll have a good idea about DI and how it's leveraged
    in .NET 6 applications, the types of scopes provided in ASP.NET Core 6, and how
    to leverage them in your projects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地了解 DI 以及它在 .NET 6 应用程序中的利用方式，ASP.NET Core 6 中提供的范围类型，以及如何在项目中利用它们。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code used in this chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在以下位置找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter05)。
- en: What is DI?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 DI？
- en: DI is a technique in which an object receives objects that it depends on. The
    DI pattern fulfills the DI principle covered as part of the **single-responsibility
    principle, open-closed principle, Liskov substitution principle, interface segregation
    principle, and dependency inversion principle** (**SOLID**) design principles
    in [*Chapter 1*](B18507_01_Epub.xhtml#_idTextAnchor020), *Designing and Architecting
    the Enterprise Application*. With the use of DI, code will be more maintainable,
    readable, testable, and extensible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是一种技术，其中对象接收它所依赖的对象。DI 模式实现了作为 **单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则**（**SOLID**）设计原则一部分的
    DI 原则，如 [*第一章*](B18507_01_Epub.xhtml#_idTextAnchor020)，*设计和架构企业应用程序* 中所述。使用 DI，代码将更易于维护、阅读、测试和扩展。
- en: 'DI is one of the most well-known methods to help achieve better maintainable
    code. DI has three entities involved, as shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是帮助实现更易于维护代码的最知名方法之一。DI 涉及三个实体，如下面的图所示：
- en: '![Figure 5.1 – DI relationship'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – DI 关系'
- en: '](img/Figure_5.1_B18507.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B18507.jpg)'
- en: Figure 5.1 – DI relationship
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – DI 关系
- en: The `IOrderRepository` is responsible for `Order` entity. .NET IoC container
    (`IOrderRepository` (`OrderController` (client).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOrderRepository` 负责处理 `Order` 实体。.NET IoC 容器（`IOrderRepository` (`OrderController`（客户端））。'
- en: '**IoC container** (also known as **DI Container**) is a framework for implementing
    automatic DI. In *Figure 5.1*, this is referred to as **Injector**. It is responsible
    for creating or referencing a dependency and injecting it into **Client**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**IoC 容器**（也称为 **DI 容器**）是一个用于实现自动 DI 的框架。在 *图 5.1* 中，这被称为 **注入器**。它负责创建或引用依赖关系并将其注入到
    **客户端**。'
- en: Now that we have learned what DI is, let's learn about the types of DI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是 DI，让我们来了解 DI 的类型。
- en: Types of DI
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DI 类型
- en: 'There are multiple ways a service can be injected into a dependency. Based
    on the way a service is injected into the client object, DI is categorized into
    three types, as outlined here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以以多种方式注入到依赖项中。根据服务注入客户端对象的方式，DI 被分为三种类型，如下所述：
- en: '`IWeatherProvider` dependency is injected through the constructor parameter:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IWeatherProvider` 依赖项通过构造函数参数注入：'
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `WeatherService` is dependent on `IWeatherProvider`,
    which is injected via a constructor parameter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`WeatherService` 依赖于 `IWeatherProvider`，它通过构造函数参数注入。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For an implementation of the `WeatherProvider` service, refer to the sample
    code from GitHub, which can be found at the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `WeatherProvider` 服务的实现，请参考 GitHub 上的示例代码，该代码可在以下链接找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Service/WeatherProvider.cs)。
- en: '`IWeatherProvider` dependency is not set while initializing `WeatherService2`.
    It is set via the `WeatherProvider` property post object initialization:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `WeatherService2` 时，`IWeatherProvider` 依赖项未设置。它是在对象初始化后通过 `WeatherProvider`
    属性设置的：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`IWeatherProvider` dependency is injected as a method parameter wherever required.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IWeatherProvider` 依赖项作为所需的方法参数进行注入。'
- en: 'In the following code snippet, the `IWeatherProvider` service is injected into
    `WeatherService` via the `GetForecast` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`IWeatherProvider` 服务通过 `GetForecast` 方法注入到 `WeatherService` 中：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are some suggestions to help in choosing the type of DI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些建议，可以帮助选择依赖注入的类型：
- en: Use constructor injection when the class has a dependency without which the
    functionality won't work.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类有依赖项且没有这个依赖项功能无法工作时，请使用构造函数注入。
- en: Use constructor injection when the dependency is used in multiple functions
    in the class.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当依赖项在类的多个函数中使用时，请使用构造函数注入。
- en: Use property injection when the dependency can change after the class is instantiated.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当依赖项在类实例化后可以更改时，请使用属性注入。
- en: Use method injection when the implementation of the dependency changes with
    every call.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当依赖项的实现随着每次调用而改变时，请使用方法注入。
- en: In most cases, constructor injection will be used for clean and decoupled code,
    but depending on the need, we will also leverage method and property injection
    techniques.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，构造函数注入将被用于干净且解耦的代码，但根据需要，我们还将利用方法和属性注入技术。
- en: We have now learned the concepts of DI. Let's dive into what .NET 6 offers to
    achieve DI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了依赖注入的概念。让我们深入了解 .NET 6 提供的依赖注入实现。
- en: DI in ASP.NET Core 6
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 中的依赖注入
- en: '.NET 6 comes with a built-in IoC container framework, which simplifies DI.
    This comes with the `Microsoft.Extensions.DependencyInjection` NuGet package and
    the ASP.NET Core 6 framework itself relies heavily on this. To support DI, a container
    needs to support three basic actions on objects/services, as outlined here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 内置了 IoC 容器框架，这简化了依赖注入。这包括 `Microsoft.Extensions.DependencyInjection`
    NuGet 包和 ASP.NET Core 6 框架本身严重依赖于它。为了支持依赖注入，容器需要对对象/服务支持三个基本操作，如下所述：
- en: '**Registering**: The container should have provisions to register dependencies.
    This will help to map the correct type to a class so that it can create the right
    dependency instance.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册**：容器应提供注册依赖项的机制。这将有助于将正确的类型映射到类，以便它可以创建正确的依赖项实例。'
- en: '**Resolving**: The container should resolve dependencies by creating a dependency
    object and injecting it into the dependent instance. IoC container manages the
    creation of registered objects by passing in all the required dependencies.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析**：容器应通过创建依赖对象并将其注入到依赖实例中来解析依赖项。IoC 容器通过传递所有必需的依赖项来管理已注册对象的形成。'
- en: '**Disposing**: The container is responsible for managing the lifetime of dependencies
    created through it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放**：容器负责管理通过它创建的依赖项的生命周期。'
- en: 'In .NET 6, the following terms are used:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中，以下术语被使用：
- en: '**Service**: Refers to a dependency managed by a container'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：指由容器管理的依赖项'
- en: '`IConfiguration`, `ILoggerFactory`, `IWebHostEnvironment`, and so on'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IConfiguration`、`ILoggerFactory`、`IWebHostEnvironment` 等'
- en: '`IWeatherProvider` service that we used in the previous section'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在上一节中使用的 `IWeatherProvider` 服务
- en: 'For the application to start, the ASP.NET Core 6 framework injects a few dependencies,
    which are referred to as `WebApplicationBuilder` is injected with the required
    framework services such as `IConfiguration` and `IWebHostEnvironment`. When you
    try printing the registered services, as shown in the following code snippet (refer
    to the code from [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16)),
    we can list the framework services registered:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序启动，ASP.NET Core 6 框架注入了一些依赖项，这些依赖项被称为 `WebApplicationBuilder` 注入所需的框架服务，如
    `IConfiguration` 和 `IWebHostEnvironment`。当您尝试打印已注册的服务时，如下代码片段所示（参考 [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DITypes/Program.cs#L16)
    中的代码），我们可以列出已注册的框架服务：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In ASP.NET Core 6.0, the `IWebHostEnvironment` framework service is available
    from the `builder.Environment` property. Similarly, the configuration is available
    from the `builder.Configuration` property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 6.0 中，`IWebHostEnvironment` 框架服务可通过 `builder.Environment` 属性获取。同样，配置可通过
    `builder.Configuration` 属性获取。
- en: ASP.NET Core 6 Runtime instantiates all the required framework services and
    registers them with IoC container. Starting with ASP.NET Core 6, they are available
    through properties of `WebApplication` and `WebApplicationBuilder` in `Program.cs`.
    These framework services can be injected into controllers and other services through
    any of the DI types we discussed in the previous section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 运行时实例化所有必需的框架服务并将它们注册到 IoC 容器中。从 ASP.NET Core 6 开始，它们可通过 `Program.cs`
    中的 `WebApplication` 和 `WebApplicationBuilder` 的属性访问。这些框架服务可以通过我们在上一节中讨论的任何 DI
    类型注入到控制器和其他服务中。
- en: 'Application services are services injected into the container by the developer.
    These services will be registered using the `Services` property of `WebApplicationBuilder`.
    The following code snippet shows how to register the `IWeatherProvider` application
    service with the container:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务是由开发人员注入到容器中的服务。这些服务将使用 `WebApplicationBuilder` 的 `Services` 属性进行注册。以下代码片段展示了如何将
    `IWeatherProvider` 应用程序服务注册到容器中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the next section, we will learn about the lifetime of these services and
    how they are managed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解这些服务的生命周期以及它们是如何被管理的。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an
    ASP.NET Core 6 Web API*, to learn about the code present in the `Program.cs` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第10章*](B18507_10_Epub.xhtml#_idTextAnchor1040)，*创建 ASP.NET Core 6 Web API*，了解
    `Program.cs` 文件中的代码。
- en: Understanding service lifetimes
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解服务生命周期
- en: 'When you register a service with a specified lifetime, the container will automatically
    dispose of the object according to the lifetime specified. There are three types
    of lifetimes available to use with Microsoft DI Container, as outlined here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用指定的生命周期注册服务时，容器将根据指定的生命周期自动销毁对象。在 Microsoft DI 容器中，可以使用以下三种类型的生命周期：
- en: '`AddTransient` extension method is used to register with this lifetime, as
    illustrated in the following code snippet:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTransient` 扩展方法用于注册此生命周期，如下代码片段所示：'
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A transient lifetime is normally used for stateless, lightweight services.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 临时生命周期通常用于无状态、轻量级的服务。
- en: '`ServiceProvider` is disposed of on application shutdown. The `AddSingleton`
    extension method is used to register with this lifetime, as illustrated in the
    following code snippet:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceProvider` 在应用程序关闭时被销毁。使用 `AddSingleton` 扩展方法注册此生命周期，如下代码片段所示：'
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`DbContext` are registered with a scoped lifetime. The `AddScoped` extension
    method is used to register with the scoped lifetime scope, as illustrated in the
    following code snippet:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DbContext` 使用作用域生命周期进行注册。使用 `AddScoped` 扩展方法注册到作用域生命周期范围，如下代码片段所示：'
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The lifetime type needs to be chosen wisely in application development. A service
    should not depend on a service that has a shorter life span than its own; for
    example, a service registered as a singleton should not depend on a service that
    is registered as transient. The following table shows which lifetimes can safely
    depend on which other lifetime scopes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发中，需要明智地选择生命周期类型。一个服务不应依赖于生命周期比其短的服务；例如，注册为单例的服务不应依赖于注册为瞬时的服务。以下表格显示了哪些生命周期可以安全地依赖于哪些其他生命周期范围：
- en: '![Figure 5.1 – DI relationship'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – DI 关系](img/Figure_5.1 – DI relationship)'
- en: '](img/Table_5.1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 5.1 – 表格结构](img/Table_5.1.jpg)'
- en: Table 5.1 – Lifetime dependency
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – 生命周期依赖
- en: 'As a developer, you need not worry about scope validation. Built-in scope validation
    is done in ASP.NET Core 6 when the environment is set to `InvalidOperationException`
    is thrown while building the application. This can be explicitly turned on by
    enabling `ValidateScopes` options for all environment configurations while registering
    `ServiceProvider`, as shown in the following code snippet. Here, while creating
    a host builder, `ValidateScopes` is set to `true` to turn on the scope validation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你不需要担心范围验证。内置的范围验证在 ASP.NET Core 6 中完成，当环境设置为 `InvalidOperationException`
    时抛出。这可以通过在注册 `ServiceProvider` 时为所有环境配置启用 `ValidateScopes` 选项来显式打开。在此代码片段中，当创建主机构建器时，`ValidateScopes`
    设置为 `true` 以打开范围验证：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s create an ASP.NET Core 6 web application to understand the service lifetime.
    We will be creating different services and registering them with the singleton,
    scoped, and transient lifetime scopes and observing how they behave. Proceed as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 ASP.NET Core 6 Web 应用程序来了解服务生命周期。我们将创建不同的服务并将它们注册为单例、作用域和瞬态生命周期范围，并观察它们的行为。按照以下步骤进行：
- en: Create a new ASP.NET Core web application (`DISampleWeb`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 ASP.NET Core Web 应用程序（`DISampleWeb`）。
- en: 'Create a new project folder with the name `Services` and add three classes:
    `ScopedService`, `SingletonService`, and `TransientService`. Add the following
    code (all these services will be the same without any real code in them; we just
    register them with different lifetime scopes as per their name):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Services` 的新项目文件夹，并添加三个类：`ScopedService`、`SingletonService` 和 `TransientService`。添加以下代码（所有这些服务都将相同，其中没有任何实际代码；我们只是根据它们的名称将它们注册为不同的生命周期范围）：（所有这些服务都将相同，其中没有任何实际代码；我们只是根据它们的名称将它们注册为不同的生命周期范围）
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`SingletonService.cs`: This class will be registered with the singleton lifetime
    scope, as illustrated in the following code snippet:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SingletonService.cs`：此类将使用单例生命周期范围进行注册，如下代码片段所示：'
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`TransientService.cs`: This class will be registered with the transient lifetime
    scope, as illustrated in the following code snippet:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TransientService.cs`：此类将使用瞬态生命周期范围进行注册，如下代码片段所示：'
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, register these services in `Program.cs` with `IServiceCollection`, as
    shown here:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Program.cs` 中使用 `IServiceCollection` 注册这些服务，如下所示：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The collection of service descriptors, `IServiceCollection`, is exposed via
    the `Services` property of `WebApplicationBuilder`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 服务描述符集合 `IServiceCollection` 通过 `WebApplicationBuilder` 的 `Services` 属性公开。
- en: 'Now, add the `HomeViewModel` model class under the `Models` folder, which will
    be used to show data retrieved from the services registered previously. The following
    code snippet illustrates how to do this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Models` 文件夹下添加 `HomeViewModel` 模型类，该类将用于显示从先前注册的服务检索到的数据。以下代码片段说明了如何进行此操作：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we registered `ScopedService`, `SingletonService`, and `TransientService`
    with ASP.NET Core 6 IoC container, we will get these services via constructor
    injection.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已使用 ASP.NET Core 6 IoC 容器注册了 `ScopedService`、`SingletonService` 和 `TransientService`，我们将通过构造函数注入获取这些服务。
- en: 'Now, we will add code to get these services in `HomeController` and `Views`
    to show data retrieved from these objects on the home page. Modify the home controller
    to get two instances of `ScopedService` and `TransientService` and set `ViewModel`
    with the object hash code of the service object. The solution structure is shown
    in the following screenshot:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加代码以在 `HomeController` 和 `Views` 中获取这些服务，以在主页上显示从这些对象检索到的数据。修改主页控制器以获取两个
    `ScopedService` 和 `TransientService` 的实例，并使用服务对象的哈希码设置 `ViewModel`。解决方案结构如下截图所示：
- en: '![Figure 5.2 – Solution structure'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 解决方案结构](img/Figure_5.2 – Solution structure)'
- en: '](img/Figure_5.2_B18507.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 解决方案结构](img/Figure_5.2_B18507.jpg)'
- en: Figure 5.2 – Solution structure
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 解决方案结构
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetHashCode` method returns the hash code of the object. This will change
    per instance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHashCode` 方法返回对象的哈希码。这将根据实例而变化。'
- en: 'Modify the constructor of `HomeController` to accept the registered services
    and define private fields to reference service instances, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`HomeController`的构造函数以接受已注册的服务，并定义私有字段以引用服务实例，如下所示：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, modify the `Index` method under `HomeController` to set `HomeViewModel`,
    as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改`HomeController`下的`Index`方法，设置`HomeViewModel`，如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, modify `Index.cshtml` under the `~/Views/Home` folder to show `HomeViewModel`
    on the page, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`~/Views/Home`文件夹下的`Index.cshtml`，以在页面上显示`HomeViewModel`，如下所示：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, run the application. You will see an output like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序。你会看到如下输出：
- en: '![Figure 5.3 – Sample output on the first run'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 第一次运行的示例输出'
- en: '](img/Figure_5.3_B18507.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B18507.jpg)'
- en: Figure 5.3 – Sample output on the first run
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 第一次运行的示例输出
- en: If we observe the output, the `ScopedService` are the same. This is because
    only one object for `IScopedService` is created per request scope. Please note
    the IDs may be different when you run the code as they are generated at runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察输出，`ScopedService`是相同的。这是因为对于每个请求作用域，只为`IScopedService`创建一个对象。请注意，当你运行代码时，ID可能不同，因为它们是在运行时生成的。
- en: The IDs of the transient service are different for both services. As we learned,
    this is because a new instance is created for every request to IoC container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 临时服务的ID对于两个服务都是不同的。正如我们所学的，这是因为每次对IoC容器的请求都会创建一个新的实例。
- en: 'Now, refresh the page again. You''ll see an output that looks something like
    this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次刷新页面。你会看到类似如下输出：
- en: '![Figure 5.4 – Sample output on the second run'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 第二次运行的示例输出'
- en: '](img/Figure_5.4_B18507.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B18507.jpg)'
- en: Figure 5.4 – Sample output on the second run
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 第二次运行的示例输出
- en: If we compare the outputs in both *Figure 5.3* and *Figure 5.4*, we will notice
    that the ID of `SingletonService` did not change—this is because only one object
    is created for a singleton object per lifetime of the application. Up until now,
    we have seen how the service lifetime is managed based on the registration. It
    is also important to understand when objects are to be disposed of. In the next
    section, we will learn about the disposal of services.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较图5.3和图5.4中的输出，我们会注意到`SingletonService`的ID没有改变——这是因为应用程序的生命周期中，对于单例对象只创建一个对象。到目前为止，我们已经看到了如何根据注册来管理服务生命周期。了解何时销毁对象也同样重要。在下一节中，我们将学习关于服务销毁的内容。
- en: Disposal of services
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务销毁
- en: As we learned earlier in this chapter, the disposal of objects is the responsibility
    of the IoC container framework. The container calls the `Dispose` method on those
    services that implement `IDisposable`. Services created by the container should
    never be disposed of by the developer explicitly. Similarly, developers are responsible
    for disposing of instances created by them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所学，对象的销毁是IoC容器框架的责任。容器会调用实现`IDisposable`接口的服务的`Dispose`方法。由容器创建的服务不应被开发者显式销毁。同样，开发者负责销毁他们创建的实例。
- en: 'Consider the following code snippet, where the `SingletonService` instance
    is registered with the singleton scope:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中`SingletonService`实例以单例作用域注册：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a simple implementation of `DisposableSingletonService`, refer to the code
    at the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DisposableSingletonService`的简单实现，请参考以下链接中的代码：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Chapter05/DISampleWeb/Services/DisposableSingletonService.cs)。
- en: 'In the preceding code snippet, we created an object of `DisposableSingletonService`
    and registered it with IoC container. The service instance is not created by the
    container. In this case, IoC Container does not dispose of the object; it is the
    developer''s responsibility to dispose of it. We can dispose of objects when an
    `ApplicationStopping` event is fired from `IHostApplicationLifetime`, which is
    exposed through the `Lifetime` property of `WebApplication`, as shown in the following
    code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个 `DisposableSingletonService` 的对象，并将其注册到 IoC 容器中。服务实例不是由容器创建的。在这种情况下，IoC
    容器不会释放该对象；开发者有责任释放它。我们可以在 `IHostApplicationLifetime` 的 `ApplicationStopping` 事件触发时释放对象，该事件通过
    `WebApplication` 的 `Lifetime` 属性公开，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code snippet, `IHostApplicationLifetime` is injected by the
    runtime into `WebApplication`. This interface allows consumers to be notified
    of `ApplicationStarted`, `ApplicationStopped`, and `ApplicationStopping` application
    lifetime events. To dispose of the singleton object, we will call a Dispose()
    method by registering to the `ApplicationStopping` lifetime event.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`IHostApplicationLifetime` 由运行时注入到 `WebApplication` 中。此接口允许消费者接收 `ApplicationStarted`、`ApplicationStopped`
    和 `ApplicationStopping` 应用程序生命周期事件的通知。为了释放单例对象，我们将通过注册到 `ApplicationStopping`
    生命周期事件来调用 Dispose() 方法。
- en: 'A new addition in .NET 6 to DI is the support of `IAsyncDisposable` for scopes.
    A new `CreateAsyncScope` extension method is added to `IServiceProvider` to support
    the creation of an asynchronous service scope, and an `AsyncServiceScope` wrapper
    is added, which implements `IAsyncDisposable`. The following code disposes of
    the scopes asynchronously:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 中 DI 的新增功能是对作用域的 `IAsyncDisposable` 支持。在 `IServiceProvider` 中添加了一个新的
    `CreateAsyncScope` 扩展方法来支持异步服务作用域的创建，并添加了一个 `AsyncServiceScope` 包装器，它实现了 `IAsyncDisposable`。以下代码展示了如何异步地释放作用域：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Going forward, if the dependency `CreateAsyncScope` wherever you are creating
    scopes manually.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果你在手动创建作用域的地方使用依赖 `CreateAsyncScope`。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Refer to the following Microsoft documentation to learn more about DI guidelines:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下 Microsoft 文档以了解更多关于 DI 指南的信息：
- en: '[https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines)'
- en: Up until now, we have looked at service lifetimes and how they are disposed
    of in .NET 6\. In the next section, we will learn about managing application services.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了服务生命周期以及它们在 .NET 6 中的释放方式。在下一节中，我们将学习如何管理应用程序服务。
- en: Managing application services
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理应用程序服务
- en: In ASP.NET Core 6, when a request is received by `MvcMiddleware`, routing is
    used to select a controller and action method. `IControllerActivator` creates
    an instance of the controller and loads constructor arguments from DI Container.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 6 中，当请求被 `MvcMiddleware` 接收到时，会使用路由来选择控制器和操作方法。`IControllerActivator`
    会创建控制器的实例，并从依赖注入容器中加载构造函数参数。
- en: In the *Understanding service lifetimes* section, we saw how application services
    are registered and how their lifetimes are managed. In the example, the services
    were injected through a constructor, which is known as constructor injection.
    In this section, we will see how to achieve method injection and go through different
    ways application services can be registered and accessed in ASP.NET Core 6 IoC
    container.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *理解服务生命周期* 部分，我们看到了应用程序服务是如何注册的以及它们的生命周期是如何管理的。在示例中，服务是通过构造函数注入的，这被称为构造函数注入。在本节中，我们将了解如何实现方法注入，并探讨在
    ASP.NET Core 6 的 IoC 容器中应用程序服务可以如何注册和访问。
- en: Accessing registered services via method injection
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过方法注入访问已注册的服务
- en: In the previous sections, we saw how the dependency service is injected into
    the controller constructor and the reference is stored in a local field that is
    used to call a method/**application programming interface** (**API**) of the dependency.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了依赖服务是如何注入到控制器构造函数中，并且引用被存储在一个局部字段中，用于调用依赖的**方法**/**应用程序编程接口**（**API**）。
- en: 'Sometimes, we don''t want the dependency service to be available in all actions
    of the controller. In such scenarios, the service can be injected via method injection.
    This is done by making a parameter with the `[FromServices]` attribute, as shown
    in the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不想在控制器的所有操作中都有依赖服务可用。在这种情况下，可以通过方法注入来注入服务。这通过创建一个带有`[FromServices]`属性的参数来完成，如下面的示例所示：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Minimal APIs introduced in ASP.NET Core 6 allow us to request DI services in
    route handlers without explicitly marking them with the `[FromServices]` attribute,
    as illustrated here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6中引入的最小API允许我们在路由处理程序中请求DI服务，而无需显式使用`[FromServices]`属性，如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You might be wondering how the runtime differentiates injected services from
    other parameters. To achieve that, .NET6 introduced a new `IServiceProviderIsService`
    interface, which helps to identify that a given service type is registered in
    the DI container without creating an instance of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道运行时如何区分注入的服务和其他参数。为了实现这一点，.NET6引入了一个新的`IServiceProviderIsService`接口，它有助于识别给定的服务类型已注册在DI容器中，而不需要创建其实例。
- en: In the next section, we will see the registration of multiple instances for
    the same service type and how to access them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到同一服务类型的多个实例的注册以及如何访问它们。
- en: Registering multiple instances
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册多个实例
- en: For a given interface, we can register multiple implementations with the IoC
    container.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的接口，我们可以使用IoC容器注册多个实现。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If more than one implementation is registered with the same service type, the
    last registration will take precedence over all previous registrations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为同一服务类型注册了多个实现，则最后一个注册将优先于所有之前的注册。
- en: 'Consider the following service registration, where the `IWeatherForecastService`
    service is registered with two implementations—`WeatherForecastService` and `WeatherForecastServiceV2`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下服务注册，其中`IWeatherForecastService`服务注册了两个实现——`WeatherForecastService`和`WeatherForecastServiceV2`：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, when there is a request for an instance of `IWeatherForecastService` from
    the controller, an instance of `WeatherForecastServiceV2` will be served, as illustrated
    in the following code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当从控制器请求`IWeatherForecastService`的实例时，将提供`WeatherForecastServiceV2`的实例，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the previous example, it might appear that the registration of `WeatherForecastV2`
    is overwriting the previous registration of `WeatherForecastService`. However,
    ASP.NET Core 6 IoC container will have all registrations of `IWeatherForecastService`.
    To get all registrations, fetch the service as `IEnumerable`, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，可能看起来`WeatherForecastV2`的注册覆盖了`WeatherForecastService`的先前注册。然而，ASP.NET
    Core 6的IoC容器将包含所有`IWeatherForecastService`的注册。要获取所有注册，请按如下方式获取服务作为`IEnumerable`：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This may be useful in scenarios such as executing a `Services` property of `WebApplicationBuilder`.
    So, in the future, when there is an addition of a rule or the removal of an existing
    rule, the change will only be to inject a new service into the `Services` property.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这在执行`WebApplicationBuilder`的`Services`属性等场景中可能很有用。因此，在未来，当添加或删除现有规则时，更改将仅限于向`Services`属性注入新的服务。
- en: Using TryAdd
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TryAdd
- en: In this section, we will learn about how we can avoid accidentally overriding
    already registered services.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何避免意外覆盖已注册的服务。
- en: The `TryAdd` extension method registers services only when no registration exists
    for the same service. The `TryAdd` extension method is available for all lifetime
    scopes (`TyrAddScoped`, `TryAddSingleton`, and `TryAddTransient`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryAdd`扩展方法仅在不存在相同服务的注册时注册服务。`TryAdd`扩展方法对所有生命周期范围（`TryAddScoped`、`TryAddSingleton`和`TryAddTransient`）都可用。'
- en: 'With the service registration shown in the following code snippet, when there
    is a request for `IWeatherForecastService`, IoC container serves `WeatherForecastService`,
    not `WeatherForecastServiceV2`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，使用服务注册时，当请求`IWeatherForecastService`时，IoC容器提供`WeatherForecastService`，而不是`WeatherForecastServiceV2`：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To overcome side effects that might occur with duplicate registrations, it is
    always recommended to use `TryAdd` extension methods to register a service.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服可能因重复注册而产生的副作用，始终建议使用`TryAdd`扩展方法来注册服务。
- en: Now, let's see how to replace an already registered service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何替换已注册的服务。
- en: Replacing an existing registration
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换现有注册
- en: 'ASP.NET Core 6 IoC container provides a way to replace existing registrations.
    In the following example, `IWeatherForecastService` is initially registered with
    `WeatherForecastService`. It is then replaced with `WeatherForecastServiceV2`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 IoC 容器提供了一种替换现有注册的方法。在下面的示例中，`IWeatherForecastService` 首先使用 `WeatherForecastService`
    进行注册。然后它被替换为 `WeatherForecastServiceV2`：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As with the `Replace` instance of `WeatherForecastServiceV2`, an implementation
    is served to the constructor of `WeatherForecastController`. In the following
    code snippet, unlike in the *Registering multiple instances* section, we will
    only see one object in the `weatherForecastService` constructor variable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `WeatherForecastServiceV2` 的 `Replace` 实例一样，一个实现被提供给 `WeatherForecastController`
    构造函数。在下面的代码片段中，与 *注册多个实例* 部分不同，我们将在 `weatherForecastService` 构造函数变量中只看到一个对象：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Till now in this section, we have learned about registering and replacing services
    with the IoC container. There may be times when we need to delete current registrations.
    Consider a scenario where you wish to utilize services and registrations from
    a library but you don't have access to its source code. If you reimplement some
    of the interfaces from that library and reregister them with the container, you
    might see some unexpected behavior. In the next section, we will see how to remove
    a registered service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们已经学习了如何使用 IoC 容器注册和替换服务。有时我们可能需要删除当前的注册。考虑这样一个场景，你希望利用库中的服务和注册，但你没有访问其源代码的权限。如果你重新实现了该库的一些接口并将它们重新注册到容器中，你可能会看到一些意外的行为。在下一节中，我们将了解如何删除已注册的服务。
- en: Removing an existing registration
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除现有注册
- en: 'To remove an existing registration, ASP.Net Core 6 IoC container provides the
    `Remove` extension. You can use the `RemoveAll` method to remove all registrations
    related to a service, as seen in the following code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除现有注册，ASP.Net Core 6 IoC 容器提供了 `Remove` 扩展方法。你可以使用 `RemoveAll` 方法删除与某个服务相关的所有注册，如下面的代码片段所示：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the following code snippet, the `Remove` method removes the registration
    of the `WeatherForecastService` implementation from the container:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`Remove` 方法从容器中移除了 `WeatherForecastService` 实现的注册：
- en: '[PRE60]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Up until now, we have seen how we work with complex services, but when it comes
    to generic open types, it will be difficult to register every generic constructed
    type. In the next section, we will learn how to deal with generic open-type services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何处理复杂的服务，但当涉及到泛型开放类型时，注册每个构造的泛型类型将会变得困难。在下一节中，我们将学习如何处理泛型开放类型服务。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about generic types, you can refer to the following website:
    [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于泛型类型的信息，你可以参考以下网站：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/types)。
- en: Registering generics
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册泛型
- en: This section will introduce you to dealing with generic-type services with DI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何使用依赖注入处理泛型类型服务。
- en: 'In the case of generic types, it does not make sense to register the service
    for each type of implementation that is in use. ASP.NET Core 6 IoC container provides
    a way to simplify the registration of the generic type. One such type that is
    already provided by the framework itself is `ILogger`, as illustrated in the following
    code snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于泛型类型，为每种正在使用的实现类型注册服务是没有意义的。ASP.NET Core 6 IoC 容器提供了一种简化泛型类型注册的方法。框架本身已经提供的一个此类类型是
    `ILogger`，如下面的代码片段所示：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For your reference, you may visit the following link: [https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便参考，你可以访问以下链接：[https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Logging/src/LoggingBuilderExtensions.cs)。
- en: Another use case for generics is with a generic repository pattern used with
    the data access layer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的一个用例是与数据访问层一起使用的泛型仓储模式。
- en: With all the registrations we have, the `ConfigureServices` method can grow
    big and can no longer be readable. The next section will help you learn how to
    address that.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有的所有注册信息中，`ConfigureServices` 方法可能会变得很大，以至于不再可读。下一节将帮助你了解如何解决这个问题。
- en: Extension methods for code readability
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码可读性的扩展方法
- en: The pattern that is followed in the ASP.NET Core 6 framework to make code look
    more readable is to create an extension method with a logical grouping of service
    registrations. The following code tries to group and register notification-related
    services using an extension method. General practice is to use the `Microsoft.Extensions.DependencyInjection`
    namespace to define service registration extension methods. This will make the
    developer use all the functionality related to DI just by using the `Microsoft.Extensions.DependencyInjection`
    namespace.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 框架遵循的使代码看起来更易读的模式是创建一个具有逻辑分组的服务注册扩展方法。以下代码尝试使用扩展方法对通知相关服务进行分组和注册。一般做法是使用
    `Microsoft.Extensions.DependencyInjection` 命名空间来定义服务注册扩展方法。这将使开发者只需使用 `Microsoft.Extensions.DependencyInjection`
    命名空间就能使用所有与依赖注入相关的功能。
- en: 'In the following code snippet, notification-related services were registered
    with `AddNotificationServices`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，使用 `AddNotificationServices` 注册了与通知相关的服务：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now that the extension method is created, we can use the `AddNotificationServices`
    method to register notification services under `ConfigureServices`. This will
    make `ConfigureServices` become more readable. The code is illustrated here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在扩展方法已经创建，我们可以使用 `AddNotificationServices` 方法在 `ConfigureServices` 下注册通知服务。这将使
    `ConfigureServices` 更易于阅读。代码如下所示：
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have seen how to inject services into controllers and other classes. In the
    next section, we will learn how to inject services into views.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将服务注入到控制器和其他类中。在下一节中，我们将学习如何将服务注入到视图中。
- en: DI in Razor Pages
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor Pages 中的依赖注入
- en: The purpose of views in MVC is to display data. Most of the time, data displayed
    in views is passed from the controller. Passing all required data from controllers
    is recommended considering the **separation of concerns** (**SoC**) principle,
    but there may be cases where we want to view specific services from pages such
    as localization and telemetry services. Using DI supported by Razor views, we
    can inject such services into views.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 中视图的目的是显示数据。大多数情况下，在视图中显示的数据是从控制器传递过来的。考虑到 **关注点分离**（**SoC**）原则，建议从控制器传递所有必要的数据，但可能存在我们想要从诸如本地化和遥测服务之类的页面查看特定服务的情况。使用由
    Razor 视图支持的依赖注入，我们可以将这些服务注入到视图中。
- en: 'To learn about injecting services into views, let''s modify the `DISampleWeb`
    application that we created in previous chapters. We will be modifying the `DISampleWeb`
    application to display additional content on the home page if a flight flag is
    set. Add the `isFlightOn` configuration, as shown in the following code snippet,
    to `appsettings.json`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何将服务注入到视图中，让我们修改在前几章中创建的 `DISampleWeb` 应用程序。我们将修改 `DISampleWeb` 应用程序，以便在设置飞行标志的情况下在主页上显示额外内容。将
    `isFlightOn` 配置添加到 `appsettings.json` 中，如下面的代码片段所示：
- en: '[PRE75]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, modify the index view under `Home` to display the content under `Flight`,
    as shown in the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改 `Home` 下的索引视图以显示 `Flight` 下的内容，如下面的代码片段所示：
- en: '[PRE79]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here, the `Iconfiguration` service, which provides the functionality of reading
    the configuration file, is injected into the Razor view using the `@inject` keyword.
    The injected configuration service is used to get the configuration and display
    additional content based on the settings. We can inject any service registered
    with `IserviceCollection` into Razor views using the `@inject` keyword.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提供读取配置文件功能的 `IConfiguration` 服务通过 `@inject` 关键字注入到 Razor 视图中。注入的配置服务用于获取配置并基于设置显示额外内容。我们可以使用
    `@inject` 关键字将任何已注册到 `IServiceCollection` 的服务注入到 Razor 视图中。
- en: Up until now, we have seen how we can leverage the .NET 6 built-in IoC container.
    In the next section, we will learn about leveraging third-party containers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何利用 .NET 6 内置的 IoC 容器。在下一节中，我们将学习如何利用第三方容器。
- en: Using third-party containers
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: Though the built-in container is sufficient for most of our scenarios, .NET
    6 provides a way to integrate with third-party containers that can be leveraged
    if need be.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内置容器对于大多数场景来说已经足够，但 .NET 6 提供了一种与第三方容器集成的途径，如果需要的话可以加以利用。
- en: Let's have a closer look at how the framework wires up the services. When the
    `Startup` class is registered with `HostBuilder` in `Program.cs`, .NET Framework
    uses reflection to identify and call the `Configure` and `ConfigureServices` methods.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看框架是如何连接服务的。当 `Startup` 类在 `Program.cs` 中与 `HostBuilder` 注册时，.NET 框架使用反射来识别并调用
    `Configure` 和 `ConfigureServices` 方法。
- en: 'Here is a snippet from the `LoadMethods` method of the `StartupLoader` class
    in ASP.NET Core 6 (refer to the code from [https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs)):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从ASP.NET Core 6的`StartupLoader`类的`LoadMethods`方法中摘录的一段代码（请参阅[https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/Internal/StartupLoader.cs)中的代码）：
- en: '[PRE90]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: From the preceding code snippet, we can see that the first two methods, `FindConfigureDelegate`
    and `FindConfigureServicesDelegate`, are to find the `Configure` and `ConfigureServices`
    methods.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到前两个方法，`FindConfigureDelegate`和`FindConfigureServicesDelegate`，是为了找到`Configure`和`ConfigureServices`方法。
- en: The last line is for `ConfigureContainer`. We can define a `ConfigureContainer`
    method in the `Startup` class to configure the services into a third-party container.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是用于`ConfigureContainer`的。我们可以在`Startup`类中定义一个`ConfigureContainer`方法来配置服务到第三方容器中。
- en: 'Here are some of the popular DI frameworks available for ASP.NET Core 6:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是可用于ASP.NET Core 6的一些流行的DI框架：
- en: '**Unity**: Unity was initially built by Microsoft and is currently open sourced.
    This is one of the oldest DI containers for .NET. The documentation is available
    at the following link: [http://unitycontainer.org/](http://unitycontainer.org/).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity**: Unity最初由微软构建，目前是开源的。这是.NET中最古老的DI容器之一。文档可在以下链接找到：[http://unitycontainer.org/](http://unitycontainer.org/).'
- en: '**Autofac**: This is one of the most popular DI containers. It has comprehensive
    documentation available at the following link: [https://autofaccn.readthedocs.io/en/latest/index.html](https://autofaccn.readthedocs.io/en/latest/index.html).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Autofac**: 这是最受欢迎的DI容器之一。它提供了全面的文档，可在以下链接找到：[https://autofaccn.readthedocs.io/en/latest/index.html](https://autofaccn.readthedocs.io/en/latest/index.html).'
- en: '**Simple Injector**: This is one of the late entrants on the list. The documentation
    can be found at the following link: [https://simpleinjector.readthedocs.io/en/latest/index.html](https://simpleinjector.readthedocs.io/en/latest/index.html).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Simple Injector**: 这是列表中较晚出现的一个。文档可在以下链接找到：[https://simpleinjector.readthedocs.io/en/latest/index.html](https://simpleinjector.readthedocs.io/en/latest/index.html).'
- en: '**Castle Windsor**: This is one of the oldest DI frameworks available for .NET.
    See its documentation at the following link: [http://www.castleproject.org/projects/windsor/](http://www.castleproject.org/projects/windsor/).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Castle Windsor**: 这是.NET中可用的最古老的DI框架之一。可在以下链接查看其文档：[http://www.castleproject.org/projects/windsor/](http://www.castleproject.org/projects/windsor/).'
- en: Though there are a few differences between these frameworks, there is generally
    feature parity. It is mostly the developer's experience that determines the choice
    of framework.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些框架之间存在一些差异，但通常功能是相同的。大多数情况下，开发者的体验决定了框架的选择。
- en: In the next section, let's see how to leverage the Autofac third-party IoC container.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何利用Autofac第三方IoC容器。
- en: Autofac IoC container
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autofac IoC容器
- en: 'Autofac is one of the most popular IoC containers among the developer community.
    As with any other IoC container, it manages dependencies between classes so that
    applications remain easy to change as they grow in complexity and size. Let''s
    learn how to use Autofac to register the same `WeatherProvider` service that we
    used earlier in this chapter. Proceed as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Autofac是开发者社区中最受欢迎的IoC容器之一。与其他任何IoC容器一样，它管理类之间的依赖关系，以便随着应用程序复杂性和规模的增加，应用程序仍然易于更改。让我们学习如何使用Autofac注册我们在本章前面使用过的相同`WeatherProvider`服务。按照以下步骤进行：
- en: Create a new project using the ASP.NET Core web API template and name it `AutofacSample`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core Web API模板创建一个新的项目，并将其命名为`AutofacSample`。
- en: 'Add the `Autofac.Extensions.DependencyInjection` NuGet package reference to
    the `AutofacSample` project, as illustrated in the following screenshot:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Autofac.Extensions.DependencyInjection` NuGet包引用添加到`AutofacSample`项目中，如图所示：
- en: '![Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – 添加Autofac.Extensions.DependencyInjection NuGet包'
- en: '](img/Figure_5.5_B18507.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B18507.jpg)'
- en: Figure 5.5 – Adding the Autofac.Extensions.DependencyInjection NuGet package
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.5 – 添加Autofac.Extensions.DependencyInjection NuGet包
- en: 'We need to register `AutofacServiceProviderFactory` with `ConfigureHostBuilder`
    so that the runtime will use the Autofac IoC container. In `Program.cs`, register
    the Autofac SP factory, as shown in the following code snippet:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`AutofacServiceProviderFactory`与`ConfigureHostBuilder`注册，以便运行时使用Autofac
    IoC容器。在`Program.cs`中，注册Autofac SP工厂，如下面的代码片段所示：
- en: '[PRE97]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, let''s register the `IWeatherProvider` service that we used in the *Types
    of DI* section with the Autofac container. Call the `ConfigureContainer` method
    on the `ConfigureHostBuilder` property of `WebApplicationBuilder` in `Program.cs`
    to register `IWeatherProvider` with the `WeatherProvider` implementation, as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将我们在*DI类型*部分使用的`IWeatherProvider`服务注册到Autofac容器中。在`Program.cs`中，通过`WebApplicationBuilder`的`ConfigureHostBuilder`属性的`ConfigureContainer`方法将`IWeatherProvider`与`WeatherProvider`实现注册，如下所示：
- en: '[PRE98]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Similar to the default .NET IoC container, we get the `IWeatherForecast` service
    injected into the `WeatherForecastController` controller, as shown in the following
    code snippet:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与默认.NET IoC容器类似，我们将`IWeatherForecast`服务注入到`WeatherForecastController`控制器中，如下面的代码片段所示：
- en: '[PRE99]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, when you run the project and navigate to the `https://localhost:7184/WeatherForecast`
    **Uniform Resource Identifier** (**URI**), you will see the output in the browser,
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行项目并导航到`https://localhost:7184/WeatherForecast` **统一资源标识符** (**URI**)时，你将在浏览器中看到以下输出：
- en: '![Figure 5.6 – Final output for the container'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 容器的最终输出'
- en: '](img/Figure_5.6_B18507.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.6_B18507.jpg)'
- en: Figure 5.6 – Final output for the container
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 容器的最终输出
- en: In the previous example, we have seen the use of the third-party Autofac IoC
    container in place of the default container provided by .NET 6.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了使用第三方Autofac IoC容器代替.NET 6提供的默认容器。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the concepts of DI, which helps to write loosely
    coupled, more testable, and more readable code. This chapter covered the types
    of DI and how they are supported in ASP.NET Core 6\. We have also seen how object
    lifetime is managed with different types of registrations. This chapter also introduced
    you to some of the popular third-party IoC containers available to further explore.
    We will be using the concepts learned in this chapter to build our e-commerce
    application. In [*Chapter 15*](B18507_15_Epub.xhtml#_idTextAnchor1803), *Testing*,
    we will also see how DI can help with testability.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了DI的概念，这有助于编写松散耦合、更易于测试和更易于阅读的代码。本章涵盖了DI的类型以及它们如何在ASP.NET Core 6中得到支持。我们还看到了如何使用不同类型的注册来管理对象的生命周期。本章还向您介绍了一些流行的第三方IoC容器，以进一步探索。我们将使用本章学到的概念来构建我们的电子商务应用程序。在[*第15章*](B18507_15_Epub.xhtml#_idTextAnchor1803)的*测试*中，我们还将看到DI如何帮助提高可测试性。
- en: As recommended in [*Chapter 1*](B18507_01_Epub.xhtml#_idTextAnchor020), *Designing
    and Architecting the Enterprise Application*, under the *Separation of concerns/single
    - responsibility architecture* section, we always try to have services registered
    via interfaces. This will help with changing the concrete implementation at any
    time without changing the client implementation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章*](B18507_01_Epub.xhtml#_idTextAnchor020)中建议的，在*关注点分离/单一责任架构*部分，我们总是尝试通过接口注册服务。这将有助于在任何时候更改具体实现，而不会更改客户端实现。
- en: In the next chapter, we will learn how to configure .NET 6 and understand the
    different configurations while learning how to build a custom one.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何配置.NET 6并了解不同的配置，同时学习如何构建自定义配置。
- en: Questions
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following is not a framework service?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是框架服务？
- en: a. `IConfiguration`
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: a. `IConfiguration`
- en: b. `IApplicationBuilder`
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: b. `IApplicationBuilder`
- en: c. `IWeatherService`
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: c. `IWeatherService`
- en: d. `IWebHostEnvironment`
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: d. `IWebHostEnvironment`
- en: '**Answer: c**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: 'True or false: DI is one of the mechanisms to achieve IoC.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：DI是实现IoC的一种机制。
- en: a. True
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: a. 真的
- en: b. False
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: b. 假的
- en: '**Answer: a**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: 'True or false: An injected service can depend on a service that has a shorter
    life span than its own.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：注入的服务可以依赖于生命周期比其短的服务。
- en: a. True
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: a. 真的
- en: b. False
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: b. 假的
- en: '**Answer: b**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: Which of the following is not a valid lifetime scope of ASP.NET Core 6 IoC container?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是ASP.NET Core 6 IoC容器的有效生命周期范围？
- en: a. Scoped
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: a. 作用域
- en: b. Singleton
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: b. 单例
- en: c. Transient
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: c. 持久
- en: d. Dynamic
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: d. 动态
- en: '**Answer: d**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：d**'
