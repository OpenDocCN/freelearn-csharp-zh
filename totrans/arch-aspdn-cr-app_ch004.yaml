- en: 3 Architectural Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 个架构原则
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，位于“EARLY
    ACCESS SUBSCRIPTION”下）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file11.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file11.png)'
- en: 'This chapter delves into fundamental architectural principles: pillars of contemporary
    software development practices. These principles help us create flexible, resilient,
    testable, and maintainable code.We can use these principles to stimulate critical
    thinking, fostering our ability to evaluate trade-offs, anticipate potential issues,
    and create solutions that stand the test of time by influencing our decision-making
    process and helping our design choices.As we embark on this journey, we constantly
    refer to those principles throughout the book, particularly the SOLID principles,
    which improve our ability to build flexible and robust software systems.In this
    chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了基本架构原则：当代软件开发实践支柱。这些原则帮助我们创建灵活、健壮、可测试和可维护的代码。我们可以使用这些原则来激发批判性思维，培养我们评估权衡、预测潜在问题以及通过影响我们的决策过程和帮助我们的设计选择来创建经得起时间考验的解决方案。在我们踏上这段旅程时，我们会在整本书中不断参考这些原则，特别是
    SOLID 原则，这些原则提高了我们构建灵活和健壮软件系统的能力。在本章中，我们将涵盖以下主题：
- en: The separation of concerns (SoC) principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）原则
- en: The **DRY** principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRY** 原则'
- en: The **KISS** principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KISS** 原则'
- en: The **SOLID** principles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOLID** 原则'
- en: 'We also revise the following notions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修订了以下概念：
- en: Covariance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协方差
- en: Contravariance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆变
- en: Interfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Separation of concerns (SoC)
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）
- en: As its name implies, the idea is to separate our software into logical blocks,
    each representing a concern. A “concern” refers to a specific aspect of a program.
    It’s a particular interest or focus within a system that serves a distinct purpose.
    Concerns could be as broad as data management, as specific as user authentication,
    or even more specific, like copying an object into another. The Separation of
    Concerns principle suggests that each concern should be isolated and managed separately
    to improve the system’s maintainability, modularity, and understandability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这个想法是将我们的软件分成逻辑块，每个块代表一个关注点。一个“关注点”指的是程序的一个特定方面。它是在系统中服务于特定目的的特定兴趣或焦点。关注点可以是数据管理这样广泛的，也可以是用户身份验证这样具体的，甚至更具体，如将对象复制到另一个对象中。关注点分离原则建议每个关注点都应该被隔离并单独管理，以提高系统的可维护性、模块化和可理解性。
- en: The Separation of Concerns principle applies to all programming paradigms. In
    a nutshell, this principle means factoring a program into the correct pieces.
    For example, modules, subsystems, and microservices are macro-pieces, while classes
    and methods are smaller pieces.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）原则适用于所有编程范式。简而言之，这个原则意味着将程序分解为正确的部分。例如，模块、子系统和微服务是宏观部分，而类和方法是更小的部分。
- en: 'By correctly separating concerns, we can prevent changes in one area from affecting
    others, allow for more efficient code reuse, and make it easier to understand
    and manage different parts of a system independently.Here are a few examples:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正确地分离关注点，我们可以防止一个区域的变化影响其他区域，允许更高效的代码重用，并使独立理解和管理工作系统的不同部分更容易。以下是一些示例：
- en: Security and logging are cross-cutting concerns.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性和日志记录是跨切面关注点。
- en: Rendering a user interface is a concern.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染用户界面是一个关注点。
- en: Handling an HTTP request is a concern.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求是一个关注点。
- en: Copying an object into another is a concern.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象复制到另一个对象中是一个关注点。
- en: Orchestrating a distributed workflow is a concern.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调分布式工作流是一个关注点。
- en: Before moving to the DRY principle, it is imperative to consider concerns when
    dividing software into pieces to create cohesive units. A good separation of concerns
    helps create modular designs and face design dilemmas more effectively, leading
    to a maintainable application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向 DRY 原则之前，考虑在将软件划分为部分以创建连贯单元时的关注点是至关重要的。良好的关注点分离有助于创建模块化设计，更有效地面对设计难题，从而实现可维护的应用程序。
- en: Don’t repeat yourself (DRY)
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）
- en: 'The DRY principle advocates the separation of concerns principle and aims to
    eliminate redundancy in code as well. It promotes the idea that each piece of
    knowledge or logic should have a single, unambiguous representation within a system.So,
    when you have duplicated logic in your system, encapsulate it and reuse that new
    encapsulation in multiple places instead. If you find yourself writing the same
    or similar code in multiple places, refactor that code into a reusable component
    instead. Leverage functions, classes, modules, or other abstractions to refactor
    the code.Adhering to the DRY principle makes your code more maintainable, less
    error-prone, and easier to modify because a change in logic or bug fix needs to
    be made in only one place, reducing the likelihood of introducing errors or inconsistencies.However,
    it is imperative to regroup duplicated logic by concern, not only by the similarities
    of the code itself. Let’s look at those two classes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: DRY原则倡导关注点分离原则，并旨在消除代码中的冗余。它提倡每个知识或逻辑片段在系统中应有一个单一、明确的表示。因此，当你系统中存在重复的逻辑时，将其封装，并在多个地方重用这个新的封装。如果你发现自己多处编写相同的或类似的代码，将那段代码重构为一个可重用的组件。利用函数、类、模块或其他抽象来重构代码。遵循DRY原则可以使代码更易于维护、更少出错、更容易修改，因为逻辑更改或错误修复只需要在一个地方进行，从而降低了引入错误或不一致的可能性。然而，必须根据关注点重新组合重复的逻辑，而不仅仅是根据代码本身的相似性。让我们看看这两个类：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code is very similar, but encapsulating a single class or method could
    very well be a mistake. Why? Keeping two separate classes is more logical because
    the admin program can have different reasons for modification compared to the
    public program.However, encapsulating the list logic into the `IBookPresenter`
    interface could make sense. It would allow us to react differently to both types
    of users if needed, like filtering the admin panel list but doing something different
    in the public section. One way to do this is by replacing the `foreach` loop with
    a `presenter` `DisplayListAsync(books)` call, like the following highlighted code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常相似，但封装单个类或方法可能是一个错误。为什么？保持两个独立的类更合理，因为管理程序与公共程序相比可能有不同的修改原因。然而，将列表逻辑封装到`IBookPresenter`接口中是有意义的。如果需要，它将允许我们对两种类型的用户做出不同的反应，例如过滤管理面板列表，但在公共部分做不同的事情。实现这一点的其中一种方法是将`foreach`循环替换为`presenter`的`DisplayListAsync(books)`调用，如下面突出显示的代码所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is more to those simple implementations to discuss, like the possibility
    of supporting multiple implementations of the interfaces for added flexibility,
    but let’s keep some subjects for further down the book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单实现之外还有更多内容可以讨论，比如支持多个接口实现以增加灵活性，但让我们把一些主题留到书的后半部分。
- en: When you don’t know how to name a class or a method, you may have identified
    a problem with your separation of concerns. This is a good indicator that you
    should go back to the drawing board. Nevertheless, naming is hard, so sometimes,
    that’s just it.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你不知道如何命名一个类或方法时，你可能已经发现了关注点分离的问题。这是一个很好的迹象，表明你应该回到起点。然而，命名是困难的，所以有时候，就是这样。
- en: Keeping our code DRY while following the separation of concerns principles is
    imperative. Otherwise, what may seem like a good move could become a nightmare.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循关注点分离原则的同时保持我们的代码DRY是至关重要的。否则，可能看似不错的举动可能会变成一场噩梦。
- en: Keep it simple, stupid (KISS)
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单，愚蠢（KISS）
- en: This is another straightforward principle, yet one of the most important. Like
    in the real world, the more moving pieces, the more chances something breaks.
    This principle is a design philosophy that advocates for simplicity in design.
    It emphasizes the idea that systems work best when they are kept simple rather
    than made complex.Striving for simplicity might involve writing shorter methods
    or functions, minimizing the number of parameters, avoiding over-architecting,
    and choosing the simplest solution to solve a problem.Adding interfaces, abstraction
    layers, and complex object hierarchy adds complexity, but are the added benefits
    better than the underlying complexity? If so, they are worth it; otherwise, they
    are not.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单直接的原则，但也是最重要的原则之一。就像在现实世界中一样，移动部件越多，出问题的机会就越多。这个原则是一种设计哲学，主张设计简单化。它强调系统在保持简单而不是变得复杂时工作得最好。追求简单可能涉及编写更短的方法或函数、最小化参数数量、避免过度设计，并选择最简单的解决方案来解决问题。添加接口、抽象层和复杂的对象层次结构会增加复杂性，但这些附加的好处是否比底层复杂性更好？如果是的话，它们是值得的；如果不是，它们就不值得。
- en: As a guiding principle, when you can write the same program with less complexity,
    do it. This is also why predicting future requirements can often prove detrimental,
    as it may inadvertently inject unnecessary complexity into your codebase for features
    that might never materialize.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为指导原则，当你可以用更少的复杂性编写相同的程序时，就去做吧。这也是为什么预测未来需求有时可能会产生不利影响，因为它可能会无意中将不必要的复杂性注入到你的代码库中，而这些特性可能永远不会实现。
- en: We study design patterns in the book and design systems using them. We learn
    how to apply a high degree of engineering to our code, which can lead to over-engineering
    if done in the wrong context. Towards the end of the book, we circle back on the
    KISS principle when exploring the vertical slice architecture and request-endpoint-response
    (REPR) patterns.Next, we delve into the SOLID principles, which are the key to
    flexible software design.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中学习设计模式，并使用它们来设计系统。我们学习如何将高度工程化应用于我们的代码，如果在不正确的环境中进行，可能会导致过度工程化。在书的结尾，我们在探讨垂直切片架构和请求-端点-响应（REPR）模式时，回到了KISS原则。接下来，我们深入探讨SOLID原则，这是灵活软件设计的关键。
- en: The SOLID principles
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'SOLID is an acronym representing five principles that extend the basic OOP
    concepts of **Abstraction**, **Encapsulation**, **Inheritance**, and **Polymorphism**.
    They add more details about what to do and how to do it, guiding developers toward
    more robust and flexible designs.It is crucial to remember that these are just
    guiding principles, not rules that you must follow, no matter what. Think about
    what makes sense for your specific project. If you’re building a small tool, it
    might be acceptable not to follow these principles as strictly as you would for
    a crucial business application. In the case of business-critical applications,
    it might be a good idea to stick to them more closely. Still, it’s usually a smart
    move to follow them, no matter the size of your app. That’s why we’re discussing
    them before diving into design patterns.The SOLID acronym represents the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一个代表五个原则的缩写，这些原则扩展了基本面向对象编程（OOP）概念——**抽象**、**封装**、**继承**和**多态**。它们提供了更多关于做什么和如何做的细节，指导开发者走向更稳健和灵活的设计。重要的是要记住，这些只是指导原则，不是你必须遵循的规则，无论什么情况。考虑一下对你具体项目有意义的事情。如果你正在构建一个小工具，可能不需要像构建关键业务应用那样严格遵循这些原则。在业务关键应用的情况下，可能更接近地遵循它们是个好主意。然而，无论你的应用大小如何，通常遵循它们都是明智之举。这就是为什么我们在深入研究设计模式之前讨论它们。SOLID缩写代表以下内容：
- en: '**S**ingle responsibility principle'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**'
- en: '**O**pen/Closed principle'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**'
- en: '**L**iskov substitution principle'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**'
- en: '**I**nterface segregation principle'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**'
- en: '**D**ependency inversion principle'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**'
- en: By following these principles, your systems should become easier to test and
    maintain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些原则，你的系统应该变得更容易测试和维护。
- en: Single responsibility principle (SRP)
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: 'Essentially, the SRP means that a single class should hold one, and only one,
    responsibility, leading me to the following quote:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，SRP意味着一个类应该只持有一个，且仅有一个职责，这让我想到了以下引言：
- en: '*“There should never be more than one reason for a class to change.”— Robert
    C. Martin, originator of the single responsibility principle*'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“一个类不应该有超过一个改变的理由。”——罗伯特·C·马丁，单一职责原则的创始人*'
- en: 'OK, but why? Before answering, take a moment to remember a project you’ve worked
    on where someone changed one or more requirements along the way. I recall several
    projects that would have benefited from this principle. Now, imagine how much
    simpler it would have been if each part of your system had just one job: one reason
    to change.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但为什么？在回答这个问题之前，花一点时间回忆一下你曾经参与过的项目，其中有人在一开始就改变了要求。我想起了几个可以从这个原则中受益的项目。现在，想象一下如果系统的每个部分都只有一个任务：一个改变的理由，那会简单多少。
- en: 'Software maintainability problems can be due to both tech and non-tech people.
    Nothing is purely black or white—most things are a shade of gray. The same applies
    to software design: always do your best, learn from your mistakes, and stay humble
    (a.k.a. continuous improvement).'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件可维护性问题可能是由技术和非技术人员共同造成的。没有什么是纯粹的黑或白——大多数事情都是灰色的一抹。软件设计也是如此：总是尽力而为，从错误中学习，保持谦逊（即持续改进）。
- en: By understanding that applications are born to change, you will feel better
    when that happens, while the SRP helps mitigate the impact of changes. For example,
    it helps make our classes more readable and reusable and to create more flexible
    and maintainable systems. Moreover, when a class does only one thing, it’s easier
    to see how changes will affect the system, which is more challenging with complex
    classes since one change might break other parts. Furthermore, fewer responsibilities
    mean less code. Less code is easier to understand, helping you grasp that part
    of the software more quickly.Let’s try this out in action.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解应用程序天生就会变化，当这种情况发生时，你会感觉更好，而SRP有助于减轻变化的影响。例如，它有助于使我们的类更易于阅读和重用，并创建更灵活、更易于维护的系统。此外，当一个类只做一件事时，更容易看到变化将如何影响系统，这对于复杂的类来说更具挑战性，因为一个变化可能会破坏其他部分。此外，职责越少，代码越少。代码越少，就越容易理解，帮助你更快地掌握软件的这一部分。让我们在实际行动中尝试一下。
- en: Project – Single Responsibility
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 – 单一职责
- en: 'First, we look at the `Product` class used in both code samples. That class
    represents a simple fictive product:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看两个代码示例中使用的`Product`类。该类代表一个简单的虚构产品：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code sample has no implementation because it is irrelevant to understanding
    the SRP. We focus on the class API instead. Please assume we implemented the data-access
    logic using your favorite database.
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码示例没有实现，因为它与理解SRP无关。我们专注于类API。请假设我们使用您最喜欢的数据库实现了数据访问逻辑。
- en: 'The following class breaks the SRP:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类违反了SRP：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What does not conform to the SRP in the preceding class? By reading the name
    of the methods, we can extract two responsibilities:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类中哪些不符合SRP？通过阅读方法的名称，我们可以提取两个职责：
- en: Handling public products (highlighted code).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理公共产品（高亮代码）。
- en: Handling private products.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理私有产品。
- en: 'The `ProductRepository` class mixes public and private product logic. From
    that API alone, there are many possibilities where an error could lead to leaking
    restricted data to public users. That is also true because the class exposes the
    private logic to the public-facing consumers; someone else could make a mistake.We
    are ready to rethink the class now that we identified the responsibilities. We
    know it has two responsibilities, so breaking the class into two sounds like an
    excellent first step. Let’s start with extracting a public API:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductRepository`类混合了公共和私有产品逻辑。仅从该API来看，就有许多可能导致错误并泄露受限数据给公共用户的情况。这也因为该类向面向公众的消费者公开了私有逻辑；其他人可能会犯错。现在我们已经确定了职责，我们可以重新思考这个类。我们知道它有两个职责，所以将类拆分为两个听起来是一个很好的第一步。让我们从提取公共API开始：'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `PublicProductReader` class now contains only two methods: `GetAllAsync`
    and `GetOneAsync`. When reading the name of the class and its methods, it is clear
    that the class handles only public product data. By lowering the complexity of
    the class, we made it easier to understandNext, let’s do the same for the private
    products:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`PublicProductReader`类只包含两个方法：`GetAllAsync`和`GetOneAsync`。当阅读类的名称及其方法时，很明显该类只处理公共产品数据。通过降低类的复杂性，我们使其更容易理解。接下来，让我们对私有产品做同样的处理：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `PrivateProductRepository` class follows the same pattern. It includes the
    read methods, named the same as the `PublicProductReader` class, and the mutation
    methods only users with private access can use.We improved our code’s readability,
    flexibility, and security by splitting the initial class into two. However, one
    thing to be careful about with the SRP is not to over-separate classes. The more
    classes in a system, the more complex assembling the system can become, and the
    harder it can be to debug and follow the execution paths. On the other hand, many
    well-separated responsibilities should lead to a better, more testable system.It
    is tough to define one hard rule that defines “one reason” or “a single responsibility”.
    However, as a rule of thumb, aim at packing a cohesive set of functionalities
    in a single class that revolves around its responsibility. You should strip out
    any excess logic and add missing pieces.A good indicator of the SRP violation
    is when you don’t know how to name an element, which points towards the fact that
    the element should not reside there, that you should extract it, or that you should
    split it into multiple smaller pieces.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrivateProductRepository` 类遵循相同的模式。它包括读取方法，方法名与 `PublicProductReader` 类相同，以及只有具有私有访问权限的用户才能使用的修改方法。通过将初始类拆分为两个，我们提高了代码的可读性、灵活性和安全性。然而，在使用单一责任原则（SRP）时，需要注意的一点是不要过度拆分类。系统中的类越多，组装系统可能变得越复杂，调试和跟踪执行路径可能越困难。另一方面，许多职责分离良好的系统应该导致更好的、更易于测试的系统。很难定义一个硬性规则来定义“一个原因”或“单一责任”。然而，作为一个经验法则，目标是将围绕其责任的单个类中的功能集打包在一起。你应该去除任何多余的逻辑并添加缺失的部分。SRP
    违规的一个良好指标是当你不知道如何命名一个元素时，这表明该元素不应该位于那里，你应该将其提取出来，或者将其拆分为多个更小的部分。'
- en: Using precise names for variables, methods, classes, and other elements is very
    important and should not be overlooked.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为变量、方法、类和其他元素使用精确的名称非常重要，不应被忽视。
- en: Another good indicator is when a method becomes too big, maybe containing many
    `if` statements or loops. In that case, you can split that method into multiple
    smaller methods, classes, or any other construct that suits your requirements.
    That should make the code easier to read and make the initial method’s body cleaner.
    It often also helps you get rid of useless comments and improve testability. Next,
    we explore how to change behaviors without modifying code, but before that, let’s
    look at interfaces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个良好指标是当一个方法变得太大时，可能包含许多 `if` 语句或循环。在这种情况下，你可以将那个方法拆分为多个更小的方法、类或其他适合你要求的构造。这应该使代码更容易阅读，并使初始方法体更清晰。这通常也有助于你去除无用的注释并提高可测试性。接下来，我们将探讨如何在不修改代码的情况下更改行为，但在那之前，让我们看看接口。
- en: Open/Closed principle (OCP)
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开闭原则（OCP）
- en: 'Let’s start this section with a quote from Bertrand Meyer, the person who first
    wrote the term open/closed principle in 1988:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从1988年首次将“开闭原则”这个术语写入的人，伯特兰·梅耶（Bertrand Meyer）的一句话开始这个部分：
- en: '*“Software entities (classes, modules, functions, and so on) should be open
    for extension but closed for modification.”*'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“软件实体（类、模块、函数等）应该对扩展开放，但对修改封闭。”*'
- en: OK, but what does that mean? It means you should be able to change the class
    behaviors from the outside without altering the code.As a bit of history, the
    first appearance of the OCP in 1988 referred to inheritance, and OOP has evolved
    a lot since then. Inheritance is still useful, but you should be careful as it
    is easily misused. Inheritance creates direct coupling between classes. You should,
    most of the time, opt for composition over inheritance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但这意味着什么？这意味着你应该能够在不更改代码的情况下从外部更改类的行为。从历史的角度来看，1988年OCP（开闭原则）首次出现时指的是继承，自那时起面向对象编程已经发展了很多。继承仍然有用，但你应该小心，因为它很容易被误用。继承在类之间创建直接的耦合。大多数时候，你应该选择组合而不是继承。
- en: “Composition over inheritance” is a principle that suggests it’s better to build
    objects by combining simple, flexible parts (composition) rather than by inheriting
    properties from a larger, more complex object (inheritance).
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “组合优于继承”是一个原则，它建议通过组合简单、灵活的部件（组合）来构建对象，而不是通过从更大的、更复杂的对象继承属性（继承）。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think of it like building with LEGO® blocks. It’s easier to build and adjust
    your creation if you put together small blocks (composition) rather than trying
    to alter a big, single block that already has a fixed shape (inheritance).
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想象一下用乐高®积木来建造。如果你将小积木组合起来（组合），而不是试图改变一个已经具有固定形状的大积木（继承），那么建造和调整你的创作会更容易。
- en: Meanwhile, we explore three versions of a business process to illustrate the
    OCP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们探索了业务流程的三个版本，以说明 OCP。
- en: Project – Open Close
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 – 开放封闭
- en: 'First, we look at the `Entity` and `EntityRepository` classes used in the code
    samples:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看代码示例中使用的 `Entity` 和 `EntityRepository` 类：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Entity` class represents a simple fictive entity with no properties; consider
    it anything you’d like. The `EntityRepository` class has a single `CreateAsync`
    method that inserts an instance of an `Entity` in a database (if it was implemented).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity` 类代表一个没有属性的简单虚构实体；可以将其视为任何你想要的东西。`EntityRepository` 类有一个单一的 `CreateAsync`
    方法，用于将一个 `Entity` 实例插入到数据库中（如果已实现）。'
- en: The code sample has few implementation details because it is irrelevant to understanding
    the OCP. Please assume we implemented the `CreateAsync` logic using your favorite
    database.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码示例中包含很少的实现细节，因为它与理解 OCP 无关。请假设我们使用你喜欢的数据库实现了 `CreateAsync` 逻辑。
- en: 'For the rest of the sample, we refactor the `EntityService` class, beginning
    with a version that inherits the `EntityRepository` class, breaking the OCP:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的示例，我们重构了 `EntityService` 类，从一个继承 `EntityRepository` 类的版本开始，打破了 OCP：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As the namespace implies, the preceding `EntityService` class offers no composability.
    Moreover, we tightly coupled it with the `EntityRepository` class. Since we just
    covered the *composition over inheritance* principle, we can quickly isolate the
    problem: **inheritance**.As the next step to fix this mess, let’s extract a private
    `_repository` field to hold an `EntityRepository` instance instead:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如命名空间所暗示的，前面的 `EntityService` 类没有提供可组合性。此外，我们将其与 `EntityRepository` 类紧密耦合。由于我们刚刚覆盖了“组合优于继承”的原则，我们可以快速隔离问题：**继承**。作为解决这个混乱的下一步，让我们提取一个私有
    `_repository` 字段来保存一个 `EntityRepository` 实例，如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now the `EntityService` is composed of an `EntityRepository` instance, and
    there is no more inheritance. However, we still tightly coupled both classes,
    and it is impossible to change the behavior of the `EntityService` this way without
    changing its code.To fix our last issues, we can inject an `EntityRepository`
    instance into the class constructor where we set our private field like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`EntityService` 由一个 `EntityRepository` 实例组成，并且不再有继承。然而，我们仍然紧密耦合了这两个类，并且不改变其代码就无法以这种方式改变
    `EntityService` 的行为。为了解决我们最后的问题，我们可以在设置我们的私有字段的地方注入一个 `EntityRepository` 实例，如下所示：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the preceding change, we broke the tight coupling between the `EntityService`
    and the `EntityRepository` classes. We can also control the behavior of the `EntityService`
    class from the outside by deciding what instance of the `EntityRepository` class
    we inject into the `EntityService` constructor. We could even go further by leveraging
    an abstraction instead of a concrete class and explore this subsequently while
    covering the DIP.As we just explored, the OCP is a super powerful principle, yet
    simple, that allows controlling an object from the outside. For example, we could
    create two instances of the `EntityService` class with different `EntityRepository`
    instances that connect to different databases. Here’s a rough example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的更改，我们打破了 `EntityService` 和 `EntityRepository` 类之间的紧密耦合。我们还可以通过决定将哪个 `EntityRepository`
    类的实例注入到 `EntityService` 构造函数中来从外部控制 `EntityService` 类的行为。我们甚至可以通过利用抽象而不是具体类来更进一步，并在覆盖
    DIP 的同时探索这一点。正如我们刚刚探索的，OCP 是一个超级强大、简单且允许从外部控制对象的原则。例如，我们可以创建两个具有不同 `EntityRepository`
    实例的 `EntityService` 类实例，这些实例连接到不同的数据库。以下是一个粗略的示例：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, assuming we implemented the `EntityRepository` class
    and configured `repository1` and `repository2` differently, the result of executing
    the `ComplexBusinessProcessAsync` method on `service1` and `service2` would create
    the entity in two different databases. The behavior change between the two instances
    happened without changing the code of the `EntityService` class; composition:
    1, inheritance: 0.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，假设我们实现了 `EntityRepository` 类并配置了 `repository1` 和 `repository2`，那么在 `service1`
    和 `service2` 上执行 `ComplexBusinessProcessAsync` 方法的结果将在两个不同的数据库中创建实体。两个实例之间的行为变化是在不改变
    `EntityService` 类代码的情况下发生的；组合：1，继承：0。
- en: We explore the **Strategy pattern**—the best way of implementing the OCP—in
    *Chapter 5*, *Strategy, Abstract Factory, and Singleton*. We revisit that pattern
    and also learn to assemble our program’s well-designed pieces and sew them together
    using dependency injection in *Chapter 6*, *Dependency Injection*.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在*第五章*，*策略、抽象工厂和单例*中探讨了**策略模式**——实现OCP的最佳方式。在*第六章*，*依赖注入*中，我们重新审视了该模式，并学习了如何使用依赖注入将程序精心设计的组件组装在一起。
- en: Next, we explore the principle we can perceive as the most complex of the five,
    yet the one we will use the less.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索我们将其视为五个中最复杂的一个，但我们将使用得最少的原则。
- en: Liskov substitution principle (LSP)
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则（LSP）
- en: The Liskov Substitution Principle (LSP) states that in a program, if we replace
    an instance of a superclass (supertype) with an instance of a subclass (subtype),
    the program should not break or behave unexpectedly.Imagine we have a base class
    called `Bird` with a function called `Fly`, and we add the `Eagle` and `Penguin`
    subclasses. Since a penguin can’t fly, replacing an instance of the `Bird` class
    with an instance of the `Penguin` subclass might cause problems because the program
    expects all birds to be able to fly.So, according to the LSP, our subclasses should
    behave so the program can still work correctly, even if it doesn’t know which
    subclass it’s using, preserving system stability.Before moving on with the LSP,
    let’s look at covariance and contravariance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则（LSP）指出，在一个程序中，如果我们用一个子类（子类型）的实例替换一个超类（超类型）的实例，程序不应该崩溃或出现意外的行为。想象我们有一个名为`Bird`的基类，它有一个名为`Fly`的函数，我们添加了`Eagle`和`Penguin`子类。由于企鹅不能飞，用`Penguin`子类的实例替换`Bird`类的实例可能会出现问题，因为程序期望所有鸟类都能飞。所以，根据LSP，我们的子类应该表现出使程序仍然可以正确工作的行为，即使它不知道正在使用哪个子类，从而保持系统稳定性。在继续讨论LSP之前，让我们看看协变和逆变。
- en: Covariance and contravariance
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协变和逆变
- en: 'We won’t go too deep into this, so we don’t move too far away from the LSP,
    but since the formal definition mentions them, we must understand these at least
    a minimum.Covariance and contravariance represent specific polymorphic scenarios.
    They allow reference types to be converted into other types implicitly. They apply
    to generic type arguments, delegates, and array types. Chances are, you will never
    need to remember this, as most of it is implicit, yet, here’s an overview:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这一点，所以不会偏离LSP太远，但既然正式定义提到了它们，我们至少要理解这些。协变和逆变代表特定的多态场景。它们允许引用类型隐式地转换为其他类型。它们适用于泛型类型参数、委托和数组类型。你可能永远不会需要记住这一点，因为其中大部分是隐式的，但这里有一个概述：
- en: '**Covariance (**`out`**)** enables us to use a more derived type (a subtype)
    instead of the supertype. Covariance is usually applicable to method return types.
    For instance, if a base class method returns an instance of a class, the equivalent
    method of a derived class can return an instance of a subclass.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协变（**`out`**）**使我们能够使用更派生的类型（子类型）而不是超类型。协变通常适用于方法返回类型。例如，如果一个基类方法返回一个类的实例，那么派生类中等效的方法可以返回子类的实例。'
- en: '**Contravariance (**`in`**)** is the reverse situation. It allows a less derived
    type (a supertype) to be used instead of the subtype. Contravariance is usually
    applicable to method argument types. If a method of a base class accepts a parameter
    of a particular class, the equivalent method of a derived class can accept a parameter
    of a superclass.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆变（**`in`**）**是相反的情况。它允许使用较少派生的类型（超类型）代替子类型。逆变通常适用于方法参数类型。如果一个基类的方法接受特定类的参数，那么派生类中等效的方法可以接受超类的参数。'
- en: 'Let’s use some code to understand this more, starting with the model we are
    using:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来更好地理解这一点，从我们使用的模型开始：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Simple class hierarchy, we have a `TwoHandedSword` class that inherits from
    the `Sword` class and the `Sword` class that inherits from the `Weapon` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的类层次结构，我们有一个`TwoHandedSword`类，它继承自`Sword`类，而`Sword`类继承自`Weapon`类。
- en: Covariance
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 协变
- en: 'To demo covariance, we leverage the following generic interface:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示协变，我们利用以下泛型接口：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In C#, the `out` modifier, the highlighted code, explicitly specifies that
    the generic parameter `T` is covariant. Covariance applies to return types, hence
    the `Get` method that returns the generic type `T`.Before testing this out, we
    need an implementation. Here’s a barebone one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`out`修饰符，高亮显示的代码，明确指定了泛型参数`T`是协变的。协变适用于返回类型，因此`Get`方法返回泛型类型`T`。在测试之前，我们需要一个实现。这里有一个简单的实现：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The highlighted code, which represents the `T` parameter, is of type `Sword`,
    a subclass of `Weapon`. Since covariance means you can **return (output) the instance
    of a subtype as its supertype**, using the `Sword` subtype allows exploring this
    with the `Weapon` supertype. Here’s the xUnit fact that demonstrates covariance:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码，代表 `T` 参数，其类型为 `Sword`，是 `Weapon` 的子类。由于协变意味着你可以 **返回（输出）子类的实例作为其超类型**，使用
    `Sword` 子类允许你用 `Weapon` 超类型来探索这一点。以下是一个演示协变的 xUnit 事实：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The highlighted line represents covariance, showing that we can implicitly convert
    the `ICovariant<Sword>` subtype to the `ICovariant<Weapon>` supertype.The code
    after that showcases what happens with that polymorphic change. For example, the
    `Get` method of the `weaponGetter` object returns a `Weapon` type, not a `Sword`,
    even if the underlying instance is a `SwordGetter` object. However, that `Weapon`
    is, in fact, a `Sword`, as the assertions demonstrate.Next, let’s explore contravariance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行代表协变，显示我们可以隐式地将 `ICovariant<Sword>` 子类型转换为 `ICovariant<Weapon>` 超类型。随后的代码展示了这种多态变化会发生什么。例如，`weaponGetter`
    对象的 `Get` 方法返回 `Weapon` 类型，而不是 `Sword`，即使底层实例是 `SwordGetter` 对象。然而，实际上这个 `Weapon`
    是一个 `Sword`，正如断言所证明的。接下来，让我们探索逆变。
- en: '**Contravariance**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逆变**'
- en: 'To demo covariance, we leverage the following generic interface:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示协变，我们利用以下泛型接口：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In C#, the `in` modifier, the highlighted code, explicitly specifies that the
    generic parameter `T` is contravariant. Contravariance applies to input types,
    hence the `Set` method that takes the generic type `T` as a parameter.Before testing
    this out, we need an implementation. Here’s a barebone one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`in` 修饰符，突出的代码，明确指定泛型参数 `T` 是逆变的。逆变适用于输入类型，因此 `Set` 方法接受泛型类型 `T` 作为参数。在测试之前，我们需要一个实现。以下是一个简单的实现：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The highlighted code, which represents the `T` parameter, is of type `Weapon`,
    the topmost class in our model; other classes derive from it. Since contravariance
    means you can **input the instance of a subtype as its supertype**, using the
    `Weapon` supertype allows exploring this with the `Sword` and `TwoHandedSword`
    subtypes. Here’s the xUnit fact that demonstrates contravariance:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码，代表 `T` 参数，其类型为 `Weapon`，是我们模型中最顶层的类；其他类都从中派生。由于逆变意味着你可以 **输入子类的实例作为其超类型**，使用
    `Weapon` 超类型允许你用 `Sword` 和 `TwoHandedSword` 子类型来探索这一点。以下是一个演示逆变的 xUnit 事实：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The highlighted line represents contravariance. We can implicitly convert the
    `IContravariant<Weapon>` supertype to the `IContravariant<Sword>` subtype.The
    code after that showcases what happens with that polymorphic change. For example,
    the `Set` method of the `weaponSetter` object can take a `Weapon`, a **Sword**
    , or a `TwoHandedSword` instance because they are all subtypes of the `Weapon`
    type (or is the `Weapon` type itself).The same happens with the `swordSetter`
    instance, but it only takes a `Sword` or a `TwoHandedSword` instance, starting
    at the `Sword` type in the inheritance hierarchy because the compiler considers
    the `swordSetter` instance to be an `IContravariant<Sword>`, even if the underlying
    implementation is of the `WeaponSetter` type.Writing the following yields a compiler
    error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行代表逆变。我们可以隐式地将 `IContravariant<Weapon>` 超类型转换为 `IContravariant<Sword>` 子类型。随后的代码展示了这种多态变化会发生什么。例如，`weaponSetter`
    对象的 `Set` 方法可以接受 `Weapon`、**Sword** 或 `TwoHandedSword` 实例，因为它们都是 `Weapon` 类型的子类型（或者本身就是
    `Weapon` 类型）。同样，`swordSetter` 实例也接受 `Sword` 或 `TwoHandedSword` 实例，从继承层次结构中的 `Sword`
    类型开始，因为编译器认为 `swordSetter` 实例是 `IContravariant<Sword>` 类型，即使其底层实现是 `WeaponSetter`
    类型。编写以下代码会导致编译错误：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The error is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That means that for the compiler, `swordSetter` is of type `IContravariant<Sword>`,
    not `IContravariant<Weapon>`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于编译器来说，`swordSetter` 的类型是 `IContravariant<Sword>`，而不是 `IContravariant<Weapon>`。
- en: '**Note**'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I left a link in the *Further reading* section that explains covariance and
    contravariance if you want to know more since we just covered the basics here.
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在 *进一步阅读* 部分留下了一个链接，解释了协变和逆变，如果你想了解更多信息，因为我们在这里只介绍了基础知识。
- en: Now that we grazed covariance and contravariance, we are ready to explore the
    formal version of the LSP.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了协变和逆变，我们可以探索 LSP 的正式版本。
- en: The LSP explained
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LSP 的解释
- en: 'The LSP came from Barbara Liskov at the end of the ‘80s and was revisited during
    the ‘90s by both Liskov and Jeannette Wing to create the principle that we know
    and use today. It is also similar to *Design by contract*, by Bertrand Meyer.Next,
    let’s look at the formal subtype requirement definition:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: LSP是由Barbara Liskov在20世纪80年代末提出的，并在90年代由Liskov和Jeannette Wing重新审视，以创建我们今天所知道和使用的原则。它也与Bertrand
    Meyer的*设计合同*相似。接下来，让我们看看正式的子类型要求定义：
- en: '*Let ![img](img/file12.png) be a property provable about objects x of type
    T. Then, ![img](img/file13.png) should be true for objects y of type S, where
    S is a subtype of T.*'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*设![img](img/file12.png)是关于类型T的对象x的一个可证明的性质。那么，![img](img/file13.png)对于类型S的对象y应该是正确的，其中S是T的子类型。*'
- en: 'In simpler words, if `S` is a subtype of `T`, we can replace objects of type
    `T` with objects of type `S` without changing any of the expected behaviors of
    the program (correctness).The LSP adds the following signature requirements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果`S`是`T`的子类型，我们可以用`S`类型的对象替换`T`类型的对象，而不改变程序预期的任何行为（正确性）。LSP增加了以下签名要求：
- en: The parameters of methods in subtypes must be contravariant.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型中方法参数必须是逆变。
- en: The return type of methods in subtypes must be covariant.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型中方法返回类型必须是协变的。
- en: You can’t throw a new type of exception in subtypes.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在子类型中抛出一种新的异常类型。
- en: The first two rules are tough to violate without effort in C#.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在C#中，不费劲就违反前两条规则是困难的。
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Throwing a new type of exception in subtypes is also considered changing behaviors.
    You can, however, throw subtyped exceptions in subtypes because the existing consumers
    can handle them.
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在子类型中抛出一种新的异常类型也被视为改变行为。然而，你可以在子类型中抛出子类型异常，因为现有的消费者可以处理它们。
- en: 'The LSP also adds the following behavioral conditions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: LSP还增加了以下行为条件：
- en: '| **Conditions** | **Examples** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **条件** | **示例** |'
- en: '| Any precondition implemented in a supertype should yield the same outcome
    in its subtypes, but subtypes can be less strict about it, never more. | If a
    supertype validates that an argument cannot be `null` , the subtype could remove
    that validation but not add stricter validation rules. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 在超类型中实现的任何前置条件都应该在子类型中产生相同的结果，但子类型可以对此不那么严格，决不能更严格。| 如果超类型验证一个参数不能为`null`，则子类型可以移除该验证，但不能添加更严格的验证规则。|'
- en: '| Any postcondition implemented in a supertype should yield the same outcome
    in its subtypes, but subtypes can be more strict about it, never less. | If the
    supertype never returns `null`, the subtype should not return `null` either or
    risk breaking the consumers of the object that are not testing for `null`.If the
    supertype does not guarantee the returned value cannot be `null`, then a subtype
    could decide never to return `null`, making both instances interchangeable. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 在超类型中实现的任何后置条件都应该在子类型中产生相同的结果，但子类型可以对此更加严格，决不能更宽松。| 如果超类型永远不会返回`null`，则子类型也不应该返回`null`，否则会破坏未测试`null`的对象消费者。如果超类型不保证返回的值不能为`null`，则子类型可以决定永远不返回`null`，这样两个实例就可以互换。|'
- en: '| Subtypes must preserve the invariance of the supertype. | A subtype must
    pass all the tests written for the supertype, so there is no variance between
    them (they don’t vary/they react the same). |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 子类型必须保持超类型的不可变性。| 子类型必须通过为超类型编写的所有测试，因此它们之间没有差异（它们不变化/它们反应相同）。|'
- en: '| The history constraint dictates that what happens in the supertype must still
    occur in the subtype, and you can’t change this. | A subtype can add new properties
    (state) and methods (behaviors).A subtype must not modify the supertype state
    in any new way. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 历史约束规定，在超类型中发生的事情必须在子类型中发生，而且你不能改变这一点。| 子类型可以添加新的属性（状态）和方法（行为）。子类型不得以任何新的方式修改超类型状态。|'
- en: 'Table 3.1: LSP behavioral conditions'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1：LSP行为条件
- en: OK, at this point, you are right to feel that this is rather complex. Yet, rest
    assured that this is the less important of those principles because we are moving
    as far as we can from inheritance, so the LSP should not apply often.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这个时候，你可能会觉得这相当复杂。但请放心，这是那些原则中不那么重要的一个，因为我们正在尽可能远离继承，所以LSP不应该经常适用。
- en: 'We can summarize the LSP to:'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以将LSP总结为：
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In your subtypes, add new behaviors and states; don’t change existing ones.*'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在你的子类型中添加新的行为和状态；不要改变现有的行为。*'
- en: 'In a nutshell, applying the LSP allows us to swap an instance of a class for
    one of its subclasses without breaking anything.To make a LEGO® analogy: LSP is
    like swapping a 4x2 block with a 4x2 block with a sticker on it: neither the structure''s
    structural integrity nor the block''s role changed; the new block only has a new
    sticker state.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，应用LSP（Liskov替换原则）允许我们替换一个类的实例为其子类实例，而不会破坏任何东西。用乐高®的类比来说：LSP就像用一个带有贴纸的4x2积木替换一个普通的4x2积木：结构完整性以及积木的角色都没有改变；新的积木只是有一个新的贴纸状态。
- en: '**Tip**'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An excellent way of enforcing those behavioral constraints is automated testing.
    You can write a test suite and run it against all subclasses of a specific supertype
    to enforce the preservation of behaviors.
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 强制执行这些行为约束的一个绝佳方法是自动化测试。你可以编写一个测试套件，并对其针对特定超类所有子类的运行进行测试，以强制保持行为的一致性。
- en: Let’s jump into some code to visualize that in practice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来直观地展示这一点。
- en: Project – Liskov Substitution
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 – Liskov替换原则
- en: 'To demonstrate the LSP, we will explore some scenarios. Each scenario is a
    test class that follows the same structure:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示LSP，我们将探索一些场景。每个场景都是一个遵循相同结构的测试类：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code structure, the highlighted code changes for every test.
    The setup is simple; I use the test method to simulate code that a program could
    execute, and just by running the same code three times on different classes, each
    theory fails once:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码结构中，高亮显示的代码为每个测试而改变。设置很简单；我使用测试方法来模拟程序可能执行的代码，仅通过在三个不同的类上运行相同的代码三次，每个理论就会失败一次：
- en: The initial test passes
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始测试通过
- en: The test of a subtype respecting the LSP passes
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型尊重LSP的测试通过
- en: The test of a subtype violating the LSP fails.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型违反LSP的测试失败。
- en: The parameter `sut` is the subject under test, a well-known acronym.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数`sut`是测试对象，这是一个众所周知的缩写。
- en: Of course, we can’t explore all scenarios, so I picked three; let’s check the
    first one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们无法探索所有场景，所以我选择了三个；让我们检查第一个。
- en: 'Scenario 1: ExceptionTest'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 场景1：ExceptionTest
- en: 'This scenario explores what can happen when a subtype throws a new exception
    type.The following code is the consumer of the subject under test:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景探讨了当子类型抛出新的异常类型时可能发生的情况。以下代码是测试对象的消费者：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code is very standard. We wrapped the execution of some code
    (the `Do` method) in a try-catch block to handle a specific exception.The initial
    subject under test (the `SuperClass`) simulates that at some point during the
    execution of the `Do` method, it throws an exception of type `SuperException`.
    When we execute the code, the try-catch block catches the `SuperException`, and
    everything goes as planned. Here’s the code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常标准。我们使用try-catch块封装了某些代码（`Do`方法）的执行，以处理特定的异常。初始的测试对象（`SuperClass`）模拟在`Do`方法执行过程中抛出类型为`SuperException`的异常。当我们执行代码时，try-catch块捕获了`SuperException`，一切按计划进行。以下是代码：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, the `SubClassOk` class simulates that the execution changed, and it throws
    a `SubException` that inherits the `SuperException` class. When we execute the
    code, the try-catch block catches the `SubException`, because it’s a subtype of
    `SuperException`, and everything goes as planned. Here’s the code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SubClassOk`类模拟执行过程的变化，并抛出一个继承自`SuperException`类的`SubException`。当我们执行代码时，try-catch块捕获了`SubException`，因为它属于`SuperException`的子类型，一切按计划进行。以下是代码：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the `SubClassBreak` class simulates that it is throwing `AnotherException`,
    a new type of exception. When we execute the code, the program stops unexpectedly
    because we did not design the try-catch block for that. Here’s the code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SubClassBreak`类模拟抛出`AnotherException`，这是一种新的异常类型。当我们执行代码时，程序意外地停止，因为我们没有为这种情况设计try-catch块。以下是代码：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So as trivial as it may sound, throwing that exception breaks the program and
    go against the LSP.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尽管听起来可能很平凡，抛出那个异常会破坏程序，违反LSP。
- en: 'Scenario 2: PreconditionTest'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 场景2：PreconditionTest
- en: 'This scenario explores that *any precondition implemented in a supertype should
    yield the same outcome in its subtypes, but subtypes can be less strict about
    it, never more*.The following code is the consumer of the subject under test:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景探讨了在超类中实现的任何前置条件都应该在子类型中产生相同的结果，但子类型对此可以不那么严格，永远不能更严格。以下代码是测试对象的消费者：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code is very standard. We have the `value` variable that could
    come from anywhere. Then we pass it to the `IsValid` method. Finally, we do something
    with the `result`; in this case, we write a line to the console.The initial subject
    under test (the `SuperClass`) simulates that a precondition exists that enforces
    that the value must be positive. Here’s the code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常标准。我们有一个 `value` 变量，它可能来自任何地方。然后我们将其传递给 `IsValid` 方法。最后，我们对 `result` 做些处理；在这种情况下，我们向控制台写入一行。最初要测试的主题（`SuperClass`）模拟存在一个前提条件，强制值必须是正数。以下是代码：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, the `SubClassOk` class simulates that the execution changed and tolerates
    negative values up to -10\. Everything is fine when executing the code because
    the precondition is less strict. Here’s the code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SubClassOk` 类模拟执行发生变化，并容忍高达 -10 的负值。在执行代码时，一切正常，因为前提条件不那么严格。以下是代码：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, the `SubClassBreak` class simulates that the execution changed and
    restricts using values under 10\. When executing the code, it breaks because we
    were not expecting that error; the precondition was more strict than the `SuperClass`.
    Here’s the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SubClassBreak` 类模拟执行发生变化，并限制使用小于 10 的值。在执行代码时，它崩溃了，因为我们没有预料到这个错误；前提条件比 `SuperClass`
    更严格。以下是代码：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Yet another example of how a simple change can break its consumers and the LSP.
    Of course, this is an overly simplified example focusing only on the precondition,
    but the same applies to more complex scenarios. Coding is like playing with blocks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是简单变化如何破坏其消费者和 LSP 的一个例子。当然，这是一个过于简化的例子，只关注前提条件，但同样的情况也适用于更复杂的场景。编码就像玩积木。
- en: 'Scenario 3: PostconditionTest'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 场景 3：后置条件测试
- en: 'This scenario explores that *postconditions implemented in a supertype should
    yield the same outcome in its subtypes, but subtypes can be more strict about
    it, never less*.The following code is the consumer of the subject under test:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景探讨了在超类型中实现的后置条件应该在子类型中产生相同的结果，但子类型可以对此更加严格，决不能更宽松。以下代码是受测试主题的消费者：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code is very standard and very similar to the second scenario.
    We have the `value` variable that could come from anywhere. Then we pass it to
    the `Do` method. Finally, we do something with the `result`; in this case, we
    write a line to the console. The `Do` method returns an instance of a `Model`
    class, which has only a `Value` property. Here’s the code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常标准，并且与第二个场景非常相似。我们有一个 `value` 变量，它可能来自任何地方。然后我们将其传递给 `Do` 方法。最后，我们对 `result`
    做些处理；在这种情况下，我们向控制台写入一行。`Do` 方法返回一个 `Model` 类的实例，该类只有一个 `Value` 属性。以下是代码：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The initial subject under test (the `SuperClass`) simulates that at some point
    during the execution, it returns a `Model` instance and sets the value of the
    `Value` property to the value of the `value` parameter. Here’s the code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最初要测试的主题（`SuperClass`）模拟在执行过程中某个时刻返回一个 `Model` 实例，并将 `Value` 属性的值设置为 `value`
    参数的值。以下是代码：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, the `SubClassOk` class simulates that the execution changed and returns
    a `SubModel` instance instead. The `SubModel` class inherits the `Model` class
    and adds a `DoCount` property. When executing the code, everything is fine because
    the output is invariant (a `SubModel` is a `Model` and behaves the same). Here’s
    the code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SubClassOk` 类模拟执行发生了变化，并返回一个 `SubModel` 实例。`SubModel` 类继承自 `Model` 类并添加了一个
    `DoCount` 属性。在执行代码时，一切正常，因为输出是不变的（`SubModel` 是 `Model` 的一种，表现相同）。以下是代码：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, the `SubClassBreak` class simulates that the execution changed and
    returns `null` when the value of the `value` parameter is 5\. When executing the
    code, it breaks at runtime with a `NullReferenceException` when accessing the
    `Value` property during the interpolation that happens in the `Console.WriteLine`
    call. Here’s the code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SubClassBreak` 类模拟执行发生变化，并在 `value` 参数的值为 5 时返回 `null`。在执行代码时，当在 `Console.WriteLine`
    调用中发生的插值过程中访问 `Value` 属性时，会抛出 `NullReferenceException` 异常。以下是代码：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This last scenario shows once again how a simple change can break our program.
    Of course, this is also an overly simplified example focusing only on the postcondition
    and history constraint, but the same applies to more complex scenarios.What about
    the history constraint? We added a new state element to the `SubClassOk` class
    by creating the `_doCount` field. Moreover, by adding the `SubModel` class, we
    added the `DoCount` property to the return type. That field and property were
    nonexistent in the supertype, and they did not alter its behaviors: LSP followed!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的场景再次展示了简单的更改如何破坏我们的程序。当然，这只是一个过于简化的例子，只关注后置条件和历史约束，但同样的情况也适用于更复杂的情况。关于历史约束呢？我们通过创建`_doCount`字段向`SubClassOk`类添加了一个新的状态元素。此外，通过添加`SubModel`类，我们将`DoCount`属性添加到了返回类型中。这个字段和属性在超类型中不存在，并且它们没有改变其行为：LSP遵循！
- en: Conclusion
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结论
- en: 'The key idea of the LSP is that the consumer of a supertype should remain unaware
    of whether it''s interacting with an instance of a supertype or an instance of
    a subtype.We could also name this principle the backward-compatibility principle
    because everything that worked in a way before must still work at least the same
    after the substitution, which is why this principle is essential.Once again, this
    is only a principle, not a law. You can also see a violation of the LSP as a *code
    smell*. From there, analyze whether you have a design problem and its impact.
    Use your analytical skills on a case-by-case basis and conclude whether or not
    it would be acceptable to break the LSP in that specific case. Sometimes you want
    to change the program''s behavior and break the LSP, but beware that you might
    break certain execution paths you did not account for and introduce defects.The
    more we progress, the more we move away from inheritance, and the less we need
    to worry about this principle. However, if you use inheritance and want to ensure
    your subtypes don’t break the program: apply the LSP, and you will be rewarded
    by improving your chances of producing defect-free, backward-compatible changes.Let’s
    look at the ISP next.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: LSP的关键思想是，超类型的消费者应该对它是在与超类型的一个实例还是子类型的一个实例交互保持无知。我们也可以把这个原则称为向后兼容性原则，因为之前所有的工作方式在替换后必须至少保持相同，这就是为什么这个原则是至关重要的。再次强调，这只是一个原则，而不是法律。你还可以将LSP的违反视为*代码异味*。从那里，分析你是否有一个设计问题及其影响。根据具体情况运用你的分析技能，并得出是否可以接受在该特定情况下违反LSP的结论。有时你可能想要改变程序的行为并违反LSP，但要注意你可能会破坏你没有考虑到的某些执行路径，并引入缺陷。随着我们不断进步，我们越来越远离继承，也就越来越不需要担心这个原则。然而，如果你使用继承并希望确保你的子类型不会破坏程序：应用LSP，你将因为提高生产无缺陷、向后兼容更改的机会而得到回报。让我们接下来看看ISP。
- en: Interface segregation principle (ISP)
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口分离原则（ISP）
- en: 'Let’s start with another famous quote by Robert C. Martin:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从罗伯特·C·马丁的另一个著名引言开始：
- en: '*“Many client-specific interfaces are better than one general-purpose interface.”*'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“许多特定客户端的接口比一个通用接口更好。”*'
- en: 'What does that mean? It means the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？这意味着以下内容：
- en: You should create interfaces.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该创建接口。
- en: You should value small interfaces more.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该更重视小型接口。
- en: You should not create multipurpose interfaces.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不应该创建多功能接口。
- en: You can see a multipurpose interface as “an interface to rule them all” or a
    God class, introduced in *Chapter 1*, *Introduction*.
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以将多功能接口视为“统治一切接口”或是在*第一章*，*简介*中引入的上帝类。
- en: An interface could refer to a class interface (the public members of a class)
    or a C# interface. We focus on C# interfaces in the book, as we use them extensively.
    Moreover, C# interfaces are very powerful.Speaking of interfaces, let’s quickly
    look at them before digging into some code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以指类接口（类的公共成员）或C#接口。我们在书中主要关注C#接口，因为我们广泛地使用它们。此外，C#接口非常强大。说到接口，在我们深入代码之前，让我们快速了解一下它们。
- en: What is an interface?
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是接口？
- en: Interfaces are among the most valuable tools in the C# toolbox for creating
    flexible and maintainable software. It can be tough to understand and grasp the
    power of interfaces at first, especially from an explanation, so don’t worry if
    you don’t; you will see plenty in action throughout the book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是C#工具箱中创建灵活和可维护软件的最有价值的工具之一。一开始理解并掌握接口的力量可能很困难，尤其是从解释的角度来看，所以如果你还没有理解，请不要担心；你将在整本书中看到很多实际应用。
- en: You can see an interface as allowing a class to impersonate different things
    (APIs), bringing polymorphism to the next level.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以看到一个接口允许一个类模仿不同的东西（API），将多态性提升到新的层次。
- en: 'Next are some more details that overview interfaces:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些概述接口的更多细节：
- en: The role of an interface is to define a cohesive contract (public methods, properties,
    and events). In its theoretical form, an interface contains no code; it is only
    a contract. In practice, since C# 8, we can create default implementation in interfaces,
    which could be helpful to limit breaking changes in a library (such as adding
    a method to an interface without breaking any class implementing that interface).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的作用是定义一个统一的契约（公共方法、属性和事件）。在其理论形式中，接口不包含任何代码；它只是一个契约。在实践中，自从 C# 8 以来，我们可以在接口中创建默认实现，这有助于限制库中的破坏性更改（例如，在不破坏实现该接口的任何类的情况下向接口添加方法）。
- en: An interface should be small (ISP), and its members should align toward a common
    goal (cohesion) and share a single responsibility (SRP).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口应该是小的（ISP），其成员应朝向一个共同的目标（内聚）并承担单一责任（SRP）。
- en: In C#, a class can implement multiple interfaces, exposing multiples of those
    public contracts or, more accurately, be any and all of them. By leveraging polymorphism,
    we can consume a class as if it was any of the interfaces it implements or its
    supertype if it inherits another class.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中，一个类可以实现多个接口，暴露多个这些公共契约，或者更准确地说，可以是它们中的任何和所有。通过利用多态性，我们可以将一个类消费为它实现的任何接口，或者如果它继承自另一个类，则是其超类型。
- en: A class does not inherit from an interface; it implements an interface. However,
    an interface can inherit from another interface.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个类不继承自接口；它实现了接口。然而，一个接口可以继承自另一个接口。
- en: Let’s explore the ISP example now that we refreshed our memory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在刷新了我们的记忆之后，探索一下 ISP 示例。
- en: Project – Interface Segregation
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 – 接口隔离
- en: 'In this project, we start with the same class as the SRP example but extract
    an interface from the `ProductRepository` class. Let’s start by looking at the
    `Product` class as a reminder, which represents a simple fictive product:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们以 SRP 示例中的相同类开始，但从中提取了 `ProductRepository` 类的接口。让我们先看看 `Product` 类作为提醒，它代表一个简单的虚构产品：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code sample has no implementation because it is irrelevant to understanding
    the ISP. We focus on the interfaces instead. Please assume we implemented the
    data-access logic using your favorite database.
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码示例没有实现，因为它与理解 ISP 无关。我们专注于接口。请假设我们使用您喜欢的数据库实现了数据访问逻辑。
- en: 'Now, let’s look at the interface extracted from the `ProductRepository` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看从 `ProductRepository` 类中提取的接口：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, the `IProductRepository` interface breaks the SRP and the ISP
    the same way the `ProductRepository` class did before. We already identified the
    SRP issues earlier but did not reach the point of extracting interfaces.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`IProductRepository` 接口与 `ProductRepository` 类之前以相同的方式违反了 SRP 和 ISP。我们之前已经确定了
    SRP 问题，但还没有达到提取接口的阶段。
- en: The `ProductRepository` class implements the `IProductRepository` interface
    and is the same as the SRP example (all methods `throw new NotImplementedException()`).
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ProductRepository` 类实现了 `IProductRepository` 接口，并且与 SRP 示例相同（所有方法 `throw new
    NotImplementedException()`）。'
- en: 'In the SRP example, we identified the following responsibilities:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SRP 示例中，我们确定了以下责任：
- en: Handling public products.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理公共产品。
- en: Handling private products.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理私有产品。
- en: 'Based on our previous analysis, we have two functional requirements (public
    and private access). By digging deeper, we can also identify five different database
    operations. Here’s the result in a grid:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的分析，我们有两个功能需求（公共和私有访问）。进一步挖掘后，我们还可以识别出五种不同的数据库操作。以下是结果表格：
- en: '|  | **Public** | **Private** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  | **公共** | **私有** |'
- en: '| Read one product | Yes | Yes |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 读取单个产品 | 是 | 是 |'
- en: '| Read all products | Yes | Yes |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 读取所有产品 | 是 | 是 |'
- en: '| Create a product | No | Yes |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 创建产品 | 否 | 是 |'
- en: '| Update a product | No | Yes |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 更新产品 | 否 | 是 |'
- en: '| Delete a product | No | Yes |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 删除产品 | 否 | 是 |'
- en: 'Table 3.3: a grid that shows what the software needs to do (functional requirements)
    and what needs to happen in the database (database operation requirements).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3：一个表格，显示了软件需要做什么（功能需求）以及数据库中需要发生什么（数据库操作需求）。
- en: 'We can extract the following families of database operations from Table 3.3:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从表 3.3 中提取以下数据库操作系列：
- en: Read products (read one, read all).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取产品（读取一个，读取所有）。
- en: Write or alter products (create, update, delete).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入或修改产品（创建、更新、删除）。
- en: 'Based on that more thorough analysis, we can extract the `IProductReader` and
    `IProductWriter` interfaces representing the database operation. Then we can create
    the `PublicProductReader` and `PrivateProductRepository` classes to implement
    our functional requirements.Let’s start with the `IProductReader` interface:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 基于更深入的分析，我们可以提取代表数据库操作的`IProductReader`和`IProductWriter`接口。然后我们可以创建`PublicProductReader`和`PrivateProductRepository`类来实现我们的功能需求。让我们从`IProductReader`接口开始：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this interface, we cover the *read one product* and *read all products*
    use cases. Next, the `IProductWriter` interface covers the other three database
    operations:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个接口，我们涵盖了*读取一个产品*和*读取所有产品*的使用场景。接下来，`IProductWriter`接口涵盖了其他三个数据库操作：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can cover all the database use cases with the preceding interfaces. Next,
    let’s create the `PublicProductReader` class:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的接口来涵盖所有数据库使用场景。接下来，让我们创建`PublicProductReader`类：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, the `PublicProductReader` only implements the `IProductReader`
    interface, covering the identified scenarios. We do the `PrivateProductRepository`
    class next before exploring the advantages of the ISP:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`PublicProductReader`只实现了`IProductReader`接口，涵盖了已识别的场景。我们在探索ISP的优势之前，先来处理`PrivateProductRepository`类：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, the `PrivateProductRepository` class implements the
    `IProductReader` and `IProductWriter` interfaces, covering all the database needs.
    Now that we have covered the building blocks, let’s explore what this can do.
    Here’s the `Program.cs` file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`PrivateProductRepository`类实现了`IProductReader`和`IProductWriter`接口，涵盖了所有数据库需求。现在我们已经涵盖了构建块，让我们探索这能做什么。以下是`Program.cs`文件：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From the preceding code, the `ReadProducts`, `ModifyProducts`, and `ReadAndUpdateProducts`
    methods write messages in the console to demonstrate the advantages of applying
    the ISP.The `publicProductReader` (instance of `PublicProductReader`) and `privateProductRepository`
    (instance of `PrivateProductRepository`) variables are passed to the methods to
    show what we can and cannot do with the current design.Before getting into the
    weed, when we execute the program, we obtain the following output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，`ReadProducts`、`ModifyProducts`和`ReadAndUpdateProducts`方法在控制台输出消息，以展示应用ISP的优势。《publicProductReader`（`PublicProductReader`的实例）和`privateProductRepository`（`PrivateProductRepository`的实例）变量被传递到方法中，以展示我们可以在当前设计中做什么，以及不能做什么。在我们深入探讨之前，当我们执行程序时，我们获得以下输出：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First operation
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一个操作
- en: 'The following code represents the first operation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示第一个操作：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since the `PublicProductReader` and `PrivateProductRepository` classes implement
    the `IProductReader` interface, the `ReadProducts` method accepts them, leading
    to the following output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PublicProductReader`和`PrivateProductRepository`类实现了`IProductReader`接口，因此`ReadProducts`方法接受它们，导致以下输出：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That means we can centralize some code that reads from both implementations
    without changing them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以集中一些代码，从这两个实现中读取，而无需更改它们。
- en: Second operation
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二个操作
- en: 'The following code represents the second operation:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示第二个操作：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since only the `PrivateProductRepository` class implements the `IProductWriter`
    interface, the `WriteProducts` method accepts only the `privateProductRepository`
    variable and outputs the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有`PrivateProductRepository`类实现了`IProductWriter`接口，因此`WriteProducts`方法只接受`privateProductRepository`变量，并输出以下内容：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is one advantage of well-segregated interfaces and responsibilities; if
    we try to execute the following line, the compiler yields the error saying that
    we “cannot convert from PublicProductReader to IProductWriter”:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是良好分离的接口和责任的一个优点；如果我们尝试执行以下行，编译器会显示错误，指出我们“不能从PublicProductReader转换为IProductWriter”：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That error makes sense because PublicProductReader does not implement the `IProductWriter`
    interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是有意义的，因为PublicProductReader没有实现`IProductWriter`接口。
- en: Third operation
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三个操作
- en: 'The following code represents the third operation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示第三个操作：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s analyze the two calls to the `ReadAndWriteProducts` method individually,
    but before that, let’s look at the console output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别分析对`ReadAndWriteProducts`方法的两次调用，但在那之前，让我们看看控制台输出：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first execution reads and writes to the `PrivateProductRepository` instance,
    which is possible because it implements both the `IProductReader` and `IProductWriter`
    interfaces.The second call, however, reads from the public reader but writes using
    the private writer. The last example shows the power of the ISP, especially when
    mixed with the SRP, and how easy it is to swap one piece for another when segregating
    our interfaces correctly and designing our code for the program’s use cases.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行读取和写入到`PrivateProductRepository`实例，这是可能的，因为它实现了`IProductReader`和`IProductWriter`接口。然而，第二次调用是从公共读取器读取，但使用私有写入器写入。最后一个示例展示了接口隔离原则（ISP）的力量，特别是当与单一职责原则（SRP）结合使用时，以及正确隔离我们的接口并针对程序用例设计代码时，如何轻松地交换一个部分为另一个部分。
- en: You should not divide all your repositories into readers and writers; this sample
    only demonstrates some possibilities. Always design your programs for the specifications
    that you have.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不应该将所有存储库都分为读取器和写入器；这个示例只是为了展示一些可能性。始终为你的程序规格设计你的程序。
- en: Conclusion
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结论
- en: To summarize the idea behind the ISP, if you have multiple smaller interfaces,
    it is easier to reuse them and expose only the features you need instead of exposing
    APIs that part of your program doesn’t need. Furthermore, it is easier to compose
    bigger pieces using multiple specialized interfaces by implementing them as needed
    than remove methods from a big interface if we don’t need them in one of its implementations.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 总结接口隔离原则（ISP）背后的思想，如果你有多个较小的接口，更容易重用它们，并且只暴露你需要的功能，而不是暴露程序不需要的部分的API。此外，通过按需实现它们，比从大接口中删除不需要的方法更容易使用多个专业接口来组合更大的部分。
- en: The main takeaway is to **only depend on the interfaces that you consume**.
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 主要的收获是**只依赖于你消费的接口**。
- en: If you don’t see all of the benefits yet, don’t worry. All the pieces should
    come together as we move on to the last SOLID principle, to dependency injection,
    the rest of the book, and as you practice applying the SOLID principles.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有看到所有的好处，请不要担心。随着我们继续到最后一个SOLID原则，即依赖注入，书的其余部分，以及你练习应用SOLID原则，所有的部分都应该逐渐整合在一起。
- en: Like the SRP, be careful not to overuse the ISP mindlessly. Think about cohesion
    and what you are trying to achieve, not how granular an interface can become.
    The finer-grained your interfaces, the more flexible your system will be but remember
    that flexibility has a cost, which can become very high very quickly. For example,
    your highly-flexible system may be very hard to navigate and understand, increasing
    the cognitive load required to work on the project.
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像单一职责原则（SRP）一样，要小心不要无意识地过度使用接口隔离原则（ISP）。考虑内聚性和你试图实现的目标，而不是接口可以变得多细粒度。你的接口越细粒度，你的系统将越灵活，但记住灵活性是有代价的，这个代价可能会很快变得非常高。例如，你的高度灵活的系统可能非常难以导航和理解，从而增加了在项目上工作的认知负荷。
- en: Next, we explore the last of the SOLID principles.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨SOLID原则中的最后一个原则。
- en: Dependency inversion principle (DIP)
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）
- en: 'The DIP provides flexibility, testability, and modularity, by reducing tight
    coupling between classes or modules.Let’s continue with another quote from Robert
    C. Martin (including the implied context from Wikipedia):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）提供了灵活性、可测试性和模块化，通过减少类或模块之间的紧密耦合。让我们继续引用罗伯特·C·马丁（包括维基百科中的隐含上下文）：
- en: '*One should “depend upon abstractions, [not] concretions.”*'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “人们应该‘依赖于抽象，而不是具体实现。’”
- en: In the previous section, we explored interfaces (abstractions), one of the pivotal
    elements of our SOLID arsenal, and using interfaces is the best way to approach
    the DIP.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了接口（抽象），这是我们SOLID工具箱中的一个关键元素，使用接口是接近依赖倒置原则（DIP）的最佳方式。
- en: Are you wondering why not use abstract classes? While helpful at providing default
    behaviors over inheritance, they’re not fully abstract. If one is, it’s better
    to use an interface instead.
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你想知道为什么不使用抽象类吗？虽然它们在提供继承的默认行为方面很有帮助，但它们并不完全抽象。如果一个是，最好使用接口。
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Interfaces are more flexible and powerful, acting as contracts between parts
    of a system. They also allow a class to implement multiple interfaces, boosting
    flexibility. However, don’t discard abstract classes mindlessly. Actually, don’t
    discard anything mindlessly.
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接口更加灵活和强大，作为系统各部分之间的契约。它们还允许一个类实现多个接口，从而提高灵活性。然而，不要无意识地丢弃抽象类。实际上，不要无意识地丢弃任何东西。
- en: 'Exposing interfaces can save countless hours of struggling to find complex
    workaround when writing unit tests. That is even more true when building a framework
    or library that others use. In that case, please pay even more attention to providing
    your consumers with interfaces to mock if necessary.All that talk about interfaces
    again is great, but how can we invert the flow of dependencies? Spoiler alert:
    interfaces!Let’s compare a direct dependency and an inverted dependency first.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露接口可以在编写单元测试时节省无数小时寻找复杂解决方案的时间。当构建其他人使用的框架或库时，这一点更是如此。在这种情况下，请更加注意为您的消费者提供接口，以便在必要时进行模拟。再次讨论接口的话题是很好的，但我们如何反转依赖关系流呢？剧透一下：接口！让我们首先比较直接依赖和反转依赖。
- en: Direct dependency
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 直接依赖
- en: 'A direct dependency occurs when a particular piece of code (like a class or
    a module) relies directly on another. For example, if Class A uses a method from
    Class B, then Class A directly depends on Class B, which is a typical scenario
    in traditional programming.Say we have a `SomeService` class that uses the `SqlDataPersistence`
    class for production but the `LocalDataPersistence` class during development and
    testing. Without inverting the dependency flow, we end up with the following UML
    dependency graph:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当一段特定的代码（如类或模块）直接依赖于另一个时，就会发生直接依赖。例如，如果类A使用类B的方法，那么类A就直接依赖于类B，这在传统编程中是一个典型的场景。假设我们有一个`SomeService`类，在生产中使用`SqlDataPersistence`类，而在开发和测试期间使用`LocalDataPersistence`类。如果不反转依赖关系，我们最终会得到以下UML依赖图：
- en: '![Figure 3.2: Direct dependency graph schema](img/file14.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：直接依赖图架构](img/file14.png)'
- en: 'Figure 3.2: Direct dependency graph schema'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：直接依赖图架构
- en: With the preceding system, we could not change the `SqlDataPersistence` or `LocalDataPersistence`
    classes by the `CosmosDbDataPersistence` class (not in the diagram) without impacting
    the `SomeService` class.We call direct dependencies like these **tight coupling**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的系统中，我们无法通过`CosmosDbDataPersistence`类（不在图中）更改`SqlDataPersistence`或`LocalDataPersistence`类，而不会影响`SomeService`类。我们称这种直接的依赖为**紧密耦合**。
- en: Inverted dependency
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反转依赖
- en: 'An inverted dependency occurs when high-level modules (which provide complex
    logic) are independent of low-level modules (which provide basic, foundational
    operations). We can achieve this by introducing an abstraction (like an interface)
    between the modules. This means that instead of Class A depending directly on
    Class B, Class A would rely on an abstraction that Class B implements.Here is
    the updated schema that improves the direct dependency example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当高级模块（提供复杂逻辑）独立于低级模块（提供基本、基础操作）时，就会发生反转依赖。我们可以通过在模块之间引入抽象（如接口）来实现这一点。这意味着，而不是类A直接依赖于类B，类A将依赖于类B实现的抽象。以下是改进直接依赖示例的更新架构：
- en: '![Figure 3.3: Indirect dependency graph schema](img/file15.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：间接依赖图架构](img/file15.png)'
- en: 'Figure 3.3: Indirect dependency graph schema'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：间接依赖图架构
- en: In the preceding diagram, we successfully inverted the dependency flow by ensuring
    the `SomeService` class depends only on an `IDataPersistance` interface (abstraction)
    that the `SqlDataPersistence` and `LocalDataPersistence` classes implement. We
    could then use the `CosmosDbDataPersistence` class (not in the diagram) without
    impacting the `SomeService` class.We call inverted dependencies like these **loose
    coupling**.Now that we covered how to invert the dependency flow of classes, we
    look at inverting subsystems.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的图中，我们通过确保`SomeService`类只依赖于`IDataPersistance`接口（抽象）来实现依赖关系的反转，该接口由`SqlDataPersistence`和`LocalDataPersistence`类实现。然后我们可以使用`CosmosDbDataPersistence`类（不在图中），而不会影响`SomeService`类。我们称这种反转的依赖为**松耦合**。现在我们已经讨论了如何反转类的依赖关系流，我们来看看如何反转子系统。
- en: Direct subsystems dependency
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 直接子系统依赖
- en: 'The preceding direct dependency example divided into packages, which have the
    same issue, would look like the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的直接依赖示例按包划分，存在相同的问题，如下所示：
- en: '![Figure 3.3: direct dependency graph divided into packages](img/file16.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：按包划分的直接依赖图](img/file16.png)'
- en: 'Figure 3.3: direct dependency graph divided into packages'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：按包划分的直接依赖图
- en: The `Core` package depends on the `SQL` and `Local` packages leading to tight
    coupling.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`Core`包依赖于`SQL`和`Local`包，导致紧密耦合。'
- en: Packages usually represent assemblies or namespaces. However, dividing responsibilities
    around assemblies allows loading only the implementations that the program need.
    For example, one program could load the `Local` assembly, another could load the
    `SQL` assembly, and a third could load both.
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包通常代表程序集或命名空间。然而，围绕程序集划分责任允许只加载程序需要的实现。例如，一个程序可以加载 `Local` 程序集，另一个可以加载 `SQL`
    程序集，第三个可以加载两者。
- en: Enough said; let’s invert the dependency flow of those subsystems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 话已说尽；让我们反转这些子系统的依赖流。
- en: Inverted subsystems dependency
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逆子系统依赖
- en: 'We discussed modules and packages, yet the example diagram of inverted dependency
    illustrated classes. Using a similar approach, we can reduce dependencies between
    subsystems and create more flexible programs by arranging our code in separate
    assemblies. This way, we can achieve loose coupling and improved modularity in
    our software. To continue the inverted dependency example, we can do the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了模块和包，但逆依赖示例图说明了类。采用类似的方法，我们可以通过将代码安排在单独的程序集中来减少子系统之间的依赖，创建更灵活的程序。这样，我们可以在软件中实现松散耦合和改进的模块化。为了继续逆依赖示例，我们可以做以下操作：
- en: Create an abstraction assembly containing only interfaces.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个只包含接口的抽象程序集。
- en: Create other assemblies that contain the implementation of the contracts from
    that first assembly.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建其他包含第一个包中合约实现的程序集。
- en: Create assemblies that consume the code through the abstraction assembly.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建通过抽象程序集消费代码的程序集。
- en: There are multiple examples of this in .NET, such as the `Microsoft.Extensions.DependencyInjection.Abstractions`
    and `Microsoft.Extensions.DependencyInjection` assemblies. We explore this concept
    further in *Chapter 12*, *Layering and Clean Architecture*.
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 .NET 中有多个这样的例子，例如 `Microsoft.Extensions.DependencyInjection.Abstractions`
    和 `Microsoft.Extensions.DependencyInjection` 程序集。我们将在第 12 章 *分层和清洁架构* 中进一步探讨这个概念。
- en: 'Then, if we divide the inverted dependency examples into multiple packages,
    it would look like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们把逆依赖示例分为多个包，它看起来会像以下这样：
- en: '![Figure 3.4: inverted dependency examples divided into multiple packages](img/file17.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：分为多个包的逆依赖示例](img/file17.png)'
- en: 'Figure 3.4: inverted dependency examples divided into multiple packages'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：分为多个包的逆依赖示例
- en: 'In the diagram, the `Core` package directly depends on the `Abstractions` package,
    while two implementations are available: `Local` and `Sql`. Since we only rely
    on abstractions, we can swap one implementation for the other without impacting
    `Core`, and the program will run just fine unless something is wrong with the
    implementation itself (but that has nothing to do with the DIP).We could also
    create a new `CosmosDb` package and a `CosmosDbDataPersistence` class that implements
    the `IDataPersistence` interface, then use it in the `Core` without breaking anything.
    Why? Because we are only directly depending on abstractions, leading to a loosely
    coupled system.Next, we dig into some code.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，`Core` 包直接依赖于 `Abstractions` 包，同时有两个实现可用：`Local` 和 `Sql`。由于我们只依赖于抽象，我们可以互换一个实现，而不会影响
    `Core`，程序将正常运行，除非实现本身有问题（但这与 DIP 没有关系）。我们还可以创建一个新的 `CosmosDb` 包和一个实现 `IDataPersistence`
    接口的 `CosmosDbDataPersistence` 类，然后在 `Core` 中使用它而不会破坏任何东西。为什么？因为我们只直接依赖于抽象，导致系统耦合度低。接下来，我们将深入研究一些代码。
- en: Project – Dependency inversion
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 – 依赖反转
- en: 'In this section, we translate the preceding iteration of the inverted dependency
    example in code. We create the following assemblies to align with the preceding
    diagram:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将代码中前面的逆依赖示例迭代翻译成中文。我们创建了以下程序集以与前面的图一致：
- en: '`App` is a console application that references all projects to showcase different
    use cases.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App` 是一个控制台应用程序，它引用所有项目以展示不同的用例。'
- en: '`Core` is a class library that depends on the `Abstractions` package.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Core` 是一个依赖于 `Abstractions` 包的类库。'
- en: '`Abstractions` is a class library that contains the `IDataPersistence` interface.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abstractions` 是一个包含 `IDataPersistence` 接口的类库。'
- en: '`Sql` and `Local` are class libraries that reference the `Abstractions` project
    and implement the `IDataPersistence` interface.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sql` 和 `Local` 是引用 `Abstractions` 项目并实现 `IDataPersistence` 接口的类库。'
- en: The code sample has few implementation details because it is irrelevant to understanding
    the DIP. Please assume we implemented the `Persist` methods logic using your favorite
    in-memory and SQL databases.
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码示例中包含很少的实现细节，因为它与理解 DIP 无关。请假设我们使用您喜欢的内存和 SQL 数据库实现了 `Persist` 方法的逻辑。
- en: 'Visually, the relationships between the packages look like the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉上，包之间的关系看起来如下：
- en: '![Figure 3.5: the visual representation of the packages and their relationships](img/file18.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：包及其关系的视觉表示](img/file18.png)'
- en: 'Figure 3.5: the visual representation of the packages and their relationships'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：包及其关系的视觉表示
- en: 'Code-wise, our abstraction contains a `Persist` method that we use to showcase
    the DIP:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码上，我们的抽象包含一个 `Persist` 方法，我们用它来展示 DIP：
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, the `LocalDataPersistence` class depends on the `Abstractions` package
    and outputs a line to the console, allowing us to trace what happens in the system:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`LocalDataPersistence` 类依赖于 `Abstractions` 包并向控制台输出一行信息，使我们能够追踪系统中的发生情况：
- en: '[PRE50]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, the `SqlDataPersistence` class is very similar to the `LocalDataPersistence`
    class; it depends on the `Abstractions` package and outputs a line in the console,
    allowing us to trace what happens in the system:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SqlDataPersistence` 类与 `LocalDataPersistence` 类非常相似；它依赖于 `Abstractions`
    包并在控制台输出一行信息，使我们能够追踪系统中的发生情况：
- en: '[PRE51]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before we get to the program flow, we still have the `SomeService` class to
    look at, which depends on the `Abstractions` package:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达程序流程之前，我们仍然需要查看 `SomeService` 类，它依赖于 `Abstractions` 包：
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The highlighted code shows that the `SomeService` class calls the `Persist`
    method of the provided `IDataPersistence` interface implementation. The `SomeService`
    class is not aware of where the data go. In the case of full implementation, the
    `someDataPersistence` instance is responsible for where the data would be persisted.
    Other than that, the `Operation` method writes lines to the console so we can
    trace what happens. Now from the `App` package, the `Program.cs` file contains
    the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码显示 `SomeService` 类调用了提供的 `IDataPersistence` 接口实现中的 `Persist` 方法。`SomeService`
    类并不知道数据去往何处。在完整实现的情况下，`someDataPersistence` 实例负责数据将持久化到何处。除此之外，`Operation` 方法将行写入控制台，以便我们追踪发生的情况。现在从
    `App` 包，`Program.cs` 文件包含以下代码：
- en: '[PRE53]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we create a `SqlDataPersistence` and a `LocalDataPersistence`
    instance. Doing that forced us to depend on both packages, but we could have chosen
    otherwise.Then we create an instance of the `SomeService` class. We then pass
    both `IDataPersistence` implementations to the `Operation` method one after the
    other.When we execute the program we get the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了 `SqlDataPersistence` 和 `LocalDataPersistence` 实例。这样做迫使我们依赖于这两个包，但我们可以选择其他方式。然后我们创建
    `SomeService` 类的一个实例。然后我们依次将两个 `IDataPersistence` 实现传递给 `Operation` 方法。当我们执行程序时，我们得到以下输出：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first half of the preceding terminal output represents the first call to
    the `Operation` method, where we passed the `LocalDataPersistence` instance. The
    second half represents the second call, where we passed the `SqlDataPersistence`
    instance.The highlighted lines show that depending on an interface allowed us
    to change this behavior (OCP). Moreover, we could create a `CosmosDb` package,
    reference it from the `App` package, then pass an instance of a `CosmosDbDataPersistence`
    class to the `Operation` method, and the `Core` package would not know about it.
    Why? Because we inverted the dependency flow, creating a loosely coupled system.
    We even did some *dependency injection*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的终端输出的一半代表对 `Operation` 方法的第一次调用，其中我们传递了 `LocalDataPersistence` 实例。另一半代表第二次调用，其中我们传递了
    `SqlDataPersistence` 实例。突出的行显示，依赖于接口允许我们改变这种行为（OCP）。此外，我们可以创建一个 `CosmosDb` 包，从
    `App` 包中引用它，然后将 `CosmosDbDataPersistence` 类的实例传递给 `Operation` 方法，而 `Core` 包将不知道这一点。为什么？因为我们反转了依赖流，创建了一个松散耦合的系统。我们甚至进行了一些
    **依赖注入**。
- en: '**Dependency injection**, or **Inversion of Control** (**IoC**), is a design
    principle that is a first-class citizen of ASP.NET Core. It allows us to map abstractions
    to implementations, and when we need a new type, the whole object tree gets created
    automatically based on our configuration. We start that journey in *Chapter 7*,
    *Dependency Injection*.'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**依赖注入**，或**控制反转**（**IoC**），是 ASP.NET Core 中的一个设计原则，它是一个一等公民。它允许我们将抽象映射到实现，当我们需要一个新的类型时，整个对象树会根据我们的配置自动创建。我们在**第
    7 章**，**依赖注入**中开始这段旅程。'
- en: Conclusion
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结论
- en: The core idea is to depend on abstractions. Interfaces are pure contracts, which
    makes them more flexible than abstract classes. Abstract classes are still helpful,
    and we explore ways to leverage them in the book.Depending on implementations
    (classes) creates tight coupling between classes, which leads to a system that
    can be harder to maintain. The cohesion between your dependencies is essential
    in whether the coupling will help or hurt you in the long run. Don’t discard concrete
    types everywhere mindlessly.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是依赖于抽象。接口是纯合约，这使得它们比抽象类更灵活。抽象类仍然很有帮助，我们在书中探讨了利用它们的方法。依赖于实现（类）会在类之间创建紧密耦合，这会导致一个更难维护的系统。你的依赖之间的内聚性对于耦合在长期内是帮助还是伤害至关重要。不要无意识地到处丢弃具体类型。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered many architectural principles. We began by exploring
    DRY, KISS, and separation of concerns principles before learning about the SOLID
    principles and their importance in modern software engineering. By following those
    principles, you should be able to build better, more maintainable software.As
    we also covered, principles are only principles, not laws. You must always be
    careful not to abuse them so they remain helpful instead of harmful. The context
    is always essential; internal tools and critical business applications require
    different levels of tinkering. The key takeaways from this chapter are:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了众多架构原则。我们首先探索了 DRY、KISS 和关注点分离原则，然后学习了 SOLID 原则及其在现代软件工程中的重要性。通过遵循这些原则，你应该能够构建更好、更易于维护的软件。正如我们也提到的，原则只是原则，而不是法律。你必须始终小心不要滥用它们，以确保它们是有益的而不是有害的。上下文始终至关重要；内部工具和关键业务应用需要不同级别的调整。本章的关键要点是：
- en: Don’t over-engineer your solutions (KISS).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要过度设计你的解决方案（KISS）。
- en: Encapsulate and reuse business logic (DRY).
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装并重用业务逻辑（DRY）。
- en: Organize elements around concerns and responsibilities (SoC/SRP).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕关注点和责任组织元素（SoC/SRP）。
- en: Aim at composability (OCP).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可组合性（OCP）为目标。
- en: Support backward compatibility (LSP).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持向后兼容性（LSP）。
- en: Write granular interfaces/contracts (ISP).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写粒度化的接口/合约（ISP）。
- en: Depend on abstractions and invert the dependency flow (DIP).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于抽象并反转依赖关系（DIP）。
- en: With all those principles in our toolbox, we are ready to jump into design patterns
    and get our design level one step further, with the next chapter covering the
    MVC pattern in the context of ASP.NET Core REST APIs.Afterward, in the following
    few chapters, we explore how to implement some of the most frequently used Gang
    of Four (GoF) patterns and then how to apply them at another level using dependency
    injection.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具箱中拥有所有这些原则后，我们准备好跳入设计模式，并将我们的设计水平提升一步，下一章将涵盖在 ASP.NET Core REST API 上下文中的
    MVC 模式。之后，在接下来的几章中，我们将探讨如何实现一些最常用的四人帮（GoF）模式，然后讨论如何通过依赖注入在另一个层面上应用它们。
- en: Questions
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个实践问题：
- en: How many principles are represented by the SOLID acronym?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOLID 这个缩写代表了多少个原则？
- en: Is it true that when following the SOLID principles, the idea is to create bigger
    components that can each manage more elements of a program by creating God-sized
    classes?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当遵循 SOLID 原则时，是否意味着要创建更大的组件，每个组件可以通过创建神级类来管理程序中的更多元素？
- en: By following the DRY principle, you want to remove all code duplication from
    everywhere, irrespective of the source, and encapsulate that code into a reusable
    component. Is this affirmation correct?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过遵循 DRY 原则，你希望从任何地方移除所有代码重复，并将其封装到可重用的组件中。这种肯定是否正确？
- en: Is it true that the ISP tells us that creating multiple smaller interfaces is
    better than creating one large one?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ISP 是否告诉我们，创建多个较小的接口比创建一个大的接口更好？
- en: What principle tells us that creating multiple smaller classes that handle a
    single responsibility is better than one class handling multiple responsibilities?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个原则告诉我们，创建多个处理单个职责的小类比一个类处理多个职责更好？
- en: Further reading
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Covariance and contravariance (C#): [https://adpg.link/BxBG](https://adpg.link/BxBG)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性和逆变（C#）：[https://adpg.link/BxBG](https://adpg.link/BxBG)
