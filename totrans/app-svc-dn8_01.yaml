- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Apps and Services with .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, the goals are setting up your development environment
    to use Visual Studio 2022 and Visual Studio Code and understanding your choices
    for building apps and services; we will review good places to look for help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub repository for this book has solutions using full application projects
    for all code tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/](https://github.com/markjprice/apps-services-net8/)'
  prefs: []
  type: TYPE_NORMAL
- en: After going to the GitHub repository, simply press the *.* (dot) key on your
    keyboard or change `.com` to `.dev` to change the repository into a live code
    editor based on Visual Studio Code using GitHub Codespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code in a web browser is great to run alongside your chosen code
    editor as you work through the book’s coding tasks. You can compare your code
    to the solution code and easily copy and paste parts if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, I use the term **modern .NET** to refer to .NET 8 and
    its predecessors like .NET 6, which come from .NET Core. I use the term **legacy
    .NET** to refer to .NET Framework, Mono, Xamarin, and .NET Standard. Modern .NET
    is a unification of those legacy platforms and standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing this book and its contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App and service technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring top-level programs, functions, and namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making good use of the GitHub repository for this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to go for help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing this book and its contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book caters to two audiences:'
  prefs: []
  type: TYPE_NORMAL
- en: Readers who have completed my book for beginners, *C# 12 and .NET 8 – Modern
    Cross-Platform Development Fundamentals*, and now want to take their learning
    further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers who already have basic skills and knowledge about C# and .NET and want
    to learn practical skills and knowledge to build real-world applications and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion books to continue your learning journey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book is the second of three books in a trilogy that continues your learning
    journey through .NET 8:'
  prefs: []
  type: TYPE_NORMAL
- en: The first book covers the fundamentals of the C# language, the .NET libraries,
    and ASP.NET Core for web development. It is designed to be read linearly because
    skills and knowledge from earlier chapters build up and are needed to understand
    later chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This second book covers more specialized topics like internationalization and
    popular third-party packages including Serilog and NodaTime. You will learn how
    to build native AOT-compiled services with ASP.NET Core Minimal APIs and how to
    improve performance, scalability, and reliability using caching, queues, and background
    services. You will implement more services using GraphQL, gRPC, SignalR, and Azure
    Functions. Finally, you will learn how to build graphical user interfaces for
    websites, desktop, and mobile apps with Blazor and .NET MAUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third book covers important tools and skills that a professional .NET developer
    should have. These include design patterns and solution architecture, debugging,
    memory analysis, all the important types of testing whether unit, performance,
    or web and mobile, and then hosting and deployment topics like Docker and Azure
    Pipelines. Finally, we look at how to prepare for an interview to get the .NET
    developer career that you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A summary of the .NET 8 trilogy and their most important topics is shown in
    *Figure 1.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Companion books for learning C# 12 and .NET 8'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tools and Skills for .NET 8 Pros* is planned to be published in the first
    half of 2024\. Look out for it in your favorite bookstore and complete your .NET
    8 trilogy.'
  prefs: []
  type: TYPE_NORMAL
- en: We provide you with a PDF file that has color images of the screenshots and
    diagrams used in this book. You can download this file from [https://packt.link/gbp/9781837637133](https://packt.link/gbp/9781837637133).
  prefs: []
  type: TYPE_NORMAL
- en: What you will learn in this book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After this first chapter, this book can be divided into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing data**: How to store and manage data locally and in the cloud with
    SQL Server and Azure Cosmos DB. Later chapters use the SQL Server database and
    entity models that you will create at the end of *Chapter 3*, *Building Entity
    Models for SQL Server Using EF Core*. The chapter about Cosmos DB uses the SQL
    API, and there is an online-only chapter about Gremlin, which is a graph API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Specialized libraries**: Dates, times, and internationalization; improving
    performance with threads and tasks; and third-party libraries for image handling,
    data validation rules, and so on. These chapters can be treated like a cookbook
    of recipes. If you are not interested in any topic, you can skip it, and you can
    read them in any order.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Service technologies**: How to build and secure services with ASP.NET Core
    Web API Minimal APIs, GraphQL, gRPC, SignalR, and Azure Functions. To improve
    service scalability and reliability we cover queues, caching, and event scheduling.
    There is also an online-only chapter about OData services.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User interface technologies**: How to build user interfaces with ASP.NET
    Core, Blazor, and .NET MAUI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: My learning philosophy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most people learn complex topics best by imitation and repetition rather than
    reading a detailed explanation of the theory; therefore, I will not overload you
    with detailed explanations of every step throughout this book. The idea is to
    get you to write some code and see it run.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to know all the nitty-gritty details immediately. That will be
    something that comes with time as you build your own apps and go beyond what any
    book can teach you.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing my mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the words of Samuel Johnson, author of the English dictionary in 1755, I
    have committed “*a few wild blunders, and risible absurdities, from which no work
    of such multiplicity is free.*” I take sole responsibility for these and hope
    you appreciate the challenge of my attempt to lash the wind by writing this book
    about rapidly evolving technologies like C# and .NET, and the apps and services
    that you can build with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an issue with something in this book, then please contact me before
    resorting to a negative review on Amazon. Authors cannot respond to Amazon reviews
    so I cannot contact you to resolve the problem. I want to help you to get the
    best from my book, and I want to listen to your feedback and do better in the
    next edition. Please email me (my email address can be found in the GitHub repository
    for the book), chat with me in the Discord channel for the book ([https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)),
    or raise an issue at the following link: [https://github.com/markjprice/apps-services-net8/issues](https://github.com/markjprice/apps-services-net8/issues).'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the solution code on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution code in the GitHub repository for this book for all code editors
    is available at the following link: [https://github.com/markjprice/apps-services-net8/tree/main/code](https://github.com/markjprice/apps-services-net8/tree/main/code).'
  prefs: []
  type: TYPE_NORMAL
- en: Project naming and port numbering conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you complete all the coding tasks in this book, then you will end up with
    dozens of projects. Many of those will be websites and services that require port
    numbers for hosting on the `localhost` domain.
  prefs: []
  type: TYPE_NORMAL
- en: With large, complex solutions, it can be difficult to navigate the entire code.
    So, a good reason to structure your projects well is to make it easier to find
    components. It is good to have an overall name for your solution that reflects
    the application or solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1990s, Microsoft registered **Northwind** as a fictional company name
    for use in database and code samples. It was first used as the sample database
    for their Access product and then also used in SQL Server. We will build multiple
    projects for this fictional company, so we will use the name `Northwind` as a
    prefix for all the project names.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: There are many ways to structure and name projects and solutions,
    for example, using a folder hierarchy as well as a naming convention. If you work
    in a team, make sure you know how your team does it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to have a naming convention for your projects in a solution so that
    any developer can tell what each one does instantly. A common choice is to use
    the type of project, for example, class library, console app, website, and so
    on, as shown in *Table 1.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common` | A class library project for common types like interfaces,
    enums, classes, records, and structs, used across multiple projects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common.EntityModels` | A class library project for common EF Core
    entity models. Entity models are often used on both the server and client side,
    so it is best to separate dependencies on specific database providers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common.DataContext` | A class library project for the EF Core
    database context with dependencies on specific database providers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Mvc` | An ASP.NET Core project for a complex website that uses
    the MVC pattern and can be more easily unit tested. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.WebApi.Service` | An ASP.NET Core project for an HTTP API service.
    A good choice for integrating with websites because it can use any JavaScript
    library or Blazor to interact with the service. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.WebApi.Client.Console` | A client to a web service. The last part
    of the name indicates that it is a console app. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.gRPC.Service` | An ASP.NET Core project for a gRPC service. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.gRPC.Client.Mvc` | A client to a gRPC service. The last part of
    the name indicates that it is an ASP.NET Core MVC website project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.BlazorWasm.Client` | An ASP.NET Core Blazor WebAssembly client-side
    project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.BlazorWasm.Server` | An ASP.NET Core Blazor WebAssembly server-side
    project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.BlazorWasm.Shared` | A class library shared between client- and
    server-side Blazor projects. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.1: Example naming conventions for common project types'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable you to run any of these projects simultaneously, we must make sure
    that we do not configure duplicated port numbers. I have used the following convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://localhost:5[chapternumber]1/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5[chapternumber]2/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for the encrypted connection to the website built in *Chapter
    14*, *Building Web User Interfaces Using ASP.NET Core*, I used port `5141`, as
    shown in the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://localhost:5141/`'
  prefs: []
  type: TYPE_NORMAL
- en: Treating warnings as errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, compiler warnings may appear if there are potential problems with
    your code when you first build a project, but they do not prevent compilation
    and they are hidden if you rebuild. Warnings are given for a reason, so ignoring
    warnings encourages poor development practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some developers would prefer to be forced to fix warnings, so .NET provides
    a project setting to do this, as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I have enabled the option to treat warnings as errors in (almost) all the solutions
    in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exceptions are the gRPC projects. This is due to a combination of factors.
    In .NET 7 or later, the compiler will warn if you compile source files that contain
    only lowercase letters in the name of a type. For example, if you define a `person`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This compiler warning has been introduced so that a future version of C# can
    safely add a new keyword knowing it will not conflict with the name of a type
    that you have used because only C# keywords should contain only lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the Google tools for generating C# source files from `.proto`
    files generate aliases for class names that only contain lowercase letters, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you treat warnings as errors, then the compiler complains and refuses to
    compile the source code, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Always treat warnings as errors in your .NET projects (except
    for gRPC projects until Google updates their code generation tools).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find that you get too many errors after enabling this, you can disable
    specific warnings by using the `<WarningsNotAsErrors>` element with a comma-separated
    list of warning codes, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: You can learn more about controlling warnings as errors
    at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#warningsaserrors-and-warningsnotaserrors](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#warningsaserrors-and-warningsnotaserrors).'
  prefs: []
  type: TYPE_NORMAL
- en: App and service technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft calls platforms for building applications and services **app models**
    or **workloads**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET, .NET Core, .NET Framework, and Xamarin are related and overlapping platforms
    for developers used to build applications and services. If you are not familiar
    with the history of .NET, then I will point you to each of these .NET concepts
    at the following link, which is from the *C# 12 and .NET 8 – Modern Cross-Platform
    Development Fundamentals* book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch01-dotnet-history.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch01-dotnet-history.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Building websites and apps using ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Websites are made up of multiple web pages loaded statically from the filesystem
    or generated dynamically by a server-side technology such as ASP.NET Core. A web
    browser makes `GET` requests using **Unique Resource Locators** (**URLs**), which
    identify each page and can manipulate data stored on the server using `POST`,
    `PUT`, and `DELETE` requests.
  prefs: []
  type: TYPE_NORMAL
- en: With many websites, the web browser is treated as a presentation layer, with
    almost all the processing performed on the server side. Some JavaScript might
    be used on the client side to implement some presentation features, such as carousels,
    or to perform data validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides multiple technologies for building websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASP.NET Core Razor Pages** can dynamically generate HTML for simple websites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Core MVC** is an implementation of the **Model-View-Controller**
    (**MVC**) design pattern, which is popular for developing complex websites. You
    will learn about using it to build user interfaces in *Chapter 14*, *Building
    Web User Interfaces Using ASP.NET Core*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Razor class libraries** provide a way to package reusable functionality for
    ASP.NET Core projects including user interface components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor** lets you build user interface components using C# and .NET and then
    run them in a web browser or embedded web component instead of a JavaScript-based
    UI framework like Angular, React, and Vue. You will learn about Blazor in detail
    in *Chapter 15*, *Building Web Components Using Blazor*, and an online-only section
    titled*Leveraging Open-Source Blazor Component Libraries*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor is not just for building websites; it can also be used to create hybrid
    mobile and desktop apps when combined with .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes that you are already familiar with the fundamentals of ASP.NET
    Core development, so although the book reviews the basics, it quickly moves on
    to intermediate topics.
  prefs: []
  type: TYPE_NORMAL
- en: Building web and other services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no formal definitions, but services are sometimes described based
    on their complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service**: All functionality needed by a client app in one monolithic service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice**: Multiple services that each focus on a smaller set of functionalities.
    The guiding principle for what the boundary of functionality should be for a microservice
    is that each microservice should own its own data. Only that microservice should
    read/write to that data. If you have a data store that multiple services access,
    then they are not microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nanoservice**: A single function provided as a service. Unlike services and
    microservices that are hosted 24/7/365, nanoservices are often inactive until
    called upon to reduce resources and costs. For this reason, they are also known
    as serverless services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the theory of microservices and serverless services has made them a
    fashionable choice over the past decade or so, monolithic services have recently
    had a resurgence in popularity as developers have found the reality of microservices
    does not always match the theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn how to build ASP.NET Core Web API and Minimal API web services
    that use HTTP as the underlying communication technology and follow the design
    principles of Roy Field’s REST architecture. You will also learn how to build
    services using web and other technologies that extend basic web APIs, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gRPC**: For building highly efficient and performant microservices with support
    for almost any platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SignalR**: For implementing real-time communications between components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL**: For letting the client control what data is retrieved across multiple
    data sources. Although GraphQL can use HTTP, it does not have to, and it does
    not follow the web design principles defined by Roy Field in his dissertation
    about REST APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Functions**: For hosting serverless nanoservices in the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OData**: For easily wrapping EF Core and other data models as a web service.
    This is an online-only section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Communication Foundation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2006, Microsoft released .NET Framework 3.0 with some major new frameworks,
    one of which was **Windows Communication Foundation** (**WCF**). It abstracted
    the business logic implementation of a service from the communication technology
    infrastructure so that you could easily switch to an alternative in the future
    or even have multiple mechanisms to communicate with the service.
  prefs: []
  type: TYPE_NORMAL
- en: WCF heavily uses XML configuration to declaratively define endpoints, including
    their address, binding, and contract. This is known as the ABCs of WCF endpoints.
    Once you understand how to do this, WCF is a powerful yet flexible technology.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft decided not to officially port WCF to modern .NET, but there is a
    community-owned OSS project named **CoreWCF** managed by the .NET Foundation.
    If you need to migrate an existing service from .NET Framework to modern .NET
    or build a client to a WCF service, then you can use CoreWCF. Be aware that it
    can never be a full port since parts of WCF are Windows-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Technologies like WCF allow for the building of distributed applications. A
    client application can make **remote procedure calls** (**RPCs**) to a server
    application. Instead of using a port of WCF to do this, we should use an alternative
    RPC technology like gRPC, which is covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about CoreWCF in its GitHub repository
    found at the following link: [https://github.com/CoreWCF/CoreWCF](https://github.com/CoreWCF/CoreWCF).
    You can read the announcement about client support for calling WCF or CoreWCF
    with System.ServiceModel 6.0 at the following link: [https://devblogs.microsoft.com/dotnet/wcf-client-60-has-been-released/](https://devblogs.microsoft.com/dotnet/wcf-client-60-has-been-released/).'
  prefs: []
  type: TYPE_NORMAL
- en: Common service principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important service architecture principles is to make method
    calls chunky instead of chatty. In other words, try to bundle all the data needed
    for an operation in a single call, rather than requiring multiple calls to transmit
    all that information. This is because the overhead of a remote call is one of
    the biggest negative effects of services. This is also why having smaller and
    smaller services can hugely negatively impact a solution architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of choices for services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each service technology has its pros and cons based on its feature support,
    as shown in *Table 1.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Web API** | **OData** | **GraphQL** | **gRPC** | **SignalR**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Clients can request just the data they need | No | Yes | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Minimum HTTP version | 1.1 | 1.1 | 1.1 | 2.0 | 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Browser support | Yes | Yes | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Data format | XML, JSON | XML, JSON | GraphQL (JSONish) | Binary | Varies
    |'
  prefs: []
  type: TYPE_TB
- en: '| Service documentation | Swagger | Swagger | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Code generation | Third-party | Third-party | Third-party | Google | Microsoft
    |'
  prefs: []
  type: TYPE_TB
- en: '| Caching | Easy | Easy | Hard | Hard | Hard |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.2: Pros and cons of common service technologies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these recommendations for various scenarios as guidance, as shown in *Table
    1.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scenario** | **Recommendation** |'
  prefs: []
  type: TYPE_TB
- en: '| Public service | HTTP/1.1-based services are best for services that need
    to be publicly accessible, especially if they need to be called from a browser
    or mobile device. |'
  prefs: []
  type: TYPE_TB
- en: '| Public data service | OData and GraphQL are both good choices for exposing
    complex hierarchical datasets that could come from different data stores. OData
    is designed and supported by Microsoft via official .NET packages. GraphQL is
    designed by Facebook and supported by third-party packages. |'
  prefs: []
  type: TYPE_TB
- en: '| Service-to-service | gRPC is designed for low-latency and high-throughput
    communication. gRPC is great for lightweight internal microservices where efficiency
    is critical. |'
  prefs: []
  type: TYPE_TB
- en: '| Point-to-point real-time communication | gRPC has excellent support for bidirectional
    streaming. gRPC services can push messages in real time without polling. SignalR
    is designed for real-time communication of many kinds, so it tends to be easier
    to implement than gRPC although it is less efficient. |'
  prefs: []
  type: TYPE_TB
- en: '| Broadcast real-time communication | SignalR has great support for broadcasting
    real-time communication to many clients. |'
  prefs: []
  type: TYPE_TB
- en: '| Polyglot environment | gRPC tooling supports all popular development languages,
    making gRPC a good choice for multi-language and platform environments. |'
  prefs: []
  type: TYPE_TB
- en: '| Network-bandwidth-constrained environment | gRPC messages are serialized
    with Protobuf, a lightweight message format. A gRPC message is always smaller
    than an equivalent JSON message. |'
  prefs: []
  type: TYPE_TB
- en: '| Serverless nanoservice | Azure Functions do not need to be hosted 24/7 so
    they are a good choice for nanoservices that usually do not need to be running
    constantly. **Amazon Web Services** (**AWS**) Lambdas are an alternative. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.3: Service scenarios and the recommended implementation technology'
  prefs: []
  type: TYPE_NORMAL
- en: Building Windows-only apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technologies for building Windows-only apps, primarily for desktop, include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Forms**, 2002'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Presentation Foundation** (**WPF**), 2006'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Store**, 2012'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Windows Platform** (**UWP**), 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows App SDK** (formerly **WinUI 3** and **Project Reunion**), 2021'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding legacy Windows application platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the Microsoft Windows 1.0 release in 1985, the only way to create Windows
    applications was to use the C language and call functions in three core DLLs named
    `KERNEL`, `USER`, and `GDI`. Once Windows became 32-bit with Windows 95, the DLLs
    were suffixed with 32 and became known as **Win32 API**.
  prefs: []
  type: TYPE_NORMAL
- en: In 1991, Microsoft introduced Visual Basic, which provided developers with a
    visual, drag-and-drop-from-a-toolbox-of-controls way to build the user interface
    for Windows applications. It was immensely popular, and the Visual Basic runtime
    is still distributed as part of Windows 11 today.
  prefs: []
  type: TYPE_NORMAL
- en: With the first version of C# and .NET Framework released in 2002, Microsoft
    provided technology for building Windows desktop applications named **Windows
    Forms**. The equivalent at the time for web development was named **Web Forms**,
    hence the complementary names. The code could be written in either Visual Basic
    or C# languages. Windows Forms had a similar drag-and-drop visual designer, although
    it generated C# or Visual Basic code to define the user interface, which can be
    difficult for humans to understand and edit directly.
  prefs: []
  type: TYPE_NORMAL
- en: In 2006, Microsoft released a more powerful technology for building Windows
    desktop applications, named **Windows Presentation Foundation** (**WPF**), as
    a key component of .NET Framework 3.0 alongside **WCF** and Windows **Workflow**
    (**WF**).
  prefs: []
  type: TYPE_NORMAL
- en: Although a WPF app can be created by writing only C# statements, it can also
    use **eXtensible Application Markup Language** (**XAML**) to specify its user
    interface, which is easy for both humans and code to understand. Visual Studio
    2022 is partially built with WPF.
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, Microsoft released Windows 8 with its Windows Store apps that run in
    a protected sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, Microsoft released Windows 10 with an updated Windows Store app concept
    named **Universal Windows Platform** (**UWP**). UWP apps can be built using C++
    and DirectX UI, JavaScript and HTML, or C# using a custom fork of modern .NET
    that is not cross-platform but provides full access to the underlying WinRT APIs.
  prefs: []
  type: TYPE_NORMAL
- en: UWP apps can only execute on the Windows 10 or Windows 11 platforms, not earlier
    versions of Windows, but UWP apps can run on Xbox and Windows Mixed Reality headsets
    with motion controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Many Windows developers rejected Windows Store and UWP apps because they have
    limited access to the underlying system. Microsoft recently created **Project
    Reunion** and **WinUI 3**, which work together to allow Windows developers to
    bring some of the benefits of modern Windows development to their existing WPF
    apps and allow them to have the same benefits and system integrations that UWP
    apps have. This initiative is now known as **Windows App SDK**.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: This book does not cover Windows App SDK because it is
    not cross-platform. If you would like to learn more, you can start at the following
    link: [https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/](https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern .NET support for legacy Windows platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The on-disk size of the .NET SDKs for Linux and macOS is about 330 MB. The on-disk
    size of the .NET SDK for Windows is about 440 MB. This is because it includes
    **.NET Desktop Runtime**, which allows the legacy Windows application platforms
    Windows Forms and WPF to be run on modern .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many enterprise applications built using Windows Forms and WPF that
    need to be maintained or enhanced with new features, but until recently they were
    stuck on .NET Framework, which is now a legacy platform. With modern .NET and
    its .NET Desktop Runtime, these apps can now use the full modern capabilities
    of .NET. Windows desktop app developers can also optionally install the Windows
    Compatibility Pack. You can learn more about this at the following link: [https://learn.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack](https://learn.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack).'
  prefs: []
  type: TYPE_NORMAL
- en: Building cross-platform mobile and desktop apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two major mobile platforms, Apple’s iOS and Google’s Android, each
    with its own programming languages and platform APIs. There are also two major
    desktop platforms, Apple’s macOS and Microsoft’s Windows, each with its own programming
    languages and platform APIs, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iOS**: Objective-C or Swift and UIkit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: Java or Kotlin and Android API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS**: Objective-C or Swift and AppKit or Catalyst'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**: C, C++, or many other languages and Win32 API or Windows App SDK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform mobile and desktop apps can be built once for the **.NET Multi-platform
    App UI** (**MAUI**) platform and then can run on many mobile and desktop platforms.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI makes it easy to develop those apps by sharing user interface components
    as well as business logic; they can target the same .NET APIs as used by console
    apps, websites, and web services.
  prefs: []
  type: TYPE_NORMAL
- en: The apps can exist standalone, but they usually call services to provide an
    experience that spans all your computing devices, from servers and laptops to
    phones and gaming systems.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI supports existing MVVM and XAML patterns. The team also plans to
    add support in the future for **Model-View-Update** (**MVU**) with C#, which is
    like Apple’s Swift UI. MVU using Comet is still only a proof of concept. It is
    not as mature or well supported as Swift UI. I will not cover it in this book.
    You can read more about it at the following link: [https://github.com/dotnet/Comet](https://github.com/dotnet/Comet).'
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI alternatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Microsoft created .NET MAUI, third parties created open-source initiatives
    to enable .NET developers to build cross-platform apps using XAML, named **Uno**
    and **Avalonia**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Uno platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Uno is “*the first C# & XAML, free and open-source platform for creating true
    single-source, multi-platform applications*,” as stated on its own website at
    the following link: [https://platform.uno/](https://platform.uno/).'
  prefs: []
  type: TYPE_NORMAL
- en: Developers can reuse 99% of the business logic and UI layer across native mobile,
    web, and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: The Uno platform uses the Xamarin native platform but not Xamarin.Forms. For
    WebAssembly, Uno uses the mono-wasm runtime just like Blazor WebAssembly. For
    Linux, Uno uses Skia to draw the user interface on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'A book to read to learn about the Uno platform can be found at the following
    link: [https://www.packtpub.com/product/creating-cross-platform-c-applications-with-uno-platform/9781801078498](https://www.packtpub.com/product/creating-cross-platform-c-applications-with-uno-platform/9781801078498).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Avalonia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avalonia “*is a cross-platform UI framework for .NET. It creates pixel-perfect,
    native apps*” and “*is supported on all major platforms*.” Avalonia “*is the trusted
    UI framework for complex apps*,” as stated on its official website home page at
    the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Avalonia as a spiritual successor to WPF. WPF, Silverlight,
    and UWP developers can continue to benefit from their years of pre-existing knowledge
    and skills.
  prefs: []
  type: TYPE_NORMAL
- en: It was used by JetBrains to modernize their legacy WPF-based tools and take
    them cross-platform. This means their C# code editor runs on Windows, macOS, and
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The Avalonia extension for Visual Studio 2022 and deep integration with JetBrains
    Rider makes development easier and more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the theory about the apps and services technologies
    that can be used with .NET 8, let’s get practical and see how you can set up your
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start programming, you’ll need a code editor for C#. Microsoft has
    a family of code editors and **Integrated Development Environments** (**IDEs**),
    which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code for Windows, Mac, or Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code for the Web or GitHub Codespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third parties have created their own C# code editors, for example, JetBrains
    Rider, which is available for Windows, Mac, or Linux but does have a license cost.
    JetBrains Rider is popular with more experienced .NET developers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Although JetBrains is a fantastic company with great products,
    both Rider and the ReSharper extension for Visual Studio are software, and all
    software has bugs and quirky behavior. For example, they might show errors like
    “Cannot resolve symbol” in your Razor Pages, Razor views, and Blazor components.
    Yet you can build and run those files because there is no actual problem. If you
    have installed the Unity Support plugin, then it will complain about boxing operations,
    which are a genuine problem for Unity game developers. But in this book we will
    not create any Unity projects so the boxing warnings do not apply.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapters 1* to *15*, you can use Visual Studio 2022 or cross-platform Visual
    Studio Code and JetBrains Rider to build all the apps and services. In *Chapter
    16*, *Building Mobile and Desktop Apps Using .NET MAUI*; and its *online sections*,
    *Implementing Model-View-ViewModel for .NET MAUI* and *Integrating .NET MAUI Apps
    with Blazor and Native Platforms*, although you could use Visual Studio Code to
    build the mobile and desktop app, it is not easy. Visual Studio 2022 has better
    support for .NET MAUI than Visual Studio Code does (for now).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the appropriate tool and application type for learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the best tool and application type for building apps and services with
    C# and .NET?
  prefs: []
  type: TYPE_NORMAL
- en: I want you to be free to choose any C# code editor or IDE to complete the coding
    tasks in this book, including Visual Studio Code, Visual Studio 2022, or even
    JetBrains Rider.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I give general instructions that work with all tools so you can
    use whichever tool you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio 2022 for general development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio 2022 can create most types of applications, including console
    apps, websites, web services, desktop, and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use Visual Studio 2022 with a .NET MAUI project to write a
    cross-platform mobile app, you still need macOS and Xcode to compile it.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 only runs on Windows 10 version 1909 or later, or Windows
    Server 2016 or later, and only on 64-bit versions. Version 17.4 is the first version
    to support native Arm64.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Visual Studio 2022 for Mac does not officially support .NET 8
    and it will reach end-of-life in August 2024\. If you have been using Visual Studio
    2022 for Mac then you should switch to Visual Studio Code for Mac, JetBrains Rider
    for Mac, or use Visual Studio 2022 for Windows in a virtual machine on your local
    computer or in the cloud using a technology like Microsoft Dev Box. The retirement
    announcement can be read here: [https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/](https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio Code for cross-platform development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most modern and lightweight code editor to choose from, and the only one
    from Microsoft that is cross-platform, is Visual Studio Code. It can run on all
    common operating systems, including Windows, macOS, and many varieties of Linux,
    including **Red Hat Enterprise Linux** (**RHEL**) and Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is a good choice for modern cross-platform development because
    it has an extensive and growing set of extensions to support many languages beyond
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: Being cross-platform and lightweight, it can be installed on all platforms that
    your apps will be deployed to for quick bug fixes and so on. Choosing Visual Studio
    Code means a developer can use a cross-platform code editor to develop cross-platform
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code has strong support for web development, although it currently
    has weak support for mobile and desktop development.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is supported on ARM processors, so you can develop on Apple
    Silicon computers and Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code is by far the most popular integrated development environment,
    with over 73% of professional developers selecting it in the Stack Overflow 2023
    survey that you can read at the following link: [https://survey.stackoverflow.co/2023/](https://survey.stackoverflow.co/2023/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub Codespaces for development in the cloud
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Codespaces is a fully configured development environment based on Visual
    Studio Code that can be spun up in an environment hosted in the cloud and accessed
    through any web browser. It supports Git repos, extensions, and a built-in command-line
    interface so you can edit, run, and test from any device.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about GitHub Codespaces at the following
    link: [https://github.com/features/codespaces](https://github.com/features/codespaces).'
  prefs: []
  type: TYPE_NORMAL
- en: What I used
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write and test the code for this book, I used the following hardware and
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 for Windows on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 11 on the HP Spectre (Intel) laptop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual Studio Code on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS on the Apple Silicon Mac mini (M1) desktop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 11 on the HP Spectre (Intel) laptop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JetBrains Rider on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 11 on the HP Spectre (Intel) laptop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS on the Apple Silicon Mac mini (M1) desktop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope that you have access to a variety of hardware and software too because
    seeing the differences on various platforms deepens your understanding of development
    challenges, although any one of the above combinations is enough to learn how
    to build practical apps and websites.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting Started**: *Chapter 1* of the *C# 12 and .NET 8 – Modern Cross-Platform
    Development Fundamentals* book has online sections showing how to get started
    with multiple projects using various code editors like Visual Studio 2022, Visual
    Studio Code, or JetBrains Rider. You can read the sections at the following link:
    [https://github.com/markjprice/cs12dotnet8/blob/main/docs/code-editors/README.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/code-editors/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains Rider and its warnings about boxing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use JetBrains Rider and you have installed the Unity Support plugin,
    then it will complain a lot about boxing. A common scenario when boxing happens
    is when value types like `int` and `DateTime` are passed as positional arguments
    to `string` formats. This is a problem for Unity projects because they use a different
    memory garbage collector to the normal .NET runtime. For non-Unity projects, like
    all the projects in this book, you can ignore these boxing warnings because they
    are not relevant. You can read more about this Unity-specific issue at the following
    link: [https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing](https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing).'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying cross-platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your choice of code editor and operating system for development does not limit
    where your code gets deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 8 supports the following platforms for deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: Windows 10 version 1607 or later. Windows 11 version 22000 or
    later. Windows Server 2012 R2 SP1 or later. Nano Server version 1809 or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mac**: macOS Catalina version 10.15 or later and in the Rosetta 2 x64 emulator.
    Mac Catalyst 11.0 or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**: Alpine Linux 3.17 or later. Debian 11 or later. Fedora 37 or later.
    openSUSE 15 or later. Oracle Linux 8 or later. **Red Hat Enterprise Linux** (**RHEL**)
    8 or later. SUSE Enterprise Linux 12 SP2 or later. Ubuntu 20.04 or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: API 21 or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS** and **tvOS**: 11.0 or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** .NET support for Windows 7 and 8.1 ended in January 2023: [https://github.com/dotnet/core/issues/7556](https://github.com/dotnet/core/issues/7556).'
  prefs: []
  type: TYPE_NORMAL
- en: Windows ARM64 support in .NET 5 and later means you can develop on, and deploy
    to, Windows Arm devices like Microsoft’s Windows Dev Kit 2023 (formerly known
    as Project Volterra) and Surface Pro X.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can review the latest supported operating systems and versions at the following
    link: [https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md](https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Visual Studio 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many professional Microsoft developers use Visual Studio 2022 in their day-to-day
    development work. Even if you choose to use Visual Studio Code to complete the
    coding tasks in this book, you might want to familiarize yourself with Visual
    Studio 2022 too.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a Windows computer, then you can skip this section and continue
    to the next section where you will download and install Visual Studio Code on
    macOS or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since October 2014, Microsoft has made a professional quality edition of Visual
    Studio 2022 available to students, open-source contributors, and individuals for
    free. It is called Community Edition. Any of the editions are suitable for this
    book. If you have not already installed it, let’s do so now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio 2022 version 17.8 or later from the following link:
    [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Workloads** tab, select the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ASP.NET and web development**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure development**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Multi-platform App UI development**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET desktop development** (because this includes console apps)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desktop development with C++** with all default components (because this
    enables publishing console apps and web services that start faster and have smaller
    memory footprints)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the **Individual components** tab, in the **Code tools** section, select
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Git for Windows**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **Install** and wait for the installer to acquire the selected software
    and install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installation is complete, click **Launch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first time that you run Visual Studio, you will be prompted to sign in.
    If you have a Microsoft account, you can use that account. If you don’t, then
    register for a new one at the following link: [https://signup.live.com/](https://signup.live.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time that you run Visual Studio, you will be prompted to configure
    your environment. For **Development Settings**, choose **Visual C#**. For the
    color theme, I chose **Blue**, but you can choose whatever tickles your fancy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to customize your keyboard shortcuts, navigate to **Tools** | **Options…**,
    and then select the **Environment** | **Keyboard** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio 2022 keyboard shortcuts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, I will avoid showing keyboard shortcuts since they are often customized.
    Where they are consistent across code editors and commonly used, I will try to
    show them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to identify and customize your keyboard shortcuts, then you can,
    as shown at the following link: [https://learn.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio](https://learn.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio).'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code has rapidly improved over the past couple of years and has
    pleasantly surprised Microsoft with its popularity. If you are brave and like
    to live on the bleeding edge, then there is the **Insiders** edition, which is
    a daily build of the next version.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you plan to only use Visual Studio 2022 for development, I recommend
    that you download and install Visual Studio Code and try the coding tasks in this
    chapter using it, and then decide if you want to stick with just using Visual
    Studio 2022 for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now download and install Visual Studio Code, the .NET SDK, and the C#
    Dev Kit extension:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install either the Stable build or the Insiders edition of Visual
    Studio Code from the following link: [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Information**: If you need more help installing Visual Studio Code on
    any operating system, you can read the official setup guide at the following link:
    [https://code.visualstudio.com/docs/setup/setup-overview](https://code.visualstudio.com/docs/setup/setup-overview).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download and install the .NET SDK for version 8.0 from the following link:
    [https://www.microsoft.com/net/download](https://www.microsoft.com/net/download).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install the **C# Dev Kit** extension using the user interface, you must first
    launch the Visual Studio Code application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, click the **Extensions** icon or navigate to **View**
    | **Extensions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**C# Dev Kit** is one of the most popular extensions available, so you should
    see it at the top of the list, or you can enter `C# Dev Kit` in the search box.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**C# Dev Kit** has a dependency on the **C#** extension version 2.0 or later,
    so you do not have to install the **C#** extension separately. Note that **C#**
    extension version 2.0 or later no longer uses OmniSharp since it has a new **Language
    Service Protocol (LSP)** host. **C# Dev Kit** also has dependencies on the **.NET
    Install Tool for Extension Authors** and **IntelliCode for C# Dev Kit** extensions
    so they will be installed too.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Install** and wait for the supporting packages to download and install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Be sure to read the license agreement for **C# Dev Kit**.
    It has a more restrictive license than the **C#** extension: [https://aka.ms/vs/csdevkit/license](https://aka.ms/vs/csdevkit/license).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing other extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In later chapters of this book, you will use more Visual Studio Code extensions.
    If you want to install them now, all the extensions that we will use are shown
    in *Table 1.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Extension name and identifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **C# Dev Kit**`ms-dotnettools.csdevkit` | Official C# extension from Microsoft.
    Manage your code with a solution explorer and test your code with integrated unit
    test discovery and execution.Includes the **C#** and **IntelliCode for C# Dev
    Kit** extensions. |'
  prefs: []
  type: TYPE_TB
- en: '| **C#**`ms-dotnettools.csharp` | C# editing support, including syntax highlighting,
    IntelliSense, Go To Definition, Find All References, debugging support for .NET,
    and support for `csproj` projects on Windows, macOS, and Linux. |'
  prefs: []
  type: TYPE_TB
- en: '| **IntelliCode for C# Dev Kit**`ms-dotnettools.vscodeintellicode-csharp` |
    Provides AI-assisted development features for Python, TypeScript/JavaScript, C#,
    and Java developers. |'
  prefs: []
  type: TYPE_TB
- en: '| **MSBuild project tools**`tintoy.msbuild-project-tools` | Provides IntelliSense
    for MSBuild project files, including autocomplete for `<PackageReference>` elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **SQL Server (mssql) for Visual Studio Code**`ms-mssql.mssql` | For developing
    SQL Server, Azure SQL Database, and SQL data warehouses everywhere with a rich
    set of functionalities. |'
  prefs: []
  type: TYPE_TB
- en: '| **REST Client**`humao.rest-client` | Send an HTTP request and view the response
    directly in Visual Studio Code. |'
  prefs: []
  type: TYPE_TB
- en: '| **ilspy-vscode**`icsharpcode.ilspy-vscode` | Decompile MSIL assemblies –
    support for modern .NET, .NET Framework, .NET Core, and .NET Standard. |'
  prefs: []
  type: TYPE_TB
- en: '| **vscode-proto3**`zxh404.vscode-proto3` | Syntax highlighting, syntax validation,
    code snippets, code completion, code formatting, brace matching, and line and
    block commenting. |'
  prefs: []
  type: TYPE_TB
- en: '| **Azure Functions for Visual Studio Code**`ms-azuretools.vscode-azurefunctions`
    | Create, debug, manage, and deploy serverless apps directly from VS Code. It
    has dependencies on the Azure Account (`ms-vscode.azure-account`) and Azure Resources
    (`ms-azuretools.vscode-azureresourcegroups`) extensions. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.4: Visual Studio Code extensions used in this book'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Visual Studio Code extensions at the command prompt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can install a Visual Studio Code extension at the command prompt or terminal,
    as shown in *Table 1.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `code --list-extensions` | List installed extensions. |'
  prefs: []
  type: TYPE_TB
- en: '| `code --install-extension <extension-id>` | Install the specified extension.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `code --uninstall-extension <extension-id>` | Uninstall the specified extension.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.5: Working with extensions at the command prompt'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to install the **C# Dev Kit** extension, enter the following at
    the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I have created PowerShell scripts to install and uninstall the Visual Studio
    Code extensions in the preceding table. You can find them at the following link:
    [https://github.com/markjprice/apps-services-net8/tree/main/scripts/extension-scripts](https://github.com/markjprice/apps-services-net8/tree/main/scripts/extension-scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Microsoft Visual Studio Code versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Microsoft releases a new feature version of Visual Studio Code (almost) every
    month and bug-fix versions more frequently. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.78.0, April 2023 feature release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 1.78.1, April 2023 bug fix release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version used in this book is 1.83.0, September 2023 feature release, but
    the version of Microsoft Visual Studio Code is less important than the version
    of the C# extension that you installed.
  prefs: []
  type: TYPE_NORMAL
- en: While the C# extension is not required, it provides IntelliSense as you type,
    code navigation, and debugging features, so it’s something that’s very handy to
    install and keep updated to support the latest C# language features.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code keyboard shortcuts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, I will avoid showing keyboard shortcuts used for tasks like creating
    a new file since they are often different on different operating systems. The
    situations where I will show keyboard shortcuts are when you need to repeatedly
    press the key, for example, while debugging. These are also more likely to be
    consistent across operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to customize your keyboard shortcuts for Visual Studio Code, then
    you can, as shown at the following link: [https://code.visualstudio.com/docs/getstarted/keybindings](https://code.visualstudio.com/docs/getstarted/keybindings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you download a PDF of keyboard shortcuts for your operating
    system from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming Azure resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the chapters in this book will require you to sign up for an Azure account
    and create Azure resources. Frequently, there are free tiers or local development
    versions of these services, but sometimes you will have to create a resource that
    generates costs for the time it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Packt books use technical reviewers who complete all the coding exercises just
    like a reader would. Here is what one of the TRs of the **second edition** (**2E**)
    of this book said about their Azure costs. “I got my Azure bill. To run through
    2E on a “paid” account cost me $3.01.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft currently says, “*Eligible new users get $200 Azure credit in your
    billing currency for the first 30 days and a limited quantity of free services
    for 12 months with your Azure free account.*” You can learn more at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/avoid-charges-free-account](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/avoid-charges-free-account)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Delete Azure resources as soon as you do not need them to
    keep your costs low.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A summary of which chapters need Azure resources and if a local development
    alternative is available is shown in *Table 1.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Chapter** | **Azure resource** | **Free tier** | **Local development alternative**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 to 16 | SQL Database | As part of the free first year. | SQL Server Developer
    Edition on Windows, or SQL Edge in a Docker container on Windows, Linux, and macOS.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Cosmos DB database | 1,000 RU/s and 25 GB of storage. | Azure Cosmos
    DB emulator on Windows or the preview version on Linux. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Azure Functions | 1 million requests and 400,000 GBs of resource consumption
    per month. | Azurite open-source emulator for testing Azure Blob, Queue Storage,
    and Table storage applications like Azure Functions. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Azure SignalR Service | 20 concurrent connections and 20,000 messages
    per day with 99.9% SLA. | Add SignalR to any ASP.NET Core project for local development.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.6: Chapters that use Azure resources and local development alternatives'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out how to check your usage of free Azure resources at the following
    link: [https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/check-free-service-usage](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/check-free-service-usage).'
  prefs: []
  type: TYPE_NORMAL
- en: Using other project templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you install the .NET SDK, there are many project templates included. Let’s
    review them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: .NET 7 and later SDKs support either `dotnet new --list` or `dotnet new list`.
    The .NET 6 and earlier SDKs only support `dotnet new --list`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will see a list of currently installed templates, including templates for
    Windows desktop development if you are running on Windows, the most common of
    which are shown in *Table 1.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Template Name** | **Short Name** | **Language** |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI App | `maui` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI Blazor App | `maui-blazor` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core Empty | `web` | C#, F# |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core gRPC Service | `grpc` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core Web API | `webapi` | C#, F# |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core Web API (native AOT) | `webapiaot` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core Web App (Model-View-Controller) | `mvc` | C#, F# |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Web App | `blazor` | C# |'
  prefs: []
  type: TYPE_TB
- en: '| Class Library | `classlib` | C#, F#, VB |'
  prefs: []
  type: TYPE_TB
- en: '| Console App | `console` | C#, F#, VB |'
  prefs: []
  type: TYPE_TB
- en: '| `EditorConfig` File | `editorconfig` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `global.json` File | `globaljson` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Solution File | `sln` |  |'
  prefs: []
  type: TYPE_TB
- en: '| xUnit Test Project | `xunit` |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.7: Project template full and short names'
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI projects are not supported for Linux. The team has said they have
    left that work to the open-source community. If you need to create a truly cross-platform
    graphical app, then take a look at Avalonia at the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing additional template packs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developers can install lots of additional template packs:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a browser and navigate to [https://www.nuget.org/packages](https://www.nuget.org/packages).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `vue` in the **Search for packages…** textbox and note that about 210
    packages are returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Filter**, select a **Package Type** of **Template**, click **Apply**,
    and note the list of about 25 available templates, including one published by
    Microsoft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Vue.Simple.Template** and then click **Project website**, and note
    the instructions for installing and using this template, as shown in the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploring top-level programs, functions, and namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since .NET 6, the default project template for console apps uses the top-level
    program feature introduced with .NET 5\. It is important to understand how it
    works with the automatically generated `Program` class and its `<Main>$` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how the top-level program feature works when you define functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred coding tool to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `TopLevelFunctions`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter01`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publishing**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, define a local function at
    the bottom of the file, and call it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note that the namespace for the `Program` class is
    `null`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is automatically generated for a local function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compiler automatically generates a `Program` class with a `<Main>$` function,
    then moves your statements and function inside the `<Main>$` method, and renames
    the local function, as shown highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the compiler to know where what statements need to go, you must follow
    some rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Import statements (`using`) must go at the top of the `Program.cs` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that will go in the `<Main>$` function must go in the middle of the
    `Program.cs` file. Any functions will become **local functions** in the `<Main>$`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is important because local functions have limitations, for example,
    they cannot have XML comments to document them.
  prefs: []
  type: TYPE_NORMAL
- en: Writing static functions in a separate Program class file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A better approach is to write any functions in a separate class file and define
    them as `static` members of the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Functions.cs`. The name has no effect, but
    it is a good practice to name it so that it is clear that this file is related
    to the `Program.cs` class file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, define a `partial Program` class, then cut and paste
    the `WhatsMyNamespace` function to move it from `Program.cs` into `Program.Functions.cs`,
    and finally add the `static` keyword, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, confirm that its entire content is now just three statements,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console app and note that it has the same behavior as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is automatically generated for a static function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use a separate file to define a partial `Program` class with `static`
    functions, the compiler defines a `Program` class with a `<Main>$` function and
    moves your top-level statements inside the `<Main>$` method, and then merges your
    function as a member of the `Program` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is much cleaner, and you can document your functions with XML comments,
    which also provide tooltips in your code editor when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Create any functions that you will call in `Program.cs`
    in a separate file and manually define them inside a `partial Program` class.
    This will merge them into the automatically generated `Program` class *at the
    same level* as the `<Main>$` method, instead of as local functions *inside* the
    `<Main>$` method.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note the lack of namespace declarations. Both the automatically
    generated `Program` class and the explicitly defined `Program` class are in the
    default `null` namespace. If you define your `partial Program` class in a namespace,
    then it will be in a different namespace and therefore not merge with the auto-generated
    `partial Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not define a namespace for any `partial Program` classes
    that you create so that they will be defined in the default `null` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, all the `static` methods in the `Program` class could be explicitly
    declared as `private` but this is the default anyway. Since all the functions
    will be called within the `Program` class itself the access modifier is not important.
  prefs: []
  type: TYPE_NORMAL
- en: Making good use of the GitHub repository for this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Git** is a commonly used source code management system. **GitHub** is a company,
    website, and desktop application that makes it easier to manage Git. Microsoft
    purchased GitHub in 2018, so it will continue to be closely integrated with Microsoft
    tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I created a GitHub repository for this book, and I use it for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To store the solution code for the book, which will be maintained after the
    print publication date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide extra materials that extend the book, like errata fixes, small improvements,
    lists of useful links, and longer articles that cannot fit in the printed book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide a place for readers to get in touch with me if they have issues with
    the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising issues with the book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you get stuck following any of the instructions in this book, or if you
    spot a mistake in the text or the code in the solutions, please raise an issue
    in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite browser to navigate to the following link: [https://github.com/markjprice/apps-services-net8/issues](https://github.com/markjprice/apps-services-net8/issues).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New Issue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter as much detail as possible that will help me to diagnose the issue. For
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The specific section title, page number, and step number.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code editor, for example, Visual Studio 2022, Visual Studio Code, or something
    else, including the version number.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As much of your code and configuration that you feel is relevant and necessary.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A description of the expected behavior and the behavior experienced.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Screenshots (you can drag and drop image files into the issue box).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is less relevant but might be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Your operating system, for example, Windows 11 64-bit, or macOS Big Sur version
    11.2.3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your hardware, for example, Intel, Apple silicon, or ARM CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I want all my readers to be successful with my book, so if I can help you (and
    others) without too much trouble, then I will gladly do so.
  prefs: []
  type: TYPE_NORMAL
- en: Giving me feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’d like to give me more general feedback about the book, then you can
    email me at `markjprice@gmail.com`. My publisher, Packt, has set up Discord channels
    for readers to interact with authors and other readers. You are welcome to join
    us at the following link: [https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8).'
  prefs: []
  type: TYPE_NORMAL
- en: I love to hear from my readers about what they like about my books, as well
    as suggestions for improvements and how they are working with C# and .NET, so
    don’t be shy. Please get in touch!
  prefs: []
  type: TYPE_NORMAL
- en: Thank you in advance for your thoughtful and constructive feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading solution code from the GitHub repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I use GitHub to store solutions to all the hands-on, step-by-step coding examples
    throughout chapters and the practical exercises that are featured at the end of
    each chapter. You will find the repository at the following link: [https://github.com/markjprice/apps-services-net8](https://github.com/markjprice/apps-services-net8).'
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to download all the solution files without using Git, click
    the green **Code** button and then select **Download ZIP**.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you add the preceding link to your favorites or bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: It is best to clone or download the code solutions to a
    short folder path, like `C:\cs12dotnet8\` or `C:\book\`, to avoid build-generated
    files exceeding the maximum path length. You should also avoid special characters
    like `#`. For example, do not use a folder name like `C:\C# projects\`. That folder
    name might work for a simple console app project but once you start adding features
    that automatically generate code you are likely to have strange issues. Keep your
    folder names short and simple.'
  prefs: []
  type: TYPE_NORMAL
- en: Where to go for help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is all about how to find quality information about programming
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Reading documentation on Microsoft Learn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definitive resource for getting help with Microsoft developer tools and
    platforms is in the technical documentation on Microsoft Learn, and you can find
    it at the following link: [https://learn.microsoft.com/en-us/docs](https://learn.microsoft.com/en-us/docs).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting help for the dotnet tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the command prompt, you can ask the `dotnet` tool for help with its commands.
    The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will cause your web browser to open a page in the documentation about the
    specified command. Common `dotnet` commands include `new`, `build`, and `run`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** The `dotnet help new` command worked with .NET Core 3.1 to .NET
    6, but it returns an error with .NET 7 or later: `Specified command ''new'' is
    not a valid SDK command. Specify a valid SDK command. For more information, run
    dotnet help.` Hopefully, the .NET team will fix that bug soon!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of help is command-line documentation. It follows this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For example, `dotnet new -?` or `dotnet new -h` or `dotnet new --help` outputs
    documentation about the `new` command at the command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: As you should now expect, `dotnet help help` opens a web browser for the `help`
    command, and `dotnet help -h` outputs documentation for the `help` command at
    the command prompt!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the official documentation in a web browser window for the `dotnet
    build` command, enter the following at the command prompt or in the Visual Studio
    Code terminal, and note the page opened in your web browser, as shown in *Figure
    1.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19587_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Web page documentation for the dotnet build command'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get help output at the command prompt, use the `-?`, `-h`, or `--help` flag,
    as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repeat both types of help request for the following commands: `add`, `help`,
    `list`, `new`, and `run`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AI tools like ChatGPT and GitHub Copilot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest changes in coding and development in the past year is the
    emergence of generative **artificial intelligence** (**AI**) tools that can help
    with coding tasks like completing a code statement, implementing an entire function,
    writing unit tests, and suggesting debugging fixes for existing code.
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ChatGPT currently has two models: 3.5 (free) and 4.0 ($20 per month).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you need to understand more about how to design a microservice. You
    might enter the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It responds with a summary of those top three mistakes, as shown in detail
    in *Figure 1.3* and the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: ChatGPT advising about microservice architecture design'
  prefs: []
  type: TYPE_NORMAL
- en: '“Designing a microservice architecture is a complex task, and there are several
    common mistakes that can lead to significant issues, even causing a project to
    be abandoned. Here are the top three most common mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improper Service Boundaries:** One of the most challenging aspects of designing
    a microservice architecture is defining the boundaries of each service. If the
    services are too large (a mistake often called a “monolith in disguise”), you
    lose many of the benefits of microservices due to tight coupling of different
    concerns. On the other hand, if the services are too small (sometimes referred
    to as “nanoservices”), you might have to deal with excessive inter-service communication,
    resulting in high latency and complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of proper boundaries can also lead to data consistency issues. If multiple
    services are interacting with the same database tables, it can be difficult to
    maintain data consistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid this mistake, it’s important to understand the business domain thoroughly
    and design services around business capabilities. Techniques such as **Domain-Driven
    Design** (**DDD**) can help identify service boundaries more effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inadequate Consideration for Data Management:** Each microservice should
    own its own data to ensure loose coupling. Sharing databases across services leads
    to tight coupling and makes it difficult to change the schema without affecting
    other services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, managing data across services introduces challenges with data consistency
    and transaction management. Developers often underestimate these challenges. They
    might try to implement distributed transactions, which are complex and can hurt
    performance, instead of using eventual consistency and compensation transactions
    (the Saga pattern).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neglecting Operational Complexity:** Microservice architectures add operational
    complexity. You’re moving from managing a single monolithic application to managing
    multiple services, each potentially written in different languages, using different
    data storage technologies, and running in different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This requires a mature DevOps capability, including automated deployment, monitoring,
    and good logging practices. You need to plan for how services will be monitored,
    how logs will be aggregated and analyzed, and how deployments and rollbacks will
    be handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring the operational challenges of microservices can lead to significant
    issues down the line. For instance, it can become very difficult to debug issues
    that span multiple services without good tracing and logging. Deploying changes
    can become a nightmare without automated deployment and good testing practices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, designing a microservice architecture isn’t a trivial task. It
    requires a deep understanding of the business domain, careful planning, and a
    mature DevOps capability. However, when done right, microservices can provide
    significant benefits, including better scalability, flexibility, and maintainability.”
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Copilot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft has a service specifically for programmers named GitHub Copilot that
    can help autocomplete code directly in your code editor. It is being enhanced
    with more intelligence using GPT-4\. It has plugins for code editors including
    Visual Studio 2022, Visual Studio Code, and JetBrains IntelliJ-based IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Copilot is free for students, teachers, and some open-source project
    maintainers. For everyone else, it has a 30-day free trial and then it costs $10
    per month or $100 per year for individuals. Once you have an account, you can
    then sign up for the more advanced experimental GitHub Copilot X features.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should check online for which Copilot features are available for various
    code editors. As you can imagine, this is a fast-changing world and a lot of what
    I might write in the book today will be out of date by the time you read it: [https://github.com/features/copilot](https://github.com/features/copilot).'
  prefs: []
  type: TYPE_NORMAL
- en: 'JetBrains has its own equivalent named AI Assistant, which you can read about
    at the following link: [https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/](https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can sign up for GitHub Copilot at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/github-copilot/signup/](https://github.com/github-copilot/signup/)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to the official .NET blog and announcements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep up to date with .NET, an excellent blog to subscribe to is the official
    .NET blog, written by the .NET engineering teams, and you can find it at the following
    link: [https://devblogs.microsoft.com/dotnet/](https://devblogs.microsoft.com/dotnet/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I also recommend that you subscribe to the official .NET announcements repository
    at the following link: [https://github.com/dotnet/announcements](https://github.com/dotnet/announcements).'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring with deeper research the topics in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the web to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it good practice to add the following setting to your project files?
    And when should you not set it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which service technology requires a minimum HTTP version of 2?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 2010, your organization created a service using .NET Framework and WCF. What
    is the best technology to migrate it to and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which code editor or IDE should you install for .NET development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should you beware of when creating Azure resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 1.2 – Review the online-only sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To preserve space in the print book, there are some optional online-only sections
    available in the GitHub repository. They are not needed for the rest of the book,
    but you will find them useful for general knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What’s New in Modern C# and .NET**: In this section, the goal is to review
    what is new since C# 6 and .NET Core 1.0, which were released in 2016\. Instead
    of just listing the new features introduced with each version of .NET, this section
    takes a themed approach to make it easier to understand how small individual improvements
    introduced over multiple versions are designed to work together. This section
    will also be updated throughout the lifetime of .NET 8, from November 2023 to
    November 2026\. This will include new language and library features introduced
    in .NET 9 and .NET 10 ([https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-whats-new.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-whats-new.md)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking Performance and Testing**: In this section, you will learn how
    to use types in the `System.Diagnostics` namespace and the Benchmark.NET library
    to monitor your code to measure performance and efficiency ([https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observing and Modifying Code Execution Dynamically**: This is about some
    common types that are included with .NET for performing code reflection and applying
    and reading attributes, working with expression trees, and creating source generators
    ([https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-dynamic-code.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-dynamic-code.md)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 1.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-1---introducing-apps-and-services-with-net](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-1---introducing-apps-and-services-with-net)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you:'
  prefs: []
  type: TYPE_NORMAL
- en: Were introduced to the app and service technologies that you will learn about
    in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up your development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned where to look for help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use SQL Server to store and manage
    relational data.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code3048220001028652625.png)'
  prefs: []
  type: TYPE_IMG
