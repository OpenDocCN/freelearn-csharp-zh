<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Design Patterns - .NET Core</h1>
                </header>
            
            <article>
                
<p><span>The previous chapter continued the building of the FlixOne inventory management application by incorporating additional patterns. More of the Gang of Four patterns were used, including the Singleton and Factory patterns. The Singleton pattern was used to illustrate the Repository pattern that was used to maintain the FlixOne collection of books. The Factory pattern was used to further explore the <strong>dependency injection</strong> (<strong>DI</strong>).</span> <span>The .Net Core framework</span> <span>was used to complete the initial inventory management console application, in order to</span> <span>facilitate</span> <span>an <strong>inversion of control</strong> (<strong>IoC</strong>) container</span><span>.</span></p>
<p>This chapter will continue building upon the inventory management console application, while also exploring features of .Net Core. The Singleton pattern, which was covered in the previous chapter, will be revisited and created, using the Singleton service lifetime built into the .Net Core framework. Using the framework's DI, the Configuration pattern will be shown, as well as <strong>constructor injection (CI)</strong> explained, using different examples.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>.Net Core service lifetimes</li>
<li>Implementation factory</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter contains various code examples that are used to explain the concepts. The code is kept simple, and is just for demonstration purposes. Most of the examples involve a .NET Core console application written in C#.</p>
<p>To run and execute the code, you need the following:</p>
<ul>
<li>Visual Studio 2019 (you can also run the application using Visual Studio 2017 <span>V</span>ersion 3<span> </span>or later).</li>
<li>Setting up .NET Core.</li>
<li>SQL server (express edition is used in this chapter).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio</h1>
                </header>
            
            <article>
                
<p>To run these code examples, you need to install Visual Studio 2010, or later. You can use your preferred IDE. To do this, follow these instructions:</p>
<ol>
<li>Download Visual Studio from the following link:<span> </span><a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.</li>
<li>Follow the installation instructions included. Multiple versions are available for Visual Studio installation. In this chapter, we are using Visual Studio for Windows.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up .NET Core</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you do not have .NET Core installed, you need to follow these instructions:</p>
<ol>
<li class="mce-root">Download .NET Core from the following link:<span> </span><a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.</li>
<li> The installation instructions and the related library can be found at the following link: <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.</li>
</ol>
<div class="packt_infobox"><span>The complete source code is available in the GitHub repository. The source code shown in the chapter might not be complete, so it is advisable to retrieve the source in order to run the examples. Please refer to <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5.</a></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">.Net Core service lifetimes</h1>
                </header>
            
            <article>
                
<p>A fundamental concept to understand when working with .Net Core's DI, is service lifetimes. A service lifetime defines how a dependency is managed in regards to how often it is created. As an illustration of this process, think of DI as managing a container of dependencies. Dependency is just a class that the DI knows about, because the class was <em>registered</em> with it. For .Net Core's DI, this is done with the following three methods of <kbd>IServiceCollection</kbd>:</p>
<ul>
<li><kbd>AddTransient&lt;TService, TImplementation&gt;()</kbd></li>
<li><kbd>AddScoped&lt;<span>TService, TImplementation</span>&gt;()</kbd></li>
<li><kbd>AddSingleton&lt;<span>TService, TImplementation</span>&gt;()</kbd></li>
</ul>
<p>The <kbd>IServiceCollection</kbd> interface is a collection of registered service descriptions, basically containing the dependency, and when the DI should supply the dependency. For example, when <kbd>TService</kbd> is requested, <kbd>TImplementation</kbd> is supplied (that is, injected).</p>
<p>In this section, we will look at the three service lifetimes, and provide an illustration of the different lifetimes via unit tests. We will also look at how implementation factories can be used to create instances of the dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transient</h1>
                </header>
            
            <article>
                
<p>A <kbd>transient</kbd> dependency means each time the DI receives a request for a dependency, then a new instance of the dependency will be created. In most situations, this is the service lifetime that makes the most sense to use, as most classes should be designed to be lightweight, stateless services. In situations where the state needs to be persisted between references and/or if there is considerable effort in instantiating a new instance, then another service lifetime might make more sense.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scoped</h1>
                </header>
            
            <article>
                
<p>In .Net Core, there is the concept of a scope, which can be thought of as a context or boundary for the executing process. In some .Net Core implementations, the scope is implicitly defined, so you might not be aware that it is being put in place. For example, in ASP.Net Core, a scope is created for each web request that is received. This means that, if a dependency has a Scoped lifetime, then it will only be constructed once per web request, so, if the same dependency is used multiple times for the same web request, it will be shared.</p>
<p>Later in this chapter, we will explicitly create a scope in order to illustrate a Scoped lifetime, and the same concept applies in the unit test as it will in an ASP.Net Core application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton</h1>
                </header>
            
            <article>
                
<p>In .Net Core, the Singleton pattern is implemented so that dependency is only ever instantiated once, just like the Singleton pattern that was implemented in the previous chapter. Similar to the Singleton pattern in the previous chapter, the <kbd>singleton</kbd> class needs to be thread safe, and only the factory method that is used to create the singleton class is guaranteed to be called only once by a single thread.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Back to FlixOne </h1>
                </header>
            
            <article>
                
<p>To illustrate .Net Core's DI, we need to make some modifications to the FlixOne inventory management application. The first thing to do will be to update the <kbd>InventoryContext</kbd> class, which was defined earlier, in order to no longer implement the Singleton pattern (as we will do this using .Net Core's DI):</p>
<pre>public class InventoryContext : IInventoryContext<br/>{<br/>    public InventoryContext()<br/>    {<br/>       _books = new ConcurrentDictionary&lt;string, Book&gt;();<br/>    }<br/><br/>    private readonly static object _lock = new object(); <br/><br/>    private readonly IDictionary&lt;string, Book&gt; _books;<br/><br/>    public Book[] GetBooks()<br/>    {<br/>        return _books.Values.ToArray();<br/>    }<br/><br/>    ...<br/>}</pre>
<p>The detail of the <kbd>AddBook</kbd> and <kbd>UpdateQuantity</kbd> methods are shown in the following code:</p>
<pre>public bool AddBook(string name)<br/>{<br/>    _books.Add(name, new Book {Name = name});<br/>    return true;<br/>}<br/><br/>public bool UpdateQuantity(string name, int quantity)<br/>{<br/>    lock (_lock)<br/>    {<br/>        _books[name].Quantity += quantity;<br/>    }<br/><br/>    return true;<br/>}</pre>
<p>There are a couple of things to note. The constructor has been changed from protected to public. This will allow the class to be instantiated by objects outside of the class. Also, note that the static <kbd>Instance</kbd> property and the private static <kbd>_instance</kbd> field have been removed, while the private <kbd>_lock</kbd> field remains. Similar to the Singleton pattern defined in the previous chapter, this only guarantees how the class is instantiated; it does not prevent methods from being accessed in parallel.</p>
<div class="packt_infobox">Both the <kbd>IInventoryContext</kbd> interface and the <kbd>InventoryContext</kbd> and <kbd>Book</kbd> classes were made public, as our DI is being defined in an external project.</div>
<p>Subsequently, the <kbd>InventoryCommandFactory</kbd> class, which is used to return commands, has been updated to have an instance of the <kbd>InventoryContext</kbd> injected into its constructor:</p>
<pre>public class InventoryCommandFactory : IInventoryCommandFactory<br/>{<br/>    private readonly IUserInterface _userInterface;<br/>    private readonly IInventoryContext _context;<br/><br/>    public InventoryCommandFactory(IUserInterface userInterface, IInventoryContext context)<br/>    {<br/>        _userInterface = userInterface;<br/>        _context = context;<br/>    }<br/><br/>    // GetCommand()<br/>    ...<br/>}</pre>
<p>The <kbd>GetCommand</kbd> method uses the input provided to determine the specific command:</p>
<pre>public InventoryCommand GetCommand(string input)<br/>{<br/>    switch (input.ToLower())<br/>    {<br/>        case "q":<br/>        case "quit":<br/>            return new QuitCommand(_userInterface);<br/>        case "a":<br/>        case "addinventory":<br/>            return new AddInventoryCommand(_userInterface, _context);<br/>        case "g":<br/>        case "getinventory":<br/>            return new GetInventoryCommand(_userInterface, _context);<br/>        case "u":<br/>        case "updatequantity":<br/>            return new UpdateQuantityCommand(_userInterface, _context);<br/>        case "?":<br/>            return new HelpCommand(_userInterface);<br/>        default:<br/>            return new UnknownCommand(_userInterface);<br/>    }<br/>}</pre>
<p><span>As noted, the</span> <kbd>IInventoryContext</kbd> interface <span>will now be supplied by the DI container that is defined in the client project. The console application now has an additional line to create a Singleton of the</span> <kbd>IInventoryContext</kbd> <span>interface using the</span> <kbd>InventoryContext</kbd> <span>class:</span></p>
<pre>class Program<br/>{<br/>    private static void Main(string[] args)<br/>    {<br/>        IServiceCollection services = new ServiceCollection();<br/>        ConfigureServices(services);<br/>        IServiceProvider serviceProvider = services.BuildServiceProvider();<br/><br/>        var service = serviceProvider.GetService&lt;ICatalogService&gt;();<br/>        service.Run();<br/><br/>        Console.WriteLine("CatalogService has completed.");<br/>        Console.ReadLine();<br/>    }<br/><br/>    private static void ConfigureServices(IServiceCollection services)<br/>    {<br/>        // Add application services.<br/>        services.AddTransient&lt;IUserInterface, ConsoleUserInterface&gt;(); <br/>        services.AddTransient&lt;ICatalogService, CatalogService&gt;();<br/>        services.AddTransient&lt;IInventoryCommandFactory, InventoryCommandFactory&gt;();<br/><br/><strong>        services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;();</strong><br/>    }<br/>}</pre>
<p>The console application can now be run with the same manual test as that performed in the previous chapter, but unit tests are a great way to understand what is being achieved using .Net Core's DI.</p>
<div class="packt_infobox">The example code provided for this chapter shows the completed project. The following section concentrates on the <kbd>InventoryContext</kbd> tests. The <kbd>InventoryCommandFactory</kbd> tests were also modified, but, as the changes are trivial, they will not be covered here.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>With the changes to the <kbd>InventoryContext</kbd> class, we no longer have a convenient property for getting the only instance of the class. This means that <kbd>InventoryContext.Instance</kbd> will need to be replaced, and, as a first attempt, let's create a method to return a new instance of <kbd>InventoryContext</kbd>, and use <kbd>GetInventoryContext()</kbd> instead of <kbd>InventoryContext.Instance</kbd>:</p>
<pre>private IInventoryContext GetInventoryContext()<br/>{<br/>    return new InventoryContext();<br/>}</pre>
<p>As expected, the unit tests fail with an error message: <em>The given key was not present in the dictionary</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/270f856b-e1dc-475a-8a82-22e9288276cb.png" style=""/></div>
<p>As we saw in the previous chapter, this is because the <kbd>InventoryContext</kbd> list of books is empty each time the <kbd>InventoryContext</kbd> class is created. This is why we need to create a context using a Singleton. </p>
<p>Let's update the <kbd>GetInventoryContext()</kbd> method to now supply an instance of the <kbd>IInventoryContext</kbd> interface using .Net Core's DI:</p>
<pre>private IInventoryContext GetInventoryContext()<br/>{<br/>    IServiceCollection services = new ServiceCollection();<br/>    services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;();<br/>    var provider = services.BuildServiceProvider();<br/><br/>    return provider.GetService&lt;IInventoryContext&gt;();<br/>}</pre>
<p>In the updated method, an instance of the <kbd>ServiceCollection</kbd> class is created, which will be used to contain all the registered dependencies. The <kbd>InventoryContext</kbd> class is registered as a Singleton to be supplied when the <kbd>IInventoryContext</kbd> dependency is requested. A <kbd>ServiceProvider</kbd> instance is then generated, which will actually perform the DI based on the reg<span>i</span>strations in the <kbd>IServiceCollection</kbd> interface. The final step is to supply the <kbd>InventoryContext</kbd> class when the <kbd>IInventoryContext</kbd> interface is requested. </p>
<div class="packt_infobox"> The <kbd>Microsoft.Extensions.DependencyInjection</kbd> library will need to be added to the <kbd>InventoryManagementTests</kbd> project in order to be able to reference the .Net Core DI components.</div>
<p>Unfortunately, the unit test still does not pass, and results in the same error: <em>The given key was not present in the dictionary. </em>This is because we are creating a new instance of the DI framework each time <kbd>IInventoryContext</kbd> is requested. This means that even though our dependency is a Singleton, each instance of <kbd>ServiceProvider</kbd> will supply a new instance of the <kbd>InventoryContext</kbd> class. To get around this, we will create <kbd>IServiceCollection</kbd> when the test first starts up, and then we will use the same reference during the test:</p>
<pre>ServiceProvider Services { get; set; }<br/><br/>[TestInitialize]<br/>public void Startup()<br/>{<br/>    IServiceCollection services = new ServiceCollection();<br/>    services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;();<br/>    Services = services.BuildServiceProvider();<br/>}</pre>
<div class="packt_tip">Using the <kbd>TestInitialize</kbd> attribute is a great way to separate the functionality required by multiple <kbd>TestMethod</kbd> tests within a <kbd>TestClass</kbd> class. The method will be run before every test is run.</div>
<p>Now that there is a reference to the same <kbd>ServiceProvider</kbd> instance, we can update to retrieve the dependency. The following illustrates how the <kbd>AddBook()</kbd> method has been updated:</p>
<pre>public Task AddBook(string book)<br/>{<br/>    return Task.Run(() =&gt;<br/>    {<br/>        Assert.IsTrue(<strong>Services.GetService&lt;IInventoryContext&gt;()</strong>.AddBook(book));<br/>    });<br/>}</pre>
<p>Our unit test now passes successfully, as only one instance of the <kbd>InventoryContext</kbd> class is created during the execution of the test: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c92dd81-8d8c-466a-982e-ab7862dcab15.png" style=""/></div>
<p>The Singleton pattern is relatively easy to implement using the built-in DI, as illustrated in this section. Understanding when to use the pattern is an important concept. The next section will explore the concept of scope in more detail, in order to gain a further understanding of service lifetimes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scope</h1>
                </header>
            
            <article>
                
<p>In applications that have multiple processes executing simultaneously, understanding service lifetime is very important to both functional and non-functional requirements. As illustrated in the previous unit test without the correct service lifetime, <kbd>InventoryContext</kbd> did not function as desired, and led to an invalid situation. Likewise, the incorrect use of service lifetimes could lead to applications that do not scale well. In general, the use of a lock-and-shared state should be avoided in multi-process solutions.</p>
<p>To illustrate this concept, imagine the FlixOne inventory management application was supplied to multiple staff members. The challenge now is how to perform a lock across multiple applications, and how to have a single collected state. In our terms, this would be a single <kbd>InventoryContext</kbd> class shared by multiple applications. Of course, this is where changing our solution to use a shared repository (for example, a database) would make sense, and/or changing our solution to a web application. We will cover databases and web application patterns in later chapters, but, as we are discussing service lifetimes, it does make sense to describe these in terms of a web application in more detail now.</p>
<p>The following diagram depicts a web app receiving two requests:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a28f0bf1-4c7f-43ab-9cc4-3de7694fdf4c.png" style=""/></div>
<p>In terms of service lifetimes, a Singleton service lifetime will be available to both requests, while each request receives its own Scope lifetime. The important thing to note is around garbage collection. Dependencies that are created with a Transient service lifetime are marked to be released once the object is no longer referenced, while dependencies created with a Scope service lifetime are not marked to be released until the web request completes. And, dependencies created with a Singleton service lifetime are not marked to be released until the application ends.</p>
<p>Also, as shown in the following diagram, it is important to remember that dependencies in .Net Core are not shared between server instances in a web garden or web farm:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13d3bc5b-0273-488b-9db0-f87daf198604.png" style=""/></div>
<p>In the following chapters, different approaches to the shared state will be shown, including using a shared cache, databases, and other forms of repositories. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation factory</h1>
                </header>
            
            <article>
                
<p>The .Net Core DI supports the ability to specify an <em>implementation factory</em> when registering a dependency. This allows for control over the creation of the dependency that is supplied by the service provided. This is done when registering by using the following extension of the <kbd>IServiceCollection</kbd> interface:</p>
<pre>public static IServiceCollection AddSingleton&lt;TService, TImplementation&gt;(this IServiceCollection services,     <strong>Func&lt;IServiceProvider, TImplementation&gt; implementationFactory</strong>)<br/>                where TService : class<br/>                where TImplementation : class, TService;</pre>
<p>The <kbd>AddSingleton</kbd> extension receives both a class to be registered as well as the class to be supplied when the dependency is required. An interesting thing to note is the .Net Core DI framework will maintain the registered services and either deliver the implementation when requested, or as part of instantiating one of the dependencies. This automatic instantiation is called <strong>constructor injection</strong> (<strong>CI</strong>). We will see examples of both in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IInventoryContext</h1>
                </header>
            
            <article>
                
<p>As an example, let's revisit the <kbd>InventoryContext</kbd> class that is used to manage the inventory of books, by segregating the read and the write operations performed on our collection of books. <kbd>IInventoryContext</kbd> is split into <kbd>IInventoryReadContext</kbd> and <kbd>IInventoryWriteContext</kbd>:</p>
<pre>using FlixOne.InventoryManagement.Models;<br/><br/>namespace FlixOne.InventoryManagement.Repository<br/>{<br/>    public interface IInventoryContext : IInventoryReadContext, IInventoryWriteContext { }<br/><br/>    public interface IInventoryReadContext<br/>    {<br/>        Book[] GetBooks();<br/>    }<br/><br/>    public interface IInventoryWriteContext<br/>    {<br/>        bool AddBook(string name);<br/>        bool UpdateQuantity(string name, int quantity);<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IInventoryReadContext</h1>
                </header>
            
            <article>
                
<p>The <kbd>IInventoryReadContext</kbd> interface contains the operation to read the books, while <kbd>IInventoryWriteContext</kbd> contains the operations that modify the collection of books. The original <kbd>IInventoryContext</kbd> interface was created for convenience for when a class requires both dependency types.</p>
<div class="packt_infobox">In later chapters, we will cover patterns that take advantage of splitting the context, including the <span><strong>Command and</strong> <strong>Query Responsibility Segregation</strong> (</span><strong>CQRS</strong><span>) pattern.</span></div>
<p>With this refactor, some changes are required. First classes only requiring to read the collection of books have their constructor updated with the <kbd>IInventoryReadContext</kbd> interface, as illustrated in the <kbd>GetInventoryCommand</kbd> class:</p>
<pre>internal class GetInventoryCommand : NonTerminatingCommand<br/>{<br/>    private readonly <strong>IInventoryReadContext</strong> _context;<br/>    internal GetInventoryCommand(IUserInterface userInterface, <strong>IInventoryReadContext context</strong>) : base(userInterface)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    protected override bool InternalCommand()<br/>    {<br/>        foreach (var book in _context.GetBooks())<br/>        {<br/>            Interface.WriteMessage($"{book.Name,-30}\tQuantity:{book.Quantity}"); <br/>        }<br/><br/>        return true;<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IInventoryWriteContext</h1>
                </header>
            
            <article>
                
<p>Likewise, classes requiring to modify the collection of books are updated to the <kbd>IInventoryWriteContext</kbd> interface, as illustrated with <kbd>AddInventoryCommand</kbd>:</p>
<pre>internal class AddInventoryCommand : NonTerminatingCommand, IParameterisedCommand<br/>{<br/>    private readonly IInventoryWriteContext _context;<br/><br/>    internal AddInventoryCommand(IUserInterface userInterface, IInventoryWriteContext context) : base(userInterface)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    public string InventoryName { get; private set; }<br/><br/>    ...<br/>}</pre>
<p>The following shows the detail of the <kbd>GetParameters</kbd> and <kbd>InternalCommand</kbd> methods:</p>
<pre>/// &lt;summary&gt;<br/>/// AddInventoryCommand requires name<br/>/// &lt;/summary&gt;<br/>/// &lt;returns&gt;&lt;/returns&gt;<br/>public bool GetParameters()<br/>{<br/>    if (string.IsNullOrWhiteSpace(InventoryName))<br/>        InventoryName = GetParameter("name");<br/>    return !string.IsNullOrWhiteSpace(InventoryName);<br/>}<br/><br/>protected override bool InternalCommand()<br/>{<br/>    return _context.AddBook(InventoryName); <br/>}</pre>
<p>Note the <kbd>InternalCommand</kbd> method, where the book is added to the inventory with the given name of the book held in the <kbd>InventoryName</kbd> parameter.</p>
<p>Next, we will look at the factory for the inventory commands.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">InventoryCommandFactory</h1>
                </header>
            
            <article>
                
<p>The <kbd>InventoryCommandFactory</kbd> class is an implementation of the Factory pattern using .Net classes, which requires both readings of, and writing to, the collection of books:</p>
<pre>public class InventoryCommandFactory : IInventoryCommandFactory<br/>{<br/>    private readonly IUserInterface _userInterface;<br/>    private readonly <strong>IInventoryContext _context</strong>; <br/><br/>    public InventoryCommandFactory(IUserInterface userInterface, <strong>IInventoryContext context</strong>)<br/>    {<br/>        _userInterface = userInterface;<br/>        _context = context; <br/>    }<br/><br/>    public InventoryCommand GetCommand(string input)<br/>    {<br/>        switch (input.ToLower())<br/>        {<br/>            case "q":<br/>            case "quit":<br/>                return new QuitCommand(_userInterface);<br/>            case "a":<br/>            case "addinventory":<br/>                return new AddInventoryCommand(_userInterface, _context);<br/>            case "g":<br/>            case "getinventory":<br/>                return new GetInventoryCommand(_userInterface, _context);<br/>            case "u":<br/>            case "updatequantity":<br/>                return new UpdateQuantityCommand(_userInterface, _context);<br/>            case "?":<br/>                return new HelpCommand(_userInterface);<br/>            default:<br/>                return new UnknownCommand(_userInterface);<br/>        }<br/>    }<br/>}</pre>
<p>An interesting thing to note, is that the class actually did not require modifying from the previous chapter's version, as polymorphism handles the casting from <kbd>IInventoryContext</kbd> to the <kbd>IInventoryReadContext</kbd> and <kbd>IInventoryWriteContext</kbd> interfaces.</p>
<p>With these changes, we need to change the registration of the dependencies that are related to <kbd>InventoryContext</kbd>, in order to use an implementation factory:</p>
<pre>private static void ConfigureServices(IServiceCollection services)<br/>{<br/>    // Add application services.<br/>    ...            <br/><br/>    <strong>var context = new InventoryContext();</strong><br/><strong>    services.AddSingleton&lt;IInventoryReadContext, InventoryContext&gt;(p =&gt; context);</strong><br/><strong>    services.AddSingleton&lt;IInventoryWriteContext, InventoryContext&gt;(p =&gt; context);</strong><br/><strong>    services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;(p =&gt; context);</strong><br/>}</pre>
<p>For all three interfaces, the same instance of <kbd>InventoryContext</kbd> will be used, and this is instantiated once using the implementation factory extension. This is supplied when a <kbd>IInventoryReadContext</kbd>, <kbd>IInventoryWriteContext</kbd>, or <kbd>IInventoryContext</kbd> dependency is requested. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">InventoryCommand</h1>
                </header>
            
            <article>
                
<p><kbd>InventoryCommandFactory</kbd> was useful to illustrate how the Factory pattern could be achieved using .Net, but let's revisit this now that we are using the .Net Core framework. Our requirement is given a string value; we want to return a particular implementation of <kbd>InventoryCommand</kbd>. This can be achieved in several ways, and, in this section, three examples will be given:</p>
<ul>
<li>Implementation factory using a function</li>
<li>Using services</li>
<li>Using third-party containers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation factory using a function</h1>
                </header>
            
            <article>
                
<p class="mce-root">The implementation factory of the <kbd>GetService()</kbd> method can be used to determine the type of <kbd>InventoryCommand</kbd> class to be returned. For this example, a new static method is created in the <kbd>InventoryCommand</kbd> class: </p>
<pre>public static Func&lt;IServiceProvider, Func&lt;string, InventoryCommand&gt;&gt; GetInventoryCommand =&gt; <br/>                                                                            provider =&gt; input =&gt;<br/>{<br/>    switch (input.ToLower())<br/>    {<br/>        case "q":<br/>        case "quit":<br/>            return new QuitCommand(provider.GetService&lt;IUserInterface&gt;());<br/>        case "a":<br/>        case "addinventory":<br/>            return new AddInventoryCommand(provider.GetService&lt;IUserInterface&gt;(), provider.GetService&lt;IInventoryWriteContext&gt;());<br/>        case "g":<br/>        case "getinventory":<br/>            return new GetInventoryCommand(provider.GetService&lt;IUserInterface&gt;(), provider.GetService&lt;IInventoryReadContext&gt;());<br/>        case "u":<br/>        case "updatequantity":<br/>            return new UpdateQuantityCommand(provider.GetService&lt;IUserInterface&gt;(), provider.GetService&lt;IInventoryWriteContext&gt;());<br/>        case "?":<br/>            return new HelpCommand(provider.GetService&lt;IUserInterface&gt;());<br/>        default:<br/>            return new UnknownCommand(provider.GetService&lt;IUserInterface&gt;());<br/>    }<br/>};</pre>
<p><span>This is a little tricky to read if you are not familiar with lambda expression bodies, so we will explain the code in a bit of detail. First of all, let's revisit the syntax of the <kbd>AddSingleton</kbd>:</span></p>
<pre>public static IServiceCollection AddSingleton&lt;TService, TImplementation&gt;(this IServiceCollection services, <strong>Func&lt;IServiceProvider, TImplementation&gt; implementationFactory</strong>)<br/>            where TService : class<br/>            where TImplementation : class, TService;</pre>
<p>This shows that the parameter of the <kbd>AddSingleton</kbd> extension is a function:</p>
<pre><strong>Func&lt;IServiceProvider, TImplementation&gt; implementationFactory</strong></pre>
<p>This means that the following code is equivalent:</p>
<pre>services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;(provider =&gt; new InventoryContext());<br/><br/>services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;(GetInventoryContext);</pre>
<p>The <kbd>GetInventoryContext</kbd> method is defined as follows:</p>
<pre>static Func&lt;IServiceProvider, InventoryContext&gt; GetInventoryContext =&gt; provider =&gt;<br/>{<br/>    return new InventoryContext();<br/>};</pre>
<p>In our particular example, the specific <kbd>InventoryCommand</kbd> types have been marked as internal to the <kbd>FlixOne.InventoryManagement</kbd> project, so the <kbd>FlixOne.InventoryManagementClient</kbd> project is not able to access them directly. This is why a new static method was created in the <span><kbd>FlixOne.InventoryManagement.InventoryCommand</kbd> class that returned the following type:</span></p>
<pre>Func&lt;IServiceProvider, <strong>Func&lt;string, InventoryCommand&gt;</strong>&gt;</pre>
<p>What this means is, when the service is requested, a string will be supplied to determine the specific type. Because the dependency changed, this means the <kbd>CatalogService</kbd> constructor requires updating:</p>
<pre>public CatalogService(IUserInterface userInterface, Func&lt;string, InventoryCommand&gt; commandFactory)<br/>{<br/>    _userInterface = userInterface;<br/>    _commandFactory = commandFactory;<br/>}</pre>
<p>When the service is requested, a string will be supplied to determine the specific. Because the dependency changed, the <kbd>CatalogueService</kbd> constructor requires updating:</p>
<p>Now when the string the user has entered is supplied to the <kbd>CommandFactory</kbd> dependency, the correct command is supplied:</p>
<pre>while (!response.shouldQuit)<br/>{<br/>    // look at this mistake with the ToLower()<br/>    var input = _userInterface.ReadValue("&gt; ").ToLower();<br/>    var command = <strong>_commandFactory(input);</strong><br/><br/>    response = command.RunCommand();<br/><br/>    if (!response.wasSuccessful)<br/>    {<br/>        _userInterface.WriteMessage("Enter ? to view options.");<br/>    }<br/>}</pre>
<p>The unit tests associated with the command factory were also updated. As a comparison, a new <kbd>test</kbd> class was created from the existing <kbd>InventoryCommandFactoryTests</kbd> class, and named <kbd>InventoryCommandFunctionTests</kbd>. The initialization step is shown in the following code, with the changes highlighted:</p>
<pre><strong>ServiceProvider Services { get; set; }</strong><br/><br/>[TestInitialize]<br/>public void Startup()<br/>{<br/>    var expectedInterface = new Helpers.TestUserInterface(<br/>        new List&lt;Tuple&lt;string, string&gt;&gt;(),<br/>        new List&lt;string&gt;(),<br/>        new List&lt;string&gt;()<br/>    );<br/><br/>    IServiceCollection services = new ServiceCollection();<br/>    services.AddSingleton&lt;IInventoryContext, InventoryContext&gt;();<br/><strong>    services.AddTransient&lt;Func&lt;string, InventoryCommand&gt;&gt;(InventoryCommand.GetInventoryCommand);</strong><br/><br/>    Services = services.BuildServiceProvider();<br/>}</pre>
<p>The individual tests were also updated to supply the string as part of the get service call, as shown in the following code with <kbd>QuitCommand</kbd>:</p>
<pre>[TestMethod]<br/>public void QuitCommand_Successful()<br/>{<br/>    Assert.IsInstanceOfType(Services.GetService&lt;Func&lt;string, InventoryCommand&gt;&gt;().Invoke("q"),             <br/>                            typeof(QuitCommand), <br/>                            "q should be QuitCommand");<br/><br/>    Assert.IsInstanceOfType(Services.GetService&lt;Func&lt;string, InventoryCommand&gt;&gt;().Invoke("quit"),<br/>                            typeof(QuitCommand), <br/>                            "quit should be QuitCommand");<br/>}</pre>
<p>The two tests verify that the services that are returned are of the <kbd>QuitCommand</kbd> type, when the service provider is given <kbd>"q"</kbd> or <kbd>"quit"</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using services</h1>
                </header>
            
            <article>
                
<p>The <kbd>ServiceProvider</kbd> class provides a <kbd>Services</kbd> method that can be used to determine the appropriate service, when there are multiple dependencies registered for the same type. This example will take a different tack with <kbd>InventoryCommands</kbd>, and, because of the extent of the refactor, this will be done with new classes that will be created just to illustrate this approach.</p>
<p>In the unit test project, a new folder, <kbd>ImplementationFactoryTests</kbd>, was created, to contain the classes for this section. In the folder, a new base class for <kbd>InventoryCommand</kbd> was created:</p>
<pre>public abstract class InventoryCommand<br/>{<br/>    protected abstract string[] CommandStrings { get; }<br/>    public virtual bool IsCommandFor(string input)<br/>    {<br/>        return CommandStrings.Contains(input.ToLower());<br/>    } <br/>}</pre>
<p>The concept behind this new class is that child classes will define the strings that they respond to. For example, <kbd>QuitCommand</kbd> will respond to the <kbd>"q"</kbd> and <kbd>"quit"</kbd> strings:</p>
<pre>public class QuitCommand : InventoryCommand<br/>{<br/>    protected override string[] CommandStrings =&gt; new[] { "q", "quit" };<br/>}</pre>
<p class="mce-root"/>
<p>The following shows the <kbd>GetInventoryCommand</kbd>, <kbd>AddInventoryCommand</kbd>, <kbd>UpdateQuantityCommand</kbd>, and <kbd>HelpCommand</kbd> classes, which follow a similar approach:</p>
<pre>public class GetInventoryCommand : InventoryCommand<br/>{<br/>    protected override string[] CommandStrings =&gt; new[] { "g", "getinventory" };<br/>}<br/><br/>public class AddInventoryCommand : InventoryCommand<br/>{<br/>    protected override string[] CommandStrings =&gt; new[] { "a", "addinventory" };<br/>}<br/><br/>public class UpdateQuantityCommand : InventoryCommand<br/>{<br/>    protected override string[] CommandStrings =&gt; new[] { "u", "updatequantity" };<br/>}<br/><br/>public class HelpCommand : InventoryCommand<br/>{<br/>    protected override string[] CommandStrings =&gt; new[] { "?" };<br/>}</pre>
<p>The <kbd>UnknownCommand</kbd> class, though, will be used as a default, so it will always evaluate to true, by overriding the <kbd>IsCommandFor</kbd> method:</p>
<pre>public class UnknownCommand : InventoryCommand<br/>{<br/>    protected override string[] CommandStrings =&gt; new string[0];<br/><br/>    public override bool IsCommandFor(string input)<br/>    {<br/>        return true;<br/>    }<br/>}</pre>
<p>Because the <kbd>UnknownCommand</kbd> class is being treated as a default, the order of registration is important, and is shown below in the initialization of the unit <kbd>test</kbd> class:</p>
<pre>[TestInitialize]<br/>public void Startup()<br/>{<br/>    var expectedInterface = new Helpers.TestUserInterface(<br/>        new List&lt;Tuple&lt;string, string&gt;&gt;(),<br/>        new List&lt;string&gt;(),<br/>        new List&lt;string&gt;()<br/>    );<br/><br/>    IServiceCollection services = new ServiceCollection(); <br/>    services.AddTransient&lt;InventoryCommand, QuitCommand&gt;();<br/>    services.AddTransient&lt;InventoryCommand, HelpCommand&gt;(); <br/>    services.AddTransient&lt;InventoryCommand, AddInventoryCommand&gt;();<br/>    services.AddTransient&lt;InventoryCommand, GetInventoryCommand&gt;();<br/>    services.AddTransient&lt;InventoryCommand, UpdateQuantityCommand&gt;();<br/>    // UnknownCommand should be the last registered<br/><strong>    services.AddTransient&lt;InventoryCommand, UnknownCommand&gt;();</strong><br/><br/>    Services = services.BuildServiceProvider();<br/>}</pre>
<p>For convenience, a new method has been created in order to return an instance of the <kbd>InventoryCommand</kbd> class when given a matching input string:</p>
<pre>public InventoryCommand GetCommand(string input)<br/>{<br/>    return Services.GetServices&lt;InventoryCommand&gt;().First(svc =&gt; svc.IsCommandFor(input));<br/>}</pre>
<p>This method will traverse the collection of dependencies that are registered for the <kbd>InventoryCommand</kbd> service, until a match is found by using the <kbd>IsCommandFor()</kbd> method.</p>
<p>The unit test then uses the <kbd>GetCommand()</kbd> method to determine the dependency, as shown below for <kbd>UpdateQuantityCommand</kbd>:</p>
<pre>[TestMethod]<br/>public void UpdateQuantityCommand_Successful()<br/>{<br/>    Assert.IsInstanceOfType(GetCommand("u"), <br/>                            typeof(UpdateQuantityCommand), <br/>                            "u should be UpdateQuantityCommand");<br/><br/>    Assert.IsInstanceOfType(GetCommand("updatequantity"), <br/>                            typeof(UpdateQuantityCommand), <br/>                            "updatequantity should be UpdateQuantityCommand");<br/><br/>    Assert.IsInstanceOfType(GetCommand("UpdaTEQuantity"), <br/>                            typeof(UpdateQuantityCommand), <br/>                            "UpdaTEQuantity should be UpdateQuantityCommand");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using third-party containers</h1>
                </header>
            
            <article>
                
<p>The .Net Core framework provides great flexibility and functionality, but some features might not be supported, and a third-party container might be a more appropriate choice. Fortunately .Net Core is extensible and allows for the built-in service container to be replaced by a third-party container. To provide an example, we will use <kbd>Autofac</kbd> as our IoC container of the .Net Core DI. </p>
<div class="packt_infobox"><kbd>Autofac</kbd> has a ton of great features, and is shown here as an example; but of course, there are other IoC containers that could have been used. For example, Castle Windsor and Unit are great alternatives that should also be considered.</div>
<p>The first step is to add the required <kbd>Autofac</kbd> package to the project. Using the package manager console, add the package using the following command (only required on the test project):</p>
<pre><strong>install-package autofac</strong></pre>
<p>This example will again support our <kbd>InventoryCommand</kbd> factory by using an <kbd>Autofac</kbd> feature of naming registered dependencies. These named dependencies will be used to retrieve the correct <kbd>InventoryCommand</kbd> instance, based on the supplied input. </p>
<p>Similar to the previous example, the registration of dependencies will be done in the <kbd>TestInitialize</kbd> method. The registrations will be named based on the command that will be used to determine the command. The following shows the <kbd>Startup</kbd> method structure that creates the <kbd>ContainerBuilder</kbd> object which will build the <kbd>Container</kbd> instance:</p>
<pre>[TestInitialize]<br/>public void Startup()<br/>{<br/>    IServiceCollection services = new ServiceCollection();<br/><br/>    var builder = new ContainerBuilder(); <br/><br/>    // commands<br/>    ...<br/><br/>    Container = builder.Build(); <br/>}</pre>
<p>The commands are registered as follows:</p>
<pre>// commands<br/>builder.RegisterType&lt;QuitCommand&gt;().Named&lt;InventoryCommand&gt;("q");<br/>builder.RegisterType&lt;QuitCommand&gt;().Named&lt;InventoryCommand&gt;("quit");<br/>builder.RegisterType&lt;UpdateQuantityCommand&gt;().Named&lt;InventoryCommand&gt;("u");<br/>builder.RegisterType&lt;UpdateQuantityCommand&gt;().Named&lt;InventoryCommand&gt;("updatequantity");<br/>builder.RegisterType&lt;HelpCommand&gt;().Named&lt;InventoryCommand&gt;("?");<br/>builder.RegisterType&lt;AddInventoryCommand&gt;().Named&lt;InventoryCommand&gt;("a");<br/>builder.RegisterType&lt;AddInventoryCommand&gt;().Named&lt;InventoryCommand&gt;("addinventory");<br/>builder.RegisterType&lt;GetInventoryCommand&gt;().Named&lt;InventoryCommand&gt;("g");<br/>builder.RegisterType&lt;GetInventoryCommand&gt;().Named&lt;InventoryCommand&gt;("getinventory");<br/>builder.RegisterType&lt;UpdateQuantityCommand&gt;().Named&lt;InventoryCommand&gt;("u");<br/>builder.RegisterType&lt;UpdateQuantityCommand&gt;().Named&lt;InventoryCommand&gt;("u");<br/>builder.RegisterType&lt;UnknownCommand&gt;().As&lt;InventoryCommand&gt;();</pre>
<p>Unlike the previous example, the container that is generated is an instance of <kbd>Autofac.IContainer</kbd>. This will be used to retrieve each registered dependency. <kbd>QuitCommand</kbd>, for example, will be named both <kbd>"q"</kbd> and <kbd>"quit"</kbd>, which indicates the two commands that can be used to execute the command. Also, note the last registered type is not named, and belongs to <kbd>UnknownCommand</kbd>. This will act as a default if no command is found by name.</p>
<p>To determine a dependency, a new method will be used to retrieve the dependency by name:</p>
<pre>public InventoryCommand GetCommand(string input)<br/>{<br/>    return Container.ResolveOptionalNamed&lt;InventoryCommand&gt;(input.ToLower()) ?? <br/>           Container.Resolve&lt;InventoryCommand&gt;();<br/>}</pre>
<p>The <kbd>Autofac.IContainer</kbd> interface has a <kbd>ResolveOptionalNamed&lt;<em>T</em>&gt;(<em>string</em>)</kbd> method name, which will return the dependency with the given name, or null, if no matching registrations are found. If the dependency is not registered with the given name, then an instance of the <kbd>UnknownCommand</kbd> class will be returned. This is done by using the null-coalescing operation, <kbd>??</kbd>, and the <kbd>IContainer.Resolve&lt;<em>T</em>&gt;</kbd> method.</p>
<div class="packt_infobox"><kbd>Autofac.IContainer.ResolveNamed&lt;<em>T</em>&gt;(<em>string</em>)</kbd> will throw a <kbd>ComponentNotRegisteredException</kbd> exception if the dependency resolution fails.</div>
<p>A test method is written for each command in order to ensure that the commands are resolved correctly. Again, using <kbd>QuitCommand</kbd> as an example, we can see the following: </p>
<pre>[TestMethod]<br/>public void QuitCommand_Successful()<br/>{<br/>    Assert.IsInstanceOfType(GetCommand("q"), typeof(QuitCommand), "q should be QuitCommand");<br/>    Assert.IsInstanceOfType(GetCommand("quit"), typeof(QuitCommand), "quit should be QuitCommand");<br/>}</pre>
<p class="mce-root">Please view the <kbd>InventoryCommandAutofacTests</kbd> class in the source for the other <kbd>InventoryCommand</kbd> examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>The goal of this chapter was to explore the .Net Core framework in more detail, and, in particular, the .Net Core DI. Three types of service lifetimes are supported: Transient, Scoped, and Singleton. A Transient service will create a new instance of a registered dependency for each request. A Scoped service will be generated once with a defined scope, while a Singleton service will be performed once for the lifetime of the DI service collection. </span></p>
<p>As the .Net Core DI is central to confidently building .Net Core applications, it is important to understand its capabilities and its limitations. It is important to use the DI effectively, as well as to avoid duplicating functionality that is already supplied. Just as crucial, it is also wise to know the limits of the .Net Core DI framework, as well as the strengths of other DI frameworks, for situations where replacing the basic .Net Core DI framework with a third-party DI framework could be beneficial for an application.</p>
<p>The next chapter will build upon the previous chapters and explore, common patterns in .Net Core ASP.Net web applications. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The following questions will allow you to consolidate the information contained in this chapter:</span></p>
<ol>
<li>If you are not sure what type of service lifetime to use, which type is it best to register a class as? Why?</li>
<li>In .Net Core ASP.Net solutions, is a Scope defined per web request, or per session?</li>
<li>Does registering a class as a Singleton in the .Net Core DI framework make it thread-safe?</li>
<li>Is it true that the .Net Core DI framework can only be replaced with other Microsoft-supplied DI frameworks?</li>
</ol>


            </article>

            
        </section>
    </body></html>