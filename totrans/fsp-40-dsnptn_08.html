<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;8.&#xA0;Data Crunching &#x2013; Data Transformation Patterns">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch08"/>
 Chapter 8. Data Crunching – Data Transformation Patterns</h1>
</div>
</div>
</div>
<p>After dealing with advanced patterns of the function definition and application in the previous chapter, I want to revisit the topic that was just slightly scratched in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 in connection with sequences. There, I claimed that the quite bulky <code class="literal">Collection.seq</code>
 library absorbs and implements just a handful of universal data processing patterns. Then I regrouped the library members by assigning to one of these patterns.</p>
<p>This chapter digs deeper into these patterns of data transformation that are applicable not only to sequences, but also to other data collections. The goal of this chapter is to help you develop the skill to convey your data processing needs with functions belonging to a handful of typical polymorphic transformation categories composed of a handful of combinators, and by operating upon data collection types that are best suitable for the task at hand. This approach allows you to uniformly cover the widest assortment of specific data transformations. Sticking to the above approach is essential for F# programmer practitioners as it effectively curbs the development of lengthy custom solutions without compelling reasons and overall adds to the positive properties of F# programs, such as succinctness, correctness, and performance.</p>
<p>In this chapter, we will inspect:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">How normalization of data transformation libraries in F# 4.0 reflects upon underlying transformation patterns commonalities. These commonalities have a polymorphic nature being applicable to the various data collections that the libraries aim.</li>
<li class="listitem">How the transformation patterns scooped in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 reveal themselves over various data collections.</li>
</ul>
</div>
<p>It will be a long trip, so please stay with me, cool and hydrated.</p>
<div class="section" title="Core data transformation libraries in F# 4.0">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch08lvl1sec57"/>
 Core data transformation libraries in F# 4.0</h1>
</div>
</div>
</div>
<p>One of the enhancements to the FSharp.Core run-time brought by F# 4.0 is <span class="strong">
<strong>normalized data collection modules</strong>
</span>
 (<a class="ulink" href="https://blogs.msdn.microsoft.com/fsharpteam/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015/">https://blogs.msdn.microsoft.com/fsharpteam/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015/</a>
 ). It is quite interesting that this development:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Confirms the commonality of data processing patterns across data processing platforms. Functions such as <code class="literal">map</code>
 or <code class="literal">filter</code>
 can be found in functional programming languages such as F#, query tools such as <span class="strong">
<strong>LINQ</strong>
</span>
 , and scripting engines such as <span class="strong">
<strong>PowerShell</strong>
</span>
 , to name a few.</li>
<li class="listitem">Recognizes that concrete functions belonging to these patterns are polymorphic and may be uniformly apply across different data collection types. F# 4.0 successfully delivers this polymorphism over the most frequently used data collection types, namely for <code class="literal">Array</code>
 , <code class="literal">List</code>
 , and <code class="literal">Seq</code>
 modules.</li>
</ul>
</div>
<p>Overall, this library normalization added 95 new optimized per collection type function implementations to F# 4.0 data crunching offering. This addition bumps the overall amount of individual functions in the previously mentioned three collection modules to 309 (as of April 2016), which is definitely a sizable result. However, it would be really challenging for a random developer to memorize and recall this arrangement by heart without recognizing some formative principles.</p>
<p>Considering that most of the functions apply uniformly to three base collection types (some of them naturally do not apply to some concrete collections; for example, <code class="literal">toList</code>
 does not apply to <code class="literal">List</code>
 ), this still leaves 117 (as of April 2016) <span class="emphasis">
<em>different function names</em>
</span>
 just for the base data collections. And do not forget about a certain number of functions related to less widely used data collections, such as <code class="literal">set</code>
 , <code class="literal">IDictionary</code>
 , or <code class="literal">Array2D</code>
 . How should you approach this variety?</p>
<p>Fortunately, the number of data transformation patterns is just a handful. Recognizing the underlying pattern most often imposes an order on associated library functions, leaving just a dozen or so functions associated with each pattern. Such categorized amounts are much easier to recall.</p>
<p>In the rest of the chapter, we will examine these concealed patterns and their correspondent cohesive function groups. The provided idiomatic code examples facilitate the pattern retention, recognition, and reuse.</p>
</div>
</div>


<div class="section" title="Data transformation patterns">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch08lvl1sec58"/>
 Data transformation patterns</h1>
</div>
</div>
</div>
<p>A good question about data transformation libraries richness would be: Where does such an overwhelming variety come from in the first place? Why do designers of F# include as many as hundred-something functions over base data collections into the <span class="emphasis">
<em>core</em>
</span>
 library?</p>
<p>I believe a single "right" answer to this question simply does not exist. However, some clues may come from considering a typical <span class="strong">
<strong>ETL - Extract, Transform, Load</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Extract,_transform,_load">https://en.wikipedia.org/wiki/Extract,_transform,_load</a>
 ) enterprise data crunching process. In the world of mutable collections and arbitrarily changing states, this operation can be expressed as follows:</p>
<pre class="programlisting">void PerformETL() 
{ 
    ExtractData(); 
    TransformData(); 
    LoadData(); 
} 
</pre>
<p>This C#-like pseudocode demonstrates how literally gazillions of possible data transformations can be hidden behind the same few opaque lines of code. We cannot say anything about the details until we meticulously delve into the implementation of each of the above pieces, find out what it does, how it gets to the data, and how it shares the mutating state with other involved pieces.</p>
<p>Now let's express the semantically similar chain of activities in a more functional manner as following:</p>
<pre class="programlisting">let performETL params : unit = 
    let inputCollection = extractData params 
    let outputCollection = transformData inputCollection 
    loadData outputCollection 
</pre>
<p>The preceding snippet tells a better story than its imperative sibling. We can see right away that <code class="literal">extractData</code>
 is a collection generator function that is based on certain input parameters <code class="literal">params</code>
 that produce the initial <code class="literal">inputCollection</code>
 function out of some sort of persistent store. This collection is given as an input parameter to the transformation function <code class="literal">transformData</code>
 that produces as a result the output collection <code class="literal">outputCollection</code>
 . Finally, this collection is given to the data loader function <code class="literal">loadData</code>
 , and it ends up being stored back into the persistent store. Given that the communication with the persistent store is implemented in an <span class="emphasis">
<em>idempotent</em>
</span>
 manner and the involved functions are referentially transparent, this chain of transformations can be replayed an arbitrary number of times with the same results.</p>
<p>We can even take another step toward idiomatic use and rewrite the last snippet as follows:</p>
<pre class="programlisting">let performETL params : unit = 
  params  
   |&gt; extractData 
   |&gt; transformData 
   |&gt; loadData 
</pre>
<p>Now we really deal with the code, transforming immutable data. This code does not dependent on the side effects of an internal state. Its components are better composable and it can be easily extended, if necessary. Finally, this code is simply more elegant now, it is easier to read and comprehend.</p>
<p>You may ask how this rather simplistic passage relates to significant library members' variety?</p>
<p>First of all, there are a few dozen of typical transformations that exist in correspondence with the widely accepted ways in which data processing algorithms are captured in computer science. For example, if we are going to provide a library function to split a collection into a pair of partitions, we cannot make it much differently than with a higher-order function of the following pseudo-signature:</p>
<pre class="programlisting">partition: predicate:('T -&gt; bool) -&gt; source:'T collection 
           -&gt; ('T collection * 'T collection) 
</pre>
<p>Here, <code class="literal">predicate</code>
 is a function that takes a single collection member of type <code class="literal">'T</code>
 and returns <code class="literal">bool</code>
 , where <code class="literal">true</code>
 signifies that the input element will go to the first collection of the result tuple, and <code class="literal">false</code>
 means it will go to the second collection. The  <code class="literal">source</code>
  parameter represents the input collection to be split. I intentionally put "generic" <code class="literal">collection</code>
 into the preceding signature, and I will explain the reason in a bit. The result is a tuple carrying <code class="literal">source</code>
 elements being partitioned into two collections by the <code class="literal">predicate</code>
 values.</p>
<p>Many known algorithms of computer science can be succinctly implemented almost barely using the above <code class="literal">partition</code>
 function. For example, the famous <span class="strong">
<strong>QuickSort</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a>
 ) representing the broad <span class="strong">
<strong>Divide and Conquer</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms">https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms</a>
 ) class of algorithms. Let's look at how <span class="strong">
<strong>QuickSort</strong>
</span>
 may be elegantly implemented using <code class="literal">partition</code>
 as shown by the following snippet (<code class="literal">Ch8_1.fsx</code>
 ):</p>
<pre class="programlisting">let rec qsort : int list -&gt; _ = function 
   | [] -&gt; [] 
   | x::xs -&gt; 
       let less, greater = List.partition ((&gt;) x) xs 
       qsort less @ x :: qsort greater 
</pre>
<p>The <code class="literal">qsort</code>
 function (somewhat simplistically) partitions a non-empty input list argument into two groups: one containing only elements that are less than one <code class="literal">x</code>
 in the head of the list, and the other containing the rest. The result would be to append the list that has <code class="literal">x</code>
 prepended to <code class="literal">qsortgreater</code>
 to the list <code class="literal">qsortless</code>
 . Beautiful! Let's look at how this plays out in FSI in the following screenshot:</p>
<div class="mediaobject"><img src="Image00038.jpg" alt="Data transformation patterns"/>
<div class="caption">
<p>Implementing quicksort with the partition function</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Now let me return to the reason I used <code class="literal">collection</code>
 in the signature of the preceding <code class="literal">partition</code>
 function. Coincidentally, this is another piece of the consideration prompting the variety of library members, which is <span class="emphasis">
<em>performance</em>
</span>
 . You can bet the farm on the assertion that in order to be effective, <code class="literal">partition</code>
 should be implemented separately for <code class="literal">array</code>
 and <code class="literal">list</code>
 collections, yielding the pair of functions, each belonging to their respective module as shown:</p>
<pre class="programlisting">List.partition: predicate:('T -&gt; bool) -&gt; list:'T list 
           -&gt; ('T list * 'T list) 
Array.partition : predicate:('T -&gt; bool) -&gt; array:'T[] 
           -&gt; 'T[] * 'T[] 
</pre>
<p>Along these lines, an interesting point is the lack of the <code class="literal">Seq.partition</code>
 function in F# 4.0 core libraries. The root cause for this artifact comes down to the performance. I refer those of you who are curious to to <span class="strong">
<strong>pertinent piece of F# design specs</strong>
</span>
 (<a class="ulink" href="https://github.com/fsharp/FSharpLangDesign/blob/5cec1d3f524240f063b6f9dad2f23ca5a9d7b158/FSharp-4.0/ListSeqArrayAdditions.md#regular-functional-operators-producing-two-or-more-output-collections">https://github.com/fsharp/FSharpLangDesign/blob/5cec1d3f524240f063b6f9dad2f23ca5a9d7b158/FSharp-4.0/ListSeqArrayAdditions.md#regular-functional-operators-producing-two-or-more-output-collections</a>
 ) and a more mundane <span class="strong">
<strong>explanation on StackOverflow Q&amp;A website</strong>
</span>
 (<a class="ulink" href="http://stackoverflow.com/a/31750808/917053">http://stackoverflow.com/a/31750808/917053</a>
 ) that gives of the exact reason.</p>
<p>Summing up, F# language designers, when defining and implementing the F# core library of data transformation functions, are continually looking for equilibrium between the following factors:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Good coverage of typical use cases distilled by many years of functional programming practice</li>
<li class="listitem">Not bloating the size of the library above reasonable limits</li>
<li class="listitem">Making each library-provided function optimized to the extent that makes nonsensical any custom implementation of the same</li>
</ul>
</div>
<p>Equipped with this holistic view, let me turn to covering patterns per se. In cases where the demonstration of a function representing a pattern can fit a one-liner I'll provide the result of the evaluation in the upcoming line as a comment for the sake of saving space.</p>
<div class="section" title="The generation pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch08lvl2sec89"/>
 The generation pattern</h2>
</div>
</div>
</div>
<p>This pattern is very easy to recognize: it represents a transition from the state without any collection to the state where a collection has been created. Generation pattern is represented by library functions that have a generic signature structure as shown here:</p>
<pre class="programlisting">name: &lt;zero or more input parameters&gt; -&gt; collection&lt;'T&gt; 
</pre>
<p>This generalized signature leads to some concrete use cases depending on the specific shape of the result collection.</p>
<div class="section" title="Generating an empty collection">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_2"><a id="ch08lvl3sec22"/>
 Generating an empty collection</h3>
</div>
</div>
</div>
<p>To generate an empty collection of a generic type, the core library function, <code class="literal">empty</code>
 , exists, allowing you to produce a strongly typed empty collection for any of the base collection types as shown here (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let el = List.empty&lt;string&gt; 
// val el : string list = [] 
let ea = Array.empty&lt;float&gt; 
// val ea : float [] = [||] 
let es = Seq.empty&lt;int -&gt; string&gt; 
// val es : seq&lt;(int -&gt; string)&gt; 
// es;; 
// val it : seq&lt;(int -&gt; string)&gt; = seq [] 
</pre>
<p>The same can be also achieved using corresponding constant expressions for each base collection type (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let ell: string list = [] 
// val ell : string list = [] 
let eal: float[] = [||] 
// val eal : float [] = [||] 
let esl: seq&lt;int -&gt; string&gt; = seq [] 
// val esl : seq&lt;(int -&gt; string)&gt; = [] 
// esl;; 
// val it : seq&lt;(int -&gt; string)&gt; = [] 
</pre>
</div>
<div class="section" title="Generating a single element collection">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_3"><a id="ch08lvl3sec23"/>
 Generating a single element collection</h3>
</div>
</div>
</div>
<p>This simple task belonging to a generation pattern can be achieved by the core library function <code class="literal">singleton</code>
 that exists for each of the base collection types. It does not need explicit declaration of collection elements type as it can be easily inferred from the typed literal given for the single collection element as shown in the following code (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let sl = List.singleton "I'm alone" 
// val sl : string list = ["I'm alone"] 
let sa = Array.singleton 42.0 
// val sa : float [] = [|42.0|] 
let ss = Seq.singleton (fun (x:int) -&gt; x.ToString()) 
// val ss : seq&lt;(int -&gt; string)&gt; 
// ss;; 
// val it : seq&lt;(int -&gt; string)&gt; = seq [&lt;fun:ss@24&gt;] 
</pre>
<p>Again, this can be also achieved using corresponding constant expressions for each base collection type as shown here (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let sll = ["I'm alone"] 
// val sll : string list = ["I'm alone"] 
let sal = [| 42.0 |] 
// val sal : float [] = [|42.0|] 
let ssl = seq [fun (x:int) -&gt; x.ToString()] 
// val ssl : seq&lt;(int -&gt; string)&gt; = [&lt;fun:ssl@24&gt;] 
</pre>
</div>
<div class="section" title="Generating a collection of a known size">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_4"><a id="ch08lvl3sec24"/>
 Generating a collection of a known size</h3>
</div>
</div>
</div>
<p>This task of the generation pattern is represented by two different cases: the case where all elements in the collection are of the same value and the case where they can be of different values.</p>
<div class="section" title="Generating a collection of a known size - all elements of the same value">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch08lvl4sec8"/>
 Generating a collection of a known size - all elements of the same value</h4>
</div>
</div>
</div>
<p>The F# 4.0 core library provides functions to replicate each base collection type that has the following signatures:</p>
<pre class="programlisting">List.replicate: count:int -&gt; initial:'T -&gt; 'T list 
Array.replicate: count:int -&gt; initial:'T -&gt; 'T[] 
Seq.replicate: count:int -&gt; initial:'T -&gt; seq&lt;'T&gt; 
</pre>
<p>Examples of this usage are as following (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let fl = List.replicate 3 "blah" 
// val fl : string list = ["blah"; "blah"; "blah"] 
let fa = Array.replicate 3 42 
// val fa : int [] = [|42; 42; 42|] 
let fs = Seq.replicate 3 42.0 
// val fs : seq&lt;float&gt; 
// fs;; 
// val it : seq&lt;float&gt; = seq [42.0; 42.0; 42.0] 
</pre>
<p>As I discussed earlier, this can be achieved using literals and comprehension expressions as shown here (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let fll = ["blah";"blah";"blah"] 
// val fll : string list = ["blah"; "blah"; "blah"] 
let fal = [| for i in 1..3 -&gt; 42 |] 
// val fal : int [] = [|42; 42; 42|] 
let fsl = seq { for i in 1..3 do yield 42.0 } 
// val fsl : seq&lt;float&gt; 
// fsl;; 
// val it : seq&lt;float&gt; = seq [42.0; 42.0; 42.0] 
</pre>
<p>In addition to <code class="literal">replicate</code>
 , F# core library for <span class="strong">
<strong>array</strong>
</span>
 collections exclusively provides the <code class="literal">create</code>
 and <code class="literal">zeroCreate</code>
 functions as shown below (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">Array.create: count:int -&gt; value:'T -&gt; 'T[] 
Array.zeroCreate: count:int -&gt; 'T[] 
let fac = Array.create 3 "blah" 
// val fac : string [] = [|"blah"; "blah"; "blah"|] 
let fazc: string[] = Array.zeroCreate 3 
// val fazc : string [] = [|null; null; null|] 
let fazci = Array.zeroCreate&lt;int&gt; 3 
// val fazci : int [] = [|0; 0; 0|] 
</pre>
<p>Note that <code class="literal">zeroCreate</code>
 , by design, does not give any clue about the type of the target array to the F# compiler. So, in order to avoid the infamous <code class="literal">error FS0030: Value restriction</code>
 error message that is going to take place if the matter of the target array type is delegated to the type inference, the type annotation can be added to the value itself, such as <code class="literal">string[]</code>
 for <code class="literal">fazc</code>
 , or a type argument can be added to the function name itself, such as <code class="literal">&lt;int&gt;</code>
 for <code class="literal">fazci</code>
 in the preceding code.</p>
</div>
<div class="section" title="Generating a collection of a known size - elements may have different values">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch08lvl4sec9"/>
 Generating a collection of a known size - elements may have different values</h4>
</div>
</div>
</div>
<p>What if elements of the collection need to be of different values? The F# core library comes to our help with the <code class="literal">init</code>
 function for each base collection type that has signatures as following:</p>
<pre class="programlisting">List.init: length:int -&gt; initializer:(int -&gt; 'T) -&gt; 'T list 
Array.init : count:int -&gt; initializer:(int -&gt; 'T) -&gt; 'T[] 
Seq. init: count:int -&gt; initializer:(int -&gt; 'T) -&gt; seq&lt;'T&gt; 
</pre>
<p>Examples of this usage are given as following (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let vl = List.init 4 ((*) 2) 
// val vl : int list = [0; 2; 4; 6]  
let va = let src = "closure" in Array.init src.Length (fun i -&gt; src.[i]) 
 
// val va : char [] = [|'c'; 'l'; 'o'; 's'; 'u'; 'r'; 'e'|] 
let vs = Seq.init 3 id  
// val vs : seq&lt;int&gt; 
// vs;; 
// val it : seq&lt;int&gt; = seq [0; 1; 2] 
</pre>
<p>Note that <code class="literal">initializer</code>
 is given the implicit index of each element that transforms it into the element value. This transformation can be very simple, such as <code class="literal">vs</code>
 , or quite complex, such as <code class="literal">va</code>
 , where it is closed around <code class="literal">src</code>
 and de-facto transforms a <code class="literal">string</code>
 to the array of <code class="literal">char</code>
 of its characters.</p>
<p>Similar to the case of the same value elements, the alternative to <code class="literal">init</code>
 in order to generate lists and arrays may be literals, and for all three base collection types, the alternative could be comprehension expressions. Examples follow-<code class="literal">vll</code>
 and <code class="literal">val</code>
 for literals and the rest for a comprehension expression having (<code class="literal">vlcy</code>
 , <code class="literal">vacy</code>
 , <code class="literal">vscy</code>
 ) or not using (<code class="literal">vlc</code>
 , <code class="literal">vac</code>
 , <code class="literal">vsc</code>
 ) of the <code class="literal">yield</code>
 construction as shown here (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let vll = [0; 2; 4; 6] 
// val vll : int list = [0; 2; 4; 6] 
let vlc = [ for i in 0..3 -&gt; i * 2 ] 
// val vlc : int list = [0; 2; 4; 6] 
let vlcy = [ for i in 0..3 do yield i * 2 ] 
// val vlcy : int list = [0; 2; 4; 6] 
let ``val`` = 
    let src = "closure" in 
    [| src.[0]; src.[1]; src.[2]; src.[3]; src.[4]; src.[5]; src.[6] |] 
// val val : char [] = [|'c'; 'l'; 'o'; 's'; 'u'; 'r'; 'e'|] 
let vac = 
    let src = "closure" in 
    [| for i in 1..src.Length -&gt; src.[i - 1] |] 
// val vac : char [] = [|'c'; 'l'; 'o'; 's'; 'u'; 'r'; 'e'|] 
let vacy = 
    let src = "closure" in 
    [| for i in 1..src.Length do 
       yield src.[i - 1] |&gt; System.Char.ToUpper |] 
// val vacy : char [] = [|'C'; 'L'; 'O'; 'S'; 'U'; 'R'; 'E'|] 
let vsc = seq { for i in 0..2..6 -&gt; i} 
// vsc;; 
// val it : seq&lt;int&gt; = seq [0; 2; 4; 6] 
let vscy = seq { for i in 0..2..6 do yield 6 - i } 
// vscy;; 
// val it : seq&lt;int&gt; = seq [6; 4; 2; 0] 
</pre>
<p>Note that the expression initializing the collection element value within comprehension expressions can be arbitrarily complex; for example, in the case of <code class="literal">vacy</code>
 , it takes a value from the <code class="literal">src</code>
 closure indexed by the element place and converts the corresponding <code class="literal">char</code>
 array element into uppercase.</p>
<p>Before further proceeding with the rest of the use cases, let me drill deeper into comprehension expressions. They are much more powerful than what has been shown so far. I've already mentioned this in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 when talking about sequences in which sequence expressions may contain multiple occurrences of <code class="literal">yield</code>
 as well as <code class="literal">yield!</code>
 . You are free to use this feature when creating comprehension expressions for lists and arrays as well as use recursion to your taste. To prove this, let me demonstrate all these features in one quick example, building a generator for a list of pseudo-random integers in a range between <code class="literal">lo</code>
 and <code class="literal">hi</code>
 of length <code class="literal">len</code>
 as shown in the following code (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let randoms lo hi len = 
    let r = System.Random() 
    let max = hi + 1 
    let rec generate n = [ 
        if n &lt; len then 
            yield r.Next(lo, max) 
            yield! generate (n + 1) 
    ] 
    generate 0 
</pre>
<p>The results of smoke testing <code class="literal">randoms</code>
 in FSI by modeling three series of 20 throws of a dice are given in the following screenshot:</p>
<div class="mediaobject"><img src="Image00039.jpg" alt="Generating a collection of a known size - elements may have different values"/>
<div class="caption">
<p>Modelling series of throwing dice with pseudo-random number generator</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>
<div class="section" title="Generating a collection of an unknown size">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_5"><a id="ch08lvl3sec25"/>
 Generating a collection of an unknown size</h3>
</div>
</div>
</div>
<p>From time to time, you may get into a situation where you should generate a collection with the size that is to be found along the generation. In such situations, the following F# core library function <code class="literal">unfold</code>
 comes to help as shown here:</p>
<pre class="programlisting">List.unfold&lt;'T,'State&gt; : generator:('State -&gt; ('T * 'State) option) -&gt; state:'State -&gt; 'T list 
Array.unfold&lt;'T,'State&gt; : generator:('State -&gt; ('T * 'State) option) -&gt; state:'State -&gt; 'T[] 
Seq.unfold   : generator:('State -&gt; ('T * 'State) option) -&gt; state:'State -&gt; seq&lt;'T&gt; 
</pre>
<p>I have already provided a very simple example of this function workings in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 ; here, I describe its inner workings to the full extent. The <code class="literal">unfold</code>
 function produces result collection elements one by one. For each element, the <code class="literal">generator</code>
 function takes a <code class="literal">'State</code>
 value as an input parameter and produces the result as an <span class="strong">
<strong>option</strong>
</span>
 value. If the returned option is of the form <code class="literal">Some('T * 'State)</code>
  consisting of the current generated collection element value <code class="literal">'T</code>
 and the <code class="literal">'State</code>
 value for the next iteration this return value indicates that sequence unfolding will continue. Otherwise, when <code class="literal">generator</code>
 function returns <code class="literal">None</code>
 this means that the collection unfolding has been completed.</p>
<p>Let me offer you a loaded example for this use case: the so-called <span class="strong">
<strong>Collatz conjecture</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Collatz_conjecture">https://en.wikipedia.org/wiki/Collatz_conjecture</a>
 ). Let us consider an integral sequence built by a simple rule of moving from an element <code class="literal">n</code>
 to the next element <code class="literal">nn</code>
 : if <code class="literal">n</code>
 is even, then <code class="literal">nn</code>
 is <code class="literal">n</code>
 divided by <code class="literal">2</code>
 ; otherwise, it is <code class="literal">3 * n + 1</code>
 . The conjecture itself is that for any initial <code class="literal">n</code>
 , this sequence named by German mathematician Lothar Collatz eventually reaches <code class="literal">1</code>
 . For example,</p>
<p>42 -&gt; 24 -&gt; 12 -&gt; 6 -&gt; 3 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</p>
<p>To this day, no starting number has been found that leads to an unbound number of elements in the Collatz sequence.</p>
<p>For starters, I begin with an idiomatic implementation of the Collatz sequence generator <code class="literal">collatzLib</code>
 function that relies upon the <code class="literal">unfold</code>
 library function as shown here (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let collatzLib n = 
    Seq.unfold (fun n -&gt; match n with 
                            | 0L -&gt; None 
                            | 1L -&gt; Some(1L, 0L) 
                            | n when n % 2L = 0L -&gt; Some(n, n/2L) 
                            | n -&gt; Some(n, 3L * n + 1L)) n 
</pre>
<p>Note the trick I used in order to deliver the value 1 to the collection that, if the generation is continued beyond it, leads to the cycle <code class="literal">...1 -&gt; 4 -&gt; 2 -&gt; 1...</code>
 <code class="literal">.</code>
 For the state of <code class="literal">1L</code>
 , I produced the <code class="literal">Some</code>
 option that has <code class="literal">1L</code>
 as the current value and an impossible marker value, <code class="literal">0L</code>
 . For the marker value, the generator produces <code class="literal">None</code>
 and the collection growth terminates. Another precaution is to operate in the field of <code class="literal">int64</code>
 numbers because even some not-that-big initial numbers may bring <code class="literal">'State</code>
 outside of the <code class="literal">int</code>
 field, which I was able to find by switching to <span class="strong">
<strong>checked</strong>
</span>
 F# arithmetic from the default <span class="strong">
<strong>unchecked</strong>
</span>
 when the generator started taking a suspiciously long time to complete.</p>
<p>So far, so good. I'm going to give this implementation a try shortly. But some of you may already have this question: what's the point if this can be achieved with a sequence expression? And the answer was already given in the beginning of this chapter - <span class="emphasis">
<em>performance</em>
</span>
 . To prove this statement experimentally, let me put down the custom Collatz sequence generator implementation without using the <code class="literal">unfold</code>
 library function (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">let rec collatzCustom num =  
    seq { 
        yield num 
        match num with 
        | 1L -&gt; () 
        | x when x % 2L = 0L -&gt;yield! collatzCustom (x/2L) 
        | x -&gt;yield! collatzCustom ((x * 3L) + 1L) 
        } 
</pre>
<p>Now let's run <code class="literal">collatzLib</code>
 and <code class="literal">collatzCustom</code>
 against each other in order to identify the difference. For this purpose, let's find out what the longest Collatz sequence collection for initial numbers between 2 and 1000 would be. This exercise is a variation of <span class="strong">
<strong>Project Euler problem 14</strong>
</span>
 (<a class="ulink" href="https://projecteuler.net/problem=14">https://projecteuler.net/problem=14</a>
 ). Composing the performance measuring code is not that difficult as shown here (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">[2L..1000000L] |&gt; Seq.map (collatzLib &gt;&gt; Seq.length) |&gt; Seq.max 
</pre>
<p>Let's compare the performance of the preceding code to this one (<code class="literal">Ch8_2.fsx</code>
 ):</p>
<pre class="programlisting">[2L..1000000L] |&gt; Seq.map (collatzCustom &gt;&gt; Seq.length) |&gt; Seq.max 
</pre>
<p>by the running time. Comparison is given in the following screenshot:</p>
<div class="mediaobject"><img src="Image00040.jpg" alt="Generating a collection of an unknown size"/>
<div class="caption">
<p>Comparing the performance of library function-based and custom implementations</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The lesson to take home is that the run using library-based <code class="literal">collatzLib</code>
 function takes <span class="strong">
<strong>only 63%</strong>
</span>
 of the time required for the run that uses custom-implemented <code class="literal">collatzCustom</code>
 function.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_6"><a id="tip9"/>
 Tip</h3>
<p>Do not spend time re-implementing functionality that F# core library functions offer unless you are in need for speed and absolutely sure that your custom implementation would improve the performance!</p>
</div>
</div>
<div class="section" title="Generating a collection of an infinite size">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_7"><a id="ch08lvl3sec26"/>
 Generating a collection of an infinite size</h3>
</div>
</div>
</div>
<p>Finally, I've reached the last use case under the Generation pattern: collections of infinite size. Apparently, when we consider this case, the underlying collection type can be the only sequence as we cannot rely on infinite memory resources yet. The F# core library function signature for the purpose of generating a sequence of infinite length is as following:</p>
<pre class="programlisting">Seq.initInfinite: initializer:(int -&gt; 'T) -&gt; seq&lt;'T&gt; 
</pre>
<p>It does not differ from <code class="literal">init</code>
 that much; it just lacks the input argument setting the collection size. Side by side with the <code class="literal">initInfinite</code>
 library function go custom implementations of infinite size sequences with sequence expressions.</p>
<p>I already covered the pattern of infinite size sequences in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 and provided some examples there as well as some advanced examples in <a class="link" title="Chapter 7.  Advanced Techniques: Functions Revisited" href="text00058.html#ch07">Chapter 7</a>
 , <span class="emphasis">
<em>Advanced Techniques: Functions Revisited</em>
</span>
 so I will not repeat myself here. This use case concludes the variety that Generation data transformation pattern covers.</p>
</div>
</div>
<div class="section" title="The aggregation pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_8"><a id="ch08lvl2sec90"/>
 The aggregation pattern</h2>
</div>
</div>
</div>
<p>The aggregation pattern can be recognized by the following kind of activity when the collection is traversed to end up with a value of type <code class="literal">'T</code>
 , similar to the collection elements' type <code class="literal">'T</code>
 , which carries some cumulative impact of all traversed elements.</p>
<div class="section" title="Generic aggregation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_9"><a id="ch08lvl3sec27"/>
 Generic aggregation</h3>
</div>
</div>
</div>
<p>The generic aggregation data transformation pattern signature is conveniently similar to the pair of concrete library functions that represent aggregation: <code class="literal">reduce</code>
 and <code class="literal">reduceBack</code>
 as shown here:</p>
<pre class="programlisting">List.reduce: reduction:('T -&gt; 'T -&gt; 'T) -&gt; list:'T list -&gt; 'T 
List.reduceBack: reduction:('T -&gt; 'T -&gt; 'T) -&gt; list:'T list -&gt; 'T 
Array.reduce: reduction:('T -&gt; 'T -&gt; 'T) -&gt; array:'T[] -&gt; 'T 
Array.reduceBack: reduction:('T -&gt; 'T -&gt; 'T) -&gt; array:'T[] -&gt; 'T 
Seq.reduce: reduction:('T -&gt; 'T -&gt; 'T) -&gt; source:seq&lt;'T&gt; -&gt; 'T 
</pre>
<p>If you recall <a class="link" title="Chapter 7.  Advanced Techniques: Functions Revisited" href="text00058.html#ch07">Chapter 7</a>
 , <span class="emphasis">
<em>Advanced Techniques: Functions Revisited</em>
</span>
 , the preceding code is almost as generic as <code class="literal">folds</code>
 ; the difference is that the state threaded through the collection by <code class="literal">fold</code>
 can be of any arbitrary type that does not necessarily coincide with the type of collection elements, while <code class="literal">reduce</code>
 deals with the same type. It is easy to implement <code class="literal">reduce</code>
 with <code class="literal">fold</code>
 but not the other way around.</p>
<p>The <code class="literal">reduce</code>
 function applies the <code class="literal">reduction</code>
 operation from the beginning to the end of the collection; if I denote the <code class="literal">reduction</code>
 function as <code class="literal">r</code>
 , then for the special case of <code class="literal">reduce</code>
 over array collection <code class="literal">c</code>
 it will be equivalent to this expression as shown here:</p>
<pre class="programlisting">...r (r (r c.[0] c.[1]) c.[2]) c.[3]... 
</pre>
<p>On the contrary, <code class="literal">reduceBack</code>
 applies the <code class="literal">reduction</code>
 operation from the right-hand side to the left of the collection; if I denote the <code class="literal">reduction</code>
 function as <code class="literal">r</code>
 again, then for the special case of <code class="literal">reduceBack</code>
 over array collection <code class="literal">c</code>
 of <code class="literal">n+1</code>
 elements it will be equivalent to this expression as shown here:</p>
<pre class="programlisting">... (r c.[n - 3] (r c.[n - 2] (r c.[n - 1] c.[n])) ... 
</pre>
<p>It is quite easy to notice that for the <span class="strong">
<strong>associative</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Associative_property">https://en.wikipedia.org/wiki/Associative_property</a>
 ) <code class="literal">reduction</code>
 operation, the results of <code class="literal">reduce</code>
 and <code class="literal">reduceBack</code>
 over the same collection would be the same, which is confirmed by simple tests as shown here (<code class="literal">Ch8_3.fsx</code>
 ):</p>
<pre class="programlisting">// associative operation min 
List.reduce min [1;2;3;4;5] 
// val it : int = 1 
List.reduceBack min [1;2;3;4;5] 
// val it : int = 1 
 
// non-associative operation (-) 
List.reduce (-) [1;2;3;4;5] 
// val it : int = -13 
List.reduceBack (-) [1;2;3;4;5] 
// val it : int = 3 
</pre>
<p>I'd like to point at the asymmetry taking place: there is no <code class="literal">reduceBack</code>
 for sequences in the library out of the box.</p>
<p>All other library aggregate functions are just specific implementations of aggregations that can be expressed by <code class="literal">reduce</code>
 . Before turning to their consideration, I want to point out just another pattern: performing aggregation not on the original element type <code class="literal">'T</code>
 but projecting each collection element to some other type <code class="literal">'U</code>
 and aggregating upon <code class="literal">'U</code>
 .</p>
</div>
<div class="section" title="Direct aggregation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_10"><a id="ch08lvl3sec28"/>
 Direct aggregation</h3>
</div>
</div>
</div>
<p>Members of this group of aggregating library functions perform aggregation directly on the type of collection elements <code class="literal">'T</code>
 , such as the library members that have the following signatures:</p>
<pre class="programlisting">List.average : list:^T list -&gt; ^T     
    when ^T : (static member ( + ) : ^T * ^T -&gt; ^T)  
    and  ^T : (static member DivideByInt : ^T*int -&gt; ^T)  
    and  ^T : (static member Zero : ^T) 
Array.average : array:^T[] -&gt; ^T     
    when ^T : (static member ( + ) : ^T * ^T -&gt; ^T)  
    and  ^T : (static member DivideByInt : ^T*int -&gt; ^T)  
    and  ^T : (static member Zero : ^T) 
Seq.average : source:seq&lt;(^T)&gt; -&gt; ^T     
    when ^T : (static member ( + ) : ^T * ^T -&gt; ^T)  
    and  ^T : (static member DivideByInt : ^T*int -&gt; ^T)  
    and  ^T : (static member Zero : ^T) 
List.max : list:'T list -&gt; 'T when 'T : comparison 
Array.max : array:'T[] -&gt; 'T  when 'T : comparison 
Seq.max : source:seq&lt;'T&gt; -&gt; 'T when 'T : comparison 
List.min : list:'T list -&gt; 'T when 'T : comparison 
Array.min : array:'T[] -&gt; 'T  when 'T : comparison 
Seq.min : source:seq&lt;'T&gt; -&gt; 'T when 'T : comparison 
List.sum : list:^T list -&gt; ^T  
    when ^T : (static member ( + ) : ^T * ^T -&gt; ^T)  
    and  ^T : (static member Zero : ^T) 
Array.sum : array: ^T[] -&gt; ^T  
    when ^T : (static member ( + ) : ^T * ^T -&gt; ^T)  
    and  ^T : (static member Zero : ^T) 
Seq.sum : source:seq&lt;(^T)&gt; -&gt; ^T  
    when ^T : (static member ( + ) : ^T * ^T -&gt; ^T)  
    and  ^T : (static member Zero : ^T) 
</pre>
<p>Based on signatures, you may notice that the library's aggregate functions introduce static constraints upon the collection type <code class="literal">'T</code>
 for the aggregations to make sense. For example, apparently, the max aggregation cannot be performed upon type <code class="literal">'T</code>
 if <code class="literal">'T</code>
 does not support comparison.</p>
</div>
<div class="section" title="Projected aggregation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_11"><a id="ch08lvl3sec29"/>
 Projected aggregation</h3>
</div>
</div>
</div>
<p>The projected aggregation library function, instead of performing aggregations upon original collection elements, first projects them from type <code class="literal">'T</code>
 into some other type <code class="literal">'U</code>
 , and only then it performs the aggregation over <code class="literal">'U</code>
 values. Here go the signatures:</p>
<pre class="programlisting">List.averageBy : projection:('T -&gt; ^U) -&gt; list:'T list  -&gt; ^U     
    when ^U : (static member ( + ) : ^U * ^U -&gt; ^U)  
    and  ^U : (static member DivideByInt : ^U*int -&gt; ^U)  
    and  ^U : (static member Zero : ^U) 
Array.averageBy : projection:('T -&gt; ^U) -&gt; array:'T[] -&gt; ^U     
    when ^U : (static member ( + ) : ^U * ^U -&gt; ^U)  
    and  ^U : (static member DivideByInt : ^U*int -&gt; ^U)  
    and  ^U : (static member Zero : ^U) 
Seq.averageBy : projection:('T -&gt; ^U) -&gt; source:seq&lt;'T&gt;  -&gt; ^U     
    when ^U : (static member ( + ) : ^U * ^U -&gt; ^U)  
    and  ^U : (static member DivideByInt : ^U*int -&gt; ^U)  
    and  ^U : (static member Zero : ^U) 
List.maxBy : projection:('T -&gt; 'U) -&gt; list:'T list -&gt; 'T 
    when 'U : comparison 
Array.maxBy  : projection:('T -&gt; 'U) -&gt; array:'T[] -&gt; 'T 
    when 'U : comparison 
Seq.maxBy : projection:('T -&gt; 'U) -&gt; source:seq&lt;'T&gt; -&gt; 'T 
    when 'U : comparison 
List.minBy : projection:('T -&gt; 'U) -&gt; list:'T list -&gt; 'T 
    when 'U : comparison 
Array.minBy : projection:('T -&gt; 'U) -&gt; array:'T[] -&gt; 'T 
    when 'U : comparison 
Seq.minBy : projection:('T -&gt; 'U) -&gt; source:seq&lt;'T&gt; -&gt; 'T 
    when 'U : comparison 
List.sumBy : projection:('T -&gt; ^U) -&gt; list:'T list -&gt; ^U  
    when ^U : (static member ( + ) : ^U * ^U -&gt; ^U)  
    and  ^U : (static member Zero : ^U) 
Array.sumBy : projection:('T -&gt; ^U) -&gt; array:'T[] -&gt; ^U  
    when ^U : (static member ( + ) : ^U * ^U -&gt; ^U)  
    and  ^U : (static member Zero : ^U) 
Seq.sumBy : projection:('T -&gt; ^U) -&gt; source:seq&lt;'T&gt;  -&gt; ^U  
    when ^U : (static member ( + ) : ^U * ^U -&gt; ^U)  
    and  ^U : (static member Zero : ^U) 
</pre>
<p>There is a little intricacy that should be mentioned when considering projected aggregations-while <code class="literal">averageBy</code>
 and <code class="literal">sumBy</code>
 return a result of type <code class="literal">'U</code>
 , <code class="literal">maxBy</code>
 and <code class="literal">minBy</code>
 return <code class="literal">'T</code>
 . Refer to the following code sample that highlights the mentioned detail (<code class="literal">Ch8_3.fsx</code>
 ):</p>
<pre class="programlisting">List.sumBy (fun x -&gt; -x) [1;2;3] 
// val it : int = -6 
List.minBy (fun x -&gt; -x) [1;2;3] 
// val it : int = 3 
</pre>
</div>
<div class="section" title="Counting aggregation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_12"><a id="ch08lvl3sec30"/>
 Counting aggregation</h3>
</div>
</div>
</div>
<p>The left-over two functions of aggregation data transformation pattern perform the counting of collection elements.</p>
<p>The first one is the good old <code class="literal">length</code>
 function:</p>
<pre class="programlisting">List.length: list:'T list -&gt; int 
Array.length: array:'T[] -&gt; int 
Seq.length: source:seq&lt;'T&gt; -&gt; int 
</pre>
<p>There are no hidden surprises here. Just recognize that <code class="literal">Seq.length</code>
 traverses the <code class="literal">source</code>
 sequence and, being applied to a sequence of infinite length will eventually blow up.</p>
<p>The other one, <code class="literal">countBy</code>
 , is trickier:</p>
<pre class="programlisting">List.countBy projection:('T -&gt; 'Key) -&gt; list:'T list 
    -&gt; ('Key * int) list 
    when 'Key : equality 
Array.countBy : projection:('T -&gt; 'Key) -&gt; array:'T[] 
    -&gt; ('Key * int)[] 
    when 'Key : equality 
Seq.countBy projection:('T -&gt; 'Key) -&gt; source:seq&lt;'T&gt; 
    -&gt; seq&lt;'Key * int&gt; 
    when 'Key : equality 
</pre>
<p>This higher-order function applies <code class="literal">projection</code>
 to each element value <code class="literal">'T</code>
 , converting it into a <code class="literal">'Key</code>
 value, counts the number of elements projected to each unique <code class="literal">'Key</code>
 , and in the end, delivers the distribution as a collection of tuples (<code class="literal">'Key</code>
 , amount). Let me make quite an interesting observation. At the beginning of this chapter, in <span class="emphasis">
<em>Generating a collection of a known size</em>
</span>
 we implemented a pseudo-random number sequence generator <code class="literal">randoms</code>
 . Let's look at roughly how "random" it is in emulating the throwing of a dice by building a long series of throws and then binning each score, expecting that the deviation of bin sizes is not statistically significant.</p>
<p>The following snippet emulates the throwing of a dice 10 million times; so, the expected number of hits of each of the six bins for outcomes should be somewhere around 1,666,000. Let's see... (<code class="literal">Ch8_3.fsx</code>
 ):</p>
<pre class="programlisting">randoms 1 6 10000000 
|&gt; Seq.countBy id 
|&gt; Seq.toList 
|&gt; printfn "%A" 
</pre>
<p>The results of running the preceding code in FSI are presented in the following screenshot:</p>
<div class="mediaobject"><img src="Image00041.jpg" alt="Counting aggregation"/>
<div class="caption">
<p>Checking the quality of a pseudo-random number generator with countBy</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Based on results reflected by preceding screenshot, my gut feeling is that the underlying pseudo-random number generator is not bad for the purpose of emulating the dice. And it is pretty fast too: it took a bit more than 2 seconds to generate and bin the series of 10 million trials.</p>
</div>
</div>
<div class="section" title="The wrapping and type conversion pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_13"><a id="ch08lvl2sec91"/>
 The wrapping and type conversion pattern</h2>
</div>
</div>
</div>
<p>Library functions belonging to this data transformation pattern split into two groups as following:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Ones that wrap the entire collection, changing its behavior</li>
<li class="listitem">Ones that simply transform the collection from one base type to another</li>
</ul>
</div>
<div class="section" title="The collection wrapping pattern">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_14"><a id="ch08lvl3sec31"/>
 The collection wrapping pattern</h3>
</div>
</div>
</div>
<p>There are only three functions that belong to this pattern. All of them are applicable only to sequences and have the following signatures:</p>
<pre class="programlisting">Seq.cache: source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
Seq.delay: generator:(unit -&gt; seq&lt;'T&gt;) -&gt; seq&lt;'T&gt; 
Seq.readonly : source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
</pre>
<p>I have already covered the <code class="literal">Seq.cache</code>
 function in <a class="link" title="Chapter 6.  Sequences - The Core of Data Processing Patterns" href="text00053.html#ch06">Chapter 6</a>
 , <span class="emphasis">
<em>Sequences - The Core of Data Processing Patterns</em>
</span>
 and also used it in <a class="link" title="Chapter 7.  Advanced Techniques: Functions Revisited" href="text00058.html#ch07">Chapter 7</a>
 , <span class="emphasis">
<em>Advanced Techniques: Functions Revisited</em>
</span>
 in the prime number generator sample, so let me not spend any more time on it and move on to the other pair.</p>
<p>
<code class="literal">Seq.delay</code>
 allows you to postpone an eager evaluation of the wrapped <code class="literal">generator</code>
 function. The evaluation is postponed until the wrapper gets enumerated. In the following code snippet, there is an eager list comprehension present that, if being evaluated, immediately prints <code class="literal">"Evaluating eagerList"</code>
 and then returns the list of <code class="literal">strings</code>
 . However, being wrapped into <code class="literal">Seq.delay</code>
 , it does not evaluate until the wrapper itself gets materialized (<code class="literal">Ch8_4.fsx</code>
 ):</p>
<pre class="programlisting">let eagerList = [ 
    printfn "Evaluating eagerList" 
    yield "I" 
    yield "am" 
    yield "an" 
    yield "eager" 
    yield "list" 
] 
// Evaluating eagerList 
// val eagerList : string list = ["I"; "am"; "an"; "eager"; "list"] 
let delayedEagerList = Seq.delay(fun () -&gt; ([ printfn "Evaluating 
                                              eagerList" 
                                            yield "I" 
                                            yield "am" 
                                            yield "an" 
                                            yield "eager" 
                                            yield "list" 
                                        ] |&gt; Seq.ofList)) 
// val delayedEagerList : seq&lt;string&gt; 
 
delayedEagerList |&gt; Seq.toList 
// Evaluating eagerList 
// val it : string list = ["I"; "am"; "an"; "eager"; "list"] 
</pre>
<p>The commented lines of the preceding script demonstrate that the expected behavior described earlier is actually taking place.</p>
<p>The <code class="literal">Seq.readonly</code>
 builds a wrapper sequence around the original collection, which does not allow you to rediscover and mutate it via a type cast. In the following snippet, it is possible via an upcast followed by a downcast, to create a backdoor, and mutate with its help the original mutable collection (<code class="literal">Ch8_4.fsx</code>
 ):</p>
<pre class="programlisting">let src = [|1;2;3|] 
let srcAsSeq = src :&gt; seq&lt;_&gt; 
let backdoor = srcAsSeq :?&gt; int array 
backdoor.[0] &lt;- 10 
printfn "%A" src 
// [|10; 2; 3|] 
</pre>
<p>Now if <code class="literal">src</code>
 gets wrapped into <code class="literal">Seq.readonly</code>
 , an attempt to downcast the sequence back to <code class="literal">int []</code>
 will incur cast exception as shown in the following code (<code class="literal">Ch8_4.fsx</code>
 ):</p>
<pre class="programlisting">let srcAsROSeq = src |&gt; Seq.readonly 
let tryBackDoor = srcAsROSeq :?&gt; int array 
// System.InvalidCastException: Unable to cast object of type 'mkSeq@541[System.Int32]' to type 'System.Int32[]'. 
</pre>
</div>
<div class="section" title="The type conversion pattern">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_15"><a id="ch08lvl3sec32"/>
 The type conversion pattern</h3>
</div>
</div>
</div>
<p>Library functions that belong to the type conversion pattern provide symmetric conversions between base collection types as shown here:</p>
<pre class="programlisting">List.toSeq list:'T list -&gt; seq&lt;'T&gt; 
List.ofSeq: source:seq&lt;'T&gt; -&gt; 'T list 
List.toArray: list:'T list -&gt; 'T[] 
List.ofArray : array:'T[] -&gt; 'T list 
Array.toSeq: array:'T[] -&gt; seq&lt;'T&gt; 
Array.ofSeq: source:seq&lt;'T&gt; -&gt; 'T[] 
Array.toList: array:'T[] -&gt; 'T list 
Array.ofList: list:'T list -&gt; 'T[] 
Seq.toList: source:seq&lt;'T&gt; -&gt; 'T list 
Seq.ofList: source:'T list -&gt; seq&lt;'T&gt; 
Seq.toArray: source:seq&lt;'T&gt; -&gt; 'T[] 
Seq.ofArray: source:'T[] -&gt; seq&lt;'T&gt; 
</pre>
<p>These functions are very straightforward and do not require additional comments.</p>
<p>Apart from them stands function that converts a loosely-typed sequence from legacy pre-generic <code class="literal">System.Collections</code>
 namespace into a typed sequence:</p>
<pre class="programlisting">Seq.cast: source:IEnumerable -&gt; seq&lt;'T&gt; 
</pre>
<p>This casting is often needed in interoperability scenarios between F# and legacy Microsoft systems in order to convert them into F#-friendly strongly typed sequences. As an example of this, let's take a look at the following snippet (<code class="literal">Ch8_4.fsx</code>
 ):</p>
<pre class="programlisting">let s = System.Collections.Stack() 
s.Push(1) 
s.Push('2') 
s.Push("xyzzy") 
s |&gt; Seq.cast&lt;_&gt; |&gt; printfn "%A" 
// seq ["xyzzy"; '2'; 1] 
</pre>
<p>Here, you can see that a <code class="literal">Stack</code>
 loosely typed collection was casted to a strongly typed F# sequence and printed out. The output shows the F# sequence containing elements of different types: <code class="literal">string</code>
 , <code class="literal">char</code>
 , <code class="literal">int</code>
 . But the sequence is strongly typed, isn't it? Can you determine the type of the preceding sequence?</p>
</div>
</div>
<div class="section" title="The selection pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_16"><a id="ch08lvl2sec92"/>
 The selection pattern</h2>
</div>
</div>
</div>
<p>This kind of data transformation pattern can be recognized by segregating one or more elements from the collection based on certain characteristic(s). These traits can be very diverse: a position of element(s), an element value matching criteria, to name a few.</p>
<p>The genuine trait that distinguishes the selection transformation pattern from the rest of the crowd is the following: <span class="emphasis">
<em>selection result is always either a single element or a single collection carrying from zero to all elements of the original collection; the selection comes as-is, without any additional projection</em>
</span>
 .</p>
<p>Such a seemingly broad transformation class lays out into surprisingly few subclasses: positional selection, search, and filtering.</p>
<p>Position-based <span class="strong">
<strong>selection</strong>
</span>
 ties the element pick criteria with the element(s) position in the original collection; for example, take up to the first 10 elements of a collection.</p>
<p>
<span class="strong">
<strong>Searching</strong>
</span>
 and <span class="strong">
<strong>filtering</strong>
</span>
 are ubiquitous data collection transformations indeed. Although these two transformations strongly resemble each other, there is a subtle difference has place between them, which is outlined below.</p>
<p>Filtering is usually associated with taking a source collection and copying it to the result collection element by element sifting out <span class="emphasis">
<em>all</em>
</span>
 elements that do not match given criteria.</p>
<p>Turning to searching, it is usually associated with a more sophisticated process. The initial state for the search is composed of the original collection, initially empty search result, and search criteria. The search process also traverses the original collection element by element applying search criteria and shaping the search result. However, searching may carry not only the matching criteria, but also a stop condition of a sort and maybe some ranking. A typical example of searching would be this: "find <span class="emphasis">
<em>any</em>
</span>
 collection element that fulfills the condition(s)".</p>
<p>Based on this difference, I place searching in a separate selection pattern, but consider the filtering a part of the <span class="emphasis">
<em>element group selection</em>
</span>
 pattern.</p>
<div class="section" title="The position-based selection pattern">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_17"><a id="ch08lvl3sec33"/>
 The position-based selection pattern</h3>
</div>
</div>
</div>
<p>F# core library functions that constitute this pattern can be further broken down into two groups: single element selections and element group selections.</p>
<div class="section" title="Single element selection">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch08lvl4sec10"/>
 Single element selection</h4>
</div>
</div>
</div>
<p>This group of functions determines the single desired element by the position it occupies in the collection. The position may be requested either explicitly via an input argument or implicitly by the associated function name. To see what I mean please compare "give me the third element" with "give me the last element". Single element selection returns either the desired element or an indication that such an element does not exist:</p>
<pre class="programlisting">List.head: list:'T list -&gt; 'T 
Array.head: array:'T[] -&gt; 'T 
Seq.head: source:seq&lt;'T&gt; -&gt; 'T 
 
List.tryHead: list:'T list -&gt; 'T option 
Array.tryHead: array:'T[] -&gt; 'T option  
Seq.tryHead: source:seq&lt;'T&gt; -&gt; 'T option 
 
List.last: list:'T list -&gt; 'T 
Array.last: list:'T list -&gt; 'T 
Seq.last: source:seq&lt;'T&gt; -&gt; 'T 
 
List.tryLast: list:'T list -&gt; 'T option 
Array.tryLast: list:'T list -&gt; 'T option 
Seq.tryLast: source:seq&lt;'T&gt; -&gt; 'T option 
 
List.item: index:int -&gt; list:'T list -&gt; 'T 
Array.item: index:int -&gt; array:'T[] -&gt; 'T 
Array.get: array:'T[] -&gt; index:int -&gt; 'T 
Seq.item: index:int -&gt; source:seq&lt;'T&gt; -&gt; 'T 
 
List.tryItem: index:int -&gt; list:'T list -&gt; 'T option 
Array.tryItem: index:int -&gt; array:'T[] -&gt; 'T option 
Seq.tryItem: index:int -&gt; source:seq&lt;'T&gt; -&gt; 'T option 
 
List.nth: list:'T list -&gt; index:int -&gt; 'T // obsolete 
Seq.nth: index:int -&gt; source:seq&lt;'T&gt; -&gt; 'T // obsolete 
 
List.exactlyOne: list:'T list -&gt; 'T 
Array.exactlyOne: array:'T[] -&gt; 'T 
Seq.exactlyOne: source:seq&lt;'T&gt; -&gt; 'T 
</pre>
<p>Note how members of this group differ by the manner of indicating an unsuccessful selection. Some simply throw an exception, while the others wrap the selection result into an <code class="literal">option</code>
 , where <code class="literal">None</code>
 indicates the absence of the sought-for element: (<code class="literal">Ch8_5.fsx</code>
 ):</p>
<pre class="programlisting">List.head&lt;int&gt; [] 
// System.ArgumentException: The input list was empty. 
List.tryHead&lt;int&gt; [] 
// val it : int option = None 
</pre>
<p>Further on functions with names that begin with <code class="literal">try...</code>
 : these allow to alleviate the lurking possibility of the requested element being missing and handle such unfortunate cases nicely.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_18"><a id="tip10"/>
 Tip</h3>
<p>Use the <span class="emphasis">
<em>imperative</em>
</span>
 forms of selection with caution. If you are not ABSOLUTELY sure that the existence of requested element is invariant, fall back to <span class="emphasis">
<em>try</em>
</span>
 forms.</p>
</div>
<p>Also, note that for data collections that support element indexing, often the simple use of index does the job of dedicated library function, like in the following code (<code class="literal">Ch8_5.fsx</code>
 ):</p>
<pre class="programlisting">let ll = [1;2;3;4] 
List.head ll = ll.[0] 
//val it : bool = true 
</pre>
</div>
<div class="section" title="The element group selection">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch08lvl4sec11"/>
 The element group selection</h4>
</div>
</div>
</div>
<p>This collection transformation sub-pattern arranges the procurement of a group of elements from a collection based on the whole slew of criteria: it can be an element counter, a predicate peeking at an element's value, a collection of undesired values, or an exclusion of repeated values:</p>
<pre class="programlisting">List.take: count:int -&gt; list:'T list -&gt; 'T list 
Array.take: count:int -&gt; array:'T[] -&gt; 'T[] 
Seq.take: count:int -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.takeWhile: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T list 
Array.takeWhile: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T[] 
Seq.takeWhile: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.truncate: count:int -&gt; list:'T list -&gt; 'T list 
Array.truncate: count:int -&gt; array:'T[] -&gt; 'T[] 
Seq.truncate: count:int -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.skip: count:int -&gt; list: 'T list -&gt; 'T list 
Array.skip: count:int -&gt; array:'T[] -&gt; 'T[] 
Seq.skip: count:int -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.skipWhile: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T list 
Array.skipWhile: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T[] 
Seq.skipWhile: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.tail: list:'T list -&gt; 'T list 
Array.tail: array:'T[] -&gt; 'T[] 
Seq.tail: source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.filter: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T list 
Array.filter: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T[] 
Seq.filter: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.except: itemsToExclude:seq&lt;'T&gt; -&gt; list:'T list -&gt; 'T list when 'T : equality 
Array.except: itemsToExclude:seq&lt;'T&gt; -&gt; array:'T[] -&gt; 'T[] when 'T : equality 
Seq.except: itemsToExclude:seq&lt;'T&gt; -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; when 'T : equality 
 
List.choose: chooser:('T -&gt; 'U option) -&gt; list:'T list -&gt; 'U list 
Array.choose: chooser:('T -&gt; 'U option) -&gt; array:'T[] -&gt; 'U[] 
Seq.choose: chooser:('T -&gt; 'U option) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'U&gt; 
 
List.where: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T list 
Array.where: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T[] 
Seq.where: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
Array.sub: array:'T[] -&gt; startIndex:int -&gt; count:int -&gt; 'T[] 
 
List.distinct: list:'T list -&gt; 'T list when 'T : equality 
Array.distinct: array:'T[] -&gt; 'T[] when 'T : equality 
Seq.distinct: source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; when 'T : equality 
 
List.distinctBy: projection:('T -&gt; 'Key) -&gt; list:'T list -&gt; 'T list when 'Key : equality 
Array.distinctBy: projection:('T -&gt; 'Key) -&gt; array:'T[] -&gt; 'T[] when 'Key : equality 
Seq.distinctBy: projection:('T -&gt; 'Key) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; when 'Key : equality 
</pre>
<div class="note" title="Note">
<h3 class="title" id="toc_19"><a id="tip11"/>
 Tip</h3>
<p>Notice that the constituent of <span class="emphasis">
<em>element group selection</em>
</span>
 pattern is the ubiquitous <code class="literal">filter</code>
 function.</p>
</div>
<p>Similarly to the previous sub-pattern for collections implementing index slicing, this is an alternative way of element group selection (<code class="literal">Ch8_5.fsx</code>
 ):</p>
<pre class="programlisting">[|10;20;30;40;50;60|].[2..4] 
// val it : int [] = [|30; 40; 50|] 
</pre>
<p>You may also notice that the more generic <code class="literal">filter</code>
 function is accompanied by more specific filtering cases, such as <code class="literal">takeWhile</code>
 , <code class="literal">skipWhile</code>
 , or just a <code class="literal">where</code>
 synonym as shown here (<code class="literal">Ch8_5.fsx</code>
 ):</p>
<pre class="programlisting">let numbers = [1;2;3;4;5;6;7;8] 
List.filter (fun x -&gt; (%) x 2 = 0) numbers = List.where (fun x -&gt; (%) x 2 = 0) numbers 
// val it : bool = true 
</pre>
</div>
</div>
</div>
<div class="section" title="The searching pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_20"><a id="ch08lvl2sec93"/>
 The searching pattern</h2>
</div>
</div>
</div>
<p>The F# 4.0 core library offer a very normalized set of functions that constitute the <span class="strong">
<strong>search</strong>
</span>
 pattern, where the name of the function carries exhaustive characteristics of the function workings indeed.</p>
<p>All the functions that have <code class="literal">...find...</code>
 in the name perform the search for the first single element that occurs while having <code class="literal">...findIndex...</code>
 do the search for the same element but returning its ordinal number in the collection.</p>
<p>Functions that have <code class="literal">...Back...</code>
 in the name perform the search in the opposite direction of the natural order of elements.</p>
<p>Similarly to the already examined selection pattern groups, the library functions of the search pattern implement two approaches to represent the <span class="emphasis">
<em>"not found"</em>
</span>
 search outcome: those without the <code class="literal">try...</code>
 prefix throw an exception if the search comes back empty, while others with the <code class="literal">try...</code>
 prefix in this situation return the <code class="literal">None</code>
 option; otherwise, it returns the found element wrapped into <code class="literal">Some...</code>
 option as shown here:</p>
<pre class="programlisting">List.find: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T 
Array.find: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T 
Seq.find: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; 'T 
 
List.tryFind: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T option 
Array.tryFind: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T option 
Seq.tryFind: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; 'T option 
 
List.findIndex: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; int 
Array.findIndex: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; int 
Seq.findIndex: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; int 
 
List.tryFindIndex: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; int option 
List.tryFindIndexBack: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; int option 
 
List.findBack: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T 
Array.findBack: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T 
Seq.findBack: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; 'T 
 
List.tryFindBack: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; 'T option 
Array.tryFindBack: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T option 
Seq.tryFindBack: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; 'T option 
 
List.findIndexBack: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; int 
Array.findIndexBack: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; int 
Seq.findIndexBack: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; int 
 
List.pick: chooser:('T -&gt; 'U option) -&gt; list:'T list -&gt; 'U 
Array.pick: chooser:('T -&gt; 'U option) -&gt; array:'T[] -&gt; 'U  
Seq.pick: chooser:('T -&gt; 'U option) -&gt; source:seq&lt;'T&gt; -&gt; 'U 
 
List.tryPick: chooser:('T -&gt; 'U option) -&gt; list:'T list -&gt; 'U option 
Array.tryPick: chooser:('T -&gt; 'U option) -&gt; array:'T[] -&gt; 'U option 
Seq.tryPick: chooser:('T -&gt; 'U option) -&gt; source:seq&lt;'T&gt; -&gt; 'U option 
</pre>
<p>Let's demonstrate the listed above instruments in action (<code class="literal">Ch8_5.fsx</code>
 ):</p>
<pre class="programlisting">List.find (fun x -&gt; (%) x 2 = 0) &lt;| [1;3;5] 
// System.Collections.Generic.KeyNotFoundException: 
// Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown. 
List.tryFind (fun x -&gt; (%) x 2 = 0) &lt;| [1;3;5] 
// val it : int option = None 
List.find (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int = 1 
List.tryFind (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int option = Some 1 
List.findIndex (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int = 0 
List.tryFindIndex (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int option = Some 0 
List.findBack (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int = 5 
List.tryFindBack (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int option = Some 5 
List.findIndexBack (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int = 2 
List.tryFindIndexBack (fun x -&gt; (%) x 2 &lt;&gt; 0) &lt;| [1;3;5] 
// val it : int option = Some 2 
</pre>
<p>Slightly apart from this very logical arrangement stands the <code class="literal">(try)pick</code>
 group of functions. Functions that belong to this group combine both search and transform functionalities together: the <code class="literal">chooser</code>
 function applies to each element of type <code class="literal">'T</code>
 , producing <code class="literal">None</code>
 until the first element matches the search criteria somehow expressed within <code class="literal">chooser</code>
 . Then, <code class="literal">Some</code>
 is wrapped around potentially different type <code class="literal">'U</code>
 and is returned, and the higher-order function returns the result of type <code class="literal">'U</code>
 . If <code class="literal">chooser</code>
 does not find any suitable element, then <code class="literal">pick</code>
 throws an exception, while <code class="literal">tryPick</code>
 returns <code class="literal">None</code>
 (<code class="literal">Ch8_5.fsx</code>
 ):</p>
<pre class="programlisting">[(9,"Nine");(42,"FortyTwo");(0,"Zero")] 
|&gt; List.pick (fun (x,y) -&gt; if x = 42 then Some y else None) 
// val it : string = "FortyTwo" 
[(9,"Nine");(42,"FortyTwo");(0,"Zero")] 
|&gt; List.tryPick (fun (x,y) -&gt; if x = 42 then Some y else None) 
// val it : string option = Some "FortyTwo" 
[(9,"Nine");(42,"FortyTwo");(0,"Zero")] 
|&gt; List.pick (fun (x,y) -&gt; if x = 14 then Some y else None) 
// System.Collections.Generic.KeyNotFoundException: 
// Exception of type 'System.Collections.Generic.KeyNotFoundException' was thrown. 
[(9,"Nine");(42,"FortyTwo");(0,"Zero")] 
|&gt; List.tryPick (fun (x,y) -&gt; if x = 14 then Some y else None) 
// val it : string option = None 
</pre>
<p>Please pay attention how the above functions fuse together to some extent selection and transformation by applying both actions while traversing the collection only once.</p>
</div>
<div class="section" title="The partitioning pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_21"><a id="ch08lvl2sec94"/>
 The partitioning pattern</h2>
</div>
</div>
</div>
<p>F# core library elements of <span class="strong">
<strong>partitioning</strong>
</span>
 pattern consume a single collection, usually returning more than one result collections as shown here:</p>
<pre class="programlisting">List.chunkBySize: chunkSize:int -&gt; list:'T list -&gt; 'T list list 
Array.chunkBySize: chunkSize:int -&gt; array:'T[] -&gt; 'T[][] 
Seq.chunkBySize: chunkSize:int -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T[]&gt; 
 
List.groupBy : projection:('T -&gt; 'Key) -&gt; list:'T list -&gt; ('Key * 'T list) list when 'Key : equality 
Array.groupBy: projection:('T -&gt; 'Key) -&gt; array:'T[] -&gt; ('Key * 'T[])[]  when 'Key : equality 
Seq.groupBy : projection:('T -&gt; 'Key) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'Key * seq&lt;'T&gt;&gt; when 'Key : equality 
 
List.pairwise: list:'T list -&gt; ('T * 'T) list 
Array.pairwise: array:'T[] -&gt; ('T * 'T)[] 
Seq.pairwise: source:seq&lt;'T&gt; -&gt; seq&lt;'T * 'T&gt; 
 
List.partition: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; ('T list * 'T list) 
Array.partition: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; 'T[] * 'T[] 
 
List.splitAt: index:int -&gt; list:'T list -&gt; ('T list * 'T list) 
Array.splitAt: index:int -&gt; array:'T[] -&gt; ('T[] * 'T[]) 
 
List.splitInto: count:int -&gt; list:'T list -&gt; 'T list list 
Array.splitInto: count:int -&gt; array:'T[] -&gt; 'T[][] 
Seq.splitInto: count:int -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T[]&gt; 
 
List.windowed: windowSize:int -&gt; list:'T list -&gt; 'T list list 
Array.windowed: windowSize:int -&gt; array:'T[] -&gt; 'T[][] 
Seq.windowed: windowSize:int -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T[]&gt; 
</pre>
<p>Examples of simple usage of the preceding functions are as following (<code class="literal">Ch8_6.fsx</code>
 ):</p>
<pre class="programlisting">List.chunkBySize 2 ['a'..'g'] 
// val it : char list list = [['a'; 'b']; ['c'; 'd']; ['e'; 'f']; ['g']] 
 
List.groupBy (fun n -&gt; n / 3) [1..7] 
// val it : (int * int list) list = [(0, [1; 2]); (1, [3; 4; 5]); (2, [6; 7])] 
 
List.pairwise [1..2..10] 
// val it : (int * int) list = [(1, 3); (3, 5); (5, 7); (7, 9)] 
 
["angle";"delta";"cheese";"America"] 
|&gt; List.partition (fun (x:string) -&gt; (System.Char.ToUpper x.[0]) = 'A') 
// val it : string list * string list = 
//  (["angle"; "America"], ["delta"; "cheese"]) 
 
["angle";"delta";"cheese";"America"] 
|&gt; List.splitAt 2 
// val it : string list * string list = 
//  (["angle"; "delta"], ["cheese"; "America"]) 
 
["angle";"delta";"cheese";"America"] 
|&gt; List.splitInto 3 
// val it : string list list = 
//   [["angle"; "delta"]; ["cheese"]; ["America"]] 
 
["angle";"delta";"cheese";"America"] 
|&gt; List.windowed 2 
// val it : string list list = 
//   [["angle"; "delta"]; ["delta"; "cheese"]; ["cheese"; "America"]] 
</pre>
</div>
<div class="section" title="The reordering pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_22"><a id="ch08lvl2sec95"/>
 The reordering pattern</h2>
</div>
</div>
</div>
<p>This group of F# core library functions represents the <span class="strong">
<strong>reordering</strong>
</span>
 data transformation pattern of changing the order of the elements in the collection using many forms of sorting, reversing, and permuting:</p>
<pre class="programlisting">List.rev: list:'T list -&gt; 'T list 
Array.rev: array:'T[] -&gt; 'T[] 
Seq.rev: source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.sort: list:'T list -&gt; 'T list when 'T : comparison 
Array.sort: array:'T[] -&gt; 'T[] when 'T : comparison 
Seq.sort: source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; when 'T : comparison 
 
List.sortDescending: list:'T list -&gt; 'T list when 'T : comparison 
Array.sortDescending: array:'T[] -&gt; 'T[] when 'T : comparison 
 
List.sortBy: projection:('T -&gt; 'Key) -&gt; list:'T list -&gt; 'T list when 'Key : comparison 
Array.sortBy: projection:('T -&gt; 'Key) -&gt; array:'T[] -&gt; 'T[] when 'Key : comparison 
Seq.sortBy: projection:('T -&gt; 'Key) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; when 'Key : comparison 
 
List.sortByDescending: projection:('T -&gt; 'Key) -&gt; list:'T list -&gt; 'T list when 'Key : comparison 
Array.sortByDescending: projection:('T -&gt; 'Key) -&gt; array:'T[] -&gt; 'T[] when 'Key : comparison 
Seq.sortByDescending : projection:('T -&gt; 'Key) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; when 'Key : comparison 
 
List.sortWith: comparer:('T -&gt; 'T -&gt; int) -&gt; list:'T list -&gt; 'T list 
Array.sortWith: comparer:('T -&gt; 'T -&gt; int) -&gt; array:'T[] -&gt; 'T[] 
Seq.sortWith : comparer:('T -&gt; 'T -&gt; int) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.permute : indexMap:(int -&gt; int) -&gt; list:'T list -&gt; 'T list 
Array.permute : indexMap:(int -&gt; int) -&gt; array:'T[] -&gt; 'T[] 
Seq.permute: indexMap:(int -&gt; int) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
Array.sortInPlace: array:'T[] -&gt; unit when 'T : comparison 
Array.sortInPlaceBy: projection:('T -&gt; 'Key) -&gt; array:'T[] -&gt; unit when 'Key : comparison 
Array.sortInPlaceWith: comparer:('T -&gt; 'T -&gt; int) -&gt; array:'T[] -&gt; unit 
</pre>
<p>Some examples of the reordering transformations are as following (<code class="literal">Ch8_7.fsx</code>
 ):</p>
<pre class="programlisting">List.sort [1;8;3;6;4;-2] 
// val it : int list = [-2; 1; 3; 4; 6; 8] 
List.sortDescending [1;8;3;6;4;-2] 
// val it : int list = [8; 6; 4; 3; 1; -2] 
List.sortBy (fun x -&gt; x.GetHashCode()) ["Fourteen";"Zero";"Forty Two"] 
// val it : string list = ["Zero"; "Forty Two"; "Fourteen"] 
</pre>
<p>Take into account that some functions perform the reordering by mutating the input collection. These are limited to <code class="literal">ArraysortInPlace</code>
 , <code class="literal">sortInPlaceBy</code>
 , and <code class="literal">sortInPlaceWith</code>
 .</p>
</div>
<div class="section" title="The testing pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_23"><a id="ch08lvl2sec96"/>
 The testing pattern</h2>
</div>
</div>
</div>
<p>This is a very straightforward pattern. <span class="strong">
<strong>Testing</strong>
</span>
 library functions instead of transforming the input collection, always returning the <code class="literal">bool</code>
 result: <code class="literal">true</code>
 if certain properties have place, otherwise <code class="literal">false</code>
 . They may check whether the given collection contains the given element, whether an element exists with the value, turning the given predicate to <code class="literal">true</code>
 , whether all elements of the collection turn the given predicate to <code class="literal">true</code>
 , or whether the input collection is empty as their signatures reflect below:</p>
<pre class="programlisting">List.contains: value:'T -&gt; source:'T list -&gt; bool when 'T : equality 
Array.contains: value:'T -&gt; array:'T[] -&gt; bool when 'T : equality 
Seq.contains: value:'T -&gt; source:seq&lt;'T&gt; -&gt; bool when 'T : equality 
 
List.exists: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; bool 
Array.exists: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; bool 
Seq.exists: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; bool 
 
List.exists2: predicate:('T1 -&gt; 'T2 -&gt; bool) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; bool 
Array.exists2: predicate:('T1 -&gt; 'T2 -&gt; bool) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; bool 
Seq.exists2: predicate:('T1 -&gt; 'T2 -&gt; bool) -&gt; source1:seq&lt;'T1&gt; -&gt; &lt;'T2&gt; -&gt; bool 
 
List.forall: predicate:('T -&gt; bool) -&gt; list:'T list -&gt; bool 
Array.forall: predicate:('T -&gt; bool) -&gt; array:'T[] -&gt; bool 
Seq.forall: predicate:('T -&gt; bool) -&gt; source:seq&lt;'T&gt; -&gt; bool 
 
List.forall2: predicate:('T1 -&gt; 'T2 -&gt; bool) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; bool 
Array.forall2: predicate:('T1 -&gt; 'T2 -&gt; bool) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; bool 
Seq.forall2: predicate:('T1 -&gt; 'T2 -&gt; bool) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; bool 
 
List.isEmpty: list:'T list -&gt; bool 
Array.isEmpty: array:'T[] -&gt; bool 
Seq.isEmpty: source:seq&lt;'T&gt; -&gt; bool 
 
List.compareWith: comparer:('T -&gt; 'T -&gt; int) -&gt; list1:'T list -&gt; list2:'T list -&gt; int 
Array.compareWith: comparer:('T -&gt; 'T -&gt; int) -&gt; array1:'T[] -&gt; array2:'T[] -&gt; int 
Seq.compareWith: comparer:('T -&gt; 'T -&gt; int) -&gt; source1:seq&lt;'T&gt; -&gt; source2:seq&lt;'T&gt; -&gt; int 
</pre>
<p>The functions representing this pattern have so obvious an intent that I didn't even provide the usage samples for them; the samples can be easily found in F# core library documentation.</p>
</div>
<div class="section" title="The iterating pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_24"><a id="ch08lvl2sec97"/>
 The iterating pattern</h2>
</div>
</div>
</div>
<p>This is another very straightforward data transformation pattern. In fact, <span class="strong">
<strong>iterating</strong>
</span>
 pattern <span class="emphasis">
<em>does not introduce any noticeable transformations</em>
</span>
 , merely denoting instead the collection traversal. Its member functions always return <code class="literal">unit</code>
 . On each single traversal step the operations performed upon the current element are hidden behind the <code class="literal">action</code>
 function.</p>
<p>This manner of data transformations must vividly remind us of imperative and object-oriented paradigms as <code class="literal">action</code>
 effectively hides what's going on and also must exploit some side effects in order to be of any practical use. Such F# programs that massively (ab) use the iterating data transformation pattern usually indicate that their authors are still captives of a non-functional way of thinking.</p>
<p>The signatures of functions representing iterating pattern are given below:</p>
<pre class="programlisting">List.iter: action:('T -&gt; unit) -&gt; list:'T list -&gt; unit 
Array.iter: action:('T -&gt; unit) -&gt; array:'T[] -&gt; unit 
Seq.iter: action:('T -&gt; unit) -&gt; source:seq&lt;'T&gt; -&gt; unit 
 
List.iter2: action:('T1 -&gt; 'T2 -&gt; unit) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; unit 
Array.iter2: action:('T1 -&gt; 'T2 -&gt; unit) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; unit 
Seq.iter2: action:('T1 -&gt; 'T2 -&gt; unit) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; unit 
 
List.iteri: action:(int -&gt; 'T -&gt; unit) -&gt; list:'T list -&gt; unit 
Array.iteri: action:(int -&gt; 'T -&gt; unit) -&gt; array:'T[] -&gt; unit 
Seq.iteri: action:(int -&gt; 'T -&gt; unit) -&gt; source:seq&lt;'T&gt; -&gt; unit 
 
List.iteri2: action:(int -&gt; 'T1 -&gt; 'T2 -&gt; unit) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; unit 
Array.iteri2: action:(int -&gt; 'T1 -&gt; 'T2 -&gt; unit) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; unit 
Seq.iteri2: action:(int -&gt; 'T1 -&gt; 'T2 -&gt; unit) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; unit 
</pre>
<p>Note that library member functions of this pattern demonstrate a certain level of regularization. The actions may involve elements (<code class="literal">iter</code>
 , <code class="literal">iter2</code>
 ), or elements and the index (<code class="literal">iteri</code>
 , <code class="literal">iteri2</code>
 ), and also may involve a single collection (<code class="literal">iter</code>
 , <code class="literal">iteri</code>
 ) or pair of collections (<code class="literal">iter2</code>
 , <code class="literal">iteri2</code>
 ).</p>
<p>As with the testing pattern, finding samples of these function's use on the Internet is not a problem.</p>
</div>
<div class="section" title="The mapping pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_25"><a id="ch08lvl2sec98"/>
 The mapping pattern</h2>
</div>
</div>
</div>
<p>Mappings constitute the gist of data transformations, projecting one or more input elements to the single result and then applying this projection to the entire input collection(s) producing the result collection(s) as the following member function signatures indicate:</p>
<pre class="programlisting">List.map: mapping:('T -&gt; 'U) -&gt; list:'T list -&gt; 'U list 
Array.map: mapping:('T -&gt; 'U) -&gt; array:'T[] -&gt; 'U[] 
Seq.map: mapping:('T -&gt; 'U) -&gt; sequence:seq&lt;'T&gt; -&gt; seq&lt;'U&gt; 
 
List.map2: mapping:('T1 -&gt; 'T2 -&gt; 'U) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; 'U list 
Array.map2: mapping:('T1 -&gt; 'T2 -&gt; 'U) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; 'U[] 
Seq.map2: mapping:('T1 -&gt; 'T2 -&gt; 'U) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; seq&lt;'U&gt; 
 
List.mapi: mapping:(int -&gt; 'T -&gt; 'U) -&gt; list:'T list -&gt; 'U list 
Array.mapi: mapping:(int -&gt; 'T -&gt; 'U) -&gt; array:'T[] -&gt; 'U[] 
Seq.mapi: mapping:(int -&gt; 'T -&gt; 'U) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'U&gt; 
 
List.mapi2: mapping:(int -&gt; 'T1 -&gt; 'T2 -&gt; 'U) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; 'U list 
Array.mapi2: mapping:(int -&gt; 'T1 -&gt; 'T2 -&gt; 'U) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; 'U[] 
Seq.mapi2: mapping:(int -&gt; 'T1 -&gt; 'T2 -&gt; 'U) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; seq&lt;'U&gt; 
 
List.map3: mapping:('T1 -&gt; 'T2 -&gt; 'T3 -&gt; 'U) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; list3:'T3 list -&gt; 'U list 
Array.map3: mapping:('T1 -&gt; 'T2 -&gt; 'T3 -&gt; 'U) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; array3:'T3[] -&gt; 'U[] 
Seq.map3: mapping:('T1 -&gt; 'T2 -&gt; 'T3 -&gt; 'U) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; source3:seq&lt;'T3&gt; -&gt; seq&lt;'U&gt; 
 
List.collect: mapping:('T -&gt; 'U list) -&gt; list:'T list -&gt; 'U list 
Array.collect: mapping:('T -&gt; 'U[]) -&gt; array:'T[] -&gt; 'U[] 
Seq.collect: mapping:('T -&gt; 'Collection) -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'U&gt;  when 'Collection :&gt; seq&lt;'U&gt; 
 
List.indexed: list:'T list -&gt; (int * 'T) list 
Array.indexed: array:'T[] -&gt; (int * 'T)[] 
Seq.indexed: source:seq&lt;'T&gt; -&gt; seq&lt;int * 'T&gt; 
</pre>
<p>Note that the group of functions belonging to the mapping pattern is normalized fairly well. Functions with names resembling <code class="literal">map</code>
 (<code class="literal">map</code>
 , <code class="literal">map2</code>
 , <code class="literal">map3</code>
 ) project elements of a single, a pair, or a triple of input collections to the elements of the single result collection. Functions with names resembling <code class="literal">mapi</code>
 (<code class="literal">mapi</code>
 , <code class="literal">mapi2</code>
 ) also add the ordinal number of element(s) as an additional input parameter to the projection.</p>
<p>The <code class="literal">collect</code>
 function does not fit the same approach. Instead, it projects each element of the input collection into a matching collection and then flattens all these element-matching collections into a single result collection. It's a bit complicated, so I'd better provide an example.</p>
<p>Let's assume we are given an array of words and we want to convert it into a list of characters constituting input words (<code class="literal">Ch8_7.fsx</code>
 ):</p>
<pre class="programlisting">"Je ne regrette rien".Split([|' '|]) 
|&gt; Seq.collect (fun x -&gt; x.ToCharArray()) 
|&gt; Seq.toList 
// val it : char list = 
//  ['J'; 'e'; 'n'; 'e'; 'r'; 'e'; 'g'; 
//   'r'; 'e'; 't'; 't'; 'e'; 'r'; 'i'; 'e'; 'n'] 
</pre>
<p>The <code class="literal">indexed</code>
 function is a helper function; it converts any collection into a collection of tuples, each combining an ordinal number of the original element and the element itself (<code class="literal">Ch8_7.fsx</code>
 ):</p>
<pre class="programlisting">"Je ne regrette rien".Split([|' '|]) 
|&gt; Seq.indexed 
// val it : seq&lt;int * string&gt; = 
//  seq [(0, "Je"); (1, "ne"); (2, "regrette"); (3, "rien")] 
</pre>
</div>
<div class="section" title="The folding pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_26"><a id="ch08lvl2sec99"/>
 The folding pattern</h2>
</div>
</div>
</div>
<p>I've already mentioned on multiple occasions the <code class="literal">fold</code>
 function as a representation of the most universal and generic data transformation pattern of functional programming. As it has already been covered fairly well, I will not get into details here and will just list the multiple variations of this extremely versatile <span class="strong">
<strong>folding</strong>
</span>
 pattern as shown by the following member function signatures:</p>
<pre class="programlisting">List.fold&lt;'T,'State&gt; : folder:('State -&gt; 'T -&gt; 'State) -&gt; state:'State -&gt; list:'T list -&gt; 'State 
Array.fold&lt;'T,'State&gt; : folder:('State -&gt; 'T -&gt; 'State) -&gt; state:'State -&gt; array: 'T[] -&gt; 'State 
Seq.fold&lt;'T,'State&gt; : folder:('State -&gt; 'T -&gt; 'State) -&gt; state:'State -&gt; source:seq&lt;'T&gt; -&gt; 'State 
List.fold2&lt;'T1,'T2,'State&gt; : folder:('State -&gt; 'T1 -&gt; 'T2 -&gt; 'State) -&gt; state:'State -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; 'State 
Array.fold2&lt;'T1,'T2,'State&gt;  : folder:('State -&gt; 'T1 -&gt; 'T2 -&gt; 'State) -&gt; state:'State -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; 'State 
Seq.fold2&lt;'T1,'T2,'State&gt; : folder:('State -&gt; 'T1 -&gt; 'T2 -&gt; 'State) -&gt; state:'State -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; 'State 
List.mapFold&lt;'T,'State,'Result&gt; : mapping:('State -&gt; 'T -&gt; 'Result * 'State) -&gt; state:'State -&gt; list:'T list -&gt; 'Result list * 'State 
Array.mapFold&lt;'T,'State,'Result&gt; : mapping:('State -&gt; 'T -&gt; 'Result * 'State) -&gt; state:'State -&gt; array:'T[] -&gt; 'Result[] * 'State 
Seq.mapFold&lt;'T,'State,'Result&gt; : mapping:('State -&gt; 'T -&gt; 'Result * 'State) -&gt; state:'State -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'Result&gt; * 'State 
 
List.foldBack&lt;'T,'State&gt; : folder:('T -&gt; 'State -&gt; 'State) -&gt; list:'T list -&gt; state:'State -&gt; 'State 
Array.foldBack&lt;'T,'State&gt; : folder:('T -&gt; 'State -&gt; 'State) -&gt; array:'T[] -&gt; state:'State -&gt; 'State 
Seq.foldBack&lt;'T,'State&gt; : folder:('T -&gt; 'State -&gt; 'State) -&gt; source:seq&lt;'T&gt; -&gt; state:'State -&gt; 'State 
 
List.foldBack2&lt;'T1,'T2,'State&gt; : folder:('T1 -&gt; 'T2 -&gt; 'State -&gt; 'State) -&gt; list1:'T1 list -&gt; list2:'T2 list -&gt; state:'State -&gt; 'State 
Array.foldBack2&lt;'T1,'T2,'State&gt; : folder:('T1 -&gt; 'T2 -&gt; 'State -&gt; 'State) -&gt; array1:'T1[] -&gt; array2:'T2[] -&gt; state:'State -&gt; 'State 
Seq.foldBack2&lt;'T1,'T2,'State&gt; : folder:('T1 -&gt; 'T2 -&gt; 'State -&gt; 'State) -&gt; source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; state:'State -&gt; 'State 
 
List.mapFoldBack&lt;'T,'State,'Result&gt; : mapping:('T -&gt; 'State -&gt; 'Result * 'State) -&gt; list:'T list -&gt; state:'State -&gt; 'Result list * 'State 
Array.mapFoldBack&lt;'T,'State,'Result&gt; : mapping:('T -&gt; 'State -&gt; 'Result * 'State) -&gt; array:'T[] -&gt; state:'State -&gt; 'Result[] * 'State 
Seq.mapFoldBack&lt;'T,'State,'Result&gt; : mapping:('T -&gt; 'State -&gt; 'Result * 'State) -&gt; source:seq&lt;'T&gt; -&gt; state:'State -&gt; seq&lt;'Result&gt; * 'State 
 
List.scan&lt;'T,'State&gt;  : folder:('State -&gt; 'T -&gt; 'State) -&gt; state:'State -&gt; list:'T list -&gt; 'State list 
Array.scan&lt;'T,'State&gt; : folder:('State -&gt; 'T -&gt; 'State) -&gt; state:'State -&gt; array:'T[] -&gt; 'State[] 
Seq.scan&lt;'T,'State&gt; : folder:('State -&gt; 'T -&gt; 'State) -&gt; state:'State -&gt; source:seq&lt;'T&gt; -&gt; seq&lt;'State&gt; 
 
List.scanBack&lt;'T,'State&gt; : folder:('T -&gt; 'State -&gt; 'State) -&gt; list:'T list -&gt; state:'State -&gt; 'State list 
Array.scanBack&lt;'T,'State&gt; : folder:('T -&gt; 'State -&gt; 'State) -&gt; array:'T[] -&gt; state:'State -&gt; 'State[] 
Seq.scanBack&lt;'T,'State&gt; : folder:('T -&gt; 'State -&gt; 'State) -&gt; source:seq&lt;'T&gt; -&gt; state:'State -&gt; seq&lt;'State&gt; 
</pre>
<p>In addition to multiple <code class="literal">fold</code>
 usage examples sprinkled around the book and readily available on the Internet I provide a few more in the script <code class="literal">Ch8_8.fsx</code>
 .</p>
</div>
<div class="section" title="The merge/split pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_27"><a id="ch08lvl2sec100"/>
 The merge/split pattern</h2>
</div>
</div>
</div>
<p>Our long journey into the world of data transformation patterns captured by F# 4.0 core library has reached the last stop. Here, functions residing with <span class="strong">
<strong>merge/split</strong>
</span>
 pattern either merge some collections into one, or perform the opposite by splitting one collection into many:</p>
<pre class="programlisting">List.append: list1:'T list -&gt; list2:'T list -&gt; 'T list 
Array.append: array1:'T[] -&gt; array2:'T[] -&gt; 'T[] 
Seq.append: source1:seq&lt;'T&gt;  -&gt; source2:seq&lt;'T&gt; -&gt; seq&lt;'T&gt; 
 
List.concat: lists:seq&lt;'T list&gt; -&gt; 'T list 
Array.concat: arrays:seq&lt;'T[]&gt; -&gt; 'T[] 
Seq.concat: sources:seq&lt;'Collection&gt; -&gt; seq&lt;'T&gt; when 'Collection :&gt; seq&lt;'T&gt; 
 
List.zip: list1:'T1 list -&gt; list2:'T2 list -&gt; ('T1 * 'T2) list 
Array.zip: array1:'T1[] -&gt; array2:'T2[] -&gt; ('T1 * 'T2)[] 
Seq.zip: source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; seq&lt;'T1 * 'T2&gt; 
 
List.zip3: list1:'T1 list -&gt; list2:'T2 list -&gt; list3:'T3 list -&gt; ('T1 * 'T2 * 'T3) list 
Array.zip3: array1:'T1[] -&gt; array2:'T2[] -&gt; array3:'T3[] -&gt; ('T1 * 'T2 * 'T3)[] 
Seq.zip3: source1:seq&lt;'T1&gt; -&gt; source2:seq&lt;'T2&gt; -&gt; source3:seq&lt;'T3&gt; -&gt; seq&lt;'T1 * 'T2 * 'T3&gt; 
 
List.unzip: list:('T1 * 'T2) list -&gt; ('T1 list * 'T2 list) 
Array.unzip: array:('T1 * 'T2)[] -&gt; ('T1[] * 'T2[]) 
 
List.unzip3 list:('T1 * 'T2 * 'T3) list -&gt; ('T1 list * 'T2 list * 'T3 list) 
Array.unzip3 array:('T1 * 'T2 * 'T3)[] -&gt; ('T1[] * 'T2[] * 'T3[]) 
</pre>
<p>The <code class="literal">append</code>
 function is the simplest form of merge pattern as it combines a pair of collections into the single one. Elements of the second argument collection just follow the elements of the first argument collection in the result collection.</p>
<p>The <code class="literal">concat</code>
 function is the generalization of <code class="literal">append</code>
 to any number of input collections just wrapped into a sequence.</p>
<p>Finally, zippers (<code class="literal">zip</code>
 , <code class="literal">zip3</code>
 ) take two or three collections and turn them into a single collection of corresponding tuples. Unzippers (<code class="literal">unzip</code>
 , <code class="literal">unzip3</code>
 ) do the opposite, taking a collection of tuples and turning it into the tuple of collections. Note that the library does not provide unzippers for <code class="literal">seq</code>
 .</p>
</div>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch08lvl1sec59"/>
 Summary</h1>
</div>
</div>
</div>
<p>This was a long chapter, but it was an essential step into the universal patterns of data transformations and their reflection in the F# 4.0 core library. The knowledge you acquired will support the process of idiomatic blueprinting of an arbitrary data transformation by prompting you to build your F# code around the handful of retained reference points. When you mentally dissect your task at hand into a composition of functions along the patterns covered here, the high-quality library functions are always available for you to quickly compose from them an error-free and adequately performant solution.</p>
<p>The next chapter will continue with the data transformation theme, looking into F# data queries and the subject of data parsing.</p>
</div>
</body></html>