- en: '*Chapter 11*: Quest Tracking and Branching Narratives'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will review how to create an ink template for quests, track
    multiple quests based on this template, and show the player the values of variables
    across quests. In the first section, we will create an ink template and its required
    sections. Next, we will improve the ink template and create a `Quest` class to
    track multiple quests progressing independently from each other. Finally, we will
    show the player the results of progressing quests and view the values of change
    during this progression.
  prefs: []
  type: TYPE_NORMAL
- en: Many larger or narrative-focused video games are composed of separate quests
    for the player to complete. This chapter will provide a template for creating
    quests in ink and will also show you how to access and manipulate this template
    in Unity. Using multiple quests, a branching narrative approach is possible by
    allowing a player to progress through each quest separately, as explained in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a quest count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking progress across multiple quests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and awarding player progression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each topic in this chapter has a separate, completed Unity project. Each topic
    includes instructions that state the name of the project and where to find it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples in this chapter have been divided into folders per project and
    can be found online on GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Making a quest count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In narrative terms, a **quest** is a series of events connected to a character
    within a story. In video games, quests are a sequence of connected events experienced
    by the *player*. In role-playing games, a quest might include unlocking a weapon,
    rescuing a prince, or defeating some great evil. Each point along the way is a
    *step* of the quest. Translated in terms of story and code, a quest can be thought
    of as a series of steps where the resolution of each step unlocks the next.
  prefs: []
  type: TYPE_NORMAL
- en: ink supports this pattern of smaller parts within a larger whole as stitches
    within a knot. Thought of in this way, each step of the quest can become its own
    stitch within the code, with the outcome of each stitch being able to move to
    the next within the larger structure. Using `LIST` in ink also allows us to define
    the steps we want by name, with a special knot progressing the player from one
    stitch to the next within the quest structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to design a quest template in ink and access
    its values in Unity across one single project, with each section building on the
    previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, *Creating a quest template in ink*, we will review how
    to use this pattern and the built-in automation available by using existing Ink
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second section, *Choosing specific knots in Unity*, we will move away
    from ink and look at Unity. Here, we will examine how to run the template in ink,
    as well as some potential issues to be aware of when using certain Story API methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reminder
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159),
    examples on GitHub folder, under the name `Chapter11,QuestProgression`. Only select
    parts of the code will be shown as they relate to the concepts examined in the
    sections of this topic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let us understand the next topic where we will create a quest template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a quest template in ink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ink stories are composed of different sections. In [*Chapter 1*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014),
    *Text Flow, Choices, and Weaves*, we learned how ink breaks code into different
    sections called `VAR` and `LIST` keywords in ink, which we did in [*Chapter 4*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062),
    *Variables, Lists, and Functions*, we can create a quest that''s composed of a
    series of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a list named `steps`, a variable named `step`, and a variable
    named `end` in ink. These three values keep track of the *quest''s progression*.
    The name of each step in the quest is added as an entry to the list, with the
    first used as the value of the `stage` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The player is presented with their first options: `Sure` and `Not today`. If
    the first is selected, the flow moves into the `quest` knot. If the second is
    selected, the flow moves to a stitch inside of the `quest` knot named `stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The names *quest* and *stop* were chosen specifically. The use of the word *quest*
    helps in understanding the code as part of a template for other quests. As will
    be outlined in the next section, *Tracking progress across multiple quests*, multiple
    `Story` objects can exist at the same time in Unity. In this case, the word is
    used to show the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quest` knot contains the central logic of this pattern. Because the entries
    in a `LIST` in ink are Boolean values (either `true` or `false`), a multi-line
    comparison is used, where the order is important. The list named `steps` contains
    three entries, each of which are initially set to `true`. When the `quest` knot
    is first encountered, it will move the flow to the stitch named `first`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `first` stitch contains an unusual ending. The use of the `DONE` keyword
    usually signals that the story is over in ink. However, in this case, the `DONE`
    keyword is used to signal that the *step* is done. Instead of diverting to the
    `quest` knot or another section, the story seemingly stops. Progression happens
    using a combination of the `LIST_MIN()` function and the subtraction (`-`) operation
    for lists in Ink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Within the `progress` knot, each entry is removed (subtracted) and the top (minimum)
    value is used as part of the `step` variable. Each use of this knot *progresses*
    the quest by removing a step from the list and then using the top remaining one
    each time. However, the knot itself is not accessed directly. Instead, it is used
    externally by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how each step can be divided into stitches as part
    of a knot named `quest`. By using a `LIST` and different variables in ink, progress
    can be tracked across the quest. In the next section, we will learn how an ink
    template can be used as a series of steps to access the `progress` knot externally
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing specific knots in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different methods and properties of the Story API provided by the ink-Unity
    Integration plugin were covered in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106),
    *Unity API – Making Choices and Story Progression*, and [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123),
    *Story API – Accessing ink Variables and Functions*. However, what was not covered
    in those chapters was a useful but potentially very dangerous method named `ChoosePathString()`.
    In this section, we will look at an example of how this method can be used safely.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the ink runtime uses the term "path string" to describe any knot
    that is part of a story. When loaded, these can be accessed by using the `ChoosePathString()`
    method, which forcibly moves the story to that section. In most cases, this is
    unwanted behavior, as its use will disregard any existing tunnels or threads.
    It can be thought of as *ripping* the flow away from wherever it was and dropping
    it into a new location.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the ink runtime, variables are global. This means that while their
    values might be changed as part of the flow of a story, they exist outside of
    it. The values of variables are maintained despite any uses of the `ChoosePathString()`
    method. In other words, by carefully avoiding any structures that might be disrupted
    by its use, the `ChoosePathString()` method can be carefully used in projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, the ink `progress` knot was introduced. To choose
    this path string in Unity using the `ChoosePathString()` method, only its name
    is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When the `ChoosePathString()` method is used with the `progress` ink knot, it
    *does* disrupt the flow of the story that's kept within the `InkStory` C# variable.
    However, as we learned, the values of variables are maintained throughout the
    story because of their global nature. The use of the `progress` ink knot *progresses*
    the quest to its next step by updating the variables each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code also includes calls to two other methods: `FlipProgress()` and `UpdateContent()`.
    The first method sets a `Button` game object in Unity to inactive by using the
    `SetActive()` method in Unity. When a game object is turned off (set to inactive)
    in Unity, it does not appear on the screen. This code effectively sets the game
    object to appear as needed and to disappear when the player is selecting dialogue
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method, `UpdateContent()`, follows the pattern we first introduced
    in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106), *Unity API –
    Making Choices and Story Progression*, where a `Prefab` is used to dynamically
    create `Button` game objects as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to create a template for quests in ink. Using
    a knot and then individual stitches for each step, the parts were divided into
    different sections. Next, we looked at the `progress` ink knot. After that, we
    looked at Unity and using the `ChoosePathString()` method. While it can be potentially
    dangerous with larger projects using more advanced techniques, using variables
    in the ink quest template helped maintain their values. Finally, at the end of
    this section, the `ChoosePathString()` method in Unity was paired with the `progress`
    knot in ink. By using this knot, the Unity code could *progress* the quest, with
    ink updating its internal variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will continue with the pattern we looked at in this
    section by extending part of the quest template in ink and creating `Quest` and
    `Dialogue` classes in C#. These will allow us to track multiple quests at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking progress across multiple quests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created an ink template for a quest and then moved
    into Unity to create the user interface to progress the quest using the `ChoosePathString()`
    method. This forced the flow within ink to move to a specific location. In this
    section, we move beyond a single quest and start tracking multiple quests at the
    same time. To do this, the ink template needs additional variables. For this,
    we will need the `Quest` and `Dialogue` classes in C#. We also will depart from
    using a single ink file and start using multiple files. For every quest, we will
    create a separate file and use the `Quest` class to track the progress of each
    in Unity with the `Dialogue` class, which handles creating options for a player
    to choose from during each step in the quest.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will update the ink template with a new variable we will access later
    in Unity. Then, we will create the `Quest` and `Dialogue` classes in Unity. After
    that, we will access multiple ink files in Unity to present an interface containing
    multiple quests. Finally, we will allow a user to toggle between quests and progress
    them independently of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)
    *examples on GitHub* folder, under the name *Chapter11-MultipleQuests*. Only select
    parts of the code will be shown as they relate to the concepts examined in the
    sections of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the ink quest template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123),
    *Story API – Accessing ink Variables and Functions*, we can access ink variables
    that have been created with the `VAR` keyword using the `variablesState` property
    in Unity. This allows us to retrieve the value of a variable based on its name.
    With that in mind, the existing ink template can be expanded to include a new
    variable for each quest – its `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By understanding that the compiled ink files will be operated from Unity, we
    can anticipate certain needs we will have with quests. For example, a quest usually
    has a *name*. We can then define this variable alongside our existing values in
    Ink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know that the `name` variable exists in ink, we can read it in Unity.
    However, unlike what was shown in the previously section, we will need to observe
    the `end` ink variable as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These small changes may not seem important, but by establishing a pattern where
    certain variables exist (`name` and `end`) and all files containing quests will
    also have a knot named `progress` (as defined in the previous section), we can
    write any quests we want if those parts remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Once these variables have been prepared, we can start creating the `Quest` and
    `Dialogue` classes, which will hold the values we defined in ink and read them
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Making Quest and Dialogue classes in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we combined a simple presentation of dialogue options
    with the values and methods to progress the single quest presented. In this section,
    we will break that functionality into two new classes in Unity: `Quest` and `Dialogue`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the `Quest` class was shown in the previous section. However, its purpose
    is to hold a `Story` object and to expose a method named `Progress()` that internally
    calls the `ChoosePathString()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Quest` class is small because it is used by other classes. Its sole purpose
    is to contain the quest (ink story) and provide a way to progress the quest (via
    the `Progress()` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'The new class, `Dialogue`, performs most of the work to create the `Button`
    game objects needed and to remember what the last line of dialogue was as a reminder
    for the player. Its `UpdateContent()` method looks like the example code that
    was first shown in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106),
    *Unity API – Making Choices and Story Progression*, except for using the new `Quest`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the updated ink template from the first section and the introduction of
    the `Quest` and `Dialogue` classes in this section, two more parts are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Quests need to be based on compiled JSON files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Players need to be able to toggle which quest they are progressing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will start with the first part by learning how to read
    files and creating a new `Quest` class per file found.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing multiple quest files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples in this book, a single ink file was used per project.
    This section will break away from that pattern. To track multiple quests, we will
    define each quest in its own file and then read the compiled JSON files. The `Quest`
    class, which we looked at in the previous section, will hold the contents and
    expose some of the values in each file. The `Dialogue` class will create the options
    the player will see based on the `Quest` class's values. First, however, we will
    need to read the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book follows the recommended naming convention of Unity folders and has
    placed all the Ink files in a folder named `Ink`. Using the **Compile All Ink
    Automatically** option in the **Project Settings** window, each created ink file
    will also contain a JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Compiled JSON files in the Ink folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Compiled JSON files in the Ink folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Unity can run on many different operating systems, it exposes the `Assets`
    folder (shown in the `Application.dataPath`. This is the *path* to the data, as
    part of the currently running application. Based on this value, any additional
    folders can be found, and their files can be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By using the `Application.dataPath` property, each compiled ink file (JSON file)
    can be read, and a new object based on the `Quest` class is created. This not
    only allows each quest to operate independently of each other via their quest
    progression, but it also exposes values that the `Dialogue` class can use to present
    different options to the player.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final section, we will write some code that will allow a player
    to toggle between which quest is active for them and see the `Quest` and `Dialogue`
    classes in action.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling quests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unity, the `Toggle` game object allows a user to select a single item among
    a group of items. For its usage in the project that''s part of this section, a
    `Toggle` prefab must be created. Like the usage of `Button` game objects, these
    are created as needed. As each `Toggle` game object is based on an object using
    the `Quest` class, this means the `GetFiles()` method (shown in the previous section,
    *Organizing multiple quest files*) is run first, and the resulting quests are
    used to make the `Toggle` game objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateQuestToggles()` method references a component named `ToggleScript`.
    This is a `Script` component that is part of each `Toggle` prefab. Each time one
    is created, its values are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This process, starting with the `GetFiles()` method, creates objects based
    on the `Quest` class first. Next, `Toggle` prefabs are created, and values are
    passed to its `Script` component. Internally, the `Toggle` prefab creates an additional
    `Script` component based on the `Dialogue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this multiple-step process of creating objects based on the
    `Quest` class, and then leading to the `Dialogue` class, is to allow each `Toggle`
    prefab to control what is shown to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Quest selection and options shown to the player'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Quest selection and options shown to the player
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking on a `Toggle` prefab, its object is enabled based on the `Dialogue`
    class, showing the current text and options to the player. These, in turn, are
    based on the `Quest` class's values, as passed to the `Dialogue` class.
  prefs: []
  type: TYPE_NORMAL
- en: The combined effect of the code is to create separate quests. Depending on which
    is active, as determined by each `Toggle` prefab selected by the player, they
    will see different dialogue options and be presented with the ability to progress
    each quest independently of each other at the end of each step. This combines
    the ink template that we created in the first section with a multiple-quest approach,
    as shown in this section, which uses multiple files and adds the ability to progress
    across individual quests, independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine how to award player progression by passing
    information between quests. This will build on the project we created for this
    section and the concepts from the first section.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and awarding player progression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming, there are two approaches to accessing values in one system
    from another: **polling** and **events-based**. Either a value can be checked
    if it has changed (*polling*) or one system can wait for a message (*event*) from
    the other to signal that a value has changed. Because the second system must wait
    for an event to happen, this is often known as the **observer pattern** because
    the second system is *observing* events.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we saw an example of polling in action. Each time a step
    of the quest came to its end, the Unity code checked (*polled*) the ink values
    to see if it should show a `Button` game object and allow the player to progress
    the quest. The second section moved us closer to an events-based approach, where
    the `ObserveVariable()` method was used within the `Quest` class. In the second
    project, whenever the `end` ink variable changed, it updated the `End` property
    of the `Quest` class in Unity. As this value (the `End` property) was used as
    part of determining whether the quest could progress, this made the second project
    more dynamic than the one that was used in the first project.
  prefs: []
  type: TYPE_NORMAL
- en: To award a player for completing a quest or achieving some outcome as part of
    one quest in another, information needs to be passed between them. Because the
    ink runtime already supports an events-based approach via its `ObserveVariable()`
    and `ObserveVariables()` named methods, this makes the process slightly easier.
    However, as we introduced in the previous section, using a `Quest` class means
    each ink story is now independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will start by creating a way for each `Quest` class to share
    changes as they happen while a player is progressing them. We will end by learning
    how to show the player this information as they complete different quests.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)
    *examples on GitHub* folder, under the name *Chapter11-TrackingQuests*. Only select
    parts of the code will be shown as they relate to the concepts examined in the
    sections of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking quest values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Story` class method, `ObserveVariables()`, can track different variables
    based on their names. However, the existing ink template contains the variables
    it uses to track progression. This means that the first step of tracking quest
    values is to make a list of variables to exclude from tracking as part of an expanded
    `Quest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, all the variables contained in the `variablesState` property, excluding
    those in the created list used to track quest progression, need to be tracked.
    This means that for each variable, it can be added to a separate list to be passed
    to the `Story` method known as `ObserveVariables()`. This can be part of the `ObserveVariables()`
    method, as part of the `Quest` method, so that it matches the one on the `Story`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The new `ObserveVariables()` method that was added to the `Quest` class accepts
    a single parameter, `Story.VariableObserver`. Internally, the `Story` class defines
    a `delegate` method called `VariableObserver`. Using the same type for the new
    method allows other methods to be passed through the `Quest` method to the `Story`
    method of the same name. In other words, the new method works the same as the
    existing one, but it will exclude a specific list of variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'While observing variables, there also needs to be a way to update the values
    of variables across all quests whenever a value changes in one. Using the existing
    `variablesState` property, a new method can be added to the `Quest` class named
    `UpdateVariable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `UpdateVariable()` method are two important checks. The first uses
    the `GlobalVariableExistsWithName()` method. This method checks if a variable
    exists. Without this check, if one quest added a variable another did not have,
    the entire project could crash. The second check verifies whether the variable
    to be updated does not already have the same value. Without this second check,
    updating a variable would trigger a variable change in any other quests, which
    would trigger another update. This would eventually cause a crash as quests would
    be trying to update each other in an endless loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Between the two new methods, `ObserveVariables()` and `UpdateVariable()`, one
    more part is needed: the two methods must be combined. Based on the project from
    the second section, *Tracking progress across multiple quests*, the `InkStoryScript`
    code is the best place to add this combination. The reason for this placement
    is because this will allow each quest to be configured as part of the existing
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This new code references an additional method, `UpdateAllQuests()`. When passed
    the name of a variable and its value, this new method works through the existing
    quests and updates their values by calling `UpdateVariable()` per quest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have defined multiple new methods. We added two to the `Quest`
    class called `ObserveVariables()` and `UpdateVariable()`. These detect changes
    using the event approach. ink will signal to Unity when a variable in one of the
    quests changes. We also added code to `InkStoryScript` by using a new method called
    `UpdateAllQuests()`, which will update the same variable in other quests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will finalize this project. Detecting changes and updating
    other quests help keep all of them updated as changes happen. Next, we need to
    show data to the player as changes happen.
  prefs: []
  type: TYPE_NORMAL
- en: Showing player progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we created the necessary code to keep all the variables
    used across quests updated. To show the player this data, we must add a new game
    object named `StatisticsText`. Next, we need to use a special keyword in C#: `static`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any method or property using the `static` keyword in C# exists outside of any
    instances of the class. This means that the property can be accessed or the method
    can be called anywhere in the project. However, this comes with a major caveat:
    any `static` method can only access `static` properties. To allow another class
    (`Dialogue`) to be able to call a `static` method in `InkStoryScript` (which holds
    all the quests), the existing `quests` and new `StatisticsText` variable must
    both use the `static` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `quests` and `StatisticsText` properties, they can be accessed by
    a new method named `ShowStatistics()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `ShowStatistics()` method uses a `Dictionary<string, object>`. This
    combines the name of the variable (`string`) with its value (`object`). However,
    a `Dictionary` in C# comes with an obstacle: it can only contain unique keys.
    In the `ShowStatistics()` method, the use of the `ContainsKey()` method prevents
    this issue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a method that can be called by another class, the new `ShowStatistics()`code
    must be placed within the `Dialogue` class as part of its `UpdateContent()` method,
    after the creation of the `Button` game objects based on the current choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The new code will always show the latest values of the variables as the values
    are updated. Because each quest handles updating its variables based on an event-based
    approach, any user action for making choices or selecting a quest will update
    all the values being tracked by the project and constantly show player progression.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we awarded player progression by showing the player's the updated
    values. We started by adding some code from the previous section to constantly
    update the variables with the same names across all quests. This keeps all the
    quests connected. Then, we created a `ShowStatistics()` method to show these values
    and updated a `Text` game object with their names and values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by creating an ink template. By defining variables and
    a `progress` knot in ink, we can move through the various sections of a quest
    as individual stitches within a larger knot. Next, we looked at the `ChoosePathString()`
    method, which can forcibly move a story to a new section.
  prefs: []
  type: TYPE_NORMAL
- en: In the second section, we broke away from single files and developed a `Quest`
    class. Each object based on the `Quest` class contained an ink `Story` object
    based on different files and a method named `Progress()`, which calls the `ChoosePathString()`
    method internally. As part of this section, we learned how the `Quest` and `Dialogue`
    classes can help organize functionality into different classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we displayed the name and values of variables. First, we added new
    methods to detect variable changes in any quest using an events-based approach.
    This triggered other variables with the same name in other quests to have their
    values updated. Then, we added the `ShowStatistics()` method to display these
    updating values.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 12*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174),
    *Procedural Storytelling with ink*, we will review the basics of procedurally
    organizing different story sections and content. While looking at two approaches,
    either coding values in ink or loading data into ink dynamically, we will examine
    when one approach might be better, depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: Q&A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a quest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the knot that's used to progress a quest based on the ink
    template shown in this chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `ChoosePathString()` method work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the global property where Unity records the path for the
    data of the application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between polling and events-based approaches?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
