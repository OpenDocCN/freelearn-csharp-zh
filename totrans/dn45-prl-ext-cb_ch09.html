<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>9. Dataflow Library</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;9.&#160;Dataflow Library">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09"></a>Chapter&#160;9.&#160;Dataflow Library</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will cover the following recipes:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Reading from and writing to a dataflow block synchronously</li>
            <li class="listitem" style="list-style-type: disc">Reading from and writing to a dataflow block asynchronously</li>
            <li class="listitem" style="list-style-type: disc">Implementing a producer-consumer dataflow pattern</li>
            <li class="listitem" style="list-style-type: disc">Creating a dataflow pipeline</li>
            <li class="listitem" style="list-style-type: disc">Cancelling a dataflow block</li>
            <li class="listitem" style="list-style-type: disc">Specifying the degree of parallelism</li>
            <li class="listitem" style="list-style-type: disc">Unlink dataflow blocks</li>
            <li class="listitem" style="list-style-type: disc">Using <code class="literal">JoinBlock</code> to read from multiple data sources</li>
          </ul>
        </div>
        <div class="section" title="Introduction">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title" id="sigil_toc_id_11"><a id="ch09lvl1sec88"></a>Introduction</h1>
              </div>
            </div>
          </div>
          <p>The Task Parallel Library's dataflow is a new library that is designed to increase the robustness of highly concurrent applications. TPL dataflow uses asynchronous message passing and pipelining to obtain more control and better performance than manual threading.</p>
          <p>A dataflow<a id="id628" class="indexterm"></a> consists of a series of blocks. Each block can be a source or target for data. Data typically enters into a dataflow by being posted to a propagation block, which is a block that implements <code class="literal">ISourceBlock&lt;T&gt;</code> and <code class="literal">ITargetBlock&lt;T&gt;</code>. The source block can be linked to other target or propagation blocks. The data flows from one block to the next block in the chain asynchronously. The data is buffered at the source or target block until it is needed.</p>
          <p>The predefined blocks fall into three categories. There are <a id="id629" class="indexterm"></a>buffering blocks which hold data for use by data consumers, there are execution blocks <a id="id630" class="indexterm"></a>that call a user-provided delegate for each piece of received data, and there are grouping blocks which combine data from one or more sources and under various constraints.</p>
          <p>The TPL dataflow library provides three types of buffering blocks. There is the <code class="literal">System.Threading.Tasks.Dataflow.BufferBlock&lt;T&gt;</code> class, the <code class="literal">System.Threading.Tasks.Dataflow.BroadcastBlock&lt;T&gt;</code> class, and the <code class="literal">System.Threading.Tasks.Dataflow.WriteOnceBlock&lt;T&gt;</code> class. The <code class="literal">BufferBlock&lt;T&gt;</code> class is a general-purpose asynchronous messaging class. <code class="literal">BufferBlock&lt;T&gt;</code> stores a <span class="strong"><strong>First-In- First-Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>)<a id="id631" class="indexterm"></a> queue of messages that can be written to by multiple sources or read from by multiple targets.</p>
          <p>The <code class="literal">BroadcastBlock&lt;T&gt;</code> class<a id="id632" class="indexterm"></a> is useful when you pass multiple messages to another component, or a message to multiple components.</p>
          <p>The <code class="literal">WriteOnceBlock&lt;T&gt;</code> class<a id="id633" class="indexterm"></a> is similar the <code class="literal">BroadcastBlock&lt;T&gt;</code> class, except that a <code class="literal">WriteOnceBlock&lt;T&gt;</code> object can be written one time only.</p>
          <p>The TPL dataflow library provides three types of execution blocks. There is the <code class="literal">ActionBlock&lt;TInput&gt;</code> class, the <code class="literal">System.Threading.Tasks.Dataflow.TransformBlock&lt;TInput, TOutput&gt;</code> class, and the <code class="literal">System.Threading.Tasks.Dataflow.TransformManyBlock&lt;TInput, TOutput&gt;</code> class.</p>
          <p>The <code class="literal">ActionBlock&lt;TInput&gt;</code> class<a id="id634" class="indexterm"></a> is a target block that calls a delegate when it receives data. You can think of a <code class="literal">ActionBlock&lt;TInput&gt;</code> object as a delegate that runs asynchronously when data becomes available.</p>
          <p>The <code class="literal">TransformBlock&lt;TInput, TOutput&gt;</code> class<a id="id635" class="indexterm"></a> resembles the <code class="literal">ActionBlock&lt;TInput&gt;</code> class, except that it acts both as a source and as a target.</p>
          <p>The <code class="literal">TransformManyBlock&lt;TInput, TOutput&gt; </code>class<a id="id636" class="indexterm"></a> resembles the <code class="literal">TransformBlock&lt;TInput,</code> <code class="literal">TOutput&gt;</code> class<a id="id637" class="indexterm"></a>, except that <code class="literal">TransformManyBlock&lt;TInput, TOutput&gt;</code> produces zero or more output values for each input value, instead of only one output value for each input value.</p>
          <p>The TPL dataflow library also provides three types of join blocks. There is the <code class="literal">BatchBlock&lt;T&gt;</code> class, the <code class="literal">JoinBlock&lt;T1, T2&gt;</code> class, and the <code class="literal">BatchedJoinBlock&lt;T1, T2&gt;</code> class.<a id="id638" class="indexterm"></a>
</p>
          <p>The <code class="literal">BatchBlock&lt;T&gt;</code> class <a id="id639" class="indexterm"></a>combines sets of input data, which are known as batches, into arrays of output data.</p>
          <p>The <code class="literal">JoinBlock&lt;T1, T2&gt;</code> and <code class="literal">JoinBlock&lt;T1, T2, T3&gt;</code> classes collect input elements and propagate out <code class="literal">System.Tuple&lt;T1, T2&gt;</code> or <code class="literal">System.Tuple&lt;T1, T2, T3&gt;</code> objects that contain those elements.</p>
          <p>The <code class="literal">BatchedJoinBlock&lt;T1, T2&gt;</code> and <code class="literal">BatchedJoinBlock&lt;T1, T2, T3&gt;</code> classes collect batches of input elements and propagate out the <code class="literal">System.Tuple(IList(T1), IList(T2))</code> or <code class="literal">System.Tuple(IList(T1), IList(T2), IList(T3))</code> objects that contain those elements.</p>
          <p>The Dataflow library's infrastructure is built on .NET 4.5's Task Parallel Library. These dataflow components are useful when you have multiple operations that must communicate with one another asynchronously or when you want to process data as it becomes available.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Reading from and writing to a dataflow block synchronously">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec89"></a>Reading from and writing to a dataflow block synchronously</h1>
            </div>
          </div>
        </div>
        <p>Writing a message synchronously to a dataflow block is done by calling the <code class="literal">Post&lt;TInput&gt;</code> method of a block. Let's use the <code class="literal">Receive</code> method of the block to receive data.</p>
        <p>In this recipe, we are <a id="id640" class="indexterm"></a>going to create a <code class="literal">Console</code> application that uses a <code class="literal">for</code> loop to synchronously write some numbers to <code class="literal">BufferBlock</code> using<a id="id641" class="indexterm"></a> the <code class="literal">Post</code> method. The application then reads the data back from <code class="literal">BufferBlock</code> using the <code class="literal">Receive</code> method and writes the data to <code class="literal">Console</code>.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec159"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>The TPL dataflow library doesn't ship with the rest of the TPL. To use the TPL dataflow library in your solutions, you need to use NuGet Package Manager to set your reference.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">After creating your new project in Visual Studio 2012, go to the <span class="strong"><strong>Solution</strong></span> <span class="strong"><strong>Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, and click on <span class="strong"><strong>Manage</strong></span> <span class="strong"><strong>NuGet</strong></span> <span class="strong"><strong>Package</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_09_01.jpg" alt="Getting ready…"/></div></li>
              <li class="listitem">In the NuGet<a id="id642" class="indexterm"></a> Package Manager<a id="id643" class="indexterm"></a> window, click on <span class="strong"><strong>Online</strong></span> from the menu on the left and search for <span class="strong"><strong>TPL Dataflow</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_09_02.jpg" alt="Getting ready…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec160"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's create a new <code class="literal">Console</code>
<a id="id644" class="indexterm"></a> application so we can<a id="id645" class="indexterm"></a> see how to create a dataflow block and write to it synchronously.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">Dataflow ReadingWriting</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGetPackages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks.Dataflow;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of the <code class="literal">Program</code> class, create a <code class="literal">BufferBlock&lt;int&gt;</code> object.<div class="informalexample"><pre class="programlisting">var bufferingBlock = new BufferBlock&lt;int&gt;();</pre>
</div></li>
              <li class="listitem">Now let's create a <code class="literal">for</code> loop that loops from zero to ten and writes the square of the loop index to the buffer block using the <code class="literal">Post</code> method.<div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 10; i++)
{
  bufferingBlock.Post(i*i);
}</pre>
</div></li>
              <li class="listitem">Now, let's create another <code class="literal">for</code> loop that loops from zero to ten that calls the <code class="literal">Receive</code> method on the buffer block for each iteration, and writes the results to <code class="literal">Console</code>.<div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; 10; i++)
{
  Console.WriteLine(bufferingBlock.Receive.ToString());
}</pre>
</div></li>
              <li class="listitem">Finish up by<a id="id646" class="indexterm"></a> writing a<a id="id647" class="indexterm"></a> message to the <code class="literal">Console</code> application and waiting for user input before exiting.<div class="informalexample"><pre class="programlisting">Console.WriteLine("Finished. Press any key to exit.");
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button, and your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_03.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec161"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This simple example shows how to read from and write to a message block directly. More often, you will <a id="id648" class="indexterm"></a>be connecting dataflow blocks to form pipelines, or linear sequences of blocks.</p>
          <p>Writing to a block<a id="id649" class="indexterm"></a> directly is a pretty easy matter; you just need to call the <code class="literal">Post&lt;TInput&gt;</code> method.</p>
          <div class="informalexample">
            <pre class="programlisting">bufferingBlock.Post(i*i);</pre>
          </div>
          <p>The <code class="literal">Post</code> method acts synchronously, and returns once the target block has decided to accept or reject the item.</p>
          <p>Conversely, data can be directly received from <code class="literal">bufferingBlock</code> by calling the <code class="literal">Receive</code> method.</p>
          <div class="informalexample">
            <pre class="programlisting">bufferingBlock.Receive()</pre>
          </div>
          <p>The <code class="literal">Receive</code> method has a few convenient overloads that can accept a time out period, <code class="literal">CancellationToken</code> or both.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Reading from and writing to a dataflow block asynchronously">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec90"></a>Reading from and writing to a dataflow block asynchronously</h1>
            </div>
          </div>
        </div>
        <p>Writing a message <a id="id650" class="indexterm"></a>asynchronously to a dataflow block is done by calling the <code class="literal">SendAsync&lt;TInput&gt;</code> method of a block. <a id="id651" class="indexterm"></a>You use the <code class="literal">ReceiveAsync</code> method of the block to receive data.</p>
        <p>In this recipe, we are going to create a <code class="literal">Console</code> application that uses a <code class="literal">for</code> loop to asynchronously write some numbers to <code class="literal">BufferBlock</code> using the <code class="literal">SendAsync</code> method. The application then reads the data back from <code class="literal">BufferBlock</code> using the <code class="literal">ReceiveAsync</code> method and writes the data to <code class="literal">Console</code>.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec162"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">Dataflow ReadWriteAsync</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to <span class="strong"><strong>Solution</strong></span> <span class="strong"><strong>Explorer</strong></span>, right-click on <span class="strong"><strong>references</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span> and add a reference to the TPL Dataflow library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks.Dataflow;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">Now let's create a <code class="literal">static async</code> method that returns <code class="literal">Task</code> called <code class="literal">WriteDataAsync</code>. The method takes a <code class="literal">BufferBlock&lt;int&gt;</code> parameter, and uses a <code class="literal">for</code> loop to iterate<a id="id652" class="indexterm"></a> from zero to ten. In each iteration of the loop, we need to use the <code class="literal">SendAsync</code> method<a id="id653" class="indexterm"></a> to write the square of the loop indexer to <code class="literal">bufferingBlock</code>.<div class="informalexample"><pre class="programlisting">private static async Task WriteDataAsync(BufferBlock&lt;int&gt; bufferingBlock)
{
  // Post some messages to the block. 
  for (int i = 0; i &lt; 10; i++)
  {
    await bufferingBlock.SendAsync(i * i);
  }
}</pre>
</div></li>
              <li class="listitem">Next, let's create a <code class="literal">static async</code> method<a id="id654" class="indexterm"></a> that returns <code class="literal">Task</code> called <code class="literal">ReadDataAsync</code>. The method takes a <code class="literal">BufferBlock&lt;int&gt;</code> parameter, and uses a <code class="literal">for</code> loop to read the data from <code class="literal">BufferBlock</code> and display it to <code class="literal">Console</code>.<div class="informalexample"><pre class="programlisting">private static async Task ReadDataAsync(BufferBlock&lt;int&gt; bufferingBlock)
{
  // Receive the messages back . 
  for (int i = 0; i &lt; 10; i++)
  {
    Console.WriteLine(await bufferingBlock.ReceiveAsync());
  }
}</pre>
</div></li>
              <li class="listitem">Finally, let's create the implementation of the <code class="literal">Main</code> method. Here we just need to wait on calls to <code class="literal">WriteDataAsync</code> and <code class="literal">ReadDataAsync</code>. We also need to wait on user input before exiting.<div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  // Create a BufferBlock object. 
  var bufferingBlock = new BufferBlock&lt;int&gt;();
  WriteDataAsync(bufferingBlock).Wait();
  ReadDataAsync(bufferingBlock).Wait();

  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre>
</div></li>
              <li class="listitem">Now, in Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Click on the <span class="strong"><strong>Start</strong></span> button. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_04.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec163"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This application uses the <code class="literal">SendAsync</code> method<a id="id655" class="indexterm"></a> to asynchronously write to a <code class="literal">BufferBlock&lt;int&gt;</code> object and the <code class="literal">ReceiveAsync</code> method to read from the<a id="id656" class="indexterm"></a> same object. We also use the <code class="literal">async</code> and <code class="literal">await</code> operators to send data to and read data from the target block.</p>
          <p>Notice that both the <a id="id657" class="indexterm"></a>
<code class="literal">ReadDataAsync</code> and <code class="literal">WriteDataAsync</code> methods<a id="id658" class="indexterm"></a> are marked as <code class="literal">async</code>, with a return type of <code class="literal">Task</code>. We use the <code class="literal">await</code> keyword to asynchronously make the call to <code class="literal">SendAsync</code> and <code class="literal">ReceiveAsync</code>.</p>
          <div class="informalexample">
            <pre class="programlisting">private static async Task ReadDataAsync(BufferBlock&lt;int&gt; bufferingBlock)
{            
  for (int i = 0; i &lt; 10; i++)
  {
    Console.WriteLine(await bufferingBlock.ReceiveAsync());
  }
}</pre>
          </div>
          <p>The <code class="literal">ReceiveAsync</code> method <a id="id659" class="indexterm"></a>is especially useful when you want to act on data as the data becomes available.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Implementing a producer-consumer dataflow pattern">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec91"></a>Implementing a producer-consumer dataflow pattern</h1>
            </div>
          </div>
        </div>
        <p>TPL dataflow blocks can also be used in a producer-consumer pattern, where a producer sends messages to a block, and the consumer reads messages from a block.</p>
        <p>In this recipe, we are going<a id="id660" class="indexterm"></a> to create a <code class="literal">Console</code> application to demonstrate a basic producer-consumer pattern that uses dataflow. The producer will use a <code class="literal">for</code> loop to create some random numbers and add them to <code class="literal">BufferBlock&lt;int&gt;</code>. The consumer task will asynchronously receive the data from <code class="literal">BufferBlock</code> as it becomes available, and returns a sum of all the numbers.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec164"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's create another <code class="literal">Console</code>
<a id="id661" class="indexterm"></a> application and see how we can use dataflow blocks to implement a producer-consumer pattern.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">Dataflow ProducerConsumer</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class.<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks.Dataflow;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class called <code class="literal">Produce</code>. This method returns <code class="literal">void</code>, and takes a parameter of type <code class="literal">ITargetBlock&lt;int&gt;</code>. This method will use a <code class="literal">for</code> loop to generate random numbers, and then use the <code class="literal">Post</code> method to send them to the block. When the <code class="literal">Produce</code> method is finished adding, it calls the <code class="literal">Complete</code> method on the block.<div class="informalexample"><pre class="programlisting">static void Produce(ITargetBlock&lt;int&gt; target)
{
  // Create a Random object.
  Random rand = new Random();

  // fill a buffer with random data  
  for (int i = 0; i &lt; 100; i++)
  {
    // get the next random number 
    int number = rand.Next();

    // Post the result .
    target.Post(number);
  }

  // Set the target to the completed state
  target.Complete();
}</pre>
</div></li>
              <li class="listitem">Next, let's create a method called <code class="literal">ConsumeAsync</code>. As you probably guessed from the method<a id="id662" class="indexterm"></a> name, this is an <code class="literal">async</code> method that returns <code class="literal">Task&lt;int&gt;</code>.The <code class="literal">ConsumeAsync</code> method<a id="id663" class="indexterm"></a> needs a parameter type of <code class="literal">ISourceBlock&lt;int&gt;</code>. This method used a <code class="literal">while</code> loop to get data from the block as it becomes available, and produces a sum of the numbers.<div class="informalexample"><pre class="programlisting">static async Task&lt;int&gt; ConsumeAsync(ISourceBlock&lt;int&gt; source)
{
  // Initialize a counter to track the sum. 
  int sumOfProcessed = 0;

  // Read from the source buffer until empty
  while (await source.OutputAvailableAsync())
  {
    int data = source.Receive();

    // calculate the sum.
    sumOfProcessed += data;
  }

  return sumOfProcessed;
}</pre>
</div></li>
              <li class="listitem">Ok, let's finish up by implementing the <code class="literal">Main</code> method<a id="id664" class="indexterm"></a> of the <code class="literal">Program</code> class. This method just needs to start <code class="literal">producer</code> and <code class="literal">consumer</code>, and display the results when finished.<div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{  
  var buffer = new BufferBlock&lt;int&gt;();

  // Start the consumer.   
  var consumer = ConsumeAsync(buffer);

  // Post source data.
  Produce(buffer);

  // Wait for the consumer to process data.
  consumer.Wait();

  // Print the count of bytes processed to the console.
  Console.WriteLine("Sum of processed numbers: {0}.", consumer.Result);
  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre>
</div></li>
              <li class="listitem">In Visual Studio <a id="id665" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_05.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec165"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">Produce</code> method is very straightforward. We declared a parameter of the interface type <code class="literal">ITargetBlock&lt;TInput&gt;</code>. <code class="literal">ITargetBlock</code> is an interface implemented by <code class="literal">BufferBlock</code> that represents a dataflow block that is a target for data.</p>
          <p>The <code class="literal">Produce</code> method just uses a <code class="literal">for</code> loop to send data to the target block using the <code class="literal">Post</code> method. After it is finished adding the data, it calls the complete method to signal that it is finished.</p>
          <div class="informalexample">
            <pre class="programlisting">static void Produce(ITargetBlock&lt;int&gt; target)
{
  ... 
  for (int i = 0; i &lt; 100; i++)
  {
    ...
    target.Post(number);
  }.
  target.Complete();
}</pre>
          </div>
          <p>
<code class="literal">ConsumeAsync</code> accepts a parameter of the interface type <code class="literal">ISourceBlock</code>, which represents a dataflow<a id="id666" class="indexterm"></a> block that is a source of data. To act asynchronously, the <code class="literal">ConsumeAsync</code> method calls the <code class="literal">OutputAvailiableAsync</code> method<a id="id667" class="indexterm"></a> to receive a notification when the source block has data available when the source block is finished, and will never have additional data. Other than that, it just uses the <code class="literal">Receive</code> method to receive the data and sums up the results.</p>
          <div class="informalexample">
            <pre class="programlisting">static async Task&lt;int&gt; ConsumeAsync(ISourceBlock&lt;int&gt; source)
{
  ...
  while (await source.OutputAvailableAsync())
  {
    int data = source.Receive();
      sumOfProcessed += data;
  }
  return sumOfProcessed;
}</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating a dataflow pipeline">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec92"></a>Creating a dataflow pipeline</h1>
            </div>
          </div>
        </div>
        <p>As we have seen so far, you can use <code class="literal">Post</code>, <code class="literal">Receive</code>, and <code class="literal">RecieveAsync</code> to send and receive messages from source blocks. You can also connect message blocks to form a dataflow pipeline. A dataflow<a id="id668" class="indexterm"></a> pipeline is a chain of dataflow blocks, each of which performs a specific task and contributes to a larger goal. Each block in the pipeline performs its work when it receives a message from another dataflow block.</p>
        <p>In this recipe, we are to return to our WordCount example one final time. We are going to create a <code class="literal">Console</code> application that forms a dataflow pipeline for downloading the contents of a classic book, filters out the small words from the book contents, and returns a count of the words.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec166"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how<a id="id669" class="indexterm"></a> we can chain dataflow blocks together to form a pipeline.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">DataflowPipeline</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading.Tasks.Dataflow;
using System.Net;</pre>
</div></li>
              <li class="listitem">The first step is to create the dataflow blocks that participate in the pipeline. In the <code class="literal">Main</code> method, create <code class="literal">TransformBlock&lt;string,string&gt;</code> that takes the string input parameter and uses <code class="literal">WebClient</code> to download the book contents as a string.<div class="informalexample"><pre class="programlisting">// Download a book as a string
var downloadBook = new TransformBlock&lt;string, string&gt;(url =&gt;
{
  Console.WriteLine("Downloading the book...");

  return new WebClient().DownloadString(url);
});</pre>
</div></li>
              <li class="listitem">Next, let's add <code class="literal">TransformBlock&lt;string, string[]&gt;</code> which receives the output from the previous block, removes the spaces, and splits the words into a string array.<div class="informalexample"><pre class="programlisting">// splits text into an array of strings. 
var createWordList = new TransformBlock&lt;string, string[]&gt;(text =&gt;
{
  Console.WriteLine("Creating list of words...");

  // Remove punctuation  
  char[] tokens = text.ToArray();
  for (int i = 0; i &lt; tokens.Length; i++)
  {
    if (!char.IsLetter(tokens[i]))
      tokens[i] = ' ';
  }
  text = new string(tokens);

  return text.Split(new char[] { ' ' },
     StringSplitOptions.RemoveEmptyEntries);
});</pre>
</div></li>
              <li class="listitem">Ok, let's create <code class="literal">TransformBlock&lt;string[],int&gt;</code> that filters out words less than three <a id="id670" class="indexterm"></a>characters and returns a count of the words.<div class="informalexample"><pre class="programlisting">// Remove short words and return the count 
var filterWordList = new TransformBlock&lt;string[], int&gt;(words =&gt;
{
  Console.WriteLine("Counting words...");

  var wordList = words.Where(word =&gt; word.Length &gt; 3).OrderBy(word =&gt; word)
     .Distinct().ToArray();
  return wordList.Count();
});</pre>
</div></li>
              <li class="listitem">Finally, let's create <code class="literal">ActionBlock&lt;int&gt;</code> to display the word count to <code class="literal">Console</code>.<div class="informalexample"><pre class="programlisting">var printWordCount = new ActionBlock&lt;int&gt;(wordcount =&gt;
{
  Console.WriteLine("Found {0} words",
     wordcount);
});</pre>
</div></li>
              <li class="listitem">Now, let's use the <code class="literal">LinkTo</code> method to connect the source blocks and target blocks to form the pipeline.<div class="informalexample"><pre class="programlisting">downloadBook.LinkTo(createWordList);
createWordList.LinkTo(filterWordList);
filterWordList.LinkTo(printWordCount);</pre>
</div></li>
              <li class="listitem">Next, we need to add some completion tasks to enable each dataflow block to perform a final action after processing all data elements.<div class="informalexample"><pre class="programlisting">downloadBook.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)createWordList).Fault(t.Exception);
  else createWordList.Complete();
});
createWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)filterWordList).Fault(t.Exception);
  else filterWordList.Complete();
});
filterWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)printWordCount).Fault(t.Exception);
  else printWordCount.Complete();
});</pre>
</div></li>
              <li class="listitem">Finally, let's add some code to <code class="literal">Main</code> to post the data to the pipeline, complete the pipeline<a id="id671" class="indexterm"></a> activity, wait for the pipeline to finish, and wait for user input before exiting.<div class="informalexample"><pre class="programlisting">// Download Origin of Species
downloadBook.Post("http://www.gutenberg.org/files/2009/2009.txt");

// Mark the head of the pipeline as complete. 
downloadBook.Complete();

printWordCount.Completion.Wait();

Console.WriteLine("Finished. Press any key to exit.");
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should display the output as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_06.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec167"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this application we used <code class="literal">TransformBlock&lt;TInput, TOutput&gt;</code> to enable each member of the pipeline to perform an operation on its input data and send the results to the next step in the<a id="id672" class="indexterm"></a> pipeline. For example, <code class="literal">downloadBook TransformBlock</code> takes a string input and returns a string output to the next step.</p>
          <div class="informalexample">
            <pre class="programlisting">var downloadBook = new TransformBlock&lt;string, string&gt;(uri =&gt;
{
  ...
  return new WebClient().DownloadString(uri);
});</pre>
          </div>
          <p>The only exception is the tail of the pipeline is <code class="literal">ActionBlock&lt;TInput&gt;</code> because it performs an action on its input and does not produce a result.</p>
          <p>The next step is to connect each block in the pipeline to the next. The <code class="literal">LinkTo</code> method of <code class="literal">DataflowBlock</code> is used to connect <code class="literal">ISourceBlock&lt;TOutput&gt;</code> to <code class="literal">TargetBlock&lt;TInput&gt;</code>. When you call the <code class="literal">LinkTo</code> method to connect a source to a target, the source will propagate data to the target as it becomes available.</p>
          <div class="informalexample">
            <pre class="programlisting">downloadBook.LinkTo(createWordList);
createWordList.LinkTo(filterWordList);
filterWordList.LinkTo(printWordCount);</pre>
          </div>
          <p>We also added some completion tasks to propagate completion through the pipeline. Each completion task sets the next dataflow block to the completed state.</p>
          <div class="informalexample">
            <pre class="programlisting">downloadBook.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)createWordList).Fault(t.Exception);
  else createWordList.Complete();
});</pre>
          </div>
          <p>Finally, we used <code class="literal">DataflowBlock.Post&lt;TInput&gt;</code> to synchronously send data to the head of the pipeline. The following is the URL string of the book we are downloading:</p>
          <div class="informalexample">
            <pre class="programlisting">downloadBook.Post("http://www.gutenberg.org/files/2009/2009.txt");</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Cancelling a dataflow block">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec93"></a>Cancelling a dataflow block</h1>
            </div>
          </div>
        </div>
        <p>Since dataflow blocks are <a id="id673" class="indexterm"></a>built on the <code class="literal">Task</code> infrastructure of the TPL, cancellation is supported by obtaining <code class="literal">CancellationToken</code> from <code class="literal">CancellationTokenSource</code>.</p>
        <p>In this recipe, we will create a dataflow pipeline to download the contents of a classic book and perform a word count, except this time, we will enable the blocks that form the pipeline to be cancelled.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec168"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's see how we <a id="id674" class="indexterm"></a>can add cancellation to our dataflow blocks.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">CancelDataflow</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Threading.Tasks.Dataflow;
using System.Net;
using System.Threading;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method, create a new <code class="literal">CancellationTokenSource</code> object.<div class="informalexample"><pre class="programlisting">var cancellationSource = new CancellationTokenSource();</pre>
</div></li>
              <li class="listitem">Next, let's create the blocks that form the pipeline. The blocks are exactly as before, except, this time they are created with a new <code class="literal">ExecutionDataflowBlockOptions</code> parameter<a id="id675" class="indexterm"></a> that sets <code class="literal">CancellationToken</code>.<div class="informalexample"><pre class="programlisting">// Download a book as a string
var downloadBook = new TransformBlock&lt;string, string&gt;(uri =&gt;
{
  Console.WriteLine("Downloading the book...");

  return new WebClient().DownloadString(uri);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});



// splits text into an array of strings. 
var createWordList = new TransformBlock&lt;string, string[]&gt;(text =&gt;
{
  Console.WriteLine("Creating list of words...");

  // Remove punctuation  
  char[] tokens = text.ToArray();
  for (int i = 0; i &lt; tokens.Length; i++)
  {
    if (!char.IsLetter(tokens[i]))
      tokens[i] = ' ';
  }
  text = new string(tokens);
  return text.Split(new char[] { ' ' },
     StringSplitOptions.RemoveEmptyEntries);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});

// Remove short words and return the count 
var filterWordList = new TransformBlock&lt;string[], int&gt;(words =&gt;
{
  Console.WriteLine("Counting words...");

  var wordList = words.Where(word =&gt; word.Length &gt; 3).OrderBy(word =&gt; word)
     .Distinct().ToArray();
  return wordList.Count();
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});

var printWordCount = new ActionBlock&lt;int&gt;(wordcount =&gt;
{
  Console.WriteLine("Found {0} words",
     wordcount);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});</pre>
</div></li>
              <li class="listitem">Now, let's use the <code class="literal">LinkTo</code> method to connect the source blocks and target blocks to form the pipeline.<div class="informalexample"><pre class="programlisting">downloadBook.LinkTo(createWordList);
createWordList.LinkTo(filterWordList);
filterWordList.LinkTo(printWordCount);</pre>
</div></li>
              <li class="listitem">Next, we<a id="id676" class="indexterm"></a> need to add some completion tasks to enable each dataflow block to perform a final action after processing all data elements.<div class="informalexample"><pre class="programlisting">downloadBook.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)createWordList).Fault(t.Exception);
  else createWordList.Complete();
});
createWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)filterWordList).Fault(t.Exception);
  else filterWordList.Complete();
});
filterWordList.Completion.ContinueWith(t =&gt;
{
  if (t.IsFaulted) ((IDataflowBlock)printWordCount).Fault(t.Exception);
  else printWordCount.Complete();
});</pre>
</div></li>
              <li class="listitem">Now, add a <code class="literal">try</code> block to post the data to the head of the pipeline, complete the pipeline activity, and cancel the token.<div class="informalexample"><pre class="programlisting">try
{
  Console.WriteLine("Starting...");                
  
  // Download Origin of Species
  downloadBook.Post("http://www.gutenberg.org/files/2009/2009.txt");

  // Mark the head of the pipeline as complete. 
  downloadBook.Complete();

  // Cancel the operation
  cancellationSource.Cancel();

  printWordCount.Completion.Wait();

}</pre>
</div></li>
              <li class="listitem">Finally, add a <code class="literal">catch</code> block that handles <code class="literal">AggregateException</code> and a <code class="literal">finally</code> block to wait for user input before exiting.<div class="informalexample"><pre class="programlisting">catch (AggregateException ae)
{
  foreach (Exception ex in ae.InnerExceptions)
  {
    Console.WriteLine(ex.Message);
  }
}
finally
{
  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre>
</div></li>
              <li class="listitem">In Visual Studio <a id="id677" class="indexterm"></a>2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_07.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec169"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This application forms a dataflow pipeline to process the contents of a book and return a word count as in<a id="id678" class="indexterm"></a> the previous recipe. The difference is that we set up cancellation by creating a <code class="literal">CancellationTokenSource</code> object, and then setting the <code class="literal">CancellationToken</code> property of the <code class="literal">ExecutionDataflowBlockOptions</code> object associated with the blocks in our pipeline.</p>
          <div class="informalexample">
            <pre class="programlisting">CancellationTokenSource cancellationSource = new CancellationTokenSource();            

var downloadBook = new TransformBlock&lt;string, string&gt;(uri =&gt;
{
  ...

  return new WebClient().DownloadString(uri);
},
new ExecutionDataflowBlockOptions
{
  CancellationToken = cancellationSource.Token
});</pre>
          </div>
          <p>We set the <code class="literal">CancellationToken</code> property<a id="id679" class="indexterm"></a> of the <code class="literal">ExecutionDataflowBlockOptions</code> object to <code class="literal">CancellationToken</code> obtained from the <code class="literal">CancellationTokenSource</code> object.</p>
          <p>As with all other cancellations in the TPL, we need to handle the <code class="literal">OperationCancelled</code> exception, which will be wrapped in a <code class="literal">AggregateException</code> object.</p>
          <div class="informalexample">
            <pre class="programlisting">catch (AggregateException ae)
{
  foreach (Exception ex in ae.InnerExceptions)
  {
    Console.WriteLine(ex.Message);
  }
}</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Specifying the degree of parallelism">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec94"></a>Specifying the degree of parallelism</h1>
            </div>
          </div>
        </div>
        <p>In the previous recipe, we saw how to use the <code class="literal">CancellationToken</code> property of the <code class="literal">ExecutionDataflowBlockOptions</code> object to enable cancellation of a pipeline. In this recipe, we will see how<a id="id680" class="indexterm"></a> to use the <code class="literal">MaxDegreeOfParallelism</code> property to enable dataflow blocks to process more than one message at a time.</p>
        <p>We are going to create a <code class="literal">Console</code> application that performs two dataflow calculations, and prints the elapsed time of each calculation. The first calculation sets the maximum degree of parallelism to one. The second operation is the same as the first, but sets the maximum degree of parallelism to the number of available processors on your machine.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec170"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how to add cancellation to our dataflow blocks.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">DegreeOfParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to the <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open<a id="id681" class="indexterm"></a> up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks.Dataflow;</pre>
</div></li>
              <li class="listitem">Let's start by creating a <code class="literal">static</code> method on the <code class="literal">Program</code> class called <code class="literal">ComputeTime</code>. The method needs to accept an <a id="id682" class="indexterm"></a><code class="literal">integer</code> parameter for <code class="literal">maxDegreeOfParallelism</code> and an <code class="literal">integer</code> parameter for <code class="literal">messageCount</code>.<div class="informalexample"><pre class="programlisting">static TimeSpan ComputeTime(int maxDegreeOfParallelism, int messageCount)
{
  
}</pre>
</div></li>
              <li class="listitem">In the <code class="literal">ComputeTime</code> method<a id="id683" class="indexterm"></a>, create <code class="literal">ActionBlock&lt;int&gt;</code> that just sleeps for the time period of the <code class="literal">integer</code> parameter. <code class="literal">ActionBlock</code> also needs to use a <code class="literal">ExecutionDataflowBlockOptions</code> parameter and set the <code class="literal">MaxDegreeOfParallelism</code> property to the value of the method parameter.<div class="informalexample"><pre class="programlisting">var actionBlock = new ActionBlock&lt;int&gt;(
  millisecondsTimeout =&gt; Thread.Sleep(millisecondsTimeout),
  new ExecutionDataflowBlockOptions
  {
     MaxDegreeOfParallelism = maxDegreeOfParallelism
  });</pre>
</div></li>
              <li class="listitem">Let's finish up the <code class="literal">ComputeTime</code> method by creating a <code class="literal">Stopwatch</code> object, using a <code class="literal">for</code> loop to post data to the action block, complete the action block, and return the elapsed time.<div class="informalexample"><pre class="programlisting">Stopwatch sw = new Stopwatch();
sw.Start();

for (int i = 0; i &lt; messageCount; i++)
{
	actionBlock.Post(1000);
}
actionBlock.Complete();
actionBlock.Completion.Wait();
sw.Stop();

return sw.Elapsed;</pre>
</div></li>
              <li class="listitem">Next, we need to implement the <code class="literal">Main</code> method. Let's start by getting the processor count of your machine; call the <code class="literal">ComputeTime</code> method twice (once with the <code class="literal">maxDegreeOfParallelism</code> parameter set to one, and once with the <code class="literal">maxDegreeOfParallelism</code> parameter set to your processor count), and display the<a id="id684" class="indexterm"></a> results.<div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  int processorCount = Environment.ProcessorCount;
  int messageCount = processorCount;
  TimeSpan elapsedTime;
  elapsedTime = ComputeTime(1, messageCount);
  Console.WriteLine("Degree of parallelism = {0}; message count = {1}; " +
     "elapsed time = {2}ms.", 1, messageCount, (int)elapsedTime.TotalMilliseconds);

  elapsedTime = ComputeTime(processorCount, messageCount);
  Console.WriteLine("Degree of parallelism = {0}; message count = {1}; " +
     "elapsed time = {2}ms.", processorCount, messageCount, (int)elapsedTime.TotalMilliseconds);

  Console.WriteLine("Finished. Press any key to exit.");
  Console.ReadLine();
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should have results as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_08.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec171"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, we just<a id="id685" class="indexterm"></a> use the <code class="literal">ComputeTime</code> method to set the maximum degree of parallelism of <code class="literal">ActionBlock&lt;int&gt;</code> to the value of the <code class="literal">maxDegreeOfParallelism</code> method parameter.</p>
          <div class="informalexample">
            <pre class="programlisting">static TimeSpan ComputeTime(int maxDegreeOfParallelism, int messageCount)
{
  var actionBlock = new ActionBlock&lt;int&gt;(
     millisecondsTimeout =&gt; Thread.Sleep(millisecondsTimeout),
     new ExecutionDataflowBlockOptions
     {
       MaxDegreeOfParallelism = maxDegreeOfParallelism
     });
   ...
     
}</pre>
          </div>
          <p>We call this method twice, once with the <code class="literal">maxDegreeOfParallelism</code> parameter set to one, and once with the <code class="literal">maxDegreeOfParallelism</code> parameter<a id="id686" class="indexterm"></a> set to the processor count of your machine.</p>
          <p>A maximum degree of parallelism of one causes the dataflow block to process messages serially, and a degree of parallelism of greater than one enables the dataflow block to process messages in parallel.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Unlink dataflow blocks">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec95"></a>Unlink dataflow blocks</h1>
            </div>
          </div>
        </div>
        <p>We have previously seen how to link dataflow blocks together to form a pipeline. This recipe is going to show how to unlink a dataflow block from its source.</p>
        <p>We are going to show<a id="id687" class="indexterm"></a> how to unlink a dataflow block by creating a <code class="literal">Console</code> application that creates three transform blocks, each of which calls a method to perform a calculation. The transform block objects will each be linked to a <code class="literal">WriteOnceBlock&lt;T&gt;</code> object, with the <code class="literal">MaxMessages</code> property<a id="id688" class="indexterm"></a> set to one. This will instruct the source blocks to unlink after the first message is received at the target.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec172"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">DegreeOfParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks.Dataflow;</pre>
</div></li>
              <li class="listitem">First, let's create a <code class="literal">static</code> method called <code class="literal">DoCalculation</code>. This method accepts <code class="literal">integer</code> and <code class="literal">CancellationToken</code> as parameters, and returns <code class="literal">integer</code>. This method is going to simulate a lengthy calculation that takes a few seconds to complete, then returns a somewhat arbitrary value.<div class="informalexample"><pre class="programlisting">static int DoCalculation(int n, CancellationTokenSource tokenSource)
{  
  // simulate a workload and return result
  SpinWait.SpinUntil(() =&gt; tokenSource.IsCancellationRequested,
    new Random().Next(2000));
  return n + 5;
}</pre>
</div></li>
              <li class="listitem">Next, let's create another <code class="literal">static</code> method called <code class="literal">ReceiveFromAny&lt;T&gt;</code>. This method will take a parameter array of <code class="literal">ISourceBlock&lt;T&gt;</code> and return <code class="literal">T</code>. This method will receive a value from the first source in the <code class="literal">source</code> array that returns a value. It will create new <code class="literal">WriteOnceBlock&lt;T&gt;</code> and link it to each source block, with a <code class="literal">DataFlowLinkOptions</code> parameter and the <code class="literal">MaxMessages</code> property set to one. Finally, it will receive the value produced by <code class="literal">WriteOnceBlock</code>.<div class="informalexample"><pre class="programlisting">public static T ReceiveFromAny&lt;T&gt;(params ISourceBlock&lt;T&gt;[] sources)
{
  var writeOnceBlock = new WriteOnceBlock&lt;T&gt;(e =&gt; e);
  foreach (var source in sources)
  {
    source.LinkTo(writeOnceBlock, new DataflowLinkOptions { MaxMessages = 1 });
  }            
  return writeOnceBlock.Receive();
}</pre>
</div></li>
              <li class="listitem">Finally, let's<a id="id689" class="indexterm"></a> implement the <code class="literal">Main</code> method. <code class="literal">Main</code> needs to create a new <code class="literal">CancellationToken</code> object, create three <code class="literal">System.Threading.Tasks.Dataflow.TransformBlock</code> objects that each call the <code class="literal">DoCalculation</code> method, posts data to each of <code class="literal">TransformBlocks</code>, and receives the result.<div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{

  try
  {
    var tokenSource = new CancellationTokenSource();

    Func&lt;int, int&gt; action = n =&gt; DoCalculation(n, tokenSource);
    var calculation1 = new TransformBlock&lt;int, int&gt;(action);
    var calculation2 = new TransformBlock&lt;int, int&gt;(action);
    var calculation3 = new TransformBlock&lt;int, int&gt;(action);

    calculation1.Post(11);
    calculation2.Post(21);
    calculation3.Post(31);

    int result = ReceiveFromAny(calculation1, calculation2, calculation3);

    // Cancel all calls to TrySolution that are still active.
    tokenSource.Cancel();

    // Print the result to the console.
    Console.WriteLine("The solution is {0}.", result);
  }
  catch (AggregateException) { }
  finally { Console.ReadLine(); }

}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, <a id="id690" class="indexterm"></a>press <span class="emphasis"><em>F5</em></span> to run the project. Your application should appear as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_09.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec173"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>The <code class="literal">Main</code> method of this application is responsible for creating our <code class="literal">TransformBlock</code> objects, creating <code class="literal">Func</code> to call the <code class="literal">DoCalculation</code> method, posting some data to <code class="literal">TransformBlocks</code>, and calling <code class="literal">RecieveFromAny</code> with <code class="literal">TransformBlocks</code> as parameter.</p>
          <div class="informalexample">
            <pre class="programlisting">var tokenSource = new CancellationTokenSource();

Func&lt;int, int&gt; action = n =&gt; DoCalculation(n, tokenSource);
var calculation1 = new TransformBlock&lt;int, int&gt;(action);
var calculation2 = new TransformBlock&lt;int, int&gt;(action);
var calculation3 = new TransformBlock&lt;int, int&gt;(action);

calculation1.Post(11);
calculation2.Post(21);
calculation3.Post(31);

int result = ReceiveFromAny(calculation1, calculation2, calculation3);</pre>
          </div>
          <p>The <code class="literal">RecieveFromAny</code> method<a id="id691" class="indexterm"></a> creates <a id="id692" class="indexterm"></a>a new <code class="literal">WriteOnceBlock&lt;T&gt;</code> object, uses a <code class="literal">for</code> loop to link the <code class="literal">WriteOnceBlocks</code> to the source <code class="literal">TransformBlocks</code>, and receives the first data the <code class="literal">WriteOnceBlock</code> produces.</p>
          <div class="informalexample">
            <pre class="programlisting">public static T ReceiveFromAny&lt;T&gt;(params ISourceBlock&lt;T&gt;[] sources)
{
  var writeOnceBlock = new WriteOnceBlock&lt;T&gt;(e =&gt; e);
  foreach (var source in sources)
  {
    source.LinkTo(writeOnceBlock, new DataflowLinkOptions { MaxMessages = 1 });
  }            
  return writeOnceBlock.Receive();
}</pre>
          </div>
          <p>The link to the source blocks is created using the <code class="literal">LinkTo</code> method<a id="id693" class="indexterm"></a> as before, but this time a new <code class="literal">DataflowLinkOptions</code> object is used as a parameter, with the <code class="literal">MaxMessages</code> property set to one.</p>
          <p>The <code class="literal">MaxMessages</code> property<a id="id694" class="indexterm"></a> is used to set the maximum number of messages that may be consumed across a link.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using JoinBlock to read from multiple data sources">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch09lvl1sec96"></a>Using JoinBlock to read from multiple data sources</h1>
            </div>
          </div>
        </div>
        <p>This recipe is going to <a id="id695" class="indexterm"></a>show how to use <code class="literal">JoinBlock</code> to perform an operation when data is available from multiple sources.</p>
        <p>We are going to create a <code class="literal">Console</code> application that defines two types of resources: <code class="literal">NetworkResource</code> and <code class="literal">MemoryResource</code>. We will use the <code class="literal">NetworkResource</code> and <code class="literal">MemoryResource</code> pair to perform an operation. To enable the operation to occur when both required resources are available, we will use <code class="literal">JoinBlock&lt;T1, T2&gt;</code>.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec174"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's see how to use <code class="literal">JoinBlock</code> to perform an operation based on data from multiple sources.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>Console Application</strong></span> project template and assign <code class="literal">JoinBlock</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Next, go to <span class="strong"><strong>Solution Explorer</strong></span>, right-click on <span class="strong"><strong>References</strong></span>, click on <span class="strong"><strong>Manage NuGet Packages</strong></span>, and add a reference to the <span class="strong"><strong>TPL Dataflow</strong></span> library.</li>
              <li class="listitem">Open up <code class="literal">Program.cs</code> and add the following <code class="literal">using</code> directives to the top of your <code class="literal">Program</code> class:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks.Dataflow;</pre>
</div></li>
              <li class="listitem">Inside the <code class="literal">Program</code> class <a id="id696" class="indexterm"></a>above the <code class="literal">Main</code> method, create an <code class="literal">abstract</code> class definition for resource, and a concrete <code class="literal">class</code> definition for <code class="literal">MemoryResource</code> and <code class="literal">NetworkResource</code>.<div class="informalexample"><pre class="programlisting">abstract class Resource
{
}

class MemoryResource : Resource
{
}

class NetworkResource : Resource
{
}</pre>
</div></li>
              <li class="listitem">Now, in the <code class="literal">Main</code> method, create a <code class="literal">BufferBlock&lt;MemoryResource&gt;</code> and a <code class="literal">BufferBlock&lt;NetworkResource&gt;</code> object.<div class="informalexample"><pre class="programlisting">var networkResources = new BufferBlock&lt;NetworkResource&gt;();
var memoryResources = new BufferBlock&lt;MemoryResource&gt;();</pre>
</div></li>
              <li class="listitem">Next, create a <code class="literal">JoinBlock&lt;NetworkResource, MemoryResource&gt;</code>. Create a <code class="literal">GroupingDataflowBlockOptions</code> object parameter and set the <code class="literal">Greedy</code> property to false.<div class="informalexample"><pre class="programlisting">var joinResources =
   new JoinBlock&lt;NetworkResource, MemoryResource&gt;(
    new GroupingDataflowBlockOptions
    {
      Greedy = false
    });</pre>
</div></li>
              <li class="listitem">Now we need to create a <code class="literal">ActionBlock&lt;Tuple&lt;NetworkResource, MemoryResource&gt;&gt;</code> object to simulate <code class="literal">NetworkResource</code> doing a lengthy network access operation.<div class="informalexample"><pre class="programlisting">var networkMemoryAction =
   new ActionBlock&lt;Tuple&lt;NetworkResource, MemoryResource&gt;&gt;(
    data =&gt;
    {
      Console.WriteLine("Network worker: using resources.");
      Thread.Sleep(new Random().Next(500, 2000));
      Console.WriteLine("Network worker: finished using resources.");
      networkResources.Post(data.Item1);
      memoryResources.Post(data.Item2);
    });</pre>
</div></li>
              <li class="listitem">Finally, let's finish<a id="id697" class="indexterm"></a> up the <code class="literal">Main</code> method by linking the resource objects, linking <code class="literal">JoinBlock</code> to <code class="literal">ActionBlock</code>, and posting data to the resource blocks.<div class="informalexample"><pre class="programlisting">networkResources.LinkTo(joinResources.Target1);
memoryResources.LinkTo(joinResources.Target2);

joinResources.LinkTo(networkMemoryAction);

networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());

memoryResources.Post(new MemoryResource());

Thread.Sleep(10000);
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. Your application should display results as shown in the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_09_10.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch09lvl2sec175"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This application starts<a id="id698" class="indexterm"></a> by creating two <code class="literal">BufferBlock&lt;T&gt;</code> objects; one holds network resources and one holds memory resources.</p>
          <div class="informalexample">
            <pre class="programlisting">var networkResources = new BufferBlock&lt;NetworkResource&gt;();
var memoryResources = new BufferBlock&lt;MemoryResource&gt;();</pre>
          </div>
          <p>Then we created a non-greedy <code class="literal">JoinBlock</code> to join the network resources to the memory resources by setting the <code class="literal">Greedy</code> property<a id="id699" class="indexterm"></a> to <code class="literal">false</code>. In the default greedy mode, the join block will greedily take the data from the source, but it still won't produce a result tuple until all necessary data is available. This is primarily important when sources are connected to multiple join blocks. If all of the joins take data greedily from the sources, you can end up in situations where data would be available to satisfy one of the joins, but end up being taken greedily and split across multiple joins such that none of them could be satisfied, and thus, none will produce results until more data comes along.</p>
          <div class="informalexample">
            <pre class="programlisting">var joinResources =
   new JoinBlock&lt;NetworkResource, MemoryResource&gt;(
    new GroupingDataflowBlockOptions
    {
      Greedy = false
   });</pre>
          </div>
          <p>The next step is to create <code class="literal">ActionBlock</code> that operates network and memory resources. The action just simulates a lengthy operation on a network resource and then releases the resources back to their pools.</p>
          <div class="informalexample">
            <pre class="programlisting">var networkMemoryAction =
   new ActionBlock&lt;Tuple&lt;NetworkResource, MemoryResource&gt;&gt;(
    data =&gt;
    {
      ...
      Thread.Sleep(new Random().Next(500, 2000));
      ...
      networkResources.Post(data.Item1);
      memoryResources.Post(data.Item2);
    });</pre>
          </div>
          <p>Finally, we link ou<a id="id700" class="indexterm"></a>r resources together, populate our resource pools and allow data to flow through for a few seconds.</p>
          <div class="informalexample">
            <pre class="programlisting">networkResources.LinkTo(joinResources.Target1);
memoryResources.LinkTo(joinResources.Target2);
joinResources.LinkTo(networkMemoryAction);

networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());
networkResources.Post(new NetworkResource());

memoryResources.Post(new MemoryResource());

Thread.Sleep(10000);</pre>
          </div>
        </div>
      </div>
    </div>
</body>
</html>