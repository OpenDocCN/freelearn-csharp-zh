- en: Chapter 8. Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。Reactive Extensions
- en: 'In this chapter, we will look at another interesting .NET library that helps
    us create asynchronous programs, **Reactive Extensions** (**Rx**). We will cover
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨另一个有趣的 .NET 库，它帮助我们创建异步程序，即 **Reactive Extensions**（**Rx**）。我们将涵盖以下食谱：
- en: Converting a collection to asynchronous `Observable`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合转换为异步 `Observable`
- en: Writing a custom `Observable`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义的 `Observable`
- en: Using the `Subject` type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Subject` 类型
- en: Creating an `Observable` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Observable` 对象
- en: Using LINQ queries against an `Observable` collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LINQ 查询对 `Observable` 集合进行操作
- en: Creating asynchronous operations with Rx
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rx 创建异步操作
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As you have already learned, there are several approaches to creating asynchronous
    programs in .NET and C#. One of them is event-based asynchronous pattern, which
    has already been mentioned in the previous chapters. The initial goal of introducing
    events was to simplify the implementation of the `Observer` design pattern. This
    pattern is common for implementing notifications between objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经学到的，在 .NET 和 C# 中创建异步程序有几种方法。其中之一是基于事件的异步模式，这在之前的章节中已经提到过。引入事件最初的目的是为了简化
    `Observer` 设计模式的实现。这种模式在对象之间实现通知时很常见。
- en: When we discussed the Task Parallel Library, we noted that the event's main
    shortcoming was their inability to be effectively composed with each other. The
    other drawback was that the Event-based Asynchronous Pattern was not supposed
    to be used to deal with the sequence of notifications. Imagine that we have `IEnumerable<string>`
    that gives us string values. However, when we iterate it, we do not know how much
    time one iteration will take. It could be slow, and if we use the regular `foreach`
    loop or other synchronous iteration constructs, we will block our thread until
    we have the next value. This situation is called the **pull-based** approach,
    when we as a client pull values from the producer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 Task Parallel Library 时，我们指出事件的主要缺点是它们无法有效地相互组合。另一个缺点是，基于事件的异步模式不应该用来处理通知的序列。想象一下，我们有一个
    `IEnumerable<string>` 提供字符串值。然而，当我们迭代它时，我们不知道一次迭代将花费多少时间。它可能很慢，如果我们使用常规的 `foreach`
    循环或其他同步迭代结构，我们将阻塞我们的线程，直到我们得到下一个值。这种情况被称为 **基于拉取** 的方法，当我们作为客户端从生产者拉取值时。
- en: The opposite approach is the **push-based** approach, when the producer notifies
    the client about new values. This allows to offload work to the producer, while
    the client is free to do anything else in the time it waits for another value.
    Therefore, the goal is to get something like the asynchronous version of `IEnumerable`,
    which produces a sequence of values and notifies the consumer about each item
    in the sequence, when the sequence is complete or when an exception is thrown.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的方法是 **基于推送** 的方法，当生产者通知客户端有新值时。这允许将工作卸载到生产者，而客户端在等待下一个值时可以自由地做其他任何事情。因此，目标是得到类似异步版本的
    `IEnumerable`，它产生一系列值，并在序列完成或抛出异常时通知消费者。
- en: .NET Framework starting from version 4.0 contains the definition of the `IObservable<out
    T>` and `IObserver<in T>` interfaces that together represent the asynchronous
    push-based collection and its client. They come from the library called Reactive
    Extensions (or simply Rx) that was created inside Microsoft to help us effectively
    compose the sequence of events and all other types of asynchronous programs using
    observable collections. The interfaces were included in .NET Framework, but their
    implementations and all other mechanics are still distributed separately in the
    Rx library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET Framework 4.0 版本开始，包含 `IObservable<out T>` 和 `IObserver<in T>` 接口的定义，它们一起代表异步推送式集合及其客户端。它们来自名为
    Reactive Extensions（或简称 Rx）的库，该库是在微软内部创建的，以帮助我们有效地组合事件序列和所有其他类型的异步程序，使用可观察集合。这些接口已包含在
    .NET Framework 中，但它们的实现和 Rx 库中的所有其他机制仍然分别分发。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rx globally is a cross-platform library. There are libraries for .NET 3.5, Silverlight,
    and Windows Phone. It is also available in JavaScript, Ruby, and Python. It is
    also open source; you can find Reactive Extensions' source code for .NET on the
    CodePlex website and other implementations on GitHub.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Rx 全局是一个跨平台库。它提供了 .NET 3.5、Silverlight 和 Windows Phone 的库。它还支持 JavaScript、Ruby
    和 Python。它也是开源的；你可以在 CodePlex 网站上找到 .NET 的 Reactive Extensions 的源代码，以及其他实现可以在
    GitHub 上找到。
- en: The most amazing thing is that the observable collections are compatible with
    LINQ, and therefore, we are able to use declarative queries to transform and compose
    those collections in an asynchronous manner. This also makes it possible for us
    to use the extension methods to add functionalities to the Rx programs in the
    same way it is used in the usual LINQ providers. Reactive Extensions also supports
    transition from all asynchronous programming patterns (including the Asynchronous
    Programming Model, the Event-based Asynchronous Pattern, and the Task Parallel
    Library) to observable collections, and it supports its own way of running asynchronous
    operations, which is still quite similar to TPL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人惊讶的是，可观察集合与LINQ兼容，因此我们可以使用声明性查询以异步方式转换和组合这些集合。这也使得我们可以使用扩展方法以与常规LINQ提供程序相同的方式向Rx程序添加功能。反应式扩展还支持从所有异步编程模式（包括异步编程模型、基于事件的异步模式和任务并行库）过渡到可观察集合，并支持其自己的异步操作运行方式，这与TPL仍然非常相似。
- en: The Reactive Extensions library is a very powerful and complex instrument, which
    is worthy of writing a separate book. In this chapter, I would like to review
    the most useful scenario, that is, how to work with asynchronous event sequences
    effectively. We will observe key types of the Reactive Extensions framework, learn
    to create sequences and manipulate them in different ways, and finally, check
    how we could use Reactive Extensions to run asynchronous operations and manage
    their options.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展库是一个非常强大且复杂的工具，值得单独写一本书。在本章中，我想回顾最有用的场景，即如何有效地处理异步事件序列。我们将观察反应式扩展框架的关键类型，学习以不同的方式创建序列并操作它们，最后检查我们如何使用反应式扩展来运行异步操作并管理它们的选项。
- en: Converting a collection to an asynchronous Observable
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将集合转换为异步可观察对象
- en: This recipe walks you through the process of creating an observable collection
    from an `Enumerable` class and how to process it asynchronously.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将指导您如何从`Enumerable`类创建可观察集合以及如何异步处理它。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，您将需要Visual Studio 2015。不需要其他先决条件。本食谱的源代码可以在`BookSamples\Chapter8\Recipe1`中找到。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to create an observable collection from an `Enumerable` class
    and process it asynchronously, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何从`Enumerable`类创建可观察集合并异步处理它，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'Add a reference to the **Reactive Extensions Main Library** NuGet package by
    following these steps:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下步骤添加对**反应式扩展主库**NuGet包的引用：
- en: Right-click on the **References** folder in the project, and select the **Manage
    NuGet Packages…** menu option.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目中的**引用**文件夹，并选择**管理NuGet包…**菜单选项。
- en: 'Now, add the **Reactive Extensions - Main Library** NuGet package. You can
    search for **rx-main** in the **Manage NuGet Packages** dialog, as shown in the
    following screenshot:'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加**反应式扩展 - 主库**NuGet包。您可以在**管理NuGet包**对话框中搜索**rx-main**，如图所示：
- en: '![How to do it...](img/B05292_08_01.jpg)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/B05292_08_01.jpg)'
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we simulate a slow enumerable collection with the `EnumerableEventSequence`
    method. Then, we iterate it with the usual `foreach` cycle, and we can see that
    it is actually slow; we wait for each iteration to complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`EnumerableEventSequence`方法模拟一个缓慢的可枚举集合。然后，我们使用常规的`foreach`循环迭代它，我们可以看到它实际上很慢；我们等待每个迭代完成。
- en: We then convert this enumerable collection to Observable with the help of the
    `ToObservable` extension method from the Reactive Extensions library. Next, we
    subscribe to the updates of this observable collection, providing the `Console.Write`
    method as the action, which will be executed on each update of the collection.
    As a result, we get exactly the same behavior as before; we wait for each iteration
    to complete because we use the main thread to subscribe to the updates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 Reactive Extensions 库中的 `ToObservable` 扩展方法将这个可枚举集合转换为 Observable。接下来，我们订阅这个
    Observable 集合的更新，提供 `Console.Write` 方法作为操作，该操作将在集合的每次更新时执行。因此，我们得到与之前完全相同的行为；我们等待每个迭代完成，因为我们使用主线程来订阅更新。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We wrap the subscription objects into using statements. Although it is not always
    necessary, disposing off the subscriptions is a good practice that will help you
    avoid lifetime-related bugs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将订阅对象包装在 using 语句中。尽管这不总是必要的，但销毁订阅是一个良好的实践，这有助于您避免与生命周期相关的错误。
- en: To make the program asynchronous, we use the `SubscribeOn` method, providing
    it with the TPL task pool scheduler. This scheduler will place the subscription
    to the TPL task pool, offloading the work from the main thread. This allows us
    to keep the UI responsive and do something else while the collection gets updated.
    To check this behavior, you could remove the last `Console.ReadLine` call from
    the code. When doing so, we finish our main thread immediately, which forces all
    background threads (including the TPL task pool worker threads) to end as well,
    and we will get no output from the asynchronous collection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使程序异步，我们使用 `SubscribeOn` 方法，向其提供 TPL 任务池调度器。这个调度器会将订阅放置在 TPL 任务池中，从而将工作从主线程卸载。这允许我们保持
    UI 响应，并在集合更新时做其他事情。要检查这种行为，您可以从代码中移除最后的 `Console.ReadLine` 调用。这样做时，我们将立即完成主线程，这迫使所有后台线程（包括
    TPL 任务池工作线程）结束，并且我们将从异步集合中得不到任何输出。
- en: If we are using a UI framework, we have to interact with the UI controls only
    from within the UI thread. To achieve this, we should use the `ObserveOn` method
    with the corresponding scheduler. For Windows Presentation Foundation, we have
    the `DispatcherScheduler` class and the `ObserveOnDispatcher` extension method
    defined in a separate NuGet package named Rx-XAML or Reactive Extensions XAML
    support library. For other platforms, there are corresponding separate NuGet packages
    as well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 UI 框架，我们必须仅在 UI 线程内与 UI 控件交互。为了实现这一点，我们应该使用带有相应调度器的 `ObserveOn` 方法。对于
    Windows Presentation Foundation，我们有 `DispatcherScheduler` 类和定义在名为 Rx-XAML 或 Reactive
    Extensions XAML 支持库的单独 NuGet 包中的 `ObserveOnDispatcher` 扩展方法。对于其他平台，也有相应的单独 NuGet
    包。
- en: Writing custom Observable
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义的 Observable
- en: This recipe will describe how to implement the `IObservable<in T>` and `IObserver<out
    T>` interfaces to get the custom Observable sequence and properly consume it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将描述如何实现 `IObservable<in T>` 和 `IObserver<out T>` 接口以获取自定义的 Observable 序列并正确消费它。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe2`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步实现这个菜谱，您需要 Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter8\Recipe2`
    中找到。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To understand how to implement the `IObservable<in T>` and `IObserver<out T>`
    interfaces to get the custom Observable sequence and consume it, perform the following
    steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何实现 `IObservable<in T>` 和 `IObserver<out T>` 接口以获取自定义的 Observable 序列并消费它，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for more details
    on how to do this.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 **Reactive Extensions 主库** NuGet 包的引用。有关如何操作的更多详细信息，请参阅 *将集合转换为异步 Observable*
    菜谱。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we implement our observer first by simply printing out to the console
    the information about the next item from the observable collection, error, or
    sequence completion. This is a very simple consumer code and there is nothing
    special about it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先通过简单地向控制台打印出可观察集合中下一个项目的信息、错误或序列完成信息来实现我们的观察者。这是一段非常简单的消费者代码，并没有什么特别之处。
- en: The interesting part is our observable collection implementation. We accept
    an enumeration of numbers into a constructor and do not check it for null on purpose.
    When we have a subscribing observer, we iterate this collection and notify the
    observer about each item in the enumeration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是我们的可观察集合实现。我们故意在构造函数中接受一个数字枚举，并且不检查它是否为空。当我们有一个订阅观察者时，我们迭代这个集合，并通知观察者枚举中的每个项目。
- en: Then, we demonstrate the actual subscription. As we can see, the asynchrony
    is achieved by calling the `SubscribeOn` method, which is an extension method
    to `IObservable` and contains asynchronous subscription logic. We do not care
    about asynchrony in our observable collection; we use standard implementation
    from the Reactive Extensions library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们演示实际的订阅。正如我们所见，异步是通过调用 `SubscribeOn` 方法实现的，这是一个对 `IObservable` 的扩展方法，包含异步订阅逻辑。我们并不关心我们的可观察集合中的异步性；我们使用来自
    Reactive Extensions 库的标准实现。
- en: When we subscribe to the normal observable collection, we just get all the items
    from it. It is now asynchronous, so we need to wait for some time for the asynchronous
    operation to complete and only then print the message and wait for the user input.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅正常的可观察集合时，我们只是从中获取所有项目。现在它是异步的，因此我们需要等待一段时间，直到异步操作完成，然后打印消息并等待用户输入。
- en: Finally, we try to subscribe to the next observable collection, where we are
    iterating a null enumeration and therefore getting a null reference exception.
    We see that the exception has been properly handled and the `OnError` method was
    executed to print out the error details.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试订阅下一个可观察集合，其中我们正在迭代一个空枚举，因此得到一个空引用异常。我们看到异常已经被正确处理，并且执行了 `OnError` 方法来打印错误详情。
- en: Using the Subject type family
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Subject 类型家族
- en: This recipe shows you how to use the `Subject` type family from the Reactive
    Extensions library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何使用 Reactive Extensions 库中的 `Subject` 类型家族。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe3`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个菜谱，你需要 Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter8\Recipe3`
    中找到。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To understand the use of the `Subject` type family from the Reactive Extensions
    library, perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解从 Reactive Extensions 库中 `Subject` 类型家族的使用，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for details
    on how to do this.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 **Reactive Extensions 主库** NuGet 包的引用。有关如何操作的详细信息，请参阅 *将集合转换为异步可观察对象* 菜谱。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this program, we look through different variants of the `Subject` type family.
    The `Subject` type represents both the `IObservable` and `IObserver` implementations.
    This is useful in different proxy scenarios when we want to translate events from
    multiple sources to one stream, or vice versa, to broadcast an event sequence
    to multiple subscribers. Subjects are also very convenient for experimenting with
    Reactive Extensions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们查看 `Subject` 类型家族的不同变体。`Subject` 类型代表 `IObservable` 和 `IObserver` 的实现。这在不同的代理场景中非常有用，当我们想要将多个源的事件转换为单个流，或者相反，向多个订阅者广播事件序列时。主题对于在
    Reactive Extensions 中进行实验也非常方便。
- en: Let's start with the basic `Subject` type. It retranslates an event sequence
    to subscribers as soon as they subscribe to it. In our case, the `A` string will
    not be printed out because the subscription happened after it was transmitted.
    Besides that, when we call the `OnCompleted` or `OnError` methods on `Observable`,
    it stops further translation of the event sequence, so the last string will also
    not be printed out.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的 `Subject` 类型开始。它会在订阅者订阅后立即将事件序列重新翻译给订阅者。在我们的例子中，`A` 字符串将不会被打印出来，因为订阅发生在它被传输之后。除此之外，当我们对
    `Observable` 调用 `OnCompleted` 或 `OnError` 方法时，它将停止进一步的事件序列翻译，所以最后一个字符串也不会被打印出来。
- en: The next type, `ReplaySubject`, is quite flexible and allows us to implement
    three additional scenarios. First, it can cache all the events from the beginning
    of their broadcasting, and if we subscribe later, we will get all the preceding
    events first. This behavior is illustrated in the second example. Here, we will
    have all four strings on the console because the first event will be cached and
    translated to the latter subscriber.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类型，`ReplaySubject`，非常灵活，允许我们实现三个额外的场景。首先，它可以缓存从广播开始的所有事件，如果我们稍后订阅，我们将首先接收到所有先前的事件。这种行为在第二个例子中得到了说明。在这里，我们将在控制台上有所有四个字符串，因为第一个事件将被缓存并翻译给后来的订阅者。
- en: Then, we can specify the buffer size and the time window size for `ReplaySubject`.
    In the next example, we set the subject to have a buffer for two events. If more
    events are broadcasted, only the last two will be retranslated to the subscriber.
    So here, we will not see the first string because we have `B` and `C` in the subject
    buffer when subscribing to it. The same is the case with a time window. We can
    specify that the `Subject` type only caches events that took place less than a
    certain time ago, discarding the older ones. Therefore, in the fourth example,
    we will only see the last two events; the older events do not fit into the time
    window.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以指定 `ReplaySubject` 的缓冲区大小和时间窗口大小。在下一个例子中，我们将主题设置为有两个事件缓冲。如果有更多事件被广播，只有最后两个将被重新翻译给订阅者。所以在这里，我们不会看到第一个字符串，因为我们订阅时主题缓冲区中有
    `B` 和 `C`。情况与时间窗口相同。我们可以指定 `Subject` 类型只缓存发生时间在某个时间之前的所有事件，丢弃较旧的事件。因此，在第四个例子中，我们只会看到最后两个事件；较旧的事件不适合时间窗口。
- en: The `AsyncSubject` type is something like a `Task` type from the TPL globally.
    It represents a single asynchronous operation. If there are several events published,
    it waits for the event sequence completion and provides only the last event to
    the subscriber.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject` 类型类似于 TPL 中的 `Task` 类型。它代表一个单一的后台操作。如果有多个事件被发布，它将等待事件序列完成，并只将最后一个事件提供给订阅者。'
- en: The `BehaviorSubject` type is quite similar to the `ReplaySubject` type, but
    it caches only one value and allows us to specify a default value in case we did
    not send any notifications. In our last example, we will see all the strings printed
    out because we provided a default value, and all other events take place after
    the subscription. If we move the `behaviorSubject.OnNext("B");` line upwards below
    the `Default` event, it will replace the default value in the output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 类型与 `ReplaySubject` 类型非常相似，但它只缓存一个值，并允许我们指定一个默认值，以防我们没有发送任何通知。在我们的最后一个例子中，我们会看到所有字符串都被打印出来，因为我们提供了一个默认值，并且所有其他事件都在订阅之后发生。如果我们把
    `behaviorSubject.OnNext("B");` 这行代码向上移动到 `Default` 事件下面，它将替换输出中的默认值。'
- en: Creating an Observable object
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 `Observable` 对象
- en: This recipe will describe different ways to create an `Observable` object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述创建 `Observable` 对象的不同方法。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe could be found at `BookSamples\Chapter8\Recipe4`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要 Visual Studio 2015。不需要其他先决条件。这个配方的源代码可以在 `BookSamples\Chapter8\Recipe4`
    中找到。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To understand different ways of creating an `Observable` object, perform the
    following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解创建 `Observable` 对象的不同方法，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous Observable* recipe for details
    on how to do this.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 **Reactive Extensions Main Library** NuGet 包的引用。有关如何操作的详细信息，请参阅 *将集合转换为异步
    Observable* 配方。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we walk through different scenarios of creating `observable` objects.
    Most of this functionality is provided as static factory methods of the `Observable`
    type. The first two samples show how we can create an `Observable` method that
    produces a single value and one that produces no value. In the next example, we
    use `Observable.Throw` to construct an `Observable` class that triggers the `OnError`
    handler of its observers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们探讨了创建 `可观察` 对象的不同场景。大部分这个功能都是作为 `Observable` 类型的静态工厂方法提供的。前两个示例展示了我们可以创建一个产生单个值的
    `Observable` 方法和一个不产生任何值的 `Observable` 方法。在下一个示例中，我们使用 `Observable.Throw` 来构建一个触发其观察者
    `OnError` 处理器的 `Observable` 类。
- en: The `Observable.Repeat` method represents an endless sequence. There are different
    overloads of this method; here, we construct an endless sequence by repeating
    42 values. Then, we use LINQ's `Take` method to take five elements from this sequence.
    `Observable.Range` represents a range of values, pretty much like `Enumerable.Range`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Repeat` 方法表示一个无限序列。这个方法有不同的重载形式；在这里，我们通过重复42个值来构建一个无限序列。然后，我们使用LINQ的
    `Take` 方法从这个序列中取出五个元素。`Observable.Range` 表示一系列值，与 `Enumerable.Range` 类似。'
- en: The `Observable.Create` method supports more custom scenarios. There are a lot
    of overloads that allow us to use cancellation tokens and tasks, but let's look
    at the simplest one. It accepts a function, which accepts an instance of observer
    and returns an `IDisposable` object representing a subscription. If we had any
    resources to clean up, we would be able to provide the cleanup logic here, but
    we just return an empty disposable as we actually do not need it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Create` 方法支持更多自定义场景。有许多重载允许我们使用取消令牌和任务，但让我们看看最简单的一个。它接受一个函数，该函数接受观察者实例并返回一个表示订阅的
    `IDisposable` 对象。如果我们有任何资源需要清理，我们就可以在这里提供清理逻辑，但因为我们实际上不需要它，所以我们只返回一个空的可丢弃对象。'
- en: The `Observable.Generate` method is another way to create a custom sequence.
    We must provide an initial value for a sequence and then a predicate that determines
    whether we should generate more items or complete the sequence. Then, we provide
    an iteration logic, which increments a counter in our case. The last parameter
    is a selector function that allows us to customize the results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Generate` 方法是创建自定义序列的另一种方式。我们必须提供一个序列的初始值，然后提供一个确定是否生成更多项或完成序列的谓词。然后，我们提供一个迭代逻辑，在我们的例子中是增加计数器。最后一个参数是一个选择函数，它允许我们自定义结果。'
- en: The last two methods deal with timers. `Observable.Interval` starts producing
    timer tick events with the `TimeSpan` period, and `Observable.Timer` specifies
    the startup time as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法处理计时器。`Observable.Interval` 以 `TimeSpan` 期间开始产生计时器滴答事件，而 `Observable.Timer`
    指定启动时间。
- en: Using LINQ queries against an observable collection
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LINQ 查询对可观察集合进行查询
- en: This recipe shows you how to use LINQ to query an asynchronous sequence of events.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何使用 LINQ 查询异步事件序列。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe5`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，你需要 Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter8\Recipe5`
    找到。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the use of LINQ queries against the observable collection, perform
    the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解对可观察集合使用 LINQ 查询的使用，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for details
    on how to do this.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 **Reactive Extensions Main Library** NuGet 包的引用。有关如何操作的详细信息，请参阅 *将集合转换为异步可观察序列*
    菜谱。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ability to use LINQ against the `Observable` event sequences is the main
    advantage of the Reactive Extensions framework. There are many different useful
    scenarios as well; unfortunately, it is impossible to show all of them here. I
    tried to provide a simple, yet very illustrative example, which does not have
    many complex details and shows the very essence of how a LINQ query could work
    when applied to asynchronous observable collections.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用 LINQ 对 `Observable` 事件序列进行操作是 Reactive Extensions 框架的主要优势。还有很多不同的有用场景；不幸的是，在这里展示所有这些场景是不可能的。我试图提供一个简单但非常具有说明性的例子，它没有太多复杂细节，展示了
    LINQ 查询在应用于异步可观察集合时的工作原理。
- en: First, we create an `Observable` event that generates a sequence of numbers,
    one number every 50 milliseconds, and we start from the initial value of zero,
    taking 21 of those events. Then, we compose LINQ queries to this sequence. First,
    we select only the even numbers from the sequence, and then only the odd numbers.
    Then, we concatenate these two sequences.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `Observable` 事件，它生成一个数字序列，每 50 毫秒一个数字，我们从初始值零开始，取 21 个这样的事件。然后，我们将
    LINQ 查询组合到这个序列中。首先，我们只选择序列中的偶数，然后只选择奇数。然后，我们将这两个序列连接起来。
- en: The final query shows us how to use a very useful method, `Do`, which allows
    us to introduce side effects and, for example, logging each value from the resulting
    sequence. To run all queries, we create nested subscriptions, and because the
    sequences are initially asynchronous, we have to be very careful about the subscription's
    lifetime. The outer scope represents a subscription to the timer, and the inner
    subscriptions deal with the combined sequence query and the side effects query,
    respectively. If we press *Enter* too early, we just unsubscribe from the timer
    and thus stop the demo.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的查询展示了如何使用一个非常有用的方法 `Do`，它允许我们引入副作用，例如，记录结果序列中的每个值。要运行所有查询，我们创建嵌套的订阅，由于序列最初是异步的，我们必须非常小心订阅的生存期。外部作用域代表对计时器的订阅，内部订阅分别处理组合序列查询和副作用查询。如果我们太早按下
    *Enter*，我们只是取消对计时器的订阅，从而停止演示。
- en: When we run the demo, we see the actual process of how different queries interact
    in real time. We can see that our queries are lazy, and they start running only
    when we subscribe to their results. The timer event's sequence is printed in the
    first column. When the even numbers query gets an even number, it prints it out
    as well using the `---` prefix to distinguish this sequence result from the first
    one. The final query results are printed in the right-hand column.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行演示时，我们可以看到不同查询如何实时交互的实际过程。我们可以看到我们的查询是懒加载的，并且只有在订阅其结果时才开始运行。计时器事件的序列打印在第一列。当偶数查询得到一个偶数时，它也会打印出来，并使用
    `---` 前缀来区分这个序列结果和第一个。最终的查询结果打印在右侧列。
- en: When the program runs, we can see that the timer sequence, the even-number sequence,
    and the side effect sequence run in parallel. Only the concatenation waits until
    the even-number sequence is complete. If we do not concatenate those sequences,
    we will have four parallel sequences of events interacting with each other in
    the most effective way! This shows the real power of Reactive Extensions and could
    be a good start to learn this library in depth.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们可以看到计时器序列、偶数序列和副作用序列是并行运行的。只有连接操作等待偶数序列完成。如果我们不连接这些序列，我们将有四个并行的事件序列以最有效的方式相互交互！这展示了
    Reactive Extensions 的真正力量，并且可以作为一个深入学习这个库的好起点。
- en: Creating asynchronous operations with Rx
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rx 创建异步操作
- en: This recipe shows you how to create an `Observable` from the asynchronous operations
    defined in other programming patterns.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何从其他编程模式定义的异步操作中创建 `Observable`。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe6`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要 Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在 `BookSamples\Chapter8\Recipe6`
    找到。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to create asynchronous operations with Rx, perform the following
    steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 Rx 创建异步操作，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for details
    on how to do this.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对**响应式扩展主库**NuGet包的引用。有关如何操作的详细信息，请参阅*将集合转换为异步可观察对象*配方。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE16]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Replace the `Main` method with the following code snippet:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main`方法替换为以下代码片段：
- en: '[PRE17]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows you how to convert different types of asynchronous operations
    to an `Observable` class. The first code snippet uses the `Observable.Start` method,
    which is quite similar to `Task.Run` from TPL. It starts an asynchronous operation
    that gives out a string result and then gets completed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何将不同类型的异步操作转换为`Observable`类。第一个代码片段使用了`Observable.Start`方法，这与TPL中的`Task.Run`非常相似。它启动了一个异步操作，该操作输出一个字符串结果，然后完成。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I would strongly suggest that you use the Task Parallel Library for asynchronous
    operations. Reactive Extensions supports this scenario as well, but to avoid ambiguity,
    it is much better to stick with tasks when speaking about separate asynchronous
    operations and to go with Rx only when we need to work with sequences of events.
    Another suggestion is to convert every type of separate asynchronous operation
    to tasks and only then convert a task to an observable class, if you need it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您使用任务并行库（Task Parallel Library，简称TPL）进行异步操作。响应式扩展（Reactive Extensions）也支持这种场景，但为了避免歧义，在讨论单独的异步操作时坚持使用任务会更好，只有在我们需要处理事件序列时才使用Rx。另一个建议是将所有类型的单独异步操作转换为任务，然后如果需要，再将任务转换为可观察类（`Observable`
    class）。
- en: Then, we do the same with tasks and convert a task to an `Observable` method
    by simply calling the `ToObservable` extension method. The next code snippet is
    about converting the Asynchronous Programming Model pattern to `Observable`. Normally,
    you would convert APM to a task and then a task to `Observable`. However, there
    is a direct conversion, and this example illustrates how to run an asynchronous
    delegate and wrap it into an `Observable` operation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用同样的方法处理任务，通过简单地调用`ToObservable`扩展方法将任务转换为`Observable`方法。下一个代码片段是关于将异步编程模型（Asynchronous
    Programming Model，简称APM）转换为`Observable`。通常，你会将APM转换为任务，然后将任务转换为`Observable`。然而，存在一种直接转换，这个例子说明了如何运行异步委托并将其包装为`Observable`操作。
- en: The next part of the code snippet shows that we are able to use the `await`
    operator in an `Observable` operation. As we are not able to use the `async` modifier
    on an entry method such as `Main`, we introduce a separate method that returns
    a task and waits for this resulting task to be complete inside the `Main` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段的下一部分展示了我们能够在`Observable`操作中使用`await`运算符。由于我们无法在如`Main`这样的入口方法上使用`async`修饰符，我们引入了一个单独的方法，该方法返回一个任务，并在`Main`方法内部等待这个结果任务的完成。
- en: The last part of this code snippet is the same as the code which converts APM
    pattern to Observable, but now, we convert the Event-based Asynchronous Pattern
    directly to an `Observable` class. We create a timer and consume its events for
    5 seconds. We then dispose the timer to clean up the resources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段的最后部分与将APM模式转换为`Observable`的代码相同，但现在，我们将基于事件的异步模式（Event-based Asynchronous
    Pattern，简称EAP）直接转换为`Observable`类。我们创建了一个计时器，并消耗其5秒的事件。然后，我们销毁计时器以清理资源。
