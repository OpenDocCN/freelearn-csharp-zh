<html><head></head><body>
        

                            
                    <h1 class="header-title">What Next?</h1>
                
            
            
                
<p>In this book, we have discovered the MVVM architectural pattern and explored the process of developing a WPF application, while taking advantage of the pattern's <strong>Separation of Concerns</strong> and adhering to its principles. We investigated a number of different ways of communicating between the various application layers and structuring our code base.</p>
<p>Importantly, we considered a variety of ways of debugging our WPF applications and tracking down our coding problems. In particular, we revealed some tips and tricks to help us to identify the causes of our data binding errors. In addition, we also learned how viewing trace information can help us to detect problems, even after our applications have been deployed.</p>
<p>We moved on to investigate the benefit of utilizing an application framework and began designing and developing our own. We structured it in a way that did not tie our framework to any particular feature or technology and experimented with a variety of ways to encapsulate our required functionality.</p>
<p>We devoted a whole chapter to the essential art of data binding and took a detailed look at the creation of Dependency Properties and Attached Properties. We looked at setting Dependency Property metadata and were introduced to the crucial Dependency Property Setting Precedence List. We then covered both standard and hierarchical data templates and studied some interesting data binding examples.</p>
<p>Investigating the rich inheritance hierarchy of the built-in WPF controls enabled us to see how their functionality is built up from each successive base class in the hierarchy. This, in turn, enabled us to see that some controls are better to use in some situations than others. We also found out how to customize the built-in controls and considered how best to make our own controls.</p>
<p>While the animation possibilities in a WPF application are practically endless, we investigated the more usable options, primarily focusing on the syntax used in XAML. We then added animation functionality directly into our application framework, where it could be used with little effort on the part of developers.</p>
<p>After turning our attention to the look of our applications, we investigated a number of techniques, such as borderless windows and adding shadows and glowing effects to more advanced methods to make our application stand out from the crowd. We also incorporated animations into our everyday controls, in order to bring about a sense of exclusivity to our applications.</p>
<p>We thoroughly investigated the data validation options that the .NET Framework offers us, primarily concentrating on the two available validation interfaces, and exploring a number of different ways of implementing them. We probed advanced techniques, such as multilevel validation and using data annotation attributes, and then added a complete validation system into our application framework.</p>
<p>We further extended our application framework with an asynchronous data operation system that was combined with a complete user feedback component, including an animated feedback display mechanism. We continued by investigating how we can provide in-application help and user preferences and implement work-heavy functions to save users time and effort.</p>
<p>We also explored a number of options that we can use to increase the performance of our WPF applications, from declaring our resources more efficiently to using lighter weight controls and more efficient methods of rendering drawings, images, and text. We saw more performant methods of data binding and discovered the importance of detaching event handlers.</p>
<p>Finally, we investigated the last task in any professional application's development, its deployment. We looked at a number of alternative methods but primarily focused on the most popular ClickOnce technology. We investigated how ClickOnce deployments are done and how we can safely store and access data in isolated storage. We ended with a number of ways to access the various application versions available to us in .NET.</p>
<p>Overall, we've covered a plethora of information that, together, will enable us to create efficient, visually appealing, highly usable, and highly productive applications in WPF. What's more, we've now got our own application framework that we can reuse for each new application that we create. <em>So, what's next?</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Turning your attention to future projects</h1>
                
            
            
                
<p>You could apply the concepts and ideas from this book to other areas and continue to experiment and explore their effect in these new areas. For example, we've learned about <kbd>Adorner</kbd> objects, so you could use that new-found knowledge to implement some visual feedback for the common drag and drop functionality in the main window's adorner layer.</p>
<p>You could then further extend this idea, using what you've discovered about Attached Properties, and completely encapsulate this drag and drop functionality, enabling the developers that utilize your application framework to make use of this feature in a property-based manner.</p>
<p>For example, you could create a <kbd>DragDropProperties</kbd> class that declared Attached Properties, such as <kbd>IsDragSource</kbd>, <kbd>IsDragTarget</kbd>, <kbd>DragEffects</kbd>, <kbd>DragDropType</kbd>, and <kbd>DropCommand</kbd>, and it could be extended by your relevant Attached Property classes, such as a <kbd>ListBoxProperties</kbd> class.</p>
<p>You could then declare a <kbd>BaseDragDropManager</kbd> class to be used in the <kbd>DragDropProperties</kbd> class, that stitches everything together, by attaching and removing the appropriate event handlers, starting the drag and drop procedure, updating the cursor via the drag and drop effects as it moves across the screen, and executing the <kbd>ICommand</kbd> object assigned to the <kbd>DropCommand</kbd> Property.</p>
<p>This leads to a further area that could be extended. Not only can we handle UI events in Attached Properties, but we can also combine them to perform more complex functionality. For example, let's say that we have an Attached Property of type <kbd>string</kbd>, named <kbd>Label</kbd>.</p>
<p>When this property is set, it could apply a particular <kbd>ControlTemplate</kbd> element from resources to the current <kbd>TextBox</kbd> object's <kbd>Template</kbd> property. This template could display the text from this property in a secondary text element and therefore act as an internal label. When the <kbd>TextBox</kbd> object has a value, the label text element could be hidden via an <kbd>IValueConverter</kbd> implementation that extends our <kbd>BaseVisibilityConverter</kbd> class:</p>
<pre>&lt;TextBlock Text="{Binding (Attached:TextBoxProperties.Label),
  RelativeSource={RelativeSource AncestorType=TextBox}, FallbackValue=''}"
  Foreground="{Binding (Attached:TextBoxProperties.LabelColor), 
  RelativeSource={RelativeSource AncestorType=TextBox}, 
  FallbackValue=#FF000000}" Visibility="{Binding Text, 
  RelativeSource={RelativeSource AncestorType=TextBox},  
  Converter={StaticResource StringToVisibilityConverter},  
  FallbackValue=Collapsed}" ... /&gt;  </pre>
<p>As shown in the preceding example, we could then declare another Attached Property, named <kbd>LabelColor</kbd>, of type <kbd>Brush</kbd>, which specifies the color to be used by the <kbd>Label</kbd> Attached Property when it is set. Note that if the <kbd>LabelColor</kbd> property is not set, then it will either use its default value if it is set, or the value specified in the <kbd>FallbackValue</kbd> property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving our application framework</h1>
                
            
            
                
<p>Another area that you can continue to work on is customizing our application framework further and adapting it to your individual requirements. With this in mind, you could continue to build up a complete collection of customized controls with a particular look and feel in an external resource file to use in all of your applications.</p>
<p>There are also many other examples provided throughout this book that could be easily extended. For example, you could update our <kbd>DependencyManager</kbd> class to enable multiple concrete classes to be registered for each interface.</p>
<p>Instead of using a <kbd>Dictionary&lt;Type, Type&gt;</kbd> object to store our registrations, you could define new custom objects. You could declare a <kbd>ConcreteImplementation</kbd> struct that has a <kbd>Type</kbd> property and an <kbd>object</kbd> array to hold any constructor input parameters that may be required for its initialization:</p>
<pre>public ConcreteImplementation(Type type, 
  params object[] constructorParameters) 
{ 
  Type = type; 
  ConstructorParameters = constructorParameters; 
} </pre>
<p>You could then declare a <kbd>DependencyRegistration</kbd> class that you could use to pair the interface type with the collection of concrete implementations:</p>
<pre>public DependencyRegistration(Type interfaceType,  
  IEnumerable&lt;ConcreteImplementation&gt; concreteImplementations) 
{ 
  if (!concreteImplementations.All(c =&gt;
    interfaceType.IsAssignableFrom(c.Type)))
    throw new ArgumentException("The System.Type object specified by the 
    ConcreteImplementation.Type property must implement the interface type 
    specified by the interfaceType input parameter.", 
    nameof(interfaceType));
  ConcreteImplementations = concreteImplementations; 
  InterfaceType = interfaceType; 
} </pre>
<p>In our <kbd>DependencyManager</kbd> class, you could change the type of the <kbd>registeredDependencies</kbd> field to a collection of this new <kbd>DependencyRegistration</kbd> type. The current <kbd>Register</kbd> and <kbd>Resolve</kbd> methods could then also be updated to use this new collection type.</p>
<p>Alternatively, you could include other common functionality that is contained within popular Dependency Injection and Inversion of Control containers, such as the automatic registering of concrete classes to interfaces at the assembly level. For this, you could use some basic reflection:</p>
<pre>using System.Reflection;

...

public void RegisterAllInterfacesInAssemblyOf&lt;T&gt;() where T : class 
{ 
  Assembly assembly = typeof(T).Assembly; 
  IEnumerable&lt;Type&gt; interfaces = 
    assembly.GetTypes().Where(p =&gt; p.IsInterface); 
  foreach (Type interfaceType in interfaces) 
  { 
    IEnumerable&lt;Type&gt; implementingTypes = assembly.GetTypes().
      Where(p =&gt; interfaceType.IsAssignableFrom(p) &amp;&amp; !p.IsInterface); 
    ConcreteImplementation[] concreteImplementations = implementingTypes.
      Select(t =&gt; new ConcreteImplementation(t, null)).ToArray();       
    if (concreteImplementations != null &amp;&amp; concreteImplementations.Any()) 
      registeredDependencies.Add(interfaceType, concreteImplementations); 
  } 
} </pre>
<p>This method first accesses the assembly that contains the generic type parameter and then gets a collection of the interfaces in that assembly. It then iterates through the interface collection and finds a collection of classes that implements each interface, instantiating a <kbd>ConcreteImplementation</kbd> element with each. Each match is added into the <kbd>registeredDependencies</kbd> collection with its relating interface type.</p>
<p>In this way, you could pass any interface type from our <kbd>Models</kbd>, <kbd>Managers</kbd>, and <kbd>ViewModels</kbd> projects to automatically register all of the interfaces and concrete classes found inside their assemblies. There is a clear benefit to doing this in larger applications, as it will mean that you don't have to manually register each type:</p>
<pre>private void RegisterDependencies() 
{ 
  DependencyManager.Instance.ClearRegistrations(); 
  DependencyManagerAdvanced.Instance. 
    RegisterAllInterfacesInAssemblyOf&lt;IDataProvider&gt;(); 
  DependencyManagerAdvanced.Instance. 
    RegisterAllInterfacesInAssemblyOf&lt;IUiThreadManager&gt;(); 
  DependencyManagerAdvanced.Instance. 
    RegisterAllInterfacesInAssemblyOf&lt;IUserViewModel&gt;(); 
} </pre>
<p>Additionally, you could declare another method that registers all types found in the assembly of the type specified by the generic type parameter <kbd>T</kbd>, where matches of implemented interfaces are found. This could be used during testing, so that you could just pass any type from the mock projects during testing, again saving time and effort:</p>
<pre>DependencyManager.Instance.
  RegisterAllConcreteImplementationsInAssemblyOf&lt;MockUiThreadManager&gt;(); </pre>
<p>As with all serious development projects, there is a need to test the code that makes up the code base. Doing so obviously helps to reduce the number of bugs in the application, but also alerts us when existing functionality has been broken, while adding new code. They also provide a safety net for refactoring, allowing us to continually improve our designs, while ensuring that existing functionality is not broken.</p>
<p>Therefore, one area that you could improve in the application would be to implement a full test suite. This book has explained a number of ways for us to swap out code during testing and this pattern can be easily extended. If a manager class uses some sort of resource that cannot be used during testing, then you can create an interface for it, add a mock class, and use the <kbd>DependencyManager</kbd> class to instantiate the relevant concrete implementation during runtime and testing.</p>
<p>Another area from the book that could be extended relates to our <kbd>AnimatedStackPanel</kbd> class. You could extract the reusable properties and animation code from this class to an <kbd>AnimatedPanel</kbd> base class so that it could service several different types of animated panels.</p>
<p>As suggested in <a href="83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml">Chapter 7</a>, <em>Mastering Practical Animations</em>, you could then further extend the base class by exposing additional animation properties so that users of your panel could have more control over the animations that it provides. For example, you could add alignment, direction, duration, and/or animation type properties to enable users of your framework to use a wide variety of animation options.</p>
<p>These properties could be divided between the entry and exit animations, to enable independent control over them. By providing a wide variety of these additional properties in a base class, you can vastly simplify the process of adding new animated panels.</p>
<p>For example, you could add a new <kbd>AnimatedWrapPanel</kbd>, or perhaps an <kbd>AnimatedColumnPanel</kbd>, by simply extending the base class, and only have to implement the two <kbd>MeasureOverride</kbd> and <kbd>ArrangeOverride</kbd> methods in the new panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Logging errors</h1>
                
            
            
                
<p>In a number of places in the code examples in this book, you may have seen <kbd>Log error</kbd> comments. In general, it is not only good practice to log errors, but it can also help you to track down bugs and improve the overall user experience of the users of your applications.</p>
<p>The easiest place to log errors to would be an <kbd>Errors</kbd> database and the minimum useful information fields that you'd want to store would include details of the current user, the time the error occurred, the exception message, the stack trace, and the assembly or area that it occurred in. This latter field can be found in the <kbd>Module</kbd> property of the exception's <kbd>TargetSite</kbd> property:</p>
<pre>public Error(Exception exception, User createdBy)  
{ 
  Id = Guid.NewGuid(); 
  Message = FlattenInnerExceptions(exception); 
  StackTrace = exception.StackTrace; 
  Area = exception.TargetSite.Module.ToString(); 
  CreatedOn = DateTime.Now; 
  CreatedBy = createdBy; 
} </pre>
<p>Note the use of the custom <kbd>FlattenInnerExceptions</kbd> method that also outputs the messages from any inner exceptions that the thrown exception may contain. One alternative to building your own <kbd>FlattenInnerExceptions</kbd> method would be to simply save the <kbd>ToString</kbd> output of the exception, which will also contain details of any inner exceptions that it may contain, although it will also contain stack trace and other information as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using online resources</h1>
                
            
            
                
<p>As a final note, if you are not already familiar with the <strong>Microsoft Docs</strong> website, you really should acquaint yourself with it. It is maintained for the Microsoft developer community and includes everything from detailed APIs for their various languages, tutorial walkthroughs, and code examples, through to downloads of their software.</p>
<p>It can be found at <a href="https://docs.microsoft.com">https://docs.microsoft.com</a> and should be the first place you look when questions arise over the members of the various classes in .NET. Should you not find your required information in their APIs, then you can ask questions in their forums and quickly receive answers from both the community and from Microsoft employees.</p>
<p>Another great developer resource is the <strong>Stack Overflow</strong> question and answer site for development professionals, where I still answer questions when I can find the time. It can be found online at <a href="http://stackoverflow.com/">http://stackoverflow.com/</a> and with answers often provided by the community within seconds, it really is hard to beat and is one of the best development forums around.</p>
<p>For further tutorials, check out the WPF Tutorial.net website at <a href="https://www.wpftutorial.net/">https://www.wpftutorial.net/</a>, where you can find a wealth of tutorials, from basic to complex. And for interesting and novel downloadable custom controls and additional tutorials, try visiting the WPF section of the Code Project website at <a href="https://www.codeproject.com/kb/wpf/">https://www.codeproject.com/kb/wpf/</a>.</p>
<p>All that remains now is for me to wish you well with your future application development and your blossoming development careers.</p>


            

            
        
    </body></html>