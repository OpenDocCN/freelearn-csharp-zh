- en: Becoming Proficient with Data Binding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为数据绑定的熟练者
- en: In this chapter, we'll investigate the data binding syntax that is used to connect
    our data sources to our UI controls. We'll examine how to declare Dependency Properties,
    along with all of the various options that we have when doing that. We'll find
    out about the scope of declared bindings and unravel the finer details of data
    templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究用于将我们的数据源连接到我们的 UI 控件的数据绑定语法。我们将检查如何声明依赖属性，以及我们在做这件事时所有可用的各种选项。我们将了解声明的绑定的范围，并揭示数据模板的细节。
- en: It is the data binding in WPF that enables it to work so well with the MVVM
    pattern. It provides the connection for two-way communication between the View
    and the View Models components. Yet this abstraction can often lead to confusion
    and make tracking down problems more difficult than when using traditional methods
    of UI to business logic communication.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正是 WPF 中的数据绑定使得它能够与 MVVM 模式如此良好地工作。它提供了视图和视图模型组件之间双向通信的连接。然而，这种抽象往往会导致困惑，并使得追踪问题比使用传统的
    UI 到业务逻辑通信方法更困难。
- en: As data binding is such an important part of the MVVM pattern, we'll cover this
    topic thoroughly, from the basics to advanced concepts, and we'll ensure that
    we are able to fulfill any binding requirements that we may receive.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据绑定是 MVVM 模式如此重要的一个部分，我们将全面介绍这个主题，从基础知识到高级概念，并确保我们能够满足我们可能收到的任何绑定要求。
- en: Data binding basics
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定基础
- en: 'In WPF, we use the `Binding` class to create our bindings. In general, it is
    fair to say that every binding will contain four constituent parts. Let''s take
    a look at them now:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中，我们使用 `Binding` 类来创建我们的绑定。一般来说，可以说每个绑定都包含四个组成部分。现在让我们来看看它们：
- en: The first is the binding source; typically, this will be one of our View Models.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是绑定源；通常，这将是我们的视图模型之一。
- en: The second is the path to the property from the source object that we would
    like to data bind to.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是从我们想要数据绑定的源对象属性路径。
- en: The third is the binding target; this will typically be a UI control.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是绑定目标；这通常是一个 UI 控件。
- en: The fourth is the path to the property of the binding target that we want to
    data bind to.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个是我们想要数据绑定的绑定目标的属性路径。
- en: If one of our bindings does not work, it is most likely that one of these four
    things has not been set correctly. It is important to stress that the target property
    will typically be from a UI control, because there is a data binding rule that
    states that the binding target must be a Dependency Property. The properties of
    most UI controls are Dependency Properties, and so, this rule simply enforces
    that data normally travels in the direction from our View Model data sources to
    the binding target UI controls.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的某个绑定不起作用，最可能的原因是以下四个设置中有一个没有正确设置。重要的是要强调，目标属性通常来自 UI 控件，因为有一个数据绑定规则指出，绑定目标必须是依赖属性。大多数
    UI 控件的属性都是依赖属性，因此，这个规则只是简单地强制数据通常从我们的视图模型数据源流向绑定目标 UI 控件。
- en: We'll examine the direction of data bound data traversal later in the chapter,
    but let's first focus on the syntax that is used to specify the value of the `Binding.Path`
    property.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面部分检查数据绑定数据的传输方向，但首先让我们专注于用于指定 `Binding.Path` 属性值的语法。
- en: Binding path syntax
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定路径语法
- en: Bindings can be declared either in longhand, defining an actual `Binding` element
    in the XAML, or in shorthand, using the markup language that is translated to
    a `Binding` element for us by the XAML. We'll primarily focus on the shorthand
    notation, as that is what we will predominantly use throughout the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定可以声明为长格式，即在 XAML 中定义实际的 `Binding` 元素，或者声明为短格式，使用标记语言，该语言由 XAML 为我们转换为 `Binding`
    元素。我们将主要关注短格式，因为这是我们将在整本书中主要使用的格式。
- en: The `Binding.Path` property is of type `PropertyPath`. This type supports a
    unique syntax that can be expressed in XAML using a XAML markup extension. While
    it can be confusing at times, there are specific rules that we can learn to make
    it easier. Let's investigate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binding.Path` 属性的类型是 `PropertyPath`。此类型支持一种独特的语法，可以使用 XAML 标记扩展在 XAML 中表示。虽然有时可能会令人困惑，但我们可以学习一些特定的规则，使其更容易理解。让我们来调查一下。'
- en: 'To start with, let''s understand that the binding path is relative to the binding
    source and that the binding source is typically set by the `DataContext` property,
    or by the path itself. In order to bind to the whole binding source, we can specify
    our binding like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们理解绑定路径是相对于绑定源而言的，并且绑定源通常由`DataContext`属性或路径本身设置。为了绑定到整个绑定源，我们可以这样指定我们的绑定：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It can also be specified like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以这样指定：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Most simply, we can specify our binding like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况下，我们可以这样指定我们的绑定：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that explicitly declaring the `Path` property name in this syntax is optional
    when the path value is declared first. The three preceding examples are all equal.
    We will omit the `Path` property declaration in the bindings in this book for
    brevity. Let's now see the remaining property path syntax mini-language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当路径值首先声明时，在这个语法中显式声明`Path`属性名是可选的。前面的三个例子都是相等的。为了简洁，本书中的绑定将省略`Path`属性声明。现在让我们看看剩余的属性路径语法迷你语言。
- en: 'To data bind to most property paths, we use the same notation as we use in
    code. For example, when binding directly to the property of a data bound object,
    we just use the property name:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定到大多数属性路径，我们使用与代码中相同的表示法。例如，当直接绑定到数据绑定对象的属性时，我们只需使用属性名：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To data bind to the property of an object that is directly referenced by a
    property of our binding source, we again use the same syntax that we do in code.
    This is known as **indirect property targeting**:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定到由绑定源的属性直接引用的对象的属性，我们再次使用与代码中相同的语法。这被称为**间接属性定位**：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, when data binding to an item in a collection, or a property of a
    collection item, we use the indexing notation from code. For example, this is
    how we access a property from the first item in our data bound binding source:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当绑定到集合中的项或集合项的属性时，我们使用代码中的索引表示法。例如，这是我们如何访问数据绑定源中第一个项的属性：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, if we want to access the second item, we use a key of `1` and use
    a key value of `2` if we want the third item and so on. Likewise, to indirectly
    target a property of a collection item, where the collection is a property of
    our binding source, we use the following syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们想访问第二个项，我们使用键`1`，如果我们想访问第三个项，我们使用键值`2`，依此类推。同样，要间接定位集合项的属性，其中集合是绑定源的属性，我们使用以下语法：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, we are freely able to combine these various syntactical options
    to generate more complex binding paths. Multi-dimensional collections are also
    accessed in the same way as we refer to them in code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以自由地组合这些不同的语法选项来生成更复杂的绑定路径。多维集合的访问方式与我们在代码中引用它们的方式相同：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While discussing data binding to collections, note that there is a special
    forward slash (`/`) syntax that we can use to access the selected item at any
    time:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论绑定到集合时，请注意，我们可以使用特殊的斜杠（`/`）语法来在任何时候访问选中项：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This particular example would bind to the `PropertyName` property of the current
    item of the collection specified by the `CollectionPropertyName` property. Let''s
    take a quick look at a more practical example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子将绑定到由`CollectionPropertyName`属性指定的集合当前项的`PropertyName`属性。让我们快速看一下一个更实际的例子：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this basic example using our `UsersViewModel`, we data bind the `Users` collection
    to a listbox. Underneath, we output the value of the `Name` property from the
    currently selected item. Note the setting of the `IsSynchronizedWithCurrentItem`
    property, as without it, this forward slash binding would not work correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本示例中，我们使用`UsersViewModel`将`Users`集合绑定到一个列表框中。下面，我们输出当前选中项的`Name`属性值。注意`IsSynchronizedWithCurrentItem`属性的设置，因为没有它，这个斜杠绑定将无法正确工作。
- en: Try removing the `IsSynchronizedWithCurrentItem` property from the example and
    running the application again and you will see that the current user's name will
    be output initially, but not updated after changes to the selected item.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从示例中移除`IsSynchronizedWithCurrentItem`属性并再次运行应用程序，您将看到当前用户的名称最初会被输出，但在选中项更改后不会更新。
- en: 'Setting this property to `True` will ensure that the `ItemCollection.CurrentItem`
    property from the `ListBox.Items` collection is updated each time the selection
    changes. Note that we could also achieve this same output using the `ListBox.SelectedItem`
    property instead of this forward slash notation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性设置为`True`将确保每次选择更改时，`ListBox.Items`集合的`ItemCollection.CurrentItem`属性都会更新。请注意，我们也可以使用`ListBox.SelectedItem`属性而不是这个正斜杠表示法来达到相同的效果：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `IsSynchronizedWithCurrentItem` property is now not needed to update the
    selected user's name in the `TextBlock`, because the `SelectedItem` property will
    take care of that. However, setting it to `True` in this case will ensure that
    the first item in the `ListBox` is selected and that the `TextBlock` will initially
    output the name of that item's user. Let's continue looking at the forward slash
    notation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsSynchronizedWithCurrentItem`属性现在不再需要更新`TextBlock`中选定的用户名称，因为`SelectedItem`属性将负责这一点。然而，在这种情况下将其设置为`True`将确保`ListBox`中的第一个项目被选中，并且`TextBlock`将最初输出该项目的用户名称。让我们继续查看正斜杠表示法。'
- en: 'If you are trying to data bind to a property of an item in a collection, where
    the collection is itself an item of a parent collection, we can use the forward
    slash notation multiple times in a single binding path:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在尝试将数据绑定到集合中某个项目的属性，其中该集合本身是父集合的一个项目，我们可以在单个绑定路径中使用正斜杠表示法多次：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To clarify, this path would bind to the `PropertyName` property of the selected
    item of the collection specified by the `InnerCollectionPropertyName` property,
    which itself is the selected item of the collection specified by the `CollectionPropertyName`
    property.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，此路径将绑定到由`InnerCollectionPropertyName`属性指定的集合中选定项目的`PropertyName`属性，该属性本身是由`CollectionPropertyName`属性指定的集合的选定项目。
- en: 'Let''s move on from collections now, to Attached Properties. In order to data
    bind to an Attached Property, we need to use a slightly different syntax from
    that used in code; we need to enclose the property name in parenthesis, along
    with the class name:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不再关注集合，而是转向附加属性。为了将数据绑定到附加属性，我们需要使用与代码中使用的语法略有不同的语法；我们需要将属性名放在括号中，包括类名：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that when the Attached Property is a custom-declared property, we must
    include the XAML namespace prefix inside the parenthesis with its separating colon:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当附加属性是自定义声明的属性时，我们必须在括号内包含XAML命名空间前缀，并用冒号分隔：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Typically, when binding to Attached Properties, we also need to specify the
    binding target as well as the target property. The binding target will generally
    either be the object that the binding is set on, or another UI element, so we
    tend to see the `RelativeSource` or `ElementName` properties being used in these
    situations:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们绑定到附加属性时，我们还需要指定绑定目标和目标属性。绑定目标通常是设置绑定的对象，或者另一个UI元素，因此在这些情况下我们倾向于看到使用`RelativeSource`或`ElementName`属性：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We'll see an extended version of this example later in the book, but in short,
    it binds to the `TextBoxProperties.Label` Attached Property of the parent control
    of type `TextBox`. It is called from within a `ControlTemplate` and so, the parent
    textbox is the templated parent of the control that is being data bound.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分看到这个示例的扩展版本，但简而言之，它绑定到父控件的`TextBoxProperties.Label`附加属性，该控件类型为`TextBox`。它是在`ControlTemplate`内部调用的，因此父文本框是正在数据绑定的控件的模板父控件。
- en: Escaping invalid characters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义无效字符
- en: When using the `PropertyPath` syntax mini-language, there may be the odd occasion
    when we need to escape certain characters that are used in the syntax. In general,
    the backslash (`\`) is used as the escape character and the only characters that
    we need to escape are as follows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`PropertyPath`语法迷你语言时，偶尔我们可能需要转义语法中使用的某些字符。一般来说，反斜杠（`\`）用作转义字符，我们只需要转义以下字符。
- en: The most common character that we may need to escape in our bind paths is the
    closing curly bracket (`}`), which signals the end of a markup section. Also,
    if you need to use an actual backslash in your binding path, then you must escape
    it by preceding it with another backslash.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的绑定路径中可能需要转义的最常见的字符是闭合花括号（`}`），它表示标记部分的结束。此外，如果您需要在绑定路径中使用实际的反斜杠，那么您必须通过在其前面加上另一个反斜杠来转义它。
- en: The only two other characters that we need to escape are the equals sign (`=`)
    and the comma character (`,`), which are both used to define binding paths. All
    other characters that we are likely to use in a binding path are deemed to be
    valid.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要转义的唯一其他两个字符是等号（`=`）和逗号字符（`,`），这两个字符都用于定义绑定路径。我们可能在绑定路径中使用的所有其他字符都被认为是有效的。
- en: Note that there is a special character to use if we need to escape a character
    when inside an indexer binding expression. In these cases, instead of using the
    backslash character, we need to use the caret character (`^`) as the escape character.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们需要在索引器绑定表达式中转义一个字符，有一个特殊的字符可以使用。在这些情况下，我们不需要使用反斜杠字符，而是需要使用 caret 字符 (`^`)
    作为转义字符。
- en: Also note that when explicitly declaring bindings in XAML, we need to escape
    the ampersand (`&`) and the greater than sign (`>`) by replacing them with their
    XML Entity forms. If you need to use these characters, then replace the ampersand
    with `&amp;` and replace the greater than sign with `&gt;`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当我们显式地在 XAML 中声明绑定时，我们需要通过将它们替换为其 XML 实体形式来转义 ampersand (`&`) 和大于号 (`>`)。如果您需要使用这些字符，那么将
    ampersand 替换为 `&amp;`，将大于号替换为 `&gt;`。
- en: Exploring the Binding class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 `Binding` 类
- en: The `Binding` class has more properties than we have space to discuss here,
    but we'll cover the most important ones in detail shortly, and briefly look at
    other notable properties momentarily. The `Binding` class is the top-level class
    in each binding, but internally it uses a lower-level class that maintains the
    connection between the binding source and binding target.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binding` 类具有比我们在这里讨论的空间更多的属性，但我们将很快详细讨论最重要的属性，并简要地看看其他值得注意的属性。`Binding` 类是每个绑定的顶级类，但内部它使用一个更低级别的类来维护绑定源和绑定目标之间的连接。'
- en: The `BindingExpression` class is that underlying object. When using MVVM, developers
    do not typically access this inner class, as we tend to keep our functionality
    in our View Models. However, if we are writing custom controls, then it can be
    useful to be aware of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingExpression` 类是那个底层对象。当使用 MVVM 模式时，开发者通常不会访问这个内部类，因为我们倾向于将功能保持在我们的 View
    Models 中。然而，如果我们正在编写自定义控件，那么了解它可能是有用的。'
- en: It can be used to programmatically update the associated binding source in certain
    circumstances and we'll find out about that later in the chapter. For now, let's
    focus on what the `Binding` class can do for us.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在某些情况下用于程序化地更新相关的绑定源，我们将在本章后面了解到这一点。现在，让我们专注于 `Binding` 类能为我们做什么。
- en: In .NET 4.5, a great new property was added to the `Binding` class. The `Delay`
    property enables us to specify an amount of time in milliseconds with which to
    delay the update of the binding source after a change has been made to the binding
    target property value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 4.5 中，`Binding` 类增加了一个非常棒的新属性。`Delay` 属性允许我们指定一个以毫秒为单位的延迟时间，在修改绑定目标属性值后，用于延迟更新绑定源。
- en: 'This is really useful if we are performing some heavy computational validation
    or other processing dependent upon the user''s input in a `TextBox` element for
    example. To clarify this functionality further, this delay is actually restarted
    each time the data bound property value changes, or each key press in our example.
    It is typically used to update the binding source in chunks, each time the user
    pauses, or completes typing, somewhat like buffering:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在执行一些依赖于用户在 `TextBox` 元素中的输入的重计算验证或其他处理时，这非常有用。为了进一步阐明这个功能，这个延迟实际上在数据绑定属性值每次改变时，或者在我们例子中的每次按键时都会重新启动。它通常用于分块更新绑定源，每次用户暂停或完成输入时，有点像缓冲：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `FallbackValue` property is another useful property when it comes to performance.
    In order to return a value from each binding, the WPF Framework does up to four
    things. The first is to simply validate the target property type with the data
    bound value. If successful, it will then try to resolve the binding path.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`FallbackValue` 属性是性能方面另一个有用的属性。为了从每个绑定返回一个值，WPF 框架最多执行四件事。第一件事是简单地验证目标属性类型与数据绑定值。如果成功，它将尝试解析绑定路径。'
- en: Most of the time, this will work, but if not, it will then attempt to find a
    converter to return the value. If it can't find one, or the located converter
    returns the `DependencyProperty.UnsetValue` value, it will then look to see if
    the `FallbackValue` property has a value to provide it with. If there is no fallback
    value, then a lookup is required to find the default value of the target Dependency
    Property.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这将有效，但如果不行，它将尝试找到一个转换器来返回值。如果找不到转换器，或者找到的转换器返回`DependencyProperty.UnsetValue`值，它将接着查看`FallbackValue`属性是否有值可以提供。如果没有备用值，则需要查找目标依赖属性的默认值。
- en: By setting the `FallbackValue` property, we can do two things to improve performance,
    albeit in a slight way. The first is that, it will stop the WPF Framework from
    performing the lookup of the default value of the target Dependency Property.
    The second is that it will prevent trace statements from being fed to the Output
    window in Visual Studio and to any other trace outputs that have been setup.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`FallbackValue`属性，我们可以以轻微的方式提高性能，尽管只能做两件事。第一是，它将阻止WPF框架查找目标依赖属性的默认值。第二是，它将防止跟踪语句被发送到Visual
    Studio的输出窗口和任何其他已设置的跟踪输出。
- en: The `TargetNullValue` property is similar to the `FallbackValue` property in
    that it enables us to provide some output when there is no data bound value from
    the binding source. The difference is that the `FallbackValue` property value
    is output when a data bound value cannot be resolved, while the `TargetNullValue`
    property value is used when the successfully resolved data bound value is `null`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`TargetNullValue`属性与`FallbackValue`属性类似，因为它允许我们在没有从绑定源绑定值时提供一些输出。区别在于，当数据绑定值无法解决时，`FallbackValue`属性值被输出，而当成功解决的数据绑定值为`null`时，使用`TargetNullValue`属性值。'
- en: 'We can use this functionality to display a more humanized value than `null`,
    or even to provide a default message in our textbox controls for example. To do
    this, we could set our data bound `string` properties to `null` and set a suitable
    value to the `TargetNullValue` property:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此功能显示比`null`更人性化的值，或者甚至在我们的文本框控件中提供默认消息。为此，我们可以将数据绑定的`string`属性设置为`null`，并将适当值设置到`TargetNullValue`属性：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, this message will actually appear in the `TextBox` control, so it's
    not an ideal way of providing this functionality. We'll see a better example of
    this later in the book, but now, let's continue our exploration of the `Binding`
    class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，此消息将实际出现在`TextBox`控件中，因此这不是提供此功能的好方法。我们将在本书后面的部分看到更好的例子，但现在，让我们继续探索`Binding`类。
- en: 'If we have any properties in our View Model that access their data asynchronously,
    or if they are calculated by a heavy computational process, then we need to set
    the `IsAsync` method to `True` on the binding:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的视图模型中有任何异步访问其数据的属性，或者如果它们是通过一个计算密集型过程计算的，那么我们需要在绑定上设置`IsAsync`方法为`True`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This stops the UI from being blocked while waiting for the data bound property
    to be calculated, or otherwise resolved. Until the binding source is resolved,
    the fallback value is used, if set, or the default value will be used otherwise.
    In this example, we are providing a default image to be displayed until the actual
    image is downloaded from the internet and the binding source is resolved.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止用户界面在等待数据绑定属性计算或解决时被阻塞。在绑定源解决之前，如果设置了备用值，则使用备用值；否则，将使用默认值。在这个例子中，我们提供了一个默认图像，直到从互联网下载实际图像并解决绑定源为止。
- en: Another useful property of the `Binding` class is the `StringFormat` property.
    As the name hints, this uses the `string.Format` method internally to format our
    data bound text output. There are, however, a few caveats to using this functionality.
    The first is that we can only use a single format item, that is represented by
    the single data bound value in a normal binding. We'll find out how to use multiple
    values later in the chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binding`类的另一个有用属性是`StringFormat`属性。正如其名称所暗示的，它内部使用`string.Format`方法来格式化我们的数据绑定文本输出。然而，使用此功能有一些注意事项。首先，我们只能使用单个格式项，即正常绑定中的单个数据绑定值。我们将在本章后面了解如何使用多个值。'
- en: 'Secondly, we need to declare our format carefully, as curly brackets are used
    by the markup extensions and we cannot use the double quote characters (`"`),
    as the binding is already declared within double quotes. One solution is to use
    single quotes to surround our format string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要仔细声明我们的格式，因为花括号被标记扩展所使用，我们不能使用双引号字符（`"`），因为绑定已经在双引号内声明。一个解决方案是使用单引号来包围我们的格式字符串：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another option is to escape the format by preceding it with a pair of curly
    brackets:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用一对花括号来跳出格式：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Most of the useful binding properties have now been discussed here, but it should
    be noted that there are a number of properties in the `Binding` class that are
    not typically used when building a WPF application with MVVM. This is because
    they involve event handlers and we do not normally implement event handlers when
    using MVVM.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数有用的绑定属性现在都已在此讨论，但应注意的是，`Binding`类中有一些属性在构建使用MVVM的WPF应用程序时通常不使用。这是因为它们涉及事件处理程序，而我们通常在使用MVVM时不会实现事件处理程序。
- en: For example, the three `NotifyOnSourceUpdated`, `NotifyOnTargetUpdated` and
    `NotifyOnValidationError` properties relate to the raising of the `Binding.SourceUpdated`,
    `Binding.TargetUpdated` and `Validation.Error` Attached Events.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三个`NotifyOnSourceUpdated`、`NotifyOnTargetUpdated`和`NotifyOnValidationError`属性与`Binding.SourceUpdated`、`Binding.TargetUpdated`和`Validation.Error`附加事件的引发有关。
- en: Likewise, the three `ValidatesOnDataErrors`, `ValidatesOnExceptions`, `ValidatesOnNotifyDataErrors` and
    `ValidationRules` properties all relate to the use of the `ValidationRule` class.
    This is a very UI-related way of validating, but this puts our business logic
    right into our Views component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，三个`ValidatesOnDataErrors`、`ValidatesOnExceptions`、`ValidatesOnNotifyDataErrors`和`ValidationRules`属性都与`ValidationRule`类的使用有关。这是一种非常与UI相关的验证方式，但这将我们的业务逻辑直接放入我们的视图组件中。
- en: When using MVVM, we want to avoid this blending of components. We therefore
    tend to work with data elements rather than UI elements, and so we perform these
    kind of duties in our Data Model and/or View Model classes instead. We'll see
    this in [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml), *Implementing
    Responsive Data Validation*, later in the book, but now let's take a deeper look
    at the most important properties of the `Binding` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MVVM时，我们希望避免组件的这种混合。因此，我们倾向于使用数据元素而不是UI元素，所以我们在这我们的数据模型和/或视图模型类中执行这些类型的任务。我们将在本书的[第9章](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml)中看到这一点，*实现响应式数据验证*，稍后，现在让我们更深入地看看`Binding`类最重要的属性。
- en: Directing data bound traffic
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指导数据绑定流量
- en: The direction of data traversal in each binding is specified by the `Binding.Mode`
    property. There are four distinct directional instances declared in the `BindingMode`
    enumeration, plus an additional value. Let's first take a look at the directional
    values and what they represent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绑定中数据遍历的方向由`Binding.Mode`属性指定。`BindingMode`枚举中声明了四个不同的方向实例，以及一个额外的值。让我们首先看看这些方向值及其代表的意义。
- en: The first and most common value reflects the most common situation, where data
    flows from the binding source, say, one of our View Models, to the binding target,
    represented by a UI control. This binding mode is called **One-Way** and is specified
    by the `OneWay` enumeration instance. This mode is used primarily for display
    only, or read-only purposes, and situations where the data bound values cannot
    be altered in the UI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最常见的数据值反映了最常见的情况，即数据从绑定源流向绑定目标，例如，我们的视图模型之一，到UI控件。这种绑定模式称为**单向**，由`OneWay`枚举实例指定。这种模式主要用于仅显示或只读目的，以及数据绑定值无法在UI中更改的情况。
- en: The next most common direction of travel is represented by the `TwoWay` enumeration
    instance and signifies that data is free to travel both from our View Models to
    the UI controls and also in the opposite direction. This is the most commonly
    used mode when data binding to form controls, when we want the users' changes
    to be reflected in our View Models.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最常见的旅行方向由`TwoWay`枚举实例表示，表示数据可以自由地从我们的视图模型流向UI控件，也可以在相反方向上。这是在将数据绑定到表单控件时最常用的模式，当我们希望用户的更改反映在我们的视图模型中时。
- en: The third directional enumeration instance is the `OneWayToSource` instance
    and is the opposite to the `OneWay` instance. That is, it specifies that data
    can only travel from the binding target, represented by a UI control, to the binding
    source, for example, one of our View Models. This mode is also useful for capturing
    user inputted date, when we don't need to alter the data bound values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个方向枚举实例是`OneWayToSource`实例，它是`OneWay`实例的反面。也就是说，它指定数据只能从绑定目标（由UI控件表示）流向绑定源，例如，我们的一些视图模型之一。这种模式也适用于捕获用户输入的日期，当我们不需要更改绑定值的数据时。
- en: The final directional instance is similar to the `OneWay` instance, except that
    it only works once and is represented by the `OneTime` instance. While this mode
    will indeed only work one time, upon instantiation of its containing control,
    it will actually also update its value each time the `DataContext` property of
    the relevant binding is set. However, its purpose is that it provides better performance
    than the `OneWay` member and is only suitable for binding to non-changing data,
    so if the data will be updated, this is not the correct directional instance to
    use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方向实例与`OneWay`实例类似，但它只工作一次，并由`OneTime`实例表示。虽然这种模式确实只工作一次，但在其包含控件的实例化时，它实际上还会在每次设置相关绑定的`DataContext`属性时更新其值。然而，它的目的是提供比`OneWay`成员更好的性能，并且仅适用于绑定到非更改数据，因此如果数据将被更新，这不是正确的方向实例。
- en: The final instance is named `Default` and as the name hints, is the default
    value of the `Binding.Mode` enumeration. It directs the binding to use the binding
    mode that was declared from the specified target property. When each Dependency
    Property is declared, we can specify whether a One or **Two-Way** binding mode
    should be used by default. If this is not specifically declared, then the property
    will be assigned a One-Way mode. We'll see this explained in more detail later
    in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个实例命名为`Default`，正如其名所暗示的，是`Binding.Mode`枚举的默认值。它指示绑定使用从指定目标属性声明的绑定模式。当每个依赖属性被声明时，我们可以指定是否默认使用单向或**双向**绑定模式。如果没有特别声明，则该属性将被分配一个单向模式。我们将在本章后面更详细地解释这一点。
- en: Binding to different sources
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对不同源的绑定
- en: 'We generally set the binding source using the `FrameworkElement.DataContext`
    property. All UI controls extend the `FrameworkElement` class, so we can set our
    binding sources on any of them. This must be set for a binding to work, although
    it can be specified in the `Path` property, or inherited from ancestor controls,
    so it does not have to be explicitly set. Take a look at this simple example,
    which assumes that a suitable binding source has been correctly set on the parent
    control:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用`FrameworkElement.DataContext`属性来设置绑定源。所有UI控件都扩展了`FrameworkElement`类，因此我们可以在它们中的任何一个上设置我们的绑定源。这是绑定能够工作所必需的，尽管它可以在`Path`属性中指定，或者从祖先控件继承，因此不需要显式设置。请看这个简单的例子，它假设在父控件上已经正确设置了合适的绑定源：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we set the binding source of the first `TextBlock` to a `User` object
    and the path to the `Name` property from that source. The second is set likewise,
    but with the binding source path pointing to the `Age` property instead. Note
    that we have set the `DataContext` property to a `User` object on each `TextBox`
    control individually.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将第一个`TextBlock`的绑定源设置为`User`对象，并将路径设置为从该源到`Name`属性。第二个也是这样设置，但绑定源路径指向`Age`属性。请注意，我们已经将每个`TextBox`控件上的`DataContext`属性设置为`User`对象。
- en: 'While this is perfectly valid XAML, you can imagine how tiresome it would be
    to do this on every control that we want to data bind to in a large form. As such,
    we tend to take advantage of the fact that the `DataContext` property can inherit
    its value from any of its ancestor controls. In this way, we can simplify this
    code by setting the `DataContext` on the parent control instead:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是完全有效的XAML，你可以想象在大型表单中为每个我们想要进行数据绑定的控件这样做是多么的麻烦。因此，我们倾向于利用`DataContext`属性可以从其任何祖先控件继承其值的事实。通过这种方式，我们可以通过在父控件上设置`DataContext`来简化代码：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In fact, when developing each `Window` or `UserControl`, it is customary to
    set the `DataContext` on these top-level controls, so that every contained control
    will have access to the same binding source. This is why we create a View Model
    for each `Window` or `UserControl` and specify that each View Model is responsible
    for providing all of the data and functionality that its related View requires.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在开发每个`Window`或`UserControl`时，通常会在这些顶级控件上设置`DataContext`，以便每个包含的控件都可以访问相同的绑定源。这就是为什么我们为每个`Window`或`UserControl`创建一个`ViewModel`，并指定每个`ViewModel`负责提供其相关视图所需的所有数据和功能。
- en: 'There are a few alternative ways of specifying a binding source, other than
    setting the `DataContext` property. One way is to use the `Source` property of
    the binding and this enables us to explicitly override the binding source that
    is inherited from the parent `DataContext`, if one was set. Using the `Source`
    property, we are also able to data bind to resources, as we saw in our View Model
    Locator example, or static values, as shown in the following snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置`DataContext`属性之外，还有几种指定绑定源的方法。一种方法是使用绑定的`Source`属性，这使我们能够显式地覆盖从父`DataContext`继承的绑定源，如果设置了的话。使用`Source`属性，我们也能够将数据绑定到资源，就像我们在我们的`ViewModel`定位器示例中看到的那样，或者绑定到静态值，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another way involves the use of the `RelativeSource` property of the binding.
    Using this incredibly useful property of type `RelativeSource`, we can specify
    that we want to use the target control, or a parent of that control as the binding
    source.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法涉及使用绑定的`RelativeSource`属性。使用这种极其有用的`RelativeSource`类型属性，我们可以指定我们想要使用目标控件，或者该控件的父控件作为绑定源。
- en: 'It also enables us to override the binding source from the `DataContext` and
    is often essential when trying to data bind to View Model properties from `DataTemplate`
    elements. Let''s adjust the earlier `DataTemplate` for our `User` Data Model to
    output a property from its normal `DataContext` that is set by the `DataTemplate`,
    and one from the View Model that is set as the `DataContext` of the parent control,
    using the `AncestorType` property of the `RelativeSource` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使我们能够覆盖`DataContext`中的绑定源，并且在尝试从`DataTemplate`元素绑定到`ViewModel`属性时通常至关重要。让我们调整之前为我们的`User`数据模型创建的`DataTemplate`，以便输出由`DataTemplate`设置的普通`DataContext`中的属性，以及由父控件的`DataContext`设置的`ViewModel`中的属性，使用`RelativeSource`类的`AncestorType`属性：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that setting the `Mode` property, that specifies the relative position
    of the binding source compared to the binding target, is optional here. Using
    the `AncestorType` property implicitly sets the `Mode` property to the `FindAncestor`
    instance, so we can declare the same binding without it, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，设置指定绑定源相对于绑定目标的相对位置的`Mode`属性在这里是可选的。使用`AncestorType`属性隐式地将`Mode`属性设置为`FindAncestor`实例，因此我们可以不使用它来声明相同的绑定，如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Mode` property is of the `RelativeSourceMode` enumeration type, which
    has four members. We''ve already seen an example of one instance, the `FindAncestor`
    member, although this can be extended using the related `RelativeSource.AncestorLevel`
    property, which specifies which level of ancestor in which to look for the binding
    source. This property is only really useful if a control has multiple ancestors
    of the same type, as in this following simplified example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mode`属性是`RelativeSourceMode`枚举类型，它有四个成员。我们已经看到了一个实例的例子，即`FindAncestor`成员，尽管这可以通过相关的`RelativeSource.AncestorLevel`属性进行扩展，该属性指定了要查找绑定源的祖先级别。这个属性只有在控件有多个相同类型的祖先时才有实际意义，如下面的简化示例所示：'
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `TextBox` in this example will output the word `"Outer"` at runtime because
    we have declared that the binding source should be the second ancestor of type
    `StackPanel`. If the `AncestorLevel` property had been set to one or omitted from
    the binding, then the `TextBox` would output the word `"Inner"` at runtime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`TextBox`将在运行时输出单词`"Outer"`，因为我们已经声明绑定源应该是`StackPanel`类型的第二个祖先。如果将`AncestorLevel`属性设置为1或从绑定中省略，那么`TextBox`将在运行时输出单词`"Inner"`。
- en: 'The next `RelativeSourceMode` enumeration instance is `Self`, which specifies
    that the binding source is the same object as the binding target. Note that when
    using the `RelativeSource``.Self` property, the `Mode` property is implicitly
    set to the `Self` instance. We could use this property to data bind one property
    of a UI control to another, as in this following example, which sets the control''s
    width value to its `Height` property to ensure that it remains a square regardless
    of the width:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`RelativeSourceMode`枚举实例是`Self`，它指定绑定源与绑定目标相同。请注意，当使用`RelativeSource.Self`属性时，`Mode`属性会隐式设置为`Self`实例。我们可以使用此属性将UI控件的一个属性绑定到另一个，如下面的例子所示，它将控件的宽度值设置为它的`Height`属性，以确保它保持正方形，无论宽度如何：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `RelativeSource.TemplatedParent` property is only used to access the properties
    of controls from inside a `ControlTemplate`. The templated parent refers to the
    object that has the `ControlTemplate` applied to it. When using the `TemplatedParent`
    property, the `Mode` property is implicitly set to the `TemplatedParent` instance
    of the `RelativeSourceMode` enumeration. Let''s see an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeSource.TemplatedParent`属性仅用于从`ControlTemplate`内部访问控件的属性。模板父级是指应用了`ControlTemplate`的对象。当使用`TemplatedParent`属性时，`Mode`属性会隐式设置为`RelativeSourceMode`枚举的`TemplatedParent`实例。让我们看一个例子：'
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the templated parent is the instance of the `ProgressBar` that
    will have this template applied to it and so, using the `TemplatedParent` property,
    we are able to access the various properties of the `ProgressBar` class from within
    the `ControlTemplate`. Furthermore, any binding source that is data bound to the
    `Value` property of the templated parent will also be data bound to the `Text`
    property of this internal `TextBox` element.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，模板父级是应用此模板的`ProgressBar`实例，因此，使用`TemplatedParent`属性，我们能够从`ControlTemplate`内部访问`ProgressBar`类的各种属性。此外，任何绑定到模板父级`Value`属性的绑定源也将绑定到这个内部`TextBox`元素的`Text`属性。
- en: Moving on to the final `RelativeSource` property, `PreviousData` is only really
    useful when defining a `DataTemplate` for items in a collection. It is used to
    set the previous item in the collection as the binding source. While not often
    used, there can be situations where we need to compare values between neighboring
    items in a collection and we'll see a full example of this later in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是最后的`RelativeSource`属性，`PreviousData`在定义集合中项的`DataTemplate`时非常有用。它用于将集合中的前一个项设置为绑定源。虽然不常用，但在某些情况下，我们需要比较集合中相邻项的值，我们将在本章后面看到一个完整的例子。
- en: 'Although a far simpler option, the `ElementName` property of the `Binding`
    class also enables us to override the binding source set by the `DataContext`.
    It is used to data bind the property of one UI control to either the property
    of another control, or another property on the same control. The only requirement
    to use this property is that we need to name the element that we want to data
    bind to in our current control. Let''s see an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一个更简单的选项，但`Binding`类的`ElementName`属性也允许我们覆盖由`DataContext`设置的绑定源。它用于将一个UI控件的一个属性绑定到另一个控件的属性，或者同一控件上的另一个属性。使用此属性的唯一要求是我们需要在我们当前控件中命名我们想要数据绑定的元素。让我们看一个例子：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we have a `CheckBox` element and a `TextBlock` element. The
    `Visibility` property of the `TextBlock` element is data bound to the `IsChecked`
    property of the `CheckBox` element and we make use of the `BoolToVisibilityConverter`
    class that we saw earlier to convert the `bool` value to a `Visibility` instance.
    Therefore, when the user checks the `CheckBox` element, the `TextBlock` element
    will become visible.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`CheckBox`元素和一个`TextBlock`元素。`TextBlock`元素的`Visibility`属性绑定到`CheckBox`元素的`IsChecked`属性，并且我们使用了之前看到的`BoolToVisibilityConverter`类将`bool`值转换为`Visibility`实例。因此，当用户勾选`CheckBox`元素时，`TextBlock`元素将变为可见。
- en: 'The `ElementName` property can also be used as a shortcut to access the parent
    control''s `DataContext`. If we name our View `This` for example, then we can
    use the `ElementName` property from within a data template to data bind to a property
    from the parent View Model:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementName`属性也可以用作访问父控件的`DataContext`的快捷方式。如果我们把我们的视图命名为`This`，例如，那么我们就可以在数据模板中使用`ElementName`属性来绑定到父视图模型的一个属性：'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When specifying these alternative binding sources, it is important to know that
    we can only use one of these three different methods at once. If we were to set
    more than one of the binding `Source`, `RelativeSource`, or `ElementName` properties,
    then an exception would be thrown from the binding.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定这些替代绑定源时，重要的是要知道我们一次只能使用这三种不同方法中的一种。如果我们设置绑定`Source`、`RelativeSource`或`ElementName`属性中的多个，那么绑定将抛出一个异常。
- en: Binding with priority
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带优先级的绑定
- en: On the odd occasion, we may need to specify a number of source binding paths
    and want to map them to a single binding target property. One way that we can
    do this is to use the `MultiBinding` class and we'll see an example of this in
    the last section of this chapter. However, there is an alternative class that
    we can use that provides us with some additional functionality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在偶尔的情况下，我们可能需要指定多个源绑定路径，并将它们映射到单个绑定目标属性。我们可以做到这一点的一种方法是通过使用`MultiBinding`类，我们将在本章的最后部分看到一个例子。然而，还有一个我们可以使用的替代类，它为我们提供了一些额外的功能。
- en: The `PriorityBinding` class enables us to specify multiple bindings and gives
    each a priority, with the bindings that are declared first having the highest
    priority. The special functionality of this class is that it will display the
    value from the first binding that returns a valid value and if that is not the
    binding with the highest priority, it will then update the display with the value
    from the highest priority binding when it is successfully resolved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBinding`类使我们能够指定多个绑定，并为每个绑定指定一个优先级，声明最早的绑定具有最高的优先级。这个类的特殊功能是，它将显示第一个返回有效值的绑定值，如果不是最高优先级的绑定，那么当它成功解析时，它将更新显示为最高优先级绑定的值。'
- en: 'To clarify further, this enables us to specify a binding to a normal property
    that will resolve immediately, while the actual value that we want to data bind
    to is being downloaded, calculated, or otherwise being resolved over time. This
    enables us to supply a default image source while the actual required image is
    being downloaded, or to output a message until a calculated value is ready for
    display. Let''s look at a simple XAML example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明，这使我们能够指定一个绑定到正常属性，它将立即解析，而我们要数据绑定的实际值正在下载、计算或以其他方式在一段时间内被解决。这使得我们可以在实际所需的图像正在下载时提供默认图像源，或者在一个计算值准备好显示之前输出一条消息。让我们看看一个简单的XAML示例：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we set the `PriorityBinding` on the `TextBlock.Text`
    property and inside, specify two bindings. The first has the higher priority and
    has the actual property value that we want to display. Note that we set the `IsAsync`
    property to `True`, to specify that this binding will take some time to resolve
    and that it should not block the UI thread.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`TextBlock.Text`属性上设置了`PriorityBinding`，并在其中指定了两个绑定。第一个具有更高的优先级，并具有我们想要显示的实际属性值。请注意，我们将`IsAsync`属性设置为`True`，以指定此绑定将需要一些时间来解析，并且它不应该阻塞UI线程。
- en: 'The second binding is data bound to a normal property using a One-Way binding
    that simply outputs a message:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个绑定使用单向绑定绑定到一个正常属性，简单地输出一条消息：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By using the `PriorityBinding` element, this message will be output instantly
    and then updated with the actual value from the `SlowString` property when it
    is ready. Let's now move on and investigate one further type of `Binding` class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`PriorityBinding`元素，这条消息将立即输出，并在准备好时更新为`SlowString`属性的实际值。现在让我们继续前进，调查`Binding`类的一种更进一步的类型。
- en: Binding from within control templates
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制模板内的绑定
- en: 'A `TemplateBinding` is a particular type of binding that is used within `ControlTemplate`
    elements in order to data bind to the properties of the type that is being templated.
    It is very similar to the `RelativeSource.TemplatedParent` property that we discussed
    earlier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateBinding`是一种特定的绑定类型，用于在`ControlTemplate`元素内将数据绑定到正在模板化的类型的属性。它与我们在前面讨论的`RelativeSource.TemplatedParent`属性非常相似：'
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example from earlier that we have edited slightly, we see that declaring
    a `TemplateBinding` is far more straightforward and less verbose than performing
    the same binding using the `RelativeSource.TemplatedParent` property. Let''s remind
    ourselves what that looked like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们稍作编辑，我们看到声明一个`TemplateBinding`比使用`RelativeSource.TemplatedParent`属性执行相同的绑定要简单得多。让我们回忆一下它看起来是什么样子：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If possible, it is generally preferable to use a `TemplateBinding` instead of
    the `RelativeSource.TemplatedParent` property and although they perform the same
    connection in the binding, there are a few differences between them. For example,
    a `TemplateBinding` is evaluated at compile time, which enables faster instantiation
    of control templates, whereas a `TemplatedParent` binding is not evaluated until
    runtime.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，通常更倾向于使用`TemplateBinding`而不是`RelativeSource.TemplatedParent`属性，尽管它们在绑定中执行相同的连接，但它们之间有一些差异。例如，`TemplateBinding`是在编译时评估的，这使控制模板的实例化更快，而`TemplatedParent`绑定则是在运行时才进行评估。
- en: Furthermore, it is a simpler form of binding and is missing a number of the
    `Binding` class properties, such as `StringFormat` and `Delay`. In addition, it
    places the extra constraints on the user, that it is permanently set to have a
    binding mode of `OneWay` and both binding target *and* binding source must be
    Dependency Properties. It was designed to be used in a single place with a single
    purpose and in that situation, it does its job well and more efficiently than
    its counterpart.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它是一种更简单的绑定形式，缺少了`Binding`类的一些属性，例如`StringFormat`和`Delay`。此外，它对用户施加了额外的约束，即它永久设置为具有`OneWay`绑定模式，并且绑定目标和绑定源都必须是依赖属性。它被设计用于单一位置和单一目的，在这种情况下，它比其对应物做得更好，更有效率。
- en: Binding source changes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定源变更
- en: At times, we may need to make changes to our binding sources and have those
    changes propagate to the binding target controls. We may want to set default values
    on a new form, clear old form values, or even set form labels from our View Models.
    In order to do this, our View Models *must* implement the `INotifyPropertyChanged`
    interface and this is why we build this implementation into our base View Model
    class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要更改我们的绑定源，并使这些更改传播到绑定目标控件。我们可能希望在新的表单上设置默认值，清除旧表单值，甚至从我们的视图模型设置表单标签。为了做到这一点，我们的视图模型*必须*实现`INotifyPropertyChanged`接口，这也是为什么我们将此实现构建到我们的基视图模型类中的原因。
- en: When we data bind a binding source to a control in the UI, an event handler
    is attached to the `PropertyChanged` event of the source object. When a notification
    of a change to the property that is specified by the binding source property path
    is received, the control is updated with the new value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在UI中将绑定源数据绑定到控件时，会为源对象的`PropertyChanged`事件附加一个事件处理器。当接收到绑定源属性路径指定的属性变更通知时，控件会使用新值进行更新。
- en: It should be noted that the `PropertyChanged` event of the binding source will
    be `null` if no handler has specifically been attached and none of its properties
    have been data bound to UI controls. It is for this reason that we must always
    check for `null`, before raising this event.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，如果未特别附加处理器并且其任何属性都没有绑定到UI控件，绑定源的`PropertyChanged`事件将是`null`。正因为如此，我们在引发此事件之前必须始终检查`null`。
- en: All of the binding modes work in the direction of binding source to binding
    target, except for the `OneWayToSource` instance. However, only this and the `TwoWay`
    instance of the `Binding.Mode` enumeration propagate changes in the direction
    of the binding target to the binding source.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的绑定模式都是绑定源到绑定目标的方向，除了`OneWayToSource`实例。然而，只有这个和`Binding.Mode`枚举的`TwoWay`实例会传播绑定目标到绑定源方向的变化。
- en: When the binding is working in either of these modes, it attaches a handler
    to the target control to listen for changes to the target property. When it receives
    notification of a change to the target property, its behavior is determined by
    the value of the binding's `UpdateSourceTrigger` property.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定以这两种模式中的任何一种工作的时候，它会为目标控件附加一个处理器来监听目标属性的变化。当它收到目标属性变更的通知时，其行为由绑定`UpdateSourceTrigger`属性的值决定。
- en: This property is of the enumeration type `UpdateSourceTrigger`, which has four
    members. The most common is the `PropertyChanged` instance and this specifies
    that the source property should be updated as soon as the target property has
    changed. This is the default value for most controls.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性是枚举类型`UpdateSourceTrigger`，它有四个成员。最常见的是`PropertyChanged`实例，这表示源属性应在目标属性更改后立即更新。这是大多数控件默认的值。
- en: The `LostFocus` member is the next most common value and this specifies that
    the binding should update the binding source when the user moves focus from the
    data bound control. This option can be useful when we want to trigger validation
    once the user has completed entry in each textbox, rather than as they type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`LostFocus`成员是下一个最常见的值，它指定当用户将焦点从数据绑定的控件移开时，应该更新绑定源。当用户在每个文本框中完成输入后触发验证而不是在输入时，这个选项可能很有用。'
- en: The `Explicit` instance will not update the binding source without explicit
    instruction to do so. As we need to programmatically call the `UpdateSource` method
    of the internal `BindingExpression` object in order to propagate the changes to
    the binding source, this option is not generally used in our normal Views.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Explicit`实例不会在没有明确指令的情况下更新绑定源。由于我们需要以编程方式调用内部`BindingExpression`对象的`UpdateSource`方法来传播更改到绑定源，因此这个选项通常在我们的正常视图中不使用。'
- en: Instead, if used at all, we would find it in our `CustomControl` classes. Note
    that calling the `UpdateSource` method will do nothing if the binding mode is
    not set to one of the `OneWayToSource` or `TwoWay` instances.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果确实使用了它，我们会在我们的`CustomControl`类中找到它。请注意，如果绑定模式没有设置为`OneWayToSource`或`TwoWay`实例之一，调用`UpdateSource`方法将不会做任何事情。
- en: 'If we had an instance of a textbox and we wanted to explicitly update the binding
    source that was data bound to its `Text` property, we can access the lower-level
    `BindingExpression` object from the `BindingOperations.GetBindingExpression` method
    and call its `UpdateSource` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个文本框的实例，并且我们想要显式更新绑定到其`Text`属性的绑定源，我们可以从`BindingOperations.GetBindingExpression`方法访问低级别的`BindingExpression`对象，并调用它的`UpdateSource`方法：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Alternatively, if our binding target control class extends the `FrameworkElement`
    class and most do, then we can simply call the `GetBindingExpression` method on
    it directly and pass in the Dependency Property key that we want to update the
    binding from:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们的绑定目标控件类扩展了`FrameworkElement`类（大多数都是这样），那么我们可以直接调用它的`GetBindingExpression`方法，并传入我们想要更新绑定的依赖属性键：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The last member of the `UpdateSourceTrigger` enumeration is the `Default` instance.
    This is similar to the `Default` instance of the `Binding.Mode` enumeration in
    that it uses the value specified by each target Dependency Property and is the
    default value of the `UpdateSourceTrigger` property. Again, we'll find out how
    to set the metadata for Dependency Properties later in this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateSourceTrigger`枚举的最后一个成员是`Default`实例。这与`Binding.Mode`枚举的`Default`实例类似，因为它使用每个目标依赖属性的指定值，并且是`UpdateSourceTrigger`属性的默认值。同样，我们将在本章后面了解到如何设置依赖属性的元数据。'
- en: Converting data bound values
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换数据绑定值
- en: There are many times when developing a WPF application, when we need to convert
    a data bound property value to a different type. For example, we might want to
    control the visibility of some UI elements with a `bool` property in our View
    Model, so that we can avoid having the UI-related `Visibility` enumeration instance
    in it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发WPF应用程序时，我们经常需要将数据绑定的属性值转换为不同的类型。例如，我们可能希望使用ViewModel中的`bool`属性来控制一些UI元素的可见性，这样我们就可以避免在UI相关的`Visibility`枚举实例中包含它。
- en: 'We might want to convert different enumeration members to different `Brush`
    objects, or collections to `string` representations of the contained collection
    items. We''ve already seen a number of examples of the `IValueConverter` interface,
    but let''s now take a bit more of a thorough look:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要将不同的枚举成员转换为不同的`Brush`对象，或将集合转换为包含集合项的字符串表示。我们已经看到了许多`IValueConverter`接口的示例，但现在让我们更彻底地看看：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we've already seen, the `value` input parameter of type `object` is the data
    bound value of the binding. The `object` return type relates to the converted
    value that we want to return. The `targetType` input parameter specifies the type
    of the binding target property and is typically used to validate the input value
    to ensure that the converter is being used with the expected type of data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，类型为`object`的`value`输入参数是绑定的数据绑定值。`object`返回类型与我们要返回的转换后的值相关。`targetType`输入参数指定绑定目标属性的类型，通常用于验证输入值以确保转换器正在使用预期的数据类型。
- en: 'The `parameter` input parameter is optionally used to pass an additional value
    through to the converter. If used, its value can be set using the `Binding.ConverterParameter`
    property. Finally, the `culture` input parameter provides us with a `CultureInfo`
    object to correctly format textual output, when working in a culturally-sensitive
    application. We''ll return to this in a moment, but let''s first look at an example
    of a converter that uses the `parameter` input parameter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`parameter` 输入参数可选地用于将额外值传递给转换器。如果使用，其值可以使用 `Binding.ConverterParameter` 属性设置。最后，`culture`
    输入参数为我们提供了一个 `CultureInfo` 对象，以便在文化敏感的应用程序中正确格式化文本输出。我们稍后会回到这一点，但首先让我们看看一个使用 `parameter`
    输入参数的转换器示例：'
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The idea of this converter is that we can data bind an enumeration property
    to a `RadioButton` or `CheckBox` control that specifies the name of a particular
    member. If the value of the data bound property matches the specified member,
    then the converter will return true and check the control. For all other enumeration
    members, the control will be unchecked. We could then specify a different member
    in each of a group of `RadioButton` controls, so that each member could be set.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换器的想法是，我们可以将枚举属性数据绑定到一个指定特定成员名称的 `RadioButton` 或 `CheckBox` 控件。如果数据绑定属性的值与指定的成员匹配，则转换器将返回
    true 并选中控件。对于所有其他枚举成员，控件将不会被选中。然后我们可以在一组 `RadioButton` 控件中的每个控件中指定不同的成员，以便每个成员都可以设置。
- en: In the class, we start by specifying the data types that are involved in the
    implementation of the converter in the `ValueConversion` attribute. Next, we see
    the `IsInverted` property that we saw in the `BaseVisibilityConverter` class that
    enables us to invert the output of the converter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们首先在 `ValueConversion` 属性中指定了涉及转换器实现的 `ValueConversion` 数据类型。接下来，我们看到
    `IsInverted` 属性，它在 `BaseVisibilityConverter` 类中出现过，使我们能够反转转换器的输出。
- en: In the `Convert` method, we first check the validity of our `value` and `parameter`
    input parameters, and return the `DependencyProperty.UnsetValue` value if either
    are invalid. For valid values, we convert both parameters to their `string` representations.
    We then create a `bool` value by comparing the two `string` values. Once we have
    our `bool` value, we use it in conjunction with the `IsInverted` property to return
    the output value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Convert` 方法中，我们首先检查 `value` 和 `parameter` 输入参数的有效性，如果任一无效，则返回 `DependencyProperty.UnsetValue`
    值。对于有效值，我们将两个参数转换为它们的 `string` 表示形式。然后我们通过比较两个 `string` 值创建一个 `bool` 值。一旦我们有了
    `bool` 值，我们就用它结合 `IsInverted` 属性来返回输出值。
- en: As with our other enumeration converter example, the `ConvertBack` method implementation
    is a little different again, as we are unable to return the correct enumeration
    instance for a false value; it could be any value except the value specified by
    the `parameter` input parameter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的枚举转换器示例一样，`ConvertBack` 方法的实现又有所不同，因为我们无法为假值返回正确的枚举实例；它可以是除了由 `parameter`
    输入参数指定的值之外的任何值。
- en: As such, we are only able to return the specified enumeration instance if the
    data bound value is true and the `IsInverted` property is false, or if it is false
    and the `IsInverted` property is true. For all other input values, we simply return
    the `DependencyProperty.UnsetValue` property, which is preferred by the property
    system rather than the `null` value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只能在数据绑定值为 true 且 `IsInverted` 属性为 false，或者为 false 且 `IsInverted` 属性为 true
    的情况下返回指定的枚举实例。对于所有其他输入值，我们简单地返回 `DependencyProperty.UnsetValue` 属性，这是属性系统比 `null`
    值更倾向于的。
- en: 'Let''s see an example of this in use, with the `BitRate` enumeration that we
    saw in the previous chapter. Let''s first look at the simple View Model:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法在实际应用中的例子，我们将使用之前章节中看到的 `BitRate` 枚举。让我们首先看看简单的视图模型：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This class just contains a collection of type `BitRate`, which will hold all
    possible members and a selection property of type `BitRate`, which we will data
    bind to the various `RadioButton` elements using our new converter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只包含一个类型为 `BitRate` 的集合，它将包含所有可能的成员和一个类型为 `BitRate` 的选择属性，我们将使用我们的新转换器将这个属性数据绑定到各种
    `RadioButton` 元素。
- en: 'Note the use of the `FillWithMembers` Extension Method in the constructor.
    Let''s see that first:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在构造函数中使用了 `FillWithMembers` 扩展方法。让我们首先看看这个方法：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the `FillWithMembers` Extension Method, we first check that the collection
    that the method is called on is of an enumeration type and throw an `ArgumentException`
    if it's not. We then clear the collection, in case it has any pre-existing items
    in it. Finally, we iterate through the result of the `Enum.GetNames` method, parsing
    each `string` name to the relevant enumeration member and casting it to the correct
    type, before adding it to the collection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FillWithMembers`扩展方法中，我们首先检查被该方法调用的集合是否为枚举类型，如果不是，则抛出`ArgumentException`。然后我们清除集合，以防它包含任何预存在的项。最后，我们遍历`Enum.GetNames`方法的结果，将每个`string`名称解析到相关的枚举成员，并将其转换为正确的类型，然后将其添加到集合中。
- en: 'Let''s now see the XAML for the View:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看视图的XAML：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this View, we set up the `Converters` XAML namespace prefix and then declare
    an instance of the `EnumToBoolConverter` class in the `Resources` section. We
    then declare a `StackPanel` containing three `RadioButton` elements inside a `GroupBox`.
    Each `RadioButton` element is data bound to the same `BitRate` property from our
    View Model, using the converter from the resources.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们设置了`Converters` XAML命名空间前缀，然后在`Resources`部分声明了`EnumToBoolConverter`类的实例。然后我们声明了一个包含三个`RadioButton`元素的`StackPanel`，这些`RadioButton`元素使用资源中的转换器绑定到视图模型中的相同`BitRate`属性。
- en: 'Each button specifies a different enumeration member in its binding''s `ConverterParameter`
    property and this is passed through to the converter in the `parameter` input
    parameter. If a `RadioButton` is checked, its true value is passed to the converter
    and converted to the value specified by its `ConverterParameter` value and the
    `BitRate` property is updated with that value. The output of this code looks like
    the following figure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮在其绑定的`ConverterParameter`属性中指定不同的枚举成员，并通过`parameter`输入参数传递给转换器。如果选中`RadioButton`，则其真实值传递给转换器，并转换为`ConverterParameter`值指定的值，`BitRate`属性将更新为该值。此代码的输出如下所示：
- en: '![](img/c1662d27-2e6f-465f-8a7a-c4f855859850.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1662d27-2e6f-465f-8a7a-c4f855859850.png)'
- en: Note that if we had a large number of enumeration members, or the members were
    changed regularly, declaring each one manually in the UI like this example might
    not be such a good idea. In these cases, we could generate the same UI with less
    work, utilizing a `DataTemplate` object. We'll see an example of this later in
    this chapter, but for now, let's return to the input parameters of our converter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们有很多枚举成员，或者成员经常变动，像这个例子一样在UI中手动声明每一个可能不是好主意。在这些情况下，我们可以利用`DataTemplate`对象以更少的劳动生成相同的UI。我们将在本章后面看到这个例子，但现在，让我们回到转换器的输入参数。
- en: The final input parameter in the `Convert` and `ConvertBack` methods is the
    `culture` parameter of type `CultureInfo`. In non-international applications,
    we can simply ignore this parameter, however if globalization plays a part in
    your application, then using this parameter is essential.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Convert`和`ConvertBack`方法的最终输入参数是`CultureInfo`类型的`culture`参数。在非国际化应用程序中，我们可以简单地忽略此参数，但是如果在您的应用程序中全球化扮演了角色，那么使用此参数是必不可少的。
- en: It enables us to correctly format any textual output that we may have in our
    converter using the `object.ToString` method and keep it in line with the rest
    of the text in the application. We can also use it in the various `Convert` class
    methods to ensure that numerals are also correctly output in the right format.
    Globalization is beyond the scope of this book and so we'll move on now.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用`object.ToString`方法正确格式化转换器中可能有的任何文本输出，并使其与应用程序中的其他文本保持一致。我们还可以在`Convert`类的各种方法中使用它，以确保数字也以正确的格式正确输出。全球化超出了本书的范围，所以我们现在继续前进。
- en: Binding multiple sources to a single target property
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个源绑定到单个目标属性
- en: In WPF, there is another, more common way to data bind to multiple binding sources
    at once and to perform some sort of conversion from the various values to a single
    output value. In order to achieve this, we need to use a `MultiBinding` object
    in conjunction with a class that implements the `IMultiValueConverter` interface.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，还有另一种更常见的方法，可以同时将数据绑定到多个绑定源，并将各种值转换为单个输出值。为了实现这一点，我们需要使用一个`MultiBinding`对象，并结合实现`IMultiValueConverter`接口的类。
- en: The `MultiBinding` class enables us to declare multiple binding sources and
    a single binding target. If the `Mode` or `UpdateSourceTrigger` properties of
    the `MultiBinding` class are set, then their values are inherited by the contained
    `binding` elements, unless they have different values set explicitly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiBinding`类使我们能够声明多个绑定源和一个单一的绑定目标。如果`MultiBinding`类的`Mode`或`UpdateSourceTrigger`属性被设置，那么它们的值将被包含的`binding`元素继承，除非它们明确设置了不同的值。'
- en: The values from the multiple binding sources can be combined in one of two ways;
    their `string` representations can be output using the `StringFormat` property,
    or we can use a class that implements the `IMultiValueConverter` interface to
    generate the output value. This interface is very similar to the `IValueConverter`
    interface, but works with multiple data bound values instead.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 来自多个绑定源的价值可以通过两种方式之一组合；它们的`string`表示形式可以使用`StringFormat`属性输出，或者我们可以使用一个实现了`IMultiValueConverter`接口的类来生成输出值。这个接口与`IValueConverter`接口非常相似，但它与多个数据绑定值一起工作。
- en: When implementing the `IMultiValueConverter` interface, we do not set the `ValueConversion`
    attribute that we are accustomed to setting in the `IValueConverter` implementations
    that we have created.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`IMultiValueConverter`接口时，我们不会设置我们在创建的`IValueConverter`实现中习惯设置的`ValueConversion`属性。
- en: In the `Convert` method that we need to implement, the `value` input parameter
    of type `object` from the `IValueConverter` interface is replaced by an `object`
    array named `values`, which contains our input values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要实现的`Convert`方法中，来自`IValueConverter`接口的`value`输入参数类型`object`被一个名为`values`的`object`数组所取代，该数组包含我们的输入值。
- en: In the `ConvertBack` method, we have an array of type `Type` for the types of
    the binding targets and one of type `object` for the return types. Apart from
    these slight differences, these two interfaces are the same. Let's look at an
    example to help clarify the situation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConvertBack`方法中，我们有一个类型为`Type`的数组，用于绑定目标的类型，以及一个类型为`object`的数组，用于返回类型。除了这些细微的差异之外，这两个接口是相同的。让我们通过一个例子来帮助澄清这种情况。
- en: Imagine a scenario where a healthcare application needs to display a patient's
    weight measurements over time. It would be helpful if we could output an indicator
    of whether each consecutive measurement was higher or lower than the previous
    one, to highlight any unhealthy trends.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，一个医疗保健应用程序需要显示患者随时间变化的体重测量值。如果我们可以输出一个指标，指示每个连续测量值是高于还是低于前一个值，以突出任何不健康趋势，那将是有帮助的。
- en: 'This can be implemented using the `RelativeSource.PreviousData` property mentioned
    earlier, a `MultiBinding` object and an `IMultiValueConverter` class. Let''s first
    take a look at how we implement the `IMultiValueConverter` interface:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用前面提到的`RelativeSource.PreviousData`属性、一个`MultiBinding`对象和一个`IMultiValueConverter`类来实现。让我们首先看看我们如何实现`IMultiValueConverter`接口：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start our implementation with the customary validation of the input values.
    In this specific converter, we are expecting two values of type `int`, and so
    we use C# 6.0 Pattern Matching to verify that before continuing. If valid, we
    compare our two pre-cast values, returning the appropriate `string`-based direction
    arrow, dependent on the result of the comparison.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对输入值的常规验证开始我们的实现。在这个特定的转换器中，我们期望两个`int`类型的值，因此我们使用C# 6.0模式匹配来验证这些值，然后再继续。如果有效，我们比较我们两个预转换的值，根据比较的结果返回适当的基于`string`的方向箭头。
- en: 'As the `ConvertBack` method is not required for our example, we simply return
    an `object` array that contains two `DependencyProperty.UnsetValue` values. Let''s
    take a quick look at our View Model next:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的示例中不需要`ConvertBack`方法，我们只需返回一个包含两个`DependencyProperty.UnsetValue`值的`object`数组。接下来，让我们快速看一下我们的视图模型：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we have a very simple View Model, with just one field and property pair.
    We''ve just hardcoded a few test values to demonstrate with. Let''s now take a
    look at our View:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个非常简单的视图模型，只有一个字段和属性对。我们只是硬编码了一些测试值来演示。现在，让我们看看我们的视图：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After the `Converters` XAML namespace prefix and the declared `HigherLowerConverter`
    element in the `Resources` section, we have a bordered `ItemsControl` that is
    data bound to the `Weights` property of the View Model that is set as the `DataContext`
    of this View. Next, we see a horizontal `StackPanel` element being used as the
    `ItemsPanelTemplate` in the `ItemsControl.ItemsPanel` property. This simply makes
    the collection control display items horizontally instead of vertically.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Converters` XAML 命名空间前缀和 `Resources` 部分中声明的 `HigherLowerConverter` 元素之后，我们有一个带有边框的
    `ItemsControl`，它绑定到作为此视图 `DataContext` 的视图模型的 `Weights` 属性。接下来，我们看到一个水平方向的 `StackPanel`
    元素被用作 `ItemsControl.ItemsPanel` 属性的 `ItemsPanelTemplate`。这仅仅使得集合控件以水平方式显示项目，而不是垂直方式。
- en: Note that in the following `DataTemplate` object, we need to specify the data
    type and so need to import the `System` namespace from the `mscorlib` assembly
    to reference the `Int32` type. The binding to the `Text` property in the first
    `TextBlock` specifies that it is binding to the whole data source object, which
    is simply an integer in this case.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在下面的 `DataTemplate` 对象中，我们需要指定数据类型，因此需要从 `mscorlib` 程序集导入 `System` 命名空间来引用
    `Int32` 类型。第一个 `TextBlock` 中的 `Text` 属性的绑定指定它绑定到整个数据源对象，在这种情况下，它只是一个整数。
- en: 'The binding to the `Text` property in the second `TextBlock` is where we are
    using our `MultiBinding` and `IMultiValueConverter` elements. We set our `HigherLowerConverter`
    class to the `Converter` property of the `MultiBinding` object and inside this,
    we specify two `Binding` objects. The first is again binding to the integer value
    and the second uses the `RelativeSource.PreviousData` property to data bind to
    the previous integer value. Let''s now see the output of this example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `TextBlock` 中的 `Text` 属性的绑定是我们使用 `MultiBinding` 和 `IMultiValueConverter`
    元素的地方。我们将我们的 `HigherLowerConverter` 类设置为 `MultiBinding` 对象的 `Converter` 属性，并在其中指定两个
    `Binding` 对象。第一个再次绑定到整数值，第二个使用 `RelativeSource.PreviousData` 属性来绑定到前一个整数值。现在让我们看看这个示例的输出：
- en: '![](img/09b903b2-9263-430e-ad92-7534edfe58ff.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09b903b2-9263-430e-ad92-7534edfe58ff.png)'
- en: Each value after the first have an arrow displayed underneath, that specifies
    whether it is higher or lower than the previous value. While the visual output
    of this example could be improved, it does still highlight the worrying trend
    of the weight measurements continually increasing towards the end of the sample
    data. This useful technique can be used in any situation when we need to compare
    current data values with previous values, such as when displaying share prices,
    or stock levels.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值之后的每个值下面都会显示一个箭头，指示它是否高于或低于前一个值。虽然这个示例的视觉输出可以改进，但它仍然突出了令人担忧的趋势，即样本数据末尾的重量测量值持续增加。这种有用的技术可以在任何需要比较当前数据值与前一个值的情况下使用，例如在显示股价或库存水平时。
- en: Dependency Properties
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖属性
- en: 'We''ve already seen some examples of Dependency Properties in previous chapters,
    but now let''s take a more thorough look. We have a large number of options that
    we can use when declaring these properties, with some more commonly used than
    others. Let''s investigate the standard declaration first, by defining an `Hours`
    property of type `int` in a class named `DurationPicker`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中看到了一些依赖属性的示例，但现在让我们更深入地研究。当我们声明这些属性时，我们有大量选项可以使用，其中一些比其他更常用。让我们首先通过在名为
    `DurationPicker` 的类中定义一个类型为 `int` 的 `Hours` 属性来调查标准的声明。
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As with all Dependency Properties, we start by declaring the property as static
    and `readonly` because, we only want a single, immutable instance of it. This
    also enables us to access it without an instance of our class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有依赖属性一样，我们首先将属性声明为静态和 `readonly`，因为我们只希望有一个单一的、不可变的实例。这也使我们能够不通过我们类的实例来访问它。
- en: Unlike normal CLR properties, we do not store the values of our Dependency Properties
    in private fields that back the properties. Instead, default values are stored
    directly within the metadata of each `DependencyProperty` object and altered values
    are stored in a separate array in the `DependencyObject` instance that the Dependency
    Property value was set on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常的 CLR 属性不同，我们不是在支持属性的私有字段中存储我们的依赖属性值。相反，默认值直接存储在每个 `DependencyProperty` 对象的元数据中，而更改后的值存储在
    `DependencyObject` 实例的单独数组中，该实例上的依赖属性值被设置。
- en: Let's clarify this a little further and remember that all of the built-in controls
    extend the `DependencyObject` class. This means that the altered values of the
    `TextProperty` Dependency Property for example, which was declared in the `TextBox`
    class, are stored in the actual `TextBox` instance that the property value was
    changed on. This is the main reason why  bindings can only be set on a Dependency
    Property of a Dependency Object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步澄清这一点，并记住所有内置控件都扩展了 `DependencyObject` 类。这意味着例如 `TextBox` 类中声明的 `TextProperty`
    依赖属性更改后的值，存储在属性值被更改的实际 `TextBox` 实例中。这是绑定只能设置在依赖对象依赖属性上的主要原因。
- en: An array of values exists in each `DependencyObject` instance and contains the
    values of all of its declared Dependency Properties that have been explicitly
    set on it. This is a very important point. This means that by default, with no
    changed values, the array is empty and therefore, the memory footprint is very
    small.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `DependencyObject` 实例中都有一个值数组存在，包含所有已显式设置在其上的已声明的依赖属性值。这是一个非常重要的点。这意味着默认情况下，如果没有更改的值，数组是空的，因此内存占用非常小。
- en: This is converse to a CLR class, where each property has a memory footprint,
    whether it is set or not. The result of this arrangement is that it saves a huge
    amount of memory, because only Dependency Property values that have been explicitly
    set will be stored in the array of values, while default values are read directly
    from the Dependency Property objects instead.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 CLR 类相反，其中每个属性都有一个内存占用，无论它是否被设置。这种安排的结果是节省了大量的内存，因为只有显式设置的依赖属性值才会存储在值数组中，而默认值则直接从依赖属性对象中读取。
- en: The fact that this array of changed values exists in the `DependencyObject` class explains
    why we need to call its `GetValue` and `SetValue` methods to access and set the
    values of our Dependency Properties. Our `HoursProperty` here is merely the identifier, known
    as the **Dependency Property Identifier**, whose `GlobalIndex` property value
    is used to access the relevant value from that array.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组在 `DependencyObject` 类中存在的事实解释了为什么我们需要调用它的 `GetValue` 和 `SetValue` 方法来访问和设置依赖属性的值。这里的
    `HoursProperty` 仅仅是标识符，被称为**依赖属性标识符**，其 `GlobalIndex` 属性值用于从该数组访问相关值。
- en: Note that the values in this array are of type `object`, so that it can work
    with any object type. This explains why we need to cast the return value of the
    `GetValue` method from `object` to the appropriate type in the getter of our CLR
    wrapper property. Let's now examine what happens internally when we declare a
    Dependency Property.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个数组中的值是 `object` 类型，因此它可以与任何对象类型一起工作。这解释了为什么我们需要在 CLR 包装器属性的获取器中将 `GetValue`
    方法的返回值从 `object` 类型转换到适当类型。现在让我们检查当我们声明依赖属性时内部会发生什么。
- en: In the `DependencyProperty` class, there is a private static `Hashtable` named `PropertyFromName`,
    which holds references to every registered Dependency Property in the application
    and is shared among all instances of the class. To declare each property and create
    our key to the `Hashtable`, we use the `Register` method of the `DependencyProperty`
    class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DependencyProperty` 类中，有一个名为 `PropertyFromName` 的私有静态 `Hashtable`，它持有应用程序中每个已注册依赖属性的引用，并且被类的所有实例共享。为了声明每个属性并创建到
    `Hashtable` 的键，我们使用 `DependencyProperty` 类的 `Register` 方法。
- en: This method has a number of overloads, but all of them require the following
    information; the name and type of the property and the type of the declaring class,
    or *owner type* as Microsoft prefer to call it. Let's look into this process in
    a bit more depth.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有多个重载，但它们都需要以下信息：属性的名称和类型以及声明类的类型，或者微软更愿意称之为*所有者类型*。让我们更深入地了解一下这个过程。
- en: When we register a Dependency Property using one of the `Register` methods,
    the provided metadata is first validated and replaced with default values, if
    required. Then a private `RegisterCommon` method is called and inside it, a class
    named `FromNameKey` is used to generate the unique key from the name and owner
    type of the Dependency Property to create. It does this by creating a unique hash
    code, by combining the results from calling the `object.GetHashCode` method on
    both the name and owner type passed to it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Register` 方法之一注册依赖属性时，提供的元数据首先被验证，并在需要时替换为默认值。然后调用一个名为 `RegisterCommon`
    的私有方法，并在其中使用一个名为 `FromNameKey` 的类来从依赖属性的名称和所有者类型生成唯一的键。它是通过结合调用传递给它的名称和所有者类型的
    `object.GetHashCode` 方法的结果来创建一个唯一的哈希码来做到这一点的。
- en: After the `FromNameKey` object has been created, the `PropertyFromName` collection
    is checked for this key and an `ArgumentException` is thrown if one already exists
    within it. If it is unique, then the default metadata and default value are validated
    and set from input parameters, or automatically generated if missing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `FromNameKey` 对象之后，检查 `PropertyFromName` 集合中是否存在此键，如果其中已存在，则抛出 `ArgumentException`。如果它是唯一的，则从输入参数验证和设置默认元数据和默认值，如果缺失则自动生成。
- en: After this step, the actual `DependencyProperty` instance is created using the
    `new` keyword and a private constructor. This internal instance is then added
    to the `PropertyFromName` `Hashtable`, using the `FromNameKey` object as the unique
    key, and then returned to the caller of the `Register` method, to be stored locally
    in the public static `readonly` Dependency Property Identifier.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤之后，实际的 `DependencyProperty` 实例使用 `new` 关键字和私有构造函数创建。然后，将此内部实例添加到 `PropertyFromName`
    `Hashtable` 中，使用 `FromNameKey` 对象作为唯一键，然后将其返回给 `Register` 方法的调用者，以便在公共静态 `readonly`
    Dependency Property Identifier 中本地存储。
- en: Note that the overloaded `Register` methods both have an additional input parameter
    of type `PropertyMetadata` and we'll investigate this in the next section. For
    now, let's focus on the last overload, which also enables us to attach a `ValidateValueCallback`
    handler to our property.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重载的 `Register` 方法都有一个额外的输入参数类型为 `PropertyMetadata`，我们将在下一节中探讨这一点。现在，让我们专注于最后一个重载，它还使我们能够将
    `ValidateValueCallback` 处理器附加到我们的属性上。
- en: 'As the name suggests, this is solely used for validation purposes and we cannot
    alter the data bound value in this method. Instead, we are simply required to
    return `true` or `false` to specify the validity of the current value. Let''s
    see how we can attach this handler to our property and what its method signature
    is:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这仅用于验证目的，我们无法在此方法中更改数据绑定值。相反，我们只需返回 `true` 或 `false` 以指定当前值的有效性。让我们看看我们如何将此处理器附加到我们的属性，以及其方法签名是什么：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that the `ValidateValueCallback` delegate does not provide us with any
    reference to our class and so, we cannot access its other properties from this
    static context. In order to compare the current value with other property values,
    or to ensure that certain conditions are met, we can use another overload of the
    `PropertyMetadata` input parameter of the `DependencyProperty.Register` method
    and we'll see this shortly. But let's now return to focus on the `PropertyMetadata`
    input parameter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ValidateValueCallback` 委托不提供对我们类的任何引用，因此，我们无法从静态上下文中访问其其他属性。为了比较当前值与其他属性值，或者确保满足某些条件，我们可以使用
    `DependencyProperty.Register` 方法 `PropertyMetadata` 输入参数的另一个重载，我们很快就会看到。但现在，让我们回到关注
    `PropertyMetadata` 输入参数。
- en: Setting metadata
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置元数据
- en: 'Using the overloads of the `PropertyMetadata` constructor, we can optionally
    set a default value for the property and attach handlers to be called when the
    value changes, or when it is being re-evaluated. Let''s update our example to
    attach a `PropertyChangedCallback` handler now:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PropertyMetadata` 构造函数的重载，我们可以可选地为属性设置默认值，并附加在值更改或正在重新评估时被调用的处理器。现在让我们更新我们的示例，以附加一个
    `PropertyChangedCallback` 处理器：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that our `PropertyChangedCallback` handler must also be declared as static
    in order to be used from the static context of the declared `DependencyProperty`
    as shown in the preceding code. However, we may have a situation where we need
    to call an instance method rather than a static method and in these cases, we
    can declare an anonymous method that calls our instance method like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `PropertyChangedCallback` 处理器也必须声明为静态，以便可以从声明的 `DependencyProperty` 的静态上下文中使用，如前述代码所示。然而，我们可能遇到需要调用实例方法而不是静态方法的情况，在这些情况下，我们可以声明一个匿名方法来调用我们的实例方法，如下所示：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Anonymous methods comprised of Lambda expressions can appear confusing, so
    let''s first extract the relevant code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Lambda 表达式组成的匿名方法可能会令人困惑，所以让我们首先提取相关代码：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This could be re-written to make the example somewhat clearer:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以重写以使示例更加清晰：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we can clearly see the input parameters of the `PropertyChangedCallback`
    handler, followed by the anonymous method body. Inside this method, we simply
    cast the `dependencyObject` input parameter to the type of the declaring class
    and then call the non-static method from the cast instance of the class, passing
    the input parameters through, if required.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以清楚地看到`PropertyChangedCallback`处理程序的输入参数，然后是匿名方法体。在这个方法内部，我们只需将`dependencyObject`输入参数转换为声明类的类型，然后从类的转换实例调用非静态方法，如果需要，通过传递输入参数。
- en: As we saw in the [Chapter 2](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml), *Debugging
    WPF Applications*, the CLR properties that provide convenient access to our Dependency
    Properties will not be called by the WPF Framework when their values change. Using
    this `PropertyChangedCallback` handler is how we are able to perform actions upon
    value changes, or to debug the changing values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml)中看到的，*调试WPF应用程序*，当它们的值发生变化时，CLR属性（提供对我们依赖属性的方便访问）不会被WPF框架调用。使用这个`PropertyChangedCallback`处理程序是我们能够在值变化时执行操作或调试变化值的方法。
- en: 'The last overload of the `PropertyMetadata` constructor additionally enables
    us to set a `CoerceValueCallback` handler, which provides the platform for us
    to ensure that our values remain within valid ranges. Unlike the `PropertyChangedCallback`
    delegate, it requires us to return the output value of the property, so this enables
    us to alter the value before returning it. Here is a simple example that shows
    how we can adjust our property values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyMetadata`构造函数的最后一个重载版本还允许我们设置一个`CoerceValueCallback`处理程序，这为我们提供了一个平台，以确保我们的值保持在有效范围内。与`PropertyChangedCallback`委托不同，它要求我们返回属性的输出值，因此这使我们能够在返回之前更改值。以下是一个简单示例，展示了我们如何调整属性值：'
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this simple example, we first cast the `dependencyObject` input parameter,
    so that we can access its `MaximumValue` property. Let's assume that our `DurationPicker`
    control can work with either twelve or twenty-four hour time formats and so we
    need to determine the current upper hour limit. We can therefore constrain our
    `Hours` property value to be between one and this upper limit.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们首先将`dependencyObject`输入参数进行转换，以便我们可以访问其`MaximumValue`属性。假设我们的`DurationPicker`控件可以处理12小时或24小时的时间格式，因此我们需要确定当前的上限小时数。因此，我们可以将`Hours`属性值限制在1到这个上限之间。
- en: When using the `CoerceValueCallback` handler, there is a special case that enables
    us to effectively cancel a change in value. If your code detects what your requirements
    specify to be a wholly invalid value, then you can simply return the `DependencyProperty.UnsetValue`
    value from the handler.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`CoerceValueCallback`处理程序时，有一个特殊情况可以有效地取消值更改。如果你的代码检测到不符合要求的完全无效值，那么你可以简单地从处理程序中返回`DependencyProperty.UnsetValue`值。
- en: This value signals to the property system that it should discard the current
    change and return the previous value instead. You could even use this technique
    to selectively block changes to a property until a certain condition is met elsewhere
    in the class, for example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值向属性系统发出信号，表示它应该丢弃当前更改并返回之前的值。你甚至可以使用这种技术有选择地阻止属性更改，直到类中的其他地方满足某个条件，例如。
- en: That sums up the useful but fairly limited options that we have with our `PropertyMetadata`
    object, although it should be noted that there are a number of classes that derive
    from this class that we can use in its place and each have their own benefits.
    The `UIPropertyMetadata` class directly extends the `PropertyMetadata` class and
    adds the ability to disable all animations of the property value via its `IsAnimationProhibited`
    property.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了我们在`PropertyMetadata`对象上可用的有用但相当有限的选择，尽管应该注意的是，有一些从该类派生出来的类，我们可以用它们来代替，并且每个都有自己的优点。`UIPropertyMetadata`类直接扩展了`PropertyMetadata`类，并添加了通过其`IsAnimationProhibited`属性禁用属性值所有动画的能力。
- en: Additionally, the `FrameworkPropertyMetadata` class further extends the `UIPropertyMetadata`
    class and provides us with the ability to set property inheritance, the default
    `Binding.Mode` and `Binding.UpdateSourceTrigger` values of the property, and a
    variety of `FrameworkPropertyMetadataOptions` flags that affect layout.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`FrameworkPropertyMetadata`类进一步扩展了`UIPropertyMetadata`类，并为我们提供了设置属性继承、属性的默认`Binding.Mode`和`Binding.UpdateSourceTrigger`值以及影响布局的`FrameworkPropertyMetadataOptions`标志的能力。
- en: 'Let''s take a look at some of the `FrameworkPropertyMetadataOptions` members.
    If we think that most users will want to use Two-Way data binding with our property,
    then we can declare it with the `BindsTwoWayByDefault` instance. This has the
    effect of switching the `Binding.Mode` from the default `OneWay` member to the
    `TwoWay` member on all bindings to our property:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些`FrameworkPropertyMetadataOptions`成员。如果我们认为大多数用户会希望使用双向数据绑定来绑定我们的属性，那么我们可以使用`BindsTwoWayByDefault`实例来声明它。这会将所有绑定到我们的属性的`Binding.Mode`从默认的`OneWay`成员切换到`TwoWay`成员：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Another commonly used flag is the `Inherits` instance, which specifies that
    the property value can be inherited by child elements. Think of the `FontSize`
    or `Foreground` properties that can be set on a `Window` and inherited by each
    control inside it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的标志是`Inherits`实例，它指定属性值可以被子元素继承。想想看，可以在`Window`上设置的`FontSize`或`Foreground`属性，并且这些属性会被窗口内的每个控件继承。
- en: Note that if we want to create a Dependency Property using this `Inherits` member,
    then we should declare it as an Attached Property, as property value inheritance
    works better with Attached Properties. We will find out more about this soon,
    in a subsequent section, but now let's continue. Next is the `SubPropertiesDoNotAffectRender`
    member, which can be used to streamline performance, and we'll find out more about
    this particular instance in [Chapter 12](8fc90c0b-ca68-49ef-a77f-75173ca49f31.xhtml),
    *Deploying Your Masterpiece Application*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想使用这个`Inherits`成员来创建依赖属性，那么我们应该将其声明为一个附加属性，因为属性值继承与附加属性配合得更好。我们将在后续章节中了解更多关于这一点，但现在让我们继续。接下来是`SubPropertiesDoNotAffectRender`成员，它可以用来优化性能，我们将在[第12章](8fc90c0b-ca68-49ef-a77f-75173ca49f31.xhtml)，*部署您的杰作应用程序*中了解更多关于这个特定实例的信息。
- en: The last commonly used options are the `AffectsArrange`, `AffectsMeasure`, `AffectsParentArrange` and
    `AffectsParentMeasure` members. These are typically used with Dependency Properties
    that have been declared in custom panels, or other UI controls, where the property
    value affects the look of the control and changes to it need to cause a visual
    update.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后常用的选项是`AffectsArrange`、`AffectsMeasure`、`AffectsParentArrange`和`AffectsParentMeasure`成员。这些通常用于在自定义面板或其他UI控件中声明的依赖属性，其中属性值会影响控件的外观，并且对它的更改需要引起视觉更新。
- en: 'It should also be noted that this `FrameworkPropertyMetadataOptions` enumeration
    is declared with the `FlagsAttribute` attribute, which signifies that we can also
    allocate a bitwise combination of its instance values, and therefore set multiple
    options for each of our Dependency Properties:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意，这个`FrameworkPropertyMetadataOptions`枚举是用`FlagsAttribute`属性声明的，这意味着我们也可以为其实例值分配一个位运算组合，因此可以为每个依赖属性设置多个选项：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to set the default value for the `Binding.UpdateSourceTrigger` property,
    we need to use the most heavily populated constructor, passing all six input parameters:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置`Binding.UpdateSourceTrigger`属性的默认值，我们需要使用参数最多的构造函数，传递所有六个输入参数：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that it is perfectly fine to pass `null` values for the callback handlers,
    if we don't need to use them. The `false` after the `CoerceValueCallback` handler value
    sets the `IsAnimationProhibited` property of the `UIPropertyMetadata` class. The
    `UpdateSourceTrigger` value set here will be used on all bindings to this property
    that have not explicitly set the `UpdateSourceTrigger` property on the binding,
    or have set the `UpdateSourceTrigger.Default` member to the binding property.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们不需要使用回调处理程序，传递`null`值是完全正常的。`CoerceValueCallback`处理程序值后面的`false`设置了`UIPropertyMetadata`类的`IsAnimationProhibited`属性。这里设置的`UpdateSourceTrigger`值将用于所有没有在绑定上显式设置`UpdateSourceTrigger`属性，或者将`UpdateSourceTrigger.Default`成员设置为绑定属性的绑定的属性。
- en: Now that we have fully investigated the various options that we have when we
    declare Dependency Properties using the `Register` method of the `DependencyProperty`
    class, let's take a look at the another registration method from this class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全调查了使用`DependencyProperty`类的`Register`方法声明依赖属性时可以使用的各种选项，让我们看看这个类中的另一个注册方法。
- en: Declaring read-only Dependency Properties
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明只读依赖属性
- en: Typically, read-only Dependency Properties are most commonly found in custom
    controls in situations where we need to data bind to a value, but do not want
    it to be publicly accessible. It might be a property that holds some relation
    to an on screen visual, a mid calculation point, or previous value, but generally,
    we don't want the users of our framework to be able to data bind to it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只读依赖属性最常见于自定义控件中，在这些情况下，我们需要将数据绑定到一个值，但又不希望它公开可访问。这可能是一个与屏幕上的视觉元素、中间计算点或前一个值相关联的属性，但通常，我们不希望我们的框架用户能够将其数据绑定到它。
- en: 'Let''s imagine a scenario where we want to create a button that will enable
    us to set a tooltip message to display when the control is disabled, in addition
    to the normal tooltip message. In this case, we could declare one Dependency Property
    to hold the disabled tooltip message and another to store the value of the original
    tooltip when displaying the disabled tooltip. This original tooltip property is
    a perfect candidate to be a read-only Dependency Property. Let''s see what this
    property looks like:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个场景，我们想要创建一个按钮，它将使我们能够设置一个工具提示消息，当控件禁用时显示，除了正常的工具提示消息。在这种情况下，我们可以声明一个依赖属性来保存禁用时的工具提示消息，另一个来存储显示禁用工具提示时的原始工具提示值。这个原始工具提示属性是成为只读依赖属性的完美候选。让我们看看这个属性的样子：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, we use a different syntax to declare read-only Dependency Properties.
    Instead of returning the `DependencyProperty` identifier that is returned from
    the `Register` method, the `RegisterReadOnly` method returns a `DependencyPropertyKey`
    object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用不同的语法来声明只读依赖属性。不是返回`Register`方法返回的`DependencyProperty`标识符，而是`RegisterReadOnly`方法返回一个`DependencyPropertyKey`对象。
- en: This object is typically declared with a `private` access modifier, to stop
    it from being externally used with the `DependencyObject.SetValue` method. However,
    this method can be used within the class that registered the read-only property
    to set its value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象通常使用`private`访问修饰符声明，以防止它通过`DependencyObject.SetValue`方法在外部使用。然而，这个方法可以在注册只读属性的类中使用，以设置其值。
- en: The `DependencyProperty` property of the `DependencyPropertyKey` object is used
    to return the actual `DependencyProperty` identifier that is used to access the
    property value from the dictionary that we discussed earlier.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyPropertyKey`对象的`DependencyProperty`属性用于返回实际使用的`DependencyProperty`标识符，从我们之前讨论的字典中访问属性值。'
- en: The input parameters of the `RegisterReadOnly` methods offer the same options
    as those of the standard `Register` method, although there is one less overload.
    Unlike the `Register` method, when calling the `RegisterReadOnly` methods, we
    always need to provide the `PropertyMetadata` object, although we can pass a `null`
    value if we do not need what it provides.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterReadOnly`方法的输入参数与标准`Register`方法的选项相同，尽管有一个较少的重载。与`Register`方法不同，在调用`RegisterReadOnly`方法时，我们始终需要提供`PropertyMetadata`对象，尽管如果我们不需要它提供的内容，我们可以传递一个`null`值。'
- en: One very important point to note is that when data binding to a read-only Dependency
    Property, we *must* set the binding `Mode` property to the `OneWay` enumeration
    member. Failure to do so will result in an error at runtime. We've now covered
    the creation of normal Dependency Properties in some detail, so let's move on
    to take a look at a different kind Dependency Property.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个非常重要的问题是，当数据绑定到一个只读依赖属性时，我们必须将绑定的`Mode`属性设置为`OneWay`枚举成员。未能这样做将在运行时导致错误。我们已经详细介绍了正常依赖属性的创建，现在让我们继续看看不同类型的依赖属性。
- en: Registering Attached Properties
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册附加属性
- en: The `DependencyProperty` class enables us to register one further, special type
    of Dependency Property. These properties are like the Extension Methods of XAML,
    as they enable us to extend existing classes with our own functionality. They
    are of course, Attached Properties.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyProperty`类使我们能够注册一种更进一步的、特殊的依赖属性类型。这些属性类似于XAML的扩展方法，因为它们使我们能够通过我们自己的功能扩展现有的类。当然，它们是附加属性。'
- en: We've already seen some examples of them earlier in this book and we'll see
    further examples later, but in this chapter, we'll cover their registration. We
    can declare Attached Properties in exactly the same ways that we can create Dependency
    Properties and have all of the same various options of setting metadata and attaching
    handlers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的早期部分看到了一些它们的示例，我们将在后面看到更多示例，但在这个章节中，我们将介绍它们的注册。我们可以以完全相同的方式声明附加属性，就像我们创建依赖属性一样，并且有所有相同的设置元数据和附加处理程序的各种选项。
- en: 'There are several overloads of the `RegisterAttached` and `RegisterAttachedReadOnly`
    methods that mirror the `Register` and `RegisterReadOnly` methods in input parameters
    and functionality. However, instead of declaring a CLR wrapper for our Attached
    Properties, we are required to declare a pair of getter and setter methods to
    access and set their values. Let''s see another example from the `TextBoxProperties`
    class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterAttached` 和 `RegisterAttachedReadOnly` 方法有几个重载，它们在输入参数和功能上与 `Register`
    和 `RegisterReadOnly` 方法相对应。然而，我们不需要为我们的附加属性声明 CLR 包装器，而是需要声明一对获取器和设置器方法来访问和设置它们的值。让我们看看
    `TextBoxProperties` 类的另一个示例：'
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we have the declaration of a `bool` Attached Property named `IsFocused`
    with a `PropertyMetadata` element that specifies a default value and a `PropertyChangedCallback`
    handler. Like the CLR property wrappers for Dependency Properties, these getter
    and setter methods will not be called by the WPF Framework. They are typically
    declared both public and static.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为 `IsFocused` 的 `bool` 附加属性，它包含一个 `PropertyMetadata` 元素，用于指定默认值和
    `PropertyChangedCallback` 处理程序。与依赖属性的 CLR 属性包装器一样，这些获取器和设置器方法不会被 WPF 框架调用。它们通常被声明为公共和静态。
- en: However, there is one situation where we do not need to declare these methods
    as public. If we want to create a Dependency Property whose value can be inherited
    by its children, then we should declare it using the `RegisterAttached` method,
    even if we don't require an Attached Property. In this situation, we are not required
    to publicly expose our property getter and setter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种情况下我们不需要将这些方法声明为公共的。如果我们想创建一个可以由其子元素继承值的依赖属性，那么我们应该使用 `RegisterAttached`
    方法来声明它，即使我们不需要附加属性。在这种情况下，我们不需要公开暴露我们的属性获取器和设置器。
- en: Although we can specify the `FrameworkPropertyMetadataOptions.Inherits` metadata
    option upon the declaration of Dependency Properties and their value inheritance
    might work in some situations, it is not guaranteed in other situations. As Attached
    Properties are global properties in the property system, we can be assured that
    their property value inheritance will work in all situations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在声明依赖属性及其值继承时指定 `FrameworkPropertyMetadataOptions.Inherits` 元数据选项，并且在某些情况下值继承可能有效，但在其他情况下并不保证。由于附加属性是属性系统中的全局属性，我们可以确信它们的属性值继承将在所有情况下都有效。
- en: Returning to our example, our `PropertyChangedCallback` handler is a simple
    affair. It casts the `dependencyObject` property to the type of control that the
    property is attached to, in this case, a `TextBox`. It then verifies that the
    data bound `bool` value has been set from `false` to `true` and that the control
    is not already focused. If these conditions are verified, the control is then
    focused.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，我们的 `PropertyChangedCallback` 处理程序是一个简单的事件。它将 `dependencyObject` 属性转换为属性附加到的控件类型，在本例中是一个
    `TextBox`。然后它验证数据绑定的 `bool` 值是否已从 `false` 设置为 `true`，并且控件尚未聚焦。如果这些条件得到验证，控件随后将被聚焦。
- en: 'This Attached Property can be data bound to a `bool` property in a View Model
    like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此附加属性可以像这样绑定到视图模型中的 `bool` 属性：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The attached `TextBox` control can then be focused from the View Model at any
    time using this following method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的 `TextBox` 控件可以通过以下方法在任何时候从视图模型中聚焦：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that we need to ensure that the variable is `false` before setting it to
    `true`, as it is the actual changing of the value that will trigger the control
    to become focused. Now that we know how to declare our own custom Dependency Properties,
    let's turn our attention to the rules that govern the way they are set.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在将其设置为 `true` 之前，我们需要确保变量是 `false`，因为实际更改值将触发控件聚焦。现在我们已经知道了如何声明我们自己的自定义依赖属性，让我们将注意力转向管理它们设置的规则。
- en: Prioritizing value setting sources
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先设置值来源
- en: As we have already seen, there are a number of ways of setting the values of
    Dependency Properties; we can set them directly in code, locally in XAML, or through
    the use of our `CoerceValueCallback` handlers for example. However, there are
    many more ways that they can be set. For example, they can also be set in styles,
    animations, or through property inheritance to name but a few.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，有几种方法可以设置依赖属性值；我们可以在代码中直接设置它们，在 XAML 中本地设置，或者通过使用我们的 `CoerceValueCallback`
    处理程序，例如。然而，还有许多其他方法可以设置它们。例如，它们也可以在样式、动画或通过属性继承中设置，仅举几例。
- en: 'When we data bind our View Model properties to Dependency Properties and find
    that the displayed value is not what we are expecting, one reason for this can
    be because another method of setting the property has a higher precedence and
    so, overrides our expected value. This is because all the methods of setting the
    values of Dependency Properties are ordered in terms of importance in a list called
    the Dependency Property Setting Precedence List. Let''s take a look at that now:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 View Model 属性数据绑定到依赖属性，并发现显示的值不是我们期望的值时，其中一个原因可能是因为另一种设置属性的方法具有更高的优先级，因此覆盖了我们的期望值。这是因为所有设置依赖属性值的方法都按照重要性顺序排列在一个称为依赖属性设置优先级列表的列表中。现在让我们看看这个列表：
- en: Property system coercion
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性系统强制转换
- en: Animated properties
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画属性
- en: Local value
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地值
- en: Template properties
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板属性
- en: Implicit style (only applies to the `Style` property)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐式样式（仅适用于 `Style` 属性）
- en: Style triggers
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式触发器
- en: Template triggers
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板触发器
- en: Style setters
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式设置器
- en: Default (theme) style
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认（主题）样式
- en: Inheritance
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承
- en: Default value from Dependency Property metadata
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从依赖属性元数据中获取的默认值
- en: 'Last on the list, with the lowest precedence at position eleven, are the default
    values that are specified in the Dependency Property declarations. Next up the
    list are changes caused by property inheritance. Remember that this can be defined
    in our Dependency Properties using the `Inherits` instance of the `FrameworkPropertyMetadataOptions`
    enumeration in the `FrameworkPropertyMetadata` input parameter of the `DependencyProperty.Register`
    method. Let''s see an example of this to highlight this order of precedence:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的末尾，优先级最低的是在依赖属性声明中指定的默认值。接下来是属性继承引起的变化。请记住，这可以在我们的依赖属性中使用 `DependencyProperty.Register`
    方法的 `FrameworkPropertyMetadata` 输入参数中的 `FrameworkPropertyMetadataOptions.Inherits`
    实例来定义。让我们看看一个例子来突出这个优先级顺序：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this first example, the `TextBlock` control in the outer `StackPanel` has
    its `Foreground` color set to black by the default value that was set in the data
    bound `Text` property. However, the `TextBlock` control inside the inner `StackPanel`
    has its default `Foreground` property value overridden by the `TextElement.Foreground`
    Attached Property value that is set on its parent control. It inherits the value
    of this property from the `StackPanel` and this demonstrates that properties set
    through property inheritance have a higher precedence than properties set with
    default values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，外层 `StackPanel` 中的 `TextBlock` 控件的 `Foreground` 颜色默认设置为黑色，这是在数据绑定的
    `Text` 属性中设置的。然而，内层 `StackPanel` 中的 `TextBlock` 控件的默认 `Foreground` 属性值被其父控件的 `TextElement.Foreground`
    附加属性值覆盖，该值设置在其父控件上。它从 `StackPanel` 继承了这个属性的值，这表明通过属性继承设置的属性优先级高于使用默认值设置的属性。
- en: 'However, default property values that are set in theme styles follow on the
    precedence list, with the next lowest priority, and override property values set
    through inheritance. As it is quite difficult to come up with a short XAML example
    for this, we''ll skip over this item and move onto the next. At number eight on
    the list, we have property values that have been set by style setters. Let''s
    adjust our earlier example to demonstrate this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在主题样式中设置的默认属性值在优先级列表中紧随其后，具有下一个最低的优先级，并覆盖了通过继承设置的属性值。由于很难给出一个简短的 XAML 示例来说明这一点，我们将跳过这一项，并继续下一项。在列表中排在第八位的是由样式设置器设置的属性值。让我们调整我们之前的例子来演示这一点：
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, the `TextBlock` control in the outer `StackPanel` still has
    its `Foreground` color set to black by the default value of the data bound `Text`
    property. The top `TextBlock` control inside the inner `StackPanel` still has
    its default `Foreground` property value overridden by the `TextElement.Foreground`
    value from its parent control. However, now we can also see that values that are
    set in a `Style` will override inherited property values. This is the output of
    this code snippet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，外层`StackPanel`中的`TextBlock`控件仍然通过数据绑定`Text`属性的默认值将其`Foreground`颜色设置为黑色。内层`StackPanel`中的顶部`TextBlock`控件仍然通过其父控件的`TextElement.Foreground`值覆盖了其默认的`Foreground`属性值。然而，现在我们还可以看到，在`Style`中设置的值将覆盖继承的属性值。这是此代码片段的输出：
- en: '![](img/cfd1682a-3687-49e2-90ba-7fcc62032f68.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfd1682a-3687-49e2-90ba-7fcc62032f68.png)'
- en: 'Next, at number seven on the precedence list, we have template triggers, which
    override property values that are set with style setters and all other previously
    mentioned methods of setting values. Note that this specifically deals with triggers
    that are declared within templates, such as the `ControlTemplate`, and does not
    relate to triggers that are declared within any `Style.Triggers` collections.
    Let''s look at an example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在优先级列表的第七位，我们有模板触发器，它们覆盖了由样式设置器和之前提到的所有其他设置值方法设置的属性值。请注意，这专门处理在模板中声明的触发器，例如`ControlTemplate`，而不涉及在`Style.Triggers`集合内声明的触发器。让我们看一个例子：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, we have declared a button and overridden its `ControlTemplate`,
    defining a new, minimal markup for it. In the style, we have set the `Foreground`
    property value to green in a setter. However, in our `ControlTemplate`, we have
    a `Trigger` that will override this value and set it to blue when its condition
    is met. Note that if we changed the trigger condition to `false` or removed the
    whole trigger, the button text would then become green, as set by the style.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了一个按钮并覆盖了它的`ControlTemplate`，为它定义了一个新的、最小化的标记。在样式设置中，我们将`Foreground`属性值设置为绿色。然而，在我们的`ControlTemplate`中有一个`Trigger`，当其条件满足时，将覆盖这个值并将其设置为蓝色。请注意，如果我们将触发条件更改为`false`或删除整个触发器，按钮文本将变为绿色，这是由样式设置的。
- en: 'Next up the list at position six are triggers that are declared within `Style.Triggers`
    collections. One important point to note here is that this only relates to styles
    that are either declared inline locally, in the current control''s `Resources`
    section, or in the application resources file and not to default styles, which
    have a lower precedence value. We can extend our previous example by adding a
    new trigger into the `Style.Triggers` collection to highlight this new priority:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的第六位，是声明在`Style.Triggers`集合内的触发器。这里的一个重要点是，这仅与声明为内联本地、当前控件`Resources`部分或应用程序资源文件中的样式相关，而不是与具有较低优先级值的默认样式相关。我们可以通过向`Style.Triggers`集合中添加一个新的触发器来扩展我们之前的示例，以突出这个新优先级：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When running this example, our text is now orange. The `Foreground` property
    value that is set by the trigger in the `Triggers` collection of the style has
    overridden the value set by the template trigger, which itself has overridden
    the value set by the style setter. Let's move on.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个示例时，我们的文本现在是橙色。由样式`Triggers`集合中的触发器设置的`Foreground`属性值覆盖了由模板触发器设置的值，而模板触发器本身又覆盖了由样式设置器设置的值。让我们继续。
- en: 'At number five on the list, we have implicit styles. Note that this special
    level of precedence only applies to the `Style` property and no others. A style
    can be implicitly set to all members of a type by specifying the target type and
    being declared without an `x:Key` directive set. Here is an example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的第五位，我们有隐式样式。请注意，这个特殊的优先级级别仅适用于`Style`属性，不适用于其他属性。可以通过指定目标类型并在没有设置`x:Key`指令的情况下声明来隐式地将样式设置为类型的所有成员。以下是一个示例：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The relevant style must either be declared in the current XAML page, or the
    `Application.Resources` section of the `App.xaml` file. Styles from themes are
    not included here, as they have a lower value precedence. Note that this special
    position in the list was only added in .NET 4 and is omitted from the .NET 3 documentation
    on the [docs.microsoft.com](http://docs.microsoft.com) website.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 相关样式必须在当前XAML页面中声明，或者位于`App.xaml`文件的`Application.Resources`部分。主题中的样式不包括在内，因为它们具有较低的值优先级。请注意，这个特殊位置在.NET
    4中才被添加，并且在.NET 3的[docs.microsoft.com](http://docs.microsoft.com)网站上的文档中被省略。
- en: 'Next up the list at position four are properties that are set within either
    a `ControlTemplate` or a `DataTemplate`. If we set a property directly on any
    element within a template, that value will override all values set by methods
    with lower precedence. For example, if we directly set the `Foreground` property
    on the `ContentPresenter` from our previous example, then its value will override
    all other settings in that example and the button text will be red:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来列表的第四个位置是设置在 `ControlTemplate` 或 `DataTemplate` 内部的属性。如果我们直接在模板内的任何元素上设置属性，该值将覆盖所有优先级较低的设置方法设置的所有值。例如，如果我们直接在我们的上一个示例中的
    `ContentPresenter` 上设置 `Foreground` 属性，那么它的值将覆盖该示例中的所有其他设置，按钮文本将变为红色：
- en: '[PRE63]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At position three on the list, we have locally set values. To demonstrate this,
    we could just set the `Foreground` property on the actual button from the last
    full example, but instead let''s highlight an extremely common mistake that a
    lot of developers make. Imagine a situation where we want to output a value predominantly
    in one color, but in another color under certain circumstances. Some developers
    might try something like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的第三个位置，我们有局部设置的值。为了演示这一点，我们可以在最后一个完整示例中的实际按钮上设置 `Foreground` 属性，但让我们强调一个很多开发者都会犯的极其常见的错误。想象一下，我们想要在大多数情况下以一种颜色输出值，但在某些情况下以另一种颜色输出。一些开发者可能会尝试这样做：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Upon running this example, some might expect this to work and be stumped when
    it doesn''t. The reason why this doesn''t work is because local property settings
    have a higher value setting precedence than properties set by style triggers.
    The solution to correcting this mistake is to use our new found knowledge of this
    value setting precedence list and move the local property setting to a style setter,
    which has a lower precedence than the trigger:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个示例时，有些人可能会期望它能够正常工作，但结果却令人困惑。这个不工作的原因是因为局部属性设置具有比由样式触发器设置的属性更高的值设置优先级。纠正这个错误的解决方案是利用我们新发现的价值设置优先级列表，并将局部属性设置移动到样式设置器，其优先级低于触发器：
- en: '[PRE65]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, the `TextBlock.Foreground` property will be set to green from the style
    setter and overridden by the trigger when the condition is true, as expected.
    Let''s continue up the list to position two. In the penultimate position, we have
    property values that are set by animations. A very simple example can demonstrate
    this nicely for us:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`TextBlock.Foreground` 属性将由样式设置器设置为绿色，并在条件为真时被触发器覆盖，正如预期的那样。让我们继续向上列表到第二个位置。在倒数第二个位置，我们有由动画设置的属性值。一个非常简单的例子可以很好地向我们展示这一点：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this example, the animation overrides the locally set value of the `Width`
    property and the rectangle grows and shrinks as planned. If we think logically
    about this, then it is clear that the animation system had to feature at a very
    high position on the property setting precedence list. Otherwise, if it was much
    lower down the list, we wouldn't be able to animate anything.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，动画覆盖了局部设置的 `Width` 属性值，矩形按计划增长和缩小。如果我们逻辑上思考这个问题，那么很明显，动画系统必须在属性设置优先级列表中占据一个非常高的位置。否则，如果它在列表中位置较低，我们就无法进行任何动画。
- en: However, properties that are set by animations are at number two of the list,
    which means that there is one place that a property can be set that will override
    even values set by animations. At number one on the list of Dependency Property
    Setting Precedence, with the absolutely highest priority setting, is the property
    coercion system that we discussed in the *Dependency Properties* section.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由动画设置的属性在列表中排在第二位，这意味着有一个地方可以设置属性，即使是由动画设置的值也可以覆盖。在依赖属性设置优先级列表中排在第一位，具有绝对最高优先级设置的是我们在
    *依赖属性* 部分讨论过的属性强制系统。
- en: This could only really happen if we built a custom control that animated a custom
    Dependency Property that had particular requirements placed upon it, such as specifying
    that it should have a certain maximum or minimum value. In this case, we could
    enforce these rules in a `CoerceValueCallback` handler that is attached to the
    Dependency Property.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况只可能发生在我们构建了一个自定义控件，该控件动画化了一个具有特定要求的自定义依赖属性的情况下，例如指定它应该具有某个最大值或最小值。在这种情况下，我们可以在附加到依赖属性的
    `CoerceValueCallback` 处理程序中强制执行这些规则。
- en: If we had these requirements that were enforced by the property coercion system,
    yet wanted to animate them in the UI, it again makes perfect sense that we would
    want our coerced values to override the values set by the animation. In this way,
    we could rest assured that our coerced property values will remain within the
    bounds that we set for them at all times.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这些由属性强制系统强制执行的请求，但希望在UI中动画化它们，那么我们希望强制值覆盖动画设置的值，这又完全合理。这样，我们可以确信我们的强制属性值将始终在我们为其设置的范围内。
- en: Data templates
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模板
- en: We've already seen a number of simple examples of the `DataTemplate`, but they
    are such an important part of WPF that we're going to have a much more thorough
    look at them now. In short, we use a `DataTemplate` to define how we want particular
    data objects to be rendered in the UI*.*
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多简单的`DataTemplate`示例，但它们是WPF的重要组成部分，因此我们现在将更深入地研究它们。简而言之，我们使用`DataTemplate`来定义我们希望在UI中渲染特定数据对象的方式*。
- en: 'If we were to data bind a particular type of object to a UI control without
    providing a `DataTemplate` for it, the WPF Framework would not know how to display
    it. Let''s highlight this with an example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供特定类型的`DataTemplate`并将其数据绑定到UI控件，WPF框架将不知道如何显示它。让我们用一个例子来强调这一点：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In these cases, the best job that the WPF Framework can do is to display a
    `string` representation of each object. It achieves this by calling the `object.ToString`
    method on the data object and setting that value to the `Text` property of a `TextBlock`,
    which it uses to display the object. If this method has not been overridden in
    the object''s class, this will result in the name of the type of the object being
    displayed in its place:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，WPF框架能做的最好的事情就是显示每个对象的`string`表示形式。它是通过在数据对象上调用`object.ToString`方法并将该值设置为`TextBlock`的`Text`属性来实现的，它使用该属性来显示对象。如果此方法在对象的类中未被重写，这将导致在显示位置显示对象的类型名称：
- en: '![](img/57fd0723-8636-47a6-81ee-773a778a5d4b.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57fd0723-8636-47a6-81ee-773a778a5d4b.png)'
- en: 'Knowing that the WPF Framework will call the `ToString` method on our data
    objects before displaying them enables us to take a shortcut, or a simple alternative
    to defining a `DataTemplate`, if we only need a textual output in the UI. Therefore,
    it is always a good idea for us to override the `object.ToString` method to output
    some meaningful display:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 知道WPF框架在显示数据对象之前会调用我们的`ToString`方法，使我们能够采取捷径，或者定义`DataTemplate`的简单替代方案，如果我们只需要在UI中输出文本。因此，我们始终覆盖`object.ToString`方法以输出一些有意义的显示是一个好主意：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will result in the following output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![](img/459b78b3-b320-44cd-88c1-39d554163a39.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/459b78b3-b320-44cd-88c1-39d554163a39.png)'
- en: 'Note that Visual Studio IntelliSense also calls the `ToString` method on our
    data objects before displaying them, so the benefit of providing a custom implementation
    for it is doubled. As such, we often add an abstract method into our base class
    to ensure that all derived classes will implement this method:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Visual Studio IntelliSense在显示数据对象之前也会调用我们的`ToString`方法，因此为其提供自定义实现的好处是双倍的。因此，我们通常在我们的基类中添加一个抽象方法，以确保所有派生类都将实现此方法：
- en: '[PRE69]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Returning to the topic of data templates now, let''s first take a look at a
    better example for our `User` objects and then investigate where we can declare
    our data templates:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到数据模板的话题，让我们首先看看我们`User`对象的一个更好的示例，然后调查我们可以在哪里声明我们的数据模板：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this example, we simply output the user''s name in one `TextBlock` and their
    age in another. Note the use of the `StringFormat` property to surround the age
    in brackets in the output. Let''s now see how this `DataTemplate` renders our
    `User` objects:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是在`TextBlock`中输出用户的名字，在另一个`TextBlock`中输出他们的年龄。注意使用`StringFormat`属性将年龄括号包围在输出中。现在让我们看看这个`DataTemplate`是如何渲染我们的`User`对象的：
- en: '![](img/e2d76956-d8f4-4a09-969e-ebab45a86e9f.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2d76956-d8f4-4a09-969e-ebab45a86e9f.png)'
- en: Primarily, we can declare our data templates in one of four main places. The
    first is in line with the control that the related data object or objects will
    be displayed in. We have two main options for this too, depending on the number
    of data objects that we have to display.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，我们可以在四个主要位置之一声明我们的数据模板。第一个是与将显示相关数据对象或对象的控件一致。对于这一点，我们也有两种主要的选择，具体取决于我们要显示的数据对象数量。
- en: 'If we have a single object to display, we can utilize the `ContentControl`
    element to display it and the `ContentControl.ContentTemplate` property to define
    the `DataTemplate` element that it should use to render the data object:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个单独的对象要显示，我们可以使用`ContentControl`元素来显示它，并使用`ContentControl.ContentTemplate`属性来定义它应该用来渲染数据对象的`DataTemplate`元素：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Similarly, in a collection control, or `ItemsControl`, such as the `ListBox`
    control, we can declare our `DataTemplate` directly in the `ItemTemplate` property:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在一个集合控件或`ItemsControl`，例如`ListBox`控件中，我们可以在`ItemTemplate`属性中直接声明我们的`DataTemplate`：
- en: '[PRE72]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The next place that we can declare our data templates is in the `Resources`
    section of the control that will display the data object or objects. Here is our
    `ContentControl` now:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在将要显示数据对象或对象的控件的`Resources`部分中声明我们的数据模板。现在这是我们的`ContentControl`：
- en: '[PRE73]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can also declare our data templates in the `Resources` section of the `Window`
    or `UserControl` that contains the control that displays the data objects. If
    we have multiple data objects, then we can set our data template like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在包含显示数据对象的控件的`Window`或`UserControl`的`Resources`部分中声明我们的数据模板。如果我们有多个数据对象，我们可以这样设置我们的数据模板：
- en: '[PRE74]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The last place that we can define our data templates is in the `Application.Resources`
    section of the `App.xaml` file. When the WPF framework searches for a data template
    for particular data type, it first searches the local `Resources` section of the
    control that is applying the template.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`App.xaml`文件的`Application.Resources`部分定义我们的数据模板。当WPF框架搜索特定数据类型的数据模板时，它首先搜索应用模板的控件本地的`Resources`部分。
- en: If it finds no match for the type, it then searches the `Resources` collection
    of the parent control and then the parent of that control and so on. If it still
    does not find a data template with a matching type, then it will search through
    the `Application.Resources` section of the `App.xaml` page.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它找不到匹配的类型，它将接着搜索父控件的`Resources`集合，然后是那个控件的父级，依此类推。如果它仍然找不到匹配类型的数据模板，它将搜索`App.xaml`页面的`Application.Resources`部分。
- en: We can use this order of lookup to our advantage. We often declare our default
    data templates in the `Application.Resources` section of the `App.xaml` page,
    as these resources are available application wide. If we need to override our
    default data templates, to display a particular output in a particular View, we
    can declare a new data template with the same `x:Key` directive locally in the
    View's `Resources` section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种查找顺序来达到我们的目的。我们通常在`App.xaml`页面的`Application.Resources`部分声明我们的默认数据模板，因为这些资源在应用程序范围内可用。如果我们需要覆盖我们的默认数据模板，以在特定的视图中显示特定的输出，我们可以在视图的`Resources`部分本地声明一个新的数据模板，并使用相同的`x:Key`指令。
- en: 'As the local `Resources` section is searched before the application resources,
    it will use the locally declared data template instead of the default one. Another
    way of overriding our default templates is to declare them without setting their
    `x:Key` directives:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在搜索应用程序资源之前会先搜索本地`Resources`部分，所以它会使用本地声明的数据模板而不是默认模板。另一种覆盖我们的默认模板的方法是不设置它们的`x:Key`指令来声明它们：
- en: '[PRE75]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Resources that are declared in this way are implicitly applied to all data objects
    of the appropriate type that do not have a data template explicitly applied. Therefore,
    in order to override these default data templates, we can simply declare a new
    data template and explicitly set it to the relative template property using its
    `x:Key` directive. Let's now look at one further way of specifying a data template.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明的资源会隐式应用于所有适当类型的、没有显式应用数据模板的数据对象。因此，为了覆盖这些默认数据模板，我们可以简单地声明一个新的数据模板，并使用其`x:Key`指令显式将其设置为相对模板属性。现在让我们看看指定数据模板的另一种方法。
- en: Taking complete control
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全控制
- en: At times, we might want to display different objects of the same type in different
    ways, depending on the values of their properties. For example, with a collection
    of objects that represent vehicles, you might want to have different displays
    for different types of vehicle, as trucks have different specifications to motor
    boats. The `DataTemplateSelector` class enables us to do just that.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想要根据它们的属性值以不同的方式显示相同类型的不同对象。例如，对于代表车辆的对象集合，你可能希望对不同类型的车辆有不同的显示，因为卡车和摩托艇有不同的规格。`DataTemplateSelector`类使我们能够做到这一点。
- en: When extending the `DataTemplateSelector` class, we can override its single
    `SelectTemplate` method. In this method, we are provided with both the data object
    and the data bound object and can select different data templates to return, dependent
    on the data object's property values.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展`DataTemplateSelector`类时，我们可以重写其单个`SelectTemplate`方法。在这个方法中，我们既提供了数据对象，也提供了数据绑定对象，可以根据数据对象的属性值选择不同的数据模板来返回。
- en: 'Let''s see a very simple example, where we return one of two data templates
    based on the `User`''s age. We''ll first need to declare another `DataTemplate`
    for our `User` type:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的例子，根据`User`的年龄返回两个数据模板之一。我们首先需要为我们的`User`类型声明另一个`DataTemplate`：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In this template, we have simply inverted the colors of the background and
    foreground from those in the first template. Let''s now see our `DataTemplateSelector`
    class that will reference both this and the other `DataTemplate` element:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们只是将背景和前景的颜色与第一个模板中的颜色进行了反转。现在让我们看看将引用这两个`DataTemplate`元素的`DataTemplateSelector`类：
- en: '[PRE77]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this example, we first defensively cast the `container` input parameter to
    an object of type `FrameworkElement`, using the `as` keyword. We then perform
    the standard `null` checks for this new object and the other input parameter and
    use the `is` keyword to pattern match the correct type and automatically cast
    the `item` parameter to a `User` object, if it's of the right type. If it is,
    then we call the `FindResource` method on our `FrameworkElement` object, to return
    the appropriate data template, dependent upon the value of the `Age` property.
    Otherwise, we return `null`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用`as`关键字将`container`输入参数转换为`FrameworkElement`类型的对象。然后，我们对这个新对象和其他输入参数执行标准的`null`检查，并使用`is`关键字进行模式匹配以确定正确的类型，如果`item`参数是正确的类型，则自动将其转换为`User`对象。如果是，那么我们就在我们的`FrameworkElement`对象上调用`FindResource`方法，根据`Age`属性的值返回适当的数据模板。如果不是，则返回`null`。
- en: The `FrameworkElement.FindResource` method first searches the calling object
    for the data template and then its parent element, and so on, up the logical tree.
    If it doesn't find it in any parent element in the application window, it then
    looks through the `App.xaml` file. If it still does not find it there, it then
    searches in the themes and system resources.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameworkElement.FindResource`方法首先在调用对象中搜索数据模板，然后是其父元素，依此类推，向上到逻辑树。如果在应用程序窗口的任何父元素中找不到它，它将接着在`App.xaml`文件中查找。如果在那里仍然找不到，它将接着在主题和系统资源中搜索。'
- en: The `container` input parameter is used to access the `FindResource` method.
    Note that it will typically be of type `ContentPresenter` if we're using a normal
    collection control, so we could have cast it to that type in order to access the
    data templates.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`container`输入参数用于访问`FindResource`方法。请注意，如果我们使用的是常规集合控件，它通常将是`ContentPresenter`类型，因此我们可以将其转换为该类型以访问数据模板。'
- en: However, the default container could be overridden to use one of the parent
    classes that the `ContentPresenter` class is derived from. Therefore, to avoid
    the possibility of exceptions, it is safer to cast it to the `FrameworkElement`
    class that actually declares the `FindResource` method.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认容器可以被覆盖以使用`ContentPresenter`类派生的一个父类。因此，为了避免异常的可能性，将其转换为实际声明`FindResource`方法的`FrameworkElement`类更安全。
- en: 'Let''s see how we can use this class now. First, we need to add the XAML namespace
    prefix for our `DataTemplateSelectors` namespace:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这个类。首先，我们需要为我们的`DataTemplateSelectors`命名空间添加XAML命名空间前缀：
- en: '[PRE78]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then we need to add an instance of our `UserAgeDataTemplateSelector` class
    to a `Resources` section:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将我们的`UserAgeDataTemplateSelector`类的一个实例添加到`Resources`部分：
- en: '[PRE79]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we set our resource selector to the `ItemTemplateSelector` property:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将资源选择器设置为`ItemTemplateSelector`属性：
- en: '[PRE80]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When running the application now, we''ll see this new output:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在运行应用程序时，我们将看到这个新的输出：
- en: '![](img/3c08a911-2fd2-477b-b651-e246c3c4ca71.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c08a911-2fd2-477b-b651-e246c3c4ca71.png)'
- en: Note that `DataTemplateSelector` classes are typically used with very different
    templates, such as those that make up the different editing or viewing modes of
    a custom control. Slight differences like those in our simple example can be far
    easier achieved using style triggers and we'll find out more about triggers and
    styles in the next chapter.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`DataTemplateSelector`类通常与非常不同的模板一起使用，例如那些构成自定义控件不同编辑或查看模式的模板。在我们简单的例子中，这样的细微差别可以通过使用样式触发器更容易地实现，我们将在下一章中了解更多关于触发器和样式的内容。
- en: Displaying hierarchical data
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示分层数据
- en: There is one class in the .NET Framework that extends the `DataTemplate` class
    in order to support UI controls that extend the `HeaderedItemsControl` class.
    As it sounds, the `HeaderedItemsControl` class represents a particular kind of
    `ItemsControl` element that has a header. Examples include the `MenuItem`, `TreeViewItem`,
    and `ToolBar` classes.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架中有一个类扩展了`DataTemplate`类，以便支持扩展`HeaderedItemsControl`类的UI控件。正如其名，`HeaderedItemsControl`类代表一种具有标题的特定类型的`ItemsControl`元素。例如包括`MenuItem`、`TreeViewItem`和`ToolBar`类。
- en: The `HierarchicalDataTemplate` class was created to display hierarchical Data
    Models. To clarify a little further, a hierarchical data Model is a data Model
    that contains a collection property with items of the same type as the parent
    object. Think of the folder view in the Windows Explorer window; each folder can
    contain further folders.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`HierarchicalDataTemplate`类是为了显示层次化数据模型而创建的。为了进一步说明，层次化数据模型是一个包含与父对象相同类型的项的集合属性的数据模型。想象一下Windows资源管理器窗口中的文件夹视图；每个文件夹可以包含更多的文件夹。'
- en: The main difference between the `HierarchicalDataTemplate` and the `DataTemplate`
    class is that the `HierarchicalDataTemplate` class has an `ItemsSource` property
    that we can use to bind the children of each item to.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`HierarchicalDataTemplate`类与`DataTemplate`类的主要区别在于，`HierarchicalDataTemplate`类有一个`ItemsSource`属性，我们可以用它来绑定每个项目的子项。'
- en: In addition to the `ItemsSource` property, there are a number of other item-related
    properties, such as the `ItemContainerStyle`, `ItemStringFormat` and `ItemTemplate`
    properties. We'll find out more about what these other properties do in the next
    chapter, but for now, let's look at an example.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ItemsSource`属性之外，还有许多其他与项相关的属性，例如`ItemContainerStyle`、`ItemStringFormat`和`ItemTemplate`属性。我们将在下一章中了解更多关于这些其他属性的功能，但现在让我们看看一个例子。
- en: 'There are plenty of `HierarchicalDataTemplate` examples that demonstrate the
    use of `TreeViewItem` elements to be found online, so for this example, we''ll
    see how we can build an application menu using data binding. First, we''ll need
    a View Model to data bind to each `MenuItem` control. Let''s take a look at our
    `MenuItemViewModel` class:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上可以找到许多`HierarchicalDataTemplate`示例，展示了如何使用`TreeViewItem`元素，所以在这个例子中，我们将看看如何使用数据绑定构建应用程序菜单。首先，我们需要一个视图模型来绑定到每个`MenuItem`控件。让我们看看我们的`MenuItemViewModel`类：
- en: '[PRE81]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this simplified example, our View Model only declares three properties to
    data bind to the `MenuItem` control's properties. In a real application, we would
    typically add further properties, so that we could define the icon, or maybe the
    style of each menu item as well. However, continuing the example with our View
    Model, let's look at the class that would declare these View Models.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的例子中，我们的视图模型只声明了三个属性来绑定到`MenuItem`控件属性。在实际应用程序中，我们通常会添加更多的属性，以便我们可以定义每个菜单项的图标或样式。然而，继续使用我们的视图模型作为例子，让我们看看将声明这些视图模型的类。
- en: 'If an application has a menu control, it would typically reside in the `MainWindow.xaml`
    file. Therefore, the data bound `MenuItemViewModel` elements would be declared
    in the View Model that is data bound to the data context of that View. Let''s
    look at the required properties:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序有一个菜单控制，它通常会位于`MainWindow.xaml`文件中。因此，数据绑定的`MenuItemViewModel`元素将声明在绑定到该视图数据上下文的视图模型中。让我们看看所需的属性：
- en: '[PRE82]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'An alternative to programmatically declaring the various menu item View Models
    would be to define the items in an XML file, read it in and generate the items
    from that at runtime. However, for the purpose of this simple example, let''s
    just hard code some values to use, omitting the commands for brevity:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以编程方式声明各种菜单项视图模型之外，还可以在XML文件中定义项，读取它并在运行时从该文件生成项。然而，为了这个简单的例子，让我们只硬编码一些值来使用，为了简洁起见省略了命令：
- en: '[PRE83]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'While this code is somewhat difficult to read, it is far more compact than
    declaring each child item separately and then building up the hierarchy afterwards.
    The end result is the same, so let''s now see what the required XAML looks like:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码读起来有些困难，但它比单独声明每个子项然后构建层次结构要紧凑得多。最终结果是一样的，所以现在让我们看看所需的XAML是什么样的：
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, we declare a `Menu` control and data bind our `MenuItems` collection to
    its `ItemsSource` property. The `ItemContainerStyle` enables us to define the
    style of the UI container that surrounds each of our data items. In this case,
    that control is a `MenuItem` control.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`Menu`控件，并将我们的`MenuItems`集合数据绑定到其`ItemsSource`属性。`ItemContainerStyle`使我们能够定义围绕我们每个数据项的UI容器的样式。在这种情况下，该控件是一个`MenuItem`控件。
- en: All we need to do in this style is to bind the `Command` property of our View
    Model to the `Command` property of the menu item. If we had declared any other
    properties in our View Model to map to the `MenuItem` class properties, then this
    style would be the place to data bind them.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格中，我们只需要将我们的视图模型的`Command`属性绑定到菜单项的`Command`属性。如果我们已经在我们的视图模型中声明了任何其他属性以映射到`MenuItem`类的属性，那么这种风格就是数据绑定的地方。
- en: As discussed earlier, the `ItemTemplate` property enables us to provide a data
    template, or in this case, our `HierarchicalDataTemplate` element, that will define
    how each item will be rendered. In the template declaration, we state the type
    of our data items and specify the collection property that contains the child
    items.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ItemTemplate`属性使我们能够提供一个数据模板，或者在这个例子中，我们的`HierarchicalDataTemplate`元素，这将定义每个项目如何被渲染。在模板声明中，我们声明了我们的数据项的类型，并指定了包含子项的集合属性。
- en: 'Inside the template, we simply output the value of the `Header` property in
    a `TextBlock` element. This will represent the name of each menu item. Let''s
    see what this will all look like when the application is running now:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板内部，我们简单地输出`Header`属性的值到一个`TextBlock`元素中。这将代表每个菜单项的名称。现在让我们看看当应用程序运行时这一切将看起来是什么样子：
- en: '![](img/77f1568d-4b49-4677-a0a9-3d6d3491e813.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77f1568d-4b49-4677-a0a9-3d6d3491e813.png)'
- en: Data binding to enumeration collections
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据绑定到枚举集合
- en: We've already seen a number of examples of data binding to enumeration instances.
    We've seen converters that we can use to convert our enumeration values and Extension
    Methods that we can use to extract additional information from each member. Earlier
    in this chapter, we even saw a full but basic example using our `BitRate` enumeration.
    Now, with our new found knowledge, let's see how we can improve that earlier example.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多将数据绑定到枚举实例的例子。我们看到了我们可以使用的转换器来转换我们的枚举值，以及我们可以用来从每个成员中提取额外信息的扩展方法。在本章的前面，我们甚至看到了一个完整但基本的例子，使用了我们的`BitRate`枚举。现在，凭借我们新获得的知识，让我们看看我们如何可以改进之前的例子。
- en: 'As noted, in the previous example, we manually declared a `RadioButton` control
    for each of our enumerations. While that is fine for our three member enumeration,
    it wouldn''t make so much sense to use this method if we had a large number of
    members. Instead, let''s think about how we could use a `DataTemplate` to declare
    how each member should be rendered. Let''s remind ourselves how we declared each
    `RadioButton` in the previous example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在前面的例子中，我们手动为我们的每个枚举声明了一个`RadioButton`控件。虽然这对我们的三个成员枚举来说是可以的，但如果枚举成员很多，使用这种方法就没有那么合理了。相反，让我们考虑一下我们如何可以使用`DataTemplate`来声明每个成员应该如何被渲染。让我们提醒自己如何在之前的例子中声明每个`RadioButton`：
- en: '[PRE85]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The first thing that we notice is the hardcoded `Content` value. Obviously,
    we can''t do this in a `DataTemplate`, otherwise every member would be given the
    same label. This is a perfect place for us to use the `EnumToDescriptionStringConverter`
    converter that we created earlier, so let''s update that now:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到硬编码的`Content`值。显然，我们无法在`DataTemplate`中这样做，否则每个成员都会被赋予相同的标签。这正是我们可以使用我们之前创建的`EnumToDescriptionStringConverter`转换器的地方，所以现在让我们更新它：
- en: '[PRE86]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we see that we have also hardcoded the `Sixteen` enumeration member to
    the `ConverterParameter` property, so we''ll need to change that in our data template
    too. Our first attempt might be to simply data bind the whole data context from
    the data template, which in our case, is one of the enumeration instances:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到我们还将枚举成员`Sixteen`硬编码到了`ConverterParameter`属性，因此我们还需要在我们的数据模板中更改这一点。我们的第一次尝试可能是简单地从数据模板中数据绑定整个数据上下文，在我们的例子中，这是一个枚举实例：
- en: '[PRE87]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'However, if we do this and run the application, we will receive the following
    exception:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们这样做并运行应用程序，我们将收到以下异常：
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Unfortunately, we cannot data bind to the `ConverterParameter` property, as
    it was not declared as a Dependency Property. As we cannot data bind to this property
    from within our data template and no longer use the `EnumToBoolConverter` class
    to specify the selected enumeration instance, this will complicate our example
    somewhat.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不能绑定到`ConverterParameter`属性，因为这个属性没有被声明为依赖属性。由于我们无法在数据模板内部绑定到这个属性，并且不再使用`EnumToBoolConverter`类来指定选择的枚举实例，这将使我们的例子变得有些复杂。
- en: 'One trick that we can use is to utilize the `SelectedItem` property of the
    `ListBoxItem` class to hold the value of our selected enumeration member instead.
    We can achieve this by data binding this property to the `IsChecked` property
    of each `RadioButton` using a `RelativeSource.FindAncestor` binding in our `DataTemplate`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的一个技巧是利用`ListBoxItem`类的`SelectedItem`属性来保存我们选择的枚举成员的值。我们可以通过在`DataTemplate`中使用`RelativeSource.FindAncestor`绑定将此属性绑定到每个`RadioButton`的`IsChecked`属性来实现这一点：
- en: '[PRE89]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that each data item in a collection control will be implicitly wrapped
    in a UI container element. In our case, we'll use a `ListBox` control and so our
    enumeration instances will be wrapped in `ListBoxItem` elements, but if we had
    chosen a `ComboBox` for example, then our items' containers would be `ComboBoxItem`
    elements. We'll find out more about this in the next chapter, but for now, let's
    continue looking at this example.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在集合控件中的每个数据项都将隐式地包装在一个UI容器元素中。在我们的例子中，我们将使用`ListBox`控件，因此我们的枚举实例将被包装在`ListBoxItem`元素中，但如果我们选择了一个`ComboBox`，例如，那么我们的项目容器将是`ComboBoxItem`元素。我们将在下一章中了解更多关于这个内容，但现在，让我们继续看这个例子。
- en: So, now we have data bound the `Content` property of the `RadioButton` to the
    description of each member from the `DescriptionAttribute` attribute declared
    in the enumeration and the `IsChecked` property to the `IsSelected` property of
    the `ListBoxItem` element. However, we have lost the connection to our selected
    enumeration property from the View Model.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经将`RadioButton`的`Content`属性绑定到枚举中`DescriptionAttribute`属性声明的每个成员的描述，以及将`IsChecked`属性绑定到`ListBoxItem`元素的`IsSelected`属性。然而，我们已经失去了与视图模型中选择的枚举属性的连接。
- en: 'In order to restore this connection, we can data bind the `BitRate` property
    to the `SelectedItem` property of the `ListBox` control. The WPF Framework implicitly
    connects this property with the `IsSelected` property of each `ListBoxItem` element
    and so our connection between the `BitRate` property and the `IsChecked` property
    of each button is now restored. Let''s see the updated XAML:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复这种连接，我们可以将`BitRate`属性绑定到`ListBox`控制的`SelectedItem`属性。WPF框架隐式地将此属性与每个`ListBoxItem`元素的`IsSelected`属性连接起来，因此我们现在恢复了`BitRate`属性与每个按钮的`IsChecked`属性之间的连接。让我们看看更新的XAML：
- en: '[PRE90]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: To update our earlier example, we need to add the new `Enums` XAML namespace
    prefix, so that we can specify our `BitRate` enumeration type in the data template.
    Next, we need to update the content of our `GroupBox` element. Now we're using
    a `ListBox` control so that we can take advantage of its item selection capabilities.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新我们之前的例子，我们需要添加新的`Enums` XAML命名空间前缀，这样我们就可以在数据模板中指定我们的`BitRate`枚举类型。接下来，我们需要更新我们的`GroupBox`元素的内容。现在我们使用`ListBox`控件，这样我们可以利用其项目选择功能。
- en: 'We data bind our `BitRates` collection to the `ItemsSource` property and our
    selected `BitRate` property to the `SelectedItem` property of the `ListBox`. The
    one problem with this method is that as we''re now using a `ListBox` element in
    our example, we can see it and its contained `ListBoxItem` objects. This is not
    how radio buttons are typically displayed:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`BitRates`集合绑定到`ItemsSource`属性，并将选择的`BitRate`属性绑定到`ListBox`的`SelectedItem`属性。这种方法的一个问题是，由于我们现在在例子中使用`ListBox`元素，我们可以看到它及其包含的`ListBoxItem`对象。这通常不是单选按钮的显示方式：
- en: '![](img/880d4dbb-c489-4263-b391-86639919ed7a.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/880d4dbb-c489-4263-b391-86639919ed7a.png)'
- en: It's not a terrible problem and it can be easily fixed by declaring a few styles.
    We'll return to this example in the following chapter and demonstrate how we can
    style the `ListBox` element and its items to completely hide their use from the
    end users.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个严重的问题，通过声明一些样式就可以轻松解决。我们将在下一章中回到这个例子，并展示如何对`ListBox`元素及其项目进行样式化，以完全隐藏它们的使用对最终用户的影响。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered a lot of important information in this chapter, from examining
    the binding path syntax mini-language to exploring a number of different binding
    scenarios. We've investigated the plethora of options that we're afforded when
    declaring our own Dependency Properties and looked into the creation of Attached
    Properties, using some interesting examples. Finally, we examined the finer details
    of data templating and explored a number of ways of data binding to enumerations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量重要信息，从检查绑定路径语法迷你语言到探索多种不同的绑定场景。我们研究了在声明自己的依赖属性时我们拥有的众多选项，并探讨了使用一些有趣的示例来创建附加属性。最后，我们考察了数据模板的细节，并探索了将数据绑定到枚举的多种方法。
- en: In the next chapter, we'll have an in-depth look at the various UI elements
    in the WPF Framework and their most relevant properties. We'll investigate when
    to customize them and when we need to create our own controls. We'll then explore
    the various ways of modifying existing controls in WPF and finally, take a detailed
    look at how to create our own custom controls.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 WPF 框架中的各种 UI 元素及其最相关的属性。我们将研究何时需要自定义它们，以及何时需要创建自己的控件。然后，我们将探索修改现有
    WPF 控件的多种方法，最后，我们将详细探讨如何创建自己的自定义控件。
