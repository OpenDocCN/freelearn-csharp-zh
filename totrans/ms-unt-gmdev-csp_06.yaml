- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Functionality with Unity Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 3*](B22017_03.xhtml#_idTextAnchor049), where we’ll delve
    into the world of Unity plugins. We’ll explore how to effectively integrate these
    plugins into your projects. This chapter aims to familiarize you with the different
    types of plugins available in the Unity ecosystem and guide you through the process
    of seamlessly incorporating them. By grasping the fundamentals of plugin integration,
    you’ll be able to make the most of existing solutions, enhance your game features,
    and save valuable development time. Let’s jump in and discover how Unity plugins
    can significantly boost your game development capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Unity plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Unity plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for using Unity plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to follow this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity version 2022.3.13**: Download and install Unity version 2022.3.13 or
    any other version. It is recommended to install the 2022 version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primary IDE – Visual Studio 2022**: Ensure Visual Studio 2022 is installed
    for optimal learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository for code samples**: Access code samples and project files
    on our GitHub repository: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003).
    Clone or download the repository to have easy access to the code demonstrated
    in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Unity plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of game development, Unity plugins are like handy tools that developers
    can add to their toolkit. Think of them as special add-ons or extra features that
    make building games easier and more exciting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore here how these optional upgrades can elevate your game development
    endeavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boost to game development**: Unity plugins are essential tools in the world
    of game development. These compact bundles of code serve as valuable additions
    to Unity, acting much like specialized ingredients seamlessly integrated into
    your game. Crafted by fellow developers, these plugins are generously shared within
    the Unity community, offering benefits to all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The significance of Unity plugins in game development**: The appeal of Unity
    plugins lies in their ability to enhance game development effortlessly. Picture
    this: you’re constructing a game, and you envision characters with incredibly
    smooth movements or breathtaking special effects such as dazzling explosions.
    Instead of grappling with complex code to achieve these elements, Unity plugins
    provide a solution. They save time and effort by leveraging the expertise of skilled
    developers, allowing you to relish the outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extending functionality – elevating games to new heights**: Extending functionality
    with plugins is akin to granting your game superpowers. It goes beyond the basics,
    allowing you to incorporate various features without delving into the complexities
    of starting from square one. It’s like an upgrade for your game, making it more
    enjoyable and engaging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity plugins play a vital role in the realm of game development, equipping
    developers with a toolbox to amplify the capabilities of Unity. It’s crucial to
    discern between two main categories of plugins: core plugins and extra plugins.
    Core plugins, inherent to Unity, provide foundational functionalities right out
    of the box. On the flip side, extra plugins act as optional upgrades, allowing
    you to tailor your toolkit to suit the specific needs of your project. To better
    understand these distinctions, let’s consider a comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Plugin Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Core plugins | Pre-packaged with Unity, offering foundational functionalities
    |'
  prefs: []
  type: TYPE_TB
- en: '| Extra plugins | Optional upgrades that can be chosen based on specific project
    requirements |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we will prioritize additional plugins as they play a crucial
    role in enhancing the project, delving into how to seamlessly extend and integrate
    them into your projects. Our spotlight on the extra plugins falls on the **new
    Input System** and **Cinemachine** – as essential extra plugins, prominent choices
    for enhancing your game without delving into the core functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start talking about installing the plugins and
    how to extend them using C# scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Unity plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s delve into the seamless process of integrating external plugins into your
    Unity projects. Discover how this skill unlocks a world of possibilities, enhancing
    your game development experience with refined character movements, cinematic visual
    effects, and more. Dive in and elevate your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the new Input System and how to use it for handling input
    for our character.
  prefs: []
  type: TYPE_NORMAL
- en: New Input System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity handles input through two systems: the older Input Manager, which is
    integrated into the editor, and the more recent Input System package. The aged
    Input Manager is an integral part of Unity’s core, readily available if you choose
    not to install the Input System package. Offering a fresher perspective, the Input
    System package enables you to employ any input device to govern your Unity content,
    taking the place of Unity’s traditional Input Manager. Installation of the new
    Input System package is a breeze – simply use the Package Manager. We will install
    it and use it in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, we’ll compare the old Input System with the new one,
    highlighting their key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Old** **Input Manager** | **New** **Input System** |'
  prefs: []
  type: TYPE_TB
- en: '| Device support | Limited to keyboards, mice, and gamepads | Unified API for
    all devices |'
  prefs: []
  type: TYPE_TB
- en: '| Input actions | Basic button and axis mappings | Complex actions with triggers
    and combinations |'
  prefs: []
  type: TYPE_TB
- en: '| Architecture | Polling-based continuously checks input states at regular
    intervals, such as every frame, to detect changes and respond to user actions
    in real-time | Event-driven relies on triggering callbacks or events based on
    user actions, promoting modularity and efficient handling of input events without
    continuous polling |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Can be sluggish | Efficient and responsive |'
  prefs: []
  type: TYPE_TB
- en: '| Extensibility | Closed system | Open-source and extensible |'
  prefs: []
  type: TYPE_TB
- en: Excited for more exploration? Look forward to the following section, where we’ll
    delve into configuring the system, crafting personalized actions, and unlocking
    its full potential.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware that the new Input System is compatible with Unity versions
    2019.4 and above, and it necessitates the .NET 4 runtime. Projects utilizing the
    old .NET 3.5 runtime are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can choose **Input System** inside the **Package
    Manager** and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Input System package inside Package Manager panel](img/B22017_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Input System package inside Package Manager panel
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing the installation process, Unity will ask you if you want to
    enable the new backends. By choosing **Yes**, Unity will enable the new backends
    and disable the old backends, and the Unity Editor will restart. You can see a
    **Warning** message in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Warning message after installing the new Input System](img/B22017_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Warning message after installing the new Input System
  prefs: []
  type: TYPE_NORMAL
- en: Please take note that you have the option to simultaneously enable both the
    old and new systems. To accomplish this, set **Active Input Handling** to **Both**.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the relevant setting in the **Player** settings (navigate to **Edit**
    | **Project Settings** | **Player**), specifically under **Active Input Handling**.
    Feel free to adjust this setting at your convenience; however, please note that
    making changes will necessitate restarting the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Input settings inside the Project Settings](img/B22017_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Input settings inside the Project Settings
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve been introduced to the new Input System, let’s explore its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Unity’s new Input System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, our focus shifts to the practical application of Unity’s
    new Input System. Get ready to dive into hands-on learning as we guide you through
    the step-by-step process of implementation. By the end of this section, you’ll
    have the skills and knowledge needed to seamlessly integrate the new Input System
    into your Unity projects, enhancing control and responsiveness. Let’s get hands-on
    and delve into the practical steps of implementing this powerful tool together.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity’s new Input System, `InputActions` are pivotal for defining and structuring
    input controls such as keyboard keys, mouse buttons, and controller inputs within
    an InputActionAsset. These actions are bound to specific input bindings and organized
    into logical groupings called `PlayerInput` component integrates InputActions
    into GameObjects, allowing for efficient input event handling through callbacks
    and events. InputActions support rebinding and overrides, empowering players to
    customize input bindings while maintaining a cohesive Input System architecture
    that enhances modularity and reusability compared to Unity’s legacy Input System.
    Let’s use the new Input System.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new input action (**Create** | **Input Actions**) in the folder inside
    your project, as you can see in the next figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Choosing Input Actions from the Create panel](img/B22017_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Choosing Input Actions from the Create panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can open this input action, and a new panel will appear, as shown
    in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Input Action panel](img/B22017_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Input Action panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the **Action Type** value to **Pass Through** and **Control Type** to
    **Vector 2**, as you can see in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Action Properties](img/B22017_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Action Properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, choose to add bindings for movement, as you can see in the next figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Choosing bindings for movement](img/B22017_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Choosing bindings for movement
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can rename the name of the movement binding. Also, you can start
    to set the input keys for each process in the **Path** dropdown, as you can see
    in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Movement binding](img/B22017_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Movement binding
  prefs: []
  type: TYPE_NORMAL
- en: 'The magic of the new Input System shines as you can assign multiple bindings
    for the same action across different devices, as demonstrated in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Arrows bindings](img/B22017_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Arrows bindings
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add new actions for **Jump** and **Dash**, but for them, you need
    to change the **Action Type** value to **Button**. Your final settings should
    look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Adding Jump and Dash](img/B22017_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Adding Jump and Dash
  prefs: []
  type: TYPE_NORMAL
- en: 'As the final step for this input action asset, you need to return to the input
    action in **Inspector** and choose **Generate C# Class** for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Generating an input class](img/B22017_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Generating an input class
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will create a wrapper script to take callbacks from the inputs and
    invoke new actions to perform movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to create a wrapper for using the new Input System, starting with
    implementing gameplay map actions in our `PlayerInput` script as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, we will register callbacks for this action and create events so that
    we can use them later in our **PlayerMovement** script, as you can see in the
    following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, magic happens here. When we get the action callback and then invoke our
    events, we will subscribe to these events in the **PlayerMovement** script, as
    you can see in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are the functions for movement in the `PlayerMovement` script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Voilà! The new Input System is now employed for player movement.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing advanced techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the upcoming section, we are going to talk about more advanced techniques
    for the new Input System. Let’s explore Unity’s Input System features by looking
    at Interactions and Processors, which help adjust input signals before they activate
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interactions**: Interactions modify or filter the raw input signal before
    reaching the action. Unity’s Input System provides a variety of built-in Interactions,
    such as **Tap**, **Slow Tap**, and **Press**, each serving specific use cases.
    For example, we can utilize **Multi Tap** for double jumps or activating special
    powers, while **Press** can help solve parts of puzzles in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can find a list of Interactions to be applied:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Interactions](img/B22017_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Interactions
  prefs: []
  type: TYPE_NORMAL
- en: '**Processors**: Processors are applied to the input data after the Interaction
    but before the action triggers. They allow you to manipulate the input data, such
    as scaling, inverting, or smoothing analog values. Processors contribute to the
    fine-tuning of input behavior; you can apply them on controls, bindings, and actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you will find a list of Processors to be applied:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Processors](img/B22017_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Processors
  prefs: []
  type: TYPE_NORMAL
- en: Having gained insights into Unity’s Input System, we now understand how Interactions
    and Processors refine input signals, enhancing control mechanisms within our game
    development endeavors. In the next section, let’s delve into Cinemachine, an essential
    tool in Unity that revolutionizes game development with cinematic flair.
  prefs: []
  type: TYPE_NORMAL
- en: Cinemachine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s talk about Cinemachine, a game-changer in Unity that takes your game development
    to cinematic levels. If you’re a Unity developer, Cinemachine is your go-to tool
    for effortlessly managing dynamic camera moves, crafting cinematic scenes, and
    enhancing the way players navigate virtual worlds.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, Cinemachine introduces virtual cameras, which are like your personal
    camera crew for the digital stage. No need for complex camera scripts – Cinemachine
    simplifies the process, making it easy to guide player perspectives. Whether you
    want action-packed shots, serene landscapes, or immersive story moments, Cinemachine
    lets you play director without the headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Cinemachine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Explore the array of features Cinemachine offers for seamless and captivating
    camera control and storytelling in Unity game development as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intuitive controls**: Cinemachine provides a user-friendly interface and
    intuitive controls, eliminating the need for complex camera scripting and making
    it accessible to developers of all skill levels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effortless perspective guidance**: With Cinemachine, you can effortlessly
    guide player perspectives, from dynamic action sequences to serene landscapes,
    without delving into intricate code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Realism with procedural noise**: Cinemachine introduces realism into scenes
    through procedural noise, offering subtle yet impactful effects such as camera
    shakes during key moments, enhancing the overall gaming experience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composer for automatic framing**: The **Composer** component automates the
    camera’s position and **field-of-view** (**FOV**) adjustments, ensuring focus
    on essential elements, streamlining the framing process, and saving valuable development
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seamless Timeline integration**: Cinemachine seamlessly integrates with Unity’s
    Timeline, enabling the easy creation of cinematic sequences for a more immersive
    and narrative-driven gaming experience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced storytelling capabilities**: Beyond a camera system, Cinemachine
    acts as a creative ally, enhancing storytelling capabilities and making games
    more captivating and memorable for players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, Cinemachine presents an array of features designed to streamline
    camera control and enhance storytelling in Unity game development, offering intuitive
    controls, effortless perspective guidance, realism with procedural noise, automated
    framing with the **Composer** component, seamless Timeline integration, and enhanced
    storytelling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cinemachine in our game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s kick off our journey with Cinemachine by exploring how to integrate it
    into our game seamlessly. In this subsection, we will learn how to install Cinemachine
    and set up your virtual camera for enhanced scene management and dynamic camera
    movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the **Package Manager** panel, from which
    you can choose and install packages and wait till the editor finishes compiling
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Installing Cinemachine from the Package Manager](img/B22017_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Installing Cinemachine from the Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity provides a variety of cameras within the Cinemachine package. Let’s discuss
    some of these cameras and their respective uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Freelook** **Camera (CinemachineFreeLook)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Usage*: The Freelook Camera provides versatile control for creating dynamic
    and cinematic camera movements in 3D environments. It is often used for character
    exploration, action sequences, and immersive gameplay experiences where fluid
    camera motion adds depth and engagement.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Key features*: Allows for multi-axis rotation, adjustable follow and look-at
    targets, customizable damping for smooth transitions, and the ability to define
    multiple rig configurations for different camera behaviors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual** **Camera (CinemachineVirtualCamera)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Usage*: The Virtual Camera serves as a foundational camera tool in Cinemachine,
    offering precise control over framing, composition, and behavior. It is suitable
    for a wide range of scenarios, including character tracking, scene framing, cutscenes,
    and scripted camera sequences.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Key features*: Provides options for target tracking, damping settings for
    smooth transitions, customizable FOV, **depth of field** (**DOF**), and various
    blending modes for seamless camera transitions and effects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2D** **Camera (CinemachineVirtualCamera)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Usage*: The 2D Camera variant of CinemachineVirtualCamera is specifically
    designed for 2D game development, offering similar functionality to the 3D Virtual
    Camera but tailored for 2D environments. It is ideal for platformers, side-scrolling
    games, and other 2D projects requiring dynamic camera control.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Key features*: Supports 2D-specific settings such as orthographic mode, pixel-perfect
    camera setup, pixel snapping, and follow and dead zones tailored for 2D gameplay
    mechanics. Allows for smooth tracking of 2D characters, parallax effects, and
    cinematic camera movements in 2D space.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following demonstration, we’ll implement the Virtual Camera to highlight
    the specific changes that occur when transitioning from Unity’s default camera
    to Cinemachine cameras.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose **Virtual Camera** from the **Cinemachine** list. When you try to add
    components, the main camera will be managed by Cinemachine moving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Virtual Camera option](img/B22017_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Virtual Camera option
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing **Virtual Camera**, the **CinemachineBrain** component will
    be added to the **MainCamera** GameObject, as seen in *Figure 3**.16*. The **CinemachineBrain**
    component orchestrates multiple virtual cameras, managing their activation, blending,
    and behavior for smooth transitions and dynamic camera control, crucial for creating
    immersive and visually engaging scenes in Unity projects using Cinemachine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – CinemachineBrain component](img/B22017_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – CinemachineBrain component
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it will create a new game object for this virtual camera inside the scene
    that has the **CinemachineVirtualCamera** component, as seen in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – CinemachineVirtualCamera component](img/B22017_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – CinemachineVirtualCamera component
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you successfully integrated Cinemachine into your game, allowing
    for streamlined camera management and dynamic virtual camera movements to enhance
    your game’s visual experience.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing gameplay dynamics – adding shake effects with Cinemachine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Utilizing Cinemachine to elevate our game experience, we’ll now explore the
    integration of effects, specifically focusing on incorporating a shake effect
    using the **CinemachineImpulseListener** component. This essential component in
    Unity’s Cinemachine package acts as a crucial receiver of impulse signals from
    other Cinemachine modules, translating them into impactful visual and auditory
    effects within the game. Its primary function involves listening for impulse signals
    triggered by events such as collisions or explosions, enabling developers to apply
    customizable parameters such as intensity and duration for immersive feedback
    experiences. Seamlessly integrated with Cinemachine modules, the **CinemachineImpulseListener**
    component enhances gameplay and cinematic effects by delivering synchronized and
    dynamic responses to in-game events, thus significantly enhancing the overall
    immersive and engaging player experience.
  prefs: []
  type: TYPE_NORMAL
- en: The shake effect stands out as a highly impactful element in game design, contributing
    significantly to the overall player experience. Whether applied to simulate fire,
    collisions, or other gameplay elements, this effect adds a layer of dynamism and
    engagement. Integrating a shake effect effectively enhances the player’s immersion
    during gameplay, creating a more compelling and enjoyable experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin implementing this feature in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by clicking on **Add Extension**. It will show us a menu like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Extensions menu](img/B22017_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Extensions menu
  prefs: []
  type: TYPE_NORMAL
- en: Then, we click on the **CinemachineImpulseListener** component to add to our
    camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can tweak the values inside this component to achieve a better effect for
    our game, as you can see in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.19 – CinemachineImpulseListener component](img/B22017_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – CinemachineImpulseListener component
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about values in Unity’s official documentation: [https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/](https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For most Unity components, tooltips appear when you hover your mouse over the
    variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to add **CinemachineImpulseSource** to a game object. In our case,
    we can easily add it to the player game object, as most Interactions will be from
    this player. The **CinemachineImpulseSource** component in Unity’s Cinemachine
    package is a versatile tool for generating impulse signals that simulate impactful
    events within a game. By defining parameters such as intensity and duration, we
    can create a range of effects such as camera shakes, controller vibrations, or
    screen flashes. Integrated seamlessly with other Cinemachine components, **CinemachineImpulseSource**
    enhances gameplay and cinematic experiences by allowing dynamic responses to events
    and fine-tuning effects for immersive and engaging player experiences. Its customization
    options and scripting capabilities enable us to tailor effects to match the game’s
    aesthetics and mechanics, adding depth and interactivity to the overall game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a reference to **CinemachineImpulseSource** in our scripts to
    start using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – CinemachineImpulseSource component](img/B22017_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – CinemachineImpulseSource component
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the **PlayerEffects** script, which will subscribe to the **PlayerShoot**
    fire event to generate an impulse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code, we will generate an impulse when the player shoots fire:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it! Now, whenever the player shoots, the effect will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic cinematic experiences – seamless camera blending with Cinemachine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another application of **Cinemachine** lies in its ability to manage multiple
    cameras concurrently and seamlessly blend between them at runtime. This functionality
    proves valuable in scenarios where you want to create a dedicated camera for specific
    in-game events. For instance, you can design a special camera that triggers when
    the player encounters a boss, automatically activating when the player enters
    a boss room.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can find the option to add custom blends in the
    Cinemachine component. Click **Create Asset** to generate a new scriptable object,
    which will be responsible for managing the transition between cameras, as well
    as orchestrating the tween action during the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Custom Blends section in Cinemachine component](img/B22017_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Custom Blends section in Cinemachine component
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following figure, using a scriptable object for **CinemachineBlenderSettings**,
    you can add transitions between cameras. The **CinemachineBlenderSettings** component
    in Unity’s Cinemachine package is instrumental in orchestrating smooth transitions
    between virtual cameras within a scene. By defining blend curves, weighting parameters,
    and blend techniques, we can control the rate, style, and visual dominance of
    camera blending, resulting in seamless and visually engaging camera movements
    during gameplay or cinematic sequences. With support for prioritization, triggering
    mechanisms, and extensive customization options, **CinemachineBlenderSettings**
    empowers us to create dynamic and immersive camera transitions tailored to the
    game’s aesthetics and narrative, enhancing overall player experience and immersion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – CinemachineBlenderSettings scriptable object](img/B22017_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – CinemachineBlenderSettings scriptable object
  prefs: []
  type: TYPE_NORMAL
- en: To utilize this functionality, you can enable or disable the game objects of
    the cameras or adjust the priority of the current camera by increasing it and
    decreasing the priority of the previous camera.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can find all the code in our GitHub repo, the link to which is mentioned
    in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I have chosen to use enums instead of strings for better performance efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code outlines the enum for various camera types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Given the abundance of Unity plugins, it’s essential to pick the right one for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, Cinemachine offers Unity developers intuitive camera controls,
    effortless perspective guidance, realism with procedural noise, automatic framing,
    seamless Timeline integration, and enhanced storytelling capabilities. As we conclude
    this section, we have explored its features and benefits, preparing to leverage
    its power in our game development endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for using Unity plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before integrating plugins into your project, it’s essential to thoroughly
    explore their functionality, understand their documentation, assess compatibility
    and potential impact, evaluate specific features, stay updated with releases,
    check version compatibility, maintain project integrity, set up a testing environment,
    document integrations for future reference, and track and resolve issues encountered
    during integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring plugin functionality**: Before adding a plugin, thoroughly explore
    its features and functionalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding documentation**: Dive into the plugin’s documentation for a
    clear understanding of its capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility and impact assessment**: Evaluate how the plugin aligns with
    your project, considering aspects such as performance and potential conflicts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature assessment**: Assess specific features to ensure they meet your project’s
    requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keeping plugins updated**: Stay informed about updates, bug fixes, and new
    features for your integrated plugins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version compatibility checks**: Verify that the plugin aligns with the current
    Unity version, exercising caution during Unity updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintaining project integrity**: Back up your entire project before making
    significant changes to avoid data loss'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing environment**: Create a dedicated testing environment to evaluate
    plugin updates or modifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation for future reference**: Create detailed integration documentation
    and include configurations, settings, and troubleshooting steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue tracking and resolution**: Maintain a record of encountered issues
    and their resolutions for future reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, exploring, understanding, assessing, updating, checking compatibility,
    maintaining integrity, testing, documenting, and tracking issues are crucial steps
    in effectively integrating and managing plugins within your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In wrapping up this chapter, we’ve covered the ins and outs of Unity plugins,
    understanding the basic and extended features they offer. You’ve also learned
    how to integrate the new Input System and Cinemachine using C#, gaining practical
    skills to enhance your game development projects. We’ve emphasized the importance
    of adopting best practices when working with plugins, setting the stage for more
    efficient integration into your projects. As you reflect on keeping your code
    organized and neat, these skills will be valuable as you continue your journey
    toward becoming a skilled Unity developer.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead to the next chapter, *Creating Fun Game Mechanics with C# in Unity*,
    get ready to expand your game development toolkit. Building on what you’ve learned
    about clean coding practices, you’ll explore how to bring excitement to your games
    through the expressive C# programming language. Imagine seamlessly incorporating
    your knowledge of plugins and organized code into the creation of engaging game
    mechanics. The upcoming chapter promises exciting challenges and discoveries that
    will further enhance your Unity development skills. Get ready to dive into the
    world of crafting immersive and enjoyable game mechanics in [*Chapter 4*](B22017_04.xhtml#_idTextAnchor058).
    Happy coding on this ongoing journey of skill-building!
  prefs: []
  type: TYPE_NORMAL
