<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor307"/>8</h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor308"/>Security and Identity in ASP.NET Core</h1>
<p>In <a href="B18971_07.xhtml#_idTextAnchor272"><em class="italic">Chapter 7</em></a>, we discussed some more advanced topics of EF Core, such as <code>DbContext</code> pooling, performance optimization, and concurrency control. At this point, you should have the skills to create a web API application that accesses the database using EF Core. However, the application is not secure. Without any authentication, anyone who knows the URL can access the API, potentially exposing sensitive data to the public. To ensure the security of the web API application, we must take additional steps.</p>
<p>Security is a broad topic, and it is a crucial aspect of any application. In this chapter, we will explore some of the security features that ASP.NET Core provides, including authentication, authorization, and some best practices for securing your web API application. We will cover the following topics:</p>
<ul>
<li>Getting started with authentication and authorization</li>
<li>Delving deeper into authorization</li>
<li>Managing users and roles</li>
<li>New Identity API endpoints in ASP.NET Core 8</li>
<li>Understanding OAuth 2.0 and OpenID Connect</li>
<li>Other security topics</li>
</ul>
<p>After reading this chapter, you will have a basic understanding of the security features in ASP.NET Core. You will also know how to implement authentication and various authorization types in your web API applications, such as role-based authorization, claim-based authorization, and policy-based authorization.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor309"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</a>. You can use VS Code or VS 2022 to open the solutions.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor310"/>Getting started with authentication and authorization</h1>
<p>Authentication<a id="_idIndexMarker693"/> and authorization are <a id="_idIndexMarker694"/>two important aspects of security. Although these two terms are often used together, they are distinct concepts. Before we dive into the code, it is important to gain an understanding of the differences between authentication and authorization.</p>
<p>We have already built some web API applications. However, these APIs will be publicly available to anyone who knows the URL. For some resources, we want to restrict access to only authenticated users. For example, we have a resource that contains some sensitive information that should not be available to everyone. In this case, the application should be able to identify the user who is making the request. If the user is anonymous, the application should not allow the user to access the resource. This is where authentication comes into play.</p>
<p>For some scenarios, we also want to restrict access to some specific users. For example, we want to allow authenticated users to read the resource, but only admin users to update or delete the resource. In this case, the application should be able to check whether the user has the required permissions to execute the operation. This is where authorization is used.</p>
<p>Long story short, authentication is used to know who the user is, while authorization is used to know what the user can do. Together, these processes are used to ensure that the user is who they claim to be and that they have the required permissions to access the resource.</p>
<p>ASP.NET Core provides the Identity framework, which has a rich set of features for authentication and authorization. In this chapter, we will explore how to use the Identity framework to implement authentication and authorization in ASP.NET Core. We will also introduce some third-party authentication providers<a id="_idTextAnchor311"/>.</p>
<p>Think about a scenario where we want to build a web API application that allows users to register and log in. For a specific endpoint, we only want to allow authenticated users to access the resource. In this section, we will explore how to implement this scenario. From this example, you will learn how to<a id="_idIndexMarker695"/> implement a basic authentication and authorization<a id="_idIndexMarker696"/> system in ASP.NET Core; this will help you prepare for the next section.</p>
<p>We will use the following resources in this example:</p>
<ul>
<li><code>POST /account/register</code>: This resource will be used to register a new user. The user should send the username and password in the request body. After validating the username and password, the application will create a new user in the database and return a JWT token to the user. This JWT token will be used to authenticate the user in subsequent requests.</li>
<li><code>POST /account/login</code>: This resource will be used to log into an existing user. After the user sends the username and password, the application will validate the credentials and return a JWT token to the user if the credentials are valid. The JWT token will be used to authenticate the user in subsequent requests.</li>
<li><code>GET /WeatherForecast</code>: This resource will be used to get the weather forecast. It only allows authenticated users to access the resource. The user should send the JWT token in the Authorization header to authenticate the user.</li>
</ul>
<p>There should be more endpoints to manage users, such as updating the user profile, deleting the user, resetting the password, and more. However, we are not building a complete application in this chapter. To keep things simple, we will only focus on the minimal features required to demonstrate the authentication and authorization features in ASP.NET Core.</p>
<p class="callout-heading">What is JWT?</p>
<p class="callout">JWT stands for <em class="italic">JSON Web Token</em>. It is an industry standard for representing claims securely between two parties. The RFC for JWT is RFC 7519: <a href="https://www.rfc-editor.org/rfc/rfc7519">https://www.rfc-editor.org/rfc/rfc7519</a>. A JWT token consists of three parts: header, payload, and signature. So, typically, a JWT token looks like <code>xxxxx.yyyyy.zzzzz</code>. The header contains the algorithm used to sign the token, the payload contains the claims, and the signature is used to verify the integrity of the token. For more information about JWT, see <a href="https://jwt.io/introduction">https://jwt.io/introduction</a>.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor313"/>Creating a sample project with authentication and authorization</h2>
<p>To begin, we<a id="_idIndexMarker697"/> must prepare the project and add any necessary NuGet packages. Additionally, we need to configure <a id="_idIndexMarker698"/>the database context to enable us <a id="_idIndexMarker699"/>to store user information in the database. Follow these steps:</p>
<ol>
<li>Create a new ASP.NET Core web API project by running the following command:<pre class="source-code">
<code>AuthenticationDemo</code>. Open the project in VS Code. You can find the start project in the <code>/</code><code>samples/chapter8/AuthenticationDemo/BasicAuthenticationDemo/start</code> f<a id="_idTextAnchor314"/>older.</p></li> <li>Now, it’s time to add the required NuGet packages. We will use ASP.NET Core Identity to implement the authentication. ASP.NET Core Identity is a membership system that provides authentication and authorization features. It is a part of the ASP.NET Core framework. We need to install the following NuGet packages:<ul><li><code>Microsoft.AspNetCore.Identity.EntityFrameworkCore</code>: This package is used for the EF Core implementation of ASP.NET Core Identity.</li><li><code>Microsoft.EntityFrameworkCore.SqlServer</code>: This package is used to connect to SQL Server.</li><li><code>Microsoft.EntityFrameworkCore.Tools</code>: This package is used to enable the necessary EF Core tools.</li><li><code>Microsoft.AspNetCore.Authentication.JwtBearer</code>: This package is used to enable JWT authentication.</li></ul><p class="list-inset">The ASP.NET Core Identity package already comes with the default project template, so we do not need to insta<a id="_idTextAnchor315"/>ll it.</p></li>
<li>Next, we <a id="_idIndexMarker700"/>will add<a id="_idIndexMarker701"/> the database context. We will use EF Core to access the database. But first, we need an entity model to represent the user. Create a new folder named <code>Authentication</code> and add a new class named <code>AppUser</code> to it. The <code>AppUser</code> class <a id="_idIndexMarker702"/>inherits from the <code>IdentityUser</code> class, which is provided by ASP.NET Core Identity, as shown in the following code:<pre class="source-code">
public class AppUser : IdentityUser{}</pre><p class="list-inset">The <code>IdentityUser</code> class already contains the properties that we need to represent a user for most of the scenarios, such as <code>UserName</code>, <code>Email</code>, <code>PasswordHash</code>, <code>PhoneNumber</code>, and others.</p></li> <li>Next, we need to create a database context to access the database. Add a new class named <code>AppDbContext</code> to the <code>Authentication</code> folder. The <code>AppDbContext</code> class inherits from the <code>IdentityDbContext</code> class, which is provided by ASP.NET Core Identity, as shown in the following code:<pre class="source-code">
public class AppDbContext(DbContextOptions&lt;AppDbContext&gt; options, IConfiguration configuration) : IdentityDbContext&lt;AppUser&gt;(options){    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)    {        base.OnConfiguring(optionsBuilder);        optionsBuilder.UseSqlServer(_configuration.GetConnectionString("DefaultConnection"));    }}
"ConnectionStrings": {    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=AuthenticationDemo;Trusted_Connection=True;MultipleActiveResultSets=true"}</pre><p class="list-inset">As we<a id="_idIndexMarker705"/> can see, this <code>AppDbContext</code> is purely for ASP.NET Core Identity. If you have other entities in your application, you can create a separate <code>DbContext</code> for them if you want to. You can use the same connection string for both<a id="_idTextAnchor316"/> <code>DbContexts</code>.</pre></li> <li>Next, we will need to create a few models for registering and logging in users because, when we register a user, we need to send the username, password, and email address. When we log a user in, we need to send the username and password. It would be good if we had separate models for these different scenarios.</li>
<li>Create a new class named <code>AddOrUpdateAppUserModel</code> in the <code>Authentication</code> folder. This class will be used to represent the user when we register a new user. The <code>AddOrUpdateAppUserModel</code> class should contain <a id="_idIndexMarker706"/>the following properties:<pre class="source-code">
public class AddOrUpdateAppUserModel{    [Required(ErrorMessage = "User name is required")]    public string UserName { get; set; } = string.Empty;    [EmailAddress]    [Required(ErrorMessage = "Email is required")]    public string Email { get; set; } = string.Empty;    [Required(ErrorMessage = "Password is required")]    public string Password { get; set; } = string.Empty;}</pre></li> <li>Similarly, create <a id="_idIndexMarker707"/>a new class named <code>LoginModel</code> in the <code>Authentication</code> folder, as <a id="_idIndexMarker708"/>shown in the following code:<pre class="source-code">
public class LoginModel{    [Required(ErrorMessage = "User name is required")]    public string UserName { get; set; } = string.Empty;    [Required(ErrorMessage = "Password is required")]    public string Password { get; set; } = string.Empty;}
public class AppUser : IdentityUser{    public string FirstName { get; set; }    public string LastName { get; set; }    public string ProfilePicture { get; set; }}</pre><p class="list-inset">If you <a id="_idIndexMarker710"/>add additional properties to the <code>AppUser</code> class, you need to add the corresponding properties for the <code>AddOrUpdateAppU<a id="_idTextAnchor317"/>serModel</code> as well.</pre></li> <li>Next, we<a id="_idIndexMarker711"/> need to configure the authentication service. First, let’s update the <code>appsettings.json</code> file to provide the configurations for JWT tokens:<pre class="source-code">
"JwtConfig": {    "ValidAudiences": "http://localhost:5056",    "ValidIssuer": "http://localhost:5056",    "Secret": "c1708c6d-7c94-466e-aca3-e09dcd1c2042"  }</pre><p class="list-inset">Update the configurations as per your requirements. Because we use the same web API to issue and validate the JWT token, we use the same URL for the <code>ValidAudiences</code> and <code>ValidIssuer</code> properties. The <code>Secret</code> property is used to sign the JWT token. You can use any string as the secret. In this case, we can use a <a id="_idIndexMarker712"/>GUID value. Also, please note that this is for demo purposes only. In a real-world application, you should store the secret in a secure location, such as Azure Key Vault.</p></li> <li>Update <a id="_idIndexMarker713"/>the <a id="_idIndexMarker714"/>code in the <code>Program.cs</code> file, as shown in the following code:<pre class="source-code">
// Omitted for brevitybuilder.Services.AddControllers();builder.Services.AddDbContext&lt;AppDbContext&gt;();builder.Services.AddIdentityCore&lt;AppUser&gt;()    .AddEntityFrameworkStores&lt;AppDbContext&gt;()    .AddDefaultTokenProviders();builder.Services.AddAuthentication(options =&gt;{    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;}).AddJwtBearer(options =&gt;{    var secret = builder.Configuration["JwtConfig:Secret"];    var issuer = builder.Configuration["JwtConfig:ValidIssuer"];    var audience = builder.Configuration["JwtConfig:ValidAudiences"];    if (secret is null || issuer is null || audience is null)    {        throw new ApplicationException("Jwt is not set in the configuration");    }    options.SaveToken = true;    options.RequireHttpsMetadata = false;    options.TokenValidationParameters = new TokenValidationParameters()    {        ValidateIssuer = true,        ValidateAudience = true,        ValidAudience = audience,        ValidIssuer = issuer,        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret))    };});// Omitted for brevityapp.UseHttpsRedirection();app.UseAuthentication();app.UseAuthorization();// Omitted for brevity</pre><p class="list-inset">In the<a id="_idIndexMarker715"/> preceding code, we configured the authentication service to use JWT tokens. The <code>AddIdentityCore()</code> method adds and configures the identity system for the specified <code>User</code> type. We also added <code>AppDbContext</code> and <code>AppUser</code> to the service collection and specified that we want to use EF Core to store the user data. The <code>AddDefaultTokenProviders()</code> method adds the default token providers for the application, which are used to generate tokens. The <code>Services.AddAuthentication()</code> method configures the authentication service to use JWT tokens. The <code>AddJwtBearer()</code> method configures the JWT bearer <a id="_idIndexMarker716"/>authentication handler, including the token validation parameters. We use some configurations from the <code>appsettings.json</code> file to configure the token validation parameters.</p><p class="list-inset">Finally, we need to call the <code>UseAuthentication()</code> and <code>UseAuthorization()</code> methods to enable authentication and authorizat<a id="_idTextAnchor318"/>ion in the application.</p></li> <li>Now, it’s <a id="_idIndexMarker717"/>time to create and update the database. We have already created the database context and the user entity. So, now, we need to create the database. To do that, just run the following command:<pre class="source-code">
<strong class="bold">dotnet ef migrations add InitialDb</strong><strong class="bold">dotnet ef database update</strong></pre><p class="list-inset">If the commands are executed successfully, you should see the database created with the following tables:</p></li> </ol>
<div><div><img alt="Figure 8.1 – The database tables created by ASP.NET Core Identity" src="img/B18971_08_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The database tables created by ASP.NET Core Identity</p>
<ol>
<li value="11">Another <a id="_idIndexMarker718"/>way to<a id="_idIndexMarker719"/> check whether the database <a id="_idIndexMarker720"/>has been created is to add the following code to the <code>Program.cs</code> file:<pre class="source-code">
using (var serviceScope = app.Services.CreateScope()){    var services = serviceScope.ServiceProvider;    // Ensure the database is created.    var dbContext = services.GetRequiredService&lt;AppDbContext&gt;();    dbContext.Database.EnsureCreated();}</pre><p class="list-inset">You can use either of the methods to check whether the database is created in the development environment.</p><p class="list-inset">The data for the users will be stored in these tables, which is convenient when using the default tables provide<a id="_idTextAnchor319"/>d by ASP.NET Core Identity.</p></li> </ol>
<p>Next, let’s <a id="_idIndexMarker721"/>apply the <code>Authorize</code> attribute <a id="_idIndexMarker722"/>to enable authentication and authorization for <code>WeatherForecastController</code>:</p>
<ol>
<li>Update <code>WeatherForecastController</code> by adding an <code>[Authorize]</code> attribute, as shown in the following code:<pre class="source-code">
[Authorize][ApiController][Route("[controller]")]public class WeatherForecastController : ControllerBase{    // ...}</pre><p class="list-inset">This <a id="_idIndexMarker723"/>attribute will ensure that the user is authenticated before accessing the controller. If the user is not authenticated, the controller will return a <code>401 Unauthorized</code> response. Test this by running the application and calling the <code>/WeatherForecast</code> endpoint. You should see a <code>401</code> response:</p></li> </ol>
<div><div><img alt="Figure 8.2 – When the user is not authenticated, the controller returns a 401 response" src="img/B18971_08_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – When the user is not authenticated, the controller returns a 401 response</p>
<p class="list-inset">The <code>Authorize</code> attribute can be applied to the controller or the action method. If the attribute is applied to the controller, all the action methods in the controller will be protected. If the attribute is applied to the action method, only that action method will be protected.</p>
<p class="list-inset">You can<a id="_idIndexMarker724"/> also use the <code>AllowAnonymous</code> attribute to allow anonymous access to the controller or action method. Note <a id="_idIndexMarker725"/>that the <code>AllowAnonymous</code> attribute overrides the <code>Authorize</code> attribute. So, if you apply both attributes to the controller or action method, the <code>AllowAnonymous</code> attribute will take precedence, which means that the controller or action method will be accessible to all the users.</p>
<ol>
<li value="2">Next, let’s add <code>AccountController</code> to handle the authentication requests. For <a id="_idIndexMarker726"/>example, we need to provide a <code>/account/register</code> endpoint. When the user sends the username and password, the application will create a record of the user in the database and generate a JWT token.<p class="list-inset">To generate a JWT token, we need to provide the following information:</p><ul><li><code>appsettings.json</code> file as described in the previous steps.</p></li>
<li>Next, create a new controller named <code>AccountController</code> to handle the authentication requests. Create a new class named <code>AccountController</code> in the <code>Controllers</code> folder. The <code>AccountController</code> class should inherit from the <code>ControllerBase</code> class, as shown in the following code:<pre class="source-code">
[ApiController][Route("[controller]")]public class AccountController(UserManager&lt;AppUser&gt; userManager, IConfiguration configuration) : ControllerBase{}</pre><p class="list-inset">We use the <code>UserManager</code> class to manage the users. The <code>UserManager</code> class is provided by ASP.NET Core Identity. We also need to inject the <code>IConfiguration</code> interface to get the configuration values from the <code>appsettings.json</code> file.</p></li> <li>Create a <a id="_idIndexMarker727"/>new method named <code>Register()</code> in the <code>AccountController</code> class. This <a id="_idIndexMarker728"/>method will be used to register a <a id="_idIndexMarker729"/>new user. The <code>Register()</code> method should accept an <code>AddOrUpdateAppUserModel</code> object as a parameter, as shown in the following code:<pre class="source-code">
[HttpPost("register")]public async Task&lt;IActionResult&gt; Register([FromBody] AddOrUpdateAppUserModel model){    // Check if the model is valid    if (ModelState.IsValid)    {        var existedUser = await userManager.FindByNameAsync(model.UserName);        if (existedUser != null)        {            ModelState.AddModelError("", "User name is already taken");            return BadRequest(ModelState);        }        // Create a new user object        var user = new AppUser()        {            UserName = model.UserName,            Email = model.Email,            SecurityStamp = Guid.NewGuid().ToString()        };        // Try to save the user        var result = await userManager.CreateAsync(user, model.Password);        // If the user is successfully created, return Ok        if (result.Succeeded)        {            var token = GenerateToken(model.UserName);            return Ok(new { token });        }        // If there are any errors, add them to the ModelState object        // and return the error to the client        foreach (var error in result.Errors)        {            ModelState.AddModelError("", error.Description);        }    }    // If we got this far, something failed, redisplay form    return BadRequest(ModelState);}
private string? GenerateToken(string userName){    var secret = _configuration["JwtConfig:Secret"];    var issuer = _configuration["JwtConfig:ValidIssuer"];    var audience = _configuration["JwtConfig:ValidAudiences"];    if (secret is null || issuer is null || audience is null)    {        throw new ApplicationException("Jwt is not set in the configuration");    }    var signingKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret));    var tokenHandler = new JwtSecurityTokenHandler();    var tokenDescriptor = new SecurityTokenDescriptor    {        Subject = new ClaimsIdentity(new[]        {            new Claim(ClaimTypes.Name, userName)        }),        Expires = DateTime.UtcNow.AddDays(1),        Issuer = issuer,        Audience = audience,        SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)    };    var securityToken = tokenHandler.CreateToken(tokenDescriptor);    var token = tokenHandler.WriteToken(securityToken);    return token;}</pre><p class="list-inset">In the<a id="_idIndexMarker733"/> preceding <a id="_idIndexMarker734"/>code, we are using<a id="_idIndexMarker735"/> the <code>JwtSecurityTokenHandler</code> class to generate the JWT token. The <code>JwtSecurityTokenHandler</code> class is provided by the <code>System.IdentityModel.Tokens.Jwt</code> NuGet package. First, we get the configuration values from the <code>appsettings.json</code> file. Then, we create a <code>SymmetricSecurityKey</code> object using the secret key. The <code>SymmetricSecurityKey</code> object is used to sign the token.</pre><p class="list-inset">Next, we created a <code>SecurityTokenDescriptor</code> object, which contains the following properties:</p><ul><li><code>Subject</code>: The subject of the token. The subject can be any value, such as the username, email address, and so on.</li><li><code>Expires</code>: The expiration date of the token.</li><li><code>Issuer</code>: The issuer of the token.</li><li><code>Audience</code>: The audience of the token.</li><li><code>SigningCredentials</code>: The credentials to sign the token. Note that we use the <code>HmacSha256Signature</code> algorithm to sign the token. It is a 256-bit HMAC cryptographic algorithm for digital signatures. If you encounter an error such as <code>IDX10603: The algorithm: 'HS256' requires the SecurityKey.KeySize to be greater than '128' bits.</code>, please check the secret key in the <code>appsettings.json</code> file. The secret key should be at least 16 characters long (16 * 8 = 128).</li></ul><p class="list-inset">Finally, we <a id="_idIndexMarker736"/>used the <code>JwtSecurityTokenHandler</code> class to create and write the token to a string value.</p></li> <li>Now, we <a id="_idIndexMarker737"/>can<a id="_idIndexMarker738"/> test the <code>Register()</code> method. Use <code>dotnet run</code> to run the application. You can use the Swagger UI or any other tools to test the API. Send a <code>POST</code> request with the following JSON data to the <code>http://localhost:5056/account/register</code> endpoint:<pre class="source-code">
{  "userName": "admin",  "email": "admin@example.com",  "password": "Passw0rd!"}</pre><p class="list-inset">You will see the response similar to the following:</p></li> </ol>
<div><div><img alt="Figure 8.3 – Registering a new user" src="img/B18971_08_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Registering a new user</p>
<p class="list-inset">As we<a id="_idIndexMarker739"/> can see, the <code>Register()</code> method returns a JWT token. The token is valid for 1 day. We <a id="_idIndexMarker740"/>can use this token to authenticate <a id="_idIndexMarker741"/>the user in the future. If you check the database, you will see that a new user has been created in the <code>AspNetUsers</code> table, and the password is hashed, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.4 – The new user has been created in the database" src="img/B18971_08_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The new user has been created in the database</p>
<ol>
<li value="6">Copy the token value and send a <code>GET</code> request to the <code>/WeatherForecast</code> endpoint. You need to attach the <code>Bearer</code> token to the request header, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 8.5 – Sending a request with the Bearer token" src="img/B18971_08_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Sending a request with the Bearer token</p>
<p class="callout-heading">Important note</p>
<p class="callout">When you attach the bearer token to the request, please note that there is a prefix of <code>Bearer</code> before the token value. So, the actual format should be</p>
<p class="callout"><code>Authorization: </code><code>Bearer &lt;token&gt;</code>.</p>
<p>OK, it works! Your API <a id="_idIndexMarker742"/>is<a id="_idIndexMarker743"/> now secured. The next step is <a id="_idIndexMarker744"/>to create a login method to authenticate the user. It is quite straightforward. Create a new method named <code>Login</code> in the <code>AccountController</code> class. The <code>Login()</code> method should accept an <code>AddOrUpdateAppUserModel</code> object as a parameter, as shown in the following code:</p>
<pre class="source-code">
[HttpPost("login")]public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel model)
{
    // Get the secret in the configuration
    // Check if the model is valid
    if (ModelState.IsValid)
    {
        var user = await _userManager.FindByNameAsync(model.UserName);
        if (user != null)
        {
            if (await _userManager.CheckPasswordAsync(user, model.Password))
            {
                var token = GenerateToken(model.UserName);
                return Ok(new { token });
            }
        }
        // If the user is not found, display an error message
        ModelState.AddModelError("", "Invalid username or password");
    }
    return BadRequest(ModelState);
}</pre>
<p>We use the <code>UserManager</code> class to find the user by the username. If the user is found, we use the <code>CheckPasswordAsync()</code> method to check<a id="_idIndexMarker745"/> the password. If the password is correct, we generate a new token and return it to the client. If the user is not found or the password is incorrect, we return an error message to the client.</p>
<p>So far, we <a id="_idIndexMarker746"/>have created a <a id="_idIndexMarker747"/>web API project with basic authentication and authorization. We also created a controller to handle account-related operations. Note that in this example, we have not implemented any specific authorization rules. All authenticated users can access the <code>WeatherForecast</code> endpoint.</p>
<p>Ne<a id="_idTextAnchor320"/>xt, we will discuss the details of the JWT token.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor321"/>Understanding the JWT token structure</h2>
<p>A JWT token is a <a id="_idIndexMarker748"/>string value. It is composed of three parts, separated by a dot (<code>.</code>):</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<p>The header and payload are encoded using the <code>Base64Url</code> algorithm. We can use <code>jwt.io</code> to decode the token. Copy the token in the response body and paste it into the <code>Encoded</code> field on the <code>jwt.io</code> website. You will see the decoded token, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.6 – Decoding the JWT token" src="img/B18971_08_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Decoding the JWT token</p>
<p>The header contains the<a id="_idIndexMarker749"/> algorithm used to sign the token. In our case, we use the <code>HmacSha256Signature</code> algorithm. So, the decoded header is as follows:</p>
<pre class="source-code">
{  "alg": "HS256",
  "typ": "JWT"
}</pre>
<p>The payload contains the claims of the token and some other additional data. In our case, the decoded payload is as follows:</p>
<pre class="source-code">
{  "unique_name": "admin",
  "nbf": 1679779000,
  "exp": 1679865400,
  "iat": 1679779000,
  "iss": "http://localhost:5056",
  "aud": "http://localhost:5056"
}</pre>
<p>There are some <a id="_idIndexMarker750"/>recommended (but not mandatory) registered claim names defined in RFC7519:</p>
<ul>
<li><code>sub</code>: The <code>sub</code> (subject) claim identifies the principal that is the subject of the token</li>
<li><code>nbf</code>: The <code>nbf</code> (not before) claim identifies the time before which the token <em class="italic">must not</em> be accepted for processing</li>
<li><code>exp</code>: The <code>exp</code> (expiration time) claim identifies the expiration time on or after which the token <em class="italic">must not</em> be accepted for processing</li>
<li><code>iat</code>: The <code>iat</code> (issued at) claim identifies the time at which the token was issued</li>
<li><code>iss</code>: The <code>iss</code> (issuer) claim identifies the principal that issued the token</li>
<li><code>aud</code>: The <code>aud</code> (audience) claim identifies the recipients that the token is intended for</li>
</ul>
<p>Note that in our case, we use the same value for the <code>iss</code> and <code>aud</code> claims because we use the same web API to issue and validate the token. In a real-world application, normally, there is a separate authentication server to issue the token so that the <code>iss</code> and <code>aud</code> claims have different values.</p>
<p>The signature is used to verify the token to make sure the token does not tamper. There are various algorithms to generate the signature. In our case, we use the <code>HmacSha256Signature</code> algorithm, so the signature is generated using the following formula:</p>
<p><code>HMACSHA256(base64UrlEncode(header) + "." + </code><code>base64UrlEncode(payload), secret)</code></p>
<p>Therefore, the <a id="_idIndexMarker751"/>token typically looks like <code>xxxxx.yyyyy.zzzzz</code>, which can be easily passed in the HTTP request he<a id="_idTextAnchor322"/>ader, or stored in the local storage of the browser.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor323"/>Consuming the API</h2>
<p>At this<a id="_idIndexMarker752"/> point, we have a secured API. You can find a sample client application named <code>AuthenticationDemoClient</code> in the <code>samples\chapter8\AuthenticationDemo\BasicAuthenticationDemo\end</code> folder. The client application is a simple console application. It uses the <code>HttpClient</code> class to send HTTP requests to the API. The main code is like this:</p>
<p>Login:</p>
<pre class="source-code">
var httpClient = new HttpClient();// Create a post request with the user name and password
var request = new HttpRequestMessage(HttpMethod.Post, "http://localhost:5056/authentication/login");
request.Content = new StringContent(JsonSerializer.Serialize(new LoginModel()
{
    UserName = userName,
    Password = password
}), Encoding.UTF8, "application/json");
var response = await httpClient.SendAsync(request);
var token = string.Empty;
if (response.IsSuccessStatusCode)
{
    var content = await response.Content.ReadAsStringAsync();
    var jwtToken = JsonSerializer.Deserialize&lt;JwtToken&gt;(content);
    Console.WriteLine(jwtToken.token);
    token = jwtToken.token;
}</pre>
<p>Get <a id="_idIndexMarker753"/>weather forecast:</p>
<pre class="source-code">
request = new HttpRequestMessage(HttpMethod.Get, "http://localhost:5056/WeatherForecast");// Add the token to the request header
request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
response = await httpClient.SendAsync(request);
if (response.IsSuccessStatusCode)
{
    var content = await response.Content.ReadAsStringAsync();
    var weatherForecasts = JsonSerializer.Deserialize&lt;IEnumerable&lt;WeatherForecast&gt;&gt;(content);
    foreach (var weatherForecast in weatherForecasts)
    {
        Console.WriteLine("Date: {0:d}", weatherForecast.Date);
        Console.WriteLine($"Temperature (C): {weatherForecast.TemperatureC}");
        Console.WriteLine($"Temperature (F): {weatherForecast.TemperatureF}");
        Console.WriteLine($"Summary: {weatherForecast.Summary}");
    }
}</pre>
<p>First, the client application sends a request to the login API to get the token. Then, it attaches the <a id="_idIndexMarker754"/>token to the request header and sends the request to the weather forecast AP<a id="_idTextAnchor324"/>I. If the token is valid, the API will return the data.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor325"/>Configuring the Swagger UI to support authorization</h2>
<p>You<a id="_idIndexMarker755"/> probably prefer to use the Swagger UI to test the APIs. The default configuration of the Swagger UI does not support <a id="_idIndexMarker756"/>authorization. We need to update the <code>AddSwaggerGen()</code> method in the <code>Program</code> class to support authorization. Update the <code>Program</code> class as follows:</p>
<pre class="source-code">
builder.Services.AddSwaggerGen(c =&gt;{
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] { }
        }
    });
});</pre>
<p>The<a id="_idIndexMarker757"/> preceding code adds the <code>Bearer</code> security definition to the Swagger UI. The <code>AddSecurityRequirement</code> method adds<a id="_idIndexMarker758"/> the <code>Authorization</code> header to the Swagger UI. Now, when you run the application, you will see the <strong class="bold">Authorize</strong> button in the Swagger UI. Click the <strong class="bold">Authorize</strong> button; you will see a pop-up window that allows you to enter the token, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.7 – Entering the token in the Swagger UI" src="img/B18971_08_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Entering the token in the Swagger UI</p>
<p>Enter the token<a id="_idIndexMarker759"/> in the <strong class="bold">Value</strong> field. Then, click the <strong class="bold">Authorize</strong> button. Now, you can test the APIs<a id="_idIndexMarker760"/> using the Swagger UI directly:</p>
<p class="callout-heading">Caution</p>
<p class="callout">You need to add the <code>Bearer</code> prefix to the token with a space.</p>
<div><div><img alt="Figure 8.8 – The Swagger UI is authorized" src="img/B18971_08_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The Swagger UI is authorized</p>
<p>You can find more information about the configuration for the Swagger UI here: <a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">https://github.com/domaindrivendev/Swashbuckle.AspNetCore</a>.</p>
<p>In this section, we discussed the implementation of a web API project that supports authentication and authorization, including the creation of a controller to handle the login request. Additionally, we explored how to generate a JWT token and validate it, as well as how to use a console application to access the project resource and how to configure the Swagger UI to test the APIs with authorization.</p>
<p>In the next section, we will learn more about authorization in ASP.NET Core. We will explore a couple of authorization types, including role-based authorization,<a id="_idTextAnchor326"/> claim-based authorization, and policy-based authorization.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor327"/>Delving deeper into authorization</h1>
<p>Authorization is <a id="_idIndexMarker761"/>the process of determining whether a user is allowed to perform a specific action. In the previous section, we implemented a web API project that enables simple authentication and authorization. By using the <code>Authorize</code> attribute, only authenticated users can access the API. However, in many scenarios, we need to implement granular authorization. For example, some resources are only accessible to the administrator, while some resources are accessible to normal users. In this section, we will explore how to implement granular authorization in ASP.NET Core, including role-based authorization<a id="_idTextAnchor328"/>, claim-based authorization, and policy-based authorization.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor329"/>Role-based authorization</h2>
<p>You can <a id="_idIndexMarker762"/>find the starter app and the completed app in this book’s GitHub repository at <code>chapter8/AuthorizationDemo/RoleBasedAuthorizationDemo</code>. The starter <a id="_idIndexMarker763"/>app is similar to the application we created in the previous section:</p>
<ol>
<li>We’ll start with the starter app. Don’t forget to create the database and run the migrations using the following commands:<pre class="source-code">
<code>AppRoles</code> that is defined as follows:<pre class="source-code">
public static class AppRoles{    public const string Administrator = "Administrator";    public const string User = "User";    public const string VipUser = "VipUser";}</pre></li> <li>In <a id="_idIndexMarker764"/>the <code>Program</code> class, we need to explicitly call the <code>AddRoles()</code> method after the <code>AddIdentityCore()</code> method. The updated code is as follows:<pre class="source-code">
// Use the `AddRoles()` methodbuilder.Services.AddIdentityCore&lt;AppUser&gt;()    .AddRoles&lt;IdentityRole&gt;()    .AddEntityFrameworkStores&lt;AppDbContext&gt;()    .AddDefaultTokenProviders();</pre><p class="list-inset">If you use the <code>AddIdentity()</code> method, you do not need to call the <code>AddRoles()</code> method. The <code>AddIdentity()</code> method will call the <code>AddRoles()</code> method internally.</p></li> <li>We<a id="_idIndexMarker765"/> also need to check whether the roles exist in the database. If not, we will create the roles. Add the code, as follows:<pre class="source-code">
using (var serviceScope = app.Services.CreateScope()){    var services = serviceScope.ServiceProvider;    var roleManager = app.Services.GetRequiredService&lt;RoleManager&lt;IdentityRole&gt;&gt;();    if (!await roleManager.RoleExistsAsync(AppRoles.User))    {        await roleManager.CreateAsync(new IdentityRole(AppRoles.User));    }    if (!await roleManager.RoleExistsAsync(AppRoles.VipUser))    {        await roleManager.CreateAsync(new IdentityRole(AppRoles.VipUser));    }    if (!await roleManager.RoleExistsAsync(AppRoles.Administrator))    {        await roleManager.CreateAsync(new IdentityRole(AppRoles.Administrator));    }}</pre></li> <li>Use <code>dotnet run</code> to run <a id="_idIndexMarker766"/>the application. You<a id="_idIndexMarker767"/> will see that the roles are created in the database:</li>
</ol>
<div><div><img alt="Figure 8.9 – Roles in the database" src="img/B18971_08_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Roles in the database</p>
<ol>
<li value="6">In the <code>AccountController</code> class, we have a <code>Register()</code> method that is used to register a new user. Let’s update the <code>Register()</code> method to assign the <code>User</code> role to the new user. The updated code is as follows:<pre class="source-code">
// Omitted for brevity// Try to save the uservar userResult = await userManager.CreateAsync(user, model.Password);// Add the user to the "User" rolevar roleResult = await userManager.AddToRoleAsync(user, AppRoles.User);// If the user is successfully created, return Okif (userResult.Succeeded &amp;&amp; roleResult.Succeeded){    var token = GenerateToken(model.UserName);    return Ok(new { token });}</pre><p class="list-inset">Similarly, we<a id="_idIndexMarker768"/> can create a new action to register an administrator or a VIP user. You can check the code in the completed app.</p></li> <li>You can<a id="_idIndexMarker769"/> register a new administrator using any HTTP client you like. After the users are created, you can view the users and their roles in the database, as shown in <em class="italic">Figure 8</em><em class="italic">.10</em>:</li>
</ol>
<div><div><img alt="Figure 8.10 – Users and their roles in the database" src="img/B18971_08_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Users and their roles in the database</p>
<p class="list-inset">The data of the <code>AspNetUserRoles</code> table is used to store the relationship between users and roles. The <code>UserId</code> column is the primary key of the <code>AspNetUsers</code> table, while the <code>RoleId</code> column is the primary key of the <code>AspNetRoles</code> table.</p>
<ol>
<li value="8">Next, we <a id="_idIndexMarker770"/>need to update the method that is used to generate the JWT token. When we generate the token, we need to <a id="_idIndexMarker771"/>include the roles of the user in the token. We can use the <code>GetRolesAsync()</code> method to get the roles and then add them to the claims. The updated code is as follows:<pre class="source-code">
var userRoles = await userManager.GetRolesAsync(user);var claims = new List&lt;Claim&gt;{    new(ClaimTypes.Name, userName)};claims.AddRange(userRoles.Select(role =&gt; new Claim(ClaimTypes.Role, role)));var tokenDescriptor = new SecurityTokenDescriptor{    Subject = new ClaimsIdentity(claims),    Expires = DateTime.UtcNow.AddDays(1),    Issuer = issuer,    Audience = audience,    SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)};</pre></li> <li>Try to run the application and register a new user or log in with an existing user. Copy the <a id="_idIndexMarker772"/>token in the response and paste it to the <code>jwt.io</code> website to decode the payload. You will see that the roles are included in the token, as shown here:<pre class="source-code">
{  "unique_name": "admin",  "role": "Administrator",  "nbf": 1679815694,  "exp": 1679902094,  "iat": 1679815694,  "iss": "http://localhost:5056",  "aud": "http://localhost:5056"}</pre></li> <li>Now, let’s<a id="_idIndexMarker773"/> update the <code>WeatherForecastController</code> class to implement role-based authorization. Add a new action for administrators, as follows:<pre class="source-code">
[HttpGet("admin", Name = "GetAdminWeatherForecast")][Authorize(Roles = AppRoles.Administrator)]public IEnumerable&lt;WeatherForecast&gt; GetAdmin(){    return Enumerable.Range(1, 20).Select(index =&gt; new WeatherForecast    {        Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),        TemperatureC = Random.Shared.Next(-20, 55),        Summary = Summaries[Random.Shared.Next(Summaries.Length)]    })    .ToArray();}</pre><p class="list-inset">The <code>Authorize</code> attribute is used to specify the role that is allowed to access the API. In the preceding code, only authenticated users with the <code>Administrator</code> role can access the API.</p><p class="list-inset">Now, you can test the API. If you use the token of a normal user to access the <code>/WeatherForecast/admin</code> endpoint, you will get a 403 Forbidden response.</p></li> </ol>
<p>Generally, the <code>administrator</code> role should have permission to access all resources. But in our <a id="_idIndexMarker774"/>current application, the administrator user cannot access the <code>/WeatherForecast</code> endpoint. There are multiple ways to fix this.</p>
<p>The first way<a id="_idIndexMarker775"/> is that when we register a new administrator, we can assign the <code>Administrator</code> role to the user and also assign the <code>User</code> role (or any other roles) to the user. This way, the administrator user can access all resources.</p>
<p>We can also update the <code>Authorize</code> attribute to allow multiple roles, like so:</p>
<pre class="source-code">
[HttpGet(Name = "GetWeatherForecast")][Authorize(Roles = $"{AppRoles.User},{AppRoles.VipUser},{AppRoles.Administrator}")]
public IEnumerable&lt;WeatherForecast&gt; Get()
{
    // Omitted for brevity
}</pre>
<p>The preceding code means that the user must have at least one of the specified roles to access the API.</p>
<p>Note that if you<a id="_idIndexMarker776"/> apply multiple <code>Authorize</code> attributes with specified roles to an action, the user must have all the roles to access the API. For example, consider the following code:</p>
<pre class="source-code">
[HttpGet("vip", Name = "GetVipWeatherForecast")][Authorize(Roles = AppRoles.User)]
[Authorize(Roles = AppRoles.VipUser)]
public IEnumerable&lt;WeatherForecast&gt; GetVip()
{
    // Omitted for brevity
}</pre>
<p>The <a id="_idIndexMarker777"/>preceding code states that the user must have both the <code>User</code> and <code>VipUser</code> roles to access the API. If the user has only one of the roles, the user will get a 403 Forbidden response.</p>
<p>Besides this, we can also define a policy to specify the roles that are allowed to access the API. For example, in the <code>Program</code> class, we can add the following code:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;{
    options.AddPolicy("RequireAdministratorRole", policy =&gt; policy.RequireRole(AppRoles.Administrator));
    options.AddPolicy("RequireVipUserRole", policy =&gt; policy.RequireRole(AppRoles.VipUser));
    options.AddPolicy("RequireUserRole", policy =&gt; policy.RequireRole(AppRoles.User));
    options.AddPolicy("RequireUserRoleOrVipUserRole", policy =&gt; policy.RequireRole(AppRoles.User, AppRoles.VipUser));
});</pre>
<p>Then, we can update the <code>Authorize</code> attribute to use the policy like this:</p>
<pre class="source-code">
[HttpGet("admin-with-policy", Name = "GetAdminWeatherForecastWithPolicy")][Authorize(Policy = "RequireAdministratorRole")]
public IEnumerable&lt;WeatherForecast&gt; GetAdminWithPolicy()
{
    // Omitted for brevity
}</pre>
<p>If the <code>policy.RequireRole()</code> method has multiple roles in parameters, the user must<a id="_idIndexMarker778"/> have at least one of the roles to access the API. You<a id="_idIndexMarker779"/> can check the code in the completed app.</p>
<p>With that, we’ve implemented role-based authorization in ASP.NET Core. In<a id="_idTextAnchor330"/> the next section, we will learn how to implement claim-based authorization.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor331"/>Claim-based authorization</h2>
<p>When<a id="_idIndexMarker780"/> a user is authenticated, the user will <a id="_idIndexMarker781"/>have a set of claims that are used to store the information about the user. For example, the user can have a claim that specifies the user’s role. So, technically, roles are also claims, but they are special claims that are used to store the roles of the user. We can store other information in the claims, such as the user’s name, email address, date of birth, driving license number, and more. Once we’ve done this, the authorization system can check the claims to determine whether the user is allowed to access the resource. Claim-based authorization provides more granular access control than role-based authorization, but it can be more complex to implement and manage.</p>
<p>You can find the starter app and the completed app in the <code>chapter8/AuthorizationDemo/ClaimBasedAuthorizationDemo</code> folder in this book’s GitHub repository:</p>
<ol>
<li>We’ll start with the starter app. Don’t forget to create the database and run the migrations using the following commands:<pre class="source-code">
<code>ClaimTypes</code> class that contains the common claim types, such as <code>NameIdentifier</code>,  <code>DateOfBirth</code>, <code>Email</code>, <code>Gender</code>, <code>GivenName</code>, <code>Name</code>, <code>PostalCode</code>, and others, including <code>Role</code>. This is why we said that roles are also claims. You<a id="_idIndexMarker783"/> can also define your own claim types. For example, we can define the following claim types in the <code>AppClaimTypes</code> class:<pre class="source-code">
public static class AppClaimTypes{    public const string DrivingLicenseNumber = "DrivingLicenseNumber";    public const string AccessNumber = "AccessNumber";}</pre></li> <li>Also, create a new <code>AppAuthorizationPolicies</code> class to define the authorization policies:<pre class="source-code">
public static class AppAuthorizationPolicies{    public const string RequireDrivingLicenseNumber = "RequireDrivingLicenseNumber";    public const string RequireAccessNumber = "RequireAccessNumber";}</pre></li> <li>Then, we can add the claims to the token when the user logs in. Update the <code>GenerateToken</code> method<a id="_idIndexMarker784"/> in the <code>AccountController</code> class, as <a id="_idIndexMarker785"/>follows:<pre class="source-code">
// Omitted for brevityvar tokenDescriptor = new SecurityTokenDescriptor{    Subject = new ClaimsIdentity(new[]    {        new Claim(ClaimTypes.Name, userName),        // Suppose the user's information is stored in the database so that we can retrieve it from the database        new Claim(ClaimTypes.Country, "New Zealand"),        // Add our custom claims        new Claim(AppClaimTypes.AccessNumber, "12345678"),        new Claim(AppClaimTypes.DrivingLicenseNumber, "123456789")    }),    Expires = DateTime.UtcNow.AddDays(1),    Issuer = issuer,    Audience = audience,    SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)};// Omitted for brevity</pre><p class="list-inset">We can<a id="_idIndexMarker786"/> add any claims to the token. In the preceding code, we added the <code>Country</code>, <code>AccessNumber</code>, and <code>DrivingLicenseNumber</code> claims to the token.</p></li> <li>Imagine that<a id="_idIndexMarker787"/> we have a requirement that only users who have their driving licenses can access the resource. We can implement this by adding the following code to the <code>Program</code> class:<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;{    options.AddPolicy(AppAuthorizationPolicies.RequireDrivingLicense, policy =&gt; policy.RequireClaim(AppClaimTypes.DrivingLicenseNumber));    options.AddPolicy(AppAuthorizationPolicies.RequireAccessNumber, policy =&gt; policy.RequireClaim(AppClaimTypes.AccessNumber));});</pre><p class="list-inset">So, the<a id="_idIndexMarker788"/> difference between role-based authorization and claim-based authorization is that claim-based authorization uses <code>policy.RequireClaim()</code> to check the claims, while role-based authorization uses <code>policy.RequireRole()</code> to check the roles.</p></li> <li>At this point, we can update the <code>Authorize</code> attribute so that it uses the policy, like this:<pre class="source-code">
[Authorize(Policy = AppAuthorizationPolicies.RequireDrivingLicense)][HttpGet("driving-license")]public IActionResult GetDrivingLicense(){    var drivingLicenseNumber = User.Claims.FirstOrDefault(c =&gt; c.Type == AppClaimTypes.DrivingLicenseNumber)?.Value;    return Ok(new { drivingLicenseNumber });}</pre></li> <li>Run the<a id="_idIndexMarker789"/> application and test the <code>/WeatherForecast/driving-license</code> endpoint. You will get a <code>401</code> Unauthorized response because the user does not have the <code>DrivingLicenseNumber</code> claim. Register a user or log in to get the token. Then, add the token to the <code>Authorization</code> header and call the <code>/WeatherForecast/driving-license</code> endpoint again. You will get a 200 OK response with <code>drivingLicenseNumber</code> in the response body.<p class="list-inset">The token <a id="_idIndexMarker790"/>now contains the claims, as shown in the following JSON response:</p><pre class="source-code">
{  "unique_name": "user",  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/country": "New Zealand",  "AccessNumber": "12345678",  "DrivingLicenseNumber": "123456789",  "nbf": 1679824749,  "exp": 1679911149,  "iat": 1679824749,  "iss": "http://localhost:5056",  "aud": "http://localhost:5056"}</pre></li> <li>This is the simplest way to implement claim-based authorization. The current approach only checks whether the token contains the claim; it does not check the value of the claim. We can check the values as well. The <code>RequireClaim()</code> method also has an overload that accepts <code>allowedValues</code> as a parameter. For example, we have a resource that can only be accessed by<a id="_idIndexMarker791"/> users based in New Zealand. We can update the <code>Program</code> class as follows:<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;{    // Omitted for brevity    options.AddPolicy(AppAuthorizationPolicies.RequireCountry, policy =&gt; policy.RequireClaim(ClaimTypes.Country, "New Zealand"));});
options.AddPolicy(AppAuthorizationPolicies.RequireCountry, policy =&gt; policy.RequireClaim(ClaimTypes.Country, "New Zealand", "Australia"));</pre><p class="list-inset">The action in the controller looks like this:</pre><pre class="source-code">[Authorize(Policy = AppAuthorizationPolicies.RequireCountry)][HttpGet("country")]public IActionResult GetCountry(){    var country = User.Claims.FirstOrDefault(c =&gt; c.Type == ClaimTypes.Country)?.Value;    return Ok(new { country });}</pre><p class="list-inset">You can test the API by calling the <code>/WeatherForecast/country</code> endpoint. Now, only users who have the <code>Country</code> claim with the value of <code>New Zealand</code> can access the resource.</p></li> </ol>
<p>Similar to roles, we<a id="_idIndexMarker793"/> can apply multiple policies to a resource. For example, we can require the user to have both the <code>DrivingLicense</code> and <code>AccessNumber</code> claims to access the resource. Just like roles, you can add <a id="_idIndexMarker794"/>two policies to the <code>Authorize</code> attribute, which means that the user must have both the <code>DrivingLicense</code> and <code>AccessNumber</code> claims to access the resource. Here’s an example:</p>
<pre class="source-code">
[Authorize(Policy = AppAuthorizationPolicies.RequireDrivingLicense)][Authorize(Policy = AppAuthorizationPolicies.RequireAccessNumber)]
[HttpGet("driving-license-and-access-number")]
public IActionResult GetDrivingLicenseAndAccessNumber()
{
    var drivingLicenseNumber = User.Claims.FirstOrDefault(c =&gt; c.Type == AppClaimTypes.DrivingLicenseNumber)?.Value;
    var accessNumber = User.Claims.FirstOrDefault(c =&gt; c.Type == AppClaimTypes.AccessNumber)?.Value;
    return Ok(new { drivingLicenseNumber, accessNumber });
}</pre>
<p>Another way is to use the <code>RequireAssertion()</code> method, which allows us to execute a custom logic to check the claims. Update the <code>Program</code> class, as follows:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;{
    // Omitted for brevity
    options.AddPolicy(AppAuthorizationPolicies.RequireDrivingLicenseAndAccessNumber, policy =&gt; policy.RequireAssertion(context =&gt;
    {
        var hasDrivingLicenseNumber = context.User.HasClaim(c =&gt; c.Type == AppClaimTypes.DrivingLicenseNumber);
        var hasAccessNumber = context.User.HasClaim(c =&gt; c.Type == AppClaimTypes.AccessNumber);
        return hasDrivingLicenseNumber &amp;&amp; hasAccessNumber;
    }));
});</pre>
<p>In the <a id="_idIndexMarker795"/>preceding code, the <code>context</code> parameter contains the <code>User</code> property that contains the claims. We can use the <code>HasClaim()</code> method to check whether the user has the claim. Then, we can return <code>true</code> if the <a id="_idIndexMarker796"/>user has both the <code>DrivingLicenseNumber</code> and <code>AccessNumber</code> claims; otherwise, we return <code>false</code>. You can also use the <code>context.User.Claims</code> property to get the claims and check the values per your requirement.</p>
<p>The action in the controller looks like this:</p>
<pre class="source-code">
[Authorize(Policy = AppAuthorizationPolicies.RequireDrivingLicenseAndAccessNumber)][HttpGet("driving-license-and-access-number")]
public IActionResult GetDrivingLicenseAndAccessNumber()
{
    // Omitted for brevity
}</pre>
<p>In this section, we learned how to implement claim-based authorization in ASP.NET Core. We also learned how to use the <code>RequireAssertion()</code> method to check the claims. If we need a more complex authorization logic, we can us<a id="_idTextAnchor332"/>e policy-based authorization. But first, let’s learn how authorization works in ASP.NET Core.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor333"/>Understanding the authorization process</h2>
<p>In the <a id="_idIndexMarker797"/>previous section, we learned how to implement role-based authorization and claim-based authorization. Let’s delve deeper into the details. You may have noticed that when we use role-based authorization or claim-based authorization, we need to call the <code>AddPolicy()</code> method in the <code>AddAuthorization</code> method. The signature of the <code>AddPolicy()</code> method is as follows:</p>
<pre class="source-code">
public void AddPolicy(string name, Action&lt;AuthorizationPolicyBuilder&gt; configurePolicy){
    // Omitted for brevity
}</pre>
<p>The <code>AddPolicy()</code> method accepts two parameters:</p>
<ul>
<li>A <code>name</code> parameter, which is the name of the policy</li>
<li>A <code>configurePolicy</code> parameter, which is a delegate that accepts an <code>AuthorizationPolicyBuilder</code> parameter</li>
</ul>
<p>You can press <em class="italic">F12</em> to check the source code of the <code>AuthorizationPolicyBuilder</code> class. You will find that it has some methods to configure the policy, such as <code>RequireRole()</code>, <code>RequireClaim()</code>, and others. The source code of the <code>RequireRole</code> method looks like this:</p>
<pre class="source-code">
public AuthorizationPolicyBuilder RequireRole(IEnumerable&lt;string&gt; roles){
    ArgumentNullThrowHelper.ThrowIfNull(roles);
    Requirements.Add(new RolesAuthorizationRequirement(roles));
    return this;
}</pre>
<p>The source code of the <code>RequireClaim()</code> method is shown here:</p>
<pre class="source-code">
public AuthorizationPolicyBuilder RequireClaim(string claimType){
    ArgumentNullThrowHelper.ThrowIfNull(claimType);
    Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues: null));
    return this;
}</pre>
<p>Both the <code>RequireRole()</code> and <code>RequireClaim()</code> methods call the <code>Requirements.Add()</code> method under the hood. So, what is the <code>Requirements</code> object?</p>
<p>We are getting<a id="_idIndexMarker798"/> closer to the core of authorization in ASP.NET Core. The definition of the <code>Requirements</code> object is as follows:</p>
<pre class="source-code">
public IList&lt;IAuthorizationRequirement&gt; Requirements { get; set; } = new List&lt;IAuthorizationRequirement&gt;();</pre> <p>The <code>Requirements</code> object in the <code>AuthorizationPolicyBuilder</code> class is a list of <code>IAuthorizationRequirement</code> objects. The <code>IAuthorizationRequirement</code> interface is just a marker service, and it does not have any methods. Let’s press <em class="italic">F12</em> on the <code>RolesAuthorizationRequirement</code> class and the <code>ClaimsAuthorizationRequirement</code> class. We will see their source code:</p>
<pre class="source-code">
// RolesAuthorizationRequirementpublic class RolesAuthorizationRequirement : AuthorizationHandler&lt;RolesAuthorizationRequirement&gt;, IAuthorizationRequirement
{
    // Omitted for brevity
}
// ClaimsAuthorizationRequirement
public class ClaimsAuthorizationRequirement : AuthorizationHandler&lt;ClaimsAuthorizationRequirement&gt;, IAuthorizationRequirement
{
    // Omitted for brevity
}</pre>
<p>As we can <a id="_idIndexMarker799"/>see, both the <code>RolesAuthorizationRequirement</code> and <code>ClaimsAuthorizationRequirement</code> classes implement the <code>IAuthorizationRequirement</code> interface. They also implement the <code>AuthorizationHandler&lt;TRequirement&gt;</code> class, which is defined as follows:</p>
<pre class="source-code">
public abstract class AuthorizationHandler&lt;TRequirement&gt; : IAuthorizationHandler        where TRequirement : IAuthorizationRequirement
{
    /// &lt;summary&gt;
    /// Makes a decision if authorization is allowed.
    /// &lt;/summary&gt;
    /// &lt;param name="context"&gt;The authorization context.&lt;/param&gt;
    public virtual async Task HandleAsync(AuthorizationHandlerContext context)
    {
        foreach (var req in context.Requirements.OfType&lt;TRequirement&gt;())
        {
            await HandleRequirementAsync(context, req).ConfigureAwait(false);
        }
    }
    /// &lt;summary&gt;
    /// Makes a decision if authorization is allowed based on a specific requirement.
    /// &lt;/summary&gt;
    /// &lt;param name="context"&gt;The authorization context.&lt;/param&gt;
    /// &lt;param name="requirement"&gt;The requirement to evaluate.&lt;/param&gt;
    protected abstract Task HandleRequirementAsync(AuthorizationHandlerContext context, TRequirement requirement);
}</pre>
<p>So, each <a id="_idIndexMarker800"/>implementation of the <code>AuthorizationHandler&lt;TRequirement&gt;</code> class implements the <code>HandleRequirementAsync()</code> method to check the requirements. For example, the <code>RolesAuthorizationRequirement</code> class consists of the following code:</p>
<pre class="source-code">
public RolesAuthorizationRequirement(IEnumerable&lt;string&gt; allowedRoles){
    ArgumentNullThrowHelper.ThrowIfNull(allowedRoles);
    if (!allowedRoles.Any())
    {
        throw new InvalidOperationException(Resources.Exception_RoleRequirementEmpty);
    }
    AllowedRoles = allowedRoles;
}
/// &lt;summary&gt;
/// Gets the collection of allowed roles.
/// &lt;/summary&gt;
public IEnumerable&lt;string&gt; AllowedRoles { get; }
/// &lt;summary&gt;
/// Makes a decision if authorization is allowed based on a specific requirement.
/// &lt;/summary&gt;
/// &lt;param name="context"&gt;The authorization context.&lt;/param&gt;
/// &lt;param name="requirement"&gt;The requirement to evaluate.&lt;/param&gt;
protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, RolesAuthorizationRequirement requirement)
{
    if (context.User != null)
    {
        var found = false;
        foreach (var role in requirement.AllowedRoles)
        {
            if (context.User.IsInRole(role))
            {
                found = true;
                break;
            }
        }
        if (found)
        {
            context.Succeed(requirement);
        }
    }
    return Task.CompletedTask;
}</pre>
<p>When a <code>RolesAuthorizationRequirement</code> instance is instantiated, it accepts a collection <a id="_idIndexMarker801"/>of roles from the constructor. Then, it uses the <code>HandleRequirementAsync()</code> method to check whether the user is in the role. If the user is in the role, it calls the <code>context.Succeed()</code> method to set the <code>Succeeded</code> property to <code>true</code>. Otherwise, it sets the <code>Succeeded</code> property to <code>false</code>.</p>
<p>If you check the implementation of the <code>ClaimsAuthorizationRequirement</code> class, you will find it is similar to the <code>RolesAuthorizationRequirement</code> class. It accepts <code>claimType</code> and a set of <code>allowValues</code> and checks whether the user has the claim, and whether the claim value is in the <code>allowValues</code> set.</p>
<p>The next question is – who is responsible for calling these methods?</p>
<p>Let’s go back to the <code>Program</code> class to understand the middleware pipeline. We have the <code>app.UseAuthorization()</code> method in the <code>Program</code> file, which is used to add the authorization middleware. Press <em class="italic">F12</em> on the <code>UseAuthorization</code> method. We’ll be able to view its source code:</p>
<pre class="source-code">
public static IApplicationBuilder UseAuthorization(this IApplicationBuilder app){
    // Omitted for brevity
    return app.UseMiddleware&lt;AuthorizationMiddleware&gt;();
}</pre>
<p>Continue<a id="_idIndexMarker802"/> to press <em class="italic">F12</em> to check the source code of <code>AuthorizationMiddleware</code>. You will see the following code in the <code>Invoke()</code> method:</p>
<pre class="source-code">
// Omitted for brevityvar authorizeData = endpoint?.Metadata.GetOrderedMetadata&lt;IAuthorizeData&gt;() ?? Array.Empty&lt;IAuthorizeData&gt;();
var policies = endpoint?.Metadata.GetOrderedMetadata&lt;AuthorizationPolicy&gt;() ?? Array.Empty&lt;AuthorizationPolicy&gt;();
// Omitted for brevity
var policyEvaluator = context.RequestServices.GetRequiredService&lt;IPolicyEvaluator&gt;();
var authenticateResult = await policyEvaluator.AuthenticateAsync(policy, context);
// Omitted for brevity
var authorizeResult = await policyEvaluator.AuthorizeAsync(policy, authenticateResult!, context, resource);
// Omitted for brevity</pre>
<p>Now, we are closer. The <code>AuthorizationMiddleware</code> class gets the policies from the endpoint metadata and then calls the <code>IPolicyEvaluator.AuthenticateAsync()</code> method to check whether the user is authenticated, after which it calls the <code>IPolicyEvaluator.AuthorizeAsync()</code> method to check whether the user is authorized. The <code>IPolicyEvaluator</code> interface is defined as follows:</p>
<pre class="source-code">
public interface IPolicyEvaluator{
    Task&lt;AuthenticateResult&gt; AuthenticateAsync(AuthorizationPolicy policy, HttpContext context);
    Task&lt;PolicyAuthorizationResult&gt; AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context, object? resource);
}</pre>
<p>The default<a id="_idIndexMarker803"/> implementation of <code>IPolicyEvaluator</code> has been injected into the DI container by the ASP.NET Core framework. You can find the source code of the <code>PolicyEvaluator</code> class here: <code>https://source.dot.net/#Microsoft.AspNetCore.Authorization.Policy/PolicyEvaluator.cs</code>. You will see it has an <code>IAuthorizationService</code> object injected into it, which is defined as follows:</p>
<pre class="source-code">
public interface IAuthorizationService{
    Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object? resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements);
    Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object? resource, string policyName);
}</pre>
<p>With that, we’ve found the <code>IAuthorizationRequirement</code> class we described earlier!</p>
<p>You can find the source code of the default implementation of <code>IAuthorizationService</code> here: <a href="https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs">https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs</a>. It is<a id="_idIndexMarker804"/> also injected into the DI container by the framework. The core code is as follows:</p>
<pre class="source-code">
public virtual async Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object? resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements){
    ArgumentNullThrowHelper.ThrowIfNull(requirements);
    var authContext = _contextFactory.CreateContext(requirements, user, resource);
    var handlers = await _handlers.GetHandlersAsync(authContext).ConfigureAwait(false);
    foreach (var handler in handlers)
    {
        await handler.HandleAsync(authContext).ConfigureAwait(false);
        if (!_options.InvokeHandlersAfterFailure &amp;&amp; authContext.HasFailed)
        {
            break;
        }
    }
    var result = _evaluator.Evaluate(authContext);
    if (result.Succeeded)
    {
        _logger.UserAuthorizationSucceeded();
    }
    else
    {
        _logger.UserAuthorizationFailed(result.Failure);
    }
    return result;
}</pre>
<p>So, we end up <a id="_idIndexMarker805"/>with the following call stack:</p>
<ol>
<li>Define the authorization policy (requirement) in the <code>Program</code> class.</li>
<li>Apply the authorization policy to the endpoint.</li>
<li>Apply the authorization middleware to the pipeline.</li>
<li>The request comes in with the <code>Authorization</code> header, which can be retrieved from the <code>HttpContext</code> object.</li>
<li><code>AuthorizationMiddleware</code> calls the <code>IPolicyEvaluator.AuthorizeAsync()</code> method.</li>
<li>The <code>IPolicyEvaluator.AuthorizeAsync()</code> method calls the <code>IAuthorizationService.AuthorizeAsync()</code> method.</li>
<li>The <code>IAuthorizationService.AuthorizeAsync()</code> method calls the <code>IAuthorizationHandler.HandleAsync()</code> method to check whether the user is authorized.</li>
</ol>
<p>Once we understand the call stack, we can easily implement an authorization policy by im<a id="_idTextAnchor334"/>plementing the <code>IAuthorizationRequirement</code>, <code>IAuthorizationHandler</code>, and <code>IAuthorizationService</code> interfaces.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor335"/>Policy-based authorization</h2>
<p>In the<a id="_idIndexMarker806"/> previous section, we explained that both role-based authorization and claim-based authorization are implemented by the <code>IAuthorizationRequirement</code>, <code>IAuthorizationHandler</code>, and <code>IAuthorizationService</code> interfaces under the hood. If we have more complex authorization logic, we can use policy-based authorization directly, which allows us to define custom <a id="_idIndexMarker807"/>authorization policies to execute complex authorization logic.</p>
<p>For example, we have a scenario where we need to support the following authorization logic:</p>
<ul>
<li>The special premium content can be accessed by the user who has a <code>Premium</code> subscription and is also based in New Zealand</li>
<li>Users who have a <code>Premium</code> subscription, but are not based in New Zealand, cannot access the special premium content</li>
</ul>
<p>There may be other complex authorization logic in the real world. Let’s implement the aforementioned authorization logic using policy-based authorization. You can find the sample code in the <code>/</code><code>samples/chapter8/AuthorizationDemo/PolicyBasedAuthorization</code> folder:</p>
<ol>
<li>First, add two classes to the <code>Authentication</code> folder, as follows:<pre class="source-code">
public static class AppClaimTypes{    public const string Subscription = "Subscription";}public static class AppAuthorizationPolicies{    public const string SpecialPremiumContent = "SpecialPremiumContent";}</pre><p class="list-inset">These<a id="_idIndexMarker808"/> classes define the claim types and authorization policies we need. You can also<a id="_idIndexMarker809"/> use strings directly in the code, but it is recommended to use constants to avoid typos.</p></li> <li>In the <code>AccountController</code> class, update the <code>GenerateToken()</code> method with a new claim, as follows:<pre class="source-code">
private string? GenerateToken(string userName, string country){    // Omitted for brevity    var tokenDescriptor = new SecurityTokenDescriptor    {        Subject = new ClaimsIdentity(new[]        {            new Claim(ClaimTypes.Name, userName),            new Claim(AppClaimTypes.Subscription, "Premium"),            new Claim(ClaimTypes.Country, country)        }),        Expires = DateTime.UtcNow.AddDays(1),        Issuer = issuer,        Audience = audience,        SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)    };    // Omitted for brevity}</pre><p class="list-inset">We <a id="_idIndexMarker810"/>added a new claim, <code>AppClaimTypes.Subscription</code>, with a value of <code>Premium</code> to the token. This claim <a id="_idIndexMarker811"/>represents the user’s subscription type. We also added a new claim, <code>ClaimTypes.Country</code>, to the token. This claim represents the user’s country. In the real world, you can get the user’s subscription type and country from the database. Let’s assume we have the subscription type and country information in the token for simplicity.</p></li> <li>Next, update the <code>Login()</code> method in the <code>AccountController</code> class to add the country to the claims and create another method for New Zealand users, as follows:<pre class="source-code">
[HttpPost("login-new-zealand")]public async Task&lt;IActionResult&gt; LoginNewZealand([FromBody] LoginModel model){    if (ModelState.IsValid)    {        var user = await userManager.FindByNameAsync(model.UserName);        if (user != null)        {            if (await userManager.CheckPasswordAsync(user, model.Password))            {                var token = GenerateToken(model.UserName, "New Zealand");                return Ok(new { token });            }        }        // If the user is not found, display an error message        ModelState.AddModelError("", "Invalid username or password");    }    return BadRequest(ModelState);}[HttpPost("login")]public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel model){    if (ModelState.IsValid)    {        var user = await userManager.FindByNameAsync(model.UserName);        if (user != null)        {            if (await userManager.CheckPasswordAsync(user, model.Password))            {                var token = GenerateToken(model.UserName, "Australia");                return Ok(new { token });            }        }        // If the user is not found, display an error message        ModelState.AddModelError("", "Invalid username or password");    }    return BadRequest(ModelState);}</pre><p class="list-inset">Again, this<a id="_idIndexMarker812"/> is a simplified implementation <a id="_idIndexMarker813"/>for demonstration purposes. In the real world, generally, there is only one login endpoint, and the country information is retrieved from the database or other sources, such as IP addresses.</p></li> <li>Next, we need to implement the authorization policy. Create a new class named <code>SpecialPremiumContentRequirement</code> in the <code>Authorization</code> folder, as follows:<pre class="source-code">
public class SpecialPremiumContentRequirement : IAuthorizationRequirement{    public string Country { get; }    public SpecialPremiumContentRequirement(string country)    {        Country = country;    }}</pre><p class="list-inset">This class implements the <code>IAuthorizationRequirement</code> interface. The <code>Country</code> property<a id="_idIndexMarker814"/> represents the country where the premium content can be accessed. We can use this property to check whether the user is authorized to access the premium content.</p></li> <li>Next, we <a id="_idIndexMarker815"/>need to implement the <code>AuthorizationHandler</code> interface. Create a <code>SpecialPremiumContentAuthorizationHandler</code> class in the <code>Authorization</code> folder, as follows:<pre class="source-code">
public class SpecialPremiumContentAuthorizationHandler : AuthorizationHandler&lt;SpecialPremiumContentRequirement&gt;{    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, SpecialPremiumContentRequirement requirement)    {        var hasPremiumSubscriptionClaim = context.User.HasClaim(c =&gt; c.Type == "Subscription" &amp;&amp; c.Value == "Premium");        if (!hasPremiumSubscriptionClaim)        {            return Task.CompletedTask;        }        var countryClaim = context.User.FindFirst(c =&gt; c.Type == ClaimTypes.Country);        if (countryClaim == null || string.IsNullOrWhiteSpace(countryClaim.ToString()))        {            return Task.CompletedTask;        }        if (countryClaim.Value == requirement.Country)        {            context.Succeed(requirement);        }        return Task.CompletedTask;    }}</pre><p class="list-inset">This <a id="_idIndexMarker816"/>handler is used to check whether the requirement is satisfied. If the user has a <code>Premium</code> subscription and is based <a id="_idIndexMarker817"/>in the country where the premium content can be accessed, the requirement is satisfied. Otherwise, the requirement is not satisfied.</p></li> <li>Next, we need to register the authorization policy and the authorization handler. Update the <code>Program</code> class, as follows:<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;{    options.AddPolicy(AppAuthorizationPolicies.SpecialPremiumContent, policy =&gt;    {        policy.Requirements.Add(new SpecialPremiumContentRequirement("New Zealand"));    });});builder.Services.AddSingleton&lt;IAuthorizationHandler, SpecialPremiumContentAuthorizationHandler&gt;();</pre><p class="list-inset">In the <a id="_idIndexMarker818"/>preceding code, we registered the authorization policy, <code>AppAuthorizationPolicies.SpecialPremiumContent</code>, with the <code>SpecialPremiumContentRequirement</code> requirement. The <code>SpecialPremiumContentRequirement</code> requirement is satisfied if the user has a <code>Premium</code> subscription and is based in New Zealand. We also registered the <code>SpecialPremiumContentAuthorizationHandler</code> handler as a singleton service.</p></li> <li>Finally, we<a id="_idIndexMarker819"/> need to apply the authorization policy to the controller. Open the <code>WeatherForecastController</code> class and add a new action, as shown in the following code:<pre class="source-code">
[Authorize(Policy = AppAuthorizationPolicies.SpecialPremiumContent)][HttpGet("special-premium", Name = "GetPremiumWeatherForecast")]public IEnumerable&lt;WeatherForecast&gt; GetPremium(){    // Omitted for brevity}</pre><p class="list-inset">This action can only be accessed by users who have a <code>Premium</code> subscription and are based in New Zealand. If the user does not have a <code>Premium</code> subscription or is not based in New Zealand, the authorization policy will not be satisfied, and the user will not be able to access the action.</p></li> </ol>
<p>You can <a id="_idIndexMarker820"/>test the application as we did in the previous section. The application has two login endpoints – one for New Zealand users and one for<a id="_idIndexMarker821"/> Australian users. If you log in as a New Zealand user, you can access the <code>WeatherForecast/special-premium</code> endpoint. Otherwise, you will get a <code>403</code> response.</p>
<p>There are some points to note for policy-based authorization:</p>
<ul>
<li>You can use one <code>AuthorizationHandler</code> instance to handle multiple requirements. in the <code>HandleAsync()</code> method, you can use <code>AuthorizationHandlerContext.PendingRequirements</code> to get all the pending requirements and then check them one by one.</li>
<li>If you have multiple <code>AuthorizationHandler</code> instances, they will be invoked in any order, which means you cannot expect the order of the handlers.</li>
<li>You need to call <code>context.Succeed(requirement)</code> to mark the requirement as satisfied.</li>
</ul>
<p>What if the requirement is not satisfied? There are two options:</p>
<ul>
<li>Generally, you do not need to call <code>context.Fail()</code> to mark the failed requirement because there may be other handlers to handle the same requirement, which may be satisfied.</li>
<li>If you want to make sure the requirement fails and indicate that the whole authorization process fails, you can call <code>context.Fail()</code> explicitly, and set the <code>InvokeHandlersAfterFailure</code> property to <code>false</code> in the <code>AddAuthorization()</code> method, like this:<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;  {      options.AddPolicy(AppAuthorizationPolicies.PremiumContent, policy =&gt;      {          policy.Requirements.Add(new PremiumContentRequirement("New Zealand"));      });      options.InvokeHandlersAfterFailure = false;  });</pre></li> </ul>
<p>In this <a id="_idIndexMarker822"/>section, we<a id="_idIndexMarker823"/> explored the three types of authorization available in ASP.NET Core: role-based, claim-based, and policy-based. We examined the source code to gain a deeper understanding of how authorization works. With this knowledge, you should now b<a id="_idTextAnchor336"/>e able to confidently use the authorization features of ASP.NET Core. Next, we will learn how to manage users and roles.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor337"/>Managing users and roles</h1>
<p>In the<a id="_idIndexMarker824"/> previous sections, we implemented the authentication and authorization features. Generally, the application should also provide a way to manage users and roles. ASP.NET Core Identity provides a set of APIs to manage users and roles. In this section, we will introduce how to use these APIs.</p>
<p>Previously, we <a id="_idIndexMarker825"/>learned that the <code>IdentityDbContext</code> class is used to store the user and role information. So, we do not need to create a new database context class. Similarly, we can use <code>UserManager</code> and <code>RoleManager</code> to manage users and roles without having to write any code.</p>
<p>Here are some common operations for managing users by using the <code>UserManager</code> class:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-6">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>CreateAsync(TUser user, </code><code>string password)</code></p>
</td>
<td class="No-Table-Style">
<p>Creates a user with the given password.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>UpdateUserAsync(TUser user)</code></p>
</td>
<td class="No-Table-Style">
<p>Updates a user.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>FindByNameAsync(string userName)</code></p>
</td>
<td class="No-Table-Style">
<p>Finds a user by name.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>FindByIdAsync(string userId)</code></p>
</td>
<td class="No-Table-Style">
<p>Finds a user by ID.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>FindByEmailAsync(string email)</code></p>
</td>
<td class="No-Table-Style">
<p>Finds a user by email.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DeleteAsync(TUser user)</code></p>
</td>
<td class="No-Table-Style">
<p>Deletes a user.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>AddToRoleAsync(TUser user, </code><code>string role)</code></p>
</td>
<td class="No-Table-Style">
<p>Adds the user to a role.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetRolesAsync(TUser user)</code></p>
</td>
<td class="No-Table-Style">
<p>Gets a list of roles for the user.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>IsInRoleAsync(TUser user, </code><code>string role)</code></p>
</td>
<td class="No-Table-Style">
<p>Checks whether the user has a role.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>RemoveFromRoleAsync(TUser user, </code><code>string role)</code></p>
</td>
<td class="No-Table-Style">
<p>Removes the user from a role.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>CheckPasswordAsync(TUser user, </code><code>string password)</code></p>
</td>
<td class="No-Table-Style">
<p>Checks whether the password is correct for the user.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ChangePasswordAsync(TUser user, string currentPassword, </code><code>string newPassword)</code></p>
</td>
<td class="No-Table-Style">
<p>Changes the user’s password. The user must provide the correct current password.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GeneratePasswordResetTokenAsync(TUser user)</code></p>
</td>
<td class="No-Table-Style">
<p>Generates a token for resetting the user’s password. You need to specify <code>options.Token.PasswordResetTokenProvider</code> in the <code>AddIdentityCore()</code> method.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GenerateEmailConfirmationTokenAsync(TUser user)</code></p>
</td>
<td class="No-Table-Style">
<p>Generates a token for confirming the user’s email. You need to specify <code>options.Tokens.EmailConfirmationTokenProvider</code> in the <code>AddIdentityCore()</code> method.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ConfirmEmailAsync(TUser user, </code><code>string token)</code></p>
</td>
<td class="No-Table-Style">
<p>Checks whether the user has a valid email confirmation token. If the token matches, this method will set the <code>EmailConfirmed</code> property of the user to <code>true</code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – Common operations for managing users</p>
<p>Here <a id="_idIndexMarker826"/>are some <a id="_idIndexMarker827"/>common operations for managing roles by using the <code>RoleManager</code> class:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>CreateAsync(TRole role)</code></p>
</td>
<td class="No-Table-Style">
<p>Creates a role</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>RoleExistsAsync(string roleName)</code></p>
</td>
<td class="No-Table-Style">
<p>Checks whether the role exists</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>UpdateAsync(TRole role)</code></p>
</td>
<td class="No-Table-Style">
<p>Updates a role</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DeleteAsync(TRole role)</code></p>
</td>
<td class="No-Table-Style">
<p>Deletes a role</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>FindByNameAsync(string roleName)</code></p>
</td>
<td class="No-Table-Style">
<p>Finds a role by name</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.2 – Common operations for managing roles</p>
<p>These APIs encapsulate the database operations, so we can use them to manage users and roles<a id="_idIndexMarker828"/> easily. Some <a id="_idIndexMarker829"/>of the methods return a <code>Task&lt;IdentityResult&gt;</code> object. The <code>IdentityResult</code> object contains a <code>Succeeded</code> property to indicate whether the operation is successful. If the operation is not successful, you can get the error messages by using the <code>Errors</code> property.</p>
<p>We will not cover all the APIs in this book. You can find more information in the ASP.NET Core documentation. Next, we will learn about the new built-in Identity API endpoints in ASP.NET Core 8.0.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor338"/>New Identity API endpoints in ASP.NET Core 8</h1>
<p>In the previous <a id="_idIndexMarker830"/>sections, we learned how to implement authentication and authorization using the built-in Identity APIs in ASP.NET Core. We developed a couple of endpoints to register, log in, and manage users and roles. ASP.NET Core 8.0 introduces a new set of features to simplify authentication for web APIs. In this section, we will introduce these new endpoints.</p>
<p>Note that this new feature is only for simple authentication scenarios. The token generated by the Identity API endpoints is opaque, not a JWT token, which means it is intended to be used by the same application only. However, it is still a choice for a quick start. In ASP.NET Core 8.0, we can use a new <code>MapIdentityApi()</code> method to map the Identity API endpoints without writing any implementation as we did in the previous sections. Let’s learn how to use it:</p>
<ol>
<li>First, follow <em class="italic">steps 1</em> to <em class="italic">5</em> in the <em class="italic">Creating a sample project with authentication and authorization</em> section to create a new web API project named <code>NewIdentityApiDemo</code>. Note that you do not need to install the <code>Microsoft.AspNetCore.Authentication.JwtBearer</code> package because we will not use JWT tokens in this sample project.</li>
<li>Add the authorization policy service and register <code>DbContext</code> in the <code>Program.cs</code> file, as follows:<pre class="source-code">
builder.Services.AddAuthorization();builder.Services.AddDbContext&lt;AppDbContext&gt;();</pre></li> <li>Run the following commands to create the database and the migration:<pre class="source-code">
dotnet ef migrations add InitialDbdotnet ef database update</pre></li> <li>Register the Identity API endpoints in the <code>Program.cs</code> file, as follows:<pre class="source-code">
builder.Services.AddIdentityApiEndpoints&lt;AppUser&gt;().AddEntityFrameworkStores&lt;AppDbContext&gt;();</pre><p class="list-inset">The <code>AddIdentityApiEndpoints()</code> method adds a set of common identity services to the application by calling the <code>AddIdentityCore&lt;TUser&gt;()</code> method under the hood. It also configures authentication to support identity bearer tokens and cookies, so we do not need to explicitly call the <code>AddIdentityCore&lt;AppUser&gt;()</code> method.</p></li> <li>Map <a id="_idIndexMarker831"/>the Identity API endpoints in the <code>Program.cs</code> file, as follows:<pre class="source-code">
app.MapGroup("/identity").MapIdentityApi&lt;AppUser&gt;();</pre><p class="list-inset">The preceding code maps the Identity API endpoints to the <code>/identity</code> path. You can change it to any path you like, such as <code>api/accounts</code>, <code>/users</code>, and so on. Note that as we use an <code>AppUser</code> instead of the default <code>IdentityUser</code>, we must specify the <code>AppUser</code> type in the <code>MapIdentityApi()</code> method.</p></li> <li>Apply the <code>[Authorize]</code> attribute to the <code>WeatherForecastController</code> class, as follows:<pre class="source-code">
[Authorize] [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase {     // Omitted for brevity }</pre></li> <li>Run the application using <code>dotnet run</code>. You will see the new Identity API endpoints in the Swagger UI:</li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 8.11 – Identity API endpoints in the Swagger UI" src="img/B18971_08_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Identity API endpoints in the Swagger UI</p>
<ol>
<li value="8">Now, you <a id="_idIndexMarker832"/>can explore the new Identity API endpoints. Send a <code>POST</code> request with the following body to the <code>/identity/register</code> endpoint to register a new user:<pre class="source-code">
{   "userName": "admin",   "email": "admin@example.com",   "password": "Passw0rd!" }
{   "email": "admin@example.com",   "password": "Passw0rd!" }</pre><p class="list-inset">You will get a response that contains the access token and refresh token:</pre><pre class="source-code">{   "tokenType": "Bearer",   "accessToken": "CfDJ8L-NUxrCjhBJqmxaYaETqK0P0...",   "expiresIn": 3600,   "refreshToken": "CfDJ8L-NUxrCjhBJqmxaYaETqK2U..." }</pre></li> </ol>
<p>Then, you can <a id="_idIndexMarker833"/>use the access token to request the protected <code>/weatherforecast</code> endpoint with the <code>Authorization</code> header, as we introduced in the previous sections.</p>
<p>This new feature also provides endpoints such as <code>refreshToken</code>, <code>confirmEmail</code>, <code>resetPassword</code>, <code>2fa</code>, and others. Feel free to explore them on your<a id="_idTextAnchor339"/> own.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor340"/>Understanding OAuth 2.0 and OpenID Connect</h1>
<p>Previously, we learned how to implement authentication and authorization using built-in Identity APIs in ASP.NET Core. However, you may encounter some terms such as OAuth 2.0 and OpenID Connect when you work on a real project. It would be helpful to understand what they are and how to use them in ASP.NET Core. It is worth authoring a full book on OAuth 2.0 and OpenID Connect. In this section, we will introduce some basic concepts surrounding OAuth 2.0 and OpenID Connect, as well as some third-party authentication and authorization provid<a id="_idTextAnchor341"/>ers.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor342"/>What is OAuth 2.0?</h2>
<p>Let’s start <a id="_idIndexMarker834"/>with a real example. When you use LinkedIn, you may see a window that prompts you to sync your contacts from Outlook, Gmail, Yahoo, or other email services. This is because LinkedIn would like to know your contacts so that it can recommend you to invite your friends to join LinkedIn or to connect with them. This is a typical example where OAuth 2.0 is used:</p>
<div><div><img alt="Figure 8.12 – Syncing contacts on LinkedIn" src="img/B18971_08_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Syncing contacts on LinkedIn</p>
<p>If you fill in your email address and click the <strong class="bold">Continue</strong> button, you will be redirected to the email service provider’s website. For example, I use Outlook, so I will see a window like this because I have multiple accounts:</p>
<div><div><img alt="Figure 8.13 – Prompting to log into Outlook" src="img/B18971_08_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Prompting to log into Outlook</p>
<p>Note the URL in<a id="_idIndexMarker835"/> the address bar. It will look something like this:</p>
<pre class="source-code">
https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&amp;redirect_uri=https%3A%2F%2Fwww.linkedin.com%2Fgenie%2Ffinishauth&amp;scope=openid%20email%20People.Read&amp;response_type=code&amp;state=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</pre> <p>The URL contains <a id="_idIndexMarker836"/>the <strong class="bold">client ID</strong> of the application, which is used to identify the application. It also<a id="_idIndexMarker837"/> contains the <strong class="bold">redirect URL</strong> so that the authorization server can redirect the user back to the application after the user grants permission.</p>
<p>You need to log into the email service provider’s website and authorize LinkedIn to access your contacts. If <a id="_idIndexMarker838"/>you have already logged in, you will see this window:</p>
<div><div><img alt="Figure 8.14 – Authorizing LinkedIn to access your contacts" src="img/B18971_08_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Authorizing LinkedIn to access your contacts</p>
<p>After you authorize LinkedIn, you will be redirected back to LinkedIn. LinkedIn will get the contacts from the email service provider and show them to you.</p>
<p>We do not <a id="_idIndexMarker839"/>want to allow LinkedIn to know the password of our email address. In this case, OAuth 2.0 and OpenID Connect are used to authorize LinkedIn to access our contacts without knowing our password.</p>
<p>OAuth 2.0 <a id="_idIndexMarker840"/>implements a <strong class="bold">delegated authorization</strong> model. It allows a client to access a protected resource on behalf of a user. There are some<a id="_idIndexMarker841"/> entities involved in the OAuth 2.0 model:</p>
<ul>
<li><strong class="bold">Resource owner</strong>: The user who owns the protected resource. In our example, the resource owner is the user who owns the email address.</li>
<li><strong class="bold">Client</strong>: The client application that wants to access the protected resource. In our example, the client is LinkedIn. Note that this client is not the user’s browser.</li>
<li><strong class="bold">Resource server</strong>: The server that hosts the protected resource. In our example, the resource server is the email service provider – for example, Outlook.</li>
<li><strong class="bold">Authorization server</strong>: The server that handles the delegated authorization. In our example, the authorization server is Microsoft Identity Platform. An <strong class="bold">Authorization</strong> server has at least two endpoints:<ul><li>The <strong class="bold">authorization endpoint</strong> is <a id="_idIndexMarker842"/>used to interact with the end user and obtain an authorization grant</li><li>The <strong class="bold">token endpoint</strong> is <a id="_idIndexMarker843"/>used with the client to exchange an authorization grant for an access token:</li></ul></li>
</ul>
<div><div><img alt="Figure 8.15 – OAuth 2.0 flow" src="img/B18971_08_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – OAuth 2.0 flow</p>
<p>Note that the<a id="_idIndexMarker844"/> client (LinkedIn) must register itself as a known client to the authorization server (Microsoft) before it can access the protected resource. The client must <a id="_idIndexMarker845"/>provide a <strong class="bold">client ID</strong> and a <strong class="bold">client secret</strong> to the <a id="_idIndexMarker846"/>authorization server to prove its identity. That is why we can see LinkedIn’s Microsoft Graph Connector in <em class="italic">Figure 8</em><em class="italic">.14</em>.</p>
<p>The common steps of<a id="_idIndexMarker847"/> OAuth 2.0 are as follows:</p>
<ol>
<li>The client requests access to a protected resource.</li>
<li>The client redirects the user to the authorization server, such as Microsoft, Google, and so on. Specifically, it redirects to the authorization endpoint of the authorization server. After the user is authenticated, the authorization server will prompt the user, asking something like “Hi, I have a <strong class="bold">known</strong> client named LinkedIn, which wants to access my APIs using your privileges. Specifically, it wants to access your contacts so that it can send emails on your behalf. Do you want to grant access to LinkedIn?” This is what <em class="italic">Figure </em><em class="italic">8</em><em class="italic">.14</em> shows.</li>
<li>Once the user<a id="_idIndexMarker848"/> accepts the request, the authorization server will generate an <strong class="bold">authorization code</strong>, which is just an opaque string that confirms the user did grant access to the client (LinkedIn). The authorization server will redirect the user back to the client (LinkedIn).</li>
<li>The authorization code is sent to the client (LinkedIn) as a query string parameter.</li>
<li>The <a id="_idIndexMarker849"/>client (LinkedIn) now has an authorization code. Next, it will use the authorization code, client ID, and client secret to request an <strong class="bold">access token</strong> from<a id="_idIndexMarker850"/> the token endpoint of the authorization server. It may ask something like “Hi, I am LinkedIn. This user has granted me access to the contacts of this email address. This is my client credentials (client id and client secret). I also have an authorization code. Can I get access to this?”</li>
<li>The authorization server will verify the client credentials and the authorization code. If all is good, it will generate an access token and send it back to the client (LinkedIn). The access token is a string that can be used to access the protected resource. It is usually a JWT token. It may also contain the <strong class="bold">scope</strong>, which is the permission that the<a id="_idIndexMarker851"/> client (LinkedIn) has been granted. For example, it may be <strong class="bold">Contacts.Read</strong>.</li>
<li>The client (LinkedIn) can now use this access token to access the protected resource. It may ask something like “Hi, I am LinkedIn. I have an access token. Can I access the contacts of this email address?” The resource server checks the access token and if it is valid, it will return the protected resource to the client (LinkedIn).</li>
</ol>
<p>In this way, the client can access the protected resource without knowing the user’s password. Because the access token has a scope, it can only access the protected resource within the scope. For example, if the scope is <code>Contacts.Read</code>, the client can only read the contacts, but it cannot modify the contacts. This mechanism provides a good balance between secur<a id="_idTextAnchor343"/>ity and usability.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor344"/>What is OpenID Connect?</h2>
<p>OAuth <a id="_idIndexMarker852"/>was initially designed and released in 2006 and later revised and standardized in 2012 as OAuth 2.0. OAuth 2.0 solves the problem of delegated authorization. However, there are some other scenarios that OAuth 2.0 cannot solve. For example, your API may need to know the identity of the user who is accessing the API, but users may not want to create an account for your API. They may already have an account in some other services, such as Microsoft, Google, and others. In this case, it would be more convenient if the user could use their existing account to access your API. However, OAuth 2.0 was not designed to implement sign-in with an existing account. This is where a new specification named OpenID Connect comes in.</p>
<p>OpenID Connect <a id="_idIndexMarker853"/>is an authentication layer on top of OAuth 2.0 that was designed by the OpenID Foundation in 2014. OpenID Connect is like an extension of OAuth 2.0 that adds and defines some new features to retrieve the identity of the user, including profile information such as the user’s name, email address, and so on. OpenID Connect uses <a id="_idIndexMarker854"/>similar terminology and concepts as OAuth 2.0, such as <strong class="bold">client</strong>, <strong class="bold">resource owner</strong>, <strong class="bold">authorization server</strong>, and others. However, keep<a id="_idIndexMarker855"/> in mind that OpenID Connect is not a replacement for OAuth 2.0. Instead, it is a specification that extends OAuth 2.0 to support authentication.</p>
<p>Many popular identity providers, such as Microsoft, Google, Facebook, and others, have implemented OpenID Connect so that you can integrate your API application with their identity provider. Then, users can use their existing account to sign into your API application. Here is an example of how OpenID Connect works on <a href="http://Medium.com">Medium.com</a>:</p>
<div><div><img alt="Figure 8.16 – Medium.com sign-in with multiple identity providers" src="img/B18971_08_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Medium.com sign-in with multiple identity providers</p>
<p>If you <a id="_idIndexMarker856"/>click <strong class="bold">Sign in with Google</strong>, you will be redirected to Google to sign in. Then, you will be redirected back to Medium.com so that you can use your existing Google account to sign in to Medium.com. This is what OpenID Connect does.</p>
<p>Similar to OAuth 2.0, OpenID Connect also generates an access token. It also introduces a new token <a id="_idIndexMarker857"/>called <strong class="bold">ID token</strong>, which is a JWT token that contains the identity of the user. The client application can inspect and validate the ID token to extract identity info<a id="_idTextAnchor345"/>rmation about the user.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor346"/>Integrating with other identity providers</h2>
<p>Many identity providers <a id="_idIndexMarker858"/>support OpenID Connect so that you can integrate your API application with these platforms. Here are some popular<a id="_idIndexMarker859"/> identity providers:</p>
<ul>
<li><strong class="bold">Microsoft</strong>: Microsoft <a id="_idIndexMarker860"/>provides <a id="_idIndexMarker861"/>Microsoft Identity Platform for authentication and authorization. For more information, see <a href="https://learn.microsoft.com/zh-cn/azure/active-directory/develop/">https://learn.microsoft.com/zh-cn/azure/active-directory/develop/</a>.</li>
<li><strong class="bold">Google</strong>: Sign in<a id="_idIndexMarker862"/> with Google is a service that helps <a id="_idIndexMarker863"/>you quickly and easily manage user authentication and share the user’s profile information with your application. For more information, see <a href="https://developers.google.com/identity/gsi/web/guides/overview">https://developers.google.com/identity/gsi/web/guides/overview</a>.</li>
<li><strong class="bold">Facebook</strong>: Facebook<a id="_idIndexMarker864"/> Login is a convenient way for <a id="_idIndexMarker865"/>people to log into your application using their Facebook account. For more information, see <a href="https://developers.facebook.com/products/facebook-login/">https://developers.facebook.com/products/facebook-login/</a>.</li>
<li><strong class="bold">Auth0</strong>: Auth0 is <a id="_idIndexMarker866"/>a cloud-based identity management<a id="_idIndexMarker867"/> platform that provides authentication, authorization, and related security services for web, mobile, and legacy applications. For more information, see <a href="https://auth0.com/docs/quickstart/backend">https://auth0.com/docs/quickstart/backend</a>.</li>
<li><strong class="bold">Okta</strong>: Okta <a id="_idIndexMarker868"/>is also a cloud-based identity platform that <a id="_idIndexMarker869"/>allows organizations to manage and secure user authentication and authorization across multiple applications and services. For more information, see <a href="https://www.okta.com/">https://www.okta.com/</a>.</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">In March 2021, Okta acquired Auth0. However, the two companies will continue to operate separately. Generally, Auth0 targets smaller companies and is known for its developer-friendly features, but Okta is considered to be more focused on large enterprises and offers more advanced features such as network integration, single sign-on, and more.</p>
<p>If you need to build an identity provider yourself, there are also some open-source projects that you can use:</p>
<ul>
<li><code>IdentityServer</code>: <code>IdentityServer</code> is <a id="_idIndexMarker870"/>one of the most flexible and standards-compliant OpenID Connect and OAuth 2.0 frameworks for ASP.NET Core. It is widely used by many companies to secure their applications and APIs. Note that <code>IdentityServer</code> is open-source, but it is not free now. The last free version is IdentityServer4, which was released in 2021, but it is no longer maintained. Duende Software now provides a commercial version of <code>IdentityServer</code>. For more information, see <a href="https://duendesoftware.com/products/identityserver">https://duendesoftware.com/products/identityserver</a>.</li>
<li><code>OpenIddict</code>: <code>OpenIddict</code> is <a id="_idIndexMarker871"/>an open-source OpenID Connect stack for ASP.NET Core. It provides a versatile solution to implement OpenID Connect client, server, token validation, and more. However, it is not a turnkey solution. You need to write some custom code to implement some business logic, such as an authorization controller, and more. For more information, see <a href="https://github.com/openiddict/openiddict-core">https://github.com/openiddict/openiddict-core</a>.</li>
<li><code>KeyCloak</code>: <code>KeyCloak</code> is an<a id="_idIndexMarker872"/> open-source identity and access management solution. It provides features such as single sign-on, user federation, strong authentication, user management, fine-grained authorization, and more. It is container-based, so it can easily be deployed in a containerized environment. For more information, see <a href="https://www.keycloak.org/">https://www.keycloak.org/</a>.</li>
</ul>
<p>We will not cover the details of how to integrate with these identity providers in this book. Plea<a id="_idTextAnchor347"/>se refer to the documentation instead.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor348"/>Other security topics</h1>
<p>As we mentioned at the beginning of this chapter, security is a very broad topic. In this section, we will briefly<a id="_idTextAnchor349"/> introduce some other security topics.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor350"/>Always use Hypertext Transfer Protocol Secure (HTTPS)</h2>
<p>HTTPS is a <a id="_idIndexMarker873"/>protocol that provides<a id="_idIndexMarker874"/> secure communication between a client and a server. It is a combination of the HTTP <a id="_idIndexMarker875"/>and <strong class="bold">Secure Sockets Layer/Transport Layer Security</strong> (<strong class="bold">SSL/TLS</strong>) protocols. HTTPS is used to encrypt communication between the client and the server, ensuring that sensitive data transmitted over the internet is secure and cannot be intercepted by unauthorized third parties. Google Chrome and other modern browsers will display a warning if you try to access a website that does not use HTTPS. Therefore, it is very important to use HTTPS for all your web applications.</p>
<p>The default ASP.NET Core web API template can use both HTTP and HTTPS. It is recommended to use HTTPS only. So, we need to configure the project to redirect all HTTP requests to HTTPS.</p>
<p>To do that, we need to add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
app.UseHttpsRedirection();</pre> <p>This code applies the <code>UseHttpsRedirection</code> middleware to redirect HTTP requests to HTTPS.</p>
<p>When you run the application locally, ASP.NET Core will automatically generate a self-signed certificate and use it to encrypt communication. However, when you deploy the application to a production environment, you need to use a certificate issued by a trusted <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>), such<a id="_idIndexMarker876"/><a id="_idTextAnchor351"/> as DigiCert, Comodo, GeoTrust, and so on.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor352"/>Using a strong password policy</h2>
<p>The<a id="_idIndexMarker877"/> default password policy we implemented in previous sections is <a id="_idIndexMarker878"/>not secure enough. Users can use any password, which might be a security risk. It is important to force users to use strong, unique passwords that are difficult for others to guess or crack. Generally, a good password should be a combination of uppercase and lowercase letters, numbers, and special characters. The length of the password should be at least 8 characters. We can define a <a id="_idIndexMarker879"/>password policy to enforce these rules.</p>
<p>We can <a id="_idIndexMarker880"/>specify the password policy in the <code>Program</code> class. Add the following code after the <code>AddAuthentication()</code> method:</p>
<pre class="source-code">
builder.Services.Configure&lt;IdentityOptions&gt;(options =&gt;{
    // Password settings
    options.Password.RequireDigit = true;
    options.Password.RequireLowercase = true;
    options.Password.RequireNonAlphanumeric = true;
    options.Password.RequireUppercase = true;
    options.Password.RequiredLength = 8;
    options.Password.RequiredUniqueChars = 1;
    // User settings
    options.User.AllowedUserNameCharacters =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+";
    options.User.RequireUniqueEmail = true;
});</pre>
<p>The preceding code is easy to understand. In this example, we require the password to contain at least one uppercase letter, one lowercase letter, one number, and one special character, and the length of the password should be at least 8 characters. We also require the user’s email to be unique. So, if a user tries to register with an email that is already in use, the registration will fail. Now, the user’s password should be hard to guess.</p>
<p>We can also enforce the password policy when the user fails to log in. For example, if the user fails to log in three times, the account will be locked for 5 minutes. This can help prevent brute-force attacks. To <a id="_idIndexMarker881"/>enable this feature, add the following code after the <code>AddAuthentication()</code> method:</p>
<pre class="source-code">
builder.Services.Configure&lt;IdentityOptions&gt;(options =&gt;{
    // Omitted for brevity
    // Lockout settings
    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5);
    options.Lockout.MaxFailedAccessAttempts = 3;
    options.Lockout.AllowedForNewUsers = true;
});</pre>
<p>This<a id="_idIndexMarker882"/> change works when we use <code>SignInManager.CheckPasswordSignInAsync()</code> method to sign in. In previous examples, we used <code>UserManager</code>. So, we need to update the <code>Login()</code> method in the <code>AuthenticationController</code> class. First, we need to inject <code>SignInManager</code> into the controller. Then, we must update the <code>AuthenticationController</code> class, as follows:</p>
<pre class="source-code">
[HttpPost("login")]public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel model)
{
    // Check if the model is valid
    if (ModelState.IsValid)
    {
        var user = await _userManager.FindByNameAsync(model.UserName);
        if (user != null)
        {
            var result =
                await _signInManager.CheckPasswordSignInAsync(user, model.Password, lockoutOnFailure: true);
            if (result.Succeeded)
            {
                var token = GenerateToken(model.UserName);
                return Ok(new { token });
            }
        }
        // If the user is not found, display an error message
        ModelState.AddModelError("", "Invalid username or password");
    }
    return BadRequest(ModelState);
}</pre>
<p>The <a id="_idIndexMarker883"/>preceding code uses the <code>SignInManager.CheckPasswordSignInAsync()</code> method to sign in, which has a parameter named <code>lockoutOnFailure</code> that specifies whether the account should be locked out <a id="_idIndexMarker884"/>when the user fails to log in. The default value is <code>false</code>, so we need to use <code>true</code> to enable the lockout feature.</p>
<p>Note that if you use <code>AddIdentityCore&lt;AppUser&gt;()</code> in <code>Program.cs</code>, as we mentioned in the previous section, <code>SignInManager</code> is not available by default. In this case, you need to explicitly add the <code>SignInManager</code> service to the <code>ConfigureServices()</code> method, like this:</p>
<pre class="source-code">
builder.Services.AddIdentityCore&lt;AppUser&gt;()    .AddSignInManager()
    .AddEntityFrameworkStores&lt;AppDbContext&gt;()
    .AddDefaultTokenProviders();</pre>
<p>Let’s test the <a id="_idIndexMarker885"/>application. Run the application using <code>dotnet run</code> and create a new user using the <code>Register</code> API. You will find that if the password is too simple, you will get an<a id="_idIndexMarker886"/> error message. Here is a sample request:</p>
<pre class="source-code">
{  "userName": "user",
  "email": "user@example.com",
  "password": "123456"
}</pre>
<p>You will get a <code>400</code> response with the following error message:</p>
<pre class="source-code">
{  "": [
    "Passwords must be at least 8 characters.",
    "Passwords must have at least one non alphanumeric character.",
    "Passwords must have at least one lowercase ('a'-'z').",
    "Passwords must have at least one uppercase ('A'-'Z')."
  ]
}</pre>
<p>If you attempt to log in with an incorrect password more than three times, you will be locked out of the system for 5 minutes. During this period, you will not be able to access the system, even if you enter the correct password. After those 5 min<a id="_idTextAnchor353"/>utes have elapsed, you will be able to log in again.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor354"/>Implementing two-factor authentication (2FA)</h2>
<p>2FA is a <a id="_idIndexMarker887"/>security process that requires users to provide two different forms of authentication to verify their identity. Besides the <a id="_idIndexMarker888"/>common username and password, 2FA adds an extra layer of security by requiring users to provide a second authentication factor, such as a code sent to their mobile phone or authenticator app, fingerprint, face recognition, and so on. This makes it harder for hackers to gain access to user accounts. Even if the hacker gets the user’s password, they still cannot get the second factor. 2FA is widely used in banking and financial <a id="_idIndexMarker889"/>services to protect users’ sensitive information.</p>
<p><strong class="bold">Multi-factor authentication</strong> (<strong class="bold">MFA</strong>) is a<a id="_idIndexMarker890"/> superset <a id="_idIndexMarker891"/>of 2FA. It requires users to provide more than two factors to verify their identity. There are two types of MFA:</p>
<ul>
<li><strong class="bold">MFA Time-based One-Time Password</strong> (<strong class="bold">TOTP</strong>): MFA TOTP is a type of MFA that <a id="_idIndexMarker892"/>requires users to provide a code generated by an authenticator app (such as Google Authenticator or Microsoft Authenticator). The code is valid for a short period, usually 30 seconds. After the code expires, the user needs to generate a new code. This type of MFA is widely used in banking and financial services. If you use a bank app, you might have seen this type of MFA. It requires the server and authenticator app to have an accurate time.</li>
<li><strong class="bold">MFA Fast Identity Online 2</strong> (<strong class="bold">FIDO2</strong>): MFA FIDO2 is a type of MFA that requires users to <a id="_idIndexMarker893"/>authenticate using a hardware key, such as a USB key or a biometric device (such as a fingerprint scanner). It has become more popular in recent years. However, ASP.NET Core does not support FIDO2 directly yet.</li>
<li><strong class="bold">MFA SMS</strong>: MFA SMS <a id="_idIndexMarker894"/>is no longer recommended because there are many security issues with SMS.</li>
</ul>
<p>To learn more about<a id="_idIndexMarker895"/> MFA, please refer to <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa</a>.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor356"/>Implementing rate-limiting</h2>
<p>Rate-limiting<a id="_idIndexMarker896"/> is a security mechanism that limits the number of <a id="_idIndexMarker897"/>requests a <a id="_idIndexMarker898"/>client can make to a server. It can prevent malicious clients from making too many requests, which can<a id="_idIndexMarker899"/> cause a <strong class="bold">denial of service</strong> (<strong class="bold">DoS</strong>) attack. ASP.NET Core provides a built-in r<a id="_idTextAnchor357"/>ate-limiting middleware. We explained how to use it in <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor358"/>Using model validation</h2>
<p>Model validation<a id="_idIndexMarker900"/> is a security mechanism that prevents malicious<a id="_idIndexMarker901"/> users from sending invalid data to the server. We should always validate the <a id="_idIndexMarker902"/>data sent by the client. In other words, the client is not trusted. For example, we expect a property in the model to be an integer, but what if the client sends a string? The application should be able to handle this situation and reject the request directly before executing any business logic.</p>
<p>ASP.NET Core provides a built-in model binding and model validation mechanism. Model binding is used to convert the data sent by the client to the corresponding model. The data sent by the client can be in different formats, such as JSON, XML, form fields, or query strings. Model validation is used to check whether the data sent by the client is valid. We used model validation in the previous sections. For example, here is the code we used to register a new user:</p>
<pre class="source-code">
// Create an action to register a new user[HttpPost("register")]
public async Task&lt;IActionResult&gt; Register([FromBody] AddOrUpdateAppUserModel model)
{
    // Check if the model is valid
    if (ModelState.IsValid)
    {
        // Omitted for brevity
    }
    return BadRequest(ModelState);
}</pre>
<p>The <code>ModelState.IsValid</code> property represents whether the model is valid. So, how does ASP.NET Core <a id="_idIndexMarker903"/>validate the model? Look at the <code>AddOrUpdateAppUserModel</code> class:</p>
<pre class="source-code">
public class AddOrUpdateAppUserModel{
    [Required(ErrorMessage = "User name is required")]
    public string UserName { get; set; } = string.Empty;
    [EmailAddress]
    [Required(ErrorMessage = "Email is required")]
    public string Email { get; set; } = string.Empty;
    [Required(ErrorMessage = "Password is required")]
    public string Password { get; set; } = string.Empty;
}</pre>
<p>We use<a id="_idIndexMarker904"/> the validation attributes to specify the validation rules. For example, <code>Required</code> is a built-in attribute annotation that specifies that the property is required. Here are some of the most commonly used ones besides <code>Required</code>:</p>
<ul>
<li><code>CreditCard</code>: This specifies that the property must be a valid credit card number</li>
<li><code>EmailAddress</code>: This specifies that the property must be a valid email address</li>
<li><code>Phone</code>: This specifies that the property must be a valid phone number</li>
<li><code>Range</code>: This specifies that the property must be within a specified range</li>
<li><code>RegularExpression</code>: This specifies that the property must match a specified regular expression</li>
<li><code>StringLength</code>: This specifies that the property must be a string with a specified length</li>
<li><code>Url</code>: This specifies that the property must be a valid URL</li>
<li><code>Compare</code>: This specifies that the property must be the same as another property</li>
</ul>
<p>If these<a id="_idIndexMarker905"/> built-in <a id="_idIndexMarker906"/>attributes cannot meet your requirements, you can also create custom attributes. For example, you can create an <code>Adult</code> attribute to validate the age of the user based on the user’s birthday:</p>
<pre class="source-code">
public class AdultAttribute : ValidationAttribute{
    public string GetErrorMessage() =&gt; $"You must be at least 18 years old to register.";
    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        var birthDate = (DateTime)value;
        var age = DateTime.Now.Year - birthDate.Year;
        if (DateTime.Now.Month &lt; birthDate.Month || (DateTime.Now.Month == birthDate.Month &amp;&amp; DateTime.Now.Day &lt; birthDate.Day))
        {
            age--;
        }
        if (age &lt; 18)
        {
            return new ValidationResult(GetErrorMessage());
        }
        return ValidationResult.Success;
    }
}</pre>
<p>Then, you can use the <code>Adult</code> attribute in the model:</p>
<pre class="source-code">
public class AddOrUpdateAppUserModel{
    // Omitted for brevity
    [Required(ErrorMessage = "Birthday is required")]
    [Adult]
    public DateTime Birthday { get; set; }
}</pre>
<p>You can also <a id="_idIndexMarker907"/>manually validate the model in the controller. For<a id="_idIndexMarker908"/> example, you can check whether the user’s email is unique:</p>
<pre class="source-code">
// Create an action to register a new user[HttpPost("register")]
public async Task&lt;IActionResult&gt; Register([FromBody] AddOrUpdateAppUserModel model)
{
    // Check if the email is unique
    if (await _userManager.FindByEmailAsync(model.Email) != null)
    {
        ModelState.AddModelError("Email", "Email already exists");
        return BadRequest(ModelState);
    }
    if (ModelState.IsValid)
    {
        // Omitted for brevity
    }
    return BadRequest(ModelState);
}</pre>
<p>In the<a id="_idIndexMarker909"/> preceding code, we use the <code>AddModelError()</code> method to <a id="_idIndexMarker910"/>add a validation error to the model. The <code>ModelState.IsValid</code> property will return <code>false</code> if there is any validation error. In <a href="B18971_16.xhtml#_idTextAnchor671"><em class="italic">Chapter 16</em></a>, we will discuss how to use the <code>ProblemDetails </code>class to return error information to the client and how to use <code>FluentValidation</code> to validate the model for<a id="_idTextAnchor359"/> more complex scenarios. You can refer to that chapter for more information.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor360"/>Using parameterized queries</h2>
<p>We <a id="_idIndexMarker911"/>explained how to use EF Core to execute SQL queries in previous<a id="_idIndexMarker912"/> chapters. Generally, if you use LINQ to query data, EF Core will generate parameterized queries for you. However, you need to take care of SQL injection attacks when you use the following methods:</p>
<ul>
<li><code>FromSqlRaw()</code></li>
<li><code>SqlQeuryRaw()</code></li>
<li><code>ExecuteSqlRaw()</code></li>
</ul>
<p>These methods allow you to execute raw SQL queries without sanitizing the input.<a id="_idTextAnchor361"/> So, please make sure you sanitize the query statements before executing them.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor362"/>Using data protection</h2>
<p>Data protection <a id="_idIndexMarker913"/>is a security mechanism that prevents malicious <a id="_idIndexMarker914"/>users from accessing sensitive data. For example, if you store the user’s password in the database, you should encrypt it before storing it. Another example is the user’s credit card number, which should also be encrypted before it is stored.</p>
<p>The reason for this is that if the database is compromised, the attacker can easily access the user’s sensitive data. In other words, the database is not trusted, just like the client. Data protection is another big topic, but it is beyond the scope of this book. ASP.NET Core provides a built-in data protection mechanism. If you would like to learn more about it, please refer to the official documentation: <a href="https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction">https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction</a>.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor364"/>Keeping secrets safe</h2>
<p>Secrets <a id="_idIndexMarker915"/>are sensitive data that should not be exposed to the public. In our applications, we may have many secrets, such as the database <a id="_idIndexMarker916"/>connection string, the API keys, the client secrets, and so on. In the previous chapters, we often stored them in the <code>appsettings.json</code> file. However, we need to emphasize that this is not a good practice. These secrets should be stored in a safe place, such as Azure Key Vault, AWS Secrets Manager, or <code>kube-secrets</code>. Never upload them to the source code repository.</p>
<p>We will introduce <strong class="bold">continuous integration/co<a id="_idTextAnchor365"/>ntinuous deployment</strong> (<strong class="bold">CI/CD</strong>) and explain how to store secrets safely in <a href="B18971_14.xhtml#_idTextAnchor585"><em class="italic">Chapter 14</em></a>.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor366"/>Keeping the framework up to date</h2>
<p>The .NET<a id="_idIndexMarker917"/> Core framework is an open-source project. It is constantly being updated. We should always keep the framework up to date, including the NuGet packages. Note the life cycle of the .NET Core framework. Use the latest version of the framework as much as possible. If you are using an older version, you should consider upgrading it. You can find the life cycle of the .NET Core fram<a id="_idTextAnchor367"/>ework here: <a href="https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core">https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core</a>.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor368"/>Checking the Open Web Application Security Project (OWASP) Top 10</h2>
<p>OWASP<a id="_idIndexMarker918"/> is a <a id="_idIndexMarker919"/>nonprofit organization that provides information about web application security. It publishes a list of the most common web application security risks, which is called the OWASP Top 10. You can find the <a id="_idIndexMarker920"/>OWASP Top 10 here: <a href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>. You should check the list regularly to make sure your application is not vulnerable to any of the risks.</p>
<p>Also, OWASP provides a free resource called <em class="italic">DotNet Security Cheat Sheet</em>, where you can find the best practices for securing .NET Core applications. You can find it <a id="_idTextAnchor369"/>here: <a href="https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html</a>.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor370"/>Summary</h1>
<p>In this chapter, we introduced the security and identity features of ASP.NET Core. We mainly learned how to use its built-in authentication and authorization mechanisms. We learned how to use the Identity framework to manage users and roles, and also explained role-based authorization, claim-based authorization, and policy-based authorization.</p>
<p>Then, we introduced OAuth 2.0 and OpenID Connect, which are the most popular authentication and authorization standards. After that, we explained several security practices, such as using HTTPS, strong passwords, parameterized queries, and more.</p>
<p>Again, security is a big topic, and we cannot cover all the details in one chapter. Please treat security as a continuous process, and always keep your application secure.</p>
<p>In the next chapter, we will get starssseted with testing, which is an important part of any software project. We will learn how to write unit tests for ASP.NET Core applications.</p>
</div>
</body></html>