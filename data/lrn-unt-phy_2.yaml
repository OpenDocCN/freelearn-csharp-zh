- en: Chapter 2. Using Different Colliders for Interaction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 使用不同碰撞体进行交互
- en: 'As mentioned in the previous chapter, colliders are among one of the main components
    of Unity3D. Using colliders, we define a shape for the object that helps in collision
    detection. In this chapter, we will learn about colliders. We will learn about
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，碰撞体是 Unity3D 中的主要组件之一。使用碰撞体，我们为对象定义一个形状，有助于碰撞检测。在本章中，我们将学习有关碰撞体的内容。我们将学习以下主题：
- en: Primitive colliders and their implementation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始碰撞体及其实现
- en: Nonprimitive colliders and their implementations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非原始碰撞体及其实现
- en: Uses of Trigger Colliders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trigger 碰撞体的用途
- en: Editing Polygon Collider 2D
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 Polygon Collider 2D
- en: Let's have a look at the primitive and nonprimitive colliders in detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看原始和非原始碰撞体。
- en: Primitive colliders
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始碰撞体
- en: Primitive colliders are basic colliders or, in other words, we can say that
    these colliders are the earliest of their kind. There are three primitive colliders
    in Unity3D, and apart from these three colliders, Unity also provides Mesh Collider,
    which helps us when we need to provide a collision shape for a complex shape.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 原始碰撞体是基本碰撞体，或者换句话说，我们可以这样说，这些碰撞体是这一类碰撞体中的最早形式。Unity3D 中有三种原始碰撞体，除了这三种碰撞体之外，Unity
    还提供了 Mesh Collider，这有助于我们在需要为复杂形状提供碰撞形状时使用。
- en: Types of primitive colliders
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始碰撞体的类型
- en: 'As shown in the following figure, there are three primitive colliders: Box
    Collider, Sphere Collider, and Capsule Collider.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，有三个原始碰撞体：Box Collider、Sphere Collider 和 Capsule Collider。
- en: '![Types of primitive colliders](img/00009.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![原始碰撞体的类型](img/00009.jpeg)'
- en: We will learn the uses and types of primitive colliders in detail with examples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过示例详细学习原始碰撞体的用途和类型。
- en: Box Collider 3D
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Box Collider 3D
- en: Box Collider contains the cube shape and can be implemented for cube-shaped
    game objects, such as boxes, walls, and doors, that resemble the shape of a cube.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Box Collider 包含立方体形状，可以为类似立方体形状的游戏对象（如盒子、墙壁和门）实现，这些对象具有立方体的形状。
- en: Example – implementation of Box Collider
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – Box Collider 的实现
- en: 'Here, we will see how we can implement Box Collider in the following scene
    by performing the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过以下步骤在以下场景中实现 Box Collider：
- en: Let's create a new scene as shown in the following screenshot:![Example – implementation
    of Box Collider](img/00010.jpeg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的场景，如下截图所示：![示例 – Box Collider 的实现](img/00010.jpeg)
- en: Select the **Cube** option by navigating to **GameObject** | **Create Other**
    as shown in the following screenshot, and then open the **Inspector** panel:![Example
    – implementation of Box Collider](img/00011.jpeg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下截图所示的导航到**GameObject** | **Create Other**选择**Cube**选项，然后打开**Inspector**面板：![示例
    – Box Collider 的实现](img/00011.jpeg)
- en: In the following screenshot, you will see the **Box Collider** checkbox inside
    the **Inspector** panel; make sure it is checked:![Example – implementation of
    Box Collider](img/00012.jpeg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下截图，您将在 **Inspector** 面板中看到 **Box Collider** 复选框；请确保它被勾选：![示例 – Box Collider
    的实现](img/00012.jpeg)
- en: In the **Inspector** panel, select the **Is Trigger** checkbox to make it trigger
    the collider and fire trigger events.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 面板中，选择 **Is Trigger** 复选框以使其触发碰撞体并触发触发事件。
- en: We can decide its shape and size using the dimension here; it should be relative
    to the game object transform and size.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这里的尺寸来决定其形状和大小；它应该与游戏对象变换和大小相关。
- en: Note
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Material**'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**材质**'
- en: Box Collider has the Material property that determines the friction and bounciness
    of the game object, but it is irrelevant if we choose the Trigger Collider.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Box Collider 具有Material属性，该属性决定了游戏对象的摩擦力和弹性，但如果选择 Trigger Collider，则无关紧要。
- en: In the previous example, we learned how we can implement Box Collider for cube-shaped
    objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们学习了如何为立方体形状的对象实现 Box Collider。
- en: Box Collider 2D
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Box Collider 2D
- en: For a 2D game object, Unity provides Box Collider 2D to handle the collision.
    This collider is of the rectangle shape and can be implemented on a sprite with
    given dimensions and coordinates. Like the 3D Box Collider, this collider too
    possesses the Is Trigger and Material properties along with the Size and Center
    properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 2D 游戏对象，Unity 提供了 Box Collider 2D 来处理碰撞。这个碰撞体是矩形形状，可以在具有给定尺寸和坐标的精灵上实现。与 3D
    Box Collider 类似，这个碰撞体也具有 Is Trigger 和 Material 属性，以及 Size 和 Center 属性。
- en: Sphere Collider 3D
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sphere Collider 3D
- en: For game objects that have the shape of a sphere, we use Unity3D's Sphere Collider.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于形状为球体的游戏对象，我们使用 Unity3D 的 Sphere Collider。
- en: Example – implementation of Sphere Collider
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 球体碰撞体的实现
- en: 'Here, we will see how we can implement Sphere Collider in the scene using the
    following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何使用以下步骤在场景中实现球体碰撞体：
- en: Create a new scene.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: As shown in the following screenshot, go to **GameObject** and select **Create
    Other** where you will get a drop-down list; now, select a **Sphere** game object
    and open the **Inspector** panel:![Example – implementation of Sphere Collider](img/00013.jpeg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，转到**游戏对象**并选择**创建其他**，您将得到一个下拉列表；现在，选择一个**球体**游戏对象并打开**检查器**面板：![示例
    – 球体碰撞体的实现](img/00013.jpeg)
- en: Inside the **Inspector** panel, you will see **Sphere Collider**; make sure
    **Sphere Collider** is checked:![Example – implementation of Sphere Collider](img/00014.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板内部，您将看到**球体碰撞体**；请确保**球体碰撞体**被勾选：![示例 – 球体碰撞体的实现](img/00014.jpeg)
- en: In the **Inspector** panel, check **Is Trigger** to make it trigger a collider
    and fire trigger events.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，勾选**触发器**以使其触发碰撞体并触发触发事件。
- en: We can decide its shape and size using the dimension and radius; here, it should
    be relative to the game object transform and size.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过尺寸和半径来决定其形状和大小；在这里，它应该与游戏对象变换和大小相关。
- en: Circle Collider 2D
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D圆形碰撞体
- en: For 2D objects, we implement Circle Collider instead of Sphere Collider for
    circle-shaped game object with a given dimension and coordinate. It has all properties
    which are in Sphere Collider such as Is Trigger and Radius.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2D对象，我们使用圆形碰撞体而不是球体碰撞体来实现给定尺寸和坐标的圆形游戏对象。它具有球体碰撞体中所有的属性，如触发器和半径。
- en: Capsule Collider 3D
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3D胶囊碰撞体
- en: Capsule Collider is used for capsule-shaped game objects. This is commonly used
    for creating a character game object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 胶囊碰撞体用于胶囊形状的游戏对象。这通常用于创建角色游戏对象。
- en: Example – implementation of Capsule Collider
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 胶囊碰撞体的实现
- en: 'Here, we will see how we can implement Capsule Collider in the scene using
    the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何使用以下步骤在场景中实现胶囊碰撞体：
- en: Create a new scene.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: As shown in the following screenshot, select the **Capsule** game object and
    then open the **Inspector** panel:![Example – implementation of Capsule Collider](img/00015.jpeg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，选择**胶囊**游戏对象然后打开**检查器**面板：![示例 – 胶囊碰撞体的实现](img/00015.jpeg)
- en: Inside the **Inspector** panel, you will see **Capsule Collider**; make sure
    that it is checked.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板内部，您将看到**胶囊碰撞体**；请确保它被勾选。
- en: In the **Inspector** panel, check **Is Trigger** to make game object trigger
    a collider and fire trigger events.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，勾选**触发器**以使游戏对象触发碰撞体并触发触发事件。
- en: 'Our capsule object will look as shown in the following screenshot:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们胶囊对象的外观将如以下截图所示：
- en: '![Example – implementation of Capsule Collider](img/00016.jpeg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![示例 – 胶囊碰撞体的实现](img/00016.jpeg)'
- en: As shown in the following screenshot, we can decide its shape and size using
    the dimension and radius; here, it should be relative to game object transform
    and size:![Example – implementation of Capsule Collider](img/00017.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们可以通过尺寸和半径来决定其形状和大小；在这里，它应该与游戏对象变换和大小相关：![示例 – 胶囊碰撞体的实现](img/00017.jpeg)
- en: Select **Height** as the length of the capsule body.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**高度**作为胶囊身体的长度。
- en: As shown in the following screenshot, give a direction relative to the game
    object:![Example – implementation of Capsule Collider](img/00018.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下截图所示，相对于游戏对象给出一个方向：![示例 – 胶囊碰撞体的实现](img/00018.jpeg)
- en: By choosing **X-Axis**, **Y-Axis**, or **Z-Axis**, we give a direction to the
    game object.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过选择**X轴**、**Y轴**或**Z轴**，我们为游戏对象提供一个方向。
- en: Mesh Collider
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格碰撞体
- en: Using mesh, Mesh Collider defines the shape of a collision. Although we use
    it for accurate shape definition for collision, this is expensive in terms of
    performance. We should avoid the use of Mesh Collider, and wherever we can, use
    primitive collider (Box, Sphere, and so on).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格，网格碰撞体定义了碰撞的形状。尽管我们用它来为碰撞提供精确的形状定义，但在性能方面这是昂贵的。我们应该避免使用网格碰撞体，并在可能的情况下使用原始碰撞体（盒形、球体等）。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mesh Collider should be avoided wherever possible by using complex colliders
    in order to optimize the performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应尽可能避免使用复杂的碰撞体来使用网格碰撞体，以优化性能。
- en: Example – implementation of Mesh Collider
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 网格碰撞体的实现
- en: 'Here, we will see how we can implement Mesh Collider in the scene using the
    following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何使用以下步骤在场景中实现网格碰撞体：
- en: Create a new scene.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: Download or use any existing assets you have. I have downloaded a free spider
    asset from Unity3D's assets store.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载或使用你已有的任何资产。我从Unity3D的资产商店下载了一个免费的蜘蛛资产。
- en: Import the assets in the scene; and you will see them appear in the scene. As
    shown in the following screenshot, you can see your spider:![Example – implementation
    of Mesh Collider](img/00019.jpeg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资产导入场景；你将看到它们出现在场景中。如图所示，你可以看到你的蜘蛛：![示例 – 网格碰撞器的实现](img/00019.jpeg)
- en: Now, as shown in the following screenshot, we will apply Mesh Collider. Navigate
    to **Component** | **Physics** | **Mesh Collider**:![Example – implementation
    of Mesh Collider](img/00020.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如图所示，我们将应用网格碰撞器。导航到**组件** | **物理** | **网格碰撞器**：![示例 – 网格碰撞器的实现](img/00020.jpeg)
- en: As shown in the screenshot, select the mesh where we have to implement Mesh
    Collider:![Example – implementation of Mesh Collider](img/00021.jpeg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如截图所示，选择我们需要实现网格碰撞器的网格：![示例 – 网格碰撞器的实现](img/00021.jpeg)
- en: As shown in the following screenshot, in the **Inspector** panel, you will see
    a Is **Trigger** checkbox, which is unchecked by default. Check **Is Trigger**
    to make it trigger a collider and fire trigger events:![Example – implementation
    of Mesh Collider](img/00022.jpeg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，在**检查器**面板中，你会看到一个未勾选的**Is Trigger**复选框。勾选**Is Trigger**以使其触发碰撞器并触发触发事件：![示例
    – 网格碰撞器的实现](img/00022.jpeg)
- en: We can mark **Convex** as true if we want this game object to collide with another
    Mesh Collider.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想让这个游戏对象与另一个网格碰撞器发生碰撞，我们可以将**Convex**标记为真。
- en: Give a direction relative to the game object:![Example – implementation of Mesh
    Collider](img/00023.jpeg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给游戏对象一个相对方向：![示例 – 网格碰撞器的实现](img/00023.jpeg)
- en: As shown in the preceding screenshot, by selecting the game object, we open
    the **Inspector** panel and we can give a direction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，通过选择游戏对象，我们打开**检查器**面板，并可以给出一个方向。
- en: Polygon Collider 2D
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D多边形碰撞器
- en: For 2D objects where the shape of the game object is irregular, Polygon Collider
    2D is used. To edit the collider shape, drag the sprite asset onto the Polygon
    Collider 2D component in the **Inspector** panel, hold the *shift* key and try
    to edit the vertex or edges.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏对象形状不规则的2D对象，使用多边形碰撞器2D。要编辑碰撞器形状，将精灵资产拖动到**检查器**面板中的多边形碰撞器2D组件上，按住**shift**键并尝试编辑顶点或边。
- en: Example – implementation of Polygon Collider 2D
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 实现多边形碰撞器2D
- en: 'The following steps will guide you through to implement Polygon Collider 2D:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你实现多边形碰撞器2D：
- en: Create a new scene and name it `Polygon Collider 2D example`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景并将其命名为`Polygon Collider 2D示例`。
- en: In the **Hierarchy** pane, click on **Create** and select **Sprite** from the
    drop-down list to create an empty sprite renderer. Name this sprite renderer `Rock`
    in the **Inspector** window.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，点击**创建**并从下拉列表中选择**精灵**以创建一个空精灵渲染器。在**检查器**窗口中将此精灵渲染器命名为`Rock`。
- en: By default, it will be represented by a box that is not appropriate, so we will
    create a Polygon Collider instead.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，它将表示为一个不合适的盒子，因此我们将创建一个多边形碰撞器。
- en: Select **Sprite collection** and click on **Open Editor**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**精灵集合**并点击**打开编辑器**。
- en: Select the **Rock Sprite** option in the **Sprite Collection** editor.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**精灵集合**编辑器中选择**Rock Sprite**选项。
- en: Select **Collider Type** as **Polygon**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**碰撞器类型**为**多边形**。
- en: Switch the **Sprite view** option to collider edit mode.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵视图**选项切换到碰撞器编辑模式。
- en: Double-click on an edge to add a control point. Click and drag this to position
    it.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击边以添加控制点。点击并拖动以定位它。
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can edit the polygon's shape directly by holding down the *shift* key as
    you move the mouse over an edge or vertex in the **Scene** view. You can move
    an existing vertex by shift-dragging when the mouse is over that vertex. If you
    shift-drag while the mouse is over an edge, a new vertex will be created at the
    pointer's location. You can remove a vertex by holding down the *control*/*command*
    key while clicking on it.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以直接通过在**场景**视图中移动鼠标并按住**shift**键来编辑多边形的形状。当鼠标悬停在顶点上时，可以通过shift-drag来移动现有的顶点。如果鼠标悬停在边上时shift-drag，将在指针位置创建一个新的顶点。可以通过按住**control**/*command*键并点击它来删除顶点。
- en: Edit the collider until you get desired result.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑碰撞器，直到得到你想要的结果。
- en: Edge Collider 2D
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D边缘碰撞器
- en: This 2D collider is used where the collision shape for a 2D game object requires
    precision. Using this collider, a shape is made of line segments. Using the *shift*
    and *control* keys, we can edit the shape of the collider. We can edit Edge Collider
    2D in a similar way as shown in the preceding section on Polygon Collider 2D.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种2D碰撞体用于需要精度的2D游戏对象的碰撞形状。使用这个碰撞体，形状由线段组成。使用*shift*和*control*键，我们可以编辑碰撞体的形状。我们可以像前一个部分中展示的Polygon
    Collider 2D一样编辑Edge Collider 2D。
- en: Nonprimitive colliders
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非原始碰撞体
- en: Nonprimitive colliders originated from primitive colliders. Especially for vehicles,
    Unity provides Wheel Collider, and for terrains, a Terrain Collider component.
    By combining various primitive colliders, we create compound colliders.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 非原始碰撞体是从原始碰撞体派生出来的。特别是对于车辆，Unity提供了轮子碰撞体，对于地形，有一个地形碰撞体组件。通过组合各种原始碰撞体，我们创建了复合碰撞体。
- en: Types of nonprimitive colliders
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非原始碰撞体的类型
- en: As shown in the following figure, nonprimitive colliders are specific for wheel
    objects and terrains. Using a Wheel Collider, we can easily provide a collision
    shape for vehicles. Similarly, using Terrain Collider collision implementation
    for different shapes becomes easy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，非原始碰撞体是针对轮子对象和地形的。使用轮子碰撞体，我们可以轻松地为车辆提供碰撞形状。同样，使用不同形状的地形碰撞体实现变得容易。
- en: '![Types of nonprimitive colliders](img/00024.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![非原始碰撞体的类型](img/00024.jpeg)'
- en: Wheel Collider
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮子碰撞体
- en: This is a nonprimitive collider used for wheels of a vehicle. Wheel Colliders
    have motorTorque, brakeTorque, radius, and steerAngle properties. Using a friction
    model, Wheel Colliders are able to give a realistic effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于车辆轮子的非原始碰撞体。轮子碰撞体具有motorTorque、brakeTorque、radius和steerAngle属性。使用摩擦模型，轮子碰撞体能够提供逼真的效果。
- en: Example – implementation of Wheel Colliders
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例 – 轮子碰撞体的实现
- en: 'Here, we will see how we can implement a compound collider in the scene using
    the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将看到如何使用以下步骤在场景中实现复合碰撞体：
- en: Create a new scene.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: In the **Hierarchy** pane, click on **Create** and select the **Cylinder** game
    object. Open the **Inspector** panel.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，点击**创建**并选择**圆柱体**游戏对象。打开**检查器**面板。
- en: Add **Wheel Collider** from **Component**, as shown in the following screenshot:![Example
    – implementation of Wheel Colliders](img/00025.jpeg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**组件**中添加**轮子碰撞体**，如图所示：![示例 – 轮子碰撞体的实现](img/00025.jpeg)
- en: Play with the properties to give a realistic effect.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调整属性来获得逼真的效果。
- en: 'Let''s open the **Inspector** panel. We will see some different properties;
    here, using **Mass**, we decide the mass of the wheel game object, which must
    be greater than 0\. In this example, I have used `1`. We can set the radius by
    using the **Radius** property that defines the radius of the wheel, measured in
    local space. Have a look at the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开**检查器**面板。我们会看到一些不同的属性；在这里，使用**质量**，我们决定轮子游戏对象的质量，它必须大于0。在这个例子中，我使用了`1`。我们可以通过使用定义轮子半径的**半径**属性来设置半径，该半径以局部空间为单位。请看下面的截图：
- en: '![Example – implementation of Wheel Colliders](img/00026.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![示例 – 轮子碰撞体的实现](img/00026.jpeg)'
- en: As shown in the preceding screenshot, there are other properties that are also
    used to give a realistic wheel effect; for example, the wheel's collision detection
    is performed by casting a ray from the center ([http://docs.unity3d.com/ScriptReference/WheelCollider-center.html](http://docs.unity3d.com/ScriptReference/WheelCollider-center.html))
    down the local *y* axis for which we use the Center property. We can extend the
    wheel's radius downwards by the `suspensionDistance` ([http://docs.unity3d.com/ScriptReference/WheelCollider-suspensionDistance.html](http://docs.unity3d.com/ScriptReference/WheelCollider-suspensionDistance.html))
    amount. By changing `forwardFriction` ([http://docs.unity3d.com/ScriptReference/WheelCollider-forwardFriction.html](http://docs.unity3d.com/ScriptReference/WheelCollider-forwardFriction.html))
    and `sidewaysFriction` ([http://docs.unity3d.com/ScriptReference/WheelCollider-sidewaysFriction.html](http://docs.unity3d.com/ScriptReference/WheelCollider-sidewaysFriction.html))
    based on what material the wheel is hitting, we simulate different road materials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，还有其他属性也被用来实现逼真的轮子效果；例如，轮子的碰撞检测是通过从中心发射一条射线到局部 *y* 轴来进行的，我们使用中心属性。我们可以通过`suspensionDistance`（[http://docs.unity3d.com/ScriptReference/WheelCollider-suspensionDistance.html](http://docs.unity3d.com/ScriptReference/WheelCollider-suspensionDistance.html)）的值向下扩展轮子的半径。通过根据轮子撞击的材料改变`forwardFriction`（[http://docs.unity3d.com/ScriptReference/WheelCollider-forwardFriction.html](http://docs.unity3d.com/ScriptReference/WheelCollider-forwardFriction.html)）和`sidewaysFriction`（[http://docs.unity3d.com/ScriptReference/WheelCollider-sidewaysFriction.html](http://docs.unity3d.com/ScriptReference/WheelCollider-sidewaysFriction.html)），我们模拟不同的路面材料。
- en: Static collider
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态碰撞体
- en: Static collider is used wherein a collision movement is not required. A static
    collider contains a nontrigger collider without a Rigidbody. This type of game
    object that does not have any Rigidbody will not get affected by Physics. Static
    colliders are mostly used to create boundaries or blockages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 静态碰撞体用于不需要碰撞移动的场景。静态碰撞体包含一个没有Rigidbody的非触发碰撞体。这种没有Rigidbody的游戏对象不会受到物理的影响。静态碰撞体通常用于创建边界或障碍。
- en: Rigidbody Collider
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rigidbody 碰撞体
- en: The Rigidbody Collider is exactly the opposite of a static collider; it is a
    collider with Rigidbody components. Rigidbody Collider will collide with a static
    collider to create collision events and will get influenced by Physics.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbody 碰撞体与静态碰撞体正好相反；它是一个带有Rigidbody组件的碰撞体。Rigidbody 碰撞体会与静态碰撞体发生碰撞以创建碰撞事件，并且会受到物理的影响。
- en: Kinematic Rigidbody Collider
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运动学 Rigidbody 碰撞体
- en: A Kinematic Rigidbody Collider is a collider that has the **Is Kinematic** flag
    `true`. Mostly, it is used where animation is required. Also, the Kinematic Rigidbody
    Collider is not influenced by the script.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运动学 Rigidbody 碰撞体是一个具有 **Is Kinematic** 标志 `true` 的碰撞体。通常，它用于需要动画的场景。此外，运动学
    Rigidbody 碰撞体不受脚本的影响。
- en: Trigger Collider
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发器碰撞体
- en: The Trigger Collider is an invisible collider that fires events without any
    physical interaction. We can define nonphysical area where Trigger Collider will
    fire event on interaction with game object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器碰撞体是一个不可见的碰撞体，在没有任何物理交互的情况下触发事件。我们可以定义非物理区域，当与游戏对象交互时，触发器碰撞体会触发事件。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Triggers should be used where a quick response is required. For games such as
    *Tower Defense* where a quick response is required, Trigger Colliders are very
    useful.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器应该用于需要快速响应的场景。对于像 *塔防* 这样的游戏，其中需要快速响应，触发器碰撞体非常有用。
- en: 'The following events are called:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件会被调用：
- en: '`OnTriggerEnter`: This event is called when the object just enters'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter`: 当对象刚刚进入时调用此事件'
- en: '`OnTriggerStay`: This event is called when the object is inside the trigger'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerStay`: 当对象在触发器内部时调用此事件'
- en: '`OnTriggerExit`: This event is called when the object leaves the trigger'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerExit`: 当对象离开触发器时调用此事件'
- en: 'When do we use Trigger Collider? As shown in the following figure, mainly,
    we use Trigger Collider for two scenarios:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在何时使用触发器碰撞体？如图所示，主要在以下两种场景中使用触发器碰撞体：
- en: '![Trigger Collider](img/00027.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![触发器碰撞体](img/00027.jpeg)'
- en: An example of proximity triggers
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 距离触发器的示例
- en: 'During the development of one of my games, I had to create a game play where
    when a player reaches the door, the door should open. In this case, I needed to
    put a Trigger Collider in front of the door. When the player reaches the door,
    it fires the `OnTriggerEnter` event where I was executing game logic accordingly:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发我的游戏之一时，我必须创建一个游戏玩法，当玩家到达门口时，门应该打开。在这种情况下，我需要在门口前放置一个触发碰撞体。当玩家到达门口时，它触发 `OnTriggerEnter`
    事件，我在那里相应地执行游戏逻辑：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, we can use `OnTriggerStay` and `OnTriggerExit`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `OnTriggerStay` 和 `OnTriggerExit`：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An example of radius triggers
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 半径触发器的示例
- en: 'In some games such as *Tower Defense*, we are required to spawn troops or shoot
    enemies in a range; hence, we create a radius. When the game object enters within
    the defined radius, `OnTriggerEnter` events get fired:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些游戏，如 *塔防* 中，我们需要在范围内生成部队或射击敌人；因此，我们创建一个半径。当游戏对象进入定义的半径内时，`OnTriggerEnter`
    事件被触发：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, we can use `OnTriggerStay` and `OnTriggerExit`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `OnTriggerStay` 和 `OnTriggerExit`：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Warning**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: Trigger Colliders respond to raycasts. Make sure your triggers are set to the
    Ignore Raycasts layer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 触发碰撞体对射线投射有响应。确保你的触发器设置为忽略射线投射层。
- en: Compound colliders
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合碰撞体
- en: Instead of using Mesh Collider, sometimes it is better to use combined primitive
    colliders. For this, we create a parent-child hierarchy of colliders. Let's see
    this in the following example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用网格碰撞体，有时使用组合的原始碰撞体更好。为此，我们创建一个碰撞体的父子层次结构。让我们在以下示例中看看。
- en: Example – implementation of compound colliders
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 复合碰撞体的实现
- en: 'Here, we will see how we can implement a compound collider in the following
    scene:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们将看到如何在以下场景中实现复合碰撞体：
- en: Create a new scene.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: As shown in the following screenshot, select the **Capsule** and **Sphere**
    game objects and create a character shape:![Example – implementation of compound
    colliders](img/00028.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，选择**胶囊**和**球体**游戏对象并创建一个角色形状：![示例 – 复合碰撞体的实现](img/00028.jpeg)
- en: Inside the **Inspector** panel, you will see **Sphere Collider** and **Capsule
    Collider**. Check the **Is Trigger** option for both to make it trigger a collider
    and fire trigger events.![Example – implementation of compound colliders](img/00029.jpeg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 面板中，你会看到 **球体碰撞体** 和 **胶囊碰撞体**。为两者都勾选 **是触发器** 选项，使其触发碰撞体并触发触发事件。![示例
    – 复合碰撞体的实现](img/00029.jpeg)
- en: In this section, we learned how we can use primitive colliders for a complex
    game object. We will learn more about animation and compound colliders in later
    chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为复杂游戏对象使用原始碰撞体。在后面的章节中，我们将了解更多关于动画和复合碰撞体的内容。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned about the different types of colliders and their implementations,
    how we can implement primitive and nonprimitive colliders, and what their uses
    are. We also learned the use of Trigger Colliders. In the next chapter, we will
    learn about the Collision Matrix of colliders. We will see how we can implement
    the Collision Matrix with nonscript-based and script-based examples. We will also
    learn about layer-based collision.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了不同类型的碰撞体及其实现方式，如何实现原始和非原始碰撞体，以及它们的应用。我们还学习了触发碰撞体的使用。在下一章中，我们将学习碰撞体的碰撞矩阵。我们将通过非脚本和基于脚本的示例来了解如何实现碰撞矩阵。我们还将学习基于层的碰撞。
