- en: Find, Execute, and Create Types at Runtime Using Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Framework contains not just code but metadata as well. Metadata is
    data about assemblies, types, methods, properties, and so on used in a program.
    These assemblies, properties, types, and methods are classes defined within the
    C# programming language. These classes, types, and methods are retrieved at runtime
    to parse a developer's application logic for execution. Attributes allow us to
    add extra information to these programs as well as methods that can be used during
    runtime while executing application logic.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Framework also allows developers to define this metadata information
    during development. It can be read during runtime using reflection. Reflection
    enables us to create an instance of the type retrieved and to invoke its methods
    and properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand how the .NET Framework allows us to read
    and create metadata, and we will also learn how to use reflection to read metadata
    and process it during runtime. In the *Attributes* section, we will focus on using
    attributes, creating custom attributes, and learn how to retrieve attribute information
    at runtime. The *Reflection* section supplies an overview of how we can use reflection
    to create types, access properties, and invoke methods. Reflection also allows
    us to retrieve attribute information; for example, this could be extra information
    that we provided to .NET Runtime to be processed while executing the application
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exercises in this chapter can be performed using Visual Studio 2012 and
    later with the .NET Framework 2.0 and later. However, any new C# features from
    C# 7.0 and later require you to have Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of these products, then you can download
    the Community Version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metadata or declarative information on types, methods, and properties can be
    associated using attributes. Metadata refers to what types are defined in a program.
    For instance, a class is a type: each class defines certain properties and methods,
    each property is of a type, and each method accepts certain data types and returns
    certain data types. All this information is referred to as metadata and can be
    accessed and retrieved during program execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Like any other method, while you define an attribute, you can define the parameters
    as well. You can define one or more attributes on an assembly, class, method,
    or property. Based on the program requirements, you can define what types of attribute
    your application needs and define them in your program. Once defined, you can
    read this information while executing your program and then process it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will demonstrate how to use attributes and create
    custom attributes as per our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Using attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A declarative way of associating information to code can be done via attributes.
    However, only a few attributes can be used on every type. Instead, they are used
    for specific types. Attributes on any type can be specified by using square brackets,
    `[]`, on top of the type that we want to apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code. Generally, we see the `Serializable`
    attribute when we want to serialize an object to the binary or XML formats. In
    real-world applications, when we need to transfer a large object over the wire,
    we serialize an object into one of the aforementioned formats and then send it.
    The serialize attribute on a class enables runtime to allow converting the object
    to binary or XML or any format required by the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common usage of attributes is in unit test projects. Observe the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we create a new test project where two attributes
    are added to each class and method. By adding them in this way, we are letting
    the framework know that this class represents a test class and that the method
    is a test method.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the use of attributes can be restricted to specific types.
    To achieve this, we will use attribute targets. By default, an attribute is applied
    to the preceding type. However, using a target, we can set whether the attribute
    applies to a class, method, or an assembly.
  prefs: []
  type: TYPE_NORMAL
- en: When the target is set to assembly, it means that the attribute is applied to
    the entire assembly. Similarly, a target can be set to a module, field, event,
    method, property, or type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an attribute can be set on a field to let the runtime know what
    type of input is accepted. Additionally, it can be set on a method to specify
    whether it is a normal method or a web method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common attributes defined by the framework include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global**: Attributes that are applied at the assembly or module level are
    generally global attributes, for example, `AssemblyVersionAttribute`. You might
    have seen this in every .NET project that is created using Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example. Here, you can see the `assembly.cs`
    file created when you create any .NET project using Visual Studio. Every assembly
    contains the following code, which tells the runtime about the current assembly
    that is being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Obsolete**: This attribute allows us to mark an entity or a class that should
    not be used. Therefore, when applied, it generates a warning message that is provided
    while applying the attribute. This class defines three constructors: the first
    without any parameters, the second with one parameter, and the third with two
    parameters. From a code-readability perspective, it is recommended that we use
    constructors with parameters as they generate warning or error messages based
    on usage. Additionally, setting the second parameter to `true` while applying
    an attribute will throw an error, whereas `false` will generate a warning. In
    the following code, we will see how we can use an obsolete attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code snippet, we defined a class named `Firstclass`; later,
    a new class was created with the name `SecondClass`. When we want new users accessing
    our library to use the second class rather than the first class, then we can use
    an `Obsolete` attribute with a message so that new users will see it and act accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Conditional**: When a conditional attribute is applied, the execution of
    the preceding code depends on the evaluation of the attribute. In a real-project
    scenario, while running a program in a live environment, you don''t want to log
    information and messages and fill up your storage. Instead, you can have a conditional
    attribute on your log methods, which will allow you to write when a flag in your
    configuration file is set to `true`. In this way, you can actually implement selecting
    logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, we have a `LogMessage` method; however, the attribute
    above the class will let the runtime application know that, when the `LogErrorOn`
    attribute is set to `yes` or `true`, it should execute this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Caller information**: The caller information attribute allows you to retrieve
    who is calling the method. They are `CallerfilePathAttribute`, `CallerLineNumberAttribute`,
    `CallerMemberNameAttribute`. Each one has its own purpose, as their names suggest.
    They allow us to get the line number, the method name, and the path of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# allows you to define your own attributes. This is similar to normal C# programming
    where you define classes and properties. To define an attribute, the first thing
    you need to do is to inherit it from the `System.Attribute` class. The class and
    properties you define are used to store and retrieve data at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four steps that you need to complete in order to complete defining
    custom attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring attribute class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attribute usage can be defined by using `System.AttributeUsageAttribute`. We
    already mentioned that there are restrictions on certain attributes, which define
    where they can be used—for example, in classes, methods, or properties. `AttributeUsageAttribte`
    allows us to define such restrictions. `AllowMultiple` specifies whether this
    attribute can be used more than once on a specific type. Inherited controls defining
    child classes form the current attribute class. The following is the general syntax
    for using the `AttributeUsage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you might have observed, you can declare the `AttributeUsage` attribute using
    its constructor on top of the custom attribute you want to define with the three
    parameters. With `AtributeTargetsAll`, you can use `CustomAttribute` on any type
    of element that is a class, property, method, and so on. A full list of allowed
    values is defined at [https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All](https://docs.microsoft.com/en-us/dotnet/api/system.attributetargets?view=netframework-4.7.2#System_AttributeTargets_All).
  prefs: []
  type: TYPE_NORMAL
- en: '`Inherited` and `AllowMultiple` are both Boolean properties, which accept true
    or false.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we define `AttributeUsage`, we can now move on to declare our custom class.
    This should be a public class and must inherit from the `System.Attribute` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our class declared, we can move on and define our constructors
    and properties. The framework allows us to define one or more constructors, covering
    all possible scenarios around a different combination of properties. Let''s define
    a custom attribute. A constructor of these attributes accepts three parameters—`AttributeTargets`,
    `AllowMultiple`, and `Inherited`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a custom attribute named `CustomerAttribute`. We
    also defined a `CustomerType` enum that we want to use as an `Attribute` property.
    By not defining any parameters in the constructor and assigning the `Customer`
    type to a `Type` property, we are telling runtime, by default, when its value
    is a customer. Additionally, this attribute is set to be used on either a field
    or property so that it cannot be used at the class level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine how we can use this attribute in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined an `Account` class where we used our custom attribute. We applied
    an attribute without any parameters. This means that, by default, we create an
    account of the customer type. In the following section, we will demonstrate how
    we can retrieve these attributes and use them in our application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are aware of OOP concepts, retrieving attribute information is as simple
    as creating an instance of the attribute that we want to retrieve, and then invoking
    the `GetCustomAttribute` method of the `System.Attribute` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we define a new attribute called `ChapterInfo` and
    define a constructor to mark two of its properties as required parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`ChapterName` and `ChapterAuthor` are the two required parameters that the
    developer has to define when using this attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in the following code the attribute is being defined over the
    `Program` class with two values: `Name` and `Author`. In the main method, `GetCustomAttribute`
    is invoked to read its properties, as you would do for any other class type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the (`[ChapterInfo("SAMPLECHAPTER", "AUTHOR1")]`) values passed
    in the attribute definition over the program class were retrieved and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is a way to query metadata at runtime from the application program.
    Reflection supplies type information from the assemblies loaded into memory that
    you can use to create an instance of the class and also access properties and
    methods of the class.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your application code executes a query and returns a dataset object,
    but your frontend accepts a custom class or model, and the model is defined during
    runtime. Based on the request received, reflection can be used to create the required
    model/class at runtime, access its properties or fields, and set their value by
    traversing through the resulting dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in previous sections, we learned how we can create custom attributes.
    So, in a scenario where you create an attribute to restrict numbers in a specific
    property, you can then use reflection to read the attribute, get the preceding
    property, implement application logic to restrict numbers, or display a message
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use reflection to create a type at runtime and access its methods
    and properties. Reflection works with `System.Types` to query information about
    assemblies that are currently loaded into memory and are being executed.
  prefs: []
  type: TYPE_NORMAL
- en: The **Common Language Runtime** (**CLR**) manages application domains with boundaries
    around objects that are of the same scope. This process includes loading assemblies
    into these domains and controlling them as required.
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET world, assemblies contain modules, modules contain types, and types
    contain members. An assembly class is used to load assemblies. Modules are used
    to identify information about classes in the assembly as well as global and non-global
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: There are many methods available in the `Reflection` class, such as `MethodInfo`,
    `PropertyInfo`, `Type`, `CustomAttribute`, and many more. These methods help developers
    to retrieve information at runtime. In the previous example, we used the `GetCustomAttribute`
    method to retrieve attribute information and displayed it.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking methods and using properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a look at how we can access the properties and methods
    of a custom class at runtime using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: This example serves to give you an idea of how we can access methods and properties
    using reflection at runtime. However, based on your requirements, you can dynamically
    access properties, their types and methods, and their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a new custom class where we defined two integer type properties:
    `Number1` and `Number2`. Then, we defined a public method that accepts a parameter
    and returns a number to be added or subtracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, we created a simple method where we could access the properties and methods
    of the custom class that we created previously. In the first line, we retrieved
    the type information of the custom class. Using this type, we created an instance
    of the class using the `Activator.CreateInstance` method. Now, using the `Getproperties`
    method of the type we retrieved, we accessed all the properties and set a value
    to each of them based on the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next line, using the `Type` information of the object, we retrieve `MethodInfo`
    using the `GetMethod` method. Then, we invoked the `public` method of the custom
    class twice with two different actions called `Add` and `Subtract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the program and debug every line, you will see that each property
    has been retrieved and values have been set. The following is the output of the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This sample is a simple one, as we created two properties, both of the integer
    type. However, in real time, such simple scenarios may not exist. Therefore, at
    runtime, you need to use the `GetType` method in order to understand the type
    of property retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in the example we were able to get the type of the `Custom` class
    where we hardcoded it. Using generics, we can even pass the class at runtime and
    get the info type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how we can use system attributes, create custom
    attributes, retrieve attributes, and then use them in our application logic. Using
    reflection to retrieve attribute information, we also looked at how we can create
    types, access properties, and invoke a method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will gain an understanding of why is it important to
    validate application input, the type of information that flows into our application,
    and how can we handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating custom attributes, a target can be set to restrict the usage
    of an attribute?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: _______ is the method used to retrieve attribute information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetAttributeValue`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetCustomAttribute`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetMetadata`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetAttributeMetadata`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The system allows you to retrieve property information from the object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**True**'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GetAttributeValue**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**True**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
