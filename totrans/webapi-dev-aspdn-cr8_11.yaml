- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides RESTful APIs, there are other types of APIs. One of them is the **remote
    procedure call** (**RPC**)-based API, which we introduced in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012).
    gRPC is a high-performance RPC framework developed by Google. Now, it is an open-source
    project under the **Cloud Native Computing Foundation** (**CNCF**), and it is
    becoming more and more popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a set of gRPC tools to help us build gRPC services. In
    this chapter, we will introduce the fundamentals of gRPC and **Protocol Buffers**
    (**Protobuf**) messages. First, we will learn how to define protobuf messages
    and gRPC services. Then, we will learn how to implement gRPC services in ASP.NET
    Core, empowering us to communicate seamlessly between different applications.
    We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Recap of gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a gRPC project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining gRPC services and messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing gRPC services and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming gRPC services in ASP.NET Core applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand the fundamentals
    of protobuf and gRPC and know how to build gRPC services in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11).
    You can use VS 2022 or VS Code to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Recap of gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have read [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012), you should
    be familiar with the concept of RPC – it is a protocol that allows a program to
    call a procedure on a remote machine. Unlike RESTful APIs, which center around
    resources, RPC-based APIs focus on actions. So, RPC methods support various types
    of actions besides CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is one of the most popular RPC frameworks. It provides many benefits over
    traditional RPC frameworks. As we mentioned in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012),
    gRPC is based on HTTP/2, which is more efficient than HTTP/1.1\. gRPC uses protobuf
    as the default data serialization format, which is a binary format that is more
    compact and efficient than JSON. The tooling support for gRPC is also very good.
    It follows the contract-first approach, which means we can create language-neutral
    service definitions and generate code for different languages. It also supports
    streaming, which is a very useful feature for real-time communication.
  prefs: []
  type: TYPE_NORMAL
- en: With the increasing popularity of microservices, gRPC is becoming more and more
    popular. While gRPC offers some advantages over RESTful APIs, it is not considered
    a complete replacement. gRPC is an excellent choice for high-performance, low-latency
    communication between microservices, but RESTful APIs are more suitable for web-based
    applications and scenarios where simplicity, flexibility, and wide adoption are
    more critical. It’s important to choose the right protocol based on the requirements
    of your specific use case. In the next section, we will learn how to set up a
    gRPC project in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a gRPC project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a gRPC project using the dotnet CLI. We will
    also create a client project to consume the gRPC service. We will be using the
    same project throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new gRPC project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new gRPC project, we can use the `dotnet new` command. The dotnet
    CLI provides a template for gRPC projects, which includes a basic gRPC service.
    We can use the following command to create a new gRPC project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `-o` option specifies the output directory. After running the command, we
    will see that a project named `GrpcDemo` is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to use VS 2022, you can also create a new gRPC project in VS
    2022 using the built-in gRPC template. You can select the **ASP.NET Core gRPC
    Service** template when creating a new project, as shown in *Figure 11**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Creating a new gRPC project in VS 2022](img/B18971_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Creating a new gRPC project in VS 2022
  prefs: []
  type: TYPE_NORMAL
- en: After creating the project, you can use VS Code or VS 2022 to open the project.
    Next, we’ll explore the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the gRPC project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project structure of a gRPC project has some differences from a RESTful
    API project. There is no `Controllers` folder in the gRPC project. Instead, there
    is a `Protos` folder, which contains the proto files. You can find a `greet.proto`
    file in the `Protos` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: gRPC uses protobuf as the default data serialization format. The `greet.proto`
    file is the proto file that defines the gRPC service and messages. If you are
    familiar with RESTful APIs, you can think of this file as the Swagger file (OpenAPI
    specification). It is the contract of the gRPC service. In the preceding proto
    file, we define a service named `Greeter` with a method named `SayHello()`. The
    `SayHello()` method takes a `HelloRequest` message as input and returns a `HelloReply`
    message as output. Both `HelloRequest` and `HelloReply` messages have string properties
    named `name` and `message`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In a proto file, you can use `//` to add comments. To add multi-line comments,
    you can use `/* ... */`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: VS Code does not provide syntax highlighting for proto files by default. You
    can install some extensions, such as `vscode-proto3`, to enable syntax highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the project file. Open the `GrpcDemo.csproj` file; we will see
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that it includes two package references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Grpc.AspNetCore`: This package provides the gRPC server library for ASP.NET
    Core. It also references the `Grpc.Tools` package, which provides the code-generation
    tooling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Google.Protobuf`: This package provides the `Protobuf` runtime library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a `Protobuf` item group that includes the proto file. The `GrpcServices`
    attribute specifies the type of code generated by the proto file. It can be set
    to the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`None`: No code is generated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: This option only generates client-side code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Server`: This option only generates server-side code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Both`: This option generates both client-side code and server-side code. It
    is the default value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the template project, the `GrpcServices` attribute is set to `Server`, which
    means only server-side code is generated.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple proto files, you can add multiple `Protobuf` items to the
    `ItemGroup` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s check the `Services` folder. You can find the `GreeterService.cs`
    file in the `Services` folder, which contains the implementation of the `Greeter`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GreeterService` class inherits from the `GreeterBase` class, which is generated
    by the proto file. It has a `SayHello()` method, which takes a `HelloRequest`
    object as input and returns a `HelloReply` object as output. The implementation
    of the `SayHello()` method is very simple – it matches the definition of the `SayHello()`
    method in the proto file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you move your mouse over the `HelloRequest` class in VS Code, you will see
    a pop-up message, which shows that the namespace of the `HelloRequest` class is
    `GrpcDemo.HelloRequest`, as shown in *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The namespace of the HelloRequest class](img/B18971_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The namespace of the HelloRequest class
  prefs: []
  type: TYPE_NORMAL
- en: The `HelloReply` class is also similar. However, you won’t be able to find the
    `HelloRequest` class and the `HelloReply` class in the project. Where are these
    classes defined?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can press *F12* to go to the definition of the `HelloRequest` class in
    VS Code. You will be navigated to a `Greet.cs` file, which is located in the `obj\Debug\net8.0\Protos`
    folder. This file is generated by the proto file and contains the definition of
    the `HelloRequest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the definition of the `HelloRequest` class, you can see that it implements
    the `IMessage<HelloRequest>` interface, which is defined in the `Google.Protobuf`
    package. All protobuf messages must implement this base interface. The `HelloRequest`
    class also has a `Name` property, which is defined in the proto file. You can
    find a `DebuggerNonUserCodeAttribute` attribute on the `Name` property. This attribute
    means that the `Name` member is not part of the user code for an application.
    The `Name` property also has a `GeneratedCode` attribute, which means this member
    is generated by the tooling. Specifically, the `Name` property is generated by
    the `protoc` tool, which is the protobuf compiler. Users should not modify this
    member.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the definition of the `HelloReply` class in the `Greet.cs`
    file. Next to the `Greet.cs` file, in the `Protos` folder, you can find a `GreetGrpc.cs`
    file, which defines the `GreeterBase` abstract class as the base class of the
    `GreeterService` class. Similarly, the `GreeterBase` class is also generated by
    the gRPC tooling. It contains the definition of the `SayHello()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `GreeterBase` class is marked with the `BindServiceMethod` attribute, which
    means this method is the implementation of the `SayHello()` method defined in
    the proto file. The `SayHello()` method has an attribute called `GeneratedCode`
    that indicates that this class is generated by the gRPC C# plugin. Inside the
    `SayHello()` method, you can see that it throws an exception by default. Because
    this method is `virtual`, we need to override this method in the `GreeterService`
    class to provide the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s check the `Program.cs` file. You will find the following code in
    the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we can see that the `AddGrpc()` method is called
    to add gRPC services to the service container. Then, we use the `MapGrpcService<GreeterService>()`
    method to map the `GreeterService` class to the gRPC service, which is similar
    to the `MapControllers` method in the RESTful API project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another line of code in the `Program.cs` file that uses the `MapGet()`
    method to show a message if users access the root path of the application from
    a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is because gRPC services cannot be accessed by a web browser. So, we need
    to show a message to notify users that they need to use a gRPC client to access
    the gRPC service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the proto file and see what happens. Open the `greet.proto` file
    and update the `HelloRequest`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and go back to the `GreeterService` class. In the `SayHello()`
    method, you can try to access the `Address` property of the `HelloRequest` object.
    You will find that the `Address` property is not available. This is because the
    generated code is not updated. We need to regenerate the code by using the `dotnet
    build` command. Alternatively, you can delete the `obj` folder and the code will
    be regenerated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find that it is not convenient to store the generated code in the `obj`
    folder. We can change the output directory of the generated code by using the
    `OutputDir` attribute in the `Protobuf` item in the `.csproj` file. For example,
    you can change the `Protobuf` item as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the generated code will be stored in the `Generated\Protos` folder. A
    proto file can generate multiple files for server-side code. For example, the
    `greet.proto` file will generate the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`greet.cs`: This file contains the definition of the messages and the methods
    to serialize and deserialize the messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`greetGrpc.cs`: This file contains the definition of the base class of the
    service and the methods to bind the service to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the structure of the gRPC project, let’s learn the concepts
    behind protobuf messages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating protobuf messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to create protobuf messages. We will introduce
    the concepts of protobuf messages and how to define them in a proto file.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is a contract-first framework, meaning that the gRPC service and messages
    must be defined in a proto file. When we talk about messages, we are talking about
    the data that is sent between the client and the server. While gRPC messages may
    be similar to the data model in RESTful APIs, they are not the same. RESTful APIs
    are centered around resources, and the data model is usually a resource model
    that can be mapped to one or multiple database tables. In contrast, gRPC is action-based,
    and the message can be any other type of data model or other message sent between
    the client and the server. Therefore, gRPC messages may not be exactly mapped
    to a resource model in RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when creating an invoice through a RESTful API using JSON as the
    data format, we need to send an HTTP POST request with a JSON body to the server.
    The JSON body will be deserialized into a .NET object, which serves as the data
    model for the invoice. To retrieve an invoice, we need to send an HTTP GET request
    to the server and the server. The server will serialize the data model into a
    JSON string and send it back to the client. We may also have other actions, such
    as updating an invoice, deleting an invoice, and so on. All these actions are
    mapped to HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the same functionality using gRPC, we need to define a gRPC service
    with several methods: `CreateInvoice()`, `GetInvoice()`, `UpdateInvoice()`, `DeleteInvoice()`,
    and others. For each of these methods, we must also define the corresponding request
    and response messages. For example, the `CreateInvoice()` method requires a `CreateInvoiceRequest`
    message containing the properties of the invoice, as well as a `CreateInvoiceResponse`
    message containing the ID of the created invoice. It is important to note that
    the request and response messages are distinct from the data model of the invoice,
    which is used to represent the invoice entity in the system. The request and response
    messages are used to send data between the client and the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that gRPC and protobuf are not the same thing. protobuf is a language-neutral,
    platform-neutral data serialization format. gRPC is a framework that uses protobuf
    as the default data serialization format. Sometimes, these two terms are used
    interchangeably, but we should know the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the invoice example we mentioned previously. An invoice has several
    properties, such as the invoice number, the invoice date, the customer’s name,
    the total amount, and so on. A customer has a name and an address. An address
    has some properties, such as street, city, state, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll define the first message that is used to create an address for the
    invoice service. The source code for this section can be found in the `chapter11/GrpcDemo-v2`
    folder. We will start with a simple message and then introduce more concepts regarding
    protobuf messages, including field numbers, field types, and how to use other
    .NET types in protobuf messages. We will also learn how to implement list and
    dictionary types using the `repeated` and `map` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a protobuf message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `invoice.proto` file in the `Protos` folder. VS Code provides
    a proto file template when you create a new file, as shown in *Figure 11**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The proto file template in VS Code](img/B18971_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The proto file template in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'The proto file template creates a proto file named `Protos.proto`. Rename it
    `invoice.proto`. The content of the proto file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A proto file is a text file with the `.proto` extension. The first line of the
    proto file specifies the syntax version of the proto file. At the time of writing,
    the latest version of the proto file is version 3, which was released in 2016\.
    You can find more information about the proto file syntax at [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/).
  prefs: []
  type: TYPE_NORMAL
- en: The `option csharp_namespace` line specifies the namespace of the generated
    code in C#. You can change the namespace according to your needs. This option
    is used to avoid naming conflicts between different proto files. Note that even
    though a proto file is language-neutral, the `option csharp_namespace` attribute
    is only used by the C# code generator. In this sample project, we can change the
    namespace to `GrpcDemo` to match the namespace of the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Protobuf supports a `package` keyword to avoid naming conflicts, depending on
    the language. For example, `package com.company` is equivalent to `option csharp_namespace
    = "Com.Company"` in C# (the name will be converted into PascalCase), and `package
    com.company` is equivalent to `option java_package = "com.company"` in Java. However,
    `package com.company` will be ignored in Python since Python modules are organized
    by filesystem directories.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using C#, we use the `option csharp_namespace` attribute, which
    can override the `package` keyword for C# applications. If you share the proto
    file with other applications that use other languages, you can use the `package`
    keyword or the language-specific option to avoid naming conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the proto file has been created, we need to add it to the project file.
    Open the `GrpcDemo.csproj` file and add the following code to an `<``ItemGroup>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, the gRPC tooling will generate the code for the `invoice.proto` file when
    we build the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC proto3 uses similar concepts as .NET classes to define messages. However,
    there are some differences. For example, proto3 does not support `GUID` and `decimal`
    types. Let’s start with a simple message. We can define an `Address` message as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, it is similar to a .NET class. We use a `message` keyword to
    define a gRPC message. In the message body, we can use `string` to declare a string
    field. However, there are some questions to answer here:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we assign a number to each property? Is it the default value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why does the number start with 1? Can we use 0?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we use these numbers in a specific order?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s answer these questions before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding field numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The numbers following the field names are called *field numbers*. Field numbers
    play an important role in the proto file. These field numbers are used to identify
    the fields in the message. What is the benefit of using field numbers instead
    of field names? Let’s look at an example of an XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding XML document, each field is wrapped in a tag. We have to open
    and close the tags to wrap the values of the fields. The XML syntax wastes a lot
    of space when transferring data. Consider the following example of a JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding JSON document, we just use each field name once. Normally,
    JSON format is more compact than XML format. What if we get rid of the field names?
    That is why we use field numbers in the proto file. By using field numbers instead
    of field names when encoding the message, we can make the gRPC message more compact.
    This is because numbers are shorter than field names. Additionally, protobuf uses
    a binary format, which is more compact than plain text formats such as JSON and
    XML. This further helps reduce the size of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to note about field numbers according to the protobuf
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: The range of field numbers is from `1` to `536,870,911`. So we cannot use `0`
    as a field number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field numbers must be unique within a message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field numbers `19000` to `19999` are reserved for protobuf, so you cannot use
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, the order of the field numbers does not matter. It is recommended
    to use the ascending order of the field numbers. Smaller field numbers use fewer
    bytes to encode. For example, a field number between `1` and `15` uses only one
    byte to encode, but numbers from `16` to `2047` use two bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a field number is assigned to a field, it cannot be changed if the proto
    file is used in production. Changing a field number will break the backward compatibility
    of the proto file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we have learned what field numbers are and why we use them. Next,
    let’s understand field types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the field types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to .NET classes, a gRPC message can have different types of fields.
    protobuf provides a set of native types, which are called **scalar value types**.
    These scalar value types have representations in most programming languages. The
    following table lists the mapping between protobuf scalar value types and .NET
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protobuf Type** | **.****NET Type** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `double` | ±5.0 × 10−324 to ±1.7 × 10308. |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `float` | ±1.5 x 10−45 to ±3.4 x 1038. |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | `int` | The length is variable. Use `sint32` if the field has negative
    numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | `long` | The length is variable. Use `sint64` if the field has
    negative numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | `uint` | The length is variable. Unsigned integer. 0 to (232-1).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | `ulong` | The length is variable. Unsigned integer. 0 to (264-1).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sint32` | `int` | The length is variable. Signed integer. -231 to (231-1).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sint64` | `long` | The length is variable. Signed integer. -263 to (263-1).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fixed32` | `uint` | The length is always 4 bytes. This type is more efficient
    than `uint32` for serializing or deserializing values that are greater than 228.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fixed64` | `ulong` | The length is always 8 bytes. This type is more efficient
    than `uint64` for serializing or deserializing values that are greater than 256.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sfixed32` | `int` | The length is always 4 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `sfixed64` | `long` | The length is always 8 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `string` | A `string` field must be encoded in UTF-8 or 7-bit
    ASCII. The maximum length of a `string` field is 232. |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | `ByteString` | This type is defined in protobuf runtime. It can
    be mapped to and from C#’s `byte[]` type. |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Protobuf scalar value types and .NET types
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new message named `CreateContactRequest` and add some fields
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateContactRequest` message requires the `first_name`, `last_name`, `email`,
    `phone`, `year_of_birth`, and `is_active` fields. The types for these fields are
    `string`, `int32`, and `bool`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can run `dotnet build` to generate the code. Alternatively, you can
    delete the existing files in the `Generated` folder and gRPC tooling will regenerate
    the code automatically based on the proto files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code files contain some complicated code. However, we can find
    the definition of the `CreateContactRequest` class, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, some code has been omitted for brevity. You can
    see that the `CreateContactRequest` message has been converted into a .NET class,
    which includes the properties for each field.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Protobuf has a style guide for naming fields and methods. The general rules
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `lower_snake_case` for field names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `PascalCase` for method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File names should be in `lower_snake_case`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using double quotes for string literals is preferred over single quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indentation should be two spaces in length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information at [https://protobuf.dev/programming-guides/style/](https://protobuf.dev/programming-guides/style/).
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve learned how to use protobuf scalar value types. Now, let’s
    consider other types.
  prefs: []
  type: TYPE_NORMAL
- en: Other .NET types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The protobuf scalar data types do not support all the .NET types, such as `Guid`,
    `DateTime`, `decimal`, and others. There are some workarounds for these types.
    In this section, we will learn how to use these types in protobuf. We will also
    explore some other types, such as `enum` and `repeated`.
  prefs: []
  type: TYPE_NORMAL
- en: GUID values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GUID` type (on other platforms, it may have another name, `UUID`) is a
    128-bit structure that is used to identify objects. It is a very common type in
    .NET applications. Normally, a `GUID` value can be represented as a string that
    contains 32 hexadecimal digits. For example, `31F6E4E7-7C48-4F91-8D33-7A74F6729C8B`
    is a `GUID` value.
  prefs: []
  type: TYPE_NORMAL
- en: However, protobuf does not support the `GUID` type. The best way to represent
    a `GUID` value in protobuf is to use a `string` field. In the .NET code, we can
    use `Guid.Parse()` to convert a string into a `GUID` value and use `Guid.ToString()`
    to convert a `GUID` value into a string.
  prefs: []
  type: TYPE_NORMAL
- en: DateTime values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET has several types to represent a date and time value, such as `DateTime`,
    `DateTimeOffset`, and `TimeSpan`. Although protobuf does not support these types
    directly, it provides several extensions to support them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these extension types, we need to import the `google/protobuf/xxx.proto`
    file into the proto file. For example, here is a message that contains a timestamp
    and a duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the generated code for the `UpdateInvoiceDueDateRequest` message in the
    `Generated` folder. You will find that the `due_date` field is converted into
    a `Timestamp` type, and the `grace_period` field is converted into a `Duration`
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Timestamp` type and the `Duration` type are not native .NET types. They
    are defined in the `Google.Protobuf.WellKnownTypes` namespace, which includes
    some well-known types that are not supported by protobuf. The source code for
    these types can be found at [https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes](https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these types are not native .NET types, we need to convert them into
    native .NET types when using them. The `Google.Protobuf.WellKnownTypes` namespace
    provides some methods to do the conversion. Here is an example of converting .NET
    types into protobuf types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `Timestamp` class to convert `DateTime` and `DateTimeOffset`
    values into `Timestamp` values. The `Timestamp.FromDateTime()` method is used
    to convert a `DateTime` value, while the `Timestamp.FromDateTimeOffset()` method
    is used to convert a `DateTimeOffset` value. We can also use the `Duration.FromTimeSpan()`
    method to convert a `TimeSpan` value into a `Duration` value. Note that if you
    use the `DateTimeOffset` type in your application, the offset of `DateTimeOffset`
    values is always 0, and the `DateTime.Kind` property is always set to `DateTimeKind.Utc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can convert protobuf types into .NET types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Timestamp` class provides several methods for converting its values into
    other types. The `ToDateTime()` method can be used to convert a `Timestamp` value
    into a `DateTime` value, while the `ToTimeSpan()` method can be used to convert
    a `Duration` value into a `TimeSpan` value. Additionally, the `ToDateTimeOffset()`
    method can be used to convert a `Timestamp` value into a `DateTimeOffset` value.
    Depending on your requirements, you can select the appropriate method for your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Decimal values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing, protobuf does not support the `decimal` type directly.
    There are some discussions about adding the `decimal` type to protobuf, but it
    hasn’t been implemented yet. As a workaround, Microsoft Docs provides a `DecimalValue`
    type, which can be used to represent a `decimal` value in protobuf. The following
    code, which has been copied from Microsoft Docs, shows how to define a `decimal`
    value in protobuf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will not delve into the details of the `DecimalValue` type in this book.
    You can find more information at [https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals](https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals).
  prefs: []
  type: TYPE_NORMAL
- en: Enum values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `enum` type is very common in .NET applications. protobuf supports the
    `enum` type. Here’s an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding enum definition is similar to the enum definition in C#, but
    we need to define it in the proto file. In the preceding code, we define an `InvoiceStatus`
    enum type with six values. Note that every enum type must contain a `0` value,
    which is the default value and must be placed at the first position. The `InvoiceStatus`
    enum type is converted into a .NET enum type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `INVOICE_STATUS` prefix in the original names is removed
    because the prefix is the same as the enum name. In the .NET code, the enum names
    are converted into PascalCase.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `enum` type, .NET also has a common type named `nullable`. We’ll
    check out nullable types in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protobuf scalar value types, such as `int32`, `sint32`, `fixed32`, and `bool`,
    cannot be `null`. But in .NET, nullable value types are very common. For example,
    we can use `int?` to declare an integer value that can be `null`. To support nullable
    value types, protobuf provides some wrapper types, which are defined in the `google/protobuf/wrappers.proto`
    file, to support nullable types. We can import this file into the proto file and
    use the wrapper types. For example, we can define a message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `google.protobuf.DoubleValue` type is used to represent
    a nullable `double` value, the `google.protobuf.Int32Value` type is used to represent
    a nullable `int32` value, and the `google.protobuf.BoolValue` type is used to
    define a nullable `bool` value. The generated code for the `AddInvoiceItemRequest`
    message is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `unitPrice`, `quantity`, and `IsTaxable` fields are converted
    into nullable types in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of .NET nullable types are supported by protobuf. Besides the `google.protobuf.DoubleValue`,
    `google.protobuf.Int32Value`, and `google.protobuf.BoolValue` types, protobuf
    also provides the following wrapper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`google.protobuf.FloatValue`: This type is used to represent a `float`? value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.protobuf.Int64Value`: This type is used to represent a `long`? value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.protobuf.UInt32Value`: This type is used to represent a `uint`? value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.protobuf.UInt64Value`: This type is used to represent a `ulong`? value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.protobuf.StringValue`: This type is used to represent a `string` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.protobuf.BytesValue`: This type is used to represent a `ByteString`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two special types in the preceding list: `google.protobuf.StringValue`
    and `google.protobuf.BytesValue`. The corresponding .NET types are `string` and
    `ByteString`. The `ByteString` type is a class that represents an immutable array
    of bytes, which is defined in the protobuf runtime. The default value of these
    two types is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if `google.protobuf.StringValue` is mapped to `string` in .NET, what is
    the difference between `google.protobuf.StringValue` and `string` in protobuf?
    The difference is the default value. We’ll look at the default values of these
    types in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table lists the default values of the scalar value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protobuf Type** | **Default Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | An empty string |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | An empty byte array |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric types | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `enums` | The first enum value |'
  prefs: []
  type: TYPE_TB
- en: Table 11.2 – Default values of protobuf scalar value types
  prefs: []
  type: TYPE_NORMAL
- en: If you use `string` as the type of a field, the default value will be an empty
    string. However, the default value of a `google.protobuf.StringValue` field is
    `null`. Similarly, the default value of a `bytes` field is an empty byte array,
    while the default value of a `google.protobuf.BytesValue` field is `null`. All
    other wrapper types also have a default value of `null`.
  prefs: []
  type: TYPE_NORMAL
- en: All numeric types, including `int32`, `double`, and `float`, have a default
    value of `0`. This applies to all numerical data types. `Enum` types in protobuf
    have a default value of the first value in the enum type, which must be 0\. For
    instance, the `InvoiceStatus` enum type has a default value of `INVOICE_STATUS_UNKNOWN`,
    which is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to .NET collections, protobuf supports repeated fields. A repeated
    field can contain zero or more items. The following code shows how to define a
    repeated field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the `repeated` keyword to define a repeated field.
    The generated code for the repeated `invoice_ids` field in the `UpdateInvoicesStatusRequest`
    message is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From the generated code, we can see that the repeated `string` field is converted
    into a `RepeatedField<string>` type. The `RepeatedField<T>` type is defined in
    the `Google.Protobuf.Collections` namespace, and it implements the .NET collection
    interfaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `RepeatedField<T>` type can be used as a normal .NET collection type, and
    any LINQ methods can be applied to it. This makes it a powerful and versatile
    tool for data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also find that the `InvoiceIds` field is a read-only property. To
    add one or multiple items to the collection, the `Add()` method can be used. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The default value of a repeated field is an empty collection.
  prefs: []
  type: TYPE_NORMAL
- en: Map fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protobuf supports map fields, which are collections of key-value pairs similar
    to a .NET dictionary. The following code provides an example of how to define
    a map field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated code for the `invoice_status_map` field is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MapField<Tkey, TValue>` type is defined in the `Google.Protobuf.Collections`
    namespace and it implements the `IDictionary<TKey, TValue>` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `MapField<TKey, TValue>` type can be used as a normal .NET dictionary type.
    This type provides the same functionality as a standard dictionary, allowing for
    the storage and retrieval of key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the repeated field, the `InvoiceStatusMap` field is also a read-only
    property. We can use the `Add()` method to add one key-value pair or multiple
    key-value pairs to the collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that map fields cannot be repeated. Also, the key of a map field must be
    a `string` or integer type. You cannot use an `enum` type as the key of a map
    field. The value of a map field can be any type, including a message type. But
    the value type cannot be another map field.
  prefs: []
  type: TYPE_NORMAL
- en: We have now acquired a comprehensive understanding of protobuf messages, including
    field numbers, field types, default values, repeated fields, and map fields. For
    further information on protobuf messages, please refer to [https://protobuf.dev/programming-guides/proto3/](https://protobuf.dev/programming-guides/proto3/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll examine the various protobuf services. We will explore the various
    types of RPC methods and how to create a gRPC client for the service. By doing
    so, we will gain a better understanding of how these services function and how
    to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a protobuf service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have understood the definition of a protobuf message, we can move
    on to defining protobuf services. These services are comprised of RPC methods,
    each of which has a request and response message. To facilitate the implementation
    of these services, gRPC tooling will generate the necessary C# code, which can
    then be used as the base class for the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC supports four types of RPC methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unary RPC**: The client sends a single request message to the server and
    receives a single response message in return. This type of method is suitable
    for applications that need single request-response exchanges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server streaming RPC**: The client sends a single request message to the
    server and the server then responds with a stream of response messages. This type
    of method allows for continuous data exchange between the client and server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client streaming RPC**: The client sends a stream request message to the
    server and the server then responds with a response message. Similar to server
    streaming RPC, this type of method also allows for a continuous data exchange
    but the data change is initiated by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bidirectional streaming RPC**: The client initiates the process by sending
    a stream request message, to which the server responds with a stream response
    message. This type of method enables communication between the client and the
    server to be conducted in both directions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s check out these RPC methods one by one. The source code for this section
    can be found in the `chapter11/GrpcDemo-v3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a unary service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A unary service is the simplest type of RPC method. The following code shows
    a unary service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we define a `CreateContactRequest` message and a `CreateContactResponse`
    message, and then we define a `ContactService` service, which contains a `CreateContact()`
    RPC method. The `CreateContact` RPC method requires a `CreateContactRequest` request
    message and a `CreateContactResponse` response message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code for the `CreateContact()` RPC method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `ContactServiceBase` class is a base class for the service implementation.
    It contains the `CreateContact()` method, which is a `virtual` method. By default,
    the `CreateContact()` method throws an exception because the method is not implemented.
    We need to override this method in the service implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `ContactService.cs` file in the `Service` folder. In the `ContactService.cs`
    file, we need to implement the `ContactService` class, which is derived from the
    `ContactServiceBase` class. The `ContactService` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we override the `CreateContact()` method and implement
    the method. This `CreateContact()` method allows us to execute some logic we need,
    such as saving the contact to the database. For simplicity, we just return a new
    `CreateContactResponse` object with a new `ContactId` value. In reality, we may
    have additional logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to register the `ContactService` class in the DI container. Open
    the `Program.cs` file and add the following code to the `ConfigureServices()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our new unary service simplifies the process of handling HTTP requests, eliminating
    the need to write any code or manage different HTTP methods. All RPC calls are
    handled by the gRPC framework, allowing for a streamlined process.
  prefs: []
  type: TYPE_NORMAL
- en: To call a gRPC service, a gRPC client must be created as current browsers do
    not support this protocol. Alternatively, tools such as Postman can be used to
    access the service. In the following section, we will demonstrate how to create
    a console application to call the service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a gRPC client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A gRPC can be a console application, a web application, or any other type of
    application, such as a WPF application. In this section, we will create a console
    application as the gRPC client for the unary service we created in the previous
    section. You can use similar code in other types of applications. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `dotnet new` command to create a new console project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have two projects. If you have not created a solution file, you can
    create it by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the two projects to the solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: cd GrpcDemo.Clientdotnet add GrpcDemo.Client.csproj package Grpc.Net.Client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the gRPC tooling to generate the client code, we also need to add the
    following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, copy the `Protos` folder from the `GrpcDemo` project to the `GrpcDemo.Client`
    project. Then, add the following code to the `GrpcDemo.Client.csproj` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the `GrpcDemo` project, we use the `Protobuf` element to specify
    the proto files and the output directory. The `GrpcServices` attribute is used
    to specify the type of the generated code. In this case, we use `Client` because
    we are creating a gRPC client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you make changes to the proto files in the `GrpcDemo` project, do not forget
    to copy the changes to the `GrpcDemo.Client` project to ensure that the client
    code is up to date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Generated/Protos` folder, you will find the generated code for each
    proto file. For example, the `invoice.proto` file will generate the following
    files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Invoice.cs`: This file contains the definition of the messages in the `invoice.proto`
    file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvoiceGrpc.cs`: This file contains the gRPC client code for the services
    in the `invoice.proto` file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s create an `InvoiceClient.cs` file in the project root folder and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we use the `GrpcChannel.ForAddress()` method to create
    a gRPC channel, which accepts the address of the gRPC server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get the address of the gRPC server, you can use the `dotnet run` command
    in the `GrpcDemo` project to start the gRPC server. The following output shows
    the address of the gRPC server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can check the `applicationUrl` property in the `Properties/launchSettings.json`
    file. The following code shows the `applicationUrl` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A gRPC channel is used to establish a connection to the gRPC server on the specified
    address and port. Once we have the gRPC channel, we can create an instance of
    the `ContactClient` class, which is generated from the proto file. Then, we call
    the `CreateContactAsync()` method to create a contact. The `CreateContactAsync()`
    method accepts a `CreateContactRequest` object as the parameter. The `CreateContactAsync()`
    method returns a `CreateContactResponse` object, which contains the `ContactId`
    value. At the end of the method, we print the `ContactId` value to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This method is straightforward. There are a few things to note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a gRPC channel is an expensive operation. So, it is recommended to
    reuse the gRPC channel. However, a gRPC client is a lightweight object, so there
    is no need to reuse it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create multiple gRPC clients from one gRPC channel, and you can safely
    use multiple gRPC clients concurrently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To secure the gRPC channel using TLS, you need to run the gRPC service with
    HTTPS. For example, you can use the following command to run the gRPC service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you can use the HTTPS address to create the gRPC channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: var contactClient = new InvoiceClient();await contactClient.CreateContactAsync();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the gRPC server and the gRPC client in different terminals. By doing this,
    you will be able to see the following output in the gRPC client terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple example of a gRPC client in a console application. In the next
    section, we will create a server streaming service and the corresponding gRPC
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a server streaming service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a unary service, a server streaming service has a request message
    and a response message. The difference is that the response message is a stream
    message. Once the server starts to send the stream response message, the client
    cannot send any more messages to the server, unless the server finishes sending
    the stream response message or the client cancels the RPC call by raising `ServerCallContext.CancellationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server streaming service is useful when we need to send a stream of data
    to the client. In this case, the server can send multiple messages to the client
    over a single RPC call. Here are some scenarios where a server streaming service
    is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Events streaming**: When the server needs to send a stream of event messages
    to the client so that the client can process the event messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time data feeds**: When the server has a continuous stream of data to
    send to the client, such as stock prices, weather data, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File streaming**: When the server needs to send a large file to the client,
    the server can split the file into small chunks and send them one by one as a
    stream response message. This can reduce the memory usage on the server and the
    client because the server and the client do not need to load the entire file into
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows a server streaming service with the required message
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding proto file, we define two messages named `GetRandomNumbersRequest`
    and `GetRandomNumbersResponse`. Then, we define a `RandomNumbers` service, which
    contains a `GetRandomNumbers()` RPC method. Note that the response message of
    the `GetRandomNumbers` RPC method is annotated with the `stream` keyword. This
    means that the response message is a stream message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code for the `GetRandomNumbers()` RPC method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the generated code, we can see that the type of the response message is
    `IServerStreamWriter<GetRandomNumbersResponse>`. Let’s add a simple implementation
    for the `RandomNumbers` service. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `RandomNumbersService.cs` file in the `Service` folder and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the implementation of the `GetRandomNumbers()` method, we use a `for` loop
    to generate random numbers and send them to the client every second. Note that
    we use the `responseStream.WriteAsync()` method to send the stream response message
    to the client. The message finishes sending when the loop ends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we need a continuous stream response message, we can check the `ServerCallContext.CancellationToken`
    property of the `context` parameter. If the client cancels the RPC call, the `ServerCallContext.CancellationToken`
    property will be raised. The following code shows how to check the `ServerCallContext.CancellationToken`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we use a `while` loop to check the `ServerCallContext.CancellationToken`
    property. If the client cancels the RPC call, the `ServerCallContext.CancellationToken`
    property will be raised, and the `while` loop will end. If there are any other
    asynchronous operations in the method, we can pass the `ServerCallContext.CancellationToken`
    property to the asynchronous operations. This can ensure that the asynchronous
    operations will be canceled when the client cancels the RPC call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will register the `RandomNumbersService` class in the DI container.
    Open the `Program.cs` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a gRPC client to call the `GetRandomNumbers()` RPC method.
    Create a `RandomNumbersClient.cs` file in the project root folder and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code to create the client is similar to that of `InvoiceClient`, which we
    introduced in the *Creating a gRPC client* section. The only difference is in
    the response message, which is handled using the `await foreach` statement. The
    `ReadAllAsync()` method returns an `IAsyncEnumerable<T>` object, which can be
    iterated over using the `await` `foreach` statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file of the `GrpcDemo.Client` project, call the `GetRandomNumbers()`
    method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the gRPC server and the gRPC client in different terminals. You will see
    that the output contains a series of random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is an example of a server streaming service and the corresponding gRPC
    client. In the next section, we will create a client streaming service and the
    corresponding gRPC client.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a client streaming service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A client streaming service allows the client to send a stream of messages to
    the server over a single request. The server then sends a single response message
    to the client when it finishes processing the stream request messages. Once the
    server sends the response message, the client streaming call is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some scenarios where a client streaming service is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File uploading**: When the client uploads a large file to the server, the
    client can split the file into small chunks and send them one by one as a stream
    request message, which can be more efficient than sending the entire file in a
    single request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time data capture**: When the client needs to send a stream of data
    to the server, such as sensor data, user interactions, or any continuous stream
    of data, the server can process the data and respond to the batch of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data aggregation**: When the client needs to send a batch of data to the
    server for aggregation or analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To define a client streaming service, we need to use the `stream` keyword to
    annotate the request message. The following code shows a client streaming service
    with the required message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `.proto` file defines two messages: `SendRandomNumbersRequest`
    and `SendRandomNumbersResponse`. The client sends a stream message containing
    a series of numbers to the server. The server then processes the stream message
    and calculates the sum of the numbers. Finally, the server sends a response message
    to the client, which contains the count of the numbers and the sum of the numbers.
    It is important to note that the `SendRandomNumbers()` RPC method is annotated
    with the `stream` keyword, indicating that the request message is a stream message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the server streaming service, we can implement the `SendRandomNumbers()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We utilize the `IAsyncStreamReader<T>.ReadAllAsync()` method in the preceding
    code to read all the stream request messages from the client. Subsequently, we
    use `await foreach` to iterate over the stream request messages. Lastly, we compute
    the count and sum of the numbers and return a `SendRandomNumbersResponse` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To consume the client streaming service, we will copy the proto files from
    the `GrpcDemo` project to the `GrpcDemo.Client` project. Then, we will create
    a `ClientStreamingClient` class in the `GrpcDemo.Client` project and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the `SendRandomNumbers()` method, we create an `AsyncClientStreamingCall`
    object by calling the `SendRandomNumbers()` method of the `RandomNumbersClient`
    class. Note that the client streaming call starts when the `SendRandomNumbers()`
    method is called, but the client does not send any messages until the `RequestStream.CompleteAsync()`
    method is called. In a `for` loop, we use the `RequestStream.WriteAsync()` method
    to send the stream request message to the server. At the end of the method, we
    call the `RequestStream.CompleteAsync()` method to indicate that the stream request
    message is complete. The stream request message contains 20 numbers, which are
    generated randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file of the `GrpcDemo.Client` project, we then call the
    `SendRandomNumbers()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the gRPC server and the gRPC client in different terminals. After around
    20 seconds, you will see the following output in the gRPC client terminal (the
    sum may be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With that, we’ve learned how to create a client streaming service and the corresponding
    gRPC client. In the next section, we will create a bidirectional streaming service
    and the corresponding gRPC client.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a bidirectional streaming service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bidirectional streaming service allows the client and the server to send a
    stream of messages to each other over a single request concurrently. Once the
    connection has been established, the client and the server can send messages to
    each other at any time in any order because the two streams are independent. For
    example, the server can respond to each message from the client, or the server
    can send a response message after receiving a series of messages from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some scenarios where a bidirectional streaming service is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat applications**: When the client and the server need to send instant
    messages to each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time data dashboard**: When the client continuously sends data to the
    server and the server builds a real-time dashboard to display the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplayer games**: When the players need to interact with each other in
    real-time and the server needs to synchronize the game state between the players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s define a bidirectional streaming service. In this example, the client
    sends some sentences to the server and the server responds to each sentence with
    the uppercase version of the sentence. The following code shows the required message
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding proto file, we have defined a `ChatMessage` message containing
    two fields: `sender` and `message`. Additionally, we have defined a `Chat` service
    with a `SendMessage` RPC method. It is important to note that both the request
    and response of this method are annotated with the `stream` keyword, indicating
    that they are both stream messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement the `SendMessage()` method. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `ChatService.cs` file in the `Service` folder and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we utilize the `await foreach` method to iterate over the stream request
    messages. For each request message, we use the `WriteAsync()` method to send a
    response message back to the client. This response message contains the uppercase
    version of the request message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, register the `ChatService` class in the dependency injection container.
    Open the `Program.cs` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: internal class BidirectionalStreamingClient{    public async Task SendMessage()    {        using
    var channel = GrpcChannel.ForAddress("https://localhost:7179");        var client
    = new Chat.ChatClient(channel);        // Create a streaming request        using
    var streamingCall = client.SendMessage();        Console.WriteLine("Starting a
    background task to receive messages...");        var responseReaderTask = Task.Run(async
    () =>        {            await foreach (var response in streamingCall.ResponseStream.ReadAllAsync())            {                Console.WriteLine(response.Message);            }        });        Console.WriteLine("Starting
    to send messages...");        Console.WriteLine("Input your message then press
    enter to send it.");        while (true)        {            var message = Console.ReadLine();            if
    (string.IsNullOrWhiteSpace(message))            {                break;            }            await
    streamingCall.RequestStream.WriteAsync(new ChatMessage            {                Message
    = message            });        }        Console.WriteLine("Disconnecting...");        await
    streamingCall.RequestStream.CompleteAsync();        await responseReaderTask;    }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Program.cs` file of the `GrpcDemo.Client` project, call the `SendMessage()`
    method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the gRPC server and the gRPC client in different terminals. You will see
    the following output in the gRPC client terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example is a simple demonstration of a bidirectional streaming service
    and the corresponding gRPC client. The bidirectional streaming service allows
    the client and the server to send a stream of messages to each other at any time
    in any order. In the preceding example, the service responds to each message from
    the client. However, using similar code, we can implement more complex logic per
    the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now explored four types of gRPC services: unary, server streaming,
    client streaming, and bidirectional streaming. We have also learned how to create
    a gRPC client to call each of these gRPC services. In the next section, we will
    learn how to use gRPC services in ASP.NET Core applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming gRPC services in ASP.NET Core applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to create console applications to consume
    gRPC services. In this section, we will integrate gRPC services into ASP.NET Core
    applications. We will reuse the gRPC services we created in the previous section,
    and we will create a new ASP.NET Core application to consume the gRPC services.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the steps outlined in this section, begin with the `GrpcDemo-v3`
    folder of the source code. The complete code for this section can be found in
    the `GrpcDemo-v4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console applications, we used the `GrpcChannel` class to create a gRPC
    channel, after which we used the gRPC channel to create a gRPC client, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In ASP.NET Core applications, a better way to create a gRPC client is to use
    the `IHttpClientFactory` interface with dependency injection. Let’s see how to
    use the DI container to create a gRPC client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a new ASP.NET Core application. In this ASP.NET Core
    application, we will create a REST API to consume the gRPC services we created
    in the previous section. Use the `dotnet new` command to create a new ASP.NET
    Core application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add this project to the solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Grpc.Net.ClientFactory package allows developers to create a gRPC client using
    a dependency injection container, eliminating the need for the new keyword. Additionally,
    the Grpc.Tools package can be used to generate gRPC client code from proto files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, copy the `Protos` folder from the `GrpcDemo` project to the `GrpcDemo.Api`
    project. Next, add the following code to the `GrpcDemo.Api.csproj` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the `GrpcDemo.Client` project, we use the `GrpcServices="Client"`
    attribute to specify the type of the generated code. In this case, we use `Client`
    because we will create a gRPC client to consume the gRPC services in the ASP.NET
    Core application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we can register the gRPC client in the DI container. Open the `Program.cs`
    file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[ApiController][Route("[controller]")]public class ContactController(Contact.ContactClient
    client, ILogger<ContactController> logger) : ControllerBase{    [HttpPost]    public
    async Task<IActionResult> CreateContact(CreateContactRequest request)    {        var
    reply = await _client.CreateContactAsync(request);        return Ok(reply);    }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the gRPC server and the ASP.NET Core application in different terminals.
    Note that the gRPC server address must match the address specified in the `AddGrpcClient()`
    method. Then, you can navigate to the Swagger UI page, such as `http://localhost:5284/swagger/index.html`,
    to test the `CreateContact()` action method. For example, you can use the following
    JSON object as the request body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following response (the `contactId` value may be different):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This simple example shows how to use the `AddGrpcClient()` method to register
    a gRPC client in the DI container in ASP.NET Core applications, and how to use
    the gRPC client to consume a unary gRPC service. For other types of gRPC services,
    you need to update the code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Updating proto files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: gRPC is a contract-first RPC framework. This means that the server and the client
    communicate with each other using a contract, which is defined in a proto file.
    Inevitably, the contract will change over time. In this section, we will learn
    how to update the contract and how to handle the changes in the server and the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Once a proto file is used in production, we need to consider backward compatibility
    when we update the proto file. This is because the existing clients may use the
    old version of the proto file, which may not be compatible with the new version
    of the proto file. If the new version of the contract is not backward compatible,
    the existing clients will break.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following changes are backward compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding new fields to a request message**: If the client does not send the
    new fields, the server can use the default values of the new fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding new fields to a response message**: If the response message contains
    the new fields but the client does not recognize the new fields, the client will
    discard the new fields in proto 3\. In the future version of proto, known as 3.5,
    this behavior will be changed to preserve the new fields as unknown fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a new RPC method to a service**: The client that uses old versions
    of the proto file will not be able to call the new RPC method. However, the old
    RPC methods will still work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a new service to a proto file**: Similar to adding a new RPC method,
    the new service will not be available to the old clients, but the old services
    will still work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following changes may cause breaking changes, which require the clients
    to be updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a field from a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming a field in a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing or renaming a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a data type of a field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a field number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing or renaming a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing or renaming an RPC method from a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming a package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the `csharp_namespace` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protobuf uses field numbers to serialize and deserialize messages. If we rename
    a field in a message without changing the field number and the data type, the
    message can still be serialized and deserialized correctly, but the field name
    in the .NET code will be different from the field name in the proto file. This
    can be confusing for developers. So, the client code needs to be updated to use
    the new field name.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a field from a message is a breaking change as the field number cannot
    be reused. For example, if we remove the `year_of_birth` field from the `CreateContactRequest`
    message defined in the *Understanding the field types* section for the gRPC server,
    the server will deserialize field number 5 as an unknown field. This could lead
    to errors in serialization/de-serialization if a developer later decides to add
    a new field with field number 5 as a different data type while existing clients
    still send field number 5 as an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To safely remove a field, we must ensure that the removed field number is not
    being used in the future. To avoid any potential conflicts, we can reserve the
    removed field number by using the `reserved` keyword. For example, if we delete
    the `year_of_birth` and `is_active` fields from the `CreateContactRequest` message,
    we can reserve the field numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `reserved` keyword to reserve field numbers
    5 and 6, and the `year_of_birth` and `is_active` field names. The reserved field
    numbers and field names cannot be reused in the proto file. If we try to use a
    reserved field number or field name, the gRPC tooling will report an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reserved field names should be listed, as well as the reserved
    field numbers. This ensures that the JSON and text formats are backward compatible.
    When the field names are reserved, they cannot be placed in the same `reserved`
    statement with the field numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored the fundamentals of gRPC services and clients.
    We discussed the field types that are used in protobuf, including the scalar types
    and some other types such as `DateTime`, `enum`, repeated fields, and map fields.
    Then, we learned about four types of gRPC services: unary, server streaming, client
    streaming, and bidirectional streaming. We explored how to implement each type
    of gRPC service and how to create a gRPC client to consume the gRPC service. Additionally,
    we demonstrated how to use the `AddGrpcClient()` method to register a gRPC client
    in the DI container of an ASP.NET Core application and how to use the gRPC client
    to consume a unary gRPC service. Finally, we discussed how to update the proto
    files and how to handle the changes in the server and the client.'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the code samples, we did not use any database access code in the
    gRPC services. In a real-world application, we may need to interact with a database
    or other external services in the gRPC services. You can follow the same approach
    as you do in REST API services.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is suitable for building high-performance service-to-service communication.
    Due to this book’s content limitations, we only covered the basics of gRPC. We
    did not cover advanced topics such as authentication, error handling, performance
    tuning, and others. However, this chapter should be enough to get you started
    with gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore GraphQL, an alternative approach to web
    APIs. GraphQL provides clients with the ability to request only the data they
    need, making it easier to modify APIs over time and enabling the use of powerful
    developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about gRPC on .NET Core, please refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://protobuf.dev/](https://protobuf.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://grpc.io/docs/languages/csharp/](https://grpc.io/docs/languages/csharp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/grpc/](https://learn.microsoft.com/en-us/aspnet/core/grpc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
