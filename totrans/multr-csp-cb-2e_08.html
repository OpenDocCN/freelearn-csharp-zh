<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Reactive Extensions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Reactive Extensions</h1></div></div></div><p>In this chapter, we will look at another interesting .NET library that helps us create asynchronous<a id="id332" class="indexterm"/> programs, <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>). We will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Converting a collection to asynchronous <code class="literal">Observable</code></li><li class="listitem" style="list-style-type: disc">Writing a custom <code class="literal">Observable</code></li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Subject</code> type</li><li class="listitem" style="list-style-type: disc">Creating an <code class="literal">Observable</code> object</li><li class="listitem" style="list-style-type: disc">Using LINQ queries against an <code class="literal">Observable</code> collection</li><li class="listitem" style="list-style-type: disc">Creating asynchronous operations with Rx</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Introduction</h1></div></div></div><p>As you have already learned, there are several approaches to creating asynchronous programs in .NET and C#. One of them is event-based asynchronous pattern, which has already been mentioned in the previous chapters. The initial goal of introducing events was to simplify the implementation of the <code class="literal">Observer</code> design pattern. This pattern is common for implementing notifications between objects.</p><p>When we discussed the Task Parallel Library, we noted that the event's main shortcoming was their inability to be effectively composed with each other. The other drawback was that the Event-based Asynchronous Pattern was not supposed to be used to deal with the sequence of notifications. Imagine that we have <code class="literal">IEnumerable&lt;string&gt;</code> that gives us string values. However, when we iterate it, we do not know how much time one iteration will take. It could be slow, and if we use the regular <code class="literal">foreach</code> loop or other synchronous iteration constructs, we will block our thread until we have the next value. This situation is called the <a id="id333" class="indexterm"/>
<span class="strong"><strong>pull-based</strong></span> approach, when we as a client pull values from the producer.</p><p>The opposite approach is the <span class="strong"><strong>push-based</strong></span> approach, when the producer notifies the client about new values. This allows to offload work to the producer, while the client is free to do anything else in the<a id="id334" class="indexterm"/> time it waits for another value. Therefore, the goal is to get something like the asynchronous version of <code class="literal">IEnumerable</code>, which produces a sequence of values and notifies the consumer about each item in the sequence, when the sequence is complete or when an exception is thrown.</p><p>.NET Framework starting from version 4.0 contains the definition of the <code class="literal">IObservable&lt;out T&gt;</code> and <code class="literal">IObserver&lt;in T&gt;</code> interfaces that together represent the asynchronous push-based collection and its client. They come from the library called Reactive Extensions (or simply Rx) that was created inside Microsoft to help us effectively compose the sequence of events and all other types of asynchronous programs using observable collections. The interfaces were included in .NET Framework, but their implementations and all other mechanics are still distributed separately in the Rx library.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Rx globally is<a id="id335" class="indexterm"/> a cross-platform library. There are libraries for .NET 3.5, Silverlight, and Windows Phone. It is also available in JavaScript, Ruby, and Python. It is also open source; you can find Reactive Extensions' source code for .NET on the CodePlex website and other implementations on GitHub.</p></div></div><p>The most amazing thing is that the observable collections are compatible with LINQ, and therefore, we are able to use declarative queries to transform and compose those collections in an asynchronous manner. This also makes it possible for us to use the extension methods to add functionalities to the Rx programs in the same way it is used in the usual LINQ providers. Reactive Extensions also supports transition from all asynchronous programming patterns (including the Asynchronous Programming Model, the Event-based Asynchronous Pattern, and the Task Parallel Library) to observable collections, and it supports its own way of running asynchronous operations, which is still quite similar to TPL.</p><p>The Reactive Extensions library is a very powerful and complex instrument, which is worthy of writing a separate book. In this chapter, I would like to review the most useful scenario, that is, how to work with asynchronous event sequences effectively. We will observe key types of the Reactive Extensions framework, learn to create sequences and manipulate them in different ways, and finally, check how we could use Reactive Extensions to run asynchronous operations and manage their options.</p></div></div>
<div class="section" title="Converting a collection to an asynchronous Observable"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Converting a collection to an asynchronous Observable</h1></div></div></div><p>This recipe walks<a id="id336" class="indexterm"/> you through the<a id="id337" class="indexterm"/> process of creating an observable collection from an <code class="literal">Enumerable</code> class and how to process it asynchronously.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec179"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe1</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec180"/>How to do it...</h2></div></div></div><p>To understand how to create an observable collection from an <code class="literal">Enumerable</code> class and process it asynchronously, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package by following these steps:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the <span class="strong"><strong>References</strong></span> folder in the project, and select the <span class="strong"><strong>Manage NuGet Packages…</strong></span> menu option.</li><li class="listitem">Now, add the <span class="strong"><strong>Reactive Extensions - Main Library</strong></span> NuGet package. You can search for <span class="strong"><strong>rx-main</strong></span> in the <span class="strong"><strong>Manage NuGet Packages</strong></span> dialog, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="graphics/B05292_08_01.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <a id="id338" class="indexterm"/><code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Reactive.Concurrency;
using System.Reactive.Linq;
using System.Threading;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the<a id="id339" class="indexterm"/> following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static IEnumerable&lt;int&gt; EnumerableEventSequence()
{
  for (int i = 0; i &lt; 10; i++)
  {
    Sleep(TimeSpan.FromSeconds(0.5));
    yield return i;
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">foreach (int i in EnumerableEventSequence())
{
  Write(i);
}

WriteLine();
WriteLine("IEnumerable");

IObservable&lt;int&gt; o = EnumerableEventSequence().().ToObservable();
using (IDisposable subscription = o.Subscribe(Write))
{
  WriteLine();
  WriteLine("IObservable");
}

o = EnumerableEventSequence().ToObservable()
    .SubscribeOn(TaskPoolScheduler.Default);
using (IDisposable subscription = o.Subscribe(Write))
{
  WriteLine();
  WriteLine("IObservable async");
  ReadLine();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec181"/>How it works...</h2></div></div></div><p>Here, we<a id="id340" class="indexterm"/> simulate a slow enumerable collection<a id="id341" class="indexterm"/> with the <code class="literal">EnumerableEventSequence</code> method. Then, we iterate it with the usual <code class="literal">foreach</code> cycle, and we can see that it is actually slow; we wait for each iteration to complete.</p><p>We then convert this enumerable collection to Observable with the help of the <code class="literal">ToObservable</code> extension method from the Reactive Extensions library. Next, we subscribe to the updates of this observable collection, providing the <code class="literal">Console.Write</code> method as the action, which will be executed on each update of the collection. As a result, we get exactly the same behavior as before; we wait for each iteration to complete because we use the main thread to subscribe to the updates.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>We wrap the subscription objects into using statements. Although it is not always necessary, disposing off the subscriptions is a good practice that will help you avoid lifetime-related bugs.</p></div></div><p>To make the program asynchronous, we use the <code class="literal">SubscribeOn</code> method, providing it with the TPL task pool scheduler. This scheduler will place the subscription to the TPL task pool, offloading<a id="id342" class="indexterm"/> the work from the main thread. This allows us to keep the UI responsive and do something else while the collection<a id="id343" class="indexterm"/> gets updated. To check this behavior, you could remove the last <code class="literal">Console.ReadLine</code> call from the code. When doing so, we finish our main thread immediately, which forces all background threads (including the TPL task pool worker threads) to end as well, and we will get no output from the asynchronous collection.</p><p>If we are using a UI framework, we have to interact with the UI controls only from within the UI thread. To achieve this, we should use the <code class="literal">ObserveOn</code> method with the corresponding scheduler. For Windows Presentation Foundation, we have the <code class="literal">DispatcherScheduler</code> class and the <code class="literal">ObserveOnDispatcher</code> extension method defined in a separate NuGet package named Rx-XAML or Reactive Extensions XAML support library. For other platforms, there are corresponding separate NuGet packages as well.</p></div></div>
<div class="section" title="Writing custom Observable"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Writing custom Observable</h1></div></div></div><p>This recipe<a id="id344" class="indexterm"/> will describe how to implement the <code class="literal">IObservable&lt;in T&gt;</code> and <code class="literal">IObserver&lt;out T&gt;</code> interfaces to get the custom Observable sequence and properly consume it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec182"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe2</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec183"/>How to do it...</h2></div></div></div><p>To understand how to implement the <code class="literal">IObservable&lt;in T&gt;</code> and <code class="literal">IObserver&lt;out T&gt;</code> interfaces to get the custom Observable sequence and consume it, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for more details on how to do this.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Reactive.Concurrency;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the<a id="id345" class="indexterm"/> following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">class CustomObserver : IObserver&lt;int&gt;
{
  public void OnNext(int value)
  {
    WriteLine($"Next value: {value}; Thread Id: {CurrentThread.ManagedThreadId}");
  }

  public void OnError(Exception error)
  {
    WriteLine($"Error: {error.Message}");
  }

  public void OnCompleted()
  {
    WriteLine("Completed");
  }
}

class CustomSequence : IObservable&lt;int&gt;
{
  private readonly IEnumerable&lt;int&gt; _numbers;
 
  public CustomSequence(IEnumerable&lt;int&gt; numbers)
  {
    _numbers = numbers;
  }
  public IDisposable Subscribe(IObserver&lt;int&gt; observer)
  {
    foreach (var number in _numbers)
    {
      observer.OnNext(number);
    }
    observer.OnCompleted();
    return Disposable.Empty;
  }
}</pre></div></li><li class="listitem">Add the<a id="id346" class="indexterm"/> following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var observer = new CustomObserver();

var goodObservable = new CustomSequence(new[] {1, 2, 3, 4, 5});
var badObservable = new CustomSequence(null);

using (IDisposable subscription = goodObservable.Subscribe(observer))
{
}

using (IDisposable subscription = goodObservable
    .SubscribeOn(TaskPoolScheduler.Default).Subscribe(observer))
{
  Sleep(TimeSpan.FromMilliseconds(100));
  WriteLine("Press ENTER to continue");
  ReadLine();
}

using (IDisposable subscription = badObservable
    .SubscribeOn(TaskPoolScheduler.Default).Subscribe(observer))
{
  Sleep(TimeSpan.FromMilliseconds(100));
  WriteLine("Press ENTER to continue");
  ReadLine();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec184"/>How it works...</h2></div></div></div><p>Here, we implement our observer first by simply printing out to the console the information about the next item from the observable collection, error, or sequence completion. This is a very simple consumer code and there is nothing special about it.</p><p>The interesting<a id="id347" class="indexterm"/> part is our observable collection implementation. We accept an enumeration of numbers into a constructor and do not check it for null on purpose. When we have a subscribing observer, we iterate this collection and notify the observer about each item in the enumeration.</p><p>Then, we demonstrate the actual subscription. As we can see, the asynchrony is achieved by calling the <code class="literal">SubscribeOn</code> method, which is an extension method to <code class="literal">IObservable</code> and contains asynchronous subscription logic. We do not care about asynchrony in our observable collection; we use standard implementation from the Reactive Extensions library.</p><p>When we subscribe to the normal observable collection, we just get all the items from it. It is now asynchronous, so we need to wait for some time for the asynchronous operation to complete and only then print the message and wait for the user input.</p><p>Finally, we try to subscribe to the next observable collection, where we are iterating a null enumeration and therefore getting a null reference exception. We see that the exception has been properly handled and the <code class="literal">OnError</code> method was executed to print out the error details.</p></div></div>
<div class="section" title="Using the Subject type family"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Using the Subject type family</h1></div></div></div><p>This recipe<a id="id348" class="indexterm"/> shows you how to use the <code class="literal">Subject</code> type family from the Reactive Extensions library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec185"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe3</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec186"/>How to do it...</h2></div></div></div><p>To understand the use of the <code class="literal">Subject</code> type family from the Reactive Extensions library, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for details on how to do this.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Reactive.Subjects;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine($"{obj}")
    , ex =&gt; WriteLine($"Error: {ex.Message}")
    , () =&gt; WriteLine("Completed")
  );
}</pre></div></li><li class="listitem">Add the<a id="id349" class="indexterm"/> following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">WriteLine("Subject");
var subject = new Subject&lt;string&gt;();

subject.OnNext("A");
using (var subscription = OutputToConsole(subject))
{
  subject.OnNext("B");
  subject.OnNext("C");
  subject.OnNext("D");
  subject.OnCompleted();
  subject.OnNext("Will not be printed out");
}

WriteLine("ReplaySubject");
var replaySubject = new ReplaySubject&lt;string&gt;();

replaySubject.OnNext("A");
using (var subscription = OutputToConsole(replaySubject))
{
  replaySubject.OnNext("B");
  replaySubject.OnNext("C");
  replaySubject.OnNext("D");
  replaySubject.OnCompleted();
}

WriteLine("Buffered ReplaySubject");
var bufferedSubject = new ReplaySubject&lt;string&gt;(2);

bufferedSubject.OnNext("A");
bufferedSubject.OnNext("B");
bufferedSubject.OnNext("C");
using (var subscription = OutputToConsole(bufferedSubject))
{
  bufferedSubject.OnNext("D");
  bufferedSubject.OnCompleted();
}

WriteLine("Time window ReplaySubject");
var timeSubject = new ReplaySubject&lt;string&gt;(TimeSpan.FromMilliseconds(200));

timeSubject.OnNext("A");
Sleep(TimeSpan.FromMilliseconds(100));
timeSubject.OnNext("B");
Sleep(TimeSpan.FromMilliseconds(100));
timeSubject.OnNext("C");
Sleep(TimeSpan.FromMilliseconds(100));
using (var subscription = OutputToConsole(timeSubject))
{
  Sleep(TimeSpan.FromMilliseconds(300));
  timeSubject.OnNext("D");
  timeSubject.OnCompleted();
}

WriteLine("AsyncSubject");
var asyncSubject = new AsyncSubject&lt;string&gt;();

asyncSubject.OnNext("A");
using (var subscription = OutputToConsole(asyncSubject))
{
  asyncSubject.OnNext("B");
  asyncSubject.OnNext("C");
  asyncSubject.OnNext("D");
  asyncSubject.OnCompleted();
}

WriteLine("BehaviorSubject");
var behaviorSubject = new BehaviorSubject&lt;string&gt;("Default");
using (var subscription = OutputToConsole(behaviorSubject))
{
  behaviorSubject.OnNext("B");
  behaviorSubject.OnNext("C");
  behaviorSubject.OnNext("D");
  behaviorSubject.OnCompleted();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec187"/>How it works...</h2></div></div></div><p>In this program, we look through different variants of the <code class="literal">Subject</code> type family. The <code class="literal">Subject</code> type represents both the <code class="literal">IObservable</code> and <code class="literal">IObserver</code> implementations. This is useful in <a id="id350" class="indexterm"/>different proxy scenarios when we want to translate events from multiple sources to one stream, or vice versa, to broadcast an event sequence to multiple subscribers. Subjects are also very convenient for experimenting with Reactive Extensions.</p><p>Let's start with the basic <code class="literal">Subject</code> type. It retranslates an event sequence to subscribers as soon as they subscribe to it. In our case, the <code class="literal">A</code> string will not be printed out because the subscription happened after it was transmitted. Besides that, when we call the <code class="literal">OnCompleted</code> or <code class="literal">OnError</code> methods on <code class="literal">Observable</code>, it stops further translation of the event sequence, so the last string will also not be printed out.</p><p>The next type, <code class="literal">ReplaySubject</code>, is quite flexible and allows us to implement three additional scenarios. First, it can cache all the events from the beginning of their broadcasting, and if we subscribe later, we will get all the preceding events first. This behavior is illustrated in the second example. Here, we will have all four strings on the console because the first event will be cached and translated to the latter subscriber.</p><p>Then, we can specify the buffer size and the time window size for <code class="literal">ReplaySubject</code>. In the next example, we set the subject to have a buffer for two events. If more events are broadcasted, only the last two will be retranslated to the subscriber. So here, we will not see the first string because we have <code class="literal">B</code> and <code class="literal">C</code> in the subject buffer when subscribing to it. The same is the case with a time window. We can specify that the <code class="literal">Subject</code> type only caches events that took place less than a certain time ago, discarding the older ones. Therefore, in the fourth example, we will only see the last two events; the older events do not fit into the time window.</p><p>The <code class="literal">AsyncSubject</code> type is something like a <code class="literal">Task</code> type from the TPL globally. It represents a single asynchronous operation. If there are several events published, it waits for the event sequence completion and provides only the last event to the subscriber.</p><p>The <code class="literal">BehaviorSubject</code> type is quite similar to the <code class="literal">ReplaySubject</code> type, but it caches only one value and allows us to specify a default value in case we did not send any notifications. In our last example, we will see all the strings printed out because we provided a<a id="id351" class="indexterm"/> default value, and all other events take place after the subscription. If we move the <code class="literal">behaviorSubject.OnNext("B");</code> line upwards below the <code class="literal">Default</code> event, it will replace the default value in the output.</p></div></div>
<div class="section" title="Creating an Observable object"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Creating an Observable object</h1></div></div></div><p>This recipe will <a id="id352" class="indexterm"/>describe different ways to create an <code class="literal">Observable</code> object.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec188"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe could be found at <code class="literal">BookSamples\Chapter8\Recipe4</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec189"/>How to do it...</h2></div></div></div><p>To understand different ways of creating an <code class="literal">Observable</code> object, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous Observable</em></span> recipe for details on how to do this.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine("{0}", obj)
    , ex =&gt; WriteLine("Error: {0}", ex.Message)
    , () =&gt; WriteLine("Completed")
  );
}</pre></div></li><li class="listitem">Add the <a id="id353" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">IObservable&lt;int&gt; o = Observable.Return(0);
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");
  
o = Observable.Empty&lt;int&gt;();
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

o = Observable.Throw&lt;int&gt;(new Exception());
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

o = Observable.Repeat(42);
using (var sub = OutputToConsole(o.Take(5)));
WriteLine(" ---------------- ");

o = Observable.Range(0, 10);
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

o = Observable.Create&lt;int&gt;(ob =&gt; {
  for (int i = 0; i &lt; 10; i++)
  {
    ob.OnNext(i);
  }
  return Disposable.Empty;
});
using (var sub = OutputToConsole(o)) ;
WriteLine(" ---------------- ");

o = Observable.Generate(
  0 // initial state
  , i =&gt; i &lt; 5 // while this is true we continue the sequence
  , i =&gt; ++i // iteration
  , i =&gt; i*2 // selecting result
);
using (var sub = OutputToConsole(o));
WriteLine(" ---------------- ");

IObservable&lt;long&gt; ol = Observable.Interval(TimeSpan.FromSeconds(1));
using (var sub = OutputToConsole(ol))
{
  Sleep(TimeSpan.FromSeconds(3));
};
WriteLine(" ---------------- ");

ol = Observable.Timer(DateTimeOffset.Now.AddSeconds(2));
using (var sub = OutputToConsole(ol))
{
  Sleep(TimeSpan.FromSeconds(3));
};
WriteLine(" ---------------- ");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec190"/>How it works...</h2></div></div></div><p>Here, we walk<a id="id354" class="indexterm"/> through different scenarios of creating <code class="literal">observable</code> objects. Most of this functionality is provided as static factory methods of the <code class="literal">Observable</code> type. The first two samples show how we can create an <code class="literal">Observable</code> method that produces a single value and one that produces no value. In the next example, we use <code class="literal">Observable.Throw</code> to construct an <code class="literal">Observable</code> class that triggers the <code class="literal">OnError</code> handler of its observers.</p><p>The <code class="literal">Observable.Repeat</code> method represents an endless sequence. There are different overloads of this method; here, we construct an endless sequence by repeating 42 values. Then, we use LINQ's <code class="literal">Take</code> method to take five elements from this sequence. <code class="literal">Observable.Range</code> represents a range of values, pretty much like <code class="literal">Enumerable.Range</code>.</p><p>The <code class="literal">Observable.Create</code> method supports more custom scenarios. There are a lot of overloads that allow us to use cancellation tokens and tasks, but let's look at the simplest one. It accepts a function, which accepts an instance of observer and returns an <code class="literal">IDisposable</code> object representing a subscription. If we had any resources to clean up, we would be able to provide the cleanup logic here, but we just return an empty disposable as we actually do not need it.</p><p>The <code class="literal">Observable.Generate</code> method is another way to create a custom sequence. We must provide an initial value for a sequence and then a predicate that determines whether we should generate more items or complete the sequence. Then, we provide an iteration logic, which increments a counter in our case. The last parameter is a selector function that allows us to customize the results.</p><p>The last two methods deal with timers. <code class="literal">Observable.Interval</code> starts producing timer tick events with the<a id="id355" class="indexterm"/> <code class="literal">TimeSpan</code> period, and <code class="literal">Observable.Timer</code> specifies the startup time as well.</p></div></div>
<div class="section" title="Using LINQ queries against an observable collection"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Using LINQ queries against an observable collection</h1></div></div></div><p>This recipe shows<a id="id356" class="indexterm"/> you how to use LINQ to query an<a id="id357" class="indexterm"/> asynchronous sequence of events.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec191"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe5</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec192"/>How to do it...</h2></div></div></div><p>To understand the use of LINQ queries against the observable collection, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for details on how to do this.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Reactive.Linq;
using static System.Console;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence, int innerLevel)
{
  string delimiter = innerLevel == 0 
        ? string.Empty 
        : new string('-', innerLevel*3);

  return sequence.Subscribe(
    obj =&gt; WriteLine($"{delimiter}{obj}")
    , ex =&gt; WriteLine($"Error: {ex.Message}")
    , () =&gt; WriteLine($"{delimiter}Completed")
  );
}</pre></div></li><li class="listitem">Add the <a id="id358" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">IObservable&lt;long&gt; sequence = Observable.Interval(
    TimeSpan.FromMilliseconds(50)).Take(21);

var evenNumbers = from n in sequence
        where n % 2 == 0
        select n;

var oddNumbers = from n in sequence
        where n % 2 != 0
        select n;

var combine = from n in evenNumbers.Concat(oddNumbers)
      select n;

var nums = (from n in combine
      where n % 5 == 0
      select n)
    .Do(n =&gt; WriteLine($"------Number {n} is processed in Do method"));

using (var sub = OutputToConsole(sequence, 0))
using (var sub2 = OutputToConsole(combine, 1))
using (var sub3 = OutputToConsole(nums, 2))
{
  WriteLine("Press enter to finish the demo");
  ReadLine();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec193"/>How it works...</h2></div></div></div><p>The ability to use<a id="id359" class="indexterm"/> LINQ against the <code class="literal">Observable</code> event sequences is the main advantage of the Reactive Extensions framework. There are many different useful scenarios as well; unfortunately, it is impossible to show all of them here. I tried to provide a simple, yet very illustrative example, which does not have many complex details and shows the very essence of how a LINQ query could work when applied to asynchronous observable collections.</p><p>First, we create an <code class="literal">Observable</code> event that generates a sequence of numbers, one number every 50 milliseconds, and we start from the initial value of zero, taking 21 of those events. Then, we compose LINQ queries to this sequence. First, we select only the even numbers from the sequence, and then only the odd numbers. Then, we concatenate these two sequences.</p><p>The final query shows us how to use a very useful method, <code class="literal">Do</code>, which allows us to introduce side effects and, for example, logging each value from the resulting sequence. To run all queries, we<a id="id360" class="indexterm"/> create nested subscriptions, and because the sequences are initially asynchronous, we have to be very careful about the subscription's lifetime. The outer scope represents a subscription to the timer, and the inner <a id="id361" class="indexterm"/>subscriptions deal with the combined sequence query and the side effects query, respectively. If we press <span class="emphasis"><em>Enter</em></span> too early, we just unsubscribe from the timer and thus stop the demo.</p><p>When we run the demo, we see the actual process of how different queries interact in real time. We can see that our queries are lazy, and they start running only when we subscribe to their results. The timer event's sequence is printed in the first column. When the even numbers query gets an even number, it prints it out as well using the <code class="literal">---</code> prefix to distinguish this sequence result from the first one. The final query results are printed in the right-hand column.</p><p>When the program runs, we can see that the timer sequence, the even-number sequence, and the side effect sequence run in parallel. Only the concatenation waits until the even-number sequence is complete. If we do not concatenate those sequences, we will have four parallel sequences of events interacting with each other in the most effective way! This shows the real power of Reactive Extensions and could be a good start to learn this library in depth.</p></div></div>
<div class="section" title="Creating asynchronous operations with Rx"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Creating asynchronous operations with Rx</h1></div></div></div><p>This recipe<a id="id362" class="indexterm"/> shows you how to create an <code class="literal">Observable</code> from<a id="id363" class="indexterm"/> the asynchronous operations defined in other programming patterns.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec194"/>Getting ready</h2></div></div></div><p>To work through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter8\Recipe6</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec195"/>How to do it...</h2></div></div></div><p>To understand how to create asynchronous operations with Rx, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <span class="strong"><strong>Reactive Extensions Main Library</strong></span> NuGet package. Refer to the <span class="emphasis"><em>Converting a collection to asynchronous observable</em></span> recipe for details on<a id="id364" class="indexterm"/> how to do this.</li><li class="listitem">In<a id="id365" class="indexterm"/> the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Reactive;
using System.Reactive.Linq;
using System.Reactive.Threading.Tasks;
using System.Threading.Tasks;
using System.Timers;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static async Task&lt;T&gt; AwaitOnObservable&lt;T&gt;(IObservable&lt;T&gt; observable)
{
  T obj = await observable;
  WriteLine($"{obj}" );
  return obj;
}

static Task&lt;string&gt; LongRunningOperationTaskAsync(string name)
{
  return Task.Run(() =&gt; LongRunningOperation(name));
}

static IObservable&lt;string&gt; LongRunningOperationAsync(string name)
{
  return Observable.Start(() =&gt; LongRunningOperation(name));
}

static string LongRunningOperation(string name)
{
  Sleep(TimeSpan.FromSeconds(1));
  return $"Task {name} is completed. Thread Id {CurrentThread.ManagedThreadId}";
}

static IDisposable OutputToConsole(IObservable&lt;EventPattern&lt;ElapsedEventArgs&gt;&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine($"{obj.EventArgs.SignalTime}")
    , ex =&gt; WriteLine($"Error: {ex.Message}")
    , () =&gt; WriteLine("Completed")
  );
}

static IDisposable OutputToConsole&lt;T&gt;(IObservable&lt;T&gt; sequence)
{
  return sequence.Subscribe(
    obj =&gt; WriteLine("{0}", obj)
    , ex =&gt; WriteLine("Error: {0}", ex.Message)
    , () =&gt; WriteLine("Completed")
  );
}</pre></div></li><li class="listitem">Replace<a id="id366" class="indexterm"/> the <code class="literal">Main</code> method with the<a id="id367" class="indexterm"/> following code snippet:<div class="informalexample"><pre class="programlisting">delegate string AsyncDelegate(string name);

static void Main(string[] args)
{
IObservable&lt;string&gt; o = LongRunningOperationAsync("Task1");
using (var sub = OutputToConsole(o))
{
  Sleep(TimeSpan.FromSeconds(2));
};
WriteLine(" ---------------- ");

Task&lt;string&gt; t = LongRunningOperationTaskAsync("Task2");
using (var sub = OutputToConsole(t.ToObservable()))
{
  Sleep(TimeSpan.FromSeconds(2));
};
WriteLine(" ---------------- ");

AsyncDelegate asyncMethod = LongRunningOperation;

// marked as obsolete, use tasks instead
Func&lt;string, IObservable&lt;string&gt;&gt; observableFactory = 
  Observable.FromAsyncPattern&lt;string, string&gt;(
        asyncMethod.BeginInvoke, asyncMethod.EndInvoke);

o = observableFactory("Task3");
using (var sub = OutputToConsole(o))
{
  Sleep(TimeSpan.FromSeconds(2));
};
WriteLine(" ---------------- ");

o = observableFactory("Task4");
AwaitOnObservable(o).Wait();
WriteLine(" ---------------- ");

using (var timer = new Timer(1000))
{
  var ot = Observable.
               FromEventPattern&lt;ElapsedEventHandler, ElapsedEventArgs&gt;(
    h =&gt; timer.Elapsed += h,
            h =&gt; timer.Elapsed -= h);
  timer.Start();

  using (var sub = OutputToConsole(ot))
  {
    Sleep(TimeSpan.FromSeconds(5));
  }
  WriteLine(" ---------------- ");
  timer.Stop();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec196"/>How it works...</h2></div></div></div><p>This recipe<a id="id368" class="indexterm"/> shows you how to convert different types<a id="id369" class="indexterm"/> of asynchronous operations to an <code class="literal">Observable</code> class. The first code snippet uses the <code class="literal">Observable.Start</code> method, which is quite similar to <code class="literal">Task.Run</code> from TPL. It starts an asynchronous operation that gives out a string result and then gets completed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>I would strongly suggest that you use the Task Parallel Library for asynchronous operations. Reactive Extensions supports this scenario as well, but to avoid ambiguity, it is much better to stick with tasks when speaking about separate asynchronous operations and to go with Rx only when we need to work with sequences of events. Another suggestion is to convert every type of separate asynchronous operation to tasks and only then convert a task to an observable class, if you need it.</p></div></div><p>Then, we do<a id="id370" class="indexterm"/> the same with tasks and convert a task to an <code class="literal">Observable</code> method by simply calling the <code class="literal">ToObservable</code> extension method. The next code<a id="id371" class="indexterm"/> snippet is about converting the Asynchronous Programming Model pattern to <code class="literal">Observable</code>. Normally, you would convert APM to a task and then a task to <code class="literal">Observable</code>. However, there is a direct conversion, and this example illustrates how to run an asynchronous delegate and wrap it into an <code class="literal">Observable</code> operation.</p><p>The next part of the code snippet shows that we are able to use the <code class="literal">await</code> operator in an <code class="literal">Observable</code> operation. As we are not able to use the <code class="literal">async</code> modifier on an entry method such as <code class="literal">Main</code>, we introduce a separate method that returns a task and waits for this resulting task to be complete inside the <code class="literal">Main</code> method.</p><p>The last part of this code snippet is the same as the code which converts APM pattern to Observable, but now, we convert the Event-based Asynchronous Pattern directly to an <code class="literal">Observable</code> class. We create a timer and consume its events for 5 seconds. We then dispose the timer to clean up the resources.</p></div></div></body></html>