- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Interactive Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the essential skills needed to construct interactive
    forms in Blazor. Forms are a critical component of many web applications, and
    Blazor provides tools that significantly simplify form creation and handling.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by learning how to bind simple and nested models to a form for
    capturing and managing user input. Next, we will explore the built-in input components
    provided by Blazor. These components help standardize form behavior across different
    platforms, ensuring consistency and reducing the amount of custom code needed.
    We will also cover techniques for interpreting keystrokes and making the form
    intuitive. At the end of the chapter, we will address the security aspect of form
    handling and the role of the **anti-forgery** token. Implementing these security
    measures is crucial for protecting your applications from common web threats such
    as **Cross-Site Request Forgery** ( **CSRF** ) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the practical knowledge to create,
    manage, and secure forms in Blazor applications – all vital for developing reliable,
    interactive, and user-friendly web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the list of recipes we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Binding a simple model to a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting static forms without full page reload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding nested models to a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing built-in input components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling file uploads with a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep the examples simple and focus on showcasing all the angles of
    setting up forms in Blazor. At the beginning of each recipe, you will find instructions
    on where to find required samples and which directories to create. With that said,
    you will need these basic tools for Blazor development:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern IDE (that supports Blazor development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser (that supports WebAssembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser DevTools (that could be a part of the modern browser already)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor project (where you’ll write your code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Handling file uploads with a form* recipe, we’ll utilize a NuGet package
    – **Microsoft.AspNetCore.Http.Features** – that’s not pre-installed by default,
    so you might as well add it to your project now.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the code samples on GitHub at : [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: Binding a simple model to a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the development of modern web applications, forms are ubiquitous and essential.
    Whether registering user details, collecting feedback, or entering information,
    forms serve as the primary interface for user input. Blazor supports a traditional
    HTML **<form>** markup but elevates the experience with its native **EditForm**
    component. **EditForm** integrates seamlessly with Blazor’s data binding capabilities
    and provides a streamlined, efficient approach to form management.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the first small form that binds to a simple data model and allows
    the user to create a new event by providing its name.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start creating a form and bind it to a simple model, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter06** / **Recipe01** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a form supporting a simple data model, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a routable **EventManager** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **@code** block of **EventManager** , declare a **Model** object
    and decorate it with a **SupplyParameterFromForm** attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still inside the **@code** block, override the **OnInitialized()** lifecycle
    method with conditional initialization of the **Model** parameter if it’s unset.
    Additionally, implement a **Save()** method as a placeholder to simulate saving
    the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the markup of **EventManager** , embed an **EditForm** component and bind
    it to the **Model** parameter. Include an input field for entering **Model.Name**
    and a submit button that triggers the **Save()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a routable **EventManager** component, which will serve
    as the container for our form.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , within the **@code** block of **EventManager** , we declare a
    **Model** parameter for our form with a form-specific attribute – **SupplyParameterFromForm**
    – enabling Blazor to automatically populate the **Model** object with values from
    the associated form. In *step 3* , we finalize the **@code** block of **EventManager**
    . We override the **OnInitialized()** lifecycle method to seamlessly initialize
    the **Model** parameter to an empty object unless it already carries a value.
    Additionally, we introduce a **Save()** method, acting as a placeholder to mimic
    the saving of changes made to the form.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we tackle the implementation of the **EventManager** markup, leveraging
    Blazor’s built-in **EditForm** component. We assign our **Model** object to the
    **Model** parameter of the **EditForm** component and the **Save()** method to
    the **OnSubmit** callback, automating the invocation of **Save()** upon form submission.
    Crucially, we set a unique value for the **FormName** parameter of **EditForm**
    , allowing Blazor to properly resolve the form data. Within the form, we incorporate
    a simple input box, binding it to the **Model.Name** property, and include a submit
    button to facilitate form submission.
  prefs: []
  type: TYPE_NORMAL
- en: We opted not to declare any render mode intentionally, resulting in static server-side
    rendering of our page. While this approach ensures quick rendering and minimal
    resource utilization on the server, submitting the form requires a full page reload
    – similar to **MVC** or **Razor** **pages** applications.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each parameter of the **EditForm** component has a corresponding Blazor attribute,
    compatible with standard HTML, which means you can customize the behavior of your
    forms extensively without relying on the **EditForm** component. You can retain
    the standard HTML **<form>** markup and customize it to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a practical example, here’s how you can implement our form using
    the HTML **<** **form>** markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We construct a simple form, leveraging the default HTML **form** element. We
    declare the form’s unique name, the method to call on submit, and that Blazor
    should execute a **post** action when submitting the data. However, as we no longer
    leverage the **EditForm** component, Blazor will force us to provide an anti-forgery
    token for security reasons. For that, we leverage a built-in **AntiforgeryToken**
    component, but we will explore that component in detail in the *Securing a form
    with an anti-forgery token* recipe, at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting static forms without full page reload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor, leveraging the diffing algorithm (we talked about it in the *Hooking
    into event delegates* recipe in [*Chapter 3*](B22020_03.xhtml#_idTextAnchor095)
    ), offers an **enhanced navigation** feature, which optimizes user interactions
    by reducing unnecessary re-renderings and updating only the parts of the UI that
    have changed rather than reloading entire pages. Interactive render modes have
    the diffing algorithm enabled by default, but forms rendered in **static server-side
    render** ( **SSR** ) mode do not. In this recipe, we will explore how to enable
    the enhanced navigation on the **EditForm** component using the **Enhanced** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enable enhanced navigation on the **Event** creation form and prevent
    the form from reloading the entire page upon submission while maintaining its
    operation in SSR mode.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore form enhancing, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter06** / **Recipe02** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **EventManager** component from the *Binding a simple model to a form*
    recipe or from the **Chapter06** / **Recipe01** directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable enhanced navigation on your form, navigate to the **EventManager**
    component and set the **Enhance** parameter value of the **EditForm** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we navigate to the **EventManager** component and set the value
    of the **Enhance** parameter on the **EditForm** component. Since **Enhance**
    is of type **bool** , merely stating the parameter name is equivalent to declaring
    **Enhance="true"** . This simple adjustment is all it takes to enable the enhanced
    navigation on your form. If you’ve been developing MVC applications, you can conceptualize
    the enhancement using **Html.BeginForm** when the form is not enhanced and **Ajax.BeginForm**
    with the **Enhance** attribute in place.
  prefs: []
  type: TYPE_NORMAL
- en: Although the **EventManager** component continues to render statically on the
    server, with enhanced navigation activated, Blazor now monitors UI changes more
    effectively. Full-page reload is no longer required when a user submits the form,
    which results in a smoother and more responsive user experience while still leveraging
    the benefits of the SSR.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Enhance** parameter, similar to other parameters of the **EditForm** component,
    has an equivalent attribute compatible with plain HTML forms – **data-enhance**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can attach **data-enhance** to your **<** **form>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We leverage the default HTML **form** element and declare the form’s unique
    name, the method to call on submit, and that Blazor should execute a **post**
    action when submitting the data. Next to those already familiar attributes, we
    attach the **data-enhance** attribute. The order of attributes has no impact on
    the form’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Binding nested models to a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore the management of **nested models** within forms
    in Blazor. Nested models are complex data structures where a model contains other
    models as properties. They’re common when we capture detailed or structured information,
    such as a user profile with multiple addresses or an order with multiple items.
    However, managing forms with complex and nested data models can get out of hand
    as the depth of the data structure grows. Keeping track of each input field and
    ensuring proper binding can be challenging, making the form less maintainable
    and more prone to errors. The **Editor<T>** component simplifies the handling
    of complex object scenarios as it encapsulates the binding of each field to its
    corresponding property, giving you a narrowed view of the current form context.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enhance our event creation form with a nested object, allowing us to add
    information about the event’s duration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start the implementation of a nested form, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter06** / **Recipe03** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **EventManager** component from the *Submitting static forms without
    full page reload* recipe or from the **Chapter06** / **Recipe02** directory of
    the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement a maintainable nested form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **EventDurationForm** component inheriting from **Editor<EventPeriod>**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the markup of the **EventDurationForm** component, utilize the **InputDate**
    component and add two fields for setting the **Start** and **End** properties
    of the base **EventPeriod** model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **EventManager** component, navigate to the **@code** block and extend
    the **Save()** method to log **Model.Period** details to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **EventManager** markup, integrate an instance of the **EventDurationForm**
    component within **EditForm** , between the existing label and the **submit**
    button, and bind it to the **Model.Period** nested property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create the **EventDurationForm** component, dedicated to handling
    the period settings of an event. To properly reference the necessary model, we
    include a **@using** directive for the assembly of the **EventPeriod** model and
    use the **@inherits** directive to derive from the generic **Editor<T>** component,
    setting **T** as our **EventPeriod** model. Next, in *step 2* , we add the markup
    of the **EventDurationForm** component. As the **Editor<T>** component implements
    the **@bind-Value** pattern, we can directly interact with the underlying model
    through the local **Value** property. We embed two date input fields using the
    **InputDate** component, binding them to the **Value.Start** and **Value.End**
    properties. For now, we will skip the built-in form components in Blazor as we
    explore them in a subsequent recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we shift our focus to the **EventManager** component. In the **@code**
    block, we extend the **Save()** placeholder method to log **Model.Period** details
    to the console. It will allow us to validate the binding of our nested model.
    Finally, in *step 4* , we jump to the markup of the **EventManager** component
    and integrate the **EventDurationForm** component into the existing **EditForm**
    markup, right before the submit button. By utilizing the bind-Value pattern, we
    bind the **Model.Period** object directly to **EventDurationForm** .
  prefs: []
  type: TYPE_NORMAL
- en: We’ve effectively encapsulated the markup and logic of managing the event period
    without complexifying the main **EditForm** instance.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout all the recipes exploring the **EditForm** capabilities, we have
    consistently utilized static server rendering. It’s a strategic choice, allowing
    you to highlight any potential edge cases and particularities of the SSR mode
    and providing a comprehensive understanding of how forms behave under different
    rendering conditions.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you choose to employ any of the interactive rendering modes available
    in Blazor, forms will continue to function correctly. By adding the **@renderMode**
    directive to your components, you can easily switch between rendering modes depending
    on the needs of your application. Whether you need server-side rendering for its
    robustness and security or client-side rendering for its interactivity and speed
    — **EditForm** will operate smoothly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing built-in input components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore how quickly you can set up both simple and complex
    forms using Blazor’s native form support and built-in input components. The benefit
    of using Blazor lies in its ability to handle much of the heavy lifting involved
    in form creation, such as data binding, event handling, maintaining state, or
    parsing user input to expected values. You’re then free to focus on other aspects
    of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s showcase Blazor’s built-in input components by creating a comprehensive
    form where the system administrator provides a detailed definition of the events
    they are planning.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we build the event creator, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter06** / **Recipe04** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **EventManager** and **EventDurationForm** components from the *Binding
    nested models to a form* recipe or copy their implementation from the **Chapter06**
    / **Recipe03** directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the event creator with built-in input components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **EventManager** component and, in the **@code** block, update the
    **Save()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to the markup section of the **EventManager** component and locate
    the **EditForm** markup. All subsequent steps will take place within this form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wrap the existing **InputText** instance, **EventDurationForm** instance, and
    the save button in separate paragraph **<** **p>** tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a new paragraph, below the **EventDurationForm** paragraph, add an **InputCheckbox**
    component and bind it to the **Model.IsActive** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another paragraph – this time with an **InputNumber** component – and bind
    it to the **Model.Capacity** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another paragraph and embed the **InputSelect** component within it,
    binding it to the **Model.Type** property. Render the select options using values
    from the **EventType** enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In another paragraph, incorporate an **InputRadioGroup** component and bind
    it to the **Model.Location** property. Use **EventVenues.All** values and an **InputRadio**
    component to render each radio option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a separate paragraph, place an **InputTextArea** component and bind it to
    the **Model.Description** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we enhance the **EventManager** component. In *step 1* , we
    navigate to the **@code** block and update the **Save()** method, where, leveraging
    the **Model.Json** auto-property, we convert the entire **Model** object to JSON
    and write out the result to the console, so we can peek at the state of the saved
    **Model** instance.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we shift to the **EditForm** markup available in the markup of
    the **EventManager** component. In *step 3* , we wrap the existing fields into
    organized paragraphs with **<p>** tags. We use the **InputText** component to
    render a text input element bound to the **Model.Name** property, allowing a user
    to set the name of an event. Next, with the **EventDurationForm** component, we
    encapsulate the setting of the event period, utilizing **InputDate** components
    for date entries. **InputDate** supports a variety of time formats and includes
    a built-in calendar picker – out of the box. We conclude the structurization of
    the form by wrapping the submit button in another set of **<** **p>** tags.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we introduce an **InputCheckbox** component in a new paragraph,
    binding it to the **Model.IsActive** property. **InputCheckbox** renders a checkbox
    input type that’s perfect for handling **bool** properties, so we allow the user
    to toggle the active status of the event.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we add an **InputNumber** component in another paragraph, linking
    it to the **Model.Capacity** property. **InputNumber** accepts any primitive numeric
    type, which makes it ideal for setting the maximum number of event participants.
    In *step 6* , we embed an **InputSelect** component within another paragraph and
    bind it to the **Model.Type** property to facilitate selecting the event type.
    **InputSelect** is a generic component, so you can easily cover a variety of objects
    within. However, remember that the **select** option **value** must be of a primitive
    type. In our form, we populate the drop-down menu by iterating over the **EventType**
    enum from the sample **Data** directory.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we allow the user to choose the event venue. We render an **InputRadioGroup**
    component and bind it to the **Model.Location** property. We also render multiple
    **InputRadio** components, each representing a venue from the **EventVenues.All**
    sample collection. Blazor automatically scopes all **InputRadio** components to
    the nearest parent element but wrapping them inside **InputRadioGroup** exposes
    additional functionalities of the checkbox group and gives us more control.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* , we add an **InputTextArea** component within the final paragraph,
    providing a text area for the **Model.Description** property. **InputTextArea**
    generates an input of type **textarea** – ideal for longer descriptions, although
    it’s not a rich text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form we’ve just built appears simple, but it renders fully functional,
    secured, and organized markup with little coding effort:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Functional, secure, and structured form using only built-in input
    components](img/B22020_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Functional, secure, and structured form using only built-in input
    components'
  prefs: []
  type: TYPE_NORMAL
- en: Handling file uploads with a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we dive into managing file uploads in Blazor applications. File
    uploading is crucial for any modern web application that requires users to upload
    documents or images. The **InputFile** component simplifies the integration of
    file uploads with its simple but comprehensive API. Moreover, with a little additional
    coding, you can enable **drag-and-drop** behavior for file uploads.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a simple form that allows users to upload a file representing an event
    cover.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we implement the form with file uploads, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter06** / **Recipe05** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **FileStorage** from the **Chapter06** / **Data** directory in the GitHub
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to enable file uploads in an interactive form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your application’s **Program** file and add the **FileStorage** service
    to the dependency injection container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an **EventCover** class with a single **File** property of type **IBrowserFile**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new routable **CoverUploader** component that renders in the **InteractiveWebAssembly**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block of **CoverUploader** , inject the **FileStorage** service
    and initialize a **Model** variable of type **EventCover** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a **FileChanged()** method that
    takes the **InputFileChangeEventArgs** parameter and assigns the file data to
    **Model.File** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, in the **@code** block, implement a **SaveAsync()** method that initializes
    a file upload from the **Model** instance, using the **FileStorage** service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **CoverUploader** markup, add an **EditForm** component, bind it to
    the **Model** instance, and attach the **SaveAsync()** method to the **OnSubmit**
    form callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **EditForm** markup, add an **InputFile** component that invokes
    the **FileChanged()** method with its **OnChange** event and a simple submit button.
    Wrap both elements in paragraphs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the application’s **Program** file and register
    the **FileStorage** service into the dependency injection container. **FileStorage**
    is a fake service that pretends to upload a file to the storage of your choice.
    In *step 2* , we create an **EventCover** class with a single **File** property
    of type **IBrowserFile** . The **IBrowserFile** interface represents a file received
    from the user, encapsulating properties such as the file’s name, content type,
    size, and methods to access the file’s content.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we create a routable **CoverUploader** component and set it to
    render in **InteractiveWebAssembly** mode to enable interactivity on our form.
    In *step 4* , within the **@code** block of the **CoverUploader** component, we
    inject the **FileStorage** service to utilize its API for managing incoming files.
    We then initialize a **Model** object of type **EventCover** , which forms the
    backbone of our form. In *step 5* , within the same **@code** block, we implement
    a **FileChanged()** method that handles **InputFileChangeEventArgs** . The **InputFileChangeEventArgs**
    object contains an **IBrowserFile** payload, which we assign to the **File** property
    of our **Model** instance, capturing the user-selected file. In *step 6* , we
    add a **SaveAsync()** method where we read the **File** value into a stream and
    use the **FileStorage.UploadAsync()** method to upload the file bytes to our selected
    storage. We leverage the **using** keyword to ensure efficient resource management
    and no memory leaks. The **using** keyword, inside a method, works together with
    an **IDisposable** object and creates a temporary, disposable scope that automatically
    disposes of the attached object when the method execution completes.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we set up the markup for **CoverUploader** using the **EditForm**
    component. We give the form a unique name, bind it to our **Model** instance,
    and assign the **SaveAsync()** method as the submission fallback. Finally, in
    *step 8* , we build the body of the **EditForm** component. We incorporate the
    **InputFile** component and attach the **FileChanged()** method to its **OnChange**
    callback. The **OnChange** event seamlessly integrates with the **FileChanged()**
    logic in our **@code** block, handling the file selection initiated by the user.
    We also add a simple submit button that activates the form’s **OnSubmit** callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, your form should look similar to mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Form containing the InputFile component and a submit button](img/B22020_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Form containing the InputFile component and a submit button'
  prefs: []
  type: TYPE_NORMAL
- en: What about the drag-and-drop feature? Actually, the **InputFile** component
    inherently supports drag-and-drop functionality! Even though it looks like a button,
    **InputFile** renders an **input** area that has the drag-and-drop feature already
    enabled – you don’t need to add any additional code or any additional attributes.
    You may want to add additional styling to make **InputFile** look like a drop
    zone, but the functionality is available out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we didn’t implement any file type or size validation for the uploading
    (we will explore validation in [*Chapter 7*](B22020_07.xhtml#_idTextAnchor236)
    ). For the enterprise-ready application, you must consider putting such boundaries
    in place to protect your infrastructure as well as server resources.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if you want to support file uploads and leverage the newest SSR render
    mode? In the SSR mode, Blazor pre-renders components on the server and serves
    only a static markup without any interactivity, so you can’t intercept the file
    the user tries to upload. However, if we consider enabling enhanced navigation
    and leveraging the **enctype** attribute, uploading files will work even in the
    SSR mode. The **enctype** HTML attribute specifies how the browser should encode
    the form data when submitting it to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our existing interactive form to render in the SSR mode and still
    allow users to upload a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the **EventCover** class by changing the **File** property type from
    **IBrowserFile** to **IFormFile** . That’s part of the **Microsoft.AspNetCore.Http.Features**
    package, so you may need to add it to your project beforehand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, adjust the **CoverUploader** component to render in SSR mode by removing
    the **@** **renderMode** directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **@code** block of the **CoverUploader** component, transform **Model**
    into a property and decorate it with **SupplyParameterFromForm** to enable automatic
    binding of the form data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, override the **OnInitialized()** lifecycle
    method to adhere to the SSR form binding pattern and remove the **FileChanged()**
    method, as we won’t need it anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **CoverUploader** markup, enhance the **EditForm** component by
    adding the **Enhance** attribute, which activates enhanced navigation, and include
    the **enctype** attribute with the value **multipart/form-data** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, replace the assignment of the **OnChange** callback on the **InputFile**
    component with the **name** HTML attribute and set its value to match the **Model.File**
    property so Blazor knows how to bind the selected file directly from the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Securing a form with an anti-forgery token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore an essential aspect of web security — protecting
    your application from CSRF attacks. CSRF attacks exploit the trust between our
    app and a user’s browser, making the browser perform unwanted actions using the
    user’s identity. An **anti-forgery token** , also known as a CSRF token, is a
    crucial security measure you must use to ensure that the requests sent to a server
    are genuine and originated from a legitimate user, not an attacker. Embedding
    an anti-forgery token in your forms practically creates a unique key sent with
    each post request. The server checks this token upon receiving a request; if the
    token is not present or is incorrect, the request is rejected, thus preventing
    unauthorized actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s secure our event creation form with the anti-forgery token implementation
    offered in Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore securing a form with the anti-forgery token, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter06** / **Recipe06** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to secure your form with the anti-forgery token:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side of your solution, navigate to the **Program** file and,
    in the middleware configuration area, register the anti-forgery middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **EventManager** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block of the **EventManager** component, declare a **Model**
    object of type **Event** and decorate it with the **SupplyParameterFromForm**
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block of **EventManager** , override the **OnInitialized()**
    lifecycle method to conditionally initialize the **Model** instance if it is not
    already set and implement a **Save()** method to simulate the process of saving
    the form data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the markup section of the **EventManager** component, construct a standard
    HTML form with a unique name that triggers the **Save()** method when submitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **<form>** area, include a text input field linked to the **Model.Name**
    property and a submit button. Most crucially, embed an **AntiforgeryToken** component
    within the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **Program** file of the server-side project
    to enable anti-forgery security. We leverage the **app.UseAntiforgery()** extension
    method within the middleware area. The order of middleware registration is crucial;
    you must position the anti-forgery middleware thoughtfully based on other middleware
    in use. If your application includes authentication and authorization, ensure
    **app.UseAntiforgery()** is placed after **app.UseAuthentication()** and **app.UseAuthorization()**
    . If you have routing configured, place anti-forgery middleware after **app.UseRouting()**
    , but before **app.UseEndpoints()** if you register endpoint middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we create a routable **EventManager** component and include the
    necessary assembly reference with the **@using** directive to access the **Event**
    type. In *step 3* , within the **@code** block of the **EventManager** component,
    we declare a **Model** property of type **Event** to support our form. We leverage
    the **SupplyParameterFromForm** attribute to enable an automatic data binding
    between the **Model** and form fields. In *step 4* , we override the **OnInitialized()**
    method to conditionally initialize the **Model** instance if it’s still empty.
    We also implement a **Save()** method as a placeholder to simulate saving changes
    to the form. In *step 5* , we move to the markup of the **EventManager** component.
    We construct a standard HTML form, using **<form>** tags, that triggers the **Save()**
    method upon submission. In Blazor, each form must have a unique name, so we use
    the **@formname** attribute and name ours **event-form** . In *step 6* , we implement
    the form body. First, we embed the **AntiforgeryToken** component. Next, we add
    a text input field for the user to provide the event name and bind it to the **Model.Name**
    property. Finally, we include a **Save** button to enable submitting the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **AntiforgeryToken** component in place, Blazor generates a hidden
    form field containing the anti-forgery token. We’ve embedded the **AntiforgeryToken**
    instance at the top of the form, but as it’s a hidden field, you can place it
    anywhere, as long as it remains part of the form. The token itself is part of
    the DOM, so you can inspect its value using your browser’s development tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Inspecting the anti-forgery token generated as part of the from
    markup](img/B22020_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Inspecting the anti-forgery token generated as part of the from
    markup'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I recommend using the **EditForm** component for all your forms due to its
    native Blazor integration and extensive API. So, why have we not covered adding
    the anti-forgery token to the **EditForm** markup? The reason is straightforward:
    **EditForm** comes with built-in anti-forgery support. Blazor automatically secures
    the **EditForm** instance, saving you the hassle of explicitly handling CSRF protection.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we entirely skipped the implementation of anti-forgery tokens for
    client-side applications. Blazor WebAssembly apps run entirely in the browser
    and do not have a server-side processing pipeline where you would typically configure
    a middleware such as **app.UseAntiforgery()** . If your Blazor WebAssembly app
    interacts with server-side APIs, you should manage anti-forgery at the API level.
    However, if you already use **token-based authentication** to secure communication,
    anti-forgery tokens are generally not necessary. Token-based authentication, by
    its nature, mitigates the risks associated with CSRF, making additional anti-forgery
    tokens redundant. We will explore authentication and authorization further in
    [*Chapter 8*](B22020_08.xhtml#_idTextAnchor273) .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’d like to learn more about token-based authentication, you can check
    this resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication](https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication)'
  prefs: []
  type: TYPE_NORMAL
