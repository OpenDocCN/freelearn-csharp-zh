<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    WPF Fundamentals
                </header>
            
            <article>
                
<p class="chapter-content">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Installing WPF Workload with Visual Studio 2017</li>
<li>Creating WPF applications</li>
<li>Creating and navigating from one window to another</li>
<li>Creating and navigating from one page to another</li>
<li>Creating a dialog box</li>
<li>Creating ownership between windows</li>
<li>Creating a single instance application</li>
<li>Passing arguments to WPF applications</li>
<li>Handling unhandled exceptions</li>
</ul>
<h1 id="uuid-9a03cfeb-b669-47eb-bd17-4bc908b6a2b7">Introduction</h1>
<p class="mce-root">The <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) provides developers with a unified programming model to build dynamic, data-driven desktop applications for Windows. It was first released in 2006 along with .NET 3.0. It is part of the .NET Framework itself.</p>
<p class="mce-root">WPF is a graphical subsystem, for rendering rich <strong>user interfaces</strong> (<span>UIs</span><span>), and is a resolution-independent framework that uses a vector-based rendering engine in the</span> <strong>Extensible Application Markup Language</strong> <span>(</span><strong>XAML</strong><span>) to create stunning user interfaces. It supports a broad set of features that includes application models, controls, layouts, graphics, resources, security, and more.</span></p>
<p class="mce-root">The runtime libraries for it to execute have been included with Windows since Windows Vista and Windows Server 2008. If you are using Windows XP with SP2/SP3 and Windows Server 2003, you can optionally install the necessary libraries.</p>
<p class="mce-root">To begin learning the different recipes of WPF, you should have a clear understanding of the basic foundations. In this chapter, we will start with the architecture and syntaxes, and will guide you in creating a building block.</p>
<h2 id="uuid-14c8e939-4e81-497b-917a-fc3a60f0fc7b">The WPF Architecture</h2>
<p class="mce-root">WPF uses a layered architecture that includes managed, unmanaged, and the core APIs in five different layers called <strong>Presentation Framework</strong>, <strong>Presentation Core</strong>, <strong>Common Language Runtime</strong>, <strong>Media Integration Library</strong>, and <strong>OS Core</strong>. The programming model is exposed through the managed code.</p>
<p class="mce-root">In the following diagram, you can see a clear picture of the architecture:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/79d3ee57-66b2-4bf9-a826-f951c2d85758.png" style=""/></div>
<h3 id="uuid-d1d7b269-2fef-411d-b5a0-54b316500a3e">Presentation Framework</h3>
<p class="mce-root">The <strong>Presentation Framework</strong>, which is part of <kbd>presentationframework.dll</kbd>, provides the basic required components (such as controls, layouts, graphics, media, styles, templates, animations, and more) to start building the UIs of your WPF applications. It is part of the managed layer.</p>
<h3 id="uuid-ac550440-ebc8-461d-8b4d-7abd0620fa11">Presentation Core</h3>
<p class="mce-root">The <strong>Presentation Core</strong> layer, part of <kbd>presentationcore.dll</kbd>, provides you with the wrapper around the <strong>Media Integration Library</strong> (<strong>MIL</strong>). It present you with the public interfaces to access the MIL Core and the Visual System to develop the Visual Tree. It contains visual elements and rendering instructions to build applications for Windows using the XAML tools. This is also part of the managed code.</p>
<h3 id="uuid-c14cc4e8-6457-4abe-997b-6ad7354e4604">Common Language Runtime</h3>
<p class="mce-root"><strong>Common Language Runtime</strong>, commonly known as the <strong>CLR</strong> and part of the managed layer, provides you with several features to build robust applications covering <strong>common type system</strong> (<strong>CTS</strong>), error handling, memory management, and more.</p>
<h3 id="uuid-b43a7a61-ca53-44e8-bfff-62cedd86a869">Media Integration Library</h3>
<p class="mce-root">The <strong>Media Integration Library (MIL)</strong>, which resides in <kbd>milcore.dll</kbd>, is part of the unmanaged layer used to display all graphics rendered through the DirectX engine. It provides you with basic support for 2D and 3D surfaces, and allows you to access the unmanaged components to enable tight integrations with DirectX. It also enables you to gain performance while rendering instructions from the Visual System to the <strong>Common Language Runtime</strong> (<strong>CLR</strong>).</p>
<h3 id="uuid-c2968c37-70b1-4e2d-a5d0-d8c4dd391e88">OS Core</h3>
<p class="mce-root">Just after the MIL, the next layer is the <strong>OS Core</strong>, which provides you with access to the low-level APIs to handle the core components of the operating system. This layer includes Kernel, User32, DirectX, GDI, and device drivers.</p>
<h2 id="uuid-a016cc3e-133e-42a9-8bd8-77419dfc64e6">Types of WPF applications</h2>
<p class="mce-root">Though WPF is mainly used for desktop applications, you can also create web-based applications. Thus, WPF applications can be of two types:</p>
<ul>
<li>Desktop-based executables (EXE)</li>
<li>Web-based applications (XBAP)</li>
</ul>
<p class="mce-root">The desktop applications are the normal <kbd>.exe</kbd> executables, which you normally run on any of your Windows-based systems, whereas the web-based applications are the <kbd>.xbap</kbd> files that can be deployed in web servers and can run inside any supported browser. The .NET Framework is mandatory to run any of these application types.</p>
<p class="mce-root">When you run a WPF application, it starts in two threads. The UI thread uses the <kbd>System.Threading.DispatcherObject</kbd> to create the messaging system and that maintains the UI operations queue. Just like the Win32 message pumping, it performs the UI operation based on the priority set for it.</p>
<p class="mce-root">The other thread is the background thread, which is used to handle the rendering engine being managed by WPF. It picks up a copy of the visual tree and performs actions to show the visual components in the Direct3D surface. Then it calls the UI elements to determine the size and arranges the child elements by their parents.</p>
<h2 id="uuid-7159d251-df58-43ef-80bb-7a02a8dc0a33">The XAML overview</h2>
<p class="mce-root"><strong>XAML</strong> stands for <strong>Extensible Application Markup Language</strong>. It is an XML-based markup language that is used to declaratively create the UI of any XAML-based application, such as <strong>Windows Platform Foundation </strong>(<strong>WPF</strong>), <strong>Universal Windows Platform</strong> (<strong>UWP</strong>), and <strong>Xamarin.Forms</strong>. You can create visible UI elements in a declarative XAML syntax to design the rich UI and then write the code behind to perform a runtime logic.</p>
<div class="packt_infobox">Microsoft recently introduced <strong>XAML Standards</strong>, which is a specification that defines a standard XAML vocabulary, which will allow the supported frameworks to share common XAML-based UI definitions.<br/>
<br/>
You can learn more about this specification by visiting GitHub here:<br/>
<a href="http://aka.ms/xamlstandard"><span class="URLPACKT">http://aka.ms/xamlstandard.</span></a></div>
<p class="mce-root">Though it is not mandatory to use the XAML markup to create a UI, it has been widely accepted as the smart option for the creation of the entire application's UI, as it makes things easier to create. You can create the UI by writing C# or VB.NET code too, but that makes it more difficult and tougher to maintain. Also, that makes it difficult for the designers to work independently.</p>
<p class="mce-root">Designing an application UI using XAML is as easy as writing an XML node with a few optional attributes. Attributes are used to set additional styles, behaviors, and properties. To create a simple button in the UI, you can just write <kbd>&lt;Button /&gt;</kbd> in your XAML file. Similarly, you can just write <kbd>&lt;TextBox /&gt;</kbd> to create a user-input box.</p>
<p class="mce-root">Additionally, you can add more details to the controls. For example, to add a label to a button, use its <kbd>Content</kbd> property, and to set its dimension, use the <kbd>Height</kbd> and <kbd>Width</kbd> property, as shown in the following code:</p>
<pre>    &lt;Button Content="Click Here" /&gt; 
    &lt;Button Height="36" Width="120" /&gt; </pre>
<p class="mce-root">In general, when you add XAML pages to your WPF application project, it compiles along with the project and produces a binary file in what is known as <strong>Binary Application Markup Language</strong> (<strong>BAML</strong>). The final output of the project (that is, the assembly file) contains this BAML file as a resource. When the application loads into the memory, the BAML is then parsed at runtime.</p>
<p class="mce-root">You can also load an XAML into memory and directly render it on the UI. But, in this case, if it has any XAML syntax errors, it will throw those in runtime. If you compare the performance with the first process, the latter is slower, as it renders the entire XAML syntax onto UI.</p>
<p class="mce-root">Here's a flow diagram, that demonstrates the ways to load and render/parse the XAML UI:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e089d867-7137-472b-b1af-a5f5274b31eb.png" style=""/></div>
<h2 id="uuid-6e1d567d-de13-4756-a342-454f09ff92e6">XAML syntax terminologies</h2>
<p class="mce-root">XAML uses some syntax terminologies to define an element in the UI and create the instance of it. Before you start working on it, you must understand the different terminologies that it offers. Let's have a look at a few of them.</p>
<h3 id="uuid-5bbbb08d-e9f9-49f6-93c6-71bea8bc1d1a">Object element syntax</h3>
<p class="mce-root">Each instance of a type is defined using proper XAML syntax to create an object element in the UI. Each of these object elements starts with a left angular bracket (<kbd>&lt;</kbd>) and defines the name of the element. You can optionally prefix the namespace when it is defined outside the default scope. You can use a self-closing angular bracket (<kbd>/&gt;</kbd>) or a right angular bracket (<kbd>&gt;</kbd>) to close the object element definition. If the object element does not have any child elements, the self-closing angular bracket is used. For example, (<kbd>&lt;Button Content="Click Here" /&gt;</kbd>) uses a self-closing angular bracket. If you write the same with a child element, it closes with an end tag (<kbd>&lt;Button&gt;Click Here&lt;/Button&gt;,</kbd>) as shown.</p>
<p class="mce-root">When you define the object element in an XAML page, the instruction to create the instance of the element gets generated and it creates the instance by calling the constructor of the element when you load it in memory.</p>
<h3 id="uuid-46c41f2b-76d9-4904-8cc6-5fde51795afb">Property Attribute syntax</h3>
<p class="mce-root">You can define one or more properties to an element. These are done by writing an attribute called <strong>Property Attribute syntax</strong> to the element. It starts with the name of the property and an assignment operator (<kbd>=</kbd>), followed by the value within quotes. The following example demonstrates how easy it is to define a button element to have a label as its content, and how to set its dimension in UI:</p>
<pre style="padding-left: 30px">&lt;Button Content="Click Here" /&gt; 
&lt;Button Content="Click Here" Width="120" Height="30" /&gt; </pre>
<h3 id="uuid-c1239273-48b7-4cb7-a1de-04b0aea06b25">Property Element syntax</h3>
<p class="mce-root">This is another type of XAML syntax that allows you to define the property as an element. This is often used when you cannot assign the value of the property within quotes. If we take the previous example, the text <kbd>Click Here</kbd> can be assigned to the button content easily. But, when you have another element or a composite property value, you cannot write those within the quotes. For this, XAML introduces <strong>Property Element syntax</strong> to help you to define the property value easily.</p>
<p class="mce-root">It starts with <kbd>&lt;element.PropertyName&gt;</kbd> and ends with <kbd>&lt;/element.PropertyName&gt;</kbd>. The following example demonstrates how to assign a color to a button background with a <kbd>SolidColorBrush</kbd> object:</p>
<pre>    &lt;Button&gt; 
      &lt;Button.Background&gt; 
         &lt;SolidColorBrush Color="Red" /&gt; 
      &lt;/Button.Background&gt; 
    &lt;/Button&gt; </pre>
<h3 id="uuid-0a6f6e3c-a7d3-4853-babd-b6d9e6266dd7">Content syntax</h3>
<p class="mce-root">This is another type of XAML syntax that is used to set the content of a UI element. It can be set as the value of child elements. The following example demonstrates how to set the text content property of a <kbd>Border</kbd> control to hold a <kbd>Button</kbd> control as its <kbd>child</kbd> element:</p>
<pre>    &lt;Border&gt; 
      &lt;Border.Child&gt; 
        &lt;Button Content="Click Here" /&gt; 
      &lt;/Border.Child&gt; 
    &lt;/Border&gt; </pre>
<p class="mce-root">While using <strong>Content syntax</strong>, you should remember the following points:</p>
<ul>
<li>The value of a <kbd>Content</kbd> property must be contiguous</li>
<li>You cannot define an XAML <kbd>Content</kbd> property twice within a single instance</li>
</ul>
<p class="mce-root">Thus, the following is invalid as it will throw XAML error:</p>
<pre>    &lt;Border&gt; 
        &lt;Border.Child&gt; 
            &lt;Button Content="Button One" /&gt; 
        &lt;/Border.Child&gt; 
        &lt;Border.Child&gt; 
            &lt;Button Content="Button Two" /&gt; 
        &lt;/Border.Child&gt; 
    &lt;/Border&gt; </pre>
<h3 id="uuid-6e449a15-4386-42d5-a8e4-484f5b1f630d">Collection syntax</h3>
<p class="mce-root">When you need to define a collection of elements to the parent root, the <strong>Collection syntax</strong> is used to make it easy to read. For example, to add elements inside <kbd>StackPanel</kbd>, we use its <kbd>Children</kbd> property, as shown in the following code:</p>
<pre>    &lt;StackPanel&gt;   <br/>      &lt;StackPanel.Children&gt; 
         &lt;Button Content="Button One" /&gt; 
         &lt;Button Content="Button Two" /&gt; 
      &lt;/StackPanel.Children&gt; 
    &lt;/StackPanel&gt; </pre>
<p class="mce-root">This can be also written as follows, and the parser knows how to create and assign the elements to <kbd>StackPanel</kbd>:</p>
<pre>    &lt;StackPanel&gt; 
      &lt;Button Content="Button One" /&gt; 
      &lt;Button Content="Button Two" /&gt; 
    &lt;/StackPanel&gt; </pre>
<h3 id="uuid-f65ccbda-06fb-4324-9e34-e2ffd490947f">Event Attribute syntax</h3>
<p class="mce-root">When you add a button, you need to associate an event listener to it, to perform some operation. The same is applicable for adding other controls and UI layouts. The XAML allows you to use the <strong>Event Attribute syntax</strong> to define events for a specific XAML object element.</p>
<p class="mce-root">The syntax looks like a property attribute, but it is used to associate the event listener to the element. The following example demonstrates how to assign the click event to a button control:</p>
<pre>    &lt;Button Content="Click Here" Click="OnButtonClicked" /&gt; </pre>
<p class="mce-root">The associated event gets generated from the code behind the XAML page, where you can perform the real action. Here is the code snippet for the event implementation of the preceding button-click event:</p>
<pre>    void OnButtonClicked (object sender, RoutedEventArgs e) 
    { 
        // event implementation 
    } </pre>
<h1 id="uuid-78e8671e-4aab-427d-94fd-ec32a3e04955">Installing WPF Workload with Visual Studio 2017</h1>
<p class="mce-root">As we have learned the basic concepts of WPF Architecture and XAML syntax, we can start to learn different recipes to build applications for Windows using the XAML tools for WPF. But, before that, let's install the required workload/components for <strong>Visual Studio 2017</strong>. If you are using prior versions of Visual Studio, this step will be different.</p>
<h2 id="uuid-949de605-bf98-4c91-ba49-1ca04ef8a60e">Getting ready</h2>
<p class="mce-root">To install the required components for building WPF applications, run the Visual Studio 2017 installer. If you don't have the installer, you can go to <a href="https://www.visualstudio.com/downloads"><span class="URLPACKT">https://www.visualstudio.com/downloads</span></a> and download the correct edition. Let's download the <span class="packt_screen">Visual Studio Community 2017</span> edition as it is a fully featured IDE and available free for students, open source, and individual developers.</p>
<h2 id="uuid-868035ee-1983-47f3-ba0a-82cc8767e88e">How to do it...</h2>
<p class="mce-root">Once you have downloaded the Visual Studio 2017 installer, follow these steps to install the correct workload:</p>
<ol>
<li>Once you have run the installer, it will show you the following screen. Click on <span class="packt_screen">Continue</span>:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/df98e9b4-7568-43ff-9e5d-9ab4b9b34ede.png" style=""/></div>
</li>
<li>Wait for a few minutes to let the installer prepare itself for the installation process. A progress bar will show you the status of the current progress:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/aabbe4d6-cfef-4ad4-a917-a481a46528a6.png" style=""/></div>
</li>
<li>Then the following screen will pop up, where it will ask you to select the <strong>workloads</strong> or <strong>components</strong> that you want to install:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7d567681-2ef1-48f9-b9b0-474a1dc85336.png" style=""/></div>
<ol start="4">
<li>To build WPF applications targeting .NET Framework, select the <span class="packt_screen">.NET desktop development</span> workload, as shown in the preceding screenshot.</li>
<li>Click on the <span class="packt_screen">Install</span> button to continue with the installation.</li>
<li>The following screen will be displayed, showing the status of the installation. It will take some time, based on your internet bandwidth, as it's going to download the required components, based on your selection, from the Microsoft servers and install them one by one:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/72f4e0b5-14ac-450c-bd6e-7b1e85ef1fa9.png" style=""/></div>
<ol start="7">
<li>Once the installation has completed, you may have to restart your system for the changes to take effect. In this case, a popup will appear on the screen, asking you to reboot your PC.</li>
</ol>
<p class="mce-root">Once you have installed the <strong>.NET desktop development component</strong> and restarted your system, you are good to go with building your first WPF application.</p>
<h1 id="uuid-529db87c-6fda-4d61-9965-f38d24823eb3">Creating WPF applications</h1>
<p class="mce-root">The WPF development platform supports a broad set of features that includes UI controls, layouts, resources, graphics, data binding, application model, and more. Before using each of those features, you need to create the WPF project using Visual Studio.</p>
<p class="mce-root">The goal of this recipe is to create a WPF project and learn the basic project structure and components. Let's start building our first WPF application using the <strong>XAML tools</strong>.</p>
<h2 id="uuid-2566eca6-b316-43de-9d15-bf51d44db3b4">Getting ready</h2>
<p class="mce-root">To get started with the WPF application development, you must have Visual Studio running on your system with the required components already installed on it.</p>
<h2 id="uuid-cc6184f0-e192-4802-a0ca-3841f9557b4e">How to do it...</h2>
<p class="mce-root">Follow these steps to create your first WPF application:</p>
<ol>
<li>Inside your Visual Studio IDE, navigate to the <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project...</span> menu as shown in the following screenshot:
<div class="CDPAlignCenter CDPAlign"><img src="assets/a1106eca-997b-4c7c-b6eb-b1697f25d9b6.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign"/>
</li>
<li>This will open the <span class="packt_screen">New Project</span> dialog on the screen. You can alternatively open it by pressing the keyboard shortcut <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">Shift</span></em> + <em><span class="KeyPACKT">N</span></em>.</li>
<li>In the <span class="packt_screen">New Project</span> dialog, navigate to <span class="packt_screen">Installed</span> | <span class="packt_screen">Templates</span> | <span class="packt_screen">Visual C#</span> | <span class="packt_screen">Windows Classic Desktop</span>, as shown in the left-hand side of the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2064791d-46e8-4210-a9ad-8a325e3ca000.png"/></div>
<ol start="4">
<li>In the right-hand side panel, first select the <span class="packt_screen">.NET Framework</span> that you want your application to target. We have selected <span class="packt_screen">.NET Framework 4.7</span> here.</li>
<li>Then select <span class="packt_screen">WPF App (.NET Framework)</span>, from the available list of templates.</li>
<li>Give a name (in our case, it is <kbd>CH01.HelloWPFDemo</kbd>) to the project.</li>
<li>Optionally, select the location of the project, where you want to create it.</li>
<li>Optionally, you can also provide a different name for the <span class="packt_screen">Solution</span>.</li>
<li>When you are ready, click on the <span class="packt_screen">OK</span> button to let Visual Studio create the project based on the template that you have selected.</li>
</ol>
<p class="mce-root">Once the project has been created, Visual Studio will open the <span class="packt_screen">Solution Explorer</span>, which lists the project with all the default files created on it. The project structure will look like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a9daf5cb-7bf7-41cb-adfd-3775cd1def9a.png" style=""/></div>
<h2 id="uuid-dcf899e8-11e0-4664-a4cd-51a3487a019e">There's more...</h2>
<p class="mce-root">Each WPF application project created by Visual Studio using the default template consists of the following files:</p>
<ul>
<li><kbd>App.config</kbd>: This is the configuration file of your WPF application. By default, it contains the following lines that describe the supported runtime version for the application to run. This contains exactly the same runtime version that we selected during the project creation:</li>
</ul>
<pre style="padding-left: 60px">    &lt;?xml version="1.0" encoding="utf-8" ?&gt; 
      &lt;configuration&gt; 
        &lt;startup&gt;  
          &lt;supportedRuntime            <br/>           version="v4.0"sku=".NETFramework,Version=v4.7" /&gt; 
        &lt;/startup&gt; 
      &lt;/configuration&gt; </pre>
<p style="padding-left: 60px">The <kbd>config</kbd> file can also contain application settings and other configuration settings that you want to use/refer in your application.</p>
<ul>
<li><kbd>App.xaml</kbd>: Visual Studio automatically creates the <kbd>App.xaml</kbd> file when you create a WPF project. It is the declarative starting point of your application. The root element of this file is the <kbd>Application</kbd> instance, which defines application specific properties and events:</li>
</ul>
<pre style="padding-left: 60px">    &lt;Application x:Class="CH01.HelloWPFDemo.App" 
               <br/>       
       
       
      StartupUri="MainWindow.xaml"&gt; 
  <br/>    &lt;Application.Resources&gt; 
          
    &lt;/Application.Resources&gt; 
    &lt;/Application&gt; </pre>
<p style="padding-left: 60px">The instance of the <kbd>Application</kbd> class defines the <kbd>Window</kbd> or a <kbd>Page</kbd> that's going to be the startup UI, and is registered with the <kbd>StartupUri</kbd> property. In the preceding code, (<kbd>StartupUri="MainWindow.xaml"</kbd>) states that the <kbd>MainWindow.xaml</kbd> page will get loaded, once you run the application.</p>
<p style="padding-left: 60px">The application instance can also hold global/application-level resources (such as, <span class="packt_screen">Style</span>, <span class="packt_screen">Template</span>, and <span class="packt_screen">Converter</span>) that can be used globally throughout the application.</p>
<ul>
<li><kbd>App.xaml.cs</kbd>: This is the code-behind class file of the <kbd>App.xaml</kbd> and extends the <kbd>Application</kbd> class of the framework to write application-specific code. You can use this file to subscribe to the events such as <kbd>Startup</kbd>, <kbd>UnhandledException</kbd> to perform common operations:</li>
</ul>
<pre style="padding-left: 90px">namespace CH01.HelloWPFDemo 
{ 
    /// &lt;summary&gt; 
    /// Interaction logic for App.xaml 
    /// &lt;/summary&gt; 
    public partial class App : Application 
    { 
    } 
} </pre>
<p style="padding-left: 60px">This class is often used to manipulate command-line parameters and load different XAML pages based on that.</p>
<ul>
<li><kbd>MainWindow.xaml</kbd>: This is the default UI page that Visual Studio generates on creation of the WPF project. It is the page that gets registered as the <kbd>StartupUri</kbd> in <kbd>App.xaml</kbd>. The root element of this page is <kbd>Window</kbd> and it contains a <kbd>Grid</kbd> layout by default. Here is the default code snippet:</li>
</ul>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.HelloWPFDemo.MainWindow" 
  xmlns=<br/>   "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
    
   Title="MainWindow" Height="350" Width="525"&gt; 
  &lt;Grid&gt; 
         
  &lt;/Grid&gt; 
&lt;/Window&gt; </pre>
<p style="padding-left: 60px">The <kbd>x:Class</kbd> attribute defines the associated partial class where the UI logic is being written. You can modify this XAML to provide a fresh look to your application start page. Various UI controls and layouts are going to be covered in the later chapters of this book.</p>
<ul>
<li><kbd>MainWindow.xaml.cs</kbd>: This is the code-behind class of <kbd>MainWindow.xaml</kbd> and contains the logic related to UI operations. In general, developers write implementations of various UI operations in this class.</li>
</ul>
<p class="mce-root">Whenever you add any UI elements to an XAML page, the control gets registered internally in a partial class file that has <kbd>.g.i.cs</kbd> as the extension. For example, if you add a control in the <kbd>MainWindow.xaml</kbd> file, it gets registered in the <kbd>MainWindow.g.i.cs</kbd> residing in the <kbd>obj</kbd> folder. If you open the file, you can observe the entire loading process inside the <kbd>InitializeComponent()</kbd> method.</p>
<h1 id="uuid-2f1dde50-1e90-4c7e-bc47-9841d521d692">Creating and navigating from one window to another</h1>
<p class="mce-root">In WPF standalone applications, a window is used to host the UI elements to enable users to interact with the UI and data. The base class <kbd>Window</kbd> provides all the APIs to create and interact with the Window UI.</p>
<p class="mce-root">In WPF applications, the generic window layout is divided into multiple parts. Here is a screenshot of a basic window, containing its various parts:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78804e0a-8aa1-4b2d-b929-32561fbe99b3.png" style=""/></div>
<p class="mce-root">The various parts of the window are as mentioned here:</p>
<ul>
<li>The outer part of the window is a <strong>Border</strong>, which you can utilize to enable the resizing option:
<ul>
<li>The outer border can contain a <strong>resizing grip</strong>, which enables you to resize the window diagonally</li>
</ul>
</li>
<li>The window contains a <strong>Title bar</strong> at the top, which consists of the following parts:
<ul>
<li>An <strong>Icon</strong> to provide a unique brand to your application window</li>
<li>A <strong>Title</strong>, showing the identifiable name of the window</li>
<li>A small panel, containing <span class="packt_screen">Minimize</span>, <span class="packt_screen">Maximis</span><span class="packt_screen">e</span>/<span class="packt_screen">Restore</span>, and <span class="packt_screen">Close</span> buttons</li>
<li>A <strong>System menu</strong> with menu items to allow users to perform <span class="packt_screen">Minimize</span>, <span class="packt_screen">Maximize</span>/ <span class="packt_screen">Restore</span>, <span class="packt_screen">Mov</span>e, <span class="packt_screen">Size</span>, and <span class="packt_screen">Close</span> operations on the window</li>
</ul>
</li>
<li>A <strong>client area</strong> for the developers to add application/window specific layouts and controls</li>
</ul>
<h2 id="uuid-6b03b640-2619-4493-a89d-61f1b61f772e">Getting ready</h2>
<p>To get started with this recipe, open your Visual Studio instance and create a WPF project called <kbd>CH01.WindowDemo</kbd> based on the <span class="packt_screen">WPF App (.NET Framework)</span> template. Once the project has been created, it will have files called <kbd>MainWindow.xaml</kbd> and <kbd>MainWindow.xaml.cs</kbd>, along with the other default files.</p>
<p>Let's get started with creating a new window in the same project and invoke a button to open the new window from the <kbd>MainWindow</kbd>.</p>
<h2 id="uuid-63afadda-5b7d-4bd6-830f-e09b1574987e">How to do it...</h2>
<p class="mce-root">To create a new window, follow these simple steps:</p>
<ol>
<li>Open the <span class="packt_screen">Solution Explorer</span> and right-click on the project node.</li>
<li>From the right-click context menu, navigate to <span class="packt_screen">Add</span> | <span class="packt_screen">Window...</span> as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1edc768d-36bf-49fe-9967-818a9965c09c.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign"/>
<ol start="3">
<li class="mce-root"><span>The following</span> <span>Add New Item</span> <span>dialog will appear on the screen:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/129ef68e-7943-4432-aa94-0f3555af8073.png"/></div>
<ol start="4">
<li>Make sure that the selected template is <span class="packt_screen">Window (WPF)</span>. Give it a name, <kbd>SecondWindow.xaml</kbd>, and click the <span class="packt_screen">Add</span> button.</li>
<li>This will create the <kbd>SecondWindow.xaml</kbd> file and its associated code-behind file <kbd>SecondWindow.xaml.cs</kbd> in the project directory.</li>
<li>Open the XAML file (<kbd>SecondWindow.xaml</kbd>) and replace the entire contents with the following XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.WindowDemo.SecondWindow" 
  xmlns=<br/>    "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
     
    Title="Second Window" Height="200" Width="300"&gt; 
    &lt;Grid&gt; 
        &lt;TextBlock Text="<a>Second Window Instance</a>" 
                   HorizontalAlignment="Center" 
                   VerticalAlignment="Center" 
                   FontSize="16"/&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt;</pre>
<ol start="7">
<li>Now open the <kbd>MainWindow.xaml</kbd> file to add a button into it. Replace the entire <kbd>&lt;Grid&gt; &lt;/Grid&gt;</kbd> block, with the following XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Button Content="<a>Open Second Window</a>" 
            Height="30" Width="150" 
            Click="OnSecondWindowButtonClicked"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="8">
<li>Now we need to add the implementation for the button-click event. Simply open the <kbd>MainWindow.xaml.cs</kbd> file and add the following lines of code inside the class definition:</li>
</ol>
<pre style="padding-left: 90px">private void OnSecondWindowButtonClicked(object sender,  
RoutedEventArgs e) 
{ 
    var window = new SecondWindow(); 
    window.Show(); 
} </pre>
<ol start="9">
<li>Now, when you run the application, you will see that the <span class="packt_screen">MainWindow</span> opens on the screen, containing a button labeled <span class="packt_screen">Open Second Window</span>. Clicking on this button opens the second window on the screen that has text content of <span class="packt_screen">Second Window Instance</span>. Here's the screenshot for your reference:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0b21988b-467a-4790-b633-95d1ed00471b.png" style=""/></div>
</li>
</ol>
<div class="packt_tip">Please note that if you click the button again, it will create another instance of the second window because it's modeless.</div>
<h2 id="uuid-df73af95-e8e9-409c-b59c-027672faa87d">How it works...</h2>
<p class="mce-root">When you create the instance of the <kbd>Window</kbd> class, it will not become visible to the user. It only becomes visible when you call the <kbd>Show()</kbd> method, which returns the handle to the originated caller without waiting for the window to close.</p>
<p class="mce-root">When you call the <kbd>Show()</kbd> method, it basically creates a modeless window, and hence you can interact with other windows within the same application when the same is already open. The <kbd>Window</kbd> class also exposes a method called <kbd>ShowDialog()</kbd>, which creates a model window and prevent users from interacting with other windows of the application. We will discuss the more later in this chapter, in the <em><span class="ChapterrefPACKT">Creating a dialog box</span></em> <span class="ChapterrefPACKT">section.</span></p>
<h2 id="uuid-a3e75316-77cb-490e-a89e-adae911d7f69">There's more...</h2>
<p class="mce-root">The <kbd>Window</kbd> class provides you with a bunch of properties, methods, and events to customize the look of the window, and perform specific operations or to be notified of the current context. To ask the client area to support transparency, set the <kbd>AllowsTransparency</kbd> property of the window to <kbd>true</kbd>. This is often useful when you want to create a custom-shaped window or a skinned theme.</p>
<p class="mce-root">You can change the default icon of the window by setting the <kbd>Icon</kbd> property and enable/disable the window resizing by setting the <kbd>ResizeMode</kbd> property. You can also set the window title, startup location, window state, window style, and taskbar visibility by settings the <kbd>Title</kbd>, <kbd>WindowStartupLocation</kbd>, <kbd>WindowState</kbd>, <kbd>WindowStyle</kbd>, and <kbd>ShowInTaskbar</kbd> properties, respectively.</p>
<p class="mce-root">Not only these but you can bring the window to the foreground by calling its <kbd>Activate()</kbd> method and close the window by calling the <kbd>Close()</kbd> method available in the <kbd>Window</kbd> class. Sometimes, when you want to hide the window instead of quitting it completely, you can utilize the <kbd>Hide()</kbd> method to make the window hidden and bring it back again by calling the <kbd>Show()</kbd> method on the same instance.</p>
<p class="mce-root">The class also exposes some events to notify you of the current contextual information. You can use the <kbd>Activated</kbd>, <kbd>Deactivated</kbd>, <kbd>Closing</kbd>, <kbd>Closed</kbd>, and <kbd>StateChanged</kbd>, events in your code to get such notifications.</p>
<h1 id="uuid-93d0d48b-ee97-4927-ab48-78f25950b33b">Creating and navigating from one page to another</h1>
<p class="mce-root">The WPF application supports a browser style navigation mechanism, which can be used in both standalone applications as well as in XBAP applications. To implement it, WPF provides the <kbd>Page</kbd> class to encapsulate the <kbd>Page</kbd> content that can be navigated to and hosted by the browser, a <kbd>NavigationWindow</kbd> and/or a <kbd>Frame</kbd>.</p>
<h2 id="uuid-ee747f3e-7841-435d-bd6a-a485d5079184">Getting ready</h2>
<p class="mce-root">To get started with this recipe to build an application that supports navigations mechanisms from one WPF page to another, open the Visual Studio IDE and create a project based on the <span class="packt_screen">WPF App (.NET Framework)</span> template. Give it a name (in our case, it's <kbd>CH01.PageDemo</kbd>).</p>
<h2 id="uuid-50387bd7-64fb-4aad-b91c-89d6e54f5b96">How to do it...</h2>
<p class="mce-root">Once you have created your project based on the <span class="packt_screen">WPF App (.NET Framework)</span> template, follow these steps to add pages to your project and integrate them with the <kbd>NavigationService</kbd>:</p>
<ol>
<li>Right-click on the project node where you want to create the pages.</li>
</ol>
<p> </p>
<ol start="2">
<li>As shown in this screenshot, navigate to <span class="packt_screen">Add</span> | <span class="packt_screen">Page...</span> from the context menu:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7ccaf015-ab4e-4c0c-9afa-572ee435ff62.png"/></div>
</li>
<li>This will open the following <span class="packt_screen">Add New Item</span> dialog window, where the item titled <span class="packt_screen">Page (WPF)</span> is already selected. Give it a name, <kbd>Page1.xaml</kbd> and click <span class="packt_screen">Add</span>. It will create the <kbd>Page1.xaml</kbd> and the associated code-behind file <kbd>Page1.xaml.cs</kbd> in your project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3a6477c0-0641-4e4b-9095-c52b1df97720.png"/></div>
<ol start="4">
<li>Now follow the same steps, 1 to 3, to create another page <kbd>Page2.xaml</kbd>, which will add both the XAML and associated C# code-behind file into the project.</li>
<li>Open the <kbd>Page1.xaml</kbd> file and replace the <kbd>Grid</kbd> with the following XAML:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;TextBlock Text="This is Page 1" FontSize="20" 
               HorizontalAlignment="Center"       
               VerticalAlignment="Center"/&gt; 
    &lt;Button Content="Next" Height="30" Width="120"  
            Margin="20" 
            HorizontalAlignment="Right"  
            VerticalAlignment="Bottom" 
            Click="OnNextButtonClicked"/&gt; 
&lt;/Grid&gt;</pre>
<ol start="6">
<li>In the associated code-behind file (<kbd>Page1.xaml.cs</kbd>), add the following button-click event handler:</li>
</ol>
<pre style="padding-left: 90px">private void OnNextButtonClicked(object sender,<br/> RoutedEventArgs e) 
{ 
  NavigationService.Navigate(new Uri("Page2.xaml", <br/>   UriKind.Relative)); 
} </pre>
<ol start="7">
<li>Similarly, add the following XAML into the <kbd>Page2.xaml</kbd> page, replacing the existing <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;TextBlock Text="This is Page 2" FontSize="20" 
               HorizontalAlignment="Center"  
               VerticalAlignment="Center"/&gt; 
    &lt;Button Content="Previous" Height="30" Width="120"  
            Margin="20" 
            HorizontalAlignment="Right"  
            VerticalAlignment="Bottom" 
            Click="OnPreviousButtonClicked"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="8">
<li>Add the following button-click event handler into the <kbd>Page2.xaml.cs</kbd> file:</li>
</ol>
<pre style="padding-left: 90px">private void OnPreviousButtonClicked(object sender, RoutedEventArgs e) 
{ 
    if (NavigationService.CanGoBack) 
    { 
        NavigationService.GoBack(); 
    } 
} </pre>
<ol start="9">
<li>Now open the <kbd>MainWindow.xaml</kbd> file and replace the XAML content with the following:</li>
</ol>
<pre style="padding-left: 90px">&lt;NavigationWindow x:Class="CH01.PageDemo.MainWindow" 
  xmlns=<br/>   "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
     
    Title="MainWindow" Height="350" Width="525" 
    Source="Page1.xaml"&gt; 
 
&lt;/NavigationWindow&gt;</pre>
<ol start="10">
<li>Now open the <kbd>MainWindow.xaml.cs</kbd> file and change its base class to <kbd>NavigationWindow</kbd>, instead of <kbd>Window</kbd>.</li>
<li>Run the application, which will open the following screen containing <span class="packt_screen">Page 1</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/04c79e6b-840a-4609-a733-20da461b8e87.png" style=""/></div>
<ol start="12">
<li>Clicking on the <span class="packt_screen">Next</span> button will navigate you to <span class="packt_screen">Page 2</span>, as shown here, which contains the activated navigational button automatically provided by the WPF Framework:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eef15e0f-7da4-4351-887f-fb4bbcfa1ef1.png" style=""/></div>
<ol start="13">
<li>Now, if you click on the <span class="packt_screen">Previous</span> button or the <span class="packt_screen">back</span> button in the navigation panel, it will navigate you to <span class="packt_screen">Page 1</span>.</li>
</ol>
<h2 id="uuid-bc03912c-8c6d-474f-bd94-8e000a0648ab">How it works...</h2>
<p class="mce-root">The <kbd>NavigationWindow</kbd>, which is defined in the <kbd>MainWindow.xaml</kbd> page, provides the basic mechanism to support the content navigation. The <kbd>Source</kbd> attribute (<kbd>Source="Page1.xaml"</kbd>), defined as <kbd>URI</kbd>, asks <kbd>NavigationWindow</kbd> to load the mentioned page (<kbd>Page1.xaml</kbd>) by default.</p>
<p class="mce-root">When you click on the <span class="packt_screen">Next</span> button of <kbd>Page1</kbd>, the <kbd>NavigationService.Navigate</kbd> method executes, passing the <kbd>URI</kbd> of the page that you want to load next. The navigation buttons automatically activate based on the history of the navigation that you performed.</p>
<p class="mce-root">In <kbd>Page2</kbd>, when you click on the <span class="packt_screen">Previous</span> button, it first checks whether the <kbd>NavigationService</kbd> has an immediate history item to navigate you to a previous page. If it finds a previous page, it then automatically navigates you to the desired page by calling the <kbd>NavigationService.GoBack()</kbd> method call. In this case, you don't have to pass the <kbd>URI</kbd> of the page.</p>
<h2 id="uuid-657a7b6b-0514-48e3-b998-b0a362c29ec8">There's more...</h2>
<p class="mce-root"><kbd>NavigationService</kbd> offers a variety of properties, methods, and events to perform navigation mechanisms on your page content. <kbd>CanGoBack()</kbd> and <kbd>CanGoForward()</kbd> return a <kbd>Boolean</kbd> value indicating whether there is at least one entry in the back and forward navigation history, respectively. The method <kbd>GoBack()</kbd> navigates you to the most recent entry from back navigation history, whereas the <kbd>GoForward()</kbd> method navigates you to the forward navigation history, if there's one available.</p>
<p class="mce-root">To refresh the current content, you can call the <kbd>Refresh()</kbd> method. The <kbd>StopLoading()</kbd> method stops the current execution from downloading/loading the content part of the current navigation context. You can also programmatically add or remove an entry from the navigation history. The <kbd>AddBackEntry</kbd> method takes a parameter for the <kbd>CustomContentState</kbd> object to add the entry into the back-navigation history. The <kbd>RemoveBackEntry()</kbd> method removes the most recent entry from the back-navigation history.</p>
<p class="mce-root">Events such as <kbd>Navigating</kbd>, <kbd>Navigated</kbd>, <kbd>NavigationFailed</kbd>, <kbd>NavigationStopped</kbd>, <kbd>NavigationProgress</kbd>, and <kbd>LoadCompleted</kbd> are there to notify you of the various statuses of the current navigation process. Use them wisely, based on your requirements.</p>
<h1 id="uuid-e2a0a8df-b39f-44c1-8a44-a3087b6b8aaa">Creating a dialog box</h1>
<p class="mce-root">A dialog box is also a kind of window, and is generally used to get some inputs from the user or to show a message to the user. It uses a model window to prevent users from interacting with other windows of the same application when it is already open. In this recipe, we will learn how to create a model dialog and use the common dialog boxes that the framework provides.</p>
<h2 id="uuid-aba8bf7f-0e93-4a5f-b24e-ff0d0e229e67">Getting ready</h2>
<p class="mce-root">To get started with building and using dialog boxes in a WPF application, open your Visual Studio IDE and create a new WPF project, calling it <kbd>CH01.DialogBoxDemo</kbd>.</p>
<h2 id="uuid-3b3f8b01-7a4e-4464-bf24-f302493e6649">How to do it...</h2>
<p class="mce-root">Follow these steps to create the dialog window and invoke it from the <kbd>MainWindow</kbd> to show a message to the user:</p>
<ol>
<li>Open the <span class="packt_screen">Solution Explorer</span> and right-click on the project node.</li>
<li>From the context menu, select <span class="packt_screen">Add</span> | <span class="packt_screen">Window...</span> to open the <span class="packt_screen">Add New Item</span> dialog.</li>
<li>Making sure that the <span class="packt_screen">Window (WPF)</span> template is selected, give it the name <kbd>MessageDialog</kbd>, and click <span class="packt_screen">Add</span> to continue. This will create <kbd>MessageDialog.xaml</kbd> and <kbd>MessageDialog.xaml.cs</kbd> files in the project.</li>
<li>Open the <kbd>MessageDialog.xaml</kbd> file and replace the entire XAML content with the following:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.DialogBoxDemo.MessageDialog" 
 xmlns=<br/>   "http://schemas.microsoft.com/winfx/2006/xaml/presentation"<br/>     
    ShowInTaskbar="False" WindowStyle="SingleBorderWindow" 
    Title="Message" Height="150" Width="400"  
    FontSize="14" Topmost="True" ResizeMode="NoResize"&gt; 
   <br/>    &lt;Grid&gt; 
       &lt;TextBlock TextWrapping="Wrap" Margin="8" 
        Text="Thank you for reading 'Windows Presentation <br/>        Foundation Cookbook'. Click 'OK' to continue next."/&gt; 
        &lt;StackPanel Orientation="Horizontal" 
                    VerticalAlignment="Bottom"  
                    HorizontalAlignment="Right" 
                    Margin="4"&gt; 
            &lt;Button Content="OK" Width="60" Height="30" 
                    Margin="4" IsDefault="True"  
                    Click="OnOKClicked"/&gt; 
            &lt;Button Content="Cancel" Width="60" Height="30" 
                    Margin="4" IsCancel="True"  
                    Click="OnCancelClicked"/&gt; 
        &lt;/StackPanel&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt;</pre>
<ol start="5">
<li>Open the <kbd>MessageDialog.xaml.cs</kbd> file, and add the following event implementations for the <span class="packt_screen">OK</span> button and <span class="packt_screen">Cancel</span> button:</li>
</ol>
<pre style="padding-left: 90px">private void OnOKClicked(object sender, RoutedEventArgs e) 
{ 
    DialogResult = true; 
} 
 
private void OnCancelClicked(object sender, RoutedEventArgs e) 
{ 
    DialogResult = false; 
} </pre>
<ol start="6">
<li>Now open the <kbd>MainWindow.xaml</kbd> page and replace the <kbd>Grid</kbd> with the following XAML content:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;ListBox x:Name="result" Height="100" Margin="8" 
             HorizontalAlignment="Stretch"  
             VerticalAlignment="Top" /&gt; 
    &lt;Button Content="Show Message" Width="150" Height="30"  
            VerticalAlignment="Bottom" Margin="8" 
            Click="OnShowMessageButtonClicked"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="7">
<li>Go to the code-behind file, <kbd>MainWindow.xaml.cs</kbd>, and add the button event implementation as shared in the following code section:</li>
</ol>
<pre style="padding-left: 90px">private void OnShowMessageButtonClicked(object sender, RoutedEventArgs e) 
{ 
    var messageDialog = new MessageDialog(); 
    var dialogResult = messageDialog.ShowDialog(); 
 
    if (dialogResult == true) 
    { 
        result.Items.Add("You clicked 'OK' button."); 
    } 
    else if (dialogResult == false) 
    { 
        result.Items.Add("You clicked 'Cancel' button."); 
    } 
}</pre>
<ol start="8">
<li>Now run the application. The visible window will have a button labeled <span class="packt_screen">Show Message</span>. Click on it to invoke the message dialog window that we have created:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb4d328a-8a14-47ba-9975-c8609110c90e.png" style=""/></div>
<ol start="9">
<li>Click on the <span class="packt_screen">Cancel</span> button, which will add <span class="packt_screen">You clicked 'Cancel' button</span> text into the list present in the <span class="packt_screen">MainWindow</span>.</li>
<li>Launch the message window again and click on the <span class="packt_screen">OK</span> button. This will add <span class="packt_screen">You clicked 'OK' button</span> in the list.</li>
</ol>
<h2 id="uuid-90d659e7-d325-464a-8d9d-3995faf0331b">How it works...</h2>
<p class="mce-root">When you call the <kbd>ShowDialog()</kbd> method of the <kbd>Window</kbd> instance, it opens it as a model dialog and waits until the user provides an input to it. In this case, the user input is the interaction with the <span class="packt_screen">OK</span> and <span class="packt_screen">Cancel</span> button. When you click the <span class="packt_screen">OK</span> button, the associated event handler assigns <kbd>true</kbd> to the <kbd>DialogResult</kbd> property and returns to the caller. Similarly, the <span class="packt_screen">Cancel</span> button event handler, assigns <kbd>false</kbd> to the <kbd>DialogResult</kbd> property and returns.</p>
<p class="mce-root">Based on the return value of the <kbd>ShowDialog()</kbd> method, which actually returns the value of <kbd>DialogResult</kbd>, you can decide whether the user clicked the <span class="packt_screen">OK</span> or <span class="packt_screen">Cancel</span> button.</p>
<p class="mce-root">The dialog window has been customized by setting the following properties to the <kbd>Window</kbd> instance:</p>
<ul>
<li>The <kbd>ShowInTaskbar</kbd> property has been set to <kbd>False</kbd> to prevent the window from being visible in the Taskbar.</li>
<li>The <kbd>WindowStyle</kbd> property has been set to <kbd>SingleBorderWindow</kbd> to add a thin border to the window, removing the minimize and maximize buttons from the title bar.</li>
<li>The <kbd>Topmost</kbd> property has been set to <kbd>True</kbd> to keep it always visible on top of other windows. This is optional, but good to have.</li>
<li>The <kbd>ResizeMode</kbd> property has been set to <kbd>NoResize</kbd> to prevent the user from resizing the dialog window.</li>
</ul>
<h2 id="uuid-9f19fbf7-436b-41bf-8c6a-97778f8f4e19">There's more...</h2>
<p class="mce-root">The operating system provides some reusable dialog boxes, which provide a user experience consistent with the version of the operating system in which the application is running. The experience also stays consistent across all applications to provide a unique interface for performing common operations such as opening files, saving files, printing files, color selection, and more.</p>
<p class="mce-root">WPF provides these reusable, common dialog boxes as managed wrapper classes, encapsulating the core implementation. This reduces the extra effort creating and managing the common operations.</p>
<h3 id="uuid-2863f102-e6d0-4ed0-b86a-f87dc61d70d1">Using the open file dialog</h3>
<p class="mce-root">To open files in your WPF application, you can use the managed wrapper class <kbd>OpenFileDialog</kbd>, which is present under the <kbd>Microsoft.Win32</kbd> namespace. You just have to create the instance and call the <kbd>ShowDialog()</kbd> method by optionally setting a few properties for UI customization.</p>
<p class="mce-root">A basic open file dialog looks like the following screenshot, providing you with an option to select one or more files to open:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0bf6052c-16a3-499a-a562-ce0bde65f88c.png" style=""/></div>
<p class="mce-root">The following code snippet demonstrates how to initiate the open file dialog by optionally filling the file-extension filter:</p>
<pre style="padding-left: 30px">private void OnOpenButtonClicked(object sender, RoutedEventArgs e) 
{ 
    var openfileDialog = new OpenFileDialog 
    { 
        Filter = "Text documents (.txt) | *.txt | Log files (.log) | <br/>        *.log" 
    }; 
 
    var dialogResult = openfileDialog.ShowDialog(); 
    if (dialogResult == true) 
    { 
        var fileName = openfileDialog.FileName; 
    } 
} </pre>
<p class="mce-root">The <kbd>dialogResult</kbd> returned by the <kbd>ShowDialog()</kbd> method tells us whether the operation was performed successfully. Based on that, you can call the instance of the file dialog to get more details about the selected file.</p>
<h3 id="uuid-8629566d-4628-40ad-bb8c-260323b8d288">Using the save file dialog</h3>
<p class="mce-root">Along with the <kbd>OpenFileDialog</kbd> interface, the <kbd>Microsoft.Win32</kbd> namespace also provides the <kbd>SaveFileDialog</kbd> managed wrapper to perform file saving operations from your WPF application. Similar to the open file dialog, you need to create the instance of it by optionally filling its various properties to finally call the <kbd>ShowDialog()</kbd> method.</p>
<p class="mce-root">The save file dialog looks like the following screenshot, where you can provide a name to save as a file:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/590ebada-3593-4c26-b9d0-5c4bfbbb352f.png" style=""/></div>
<p class="mce-root">Optionally, you can set the extension filter, default file name, and other properties before launching the dialog window, as shown in the following code snippet:</p>
<pre style="padding-left: 60px">private void OnSaveButtonClicked(object sender, RoutedEventArgs e) 
{ 
    var saveFileDialog = new SaveFileDialog 
    { 
        Filter = "Text documents (.txt) | *.txt | Log files (.log) |<br/>         *.log" 
    }; 
 
    var dialogResult = saveFileDialog.ShowDialog(); 
    if (dialogResult == true) 
    { 
        var fileName = saveFileDialog.FileName; 
    } 
} </pre>
<p class="mce-root">Based on the <kbd>dialogResult</kbd> returned by the <kbd>ShowDialog()</kbd> call you can decide whether the save was successful and retrieve more information about the saved file from the file dialog instance.</p>
<h3 id="uuid-9c57acd2-868f-409f-af72-9cfa6a3edce2">Using the print dialog</h3>
<p class="mce-root">The managed wrapper <kbd>PrintDialog</kbd> is also present in the <kbd>Microsoft.Win32</kbd> namespace, and provides you with the interface to call the operating system's printer properties and perform the <kbd>print</kbd> operation. The dialog gives you the option to <span class="packt_screen">Select Printer</span>, configure the printing preferences, and select the page range and other parameters, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ae68185b-389b-473c-ab48-eb8688efdd55.png" style=""/></div>
<p class="mce-root">To invoke the same, just create the instance of the <kbd>PrintDialog</kbd> and call its <kbd>ShowDialog()</kbd> method. You can optionally set page range, printable area, and other properties. If the <kbd>dialogResult</kbd> returned by the <kbd>ShowDialog()</kbd> method is set to <kbd>true</kbd>, it confirms that the printing job has been queued up successfully, and based on that you can perform the next set of actions.</p>
<p class="mce-root">Here's the code snippet for your reference:</p>
<pre style="padding-left: 30px">private void OnPrintButtonClicked(object sender, RoutedEventArgs e) 
{ 
    var printDialog = new PrintDialog(); 
    var dialogResult = printDialog.ShowDialog(); 
 
    if (dialogResult == true) 
    { 
        // perform the print operation 
    } 
} </pre>
<h3 id="uuid-22b87214-f929-4534-9ed9-bf1ea8492ce0">Other common dialogs</h3>
<p class="mce-root">WPF also provides some other common dialog boxes to perform the selection of various formatting options, such as font, font style, font size, text effects, and color. You can use the <kbd>FontDialog</kbd> and <kbd>ColorDialog</kbd>, present under the <kbd>System.Windows.Forms</kbd> namespace, to add support for the font and color selections, respectively.</p>
<p class="mce-root">Here's the screenshot presenting the font selector and color selector dialogs:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2b7bdd04-367f-4027-a237-8ad0cd93323c.png" style=""/></div>
<h1 id="uuid-984b28ea-26fe-45b2-905f-938209607db9">Creating ownership between windows</h1>
<p class="mce-root">In the WPF application, the window objects that you create are independent of each other by default. But, sometimes, you may want to create an owner-owned relationship between them. For example, the toolbox window that you generally see in your Visual Studio IDE and/or in a Photoshop application.</p>
<p class="mce-root">When you set an owner of a window, it acts according to the owner instance. For example, if you minimize or close the owner window, the other window under the owner-owned relationship automatically minimizes or closes according to its owner.</p>
<p class="mce-root">Let's begin creating this recipe to have an owner-owned relationship between two windows.</p>
<h2 id="uuid-c1ee7a97-8093-4c09-a1ee-4b786b6d029b">Getting ready</h2>
<p class="mce-root">To get started with this recipe, open your Visual Studio IDE and create a new WPF project called <kbd>CH01.OwnershipDemo</kbd>.</p>
<h2 id="uuid-9e1fdd95-c1af-4170-ad64-32fde3b83a18">How to do it...</h2>
<p class="mce-root">Perform the following steps to create a <kbd>ToolBox</kbd> window and assign its ownership to the <kbd>MainWindow</kbd>, so that it can act according to its owner:</p>
<ol>
<li>Right-click on the project node and select <span class="packt_screen">Add</span> | <span class="packt_screen">Window...</span> from the context menu. The <span class="packt_screen">Add New Item</span> dialog will be shown on the screen.</li>
<li>Select <span class="packt_screen">Window (WPF)</span> from the available list, give it the name <kbd>ToolBox</kbd>, and click <span class="packt_screen">Add</span> to continue. This will add <kbd>ToolBox.xaml</kbd> and <kbd>ToolBox.xaml.cs</kbd> into your project.</li>
<li>Open the <kbd>ToolBox.xaml</kbd> file and replace its content with the following XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.OwnershipDemo.ToolBox" 
  xmlns=<br/>   "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
     
    SizeToContent="WidthAndHeight"  
    ResizeMode="NoResize" 
    Title="ToolBox"&gt; 
    &lt;StackPanel Margin="10"&gt; 
        &lt;Button Content="Bold" Width="70" Margin="4"/&gt; 
        &lt;Button Content="Italics" Width="70" Margin="4"/&gt; 
        &lt;Button Content="Underlined" Width="70"  
                Margin="4"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/Window&gt; </pre>
<ol start="4">
<li>Now open the <kbd>App.xaml</kbd> page and remove the property attribute <kbd>StartupUri</kbd>, defined as (<kbd>StartupUri="MainWindow.xaml"</kbd>) from it.</li>
<li>Go to its code-behind file <kbd>App.xaml.cs</kbd> and override the <kbd>OnStartup</kbd> event. We need to modify the implementation according to our needs. Replace the entire <kbd>OnStartup</kbd> event handler with the following code block:</li>
</ol>
<pre style="padding-left: 90px">protected override void OnStartup(StartupEventArgs e) 
{ 
    base.OnStartup(e); 
 
    var mainWindow = new MainWindow(); 
    mainWindow.Show(); // must show before setting it<br/>    as owner of some other window 
 
    var toolBox = new ToolBox { Owner = mainWindow }; 
    toolBox.Show(); 
} </pre>
<ol start="6">
<li>Run the application to see the relationship between the two windows. The windows will look like the following screenshot:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c5c3dddc-e526-4c17-89b2-f6468f098c25.png" style=""/></div>
</li>
<li>Drag the <span class="packt_screen">ToolBox</span> window and you can see that you are able to move it outside the <span class="packt_screen">MainWindow</span>. Now perform some operations, such as minimizing and closing, on the <span class="packt_screen">MainWindow</span>, and you will see that the <span class="packt_screen">ToolBox</span> window also acts according to its owner.</li>
</ol>
<h2 id="uuid-26cd2781-617d-463f-8673-e272f3fed8f3">How it works...</h2>
<p class="mce-root">By default, the owner of every <kbd>Window</kbd> object is set to null, and thus each window is independent of the other. But, when you set its owner, it follows the owner-owned relationship and acts with the owner window.</p>
<p class="mce-root"><kbd>Window</kbd> ownership is not a feature of WPF, but a capability of the Win32 user API and, accessible from a WPF application.</p>
<h2 id="uuid-158784a5-5e03-403b-a112-102e1fff5e22">There's more...</h2>
<p class="mce-root">Make sure you display the owner window first, before setting it as the owner of some other window, otherwise the system will throw an <kbd>InvalidOperationException</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/946e35e3-37e8-4a98-ba6a-2fe2977d54b2.png"/></div>
<p class="mce-root">Some points to note about window ownership:</p>
<ul>
<li>The window that has an ownership relationship with another window always appears on top of that owner</li>
<li>You can drag the window outside the owner window</li>
<li>When you minimize or close the owner, the other window, which is related to it, will follow the owner and minimize or close respectively</li>
<li>By default, the window in a relationship gets displayed in the taskbar, but when you minimize the owner, it gets removed from the taskbar</li>
<li>When you want to break the relationship, just set the <kbd>Owner</kbd> property to <kbd>null</kbd></li>
</ul>
<h1 id="uuid-d3ffd751-9c71-4af6-821b-0bf90620d8eb">Creating a single instance application</h1>
<p class="mce-root">When you build applications for Windows, there are many reasons why you would want to restrict users from launching multiple instances of your application. Some common examples are installers, uninstallers, update utilities, media applications, utility tools, and so on.</p>
<p class="mce-root">In a normal application, when you launch the app, it creates a Windows process, and allocates its own memory space and resources. But, when you don't want to create multiple instances of the process for a single application that is already running, you want to silently quit the new instance and bring the running process into the foreground.</p>
<p class="mce-root">In this recipe, we will learn how to achieve this using <strong>Mutex</strong> <span>(</span><strong>Mutual Exclusion</strong><span>) </span>and unmanaged code.</p>
<h2 id="uuid-1cdaa1a8-6406-4233-b277-7ff9bde36509">Getting ready</h2>
<p class="mce-root">To get started with this, open your Visual Studio instance and create a new project based on the WPF application template. During the project creation, give it the name <kbd>CH01.SingleInstanceDemo</kbd>.</p>
<h2 id="uuid-808e421a-850a-4287-9d82-9cabf8b7efaa">How to do it...</h2>
<p class="mce-root">Once the WPF project has been created, follow these steps to create a single instance of the WPF application:</p>
<ol>
<li>Run the application by pressing the <em><span class="KeyPACKT">CTRL</span></em> + <em><span class="KeyPACKT">F5</span></em> key combination. This will launch one instance of the application.</li>
</ol>
<p> </p>
<ol start="2">
<li>Press <em><span class="KeyPACKT">CTRL</span></em> + <em><span class="KeyPACKT">F5</span></em> multiple times to launch multiple instances of the application. Now it's time to make the application a single instance application:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/123dcc2f-914c-4092-9c51-29ff7ccf41dd.png" style=""/></div>
</li>
<li>Close all the running processes and then follow the next steps to implement the single instance behavior.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> and add the window title to <kbd>Single Instance Demo</kbd>. Here you can find the entire XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.SingleInstanceDemo.MainWindow" 
  xmlns=<br/>    "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
      
     Title="Single Instance Demo"  
     Height="250" Width="400"&gt; 
    &lt;Grid&gt; 
          
    &lt;/Grid&gt; 
&lt;/Window&gt;</pre>
<ol start="5">
<li>Open the <kbd>App.xaml.cs</kbd> file and override the base implementation of the <kbd>OnStartup</kbd> method.</li>
<li>Change the code of the <kbd>OnStartup</kbd> method so that it looks like the following code:</li>
</ol>
<pre style="padding-left: 90px">protected override void OnStartup(StartupEventArgs e) 
{ 
  base.OnStartup(e); 
 
  var mutex = new Mutex(true, "SingleInstanceDemo",  
  out bool isNewInstance); 
  if (!isNewInstance) 
  { 
    MessageBox.Show("Application instance is  
     already running!"); 
    Shutdown(); 
  } 
} </pre>
<ol start="7">
<li>Add the <kbd>System.Threading</kbd> namespace declaration, so that the Mutex can be discoverable. The Mutex resides in the aforesaid namespace.</li>
<li>Now compile the project to make sure that there are no compiler errors.</li>
<li>Press <em><span class="KeyPACKT">CTRL</span></em> + <em><span class="KeyPACKT">F5</span></em>, which will run the first instance of the application.</li>
<li>Now return to the Visual Studio, without closing the application, and then hit <em><span class="KeyPACKT">CTRL</span></em> + <em><span class="KeyPACKT">F5</span></em>. This time, instead of launching the application UI, an <span class="packt_screen">Application instance is already running!</span> message will pop up on the screen. Clicking <span class="packt_screen">OK</span> will close the message.</li>
<li>Press <em><span class="KeyPACKT">CTRL</span></em> + <em><span class="KeyPACKT">F5</span></em> again. Observe that no second instance of the UI is visible on the screen.</li>
</ol>
<h2 id="uuid-13face5e-7f2f-4ba7-aa46-47bbe8e96b74">How it works...</h2>
<p class="mce-root">It's a trick to handle the application to have only a single instance.  The <strong>Mutex</strong> (<strong>Mutual Exclusion</strong>) object is used to define the instance with a unique name. Here we called it <kbd>SingleInstanceDemo</kbd>. The Boolean <kbd>out</kbd> parameter returns whether the current calling thread has been granted the initial ownership of the <kbd>mutex</kbd> object.</p>
<div class="packt_infobox">A <strong>Mutex</strong> object is a synchronization object, which is generally used to synchronize access to a shared resource, so that only one thread can access that resource at a single point in time.</div>
<p class="mce-root">For the first instance of the application, it will be granted as the initial ownership. When the second instance runs, the calling thread will not get the initial ownership because the <kbd>mutex</kbd> object with the same name, <kbd>SingleInstanceDemo,</kbd> already exists and is running.</p>
<p class="mce-root">So, the Boolean value of <kbd>isNewInstance</kbd> will be <kbd>false</kbd> and the message box will get displayed on the screen. The second instance of the application is still running at that moment and calls the <kbd>Shutdown()</kbd> method when you click on the <span class="packt_screen">OK</span> button to close the message box.</p>
<p class="mce-root">Thus, the second instance will be removed from the process list. The first instance will continue running on the system.</p>
<h2 id="uuid-032f3bab-a494-43c8-92c8-519e38e858bf">There's more...</h2>
<p class="mce-root">There could be a scenario where the application is running in a background process and the user tries to relaunch the application. In such a scenario, instead of showing a message to the user, you may want to activate the already running application and show its UI.</p>
<p class="mce-root">You can do this by changing a bit of the existing code and integrating an unmanaged code call. To do so, open the <kbd>App.xaml.cs</kbd> file once again and follow these steps:</p>
<ol>
<li>Add the following <kbd>using namespace</kbd> into the file: <kbd>System.Runtime.InteropServices</kbd>.</li>
<li>Then, you need to add the following unmanaged code declaration from the <kbd>user32.dll</kbd> to the <kbd>App.xaml.cs</kbd> file:</li>
</ol>
<pre style="padding-left: 90px">[DllImport("user32", CharSet = CharSet.Unicode)] 
static extern IntPtr FindWindow(string cls, string win); 
 
[DllImport("user32")] 
static extern IntPtr SetForegroundWindow(IntPtr hWnd);</pre>
<ol start="3">
<li>Add the following method to activate the already running window, provided that the title of the window is static. In our case, it is <span class="packt_screen">Single Instance Demo</span>, modified in the <kbd>MainWindow.xaml</kbd> page:</li>
</ol>
<pre style="padding-left: 90px">private static void ActivateWindow() 
{ 
    var otherWindow = FindWindow(null, "Single Instance Demo"); 
    if (otherWindow != IntPtr.Zero) 
    { 
        SetForegroundWindow(otherWindow); 
    } 
} </pre>
<ol start="4">
<li>Now, instead of calling the <kbd>MessageBox</kbd>, call the <kbd>ActivateWindow()</kbd> method in the <kbd>OnStartup</kbd>. Here, you can find this new code:</li>
</ol>
<pre style="padding-left: 90px">protected override void OnStartup(StartupEventArgs e) 
{ 
    base.OnStartup(e); 
 
    var mutex = new Mutex(true,  
     "SingleInstanceDemo",  
     out bool isNewInstance); 
    if (!isNewInstance) 
    { 
        // MessageBox.Show("Application instance is  
           already running!"); 
        ActivateWindow(); 
        Shutdown(); 
    } 
} </pre>
<ol start="5">
<li>Now run the application. It will launch the <kbd>MainWindow</kbd> titled <span class="packt_screen">Single Instance Demo</span> on the screen.</li>
<li>Return to Visual Studio. This will put the application window in the background. Now run the application once again by pressing the keyboard shortcut <span class="KeyPACKT"><em>CTRL</em> + <em>F5</em></span>. This time, instead of running a different instance to show the UI, it will activate the existing window and push the running application to foreground.</li>
</ol>
<p class="mce-root">It's not mandatory that the application window must always have a static title. In such cases, it will become more complex to handle said scenario.</p>
<h1 id="uuid-3036954f-e39b-4b1c-ad70-e8578a02a8e1">Passing arguments to WPF applications</h1>
<p class="mce-root">The command-line arguments are used to take optional parameters or values from the user, while launching the application. These are generally used to perform specific commands on the application from the outside.</p>
<p class="mce-root">In this recipe, we will learn how to pass command-line arguments to a WPF application.</p>
<h2 id="uuid-1f4e7f51-2d62-47cb-b9a2-5617f0b1bc74">Getting ready</h2>
<p class="mce-root">To get started, open the Visual Studio IDE and create a WPF application project called <kbd>CH01.CommandLineArgumentDemo</kbd>.</p>
<h2 id="uuid-3fcbdb66-5fc0-44bc-a71c-2100f48bfc7b">How to do it...</h2>
<p class="mce-root">Now follow these steps to let the application support command line arguments and perform actions based on those:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> to add a <kbd>TextBlock</kbd> into the <kbd>Grid</kbd> panel. Replace the entire XAML content with the following lines:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.CommandLineArgumentDemo.MainWindow" 
  xmlns=<br/>   "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
     
    Title="Main Window" Height="200" Width="400"&gt; 
    &lt;Grid&gt; 
        &lt;TextBlock Text="This is 'Main Window'<br/>          of the application." 
            HorizontalAlignment="Center"  
            VerticalAlignment="Center" 
            FontSize="18" /&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt; </pre>
<ol start="2">
<li>Create a new window in the project by right-clicking on the project node and then following the context menu path <span class="packt_screen">Add</span> | <span class="packt_screen">Window...</span> to open the <span class="packt_screen">Add New Item</span> dialog window. Give it the name <kbd>OtherWindow</kbd> and click the <span class="packt_screen">Add</span> button. This will add <kbd>OtherWindow.xaml</kbd> and <kbd>OtherWindow.xaml.cs</kbd> into the project.</li>
</ol>
<p> </p>
<ol start="3">
<li>Now open the <kbd>OtherWindow.xaml</kbd> and change its UI to have different text. Let's replace the entire XAML code with the following lines:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.CommandLineArgumentDemo.OtherWindow" 
xmlns=<br/>  "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
    
   Title="Other Window" Height="200" Width="400"&gt; 
    &lt;Grid&gt; 
        &lt;TextBlock Text="This is 'Other Window' of the  <br/>          application." 
            HorizontalAlignment="Center"  
            VerticalAlignment="Center" 
            FontSize="18" /&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt; </pre>
<ol start="4">
<li>Now open the <kbd>App.xaml</kbd> and remove the <kbd>StartupUri="MainWindow.xaml"</kbd>. This has been done to control the launch of the proper window, based on the argument passed to the application.</li>
<li>Open the <kbd>App.xaml.cs</kbd> and override its <kbd>OnStartup</kbd> method to retrieve the arguments passed to it and open the desired window based on that. Let's add the following code implementation for the <kbd>OnStartup</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">protected override void <a>OnStartup(StartupEventArgs e)</a> 
{ 
    base.OnStartup(e); 
 
    var args = e.Args; 
    if (args.Contains("/other"))  
    {  
        new OtherWindow().Show();  
    } 
    else  
    {  
        new MainWindow().Show();  
    } 
} </pre>
<ol start="6">
<li>Now build the project. Navigate to the <kbd>bin\Debug</kbd> folder and launch a <span class="packt_screen">Command Window</span> in that location. Alternatively, you can launch a <strong>Command Window</strong> (<strong>cmd.exe</strong>) and navigate to the <kbd>bin\Debug</kbd> path, where your application is available.</li>
</ol>
<p> </p>
<ol start="7">
<li>In the console window, enter the name of the application without passing any arguments to it, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>      CH01.CommandLineArgumentDemo.exe</strong></pre>
<ol start="8">
<li>This will launch the <kbd>MainWindow</kbd> of our application, with this screen:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/cecf1ff2-aec9-4e33-a6a8-0d42e35dab66.png" style=""/></div>
</li>
<li>Close the application window and, from the console window, enter the application name by specifying the <kbd>/other</kbd> argument to it, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px">      <strong>CH01.CommandLineArgumentDemo.exe /other</strong></pre>
<ol start="10">
<li>This will launch the <kbd>OtherWindow</kbd> of the application, instead of the <kbd>MainWindow</kbd>:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e63f0383-54d3-44f1-a74e-e8e1df7189f7.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-6fe1c3ef-1f7c-42be-9bc5-0e9224e7af95">How it works...</h2>
<p class="mce-root">The <kbd>OnStartup(<a>StartupEventArgs</a> e)</kbd> method signature contains <kbd>StartupEventArgs</kbd> as a method parameter. It contains a property, <kbd>Args</kbd>, that returns a string array of the command line arguments that were passed to the application. If no command line arguments were passed, the string array will have zero items in it.</p>
<p class="mce-root">Now, by checking the condition, we launch the desired window that we want to show to the user. You can also take arguments such that the application launches in normal mode, maximized mode, or minimized. You can also use it to open the application as hidden, in some specific cases.</p>
<h2 id="uuid-f50b1bc6-32b9-4e1f-bcd4-26c21081f83b">There's more...</h2>
<p class="mce-root">As we have seen how to launch the WPF application from the command line by passing the arguments, let's learn how to do this from Visual Studio itself to launch it in debug mode.</p>
<p class="mce-root">To pass a command line argument to your WPF application from Visual Studio in debug mode, right-click on the project node and click <span class="packt_screen">Properties</span> from the context menu entry. This will open the project properties. Now navigate to the <span class="packt_screen">Debug</span> tab. Please refer to the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/00535898-8b9a-4217-b475-a210524c2ed3.png" style=""/></div>
<p class="mce-root">Under <span class="packt_screen">Start options</span>, enter <kbd>/other</kbd> as the command line arguments. Now run the application in debug mode by pressing <em><span class="KeyPACKT">F5</span></em>. You will see that the <kbd>OtherWindow</kbd> opens on the screen. To launch the <kbd>MainWindow</kbd>, just remove the <kbd>/other</kbd> argument from the project properties mentioned earlier and run the application again. This time you will see that the <kbd>MainWindow</kbd> opens instead of the <kbd>OtherWindow</kbd>.</p>
<h1 id="uuid-cc046a75-e0df-410a-8ff8-fa730a559438">Handling unhandled exceptions</h1>
<p class="mce-root">Exception handling is a vital part of software development. When an exception occurs at runtime, due to any error in the code, we handle those with a <kbd>try {} catch {}</kbd> block. The <kbd>try {}</kbd> block contains the code where the exception occurred; the <kbd>catch {}</kbd> block knows how to handle that, based on the type of the exception. After the exception has been handled, the normal execution of the program continues without affecting the application.</p>
<p class="mce-root">Though, in most of the cases we handle, there could be cases that may go unnoticed and come into the picture at runtime. Such an unhandled exception crashes the application. In this recipe, we will learn how to catch the unhandled exceptions in the WPF application and close the application properly.</p>
<h2 id="uuid-e11fbfd7-c67f-4582-b19d-af9dc8daef54">Getting ready</h2>
<p class="mce-root">To get started, open the Visual Studio IDE. Now create a new project, based on the WPF Application template, and call it <kbd>CH01.UnhandledExceptionDemo</kbd>.</p>
<h2 id="uuid-53103007-f46d-44ae-a680-49c3a14f877e">How to do it...</h2>
<p class="mce-root">Let's start the demonstration by following these steps:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> page, and add two radio buttons and one button on it. The first radio button will cause an exception handled in a <kbd>try {} catch {}</kbd> block, whereas the second radio button will throw an exception that will go unhandled. Add the following code into your <kbd>MainWindow.xaml</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window x:Class="CH01.UnhandledExceptionDemo.MainWindow" 
  xmlns=<br/>    "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
      
     Title="UnhandledException Demo"  
     Height="120" Width="400"&gt; 
    &lt;Grid Margin="10"&gt; 
        &lt;StackPanel Orientation="Vertical"&gt; 
            &lt;RadioButton x:Name="radioOne" GroupName="type" 
                  Content="Handle in Try/Catch Block"  
                  IsChecked="True" Margin="4"/&gt; 
            &lt;RadioButton x:Name="radioTwo" GroupName="type" 
                  Content="Handle in Unhandled Block"  
                  IsChecked="False" Margin="4"/&gt; 
        &lt;/StackPanel&gt; 
        &lt;Button Content="Throw Exception"  
                Width="120" Height="30" 
                VerticalAlignment="Top"  
                HorizontalAlignment="Right" 
                Margin="10"  
                Click="OnThrowExceptionClicked"/&gt; 
    &lt;/Grid&gt; 
&lt;/Window&gt; </pre>
<ol start="2">
<li>Open the <kbd>MainWindow.xaml.cs</kbd> file to add the button-click event handler. Add the following code block inside the class:</li>
</ol>
<pre style="padding-left: 90px">private void OnThrowExceptionClicked(object sender, RoutedEventArgs e) 
{ 
    if (radioOne.IsChecked == true) 
    { 
        try { throw new Exception("Demo Exception"); } 
        catch (Exception ex) 
        { 
            MessageBox.Show("'" + ex.Message +  
                  "' handled in Try/Catch block"); 
        } 
    } 
    else 
    { 
        throw new Exception("Demo Exception"); 
    } 
} </pre>
<ol start="3">
<li>Go to the <kbd>App.xaml.cs</kbd> file and override the <kbd>OnStartup</kbd> method to have the application level <kbd>DispatcherUnhandledException</kbd> event registered as shown in the following code:</li>
</ol>
<pre style="padding-left: 90px">protected override void OnStartup(StartupEventArgs e) 
{ 
    base.OnStartup(e); 
 
    DispatcherUnhandledException += OnUnhandledException; 
}</pre>
<ol start="4">
<li>Add the <kbd>DispatcherUnhandledException</kbd> event handler into the <kbd>App.xaml.cs</kbd> and handle the exception as shown in the following code, but with an empty code block:</li>
</ol>
<pre style="padding-left: 90px">private void OnUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e) 
{ 
 
} </pre>
<ol start="5">
<li>Let's build and run the application. You will see the following UI on the screen:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1a8986f3-82a1-4168-b4d7-f20b6f322d48.png" style=""/></div>
</li>
<li>It will have two radio selectors and one button in the application window. When the first radio button is checked and you click on the <span class="packt_screen">Throw Exception</span> button, it will generate an exception in a <kbd>try {}</kbd> block, which will then immediately be handled by the associated <kbd>catch {}</kbd> block without crashing the application. The following message box will be shown on the UI:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d36f20f5-4b66-4c7a-9b4f-df06339b82db.png" style=""/></div>
<ol start="7">
<li>For the second radio button, when checked, if you click on the <span class="packt_screen">Throw Exception</span> button, the exception will go unhandled and will be caught in the <kbd>App.xaml.cs</kbd> file, under the <kbd>OnUnhandledException</kbd> event, and the application will crash:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d16691e7-85f5-4a47-ba53-f69e8fac5521.png" style=""/></div>
<ol start="8">
<li>Open the <kbd>App.xaml.cs</kbd> once again and modify the <kbd>OnUnhandledException</kbd> event implementation, as follows, to handle the thrown exception:</li>
</ol>
<pre style="padding-left: 90px">private void OnUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e) 
{ 
    e.Handled = true; 
} </pre>
<ol start="9">
<li>Now run the application once again, check the second radio button and click on the button. You will notice that the application will not crash this time.</li>
<li>Click the <span class="packt_screen">Throw Exception</span> button multiple times. The application will continue as-is, without causing any crash of the UI.</li>
</ol>
<h2 id="uuid-c8626916-6211-471e-a626-6ee7c726afab">How it works...</h2>
<p class="mce-root">When you handle this kind of uncaught/unhandled exception by specifying <kbd>e.Handled = true</kbd>, your application will not crash and will continue running. The best part of catching an unhandled exception is logging the unknown/unhandled errors, so that you can investigate the root cause behind these exceptions and fix them in future builds.</p>
<p class="mce-root">When there's a critical error, you can restart the application programmatically from this block.</p>
<h2 id="uuid-b34221ec-e733-48ba-ab5e-feb196bbb573">There's more...</h2>
<p class="mce-root">You can also use the <kbd>AppDomain.CurrentDomain.UnhandledException</kbd> event handler to catch any unhandled exceptions, but you won't be able to handle it in a way to continue running the application. When used, you can log the error and terminate/restart the application.</p>
<div class="packt_tip">Unhandled exceptions handled in the <kbd>DispatcherUnhandledException</kbd> event, by specifying <kbd>e.Handled = true</kbd> will not route to the <kbd>AppDomain.CurrentDomain.UnhandledException</kbd>.</div>


            </article>

            
        </section>
    </body></html>