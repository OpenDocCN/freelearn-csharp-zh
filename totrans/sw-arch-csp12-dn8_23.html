<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer385">
<h1 class="chapterTitle" id="_idParaDest-489"><span class="koboSpan" id="kobo.1.1">Answers</span></h1>
<h1 class="heading-1" id="_idParaDest-490"><span class="koboSpan" id="kobo.2.1">Chapter 1</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3.1">A software architect needs to be aware of any technology that can help them solve problems faster and ensure they can create better quality software.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.4.1">Azure helps software architects by providing scalable cloud infrastructure, diverse development tools, and services for building, deploying, and managing enterprise applications efficiently, with strong support for security and compliance.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5.1">The best software development process model depends on the kind of project, team, and budget you have. </span><span class="koboSpan" id="kobo.5.2">As a software architect, you need to consider all these variables and understand different process models so that you can fit the environment’s needs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.6.1">A software architect pays attention to any user or system requirement that can influence performance, security, usability, system architecture, structure, organization, and so on.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.7.1">A software architect should verify both functional and non-functional requirements, with a special focus on system architecture, performance, scalability, security, maintainability, and compatibility in the requirements specification.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.8.1">Design thinking and design sprint help a software architect to understand user needs deeply and rapidly prototyping solutions, ensuring the requirements gathered align closely with user expectations and project goals.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.9.1">User stories are good when we want to define functional requirements. </span><span class="koboSpan" id="kobo.9.2">They can be written quickly and commonly deliver not only the feature required but also the acceptance criteria for the solution.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.10.1">Effective techniques for developing high-performance software include optimizing code, using efficient algorithms, leveraging parallel processing, and implementing effective memory management.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.11.1">To check that the implementation is correct, a software architect compares it with models and prototypes that have already been designed and validated.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-491"><span class="koboSpan" id="kobo.12.1">Chapter 2</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.13.1">Vertically and horizontally.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.14.1">Yes, you can deploy automatically to an already-defined web app or create a new one directly using Visual Studio.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.15.1">To take advantage of available hardware resources by minimizing the time they remain idle.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.16.1">Code behavior is deterministic, so it is easy to debug. </span><span class="koboSpan" id="kobo.16.2">The execution flow mimics the flow of sequential code, which means it is easier to design and understand.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.17.1">Because the right order minimizes the number of gestures that are needed to fill in a form.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.18.1">Because it allows for the manipulation of path files in a way that is independent of the operating system.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.19.1">It can be used with several .NET Core versions, as well as with several versions of the classic .NET Framework.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.20.1">Console, .NET Core, .NET (5+), and .NET Standard class libraries; ASP.NET Core, test projects, microservices, and much more.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-492"><span class="koboSpan" id="kobo.21.1">Chapter 3</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.22.1">No, it is available for several platforms.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.23.1">Automatic, manual, and load test plans.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.24.1">Yes, they can – through Azure DevOps feeds.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.25.1">To manage requirements and organize the whole development process.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.26.1">Epic work items represent higher-level system subparts that are made up of several features.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.27.1">A parent-child relationship.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.28.1">They can organize projects using the same concept we have in Azure DevOps.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.29.1">Both options are great tools for running agile projects. </span><span class="koboSpan" id="kobo.29.2">The best option depends on your team’s experience.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-493"><span class="koboSpan" id="kobo.30.1">Chapter 4</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.31.1">Maintainability gives you the opportunity to deliver the software you designed quickly. </span><span class="koboSpan" id="kobo.31.2">It also allows you to fix bugs easily.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.32.1">Cyclomatic complexity is a measure of code complexity based on the control flow graph. </span><span class="koboSpan" id="kobo.32.2">It detects the number of nodes a method has. </span><span class="koboSpan" id="kobo.32.3">The higher the number, the worse the effect.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.33.1">A version control system will guarantee the integrity of your source code, giving you the opportunity to analyze the history of each modification that you’ve made. </span><span class="koboSpan" id="kobo.33.2">It offers the possibility of branching your code development, then merging different branches, and much more.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.34.1">A garbage collector is a system in .NET Core, .NET (5+), and .NET Framework that monitors your application and detects objects that you aren’t using anymore. </span><span class="koboSpan" id="kobo.34.2">It disposes of these objects to free up memory.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.35.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">IDisposable</span></code><span class="koboSpan" id="kobo.37.1"> interface is important firstly because it is a good pattern for deterministic cleanup. </span><span class="koboSpan" id="kobo.37.2">Secondly, it is required in classes that instantiate objects that need to be disposed of by the programmer, since the garbage collector cannot dispose of them.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.38.1">.NET 8 encapsulates some key design patterns in some of its libraries, such as dependency injection and the Builder pattern, in a way that can guarantee safer, more reliable code.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.39.1">Well-written code is code that any person skilled in that programming language can handle, modify, and evolve.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.40.1">Roslyn is the .NET compiler that’s used for code analysis inside Visual Studio.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.41.1">Code analysis is a practice that considers the way code is written to detect bad practices before compilation.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.42.1">Code analysis can find problems that happen even with apparently good software, such as memory leaks and bad programming practices.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.43.1">Roslyn is an engine that provides an API that enables analyzers to inspect your code for style, quality, maintainability, design, and other issues. </span><span class="koboSpan" id="kobo.43.2">This is done during design time, so you can check the mistakes before compiling your code.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.44.1">Visual Studio extensions are tools that have been programmed to run inside Visual Studio. </span><span class="koboSpan" id="kobo.44.2">These tools can help you out in some cases where the Visual Studio IDE doesn’t have the appropriate feature for you to use.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">SonarLint</span></code><span class="koboSpan" id="kobo.46.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">SonarAnalyzer.CSharp</span></code><span class="koboSpan" id="kobo.48.1"> NuGet package.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-494"><span class="koboSpan" id="kobo.49.1">Chapter 5</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.50.1">Copy-and-paste is an inadequate form of code reuse, since it leads to duplicated code, making maintenance and updates more difficult. </span><span class="koboSpan" id="kobo.50.2">In fact, there is no safe way to discover all duplicates, and then it is very difficult to modify all of them.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.51.1">The best approaches for code reuse are creating libraries, using generics, object-oriented inheritance, and more.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.52.1">Yes. </span><span class="koboSpan" id="kobo.52.2">You can find components that have already been created in the libraries you’ve created before, and then you increase these libraries by creating new components that can be reused in the future.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.53.1">.NET Standard is a specification that allows compatibility across different .NET frameworks, from .NET Framework to Unity. </span><span class="koboSpan" id="kobo.53.2">.NET Core is one .NET implementation of .NET and is open source.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.54.1">By creating a .NET Standard library, you will be able to use it in different .NET implementations, such as .NET Core, .NET, .NET Framework, and Xamarin.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.55.1">You can enable code reuse using object-oriented principles (e.g., inheritance, encapsulation, abstraction, and polymorphism).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.56.1">Generics is a sophisticated implementation that simplifies how objects with the same characteristics are treated, by defining a placeholder that will be replaced with the specific type at compile time.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.57.1">The answer to this question is well explained by Immo Landwerth on the .NET blog: </span><a href="https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/"><span class="url"><span class="koboSpan" id="kobo.58.1">https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/</span></span></a><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">The basic answer is that .NET versions 5 and above need to be thought of as the foundation for sharing code moving forward.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.60.1">The challenges related to refactoring include ensuring that changes don’t introduce bugs, maintaining the functionality and performance of code, and improving readability and maintainability without altering the external behavior of software components.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-495"><span class="koboSpan" id="kobo.61.1">Chapter 6</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.62.1">Design patterns are good solutions to common problems in software development.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.63.1">While design patterns give you code implementation for typical problems we face in development, design principles help you select the best options when it comes to implementing the software architecture.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.64.1">The Builder pattern will help you generate sophisticated objects without the need to define them in the class you are going to use them in.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.65.1">The Factory pattern is useful in situations where you have multiple kinds of objects from the same abstraction, and you don’t know which of them needs to be created at compile time.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.66.1">The Singleton pattern is useful when you need a class that has only one instance during the software’s execution.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.67.1">The Proxy pattern is used when you need to provide an object that controls access to another object.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.68.1">The Command pattern is used when you need to execute a command that will affect the behavior of an object.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.69.1">The Publisher/Subscriber pattern is useful when you need to provide information about an object to a group of other objects.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.70.1">The DI pattern is useful if you want to implement the Inversion of Control principle. </span><span class="koboSpan" id="kobo.70.2">Instead of creating instances of the objects that the component depends on, you just need to define their dependencies, declare their interfaces, and enable the reception of the objects by injection. </span><span class="koboSpan" id="kobo.70.3">Typically, you can do this by using the constructor of the class to receive the objects, tagging some class properties to receive the objects, or defining an interface with a method to inject all the necessary components.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-496"><span class="koboSpan" id="kobo.71.1">Chapter 7</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.72.1">Changes in the language used by experts and changes in the meaning of words.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.73.1">Context mapping is the main tool used to coordinate the development of a separate bounded context, helping to define and manage interactions between different contexts.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.74.1">No; the whole communication passes through the entity, that is, the aggregate root.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.75.1">There is a single aggregate root in a part-subpart hierarchy to ensure the consistency of and enforce rules across all elements of the aggregate, acting as the main entry point for external interactions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.76.1">Just one, since repositories are aggregate-centric.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.77.1">The application layer manipulates repository interfaces. </span><span class="koboSpan" id="kobo.77.2">Repository implementations are registered in the dependency injection engine.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.78.1">To coordinate operations on several aggregates in single transactions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.79.1">The specifications for updates and queries are usually quite different, especially in simple </span><strong class="keyWord"><span class="koboSpan" id="kobo.80.1">CRUD</span></strong><span class="koboSpan" id="kobo.81.1"> systems. </span><span class="koboSpan" id="kobo.81.2">The reason for its strongest form is mainly the optimization of query response times.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.82.1">Dependency injection.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.83.1">No; a serious impact analysis must be performed so that we can adopt it.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-497"><span class="koboSpan" id="kobo.84.1">Chapter 8</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.85.1">DevOps is the approach of delivering value to the end user continuously. </span><span class="koboSpan" id="kobo.85.2">To do this with success, continuous integration, continuous delivery, and continuous feedback must be undertaken.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.86.1">Continuous integration</span></strong><span class="koboSpan" id="kobo.87.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.88.1">CI</span></strong><span class="koboSpan" id="kobo.89.1">) allows you to check the quality of the software you are delivering every single time you commit a change. </span><span class="koboSpan" id="kobo.89.2">You can implement this by turning on this feature in Azure DevOps.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.90.1">Continuous delivery</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.92.1">CD</span></strong><span class="koboSpan" id="kobo.93.1">) allows you to deploy a solution once you are sure that all the quality checks have passed the tests you designed. </span><span class="koboSpan" id="kobo.93.2">Azure DevOps helps you with that by providing you with relevant tools.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.94.1">Yes, you can have DevOps separately and then enable </span><strong class="keyWord"><span class="koboSpan" id="kobo.95.1">CI</span></strong><span class="koboSpan" id="kobo.96.1"> later. </span><span class="koboSpan" id="kobo.96.2">You can also have CI enabled without </span><strong class="keyWord"><span class="koboSpan" id="kobo.97.1">CD</span></strong><span class="koboSpan" id="kobo.98.1"> enabled. </span><span class="koboSpan" id="kobo.98.2">Your team and process need to be ready and attentive for this to happen.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.99.1">You might confuse </span><strong class="keyWord"><span class="koboSpan" id="kobo.100.1">CI</span></strong><span class="koboSpan" id="kobo.101.1"> with a CD process, which could cause damage to your production environment. </span><span class="koboSpan" id="kobo.101.2">In the worst-case scenario, for example, a feature that is not ready might be deployed, causing disruptions at inconvenient times for your customers, or you could even suffer a bad collateral effect due to an incorrect fix.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.102.1">A multi-stage environment protects production from bad releases when fully automated build and deployment pipelines are in place.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.103.1">Automated tests anticipate bugs and bad behaviors in preview scenarios.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.104.1">Pull requests allow code reviews before commits are made in the master branch.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.105.1">No; pull requests can help you in any development approach where you have Git as your source control.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.106.1">Continuous feedback is the adoption of tools in the DevOps life cycle that enable fast feedback when it comes to performance, usability, and other aspects of the application you are developing.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.107.1">The build pipeline will let you run tasks to build and test your application, while the release pipeline will give you the opportunity to define how the application will be deployed in each scenario.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.108.1">Application Insights is a helpful tool for monitoring the health of the system you’ve deployed, which makes it a fantastic continuous feedback tool.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.109.1">Test and Feedback is a tool that allows stakeholders to analyze the software you are developing and enables a connection with Azure DevOps to open tasks and even bugs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.110.1">The main goal of service design thinking is to enhance user experience and satisfaction by optimizing the service’s usability, efficiency, and effectiveness in meeting user needs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.111.1">Azure DevOps is a tool that can automate the whole application life cycle when it comes to software development. </span><span class="koboSpan" id="kobo.111.2">However, many software architects tend to also use GitHub to do so, and Microsoft has developed the platform a lot in the last few years.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-498"><span class="koboSpan" id="kobo.112.1">Chapter 9</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.113.1">Because most of the tests must be repeated after any software change occurs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.114.1">Because the probability of the same error occurring in a unit test and its associated application code is very low.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">[Theory]</span></code><span class="koboSpan" id="kobo.116.1"> is used when the test method defines several tests, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">[Fact]</span></code><span class="koboSpan" id="kobo.118.1"> is used when the test method defines just one test.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.119.1">Assert.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">Setup</span></code><span class="koboSpan" id="kobo.121.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">Returns</span></code><span class="koboSpan" id="kobo.123.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">ReturnsAsync</span></code><span class="koboSpan" id="kobo.125.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.126.1">Yes, with </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">ReturnAsync</span></code><span class="koboSpan" id="kobo.128.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.129.1">No; it depends on the complexity of the user interface and how often it changes.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.130.1">The ASP.NET Core pipeline isn’t executed, but inputs are passed directly to controllers.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.131.1">Usage of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">Microsoft.AspNetCore.Mvc.Testing</span></code><span class="koboSpan" id="kobo.133.1"> NuGet package.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.134.1">Usage of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">AngleSharp</span></code><span class="koboSpan" id="kobo.136.1"> NuGet package.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-499"><span class="koboSpan" id="kobo.137.1">Chapter 10</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.138.1">IaaS is a good option when you are migrating from an on-premises solution or if you have an infrastructure team.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.139.1">PaaS is the best option for fast and safe software delivery in systems where the team is focused on software development.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.140.1">If the solution you intend to deliver is provided by a well-known player, such as a SaaS, you should consider using it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.141.1">Serverless is an option when you are building a new system if you don’t have people who specialize in infrastructure and you don’t want to worry about it for scaling.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.142.1">Azure SQL Database can be up in minutes, and you will have all the power of Microsoft SQL Server afterward. </span><span class="koboSpan" id="kobo.142.2">Moreover, Microsoft will handle the database server infrastructure.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.143.1">Azure provides a set of services called Azure Cognitive Services. </span><span class="koboSpan" id="kobo.143.2">These services provide solutions for vision, speech, language, search, and knowledge.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.144.1">In a hybrid scenario, you have the flexibility to decide on the best solution for each part of your system, while respecting the solution’s development path in the future.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-500"><span class="koboSpan" id="kobo.145.1">Chapter 11</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.146.1">The modularity of code and deployment modularity.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.147.1">No. </span><span class="koboSpan" id="kobo.147.2">Other important advantages include handling the development team and the whole </span><strong class="keyWord"><span class="koboSpan" id="kobo.148.1">CI</span></strong><span class="koboSpan" id="kobo.149.1">/</span><strong class="keyWord"><span class="koboSpan" id="kobo.150.1">CD</span></strong><span class="koboSpan" id="kobo.151.1"> cycle well, and the possibility of mixing heterogeneous technologies easily and effectively.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.152.1">A library that helps us implement resilient communication.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.153.1">Once you’ve installed Docker on your development machine, you can develop, debug, and deploy Dockerized .NET applications. </span><span class="koboSpan" id="kobo.153.2">You can also add Docker images to Service Fabric applications that are handled with Visual Studio.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.154.1">Orchestrators are software that manages microservices and nodes in microservice clusters. </span><span class="koboSpan" id="kobo.154.2">Azure supports two relevant orchestrators: Azure Kubernetes Service and Azure Service Fabric.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.155.1">Because it decouples the actors that take place in a communication.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.156.1">A message broker. </span><span class="koboSpan" id="kobo.156.2">It takes care of service-to-service communication and events.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.157.1">The same message can be received several times because the sender doesn’t receive confirmation of reception before its time-out period, so the sender resends the message again. </span><span class="koboSpan" id="kobo.157.2">Therefore, the effect of receiving a single message once or several times must be the same.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-501"><span class="koboSpan" id="kobo.158.1">Chapter 12</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.159.1">Redis is a distributed in-memory storage based on key-value pairs and supports distributed queuing. </span><span class="koboSpan" id="kobo.159.2">Its most well-known usage is for distributed caching, but it can be used as an alternative to relational databases, since it is able to persist data to disk.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.160.1">Yes, they are. </span><span class="koboSpan" id="kobo.160.2">Most of this chapter’s sections are dedicated to explaining why.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.161.1">Write operations.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.162.1">The main weaknesses of NoSQL databases are their consistency and transactions, while their main advantage is performance, especially when it comes to handling distributed writes.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.163.1">Eventual, Consistency Prefix, Session, Bounded Staleness, and Strong.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.164.1">No, they are not efficient in a distributed environment. </span><span class="koboSpan" id="kobo.164.2">GUID-based strings perform better, since their uniqueness is automatic and doesn’t require synchronization operations.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">OwnsMany</span></code><span class="koboSpan" id="kobo.166.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">OwnsOne</span></code><span class="koboSpan" id="kobo.168.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.169.1">Yes, they can. </span><span class="koboSpan" id="kobo.169.2">Once you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">SelectMany</span></code><span class="koboSpan" id="kobo.171.1">, indices can be used to search for nested objects.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-502"><span class="koboSpan" id="kobo.172.1">Chapter 13</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.173.1">With the help of database-dependent providers.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.174.1">Either by calling them </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">Id</span></code><span class="koboSpan" id="kobo.176.1"> or by decorating them with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">Key</span></code><span class="koboSpan" id="kobo.178.1"> attribute. </span><span class="koboSpan" id="kobo.178.2">This can also be done with a fluent configuration approach.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.179.1">With the </span><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">MaxLength</span></code><span class="koboSpan" id="kobo.181.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">MinLength</span></code><span class="koboSpan" id="kobo.183.1"> attributes, or with their equivalent fluent configuration methods.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.184.1">With something similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">builder.Entity&lt;Package&gt;().HasIndex(m =&gt; m.Name);</span></code><span class="koboSpan" id="kobo.186.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.187.1">With something similar to the following:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.188.1">builder.Entity&lt;Destination&gt;()
.HasMany(m =&gt; m.Packages)
.WithOne(m =&gt; m.MyDestination)
.HasForeignKey(m =&gt; m.DestinationId)
.OnDelete(DeleteBehavior.Cascade);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.189.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">Add-Migration</span></code><span class="koboSpan" id="kobo.191.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">Update-Database</span></code><span class="koboSpan" id="kobo.193.1"> in the package-manager console, or with </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">dotnet ef migrations</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.195.1">add</span></code><span class="koboSpan" id="kobo.196.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">dotnet</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.198.1">ef</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.199.1">database</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.200.1">update</span></code><span class="koboSpan" id="kobo.201.1"> in the operating system console.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.202.1">No, but you can forcefully include them with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">Include</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.204.1">LINQ</span></code><span class="koboSpan" id="kobo.205.1"> clause or by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">UseLazyLoadingProxies</span></code><span class="koboSpan" id="kobo.207.1"> option when configuring your </span><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">DbContext</span></code><span class="koboSpan" id="kobo.209.1">. </span><span class="koboSpan" id="kobo.209.2">With Include, related entities are loaded together with the main entities, while with </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">UseLazyLoadingProxies</span></code><span class="koboSpan" id="kobo.211.1">, related entities are lazy-loaded; that is, they are loaded as soon as they are required.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.212.1">Yes, it is, thanks to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">Select LINQ</span></code><span class="koboSpan" id="kobo.214.1"> clause.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.215.1">By calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.216.1">context.Database.Migrate()</span></code><span class="koboSpan" id="kobo.217.1">.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-503"><span class="koboSpan" id="kobo.218.1">Chapter 14</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.219.1">Because using queues are the only way to avoid time-consuming blocking calls.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.220.1">With the </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">import</span></code><span class="koboSpan" id="kobo.222.1"> declaration.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.223.1">With the standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">Duration</span></code><span class="koboSpan" id="kobo.225.1"> message.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.226.1">Version compatibility and interoperability while maintaining good performance.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.227.1">Better horizontal scalability, and support for the Publisher/Subscriber pattern.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.228.1">For two reasons. </span><span class="koboSpan" id="kobo.228.2">The operation is very fast, and the insertion in the first queue of a communication path must necessarily be a blocking operation. </span><span class="koboSpan" id="kobo.228.3">At least one blocking operation is always necessary to store the message in some permanent storage (usually a queue), so it can be recovered if the ongoing processing might fail for some reason.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.229.1">With the following XML code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.230.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.231.1">ItemGroup</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.232.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.233.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.234.1">Protobuf</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.235.1">Include</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.236.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.237.1">"Protos\file1.proto"</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.238.1">GrpcServices</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.239.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.240.1">"Server/Client"</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.241.1"> /&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.242.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.243.1">Protobuf</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.244.1">Include</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.245.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.246.1">"Protos\file2.proto"</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.247.1">GrpcServices</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.248.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.249.1">"Server/Client"</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.250.1"> /&gt;</span></span><span class="koboSpan" id="kobo.251.1">
   ...
</span><span class="hljs-tag"><span class="koboSpan" id="kobo.252.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.253.1">ItemGroup</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.254.1">&gt;</span></span>
</code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.255.1">Where </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">Protos\file1.proto</span></code><span class="koboSpan" id="kobo.257.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">Protos\file2.proto</span></code><span class="koboSpan" id="kobo.259.1"> must be replaced with the actual paths to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">ProtoBuf</span></code><span class="koboSpan" id="kobo.261.1"> files within our project. </span><span class="koboSpan" id="kobo.261.2">Moreover, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">GrpcServices</span></code><span class="koboSpan" id="kobo.263.1"> attribute must be set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">"Server"</span></code><span class="koboSpan" id="kobo.265.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">"Client"</span></code><span class="koboSpan" id="kobo.267.1">, depending on whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">proto</span></code><span class="koboSpan" id="kobo.269.1"> file describes a server or not.</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8"><span class="koboSpan" id="kobo.270.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">channel.BasicPublish(…)</span></code><span class="koboSpan" id="kobo.272.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.273.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">channel.WaitForConfirmsOrDie(timeout)</span></code><span class="koboSpan" id="kobo.275.1">.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-504"><span class="koboSpan" id="kobo.276.1">Chapter 15</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.277.1">No, since this would violate the principle that a service reaction to a request must depend on the request itself, and not on other messages/requests that had previously been exchanged with the client.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.278.1">No, implementing a service with a custom communication protocol is generally not good practice because it compromises interoperability, increases development and maintenance complexity, and isolates the service from widely used standards and tools. </span><span class="koboSpan" id="kobo.278.2">Standard protocols such as HTTP/REST, </span><code class="inlineCode"><span class="koboSpan" id="kobo.279.1">gRPC</span></code><span class="koboSpan" id="kobo.280.1">, and others are preferred for their broad support, ease of integration, and community backing.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.281.1">Yes, it can. </span><span class="koboSpan" id="kobo.281.2">The primary action of a POST must be creation, but deletion can be performed as a side effect. </span><span class="koboSpan" id="kobo.281.3">The HTTP verb to use is determined by the virtual table named in the URL (in our case, a POST, since the operation is an addition), but other operations can be performed on other virtual tables that are not mentioned in the URL as side effects.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.282.1">Three; they are </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">Base64</span></code><span class="koboSpan" id="kobo.284.1"> encoding of the header, </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">Base64</span></code><span class="koboSpan" id="kobo.286.1"> encoding of the body, and the signature.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.287.1">From the request body.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.288.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">ApiController</span></code><span class="koboSpan" id="kobo.290.1"> attribute sets up some default behaviors that help in the implementation of REST services.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.291.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">ProducesResponseType</span></code><span class="koboSpan" id="kobo.293.1"> attribute.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.294.1">When using API controllers, they are declared with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">Route</span></code><span class="koboSpan" id="kobo.296.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">Http&lt;verb&gt;</span></code><span class="koboSpan" id="kobo.298.1"> attributes. </span><span class="koboSpan" id="kobo.298.2">When using a minimal API, they are declared in the first argument of </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">MapGet</span></code><span class="koboSpan" id="kobo.300.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">MapPost</span></code><span class="koboSpan" id="kobo.302.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">…</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.304.1">Map{Http verb}</span></code><span class="koboSpan" id="kobo.305.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.306.1">By adding something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">builder.Services.AddHttpClient&lt;MyProxy&gt;()</span></code><span class="koboSpan" id="kobo.308.1"> in the dependency injection part of the host configuration.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-505"><span class="koboSpan" id="kobo.309.1">Chapter 16</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.310.1">Azure Functions is an Azure PaaS component that allows you to implement FaaS solutions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.311.1">You can program Azure Functions in different languages, such as C#, F#, PHP, Python, and Node.js. </span><span class="koboSpan" id="kobo.311.2">You can also create functions using the Azure portal and Visual Studio Code. </span><span class="koboSpan" id="kobo.311.3">Additional stacks can be used by using custom handlers: </span><a href="https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers"><span class="url"><span class="koboSpan" id="kobo.312.1">https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers</span></span></a><span class="koboSpan" id="kobo.313.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.314.1">There are two plan options in Azure Functions. </span><span class="koboSpan" id="kobo.314.2">The first plan is the Consumption Plan, where you are charged according to the amount you use. </span><span class="koboSpan" id="kobo.314.3">The second plan is the App Service Plan, where you share your App Service resources with the function’s needs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.315.1">The process of deploying functions in Visual Studio is the same as in web app deployment.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.316.1">There are lots of ways we can trigger Azure Functions, such as using Blob Storage, Cosmos DB, Event Grid, Event Hubs, HTTP, Microsoft Graph Events, Queue Storage, Service Bus, Timer, and Webhooks.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.317.1">Azure Functions v1 needs the .NET Framework Engine, whereas v2 needs .NET Core 2.2, and v3 needs .NET Core 3.1 and .NET 5-6. </span><span class="koboSpan" id="kobo.317.2">v4 is the current version for .NET 6, 7, and 8.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.318.1">The execution of every Azure function can be monitored by Application Insights. </span><span class="koboSpan" id="kobo.318.2">Here, you can check the time it took to process, resource usage, errors, and exceptions that happened in each function call.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.319.1">They are functions that will let us write stateful workflows, managing the state behind the scenes.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-506"><span class="koboSpan" id="kobo.320.1">Chapter 17</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.321.1">Typical middleware modules scaffolded by Visual Studio in an ASP.NET Core project include a developer exception page, request routing, static file serving, HTTPS redirection, authentication, and authorization.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.322.1">No.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.323.1">False. </span><span class="koboSpan" id="kobo.323.2">Several tag helpers can be invoked on the same tag.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">ModelState.IsValid</span></code><span class="koboSpan" id="kobo.325.1">.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">@RenderBody()</span></code><span class="koboSpan" id="kobo.327.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.328.1">We can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">@RenderSection("Scripts", required: false)</span></code><span class="koboSpan" id="kobo.330.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.331.1">We can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">return View("viewname", ViewModel)</span></code><span class="koboSpan" id="kobo.333.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.334.1">Three providers are included in ASP.NET Core, but they must be configured. </span><span class="koboSpan" id="kobo.334.2">If different providers are needed, they must be implemented by the developers and added to the providers list.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.335.1">No, </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">ViewModels</span></code><span class="koboSpan" id="kobo.337.1"> are not the only way for controllers to communicate with views in ASP.NET Core. </span><span class="koboSpan" id="kobo.337.2">Controllers can also use </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">ViewData</span></code><span class="koboSpan" id="kobo.339.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">ViewData</span></code><span class="koboSpan" id="kobo.341.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">TempData</span></code><span class="koboSpan" id="kobo.343.1"> to pass data to views.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-507"><span class="koboSpan" id="kobo.344.1">Chapter 18</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.345.1">API gateways work as interfaces for API microservices, while frontends take care of building web pages’ HTML.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.346.1">Robust web servers optimize the whole request/response handling and ensure the needed level of security.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.347.1">Because they have an impact on performance that is usually unacceptable for high-traffic microservices.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.348.1">When transactions are quite fast and the probability of collision between transactions is low.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.349.1">A better decoupling of the aggregates and commands methods.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-508"><span class="koboSpan" id="kobo.350.1">Chapter 19</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.351.1">It is a W3C standard: the assembly of a virtual machine running in W3C-compliant browsers.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.352.1">A web UI where dynamic HTML is created in the browser itself.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.353.1">Selecting a page based on the current browser URL.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.354.1">A Blazor component with routes attached to it. </span><span class="koboSpan" id="kobo.354.2">For this reason, the Blazor router can select it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.355.1">Defining the .NET namespace of a Blazor component class.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.356.1">A local service that takes care of storing and handling all form-related information, such as validation errors and changes in HTML inputs.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.357.1">Either </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">OnInitialized</span></code><span class="koboSpan" id="kobo.359.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">OnInitializedAsync</span></code><span class="koboSpan" id="kobo.361.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.362.1">Callbacks and services.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.363.1">Blazor’s way to interact with JavaScript.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.364.1">Getting a reference to a component or HTML element instance.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-509"><span class="koboSpan" id="kobo.365.1">Chapter 20</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.366.1">Services are needed to dispatch communication to pods, since a pod has no stable IP address.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.367.1">Kubernetes offers higher-level entities called Ingresses that are built on top of services, empowering clusters with all the advanced capabilities offered by a web server, such as routing HTTP/HTTPS URLs from outside the cluster to internal service URLs inside the cluster.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.368.1">Helm charts are a way to organize the templating and installation of complex Kubernetes applications that contain several </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">.yaml</span></code><span class="koboSpan" id="kobo.370.1"> files.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.371.1">Yes, with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">---</span></code><span class="koboSpan" id="kobo.373.1"> separator.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.374.1">Kubernetes detects container faults through liveness and readiness probes that check the health and availability of containers, ensuring they run as expected.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.375.1">Because Pods, having no stable location, can’t rely on the storage of the node where they are currently running.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">StatefulSet</span></code><span class="koboSpan" id="kobo.377.1"> is assumed to have state and achieve write/update parallelism through sharding, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">ReplicaSet</span></code><span class="koboSpan" id="kobo.379.1"> has no state, so as it is indistinguishable, it can achieve parallelism by splitting the load.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-510"><span class="koboSpan" id="kobo.380.1">Chapter 21</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.381.1">It is because it doesn’t support TCP/IP communications.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.382.1">Visual Studio’s recommended tool to debug Kubernetes applications.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.383.1">No, it works with any Kubernetes cluster that has been configured as the default cluster in the local Kubectl installation.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.384.1">With something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">minikube</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.386.1">image</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.387.1">load</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.388.1">grpcmicroservice:latest</span></code><span class="koboSpan" id="kobo.389.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.390.1">It is enough to start Minikube, and Minikube’s start procedure will do it for you.</span></li>
</ol>
<h1 class="heading-1"><span class="koboSpan" id="kobo.391.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.392.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.393.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>