<html><head></head><body>
<div id="_idContainer055" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-57" class="calibre5"><a id="_idTextAnchor059" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Implementing Engaging Game Mechanics Using C# in Unity</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Welcome to </span><a href="B22017_04.xhtml#_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.5.1">, where we invite you into the dynamic world of game development. </span><span class="kobospan" id="kobo.5.2">As you delve into this chapter, your journey will begin by exploring the foundational principles that drive successful game mechanics. </span><span class="kobospan" id="kobo.5.3">This initial step involves an introduction to game mechanics, allowing you to grasp the essential concepts that form the backbone of </span><span><span class="kobospan" id="kobo.6.1">captivating gameplay.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">Following this, you’ll seamlessly transition into the realm of player behavior and AI before delving into the topics of challenge and reward systems. </span><span class="kobospan" id="kobo.7.2">This journey unravels the art of crafting interactive and responsive </span><span><span class="kobospan" id="kobo.8.1">gaming experiences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">By the end of this chapter, you’ll be equipped with not only theoretical insights but also practical skills to shape immersive gaming adventures in Unity using the power </span><span><span class="kobospan" id="kobo.10.1">of C#.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.12.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Introducing </span><span><span class="kobospan" id="kobo.14.1">game mechanics</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">Implementing player behavior and AI logic </span><span><span class="kobospan" id="kobo.16.1">using C#</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.17.1">Implementing challenge and reward systems </span><span><span class="kobospan" id="kobo.18.1">using C#</span></span></li>
</ul>
<h1 id="_idParaDest-58" class="calibre5"><a id="_idTextAnchor060" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.19.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.20.1">You can access the code samples and project files on our dedicated GitHub </span><span><span class="kobospan" id="kobo.21.1">repository: </span></span><a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.22.1">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004</span></span></a><span><span class="kobospan" id="kobo.23.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">Clone or download the repository so that you have easy access to the code demonstrated in </span><span><span class="kobospan" id="kobo.25.1">this chapter.</span></span></p>
<h1 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor061" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.26.1">Introducing game mechanics</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.27.1">Game mechanics</span></strong><span class="kobospan" id="kobo.28.1"> are </span><a id="_idIndexMarker226" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.29.1">the rules and systems that shape how a game is played. </span><span class="kobospan" id="kobo.29.2">Think of them as the behind-the-scenes mechanisms that define the player’s experience. </span><span class="kobospan" id="kobo.29.3">They are vital for crafting engaging gameplay, influencing everything from movement and combat to how a story unfolds. </span><span class="kobospan" id="kobo.29.4">Successful games, such as </span><em class="italic"><span class="kobospan" id="kobo.30.1">Mario</span></em><span class="kobospan" id="kobo.31.1"> with its jumping mechanics, or </span><em class="italic"><span class="kobospan" id="kobo.32.1">Tetris</span></em><span class="kobospan" id="kobo.33.1"> with its block arrangement challenges, showcase how well-crafted mechanics can create memorable and enjoyable experiences </span><span><span class="kobospan" id="kobo.34.1">for players.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">Game mechanics go beyond just making a game work; they subtly tell stories by how players interact. </span><span class="kobospan" id="kobo.35.2">Whether it’s in fighting games with complex combat or in platformers with puzzle-solving, these mechanics add to the overall story. </span><span class="kobospan" id="kobo.35.3">When players follow the game’s rules, they’re not just watching; they become part of </span><span><span class="kobospan" id="kobo.36.1">the story.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.37.1">So, understanding and creating game mechanics is like becoming skilled at interactive storytelling. </span><span class="kobospan" id="kobo.37.2">Each button that’s pressed or moved in the game helps the story move along, making every playthrough a unique and </span><span><span class="kobospan" id="kobo.38.1">personal journey.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">In the following section, we will talk about the essential principles you need to know about </span><span><span class="kobospan" id="kobo.40.1">game mechanics.</span></span></p>
<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor062" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.41.1">Essential principles of game mechanics</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">Now, let’s get</span><a id="_idIndexMarker227" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.43.1"> into the important stuff that makes games enjoyable. </span><span class="kobospan" id="kobo.43.2">We’re talking about the basic rules that shape how players have fun. </span><span class="kobospan" id="kobo.43.3">It’s all about finding the right balance, giving feedback, and making sure players feel in control. </span><span class="kobospan" id="kobo.43.4">These simple things turn games into exciting adventures where every move adds to </span><span><span class="kobospan" id="kobo.44.1">the fun.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.45.1">Balance</span></h3>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.46.1">Balance</span></strong><span class="kobospan" id="kobo.47.1"> in </span><a id="_idIndexMarker228" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.48.1">games is like ensuring everyone gets a fair shot at having fun. </span><span class="kobospan" id="kobo.48.2">Picture a game where one character is super strong, making it impossible for others to enjoy. </span><span class="kobospan" id="kobo.48.3">That wouldn’t be fair, right? </span><span class="kobospan" id="kobo.48.4">Game developers work hard to create a balanced experience where each player or character has a chance to shine. </span><span class="kobospan" id="kobo.48.5">Take </span><em class="italic"><span class="kobospan" id="kobo.49.1">Overwatch</span></em><span class="kobospan" id="kobo.50.1">, for example. </span><span class="kobospan" id="kobo.50.2">In this game, each hero boasts unique abilities, and no one is overwhelmingly powerful or weak. </span><span class="kobospan" id="kobo.50.3">It’s this careful balance that ensures a level playing field, allowing everyone to have a good time and contribute to the </span><span><span class="kobospan" id="kobo.51.1">game’s excitement.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">Furthermore, balance</span><a id="_idIndexMarker229" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.53.1"> goes beyond characters; it extends to the overall gameplay. </span><span class="kobospan" id="kobo.53.2">Imagine a game with levels that are either too easy or impossibly hard – players would quickly lose interest. </span><span class="kobospan" id="kobo.53.3">Achieving balance in challenges, difficulty, and rewards keeps players engaged. </span><span class="kobospan" id="kobo.53.4">Games that strike this delicate balance provide a satisfying and enjoyable experience for players of all skill levels, making them want to keep playing and exploring what the game has </span><span><span class="kobospan" id="kobo.54.1">to offer.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.55.1">Feedback</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.56.1">In the world of </span><a id="_idIndexMarker230" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.57.1">gaming, </span><strong class="bold"><span class="kobospan" id="kobo.58.1">feedback</span></strong><span class="kobospan" id="kobo.59.1"> is the game’s way of talking to you, letting you know how you’re doing. </span><span class="kobospan" id="kobo.59.2">It’s like a pat on the back when you do something right or a gentle nudge when you could improve. </span><span class="kobospan" id="kobo.59.3">In </span><em class="italic"><span class="kobospan" id="kobo.60.1">Minecraft</span></em><span class="kobospan" id="kobo.61.1">, for instance, when you successfully mine resources, a satisfying sound accompanies the action. </span><span class="kobospan" id="kobo.61.2">That sound is feedback, a small celebration telling you that you’ve accomplished </span><span><span class="kobospan" id="kobo.62.1">a task.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">Think about playing a racing game without any feedback – no cheering crowd, no speedometer ticking up – it would be a bit strange, right? </span><span class="kobospan" id="kobo.63.2">Good feedback, whether it’s visual, auditory, or haptic, is essential for making players feel accomplished and guiding them through the </span><span><span class="kobospan" id="kobo.64.1">game’s challenges.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">Moreover, feedback extends to storytelling in games. </span><span class="kobospan" id="kobo.65.2">Choices you make should have consequences, and the game should let you know how your decisions impact the story. </span><span class="kobospan" id="kobo.65.3">Effective feedback creates a dynamic connection between the player and the game world, making every action feel meaningful. </span><span class="kobospan" id="kobo.65.4">Whether it’s triumphant music after a successful quest or a subtle change in the environment based on your decisions, feedback adds depth to the gaming experience, ensuring players stay engaged and invested in the virtual world </span><span><span class="kobospan" id="kobo.66.1">they’re exploring.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.67.1">Player agency</span></h3>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.68.1">Player agency</span></strong><span class="kobospan" id="kobo.69.1"> is like </span><a id="_idIndexMarker231" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.70.1">having a steering wheel in a game – you get to make choices and have control over your virtual adventure. </span><span class="kobospan" id="kobo.70.2">In </span><em class="italic"><span class="kobospan" id="kobo.71.1">The Elder Scrolls V: Skyrim</span></em><span class="kobospan" id="kobo.72.1">, this principal shines brightly. </span><span class="kobospan" id="kobo.72.2">Right from the start, you decide who your character is going to be. </span><span class="kobospan" id="kobo.72.3">Do you want to be a brave warrior, a sneaky thief, or a powerful wizard? </span><span class="kobospan" id="kobo.72.4">The game doesn’t force you down a specific path; instead, it lets you carve out your </span><span><span class="kobospan" id="kobo.73.1">own story.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">This freedom </span><a id="_idIndexMarker232" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.75.1">to make choices extends beyond character creation. </span><span class="kobospan" id="kobo.75.2">As you progress through the game, you encounter various quests and challenges, and here, again, player agency takes center stage. </span><span class="kobospan" id="kobo.75.3">You can decide how to approach a situation – do you want to negotiate, fight, or sneak past enemies? </span><span class="kobospan" id="kobo.75.4">Your choices influence not just the immediate outcome but also the overall story. </span><span class="kobospan" id="kobo.75.5">Your version of </span><em class="italic"><span class="kobospan" id="kobo.76.1">Skyrim</span></em><span class="kobospan" id="kobo.77.1"> might be entirely different from someone else’s because player agency allows for </span><span><span class="kobospan" id="kobo.78.1">diverse experiences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.79.1">Having player agency transforms a game into more than just a set path with predetermined outcomes. </span><span class="kobospan" id="kobo.79.2">It transforms it into your story, where your decisions matter, and the game adapts to your choices. </span><span class="kobospan" id="kobo.79.3">This sense of control and the ability to shape your unique adventure is what makes player agency a key principle in creating immersive and personally meaningful </span><span><span class="kobospan" id="kobo.80.1">gaming experiences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.81.1">In the following section, we are going to understand the relationship between code and </span><span><span class="kobospan" id="kobo.82.1">game mechanics.</span></span></p>
<h2 id="_idParaDest-61" class="calibre7"><a id="_idTextAnchor063" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.83.1">The connection between code and game mechanics</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">Now, here’s the cool part – the code is what turns ideas into action in the game. </span><span class="kobospan" id="kobo.84.2">It’s like a rulebook</span><a id="_idIndexMarker233" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.85.1"> that tells the game what to do. </span><span class="kobospan" id="kobo.85.2">If you want to create a game where players can shoot lasers, you’d write code to make it happen. </span><span class="kobospan" id="kobo.85.3">So, the relationship between code and game mechanics is like a chef’s recipe for a delicious meal – the code guides the game to do exactly what </span><span><span class="kobospan" id="kobo.86.1">we want.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">Understanding these coding basics is like having the keys to the game-making kingdom. </span><span class="kobospan" id="kobo.87.2">It allows you to bring your game ideas to life and create all sorts of cool stuff. </span><span class="kobospan" id="kobo.87.3">Plus, the more you understand C#, the more you can make your games do awesome things. </span><span class="kobospan" id="kobo.87.4">So, get ready to dive into the world of coding in this chapter – it’s not as tricky as it sounds, and it’s the secret sauce that makes games so much fun </span><span><span class="kobospan" id="kobo.88.1">to play!</span></span></p>
<h1 id="_idParaDest-62" class="calibre5"><a id="_idTextAnchor064" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.89.1">Implementing player behavior and AI logic using C#</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">In this section, we’ll be</span><a id="_idIndexMarker234" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.91.1"> getting into how games </span><a id="_idIndexMarker235" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.92.1">are made, looking at how players act and how computer-controlled characters (we call it AI) think in games. </span><span class="kobospan" id="kobo.92.2">Figuring out how players act and how game characters react is a big deal in making games fun. </span><span class="kobospan" id="kobo.92.3">It’s like giving players a script to follow, just like actors in a play. </span><span class="kobospan" id="kobo.92.4">Players bring the game to life, a bit like how actors make a story interesting. </span><span class="kobospan" id="kobo.92.5">We’ll look at different types of games, checking out how players act in all sorts of situations, from big adventures to </span><span><span class="kobospan" id="kobo.93.1">tactical fights.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.94.1">Then, we’ll </span><a id="_idIndexMarker236" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.95.1">check out AI, the smart computer stuff that makes game enemies, friends, and other characters feel real. </span><span class="kobospan" id="kobo.95.2">AI isn’t just code; it’s like</span><a id="_idIndexMarker237" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.96.1"> magic that makes challenges exciting, enemies tricky, and friends helpful. </span><span class="kobospan" id="kobo.96.2">We’ll explain the basic ideas behind this digital magic, kind of like understanding the cues a conductor gives to an orchestra, guiding all the actions and reactions in </span><span><span class="kobospan" id="kobo.97.1">a game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.98.1">So, we’re on a journey to make player behavior and AI logic less mysterious using C# – a fancy way to talk to computers. </span><span class="kobospan" id="kobo.98.2">You’ll be all set to make games that feel real, keeping players interested and making your game </span><span><span class="kobospan" id="kobo.99.1">super exciting!</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.100.1">Understanding player behavior design</span></strong><span class="kobospan" id="kobo.101.1">: In the realm of player behavior design, crafting a responsive</span><a id="_idIndexMarker238" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.102.1"> game involves the fundamental aspect </span><a id="_idIndexMarker239" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1">of </span><strong class="bold"><span class="kobospan" id="kobo.104.1">health management</span></strong><span class="kobospan" id="kobo.105.1">. </span><strong class="bold"><span class="kobospan" id="kobo.106.1">Health</span></strong><span class="kobospan" id="kobo.107.1">, being a universal concept for both players and enemies, is a core behavior that greatly influences the overall gaming experience. </span><span class="kobospan" id="kobo.107.2">To achieve a modular and extensible system, we must introduce an </span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">IHealth</span></strong><span class="kobospan" id="kobo.109.1"> interface that encapsulates essential functions, such as tracking maximum health, current health, taking damage, and healing. </span><span class="kobospan" id="kobo.109.2">By adopting this interface, we can establish a unified approach to health management that applies to both players and enemies. </span><span class="kobospan" id="kobo.109.3">This not only streamlines the code base but also allows for easy expansion and modification as the </span><span><span class="kobospan" id="kobo.110.1">game evolves.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.111.1">Shooting mechanics</span></strong><span class="kobospan" id="kobo.112.1">: In </span><a id="_idIndexMarker240" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.113.1">addition to health, we’ll delve into shooting mechanics, a pivotal player behavior in a shooting game. </span><span class="kobospan" id="kobo.113.2">Rather than a simplistic shooting script, we’ll opt for a modular approach, creating separate components for bullets, projectiles, and weapons. </span><span class="kobospan" id="kobo.113.3">This modular design enables flexibility and scalability, making it easier to introduce new weapons, tweak projectile behaviors, and enhance overall </span><span><span class="kobospan" id="kobo.114.1">gameplay dynamics.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.115.1">Introduction to AI logic</span></strong><span class="kobospan" id="kobo.116.1">: Transitioning to AI logic, we’ll explore fundamental concepts that </span><a id="_idIndexMarker241" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.117.1">breathe life into in-game adversaries. </span><span class="kobospan" id="kobo.117.2">Basic AI principles encompass understanding the role of AI in creating dynamic and challenging gameplay. </span><span class="kobospan" id="kobo.117.3">The AI system becomes a crucial component in determining enemy behaviors, ranging from simple wandering to complex attack patterns. </span><span class="kobospan" id="kobo.117.4">By delving into these concepts, we’ll gain insights into the decision-making processes that drive AI-controlled entities, contributing to the overall richness of the </span><span><span class="kobospan" id="kobo.118.1">gaming experience.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.119.1">Coding player behavior and AI</span></strong><span class="kobospan" id="kobo.120.1">: Moving from theory to practice, we’ll embark on </span><a id="_idIndexMarker242" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.121.1">the practical implementation of player behavior and AI logic using C# scripts. </span><span class="kobospan" id="kobo.121.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.122.1">IHealth</span></strong><span class="kobospan" id="kobo.123.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.124.1">IDamage</span></strong><span class="kobospan" id="kobo.125.1"> interfaces </span><a id="_idIndexMarker243" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.126.1">become the cornerstone for implementing health-related functionalities, ensuring a consistent and manageable approach across diverse game elements. </span><span class="kobospan" id="kobo.126.2">The modular shooting system will take shape as we learn to handle bullets, projectiles, and weapons separately, promoting code reusability </span><span><span class="kobospan" id="kobo.127.1">and maintainability.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.128.1">To reinforce learning, we’ll </span><a id="_idIndexMarker244" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.129.1">engage in hands-on demonstrations, showcasing the step-by-step creation of C# scripts for player behavior and </span><a id="_idIndexMarker245" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.130.1">AI logic in the subsequent sections. </span><span class="kobospan" id="kobo.130.2">We’ll gain proficiency in designing and implementing responsive player behaviors, fostering an understanding of how to bring dynamic AI characters to life within the Unity game </span><span><span class="kobospan" id="kobo.131.1">development environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.132.1">Let’s start by writing the </span><strong class="source-inline"><span class="kobospan" id="kobo.133.1">IHealth</span></strong><span class="kobospan" id="kobo.134.1"> interface and establishing the fundamental logic </span><span><span class="kobospan" id="kobo.135.1">for it.</span></span></p>
<h2 id="_idParaDest-63" class="calibre7"><a id="_idTextAnchor065" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.136.1">Writing the IHealth and IDamage interfaces</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.137.1">In the following </span><a id="_idIndexMarker246" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.138.1">code block, we’ve introduced the </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">IHealth</span></strong><span class="kobospan" id="kobo.140.1"> interface, which incorporates properties for maximum and current health, along with essential functions for setting maximum health, inflicting damage, and facilitating healing. </span><span class="kobospan" id="kobo.140.2">Here, we’ll create an interface to manage the health logic throughout the entire game. </span><span class="kobospan" id="kobo.140.3">I’ve designed it so that it oversees the health of each entity once they implement this interface. </span><span class="kobospan" id="kobo.140.4">This approach will simplify communication between entities and prove beneficial when we also create the </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">IDamage</span></strong><span class="kobospan" id="kobo.142.1"> interface. </span><span class="kobospan" id="kobo.142.2">Implementing </span><strong class="source-inline"><span class="kobospan" id="kobo.143.1">IDamage</span></strong><span class="kobospan" id="kobo.144.1"> in components responsible for dealing damage will allow us to affect the </span><a id="_idIndexMarker247" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.145.1">health </span><span><span class="kobospan" id="kobo.146.1">component seamlessly:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.147.1">
namespace FusionFuryGame
{
    public interface IHealth
    {
        float MaxHealth { get; set; }   // Property for maximum health
        float CurrentHealth { get; set; }  // Property for current health
        void TakeDamage(float damage);  // Method to apply damage
        void SetMaxHealth();  // Method to set current health to max health
        void Heal();            // Method to apply healing
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.148.1">Next, we will create the </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">IDamage</span></strong><span class="kobospan" id="kobo.150.1"> interface, which will feature a central function for dealing damage. </span><span class="kobospan" id="kobo.150.2">Subsequent classes will implement this interface, handling damage calculations internally and conveying the resulting damage value to other classes, as demonstrated in the following </span><span><span class="kobospan" id="kobo.151.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.152.1">
namespace FusionFuryGame
{
    public interface IDamage
    {
        float GetDamageValue();  // Method to retrieve the damage value
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.153.1">Now, we must </span><a id="_idIndexMarker248" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.154.1">integrate the </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">IHealth</span></strong><span class="kobospan" id="kobo.156.1"> interface into the player. </span><span class="kobospan" id="kobo.156.2">Therefore, we will generate the </span><strong class="source-inline"><span class="kobospan" id="kobo.157.1">PlayerHealth</span></strong><span class="kobospan" id="kobo.158.1"> component and affix it to the player’s </span><strong class="source-inline"><span class="kobospan" id="kobo.159.1">GameObject</span></strong><span class="kobospan" id="kobo.160.1">. </span><span class="kobospan" id="kobo.160.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">PlayerHealth</span></strong><span class="kobospan" id="kobo.162.1"> class will manage all functions related to the player’s health, including setting the maximum health and processing damage. </span><span class="kobospan" id="kobo.162.2">When the player’s health falls to zero or below, the player dies. </span><span class="kobospan" id="kobo.162.3">It’s designed as a separate class that you attach to the player’s GameObject, facilitating communication with enemies, as illustrated in the following </span><span><span class="kobospan" id="kobo.163.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.164.1">
namespace FusionFuryGame
{
    public class PlayerHealth : MonoBehaviour, IHealth
    {
        public static UnityAction onPlayerDied = delegate { };
        public float startingMaxHealth = 100;  // Set a default starting maximum health for the player
        public float healInterval = 2f;  // Time interval for healing
        public float healAmount = 5f;    // Amount of healing per interval
        private WaitForSeconds healIntervalWait;  // Reusable WaitForSeconds instance
        private Coroutine healOverTimeCoroutine;
        public float MaxHealth { get; set; }
        public float CurrentHealth { get; set; }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.165.1">In the </span><a id="_idIndexMarker249" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.166.1">preceding code, I’ve included the required variables related to the player’s health and healing. </span><span class="kobospan" id="kobo.166.2">Additionally, a coroutine will ensure the player heals gradually within the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">PlayerHealth</span></strong></span><span><span class="kobospan" id="kobo.168.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.169.1">
        void OnDestroy()
        {
            // Ensure to stop the healing coroutine when the object is destroyed
            if (healOverTimeCoroutine != null)
                StopCoroutine(healOverTimeCoroutine);
        }
        void Start()
        {
            SetMaxHealth();  // Set initial max health
            healIntervalWait = new WaitForSeconds(healInterval);
            StartHealingOverTime();
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.170.1">Let’s take a look at the </span><span><span class="kobospan" id="kobo.171.1">preceding code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.172.1">OnDestroy</span></strong><span class="kobospan" id="kobo.173.1">: This method ensures that the healing coroutine is stopped when the player object is destroyed to prevent </span><span><span class="kobospan" id="kobo.174.1">memory leaks</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.175.1">Start</span></strong><span class="kobospan" id="kobo.176.1">: This method initializes the player’s health parameters, sets their maximum health, creates a </span><strong class="source-inline1"><span class="kobospan" id="kobo.177.1">WaitForSeconds</span></strong><span class="kobospan" id="kobo.178.1"> instance for healing intervals, and starts the </span><span><span class="kobospan" id="kobo.179.1">healing coroutine:</span></span></li>
</ul>
<pre class="source-code"><span class="kobospan1" id="kobo.180.1">
        public void TakeDamage(float damage)
        {
            // Implement logic to handle taking damage
            CurrentHealth -= damage;
            // Check for death or other actions based on health status
            if (CurrentHealth &lt;= 0) onPlayerDied.Invoke();
        }
        public void SetMaxHealth()
        {
            MaxHealth = startingMaxHealth;
        }
        public void Heal()
        {
            CurrentHealth += healAmount;
            CurrentHealth = Mathf.Min(CurrentHealth, MaxHealth);
        }
        private void StartHealingOverTime()
        {
            healOverTimeCoroutine = StartCoroutine(HealOverTime());
        }
        private IEnumerator HealOverTime()
        {
            while (true)
            {
                yield return healIntervalWait;
                Heal();
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.181.1">Let’s break down the </span><span><span class="kobospan" id="kobo.182.1">preceding code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.183.1">TakeDamage</span></strong><span class="kobospan" id="kobo.184.1">: This </span><a id="_idIndexMarker250" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1">method handles the logic for deducting health from the player when they take damage. </span><span class="kobospan" id="kobo.185.2">It also checks if the player’s health has reached zero, triggering the </span><strong class="source-inline1"><span class="kobospan" id="kobo.186.1">onPlayerDied</span></strong><span class="kobospan" id="kobo.187.1"> event </span><span><span class="kobospan" id="kobo.188.1">if necessary.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">SetMaxHealth</span></strong><span class="kobospan" id="kobo.190.1">: This </span><a id="_idIndexMarker251" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.191.1">method sets the maximum health of the player to the specified starting maximum </span><span><span class="kobospan" id="kobo.192.1">health value.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.193.1">Heal</span></strong><span class="kobospan" id="kobo.194.1">: This </span><a id="_idIndexMarker252" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.195.1">method restores the player’s health. </span><span class="kobospan" id="kobo.195.2">It increments the current health by the specified healing amount and ensures that the player’s current health does not exceed the </span><span><span class="kobospan" id="kobo.196.1">maximum health.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.197.1">StartHealingOverTime</span></strong><span class="kobospan" id="kobo.198.1">: This</span><a id="_idIndexMarker253" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.199.1"> method initiates the healing coroutine that’s responsible for gradually restoring the player’s health </span><span><span class="kobospan" id="kobo.200.1">over time.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">HealOverTime</span></strong><span class="kobospan" id="kobo.202.1">: This coroutine </span><a id="_idIndexMarker254" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.203.1">runs indefinitely, waiting for the specified healing interval and then invoking the </span><strong class="source-inline1"><span class="kobospan" id="kobo.204.1">Heal</span></strong><span class="kobospan" id="kobo.205.1"> method to restore the </span><span><span class="kobospan" id="kobo.206.1">player’s health.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.207.1">Now, let’s examine the </span><strong class="source-inline"><span class="kobospan" id="kobo.208.1">PlayerCollision</span></strong><span class="kobospan" id="kobo.209.1"> component and understand how the player incurs damage. </span><span class="kobospan" id="kobo.209.2">The following code block demonstrates the process of the player taking damage either directly </span><a id="_idIndexMarker255" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.210.1">from the enemy or from their projectiles. </span><span class="kobospan" id="kobo.210.2">This class acts as a bridge between the player’s health component and the </span><strong class="source-inline"><span class="kobospan" id="kobo.211.1">IDamage</span></strong><span class="kobospan" id="kobo.212.1"> interface of the colliding object. </span><span class="kobospan" id="kobo.212.2">We can utilize </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">PlayerHealth</span></strong><span class="kobospan" id="kobo.214.1"> and obtain damage through the </span><strong class="source-inline"><span class="kobospan" id="kobo.215.1">IDamage</span></strong><span class="kobospan" id="kobo.216.1"> interface by using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.217.1">OnCollisionEnter</span></strong></span><span><span class="kobospan" id="kobo.218.1"> method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.219.1">
namespace FusionFuryGame
{
    public class PlayerCollision : MonoBehaviour
    {
        private PlayerHealth playerHealth;
        private IDamage enemyDamage;
        private void Start()
        {
            playerHealth = GetComponent&lt;PlayerHealth&gt;();
        }
        private void OnCollisionEnter(Collision collision)
        {
            if (collision.gameObject.CompareTag("Enemy") || collision.gameObject.CompareTag("EnemyProjectile"))
            {
                if (collision.gameObject.TryGetComponent(out enemyDamage))
                {
                    playerHealth.TakeDamage(enemyDamage.GetDamageValue());
                }
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.220.1">Now, let’s look </span><a id="_idIndexMarker256" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.221.1">at the</span><a id="_idIndexMarker257" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.222.1"> different variables we </span><span><span class="kobospan" id="kobo.223.1">used here:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.224.1">private PlayerHealth playerHealth;</span></strong><span class="kobospan" id="kobo.225.1">: This is a reference to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.226.1">PlayerHealth</span></strong><span class="kobospan" id="kobo.227.1"> component that’s attached to the same GameObject. </span><span class="kobospan" id="kobo.227.2">This component manages the health of </span><span><span class="kobospan" id="kobo.228.1">the player.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">private IDamage enemyDamage;</span></strong><span class="kobospan" id="kobo.230.1">: This is an interface reference for handling damage inflicted by enemies or </span><span><span class="kobospan" id="kobo.231.1">enemy projectiles.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.232.1">Start</span></strong><span class="kobospan" id="kobo.233.1">: This method retrieves the </span><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">PlayerHealth</span></strong><span class="kobospan" id="kobo.235.1"> component that’s attached to the same GameObject </span><span><span class="kobospan" id="kobo.236.1">during initialization.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.237.1">OnCollisionEnter</span></strong><span class="kobospan" id="kobo.238.1">: This method is invoked automatically when a collision occurs that involves the GameObject. </span><span class="kobospan" id="kobo.238.2">It checks if the collision involves an enemy or an enemy projectile by comparing tags. </span><span class="kobospan" id="kobo.238.3">If the collision involves an enemy or an enemy projectile, it attempts to retrieve the </span><strong class="source-inline1"><span class="kobospan" id="kobo.239.1">IDamage</span></strong><span class="kobospan" id="kobo.240.1"> component from the colliding object using </span><strong class="source-inline1"><span class="kobospan" id="kobo.241.1">TryGetComponent</span></strong><span class="kobospan" id="kobo.242.1">. </span><span class="kobospan" id="kobo.242.2">If successful, it invokes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.243.1">TakeDamage</span></strong><span class="kobospan" id="kobo.244.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.245.1">PlayerHealth</span></strong><span class="kobospan" id="kobo.246.1"> component to apply damage to the </span><span><span class="kobospan" id="kobo.247.1">player’s health.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.248.1">Overall, this script handles collisions between the player character and enemy entities or enemy projectiles. </span><span class="kobospan" id="kobo.248.2">Upon collision, it retrieves the damage value from the colliding object and applies it to the player’s health, ensuring proper damage management in </span><span><span class="kobospan" id="kobo.249.1">the game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.250.1">In the next section, we will explore how the player engages in shooting enemies. </span><span class="kobospan" id="kobo.250.2">However, before delving into that, we’ll implement a shoot system to ensure both the player and the enemy can make use </span><span><span class="kobospan" id="kobo.251.1">of it.</span></span></p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor066" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.252.1">Implementing a shoot system</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.253.1">In this </span><a id="_idIndexMarker258" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.254.1">section, we’ll create classes for shooting. </span><span class="kobospan" id="kobo.254.2">Here, we’ll incorporate the </span><strong class="source-inline"><span class="kobospan" id="kobo.255.1">IDamage</span></strong><span class="kobospan" id="kobo.256.1"> interface into the </span><strong class="source-inline"><span class="kobospan" id="kobo.257.1">BaseProjectile</span></strong><span class="kobospan" id="kobo.258.1"> class, which serves as the foundation for all ammunition types. </span><span class="kobospan" id="kobo.258.2">This allows us to compute the damage that will be applied to the </span><span><span class="kobospan" id="kobo.259.1">health component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.260.1">In the following code block, we’re configuring the damage value, which will be calculated for the player or enemies. </span><span class="kobospan" id="kobo.260.2">This is a general system that can be applied to </span><span><span class="kobospan" id="kobo.261.1">all objects:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.262.1">
namespace FusionFuryGame
{
    public abstract class BaseProjectile : MonoBehaviour, IDamage
    {
        private float damage;
        public virtual void SetDamageValue(float value)
        {
            damage = value;
        }
        public float GetDamageValue()
        {
            return damage;
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.263.1">Let’s look at the </span><a id="_idIndexMarker259" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.264.1">variables that were </span><span><span class="kobospan" id="kobo.265.1">used here:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.266.1">private float damage;</span></strong><span class="kobospan" id="kobo.267.1">: This variable stores the damage value associated with </span><span><span class="kobospan" id="kobo.268.1">the projectile.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.269.1">public virtual void SetDamageValue(float value)</span></strong><span class="kobospan" id="kobo.270.1">: This method allows subclasses to set the damage value for the projectile. </span><span class="kobospan" id="kobo.270.2">It takes a float parameter value representing the damage to be set. </span><span class="kobospan" id="kobo.270.3">When called, it assigns the provided value to the damage variable. </span><span class="kobospan" id="kobo.270.4">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">virtual</span></strong><span class="kobospan" id="kobo.272.1"> keyword indicates that this method can be overridden by subclasses to provide specialized behavior </span><span><span class="kobospan" id="kobo.273.1">if needed.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.274.1">GetDamageValue Method</span></strong><span class="kobospan" id="kobo.275.1">: This method retrieves the damage value of the projectile. </span><span class="kobospan" id="kobo.275.2">It simply returns the value stored in the </span><span><span class="kobospan" id="kobo.276.1">damage variable.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.277.1">Overall, this abstract class provides a blueprint for projectile objects in the game. </span><span class="kobospan" id="kobo.277.2">Subclasses can inherit from this class and customize the behavior of projectiles by overriding the </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">SetDamageValue</span></strong><span class="kobospan" id="kobo.279.1"> method or adding additional functionality as needed. </span><span class="kobospan" id="kobo.279.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">GetDamageValue</span></strong><span class="kobospan" id="kobo.281.1"> method allows other game components to access the damage value of projectiles when needed, enabling consistent damage handling throughout </span><span><span class="kobospan" id="kobo.282.1">the game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.283.1">Next, we can create the </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">BaseWeapon</span></strong><span class="kobospan" id="kobo.285.1"> script, which is versatile enough to be utilized by both players and enemies, considering that enemies will also possess weapons. </span><span class="kobospan" id="kobo.285.2">Each weapon will be associated with an attached projectile, allowing for the creation of various </span><span><span class="kobospan" id="kobo.286.1">projectile types.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.287.1">Additionally, there</span><a id="_idIndexMarker260" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.288.1"> is the concept of </span><strong class="source-inline"><span class="kobospan" id="kobo.289.1">weaponPower</span></strong><span class="kobospan" id="kobo.290.1">, a variable that varies from one weapon to another, influencing the applied damage. </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">muzzleTransform</span></strong><span class="kobospan" id="kobo.292.1"> serves as the point for shooting projectiles, and </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">projectileForce</span></strong><span class="kobospan" id="kobo.294.1"> dictates the movement of </span><span><span class="kobospan" id="kobo.295.1">the projectile.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.296.1">Lastly, we must define the </span><strong class="source-inline"><span class="kobospan" id="kobo.297.1">Shoot</span></strong><span class="kobospan" id="kobo.298.1"> function, as illustrated in the following </span><span><span class="kobospan" id="kobo.299.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.300.1">
namespace FusionFuryGame
{
    public abstract class BaseWeapon : MonoBehaviour
    {
        [SerializeField] protected BaseProjectile attachedProjectile;
        [SerializeField] protected float weaponPower;
        [SerializeField] protected Transform muzzleTransform;
        [SerializeField] protected float projectileForce;
        public virtual void Shoot( float fireDamage)
        {
          // Instantiate the projectile from the object pool
          GameObject projectileObject = ObjectPoolManager.Instance.GetPooledObject(attachedProjectile.tag);
          if (projectileObject != null)
          {
            // Set the position of the projectile to the gun's muzzle position
            projectileObject.transform.position = muzzleTransform.position;
            // Get the rigid body component from the projectile
            Rigidbody projectileRb = projectileObject.GetComponent&lt;Rigidbody&gt;();
            if (projectileRb != null)
            {
               // Apply force to the projectile in the forward vector of the weapon
               projectileRb.AddForce(muzzleTransform.forward * projectileForce, ForceMode.Impulse);
               // Modify the fire damage by adding the current weapon's power
               float modifiedDamage = fireDamage + weaponPower;
               // Apply damage and other logic to the projectile (consider implementing IDamage interface)
               attachedProjectile.SetDamageValue(modifiedDamage);
            }
            else
            {
               // Handle if the projectile doesn't have a rigid body
               Debug.LogWarning("Projectile prefab is missing Rigidbody component.");
            }
          }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.301.1">Let’s look at the </span><a id="_idIndexMarker261" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.302.1">serialized fields:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.303.1">protected BaseProjectile attachedProjectile</span></strong><span class="kobospan" id="kobo.304.1">: This refers to the type of projectile attached to the weapon. </span><span class="kobospan" id="kobo.304.2">It is serialized to allow assignment in Unity’s </span><span><strong class="bold"><span class="kobospan" id="kobo.305.1">Inspector</span></strong></span><span><span class="kobospan" id="kobo.306.1"> view.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">protected float weaponPower</span></strong><span class="kobospan" id="kobo.308.1">: This refers to the power of the weapon. </span><span class="kobospan" id="kobo.308.2">It is serialized to allow for adjustments in the </span><span><strong class="bold"><span class="kobospan" id="kobo.309.1">Inspector</span></strong></span><span><span class="kobospan" id="kobo.310.1"> view.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.311.1">protected Transform muzzleTransform</span></strong><span class="kobospan" id="kobo.312.1">: This refers to the position where projectiles spawn, typically the muzzle of </span><span><span class="kobospan" id="kobo.313.1">the weapon.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.314.1">protected float projectileForce</span></strong><span class="kobospan" id="kobo.315.1">: This refers to the force that’s applied to the projectile when it’s shot from </span><span><span class="kobospan" id="kobo.316.1">the weapon.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.317.1">Shoot</span></strong><span class="kobospan" id="kobo.318.1">: This method is responsible for shooting the weapon. </span><span class="kobospan" id="kobo.318.2">First, it attempts to get a pooled projectile object from Object Pool Manager. </span><span class="kobospan" id="kobo.318.3">If a projectile object is retrieved, it sets its position to the muzzle of the weapon and adds force to propel it forward. </span><span class="kobospan" id="kobo.318.4">This method also modifies the fire damage by adding the weapon’s power to it. </span><span class="kobospan" id="kobo.318.5">Finally, it applies the modified damage and any other logic to the projectile, potentially by implementing an </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.319.1">IDamage</span></strong></span><span><span class="kobospan" id="kobo.320.1"> interface.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.321.1">Overall, this abstract class provides a foundation for implementing different types of weapons in the game. </span><span class="kobospan" id="kobo.321.2">Subclasses can inherit from this class to create specific weapon types and customize their behavior as needed. </span><span class="kobospan" id="kobo.321.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">Shoot</span></strong><span class="kobospan" id="kobo.323.1"> method handles the spawning and firing of projectiles, allowing for flexible and dynamic </span><span><span class="kobospan" id="kobo.324.1">weapon functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">The following code</span><a id="_idIndexMarker262" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.326.1"> block provides an example of utilizing </span><strong class="source-inline"><span class="kobospan" id="kobo.327.1">BaseWeapon</span></strong><span class="kobospan" id="kobo.328.1"> with the </span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">SimpleGun</span></strong><span class="kobospan" id="kobo.330.1"> class. </span><span class="kobospan" id="kobo.330.2">We’re going to use it with the player for shooting enemies, so it will be used as the </span><span><span class="kobospan" id="kobo.331.1">player’s weapon:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.332.1">
namespace FusionFuryGame
{
    public class SimpleGun : BaseWeapon
    {
        public override void Shoot( float fireDamage)
        {
            base.Shoot( fireDamage );
            //Add here special logic for the gun if needed
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.333.1">Let’s break down </span><span><span class="kobospan" id="kobo.334.1">the code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.335.1">SimpleGun</span></strong><span class="kobospan" id="kobo.336.1">: This class represents a specific type of gun in the game. </span><span class="kobospan" id="kobo.336.2">It inherits from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.337.1">BaseWeapon</span></strong><span class="kobospan" id="kobo.338.1"> class, indicating that it shares characteristics and functionality with other weapons but may have </span><span><span class="kobospan" id="kobo.339.1">specialized behavior.</span></span></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.340.1">Override Shoot</span></strong></span><span><span class="kobospan" id="kobo.341.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.342.1">public override void Shoot(float fireDamage)</span></strong><span class="kobospan" id="kobo.343.1">: This method overrides the </span><strong class="source-inline1"><span class="kobospan" id="kobo.344.1">Shoot</span></strong><span class="kobospan" id="kobo.345.1"> method defined in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">BaseWeapon</span></strong></span><span><span class="kobospan" id="kobo.347.1"> class</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.348.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.349.1">base.Shoot(fireDamage)</span></strong><span class="kobospan" id="kobo.350.1"> statement calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.351.1">Shoot</span></strong><span class="kobospan" id="kobo.352.1"> method from the base class (</span><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">BaseWeapon</span></strong><span class="kobospan" id="kobo.354.1">), allowing the gun to perform the standard shooting behavior defined in the </span><span><span class="kobospan" id="kobo.355.1">base class</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.356.1">In summary, the </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">SimpleGun</span></strong><span class="kobospan" id="kobo.358.1"> class extends the functionality of the </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">BaseWeapon </span></strong><span class="kobospan" id="kobo.360.1">class by providing its own implementation of the </span><strong class="source-inline"><span class="kobospan" id="kobo.361.1">Shoot</span></strong><span class="kobospan" id="kobo.362.1"> method. </span><span class="kobospan" id="kobo.362.2">This allows for specialized behavior while leveraging the common functionality provided by the </span><span><span class="kobospan" id="kobo.363.1">base class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.364.1">Now, let’s present the </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">PlayerShoot</span></strong><span class="kobospan" id="kobo.366.1"> component, which encompasses the shooting logic. </span><span class="kobospan" id="kobo.366.2">In this context, the </span><a id="_idIndexMarker263" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.367.1">player awaits input actions and possesses the current weapon. </span><span class="kobospan" id="kobo.367.2">In </span><a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.368.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.369.1">, which focuses on data handling, we’ll create scriptable objects for weapon statistics. </span><span class="kobospan" id="kobo.369.2">This way, we can substitute the weapon’s power with the weapon’s stats, utilizing the power derived from it. </span><span class="kobospan" id="kobo.369.3">We can also make different stats for the same weapon, as illustrated in the following </span><span><span class="kobospan" id="kobo.370.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.371.1">
namespace FusionFuryGame {
    public class PlayerShoot : MonoBehaviour
    {
        public static UnityAction onFire = delegate { };
        [SerializeField] BaseWeapon currentWeapon;
        [SerializeField] private float fireDamage;
        [SerializeField] private float shootingInterval = 0.5f;  // Set the shooting interval in seconds
        private float timeSinceLastShot = 0f;
        private void Update()
        {
            timeSinceLastShot += Time.deltaTime;
        }
        private void OnEnable()
        {
            PlayerInput.onShoot += OnShootFire;
        }
        private void OnDisable()
        {
            PlayerInput.onShoot -= OnShootFire;
        }
        private void OnShootFire()
        {
            // Check if enough time has passed since the last shot
            if (timeSinceLastShot &gt;= shootingInterval)
            {
                // Shoot in the forward vector of the weapon and pass player power stat
                currentWeapon.Shoot(fireDamage);
                // Reset the timer
                timeSinceLastShot = 0f;
                // Invoke the onFire event
                onFire.Invoke();
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.372.1"> Let’s break down the </span><a id="_idIndexMarker264" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.373.1">preceding code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.374.1">onFire Event</span></strong></span><span><span class="kobospan" id="kobo.375.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.376.1">public static UnityAction onFire = delegate { };</span></strong><span class="kobospan" id="kobo.377.1">: This static event is triggered whenever the player fires a shot. </span><span class="kobospan" id="kobo.377.2">Other scripts can subscribe to this event to perform actions when the </span><span><span class="kobospan" id="kobo.378.1">player shoots.</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.379.1">Serialized fields</span></strong></span><span><span class="kobospan" id="kobo.380.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.381.1">currentWeapon</span></strong><span class="kobospan" id="kobo.382.1">: This field holds a reference to the current weapon the player </span><span><span class="kobospan" id="kobo.383.1">is using</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.384.1">fireDamage</span></strong><span class="kobospan" id="kobo.385.1">: This field represents the damage value of the </span><span><span class="kobospan" id="kobo.386.1">player’s shots</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.387.1">shootingInterval</span></strong><span class="kobospan" id="kobo.388.1">: This field specifies the time interval between </span><span><span class="kobospan" id="kobo.389.1">consecutive shots</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.390.1">Event subscriptions</span></strong></span><span><span class="kobospan" id="kobo.391.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.392.1">OnEnable()</span></strong><span class="kobospan" id="kobo.393.1">: Subscribes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.394.1">OnShootFire</span></strong><span class="kobospan" id="kobo.395.1"> method to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.396.1">onShoot</span></strong><span class="kobospan" id="kobo.397.1"> event when the object </span><span><span class="kobospan" id="kobo.398.1">is enabled</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.399.1">OnDisable()</span></strong><span class="kobospan" id="kobo.400.1">: Unsubscribes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">OnShootFire</span></strong><span class="kobospan" id="kobo.402.1"> method from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.403.1">onShoot</span></strong><span class="kobospan" id="kobo.404.1"> event when the object </span><span><span class="kobospan" id="kobo.405.1">is disabled</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.406.1">OnShootFire</span></strong><span class="kobospan" id="kobo.407.1">: This method is invoked when the player performs a shoot action (</span><strong class="source-inline1"><span class="kobospan" id="kobo.408.1">onShoot event</span></strong><span class="kobospan" id="kobo.409.1">). </span><span class="kobospan" id="kobo.409.2">It checks if enough time has passed since the last shot. </span><span class="kobospan" id="kobo.409.3">If so, it triggers the </span><strong class="source-inline1"><span class="kobospan" id="kobo.410.1">Shoot</span></strong><span class="kobospan" id="kobo.411.1"> method of the current weapon, resets the shot timer, and invokes the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.412.1">onFire</span></strong></span><span><span class="kobospan" id="kobo.413.1"> event.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.414.1">Overall, the </span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">PlayerShoot</span></strong><span class="kobospan" id="kobo.416.1"> class facilitates player shooting mechanics by controlling the shooting interval, managing events for shooting actions, and delegating the shooting logic to the </span><span><span class="kobospan" id="kobo.417.1">current weapon.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.418.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.419.1">Make sure that you assign distinct tags to projectiles associated with both the player and the enemies. </span><span class="kobospan" id="kobo.419.2">This prevents conflicts when they collide with </span><span><span class="kobospan" id="kobo.420.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.421.1">Currently, the </span><a id="_idIndexMarker265" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.422.1">player possesses the capability to both shoot and endure damage. </span><span class="kobospan" id="kobo.422.2">In the following subsection, we will delve into the AI logic for </span><span><span class="kobospan" id="kobo.423.1">our game.</span></span></p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor067" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.424.1">Delving into the AI logic</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">Welcome to the world </span><a id="_idIndexMarker266" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.426.1">of </span><strong class="bold"><span class="kobospan" id="kobo.427.1">AI logic</span></strong><span class="kobospan" id="kobo.428.1">! </span><span class="kobospan" id="kobo.428.2">In this section, we’ll explore the algorithms and decision-making processes that bring intelligence to our game characters. </span><span class="kobospan" id="kobo.428.3">We’ll discover how AI logic enhances navigation, strategy, and dynamic interactions, elevating the overall gaming experience. </span><span class="kobospan" id="kobo.428.4">Join us as we unravel the secrets behind crafting smart behaviors for a more immersive virtual world. </span><span class="kobospan" id="kobo.428.5">Plus, we’ll delve into the implementation of a finite state machine to create distinct states for all enemies, allowing seamless transitions </span><span><span class="kobospan" id="kobo.429.1">between behaviors.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.430.1"> In the upcoming steps, we’ll integrate the </span><strong class="source-inline"><span class="kobospan" id="kobo.431.1">NavMesh</span></strong><span class="kobospan" id="kobo.432.1"> package into our project. </span><span class="kobospan" id="kobo.432.2">However, before delving into AI logic, it’s essential to include the navigation package in the project. </span><span class="kobospan" id="kobo.432.3">Follow these steps to </span><span><span class="kobospan" id="kobo.433.1">do so:</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.434.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.435.1">Before Unity 2022, navigation was pre-implemented; however, starting from Unity 2022, it must be added via </span><span><span class="kobospan" id="kobo.436.1">Package Manager.</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.437.1">Access </span><strong class="bold"><span class="kobospan" id="kobo.438.1">Package Manager</span></strong><span class="kobospan" id="kobo.439.1"> to install the </span><strong class="bold"><span class="kobospan" id="kobo.440.1">AI Navigation</span></strong><span class="kobospan" id="kobo.441.1"> package, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.442.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.443.1">.1</span></em></span><span><span class="kobospan" id="kobo.444.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer047">
<span class="kobospan" id="kobo.445.1"><img alt="Figure 4.1 – Installing AI Navigation via Package Manager" src="image/B22017_04_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.446.1">Figure 4.1 – Installing AI Navigation via Package Manager</span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.447.1">Following the </span><a id="_idIndexMarker267" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.448.1">installation, you’ll notice a new menu that allows you to toggle the visibility of </span><strong class="bold"><span class="kobospan" id="kobo.449.1">NavMesh</span></strong><span class="kobospan" id="kobo.450.1"> surfaces and access other options concerning </span><strong class="bold"><span class="kobospan" id="kobo.451.1">AI Navigation</span></strong><span class="kobospan" id="kobo.452.1">. </span><span class="kobospan" id="kobo.452.2">This menu is integrated into the </span><em class="italic"><span class="kobospan" id="kobo.453.1">scene toolbar</span></em><span class="kobospan" id="kobo.454.1">, as illustrated in </span><span><em class="italic"><span class="kobospan" id="kobo.455.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.456.1">.2</span></em></span><span><span class="kobospan" id="kobo.457.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer048">
<span class="kobospan" id="kobo.458.1"><img alt="Figure 4.2 – The AI Navigation menu in the Scene view" src="image/B22017_04_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.459.1">Figure 4.2 – The AI Navigation menu in the Scene view</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.460.1">Additional reading</span></p>
<p class="callout"><span class="kobospan" id="kobo.461.1">You can explore the </span><strong class="bold"><span class="kobospan" id="kobo.462.1">AI Navigation</span></strong><span class="kobospan" id="kobo.463.1"> settings or find more information in the official Unity </span><span><span class="kobospan" id="kobo.464.1">documentation: </span></span><a href="https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.465.1">https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html</span></span></a><span><span class="kobospan" id="kobo.466.1">.</span></span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.467.1">To begin </span><a id="_idIndexMarker268" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.468.1">utilizing this feature, we’ll need to incorporate a </span><strong class="bold"><span class="kobospan" id="kobo.469.1">NavMesh Surface</span></strong><span class="kobospan" id="kobo.470.1"> property into the scene. </span><span class="kobospan" id="kobo.470.2">You can choose this from the </span><strong class="bold"><span class="kobospan" id="kobo.471.1">Create</span></strong><span class="kobospan" id="kobo.472.1"> menu, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.473.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.474.1">.3</span></em></span><span><span class="kobospan" id="kobo.475.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer049">
<span class="kobospan" id="kobo.476.1"><img alt="Figure 4.3 – Choosing NavMesh Surface from the Create menu" src="image/B22017_04_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.477.1">Figure 4.3 – Choosing NavMesh Surface from the Create menu</span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.478.1">Subsequently, </span><strong class="bold"><span class="kobospan" id="kobo.479.1">NavMesh Surface</span></strong><span class="kobospan" id="kobo.480.1"> will be included, at which point you can proceed to </span><strong class="bold"><span class="kobospan" id="kobo.481.1">Bake</span></strong><span class="kobospan" id="kobo.482.1"> the surface. </span><span class="kobospan" id="kobo.482.2">This refers to the process of precomputing and storing navigation </span><a id="_idIndexMarker269" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.483.1">data for AI pathfinding, as demonstrated in </span><span><em class="italic"><span class="kobospan" id="kobo.484.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.485.1">.4</span></em></span><span><span class="kobospan" id="kobo.486.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer050">
<span class="kobospan" id="kobo.487.1"><img alt="Figure 4.4 – The Bake action in the NavMeshSurface component" src="image/B22017_04_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.488.1">Figure 4.4 – The Bake action in the NavMeshSurface component</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.489.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.490.1">Before initiating the baking process, it’s crucial to remove the player and dynamic objects to prevent the creation of empty spaces in the </span><span><span class="kobospan" id="kobo.491.1">resulting baking.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.492.1">You can also include additional AI agents by navigating to the </span><strong class="bold"><span class="kobospan" id="kobo.493.1">Navigation</span></strong><span class="kobospan" id="kobo.494.1"> tab under </span><strong class="bold"><span class="kobospan" id="kobo.495.1">Window</span></strong><span class="kobospan" id="kobo.496.1"> in the top bar. </span><span class="kobospan" id="kobo.496.2">Choose </span><strong class="bold"><span class="kobospan" id="kobo.497.1">AI</span></strong><span class="kobospan" id="kobo.498.1"> and then </span><strong class="bold"><span class="kobospan" id="kobo.499.1">Navigation</span></strong><span class="kobospan" id="kobo.500.1">, avoiding the </span><strong class="bold"><span class="kobospan" id="kobo.501.1">Navigation (Obsolete)</span></strong><span class="kobospan" id="kobo.502.1"> option, as illustrated in </span><span><em class="italic"><span class="kobospan" id="kobo.503.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.504.1">.5</span></em></span><span><span class="kobospan" id="kobo.505.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer051">
<span class="kobospan" id="kobo.506.1"><img alt="Figure 4.5 – Selecting Navigation" src="image/B22017_04_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.507.1">Figure 4.5 – Selecting Navigation</span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.508.1">In the </span><strong class="bold"><span class="kobospan" id="kobo.509.1">Navigation</span></strong><span class="kobospan" id="kobo.510.1"> tab, you </span><a id="_idIndexMarker270" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.511.1">have the option to include more </span><strong class="bold"><span class="kobospan" id="kobo.512.1">Agents</span></strong><span class="kobospan" id="kobo.513.1"> with various settings, allowing for increased diversity in enemy behavior, as depicted in </span><span><em class="italic"><span class="kobospan" id="kobo.514.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.515.1">.6</span></em></span><span><span class="kobospan" id="kobo.516.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer052">
<span class="kobospan" id="kobo.517.1"><img alt="Figure 4.6 – Adding more agents via the Navigation tab" src="image/B22017_04_06.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.518.1">Figure 4.6 – Adding more agents via the Navigation tab</span></p>
<ol class="calibre15">
<li value="7" class="calibre11"><span class="kobospan" id="kobo.519.1">Additionally, you </span><a id="_idIndexMarker271" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.520.1">have the flexibility to introduce more </span><strong class="bold"><span class="kobospan" id="kobo.521.1">Areas</span></strong><span class="kobospan" id="kobo.522.1">, providing variations in your gameplay. </span><span class="kobospan" id="kobo.522.2">As shown in the following screenshot, you can designate areas as </span><strong class="bold"><span class="kobospan" id="kobo.523.1">Walkable</span></strong><span class="kobospan" id="kobo.524.1">, </span><strong class="bold"><span class="kobospan" id="kobo.525.1">Not Walkable</span></strong><span class="kobospan" id="kobo.526.1">, or even as </span><strong class="bold"><span class="kobospan" id="kobo.527.1">Jump</span></strong><span class="kobospan" id="kobo.528.1"> areas, tailoring them to the specific requirements of </span><span><span class="kobospan" id="kobo.529.1">your game:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer053">
<span class="kobospan" id="kobo.530.1"><img alt="Figure 4.7 – Areas in the Navigation tab" src="image/B22017_04_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.531.1">Figure 4.7 – Areas in the Navigation tab</span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.532.1">Now that we’ve familiarized ourselves with adding additional areas or agents, we won’t be </span><a id="_idIndexMarker272" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.533.1">making further modifications to them. </span><span class="kobospan" id="kobo.533.2">I’ve mentioned them for informational purposes only. </span><span class="kobospan" id="kobo.533.3">Now, let’s proceed with integrating AI into our game. </span><span class="kobospan" id="kobo.533.4">To do so, we must attach the </span><strong class="bold"><span class="kobospan" id="kobo.534.1">Nav Mesh Agent</span></strong><span class="kobospan" id="kobo.535.1"> component to the enemies to enable navigation, as illustrated in </span><span><em class="italic"><span class="kobospan" id="kobo.536.1">Figure 4</span></em></span><em class="italic"><span class="kobospan" id="kobo.537.1">.8</span></em><span class="kobospan" id="kobo.538.1">. </span><span class="kobospan" id="kobo.538.2">We have the flexibility to adjust values tailored to our game, such as changing the speed and when the AI will stop when the AI has reached its goal. </span><span class="kobospan" id="kobo.538.3">For further details, please refer to the official </span><span><em class="italic"><span class="kobospan" id="kobo.539.1">Unity documentation</span></em></span><span><span class="kobospan" id="kobo.540.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer054">
<span class="kobospan" id="kobo.541.1"><img alt="Figure 4.8 – The Nav Mesh Agent component for one of the enemies" src="image/B22017_04_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.542.1">Figure 4.8 – The Nav Mesh Agent component for one of the enemies</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.543.1">After installing the package, we’ll kick off the AI logic. </span><span class="kobospan" id="kobo.543.2">We’ll begin by establishing the </span><strong class="source-inline"><span class="kobospan" id="kobo.544.1">BaseEnemy</span></strong><span class="kobospan" id="kobo.545.1"> class and </span><a id="_idIndexMarker273" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.546.1">laying down the foundation for the state system since we intend to construct a finite </span><span><span class="kobospan" id="kobo.547.1">state machine.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.548.1">Let’s start with the interface for states. </span><span class="kobospan" id="kobo.548.2">The foundational structure is provided in the following </span><span><span class="kobospan" id="kobo.549.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.550.1">
namespace FusionFuryGame
{
    public interface IEnemyState
    {
        void EnterState(BaseEnemy enemy);
        void UpdateState(BaseEnemy enemy);
        void ExitState(BaseEnemy enemy);
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.551.1">Let’s take a closer look at </span><span><span class="kobospan" id="kobo.552.1">this code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.553.1">void </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.554.1">EnterState(BaseEnemy enemy)</span></strong></span><span><span class="kobospan" id="kobo.555.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.556.1">This method is responsible for setting up the initial conditions and behaviors when the enemy enters this state. </span><span class="kobospan" id="kobo.556.2">It takes a </span><strong class="source-inline1"><span class="kobospan" id="kobo.557.1">BaseEnemy</span></strong><span class="kobospan" id="kobo.558.1"> object as a parameter, allowing us to access the enemy’s properties </span><span><span class="kobospan" id="kobo.559.1">and methods.</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.560.1">void </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.561.1">UpdateState(BaseEnemy enemy)</span></strong></span><span><span class="kobospan" id="kobo.562.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.563.1">This method is called repeatedly while the enemy is in this state. </span><span class="kobospan" id="kobo.563.2">It defines the logic and actions that the enemy should perform during this state. </span><span class="kobospan" id="kobo.563.3">Again, it takes a </span><strong class="source-inline1"><span class="kobospan" id="kobo.564.1">BaseEnemy</span></strong><span class="kobospan" id="kobo.565.1"> object as a parameter to manipulate the </span><span><span class="kobospan" id="kobo.566.1">enemy’s behavior.</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.567.1">void </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.568.1">ExitState(BaseEnemy enemy)</span></strong></span><span><span class="kobospan" id="kobo.569.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.570.1">This method is called when the enemy exits this state. </span><span class="kobospan" id="kobo.570.2">It is responsible for cleaning up any resources or resetting any variables associated with this state. </span><span class="kobospan" id="kobo.570.3">As with the other methods, it also accepts a </span><strong class="source-inline1"><span class="kobospan" id="kobo.571.1">BaseEnemy</span></strong> <span><span class="kobospan" id="kobo.572.1">object parameter.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.573.1">By implementing</span><a id="_idIndexMarker274" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.574.1"> this interface, different classes representing specific enemy states can define their unique behavior for entering, updating, and exiting those states. </span><span class="kobospan" id="kobo.574.2">This approach allows for modular and organized management of enemy behavior, making it easier to add, remove, or modify states as needed within </span><span><span class="kobospan" id="kobo.575.1">the game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.576.1">Let’s move on to creating enemy components, starting with: </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">EnemyHealth</span></strong><span class="kobospan" id="kobo.578.1">. </span><span class="kobospan" id="kobo.578.2">This component will integrate the </span><strong class="source-inline"><span class="kobospan" id="kobo.579.1">IHealth</span></strong><span class="kobospan" id="kobo.580.1"> interface and handle all health-related logic for enemies. </span><span class="kobospan" id="kobo.580.2">Check out the following </span><span><span class="kobospan" id="kobo.581.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.582.1">
    public class EnemyHealth : MonoBehaviour, IHealth
    {
        [SerializeField] float startingMaxHealth = 100;  // Set a default starting maximum health for the Enemy
        private float maxHealth;
        private float currentHealth;
        [SerializeField] float healAmount = 5f;    // Amount of healing per interval
        [SerializeField] float healInterval = 2f;  // Time interval for healing
        private WaitForSeconds healIntervalWait;  // Reusable WaitForSeconds instance
        private Coroutine healOverTimeCoroutine;
        public UnityAction onEnemyDied = delegate { };
        public float MaxHealth
        {
            get { return maxHealth; }
            set { maxHealth = value; }
        }
        public float CurrentHealth
        {
            get { return currentHealth; }
            set
            {
                currentHealth = Mathf.Clamp(value, 0, MaxHealth);
                if (currentHealth &lt;= 0)
                {
                    onEnemyDied.Invoke();
                }
            }
        }
        private void Start()
        {
            SetMaxHealth();  // Set initial max health
            healIntervalWait = new WaitForSeconds(healInterval);
            StartHealingOverTime();
        }
        public void SetMaxHealth()
        {
            MaxHealth = startingMaxHealth;
        }
        public void TakeDamage(float damage)
        {
            // Implement logic to handle taking damage
            CurrentHealth -= damage;
        }
        //we can also just heal in some states only
        public void Heal()
        {
            CurrentHealth += healAmount;
            CurrentHealth = Mathf.Min(CurrentHealth, MaxHealth);
        }
        private void StartHealingOverTime()
        {
            healOverTimeCoroutine = StartCoroutine(HealOverTime());
        }
        private IEnumerator HealOverTime()
        {
            while (true)
            {
                yield return healIntervalWait;
                Heal();
            }
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.583.1">Let’s understand </span><a id="_idIndexMarker275" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.584.1">the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">EnemyHealth</span></strong></span><span><span class="kobospan" id="kobo.586.1"> component:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.587.1">startingMaxHealth</span></strong><span class="kobospan" id="kobo.588.1">: Default starting maximum health for </span><span><span class="kobospan" id="kobo.589.1">the enemy.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.590.1">healAmount</span></strong><span class="kobospan" id="kobo.591.1">: Amount of healing </span><span><span class="kobospan" id="kobo.592.1">per interval</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.593.1">healInterval</span></strong><span class="kobospan" id="kobo.594.1">: Time interval </span><span><span class="kobospan" id="kobo.595.1">for healing</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.596.1">healIntervalWait</span></strong><span class="kobospan" id="kobo.597.1">: Reusable </span><strong class="source-inline1"><span class="kobospan" id="kobo.598.1">WaitForSeconds</span></strong><span class="kobospan" id="kobo.599.1"> instance </span><span><span class="kobospan" id="kobo.600.1">for healing</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.601.1">healOverTimeCoroutine</span></strong><span class="kobospan" id="kobo.602.1">: Coroutine for healing </span><span><span class="kobospan" id="kobo.603.1">over time</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.604.1">maxHealth</span></strong><span class="kobospan" id="kobo.605.1">: Maximum health of </span><span><span class="kobospan" id="kobo.606.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.607.1">currentHealth</span></strong><span class="kobospan" id="kobo.608.1">: Current health of </span><span><span class="kobospan" id="kobo.609.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.610.1">TakeDamage(float damage)</span></strong><span class="kobospan" id="kobo.611.1">: Handles damage taken by </span><span><span class="kobospan" id="kobo.612.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.613.1">SetMaxHealth()</span></strong><span class="kobospan" id="kobo.614.1">: Sets the maximum health of </span><span><span class="kobospan" id="kobo.615.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.616.1">Heal()</span></strong><span class="kobospan" id="kobo.617.1">: Heals the enemy </span><span><span class="kobospan" id="kobo.618.1">over time</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.619.1">StartHealingOverTime()</span></strong><span class="kobospan" id="kobo.620.1">: Starts the coroutine for healing </span><span><span class="kobospan" id="kobo.621.1">over time</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.622.1">HealOverTime()</span></strong><span class="kobospan" id="kobo.623.1">: The coroutine method for healing </span><span><span class="kobospan" id="kobo.624.1">over time</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">Next up is </span><a id="_idIndexMarker276" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.626.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">EnemyAnimations</span></strong><span class="kobospan" id="kobo.628.1"> component, which is responsible for managing the animations of the enemy. </span><span class="kobospan" id="kobo.628.2">Let’s delve into its </span><span><span class="kobospan" id="kobo.629.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.630.1">
  public class EnemyAnimations : MonoBehaviour
  {
      private Animator animator;
      private void Start()
      {
          animator = GetComponent&lt;Animator&gt;();
      }
      public void StartAttackAnimations()
      {
          animator.SetBool("IsAttacking", true);
      }
      public void StopAttackAnimations()
      {
          animator.SetBool("IsAttacking", false);
      }
  }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.631.1">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">StartAttackAnimations()</span></strong><span class="kobospan" id="kobo.633.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.634.1">StopAttackAnimations()</span></strong><span class="kobospan" id="kobo.635.1"> manage </span><span><span class="kobospan" id="kobo.636.1">attack animations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.637.1">Next, we’ll implement</span><a id="_idIndexMarker277" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.638.1"> the collision logic for the enemy in the </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">EnemyCollision</span></strong><span class="kobospan" id="kobo.640.1"> class. </span><span class="kobospan" id="kobo.640.2">This class will handle collisions with the player, allowing the enemy to take damage. </span><span class="kobospan" id="kobo.640.3">Look at the following code block </span><span><span class="kobospan" id="kobo.641.1">for details:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.642.1">
    public class EnemyCollision : MonoBehaviour
    {
        private IDamage playerDamage;
        private EnemyHealth healthComponent;
        private void Start()
        {
            healthComponent = GetComponent&lt;EnemyHealth&gt;();
        }
        //we can also make layers for them and reduce calculations of collision in layer matrix in project settings
        private void OnCollisionEnter(Collision collision)
        {
            if (collision.gameObject.CompareTag("PlayerProjectile"))
            {
                if (collision.gameObject.TryGetComponent(out playerDamage))
                {
                    healthComponent.TakeDamage(playerDamage.GetDamageValue());
                }
            }
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.643.1"> Let’s look at </span><a id="_idIndexMarker278" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.644.1">what the </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">EnemyCollision</span></strong> <span><span class="kobospan" id="kobo.646.1">class does:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.647.1">playerDamage</span></strong><span class="kobospan" id="kobo.648.1">: Represents the damage that’s inflicted by </span><span><span class="kobospan" id="kobo.649.1">the player</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.650.1">damage</span></strong><span class="kobospan" id="kobo.651.1">: Damage inflicted when the enemy collides with </span><span><span class="kobospan" id="kobo.652.1">the player</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.653.1">OnCollisionEnter(Collision collision)</span></strong><span class="kobospan" id="kobo.654.1">: Handles collisions with </span><span><span class="kobospan" id="kobo.655.1">player projectiles</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.656.1">The final component in the enemy’s logic is </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">EnemyShoot</span></strong><span class="kobospan" id="kobo.658.1">. </span><span class="kobospan" id="kobo.658.2">It’s responsible for firing projectiles using the attached weapon. </span><span class="kobospan" id="kobo.658.3">Implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.659.1">IDamage</span></strong><span class="kobospan" id="kobo.660.1"> interface here so that it will pass the damage value to the player. </span><span class="kobospan" id="kobo.660.2">Refer to the following code block </span><span><span class="kobospan" id="kobo.661.1">for details:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.662.1">
    public class EnemyShoot : MonoBehaviour , IDamage
    {
        [SerializeField] float damage; //when the enemy collide with the player
        public BaseWeapon attachedWeapon;  // Reference to the attacted Weapon
        [SerializeField] float fireDamage; //when the enemy shoot the player
        public void FireProjectile()
        {
            attachedWeapon.Shoot(fireDamage);
        }
        public float GetDamageValue()
        {
            // You can implement more sophisticated logic here based on enemy stats
            return damage;
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.663.1">Let’s look at </span><a id="_idIndexMarker279" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.664.1">what </span><span><strong class="source-inline"><span class="kobospan" id="kobo.665.1">EnemyShoot</span></strong></span><span><span class="kobospan" id="kobo.666.1"> does:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.667.1">fireDamage</span></strong><span class="kobospan" id="kobo.668.1">: Damage inflicted when the enemy shoots </span><span><span class="kobospan" id="kobo.669.1">the player</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.670.1">attachedWeapon</span></strong><span class="kobospan" id="kobo.671.1">: Reference to the attached weapon of </span><span><span class="kobospan" id="kobo.672.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.673.1">FireProjectile()</span></strong><span class="kobospan" id="kobo.674.1">: Initiates the firing of the </span><span><span class="kobospan" id="kobo.675.1">attached weapon</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.676.1">GetDamageValue()</span></strong><span class="kobospan" id="kobo.677.1">: Retrieves the </span><span><span class="kobospan" id="kobo.678.1">damage value</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.679.1">Now, let’s create the </span><strong class="source-inline"><span class="kobospan" id="kobo.680.1">BaseEnemy</span></strong><span class="kobospan" id="kobo.681.1"> class is an abstract class that defines the basic functionality and attributes of an enemy in a game. </span><span class="kobospan" id="kobo.681.2">It will utilize state machine logic and contain references for the shooting and animation components of the enemies. </span><span class="kobospan" id="kobo.681.3">This class facilitates communication between different states of the enemy, making it suitable for use with </span><span><span class="kobospan" id="kobo.682.1">all enemies:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.683.1">
[RequireComponent(typeof(EnemyHealth) , typeof(EnemyAnimations) , typeof(EnemyShoot)) ]
    [RequireComponent(typeof(EnemyCollision))]
    public abstract class BaseEnemy : MonoBehaviour
    {
        public Transform player;
        [HideInInspector] public NavMeshAgent navMeshAgent;
        // Reference to the current state
        protected IEnemyState currentState;
        // Define the different states
        public IEnemyState wanderState;
        public IEnemyState idleState;
        public IEnemyState attackState;
        public IEnemyState deathState;
        public IEnemyState chaseState;
        public float attackRange = 5f;
        [SerializeField] internal float chaseSpeed;
        [SerializeField] internal float rotationSpeed;
        internal EnemyAnimations animationComponent;
        internal EnemyShoot shootComponent;
        internal EnemyHealth healthComponent;
        protected virtual void Start()
        {
            // Initialize states
            wanderState = new WanderState();
            idleState = new IdleState();
            attackState = new AttackState();
            chaseState = new ChaseState();
            deathState = new DeathState();
            // Set initial state
            currentState = wanderState;
            // Get references
            player = GameObject.FindGameObjectWithTag("Player").transform;
            navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
            animationComponent = GetComponent&lt;EnemyAnimations&gt;();
            shootComponent = GetComponent&lt;EnemyShoot&gt;();
            healthComponent = GetComponent&lt;EnemyHealth&gt;();
            healthComponent.onEnemyDied += OnDied;
        }
        protected virtual void Update()
        {
            // Update the current state
            currentState.UpdateState(this);
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.684.1">Let’s take a closer look </span><a id="_idIndexMarker280" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.685.1">at this code so that we </span><span><span class="kobospan" id="kobo.686.1">understand it:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">player</span></strong><span class="kobospan" id="kobo.688.1">: Reference to the player’s </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.689.1">Transform</span></strong></span><span><span class="kobospan" id="kobo.690.1"> value</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.691.1">navMeshAgent</span></strong><span class="kobospan" id="kobo.692.1">: Reference to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.693.1">NavMeshAgent</span></strong><span class="kobospan" id="kobo.694.1"> component </span><span><span class="kobospan" id="kobo.695.1">for navigation</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">currentState</span></strong><span class="kobospan" id="kobo.697.1">: Reference to the current state of </span><span><span class="kobospan" id="kobo.698.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.699.1">wanderState</span></strong><span class="kobospan" id="kobo.700.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.701.1">idleState</span></strong><span class="kobospan" id="kobo.702.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.703.1">attackState</span></strong><span class="kobospan" id="kobo.704.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.705.1">deathState</span></strong><span class="kobospan" id="kobo.706.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.707.1">chaseState</span></strong><span class="kobospan" id="kobo.708.1">: Different states of the enemy (wandering, idle, attacking, dead, and </span><span><span class="kobospan" id="kobo.709.1">chasing, respectively)</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">attackRange</span></strong><span class="kobospan" id="kobo.711.1">: The range within which the enemy </span><span><span class="kobospan" id="kobo.712.1">can attack</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.713.1">chaseSpeed</span></strong><span class="kobospan" id="kobo.714.1">: The speed at which the enemy chases </span><span><span class="kobospan" id="kobo.715.1">the player</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.716.1">rotationSpeed</span></strong><span class="kobospan" id="kobo.717.1">: The speed of rotation for </span><span><span class="kobospan" id="kobo.718.1">the enemy</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.719.1">Start()Method</span></strong><span class="kobospan" id="kobo.720.1">: Initializes states, sets the initial state, and </span><span><span class="kobospan" id="kobo.721.1">gets references</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.722.1">Update()Method</span></strong><span class="kobospan" id="kobo.723.1">: Updates the current state of </span><span><span class="kobospan" id="kobo.724.1">the enemy</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.725.1">Now, let’s delve into the </span><a id="_idIndexMarker281" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.726.1">state machine logic that’s responsible for transitioning </span><span><span class="kobospan" id="kobo.727.1">between states:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.728.1">
        public bool PlayerInSight()
        {
            Vector3 directionToPlayer = player.position - transform.position;
            float distanceToPlayer = directionToPlayer.magnitude;
            // Create a ray from the enemy's position towards the player
            Ray ray = new Ray(transform.position, directionToPlayer.normalized);
            RaycastHit hit;
            // Check if the ray hits something
            if (Physics.Raycast(ray, out hit, distanceToPlayer))
            {
                // Check if the hit object is the player
                if (hit.collider.CompareTag("Player"))
                {
                    // The player is in sight
                    return true;
                }
            }
            // No direct line of sight to the player
            return false;
        }
        public bool PlayerInRange()
        {
            Vector3 directionToPlayer = player.position - transform.position;
            float distanceToPlayer = directionToPlayer.magnitude;
            // Check if the player is within the attack range
            if (distanceToPlayer &lt;= attackRange)
            {
                // Calculate the angle between the enemy's forward direction and the direction to the player
                float angleToPlayer = Vector3.Angle(transform.forward, directionToPlayer.normalized);
                // Set a cone angle to define the attack range
                float attackConeAngle = 45f; // Adjust this value based on your game's requirements
                // Check if the player is within the cone angle
                if (angleToPlayer &lt;= attackConeAngle * 0.5f)
                {
                    // The player is in range and within the attack cone
                    return true;
                }
            }
            // Player is not within attack range or cone angle
            return false;
        }
        public bool IsIdleConditionMet()
        {
            return !PlayerInSight() &amp;&amp; !PlayerInRange();
        }
        public void TransitionToState(IEnemyState newState)
        {
            currentState?.ExitState(this);
            currentState = newState;
            currentState?.EnterState(this);
        }
           private void OnDied()
        {
            healthComponent.onEnemyDied -= OnDied;
            // Trigger death logic if health reaches zero
            TransitionToState(deathState);
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.729.1">To understand this </span><a id="_idIndexMarker282" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.730.1">code, let’s examine </span><span><span class="kobospan" id="kobo.731.1">its functions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.732.1">PlayerInSight()</span></strong><span class="kobospan" id="kobo.733.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.734.1">PlayerInRange()</span></strong><span class="kobospan" id="kobo.735.1">: These functions check if the player is in sight or </span><span><span class="kobospan" id="kobo.736.1">range, respectively</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.737.1">IsIdleConditionMet()</span></strong><span class="kobospan" id="kobo.738.1">: Checks if the conditions for idling have </span><span><span class="kobospan" id="kobo.739.1">been met</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.740.1">TransitionToState()</span></strong><span class="kobospan" id="kobo.741.1">: Transitions to a </span><span><span class="kobospan" id="kobo.742.1">new state</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.743.1">OnDied()Method</span></strong><span class="kobospan" id="kobo.744.1">: Transitions to the </span><span><span class="kobospan" id="kobo.745.1">death state</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.746.1">Now, let’s move on to the states. </span><span class="kobospan" id="kobo.746.2">First, we’ll implement </span><strong class="source-inline"><span class="kobospan" id="kobo.747.1">IEnemyStates</span></strong><span class="kobospan" id="kobo.748.1"> so that we can include the base methods. </span><span class="kobospan" id="kobo.748.2">Then, in the subsequent code block, we’ll develop the logic for </span><strong class="source-inline"><span class="kobospan" id="kobo.749.1">IdleState</span></strong><span class="kobospan" id="kobo.750.1">, detailing the actions the enemy will take in this state. </span><strong class="source-inline"><span class="kobospan" id="kobo.751.1">IdleState</span></strong><span class="kobospan" id="kobo.752.1"> is the default state for all enemies. </span><span class="kobospan" id="kobo.752.2">Here, we simply check for the conditions of other states so that we can transition to them when their respective logic </span><span><span class="kobospan" id="kobo.753.1">is met:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.754.1">
   public class IdleState : IEnemyState
    {
        private float idleTime = 3f; // Set the duration for which the enemy stays idle
        private float timer; // Timer to track the idle time
        public void EnterState(BaseEnemy enemy)
        {
            timer = 0f;
        }
        public void ExitState(BaseEnemy enemy)
        {
            //Logic for Exit
        }
        public void UpdateState(BaseEnemy enemy)
        {
            // Logic to be executed while in the idle state
            timer += Time.deltaTime;
            if (timer &gt;= idleTime)
            {
                enemy.TransitionToState(enemy.wanderState);
            }
            else if (enemy.PlayerInSight())
            {
                enemy.TransitionToState(enemy.chaseState);
            }
            else if (enemy.PlayerInRange())
            {
                enemy.TransitionToState(enemy.attackState);
            }
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.755.1">Let’s take a closer</span><a id="_idIndexMarker283" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.756.1"> look at the </span><span><span class="kobospan" id="kobo.757.1">preceding code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.758.1">Variables</span></strong></span><span><span class="kobospan" id="kobo.759.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.760.1">idleTime</span></strong><span class="kobospan" id="kobo.761.1">: This variable determines the duration for which the enemy </span><span><span class="kobospan" id="kobo.762.1">remains idle</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">timer</span></strong><span class="kobospan" id="kobo.764.1">: This variable tracks the elapsed time while the enemy is in the </span><span><span class="kobospan" id="kobo.765.1">idle state</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.766.1">Methods</span></strong></span><span><span class="kobospan" id="kobo.767.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.768.1">EnterState(BaseEnemy enemy)</span></strong><span class="kobospan" id="kobo.769.1">: This method is called when the enemy enters the idle state. </span><span class="kobospan" id="kobo.769.2">Here, it initializes </span><span><span class="kobospan" id="kobo.770.1">the timer.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.771.1">ExitState(BaseEnemy enemy)</span></strong><span class="kobospan" id="kobo.772.1">: This method is called when the enemy exits the idle state. </span><span class="kobospan" id="kobo.772.2">Currently, it’s empty, but you can add logic here </span><span><span class="kobospan" id="kobo.773.1">if needed.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.774.1">UpdateState(BaseEnemy enemy)</span></strong><span class="kobospan" id="kobo.775.1">: This method is called every frame to update the state of the enemy. </span><span class="kobospan" id="kobo.775.2">Here’s </span><span><span class="kobospan" id="kobo.776.1">what happens:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.777.1">The timer is incremented by the time elapsed since the </span><span><span class="kobospan" id="kobo.778.1">last frame</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.779.1">If the idle time exceeds the specified duration (</span><strong class="source-inline1"><span class="kobospan" id="kobo.780.1">idleTime</span></strong><span class="kobospan" id="kobo.781.1">), the enemy transitions to the wander state, indicating it’s ready to </span><span><span class="kobospan" id="kobo.782.1">move around</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.783.1">If the enemy detects the player within its line of sight (</span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">PlayerInSight()</span></strong><span class="kobospan" id="kobo.785.1">), it transitions to the chase state to pursue </span><span><span class="kobospan" id="kobo.786.1">the player</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.787.1">If the player is within the attack range (</span><strong class="source-inline1"><span class="kobospan" id="kobo.788.1">PlayerInRange()</span></strong><span class="kobospan" id="kobo.789.1">), the enemy transitions to the attack state to engage </span><span><span class="kobospan" id="kobo.790.1">the player</span></span></li></ul></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.791.1">This code ensures </span><a id="_idIndexMarker284" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.792.1">that the enemy behaves as expected while in the idle state, transitioning to other states based on specific conditions, such as time elapsed and </span><span><span class="kobospan" id="kobo.793.1">player proximity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.794.1">In the following class, </span><strong class="source-inline"><span class="kobospan" id="kobo.795.1">AttackState</span></strong><span class="kobospan" id="kobo.796.1">, we also implement </span><strong class="source-inline"><span class="kobospan" id="kobo.797.1">IEnemyState</span></strong><span class="kobospan" id="kobo.798.1"> so that we can modify the base methods so that they fit the attack state. </span><span class="kobospan" id="kobo.798.2">The attack state is the state that all enemies will enter when they are attacking the player. </span><span class="kobospan" id="kobo.798.3">It includes logic for tracking the player’s position and firing projectiles toward the player, along with handling </span><span><span class="kobospan" id="kobo.799.1">associated animations:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.800.1">
    public class AttackState : IEnemyState
    {
        private float attackTimer;  // Timer to control the attack rate
        private float timeBetweenAttacks = 1.5f;  // Adjust as needed based on your game's requirements
        public void EnterState(BaseEnemy enemy)
        {
            enemy.animationsComponent.StartAttackAnimations();
            attackTimer = 0f;
        }
        public void UpdateState(BaseEnemy enemy)
        {
            LookAtPlayer(enemy);
            attackTimer += Time.deltaTime;
            if (attackTimer &gt;= timeBetweenAttacks)
            {
                AttackPlayer(enemy);
                attackTimer = 0f;  // Reset the timer after attacking
            }
        }
        public void ExitState(BaseEnemy enemy)
        {
            enemy.animationsComponent.StopAttackAnimations();
        }
        private void LookAtPlayer(BaseEnemy enemy)
        {
            Vector3 lookDirection = enemy.player.position - enemy.transform.position;
            lookDirection.y = 0;  // Keep the enemy's rotation in the horizontal plane
            Quaternion rotation = Quaternion.LookRotation(lookDirection);
            enemy.transform.rotation = Quaternion.Slerp(enemy.transform.rotation, rotation, Time.deltaTime * enemy.rotationSpeed);
        }
        private void AttackPlayer(BaseEnemy enemy)
        {
            enemy.shootComponent.FireProjectile();
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.801.1">Here’s an explanation </span><a id="_idIndexMarker285" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.802.1">for </span><span><span class="kobospan" id="kobo.803.1">this code:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.804.1">Methods</span></strong></span><span><span class="kobospan" id="kobo.805.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.806.1">EnterState</span></strong><span class="kobospan" id="kobo.807.1">: Initializes the attack state, starts attack animations, and resets the </span><span><span class="kobospan" id="kobo.808.1">attack timer.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.809.1">UpdateState</span></strong><span class="kobospan" id="kobo.810.1">: Checks if it’s time to attack based on the time between attacks. </span><span class="kobospan" id="kobo.810.2">It ensures that the enemy is facing the player and initiates the attack if conditions </span><span><span class="kobospan" id="kobo.811.1">are met.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.812.1">ExitState</span></strong><span class="kobospan" id="kobo.813.1">: Stops attack animations when exiting </span><span><span class="kobospan" id="kobo.814.1">the state.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.815.1">LookAtPlayer</span></strong><span class="kobospan" id="kobo.816.1">: Calculates the direction to look at the player and smoothly rotates the enemy toward </span><span><span class="kobospan" id="kobo.817.1">the player.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.818.1">AttackPlayer</span></strong><span class="kobospan" id="kobo.819.1">: Causes the enemy to perform an attack action, such as firing </span><span><span class="kobospan" id="kobo.820.1">a projectile.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.821.1">With that, you’ve learned how to create states, enabling you to effortlessly add more states so that you can tailor </span><span><span class="kobospan" id="kobo.822.1">your game.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.823.1">Now that we’ve established the interaction loop between the enemy and the player, allowing them to shoot</span><a id="_idIndexMarker286" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.824.1"> at each other, the next step involves creating a prefab for each enemy – for instance, implementing the </span><strong class="source-inline"><span class="kobospan" id="kobo.825.1">ShooterEnemy</span></strong><span class="kobospan" id="kobo.826.1"> base class and adding this component to the respective </span><strong class="source-inline"><span class="kobospan" id="kobo.827.1">GameObject</span></strong><span class="kobospan" id="kobo.828.1">, turning it into a prefab. </span><span class="kobospan" id="kobo.828.2">Similarly, for projectiles, remember that it’s essential to modify tags based on whether they’re for the player or </span><span><span class="kobospan" id="kobo.829.1">the enemy.</span></span></p>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor068" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.830.1">Implementing challenge and reward systems using C#</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.831.1">Challenges breathe life </span><a id="_idIndexMarker287" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.832.1">into the gaming experience, pulsating with excitement and unpredictability, guiding players through pivotal moments that require skill, strategy, and determination. </span><span class="kobospan" id="kobo.832.2">These obstacles ensure players stay fully immersed in the gaming world, crafting a dynamic landscape that turns each gaming session into an adventure, complete with unexpected twists </span><span><span class="kobospan" id="kobo.833.1">and turns.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.834.1">In games such as </span><em class="italic"><span class="kobospan" id="kobo.835.1">Dark Souls</span></em><span class="kobospan" id="kobo.836.1">, challenges manifest in the form of formidable enemies and intricate level designs. </span><span class="kobospan" id="kobo.836.2">Players are tested on their combat skills and adaptability, creating an intense and rewarding experience. </span><em class="italic"><span class="kobospan" id="kobo.837.1">Super Mario Bros.</span></em><span class="kobospan" id="kobo.838.1"> introduces challenges through precise platforming, timing, and defeating enemies. </span><span class="kobospan" id="kobo.838.2">Each level presents a new set of challenges, gradually increasing </span><span><span class="kobospan" id="kobo.839.1">in complexity.</span></span></p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor069" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.840.1">Challenges versus missions/quests</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.841.1">While </span><a id="_idIndexMarker288" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.842.1">challenges, missions, and quests share common ground in engaging players, they differ in their nature. </span><strong class="bold"><span class="kobospan" id="kobo.843.1">Challenges</span></strong><span class="kobospan" id="kobo.844.1"> often refer to specific obstacles or tasks that test a player’s abilities, such as completing a level within a time limit or defeating a powerful adversary. </span><strong class="bold"><span class="kobospan" id="kobo.845.1">Missions and quests</span></strong><span class="kobospan" id="kobo.846.1">, on the other hand, are broader objectives that contribute to the game’s narrative and involve a series of tasks that may include challenges. </span><span class="kobospan" id="kobo.846.2">The distinction lies in the focused, skill-testing nature of challenges, making them pivotal components of </span><span><span class="kobospan" id="kobo.847.1">dynamic gameplay.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.848.1">In </span><em class="italic"><span class="kobospan" id="kobo.849.1">The Legend of Zelda: Breath of the Wild</span></em><span class="kobospan" id="kobo.850.1">, a challenge might involve solving a complex puzzle shrine and testing the player’s problem-solving skills. </span><span class="kobospan" id="kobo.850.2">In contrast, a mission could be part of the game’s overarching narrative, such as rescuing a character or retrieving a special item. </span><span class="kobospan" id="kobo.850.3">Challenges offer immediate, skill-based hurdles, while missions contribute to the overall progression </span><span><span class="kobospan" id="kobo.851.1">and storytelling.</span></span></p>
<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor070" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.852.1">Balancing difficulty levels for broad appeal</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.853.1">Achieving a </span><a id="_idIndexMarker289" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.854.1">harmonious difficulty curve is essential to cater to players of varying skill levels. </span><span class="kobospan" id="kobo.854.2">Balancing challenges ensures that both novice and experienced players find engagement without encountering excessive frustration. </span><span class="kobospan" id="kobo.854.3">Games such as </span><em class="italic"><span class="kobospan" id="kobo.855.1">Celeste</span></em><span class="kobospan" id="kobo.856.1"> masterfully balance difficulty, starting with simple challenges and gradually introducing more complex ones, allowing players to grow alongside the </span><span><span class="kobospan" id="kobo.857.1">game’s intricacies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.858.1">Successful games often employ techniques </span><a id="_idIndexMarker290" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.859.1">such as </span><strong class="bold"><span class="kobospan" id="kobo.860.1">adaptive difficulty scaling</span></strong><span class="kobospan" id="kobo.861.1"> or optional challenges to accommodate diverse player skill levels. </span><span class="kobospan" id="kobo.861.2">This careful balance prevents discouragement for newcomers while providing a satisfying experience for seasoned players seeking </span><span><span class="kobospan" id="kobo.862.1">greater challenges.</span></span></p>
<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor071" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.863.1">Exploring reward systems</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.864.1">Reward systems</span></strong><span class="kobospan" id="kobo.865.1"> in</span><a id="_idIndexMarker291" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.866.1"> gaming are like treasured prizes waiting for triumphant players after they’ve overcome tough challenges. </span><span class="kobospan" id="kobo.866.2">These systems are closely linked to the</span><a id="_idIndexMarker292" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.867.1"> challenge dynamics, acting as the driving force that propels players forward. </span><span class="kobospan" id="kobo.867.2">Rewards come in various forms – power-ups, upgrades, or in-game currency, along with narrative progress and cosmetic items, each with its </span><span><span class="kobospan" id="kobo.868.1">unique appeal.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.869.1">In games such as </span><em class="italic"><span class="kobospan" id="kobo.870.1">The Legend of Zelda</span></em><span class="kobospan" id="kobo.871.1">, conquering tricky dungeons or defeating tough bosses often rewards players with new tools or abilities to progress in the story. </span><span class="kobospan" id="kobo.871.2">In RPGs such as </span><em class="italic"><span class="kobospan" id="kobo.872.1">The Witcher 3</span></em><span class="kobospan" id="kobo.873.1">, completing side quests not only gives experience points and in-game money but also unlocks new storylines or equipment. </span><span class="kobospan" id="kobo.873.2">The connection between challenges and rewards ensures that overcoming obstacles not only tests the player’s skills but also promises valuable incentives, boosting player engagement </span><span><span class="kobospan" id="kobo.874.1">and satisfaction.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.875.1">Successfully blending rewards into the gameplay loop ensures that challenges aren’t just hurdles but opportunities for growth. </span><span class="kobospan" id="kobo.875.2">This fosters a sense of accomplishment and progression. </span><span class="kobospan" id="kobo.875.3">Players are motivated to take on tougher challenges for the promise of more significant rewards, creating a satisfying gaming experience. </span><span class="kobospan" id="kobo.875.4">The seamless integration of rewards makes the gaming journey fulfilling </span><span><span class="kobospan" id="kobo.876.1">and enjoyable.</span></span></p>
<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor072" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.877.1">C# implementation of challenges and rewards</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.878.1">Moving from</span><a id="_idIndexMarker293" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.879.1"> theory to practice, our C# implementation </span><a id="_idIndexMarker294" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.880.1">of challenges and rewards brings coding insights to life. </span><span class="kobospan" id="kobo.880.2">With illustrative code snippets, you’ll gain hands-on experience, bringing challenges to life and rewarding players meaningfully. </span><span class="kobospan" id="kobo.880.3">We’ll discuss the delicate balance that’s needed to keep players engaged and motivated, understanding how challenge difficulty correlates with the magnitude </span><span><span class="kobospan" id="kobo.881.1">of rewards.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.882.1">Introducing the challenge logic</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.883.1">Let’s begin by </span><a id="_idIndexMarker295" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.884.1">establishing the foundational data structure for challenges. </span><span class="kobospan" id="kobo.884.2">This can be seen in the following class. </span><span class="kobospan" id="kobo.884.3">Every challenge will share this common set of data, simplifying runtime tracking and allowing prizes to </span><span><span class="kobospan" id="kobo.885.1">be assigned:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.886.1">
[Serializable]
 public class CommonChallengeData
 {
     public bool isCompleted;
     public RewardType rewardType; // Type of reward
     public int rewardAmount;      // Amount or value of the reward
     … other challenge Data
 }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.887.1">Let’s proceed to the </span><strong class="source-inline"><span class="kobospan" id="kobo.888.1">BaseChallenge</span></strong><span class="kobospan" id="kobo.889.1"> class, which features the logic for starting and completing challenges. </span><span class="kobospan" id="kobo.889.2">Refer to the following code block for details. </span><span class="kobospan" id="kobo.889.3">All challenges will derive from this script, customizing their logic within </span><span><span class="kobospan" id="kobo.890.1">its methods:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.891.1">
public abstract class BaseChallenge : MonoBehaviour
 {
     public CommonChallengeData commonData;
     public abstract void StartChallenge();
     public abstract void CompleteChallenge();
 }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.892.1">Let’s take a</span><a id="_idIndexMarker296" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.893.1">closer look:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.894.1">public CommonChallengeData commonData</span></strong><span class="kobospan" id="kobo.895.1">: This is a public variable of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.896.1">CommonChallengeData</span></strong><span class="kobospan" id="kobo.897.1"> type. </span><span class="kobospan" id="kobo.897.2">It holds data that might be common across various types of challenges. </span><span class="kobospan" id="kobo.897.3">It allows derived classes to access and modify shared </span><span><span class="kobospan" id="kobo.898.1">challenge data.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.899.1">public abstract void StartChallenge()</span></strong><span class="kobospan" id="kobo.900.1">: This is an abstract method declaration without any implementation. </span><span class="kobospan" id="kobo.900.2">It specifies that any class inheriting from </span><strong class="source-inline1"><span class="kobospan" id="kobo.901.1">BaseChallenge</span></strong><span class="kobospan" id="kobo.902.1"> must provide its own implementation for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.903.1">StartChallenge</span></strong><span class="kobospan" id="kobo.904.1"> method. </span><span class="kobospan" id="kobo.904.2">This method likely contains logic to initialize or begin </span><span><span class="kobospan" id="kobo.905.1">the challenge.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.906.1">public abstract void CompleteChallenge()</span></strong><span class="kobospan" id="kobo.907.1">: Similar to </span><strong class="source-inline1"><span class="kobospan" id="kobo.908.1">StartChallenge()</span></strong><span class="kobospan" id="kobo.909.1">, this is another abstract method that any derived class must implement. </span><span class="kobospan" id="kobo.909.2">It is responsible for handling the completion of the challenge, which may involve updating the UI, awarding rewards, or triggering other </span><span><span class="kobospan" id="kobo.910.1">game events.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.911.1">In summary, </span><strong class="source-inline"><span class="kobospan" id="kobo.912.1">BaseChallenge</span></strong><span class="kobospan" id="kobo.913.1"> serves as a template for creating different types of challenges in a game. </span><span class="kobospan" id="kobo.913.2">It defines common functionality that all challenges should have, such as starting and completing the challenge, while allowing specific implementations to vary based on the type </span><span><span class="kobospan" id="kobo.914.1">of challenge.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.915.1">Let’s transition to </span><strong class="source-inline"><span class="kobospan" id="kobo.916.1">ChallengeManager</span></strong><span class="kobospan" id="kobo.917.1">, a central entity that houses all challenges and takes on the responsibility of initiating challenges. </span><span class="kobospan" id="kobo.917.2">Currently, it includes a dictionary for storing all challenge components by their respective types, encompassing all challenge types. </span><span class="kobospan" id="kobo.917.3">It also features a method to commence challenges, which will be invoked </span><span><span class="kobospan" id="kobo.918.1">by </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.919.1">LevelManager</span></strong></span><span><span class="kobospan" id="kobo.920.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.921.1">Consequently, each level can have a designated challenge, and the manager maintains a reference to the </span><a id="_idIndexMarker297" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.922.1">current challenge. </span><span class="kobospan" id="kobo.922.2">All of these functionalities are detailed in the following </span><span><span class="kobospan" id="kobo.923.1">code script:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.924.1">
    public class ChallengeManager : Singleton&lt;ChallengeManager&gt;
    {
        // Define different types of challenges
        public enum ChallengeType
        {
            EnemyWaves,
            TimeTrials,
            LimitedResources,
            NoDamageRun,
            AccuracyChallenge
        }
        public GenericDictionary&lt;ChallengeType, BaseChallenge&gt; challengeDictionary = new GenericDictionary&lt;ChallengeType, BaseChallenge&gt;();
        public void StartChallenge(ChallengeType challengeType)
        {
            if (challengeDictionary.TryGetValue(challengeType, out BaseChallenge challengeScript))
            {
                if (!challengeScript.commonData.isCompleted)
                {
                    SetCurrentChallenge(challengeScript);
                    currentChallenge.StartChallenge();
                }
                else
                {
                    Debug.Log("Challenge already completed!");
                }
            }
            else
            {
                Debug.LogError($"No challenge script found for ChallengeType {challengeType}");
            }
        }
        private BaseChallenge currentChallenge;
        private void SetCurrentChallenge(BaseChallenge challengeScript)
        {
            if (currentChallenge != null)
            {
                currentChallenge.CompleteChallenge();
            }
            currentChallenge = challengeScript;
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.925.1">Here’s an</span><a id="_idIndexMarker298" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.926.1"> explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.927.1">ChallengeManager</span></strong></span><span><span class="kobospan" id="kobo.928.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.929.1">public enum ChallengeType</span></strong><span class="kobospan" id="kobo.930.1">: This is an enumeration that defines different types of challenges available in the game. </span><span class="kobospan" id="kobo.930.2">Each challenge type represents a specific kind of gameplay challenge, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.931.1">EnemyWaves</span></strong><span class="kobospan" id="kobo.932.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.933.1">TimeTrials</span></strong><span class="kobospan" id="kobo.934.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.935.1">LimitedResources</span></strong><span class="kobospan" id="kobo.936.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.937.1">NoDamageRun</span></strong><span class="kobospan" id="kobo.938.1">, </span><span><span class="kobospan" id="kobo.939.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.940.1">AccuracyChallenge</span></strong></span><span><span class="kobospan" id="kobo.941.1">.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.942.1">public GenericDictionary&lt;ChallengeType</span></strong><span class="kobospan" id="kobo.943.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.944.1">BaseChallenge&gt; challengeDictionary</span></strong><span class="kobospan" id="kobo.945.1">: This is a generic dictionary that maps </span><strong class="source-inline1"><span class="kobospan" id="kobo.946.1">ChallengeType</span></strong><span class="kobospan" id="kobo.947.1"> enum values to corresponding </span><strong class="source-inline1"><span class="kobospan" id="kobo.948.1">BaseChallenge</span></strong><span class="kobospan" id="kobo.949.1"> objects. </span><span class="kobospan" id="kobo.949.2">It stores instances of different challenge scripts associated with their respective </span><span><span class="kobospan" id="kobo.950.1">challenge types.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.951.1">public void StartChallenge(ChallengeType challengeType)</span></strong><span class="kobospan" id="kobo.952.1">: This method is responsible for starting a challenge of the specified type. </span><span class="kobospan" id="kobo.952.2">It retrieves the corresponding challenge script from the dictionary based on the provided challenge type and then calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.953.1">StartChallenge()</span></strong><span class="kobospan" id="kobo.954.1"> method of the </span><span><span class="kobospan" id="kobo.955.1">retrieved script.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.956.1">private BaseChallenge currentChallenge</span></strong><span class="kobospan" id="kobo.957.1">: This private field holds a reference to the currently active challenge. </span><span class="kobospan" id="kobo.957.2">It is used to track and manage the state of the current challenge </span><span><span class="kobospan" id="kobo.958.1">being played.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.959.1">private void </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.960.1">SetCurrentChallenge(BaseChallenge challenge</span></strong></span><strong class="source-inline1"><span class="kobospan" id="kobo.961.1">
Script)</span></strong><span class="kobospan" id="kobo.962.1">: This method sets the current challenge to the one provided as an argument. </span><span class="kobospan" id="kobo.962.2">Before setting the new challenge, it ensures that any existing challenge is completed by calling its </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.963.1">CompleteChallenge()</span></strong></span><span><span class="kobospan" id="kobo.964.1"> method.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.965.1">In summary, the </span><strong class="source-inline"><span class="kobospan" id="kobo.966.1">ChallengeManager</span></strong><span class="kobospan" id="kobo.967.1"> class facilitates the management and execution of different types </span><a id="_idIndexMarker299" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.968.1">of challenges in the game. </span><span class="kobospan" id="kobo.968.2">It provides methods to start challenges, handle the completion of challenges, and track the current active challenge. </span><span class="kobospan" id="kobo.968.3">The use of a singleton pattern ensures centralized control over challenge </span><span><span class="kobospan" id="kobo.969.1">management operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.970.1">Now, let’s shift our focus to the individual challenges. </span><span class="kobospan" id="kobo.970.2">The following code block contains an example that implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.971.1">BaseChallenge</span></strong><span class="kobospan" id="kobo.972.1"> class, integrating custom logic specific to the </span><strong class="source-inline"><span class="kobospan" id="kobo.973.1">Enemy Waves</span></strong><span class="kobospan" id="kobo.974.1"> challenge. </span><span class="kobospan" id="kobo.974.2">When the challenge starts, enemies are spawned near the player. </span><span class="kobospan" id="kobo.974.3">Additionally, it includes logic to reward the player upon completing the challenge. </span><span class="kobospan" id="kobo.974.4">This is facilitated by the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.975.1">RewardManager</span></strong></span><span><span class="kobospan" id="kobo.976.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.977.1">
    public class EnemyWavesChallenge : BaseChallenge
    {
        public int totalWaves = 5;  // Adjust as needed
        private int currentWave = 0;
        public override void StartChallenge()
        {
            if (!commonData.isCompleted)
            {
                StartCoroutine(StartEnemyWavesChallenge());
            }
            else
            {
                Debug.Log("Challenge already completed!");
            }
        }
        IEnumerator StartEnemyWavesChallenge()
        {
            while (currentWave &lt; totalWaves)
            {
                yield return StartCoroutine(SpawnEnemyWave());
                currentWave++;
            }
            CompleteChallenge();
        }
        public override void CompleteChallenge()
        {
            if (!commonData.isCompleted)
            {
                RewardManager.Instance.GrantReward(commonData);
                commonData.isCompleted = true;
            }
            else
            {
                Debug.Log("Challenge already completed!");
            }
        }
        IEnumerator SpawnEnemyWave()
        {
            // Adjust spawn positions, enemy types, and other parameters based on your game
            Debug.Log($"Spawning Wave {currentWave + 1}");
            yield return new WaitForSeconds(2f);
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.978.1">Here’s an </span><a id="_idIndexMarker300" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.979.1">explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.980.1">EnemyWavesChallenge</span></strong></span><span><span class="kobospan" id="kobo.981.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.982.1">public int totalWaves = 5</span></strong><span class="kobospan" id="kobo.983.1">: This variable determines the total number of waves for the enemy challenge. </span><span class="kobospan" id="kobo.983.2">Game designers can adjust this value to set the desired number </span><span><span class="kobospan" id="kobo.984.1">of waves.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.985.1">private int currentWave = 0</span></strong><span class="kobospan" id="kobo.986.1">: This variable keeps track of the current wave during the challenge. </span><span class="kobospan" id="kobo.986.2">It starts at </span><strong class="source-inline1"><span class="kobospan" id="kobo.987.1">0</span></strong><span class="kobospan" id="kobo.988.1"> and increments as waves </span><span><span class="kobospan" id="kobo.989.1">are spawned.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.990.1">public override void StartChallenge()</span></strong><span class="kobospan" id="kobo.991.1">: This method overrides the </span><strong class="source-inline1"><span class="kobospan" id="kobo.992.1">StartChallenge()</span></strong><span class="kobospan" id="kobo.993.1"> method that’s inherited from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.994.1">BaseChallenge</span></strong><span class="kobospan" id="kobo.995.1"> class. </span><span class="kobospan" id="kobo.995.2">It initiates the enemy waves challenge if it’s not already completed. </span><span class="kobospan" id="kobo.995.3">Inside this method, a coroutine named </span><strong class="source-inline1"><span class="kobospan" id="kobo.996.1">StartEnemyWavesChallenge()</span></strong><span class="kobospan" id="kobo.997.1"> is started to handle the wave </span><span><span class="kobospan" id="kobo.998.1">spawning process.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.999.1">IEnumerator StartEnemyWavesChallenge()</span></strong><span class="kobospan" id="kobo.1000.1">: This coroutine function manages the spawning of enemy waves. </span><span class="kobospan" id="kobo.1000.2">It runs until the current wave count reaches the total number of waves specified. </span><span class="kobospan" id="kobo.1000.3">Inside the loop, it waits for a wave to be spawned using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1001.1">SpawnEnemyWave()</span></strong></span><span><span class="kobospan" id="kobo.1002.1"> coroutine.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1003.1">public override void CompleteChallenge()</span></strong><span class="kobospan" id="kobo.1004.1">: This method overrides the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1005.1">CompleteChallenge()</span></strong><span class="kobospan" id="kobo.1006.1"> method from the base class. </span><span class="kobospan" id="kobo.1006.2">It grants rewards for completing the challenge using </span><strong class="source-inline1"><span class="kobospan" id="kobo.1007.1">RewardManager</span></strong><span class="kobospan" id="kobo.1008.1"> and marks the challenge </span><span><span class="kobospan" id="kobo.1009.1">as completed.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1010.1">IEnumerator SpawnEnemyWave()</span></strong><span class="kobospan" id="kobo.1011.1">: This coroutine function represents the logic for spawning an enemy wave. </span><span class="kobospan" id="kobo.1011.2">Game designers can adjust spawn positions, enemy types, and other parameters to customize the wave spawning process. </span><span class="kobospan" id="kobo.1011.3">In </span><a id="_idIndexMarker301" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1012.1">this example, it logs a message indicating the wave being spawned and waits for a set duration before spawning the </span><span><span class="kobospan" id="kobo.1013.1">next wave.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1014.1">In summary, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1015.1">EnemyWavesChallenge</span></strong><span class="kobospan" id="kobo.1016.1"> class defines a challenge where waves of enemies are spawned sequentially. </span><span class="kobospan" id="kobo.1016.2">It provides methods to start the challenge, spawn enemy waves, and handle the completion of the challenge by granting rewards. </span><span class="kobospan" id="kobo.1016.3">Game designers can customize the wave spawning process and adjust parameters according to the </span><span><span class="kobospan" id="kobo.1017.1">game’s requirements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1018.1">The previous example is just one of the challenges provided. </span><span class="kobospan" id="kobo.1018.2">You can find all the challenges in this book’s GitHub repository (see the </span><em class="italic"><span class="kobospan" id="kobo.1019.1">Technical requirements</span></em><span class="kobospan" id="kobo.1020.1"> section). </span><span class="kobospan" id="kobo.1020.2">Lastly, here’s </span><strong class="source-inline"><span class="kobospan" id="kobo.1021.1">LevelManager</span></strong><span class="kobospan" id="kobo.1022.1">, which is tasked with assigning a suitable challenge for the </span><span><span class="kobospan" id="kobo.1023.1">current level:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1024.1">
   public class LevelManager : Singleton&lt;LevelManager&gt;
   {
       public GenericDictionary&lt;int, ChallengeType&gt; levelChallengeMapping = new GenericDictionary&lt;int, ChallengeType&gt;();
       public int currentLevel;
       private void Start()
       {
           StartChallengeForCurrentLevel(currentLevel);
       }
       public void StartChallengeForCurrentLevel(int currentLevel)
       {
           if (levelChallengeMapping.TryGetValue(currentLevel, out ChallengeType challengeType))
           {
               // Start the challenge associated with the current level
               ChallengeManager.Instance.StartChallenge(challengeType);
           }
           else
           {
               Debug.LogError($"No challenge mapped for Level {currentLevel}");
           }
       }
   }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1025.1">Here’s an </span><a id="_idIndexMarker302" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1026.1">explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1027.1">LevelManager</span></strong></span><span><span class="kobospan" id="kobo.1028.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1029.1">public GenericDictionary&lt;int</span></strong><span class="kobospan" id="kobo.1030.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1031.1">ChallengeType&gt; levelChallengeMapping</span></strong><span class="kobospan" id="kobo.1032.1">: This dictionary stores mappings between levels and their corresponding challenge types. </span><span class="kobospan" id="kobo.1032.2">The key represents the level number, and the value represents the type of challenge associated with </span><span><span class="kobospan" id="kobo.1033.1">that level.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1034.1">public int currentLevel</span></strong><span class="kobospan" id="kobo.1035.1">: This variable stores the current level of </span><span><span class="kobospan" id="kobo.1036.1">the game.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1037.1">private void Start()</span></strong><span class="kobospan" id="kobo.1038.1">: This method is called when the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1039.1">LevelManager</span></strong><span class="kobospan" id="kobo.1040.1"> object is initialized. </span><span class="kobospan" id="kobo.1040.2">It automatically starts the challenge associated with the </span><span><span class="kobospan" id="kobo.1041.1">current level.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1042.1">public void StartChallengeForCurrentLevel(int currentLevel)</span></strong><span class="kobospan" id="kobo.1043.1">: This method starts the challenge for the specified current level. </span><span class="kobospan" id="kobo.1043.2">It checks if a challenge has been mapped for the current level in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1044.1">levelChallengeMapping</span></strong><span class="kobospan" id="kobo.1045.1"> dictionary. </span><span class="kobospan" id="kobo.1045.2">If a mapping is found, it retrieves the associated challenge type and starts the corresponding challenge </span><span><span class="kobospan" id="kobo.1046.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1047.1">ChallengeManager</span></strong></span><span><span class="kobospan" id="kobo.1048.1">.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1049.1">ChallengeManager.Instance.StartChallenge(challengeType)</span></strong><span class="kobospan" id="kobo.1050.1">: This line of code invokes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1051.1">StartChallenge</span></strong><span class="kobospan" id="kobo.1052.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1053.1">ChallengeManager</span></strong><span class="kobospan" id="kobo.1054.1"> singleton instance, passing the challenge type associated with the current level as </span><span><span class="kobospan" id="kobo.1055.1">an argument.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1056.1">In summary, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1057.1">LevelManager</span></strong><span class="kobospan" id="kobo.1058.1"> class </span><a id="_idIndexMarker303" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1059.1">facilitates the initiation of challenges based on the current level of the game. </span><span class="kobospan" id="kobo.1059.2">It ensures that the correct challenge is started for each level by looking up the challenge type associated with the current level in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1060.1">levelChallengeMapping</span></strong><span class="kobospan" id="kobo.1061.1"> dictionary and then invoking the </span><strong class="source-inline"><span class="kobospan" id="kobo.1062.1">StartChallenge</span></strong><span class="kobospan" id="kobo.1063.1"> method of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1064.1">ChallengeManager</span></strong> <span><span class="kobospan" id="kobo.1065.1">singleton instance.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1066.1">Implementing the reward system</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1067.1">Now, let’s delve into</span><a id="_idIndexMarker304" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1068.1"> the reward system, a crucial element in the gameplay flow that allows users to receive rewards. </span><span class="kobospan" id="kobo.1068.2">This feature is essential for user motivation </span><span><span class="kobospan" id="kobo.1069.1">and engagement</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1070.1">Here’s </span><strong class="source-inline"><span class="kobospan" id="kobo.1071.1">RewardManager</span></strong><span class="kobospan" id="kobo.1072.1">, which is tasked with providing the user with rewards based on the challenge data. </span><span class="kobospan" id="kobo.1072.2">As we can see, it communicates with other managers to enable the user to receive </span><span><span class="kobospan" id="kobo.1073.1">specific rewards:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1074.1">
    public class RewardManager : Singlton&lt;RewardManager&gt;
    {
        // Define different types of rewards
        public enum RewardType
        {
            PowerUp,
            UnlockableWeapon,
            ScoreMultiplier,
            SecretArea,
            Coins
        }
        public void GrantReward(CommonChallengeData commonData)
        {
            // Add code here to handle the specific reward type
            switch (commonData.rewardType)
            {
                case RewardType.PowerUp:
                    // Grant temporary power-up
                    break;
                case RewardType.UnlockableWeapon:
                    // Unlock a new weapon
                    break;
                case RewardType.ScoreMultiplier:
                    ApplyScoreMultiplier(commonData.rewardAmount);
                    break;
                case RewardType.SecretArea:
                    // Grant items found in a secret area
                    break;
                case RewardType.Coins:
                    GrantCoins(commonData.rewardAmount);
                    break;
            }
        }
        private void ApplyScoreMultiplier(int multiplier)
        {
            ScoreManager.Instance.ApplyMultiplier(multiplier);
            Debug.Log($"Score Multiplier Applied: {multiplier}x");
        }
        private void GrantCoins(int coinAmount)
        {
            CurrencyManager.Instance.AddCoins(coinAmount);
            Debug.Log($"Coins Granted: {coinAmount}");
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1075.1">Here’s an explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1076.1">RewardManager</span></strong></span><span><span class="kobospan" id="kobo.1077.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1078.1">public enum RewardType</span></strong><span class="kobospan" id="kobo.1079.1">: This enumeration defines different types of rewards that can be granted to the player, such as power-ups, unlockable weapons, score multipliers, items found in secret areas, </span><span><span class="kobospan" id="kobo.1080.1">and coins.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1081.1">public void GrantReward(CommonChallengeData commonData)</span></strong><span class="kobospan" id="kobo.1082.1">: This method is responsible for granting rewards to the player. </span><span class="kobospan" id="kobo.1082.2">It takes a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1083.1">CommonChallengeData</span></strong><span class="kobospan" id="kobo.1084.1"> object as a parameter, which contains information about the type and amount of reward to </span><span><span class="kobospan" id="kobo.1085.1">be granted.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1086.1">switch (commonData.rewardType)</span></strong><span class="kobospan" id="kobo.1087.1">: This switch statement checks the type of</span><a id="_idIndexMarker305" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1088.1"> reward specified in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1089.1">CommonChallengeData</span></strong><span class="kobospan" id="kobo.1090.1"> object and executes the corresponding reward logic based </span><span><span class="kobospan" id="kobo.1091.1">on </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1092.1">RewardType</span></strong></span><span><span class="kobospan" id="kobo.1093.1">.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1094.1">case RewardType.PowerUp</span></strong><span class="kobospan" id="kobo.1095.1">: This case allows temporary power-ups to be granted to </span><span><span class="kobospan" id="kobo.1096.1">the player.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1097.1">case RewardType.UnlockableWeapon</span></strong><span class="kobospan" id="kobo.1098.1">: This case allows new weapons to be unlocked for </span><span><span class="kobospan" id="kobo.1099.1">the player.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1100.1">case RewardType.ScoreMultiplier</span></strong><span class="kobospan" id="kobo.1101.1">: This case applies a score multiplier to the player’s score by invoking the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1102.1">ApplyScoreMultiplier</span></strong><span class="kobospan" id="kobo.1103.1"> method with the specified </span><span><span class="kobospan" id="kobo.1104.1">multiplier value.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1105.1">case RewardType.SecretArea</span></strong><span class="kobospan" id="kobo.1106.1">: This case allows items to be found in </span><span><span class="kobospan" id="kobo.1107.1">secret areas.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1108.1">case RewardType.Coins</span></strong><span class="kobospan" id="kobo.1109.1">: This case grants coins to the player by invoking the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1110.1">GrantCoins</span></strong><span class="kobospan" id="kobo.1111.1"> method with the specified </span><span><span class="kobospan" id="kobo.1112.1">coin amount.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1113.1">private void ApplyScoreMultiplier(int multiplier)</span></strong><span class="kobospan" id="kobo.1114.1">: This method applies a score multiplier to the player’s score by invoking the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1115.1">ApplyMultiplier</span></strong><span class="kobospan" id="kobo.1116.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1117.1">ScoreManager</span></strong> <span><span class="kobospan" id="kobo.1118.1">singleton instance.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1119.1">private void GrantCoins(int coinAmount)</span></strong><span class="kobospan" id="kobo.1120.1">: This method adds coins to the player’s currency balance by invoking the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1121.1">AddCoins</span></strong><span class="kobospan" id="kobo.1122.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1123.1">CurrencyManager</span></strong> <span><span class="kobospan" id="kobo.1124.1">singleton instance.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1125.1">Overall, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1126.1">RewardManager</span></strong><span class="kobospan" id="kobo.1127.1"> class provides a centralized mechanism for managing and granting various types of rewards to the player upon </span><span><span class="kobospan" id="kobo.1128.1">completing challenges.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1129.1">The following code block contains </span><strong class="source-inline"><span class="kobospan" id="kobo.1130.1">CurrencyManager</span></strong><span class="kobospan" id="kobo.1131.1">, which is responsible for overseeing in-game</span><a id="_idIndexMarker306" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1132.1"> currency. </span><span class="kobospan" id="kobo.1132.2">However, the focus here is on a segment dedicated to adding coins to </span><span><span class="kobospan" id="kobo.1133.1">the player:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1134.1">
   Public class CurrencyManager : Singlton&lt;CurrencyManager&gt;
   {
       private int currentCoins;
       public void AddCoins(int amount)
       {
           currentCoins += amount;
           Debug.Log($"Coins: {currentCoins}");
       }
   }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1135.1">Here’s an explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1136.1">CurrencyManager</span></strong></span><span><span class="kobospan" id="kobo.1137.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1138.1">private int currentCoins</span></strong><span class="kobospan" id="kobo.1139.1">: This variable stores the current number of coins the </span><span><span class="kobospan" id="kobo.1140.1">player has.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1141.1">public void AddCoins(int amount)</span></strong><span class="kobospan" id="kobo.1142.1">: This method allows you to add coins to the player’s currency balance. </span><span class="kobospan" id="kobo.1142.2">It takes an integer parameter amount, representing the number of coins to add to the </span><span><span class="kobospan" id="kobo.1143.1">current balance.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1144.1">currentCoins += amount</span></strong><span class="kobospan" id="kobo.1145.1">: This line increments the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1146.1">currentCoins</span></strong><span class="kobospan" id="kobo.1147.1"> variable by the specified amount, effectively adding coins to the </span><span><span class="kobospan" id="kobo.1148.1">player’s balance.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1149.1">Overall, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1150.1">CurrencyManager</span></strong><span class="kobospan" id="kobo.1151.1"> class provides a simple yet essential functionality for managing the player’s currency balance, specifically adding coins to their </span><span><span class="kobospan" id="kobo.1152.1">total balance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1153.1">The following code block contains </span><strong class="source-inline"><span class="kobospan" id="kobo.1154.1">ScoreManager</span></strong><span class="kobospan" id="kobo.1155.1">, which is tasked with managing the player’s score and </span><a id="_idIndexMarker307" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1156.1">implementing a </span><span><span class="kobospan" id="kobo.1157.1">scoring multiplier:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1158.1">
    public class ScoreManager : Singlton&lt;ScoreManager&gt;
    {
        private float currentScore;
        private int scoreMultiplier = 1;
        public void ApplyMultiplier(int multiplier)
        {
            scoreMultiplier *= multiplier;
        }
        private void ResetMultiplier()
        {
            scoreMultiplier = 1;
        }
        public void AddScore(int scoreValue)
        {
            // Adjust score based on the current multiplier
            currentScore += scoreValue * scoreMultiplier;
            Debug.Log($"Score: {currentScore}");
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1159.1">Here’s an explanation of</span><a id="_idIndexMarker308" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1160.1"> the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1161.1">ScoreManager</span></strong></span><span><span class="kobospan" id="kobo.1162.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1163.1">private float currentScore</span></strong><span class="kobospan" id="kobo.1164.1">: This variable stores the current score of </span><span><span class="kobospan" id="kobo.1165.1">the player.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1166.1">private int scoreMultiplier = 1</span></strong><span class="kobospan" id="kobo.1167.1">: This variable represents the score multiplier, which starts at </span><strong class="source-inline1"><span class="kobospan" id="kobo.1168.1">1</span></strong> <span><span class="kobospan" id="kobo.1169.1">by default.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1170.1">public void ApplyMultiplier(int multiplier)</span></strong><span class="kobospan" id="kobo.1171.1">: This method allows you to apply a score multiplier to the current score. </span><span class="kobospan" id="kobo.1171.2">It takes an integer parameter multiplier, which adjusts the score </span><span><span class="kobospan" id="kobo.1172.1">multiplier accordingly.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1173.1">*scoreMultiplier = multiplier</span></strong><span class="kobospan" id="kobo.1174.1">: This line multiplies the existing score multiplier by the specified multiplier, effectively adjusting the </span><span><span class="kobospan" id="kobo.1175.1">score multiplier.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1176.1">private void ResetMultiplier()</span></strong><span class="kobospan" id="kobo.1177.1">: This method resets the score multiplier to its default value </span><span><span class="kobospan" id="kobo.1178.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1179.1">1</span></strong></span><span><span class="kobospan" id="kobo.1180.1">.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1181.1">public void AddScore(int scoreValue)</span></strong><span class="kobospan" id="kobo.1182.1">: This method adds a specified score value to the player’s current score. </span><span class="kobospan" id="kobo.1182.2">It takes an integer parameter called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1183.1">scoreValue</span></strong><span class="kobospan" id="kobo.1184.1">, representing the score to add to the </span><span><span class="kobospan" id="kobo.1185.1">current score.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1186.1">currentScore += scoreValue * scoreMultiplier</span></strong><span class="kobospan" id="kobo.1187.1">: This line adjusts the current score based on the score value and the current score multiplier. </span><span class="kobospan" id="kobo.1187.2">It multiplies the score value by the score multiplier and adds it to the </span><span><span class="kobospan" id="kobo.1188.1">current score.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1189.1">Overall, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1190.1">ScoreManager</span></strong><span class="kobospan" id="kobo.1191.1"> class handles score calculations and updates, including applying multipliers and adding score values to the player’s </span><span><span class="kobospan" id="kobo.1192.1">total score.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1193.1">This example </span><a id="_idIndexMarker309" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1194.1">highlights the vital relationship between challenges and the reward system in game development. </span><span class="kobospan" id="kobo.1194.2">Challenges provide engaging obstacles and objectives, fostering player interaction and progression. </span><span class="kobospan" id="kobo.1194.3">Integrated with the reward system, completing challenges becomes not just an accomplishment but a satisfying experience, offering incentives that motivate players. </span><span class="kobospan" id="kobo.1194.4">This dynamic interplay enhances the overall gaming experience, ensuring players remain engaged, motivated, and fulfilled throughout their journey in the </span><span><span class="kobospan" id="kobo.1195.1">game world.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1196.1">In </span><a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1197.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.1198.1">, which focuses on data handling, I intend to introduce a save system that will store all pertinent data, encompassing the elements we’ve discussed so far. </span><span class="kobospan" id="kobo.1198.2">This chapter will delve into</span><a id="_idIndexMarker310" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1199.1"> the specifics of implementing </span><span><span class="kobospan" id="kobo.1200.1">this system.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1201.1">The provided scripts serve as demonstrations, and you can find the complete logic in this book’s </span><span><span class="kobospan" id="kobo.1202.1">GitHub repository.</span></span></p>
<h1 id="_idParaDest-71" class="calibre5"><a id="_idTextAnchor073" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1203.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1204.1">In this chapter, we delved into essential Unity game development principles, specifically addressing game mechanics with a focus on C#. </span><span class="kobospan" id="kobo.1204.2">We underscored their significance in shaping engaging gameplay, encompassing aspects such as balance, feedback, and player agency. </span><span class="kobospan" id="kobo.1204.3">This provided you with practical skills in C# coding for implementing effective game mechanics. </span><span class="kobospan" id="kobo.1204.4">Transitioning to the next section, </span><em class="italic"><span class="kobospan" id="kobo.1205.1">Implementing player behavior and AI logic using C#</span></em><span class="kobospan" id="kobo.1206.1">, we explored player behavior design and foundational AI concepts. </span><span class="kobospan" id="kobo.1206.2">Additionally, we emphasized the crucial role of challenges and reward systems in elevating the player experience and </span><span><span class="kobospan" id="kobo.1207.1">fostering engagement.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1208.1">In </span><a href="B22017_05.xhtml#_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1209.1">Chapter 5</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.1210.1">,</span></em> <em class="italic"><span class="kobospan" id="kobo.1211.1">Designing Optimized User Interfaces with C# for Unity Games</span></em><span class="kobospan" id="kobo.1212.1">, you will delve into the domain of UI design principles and responsive UI elements. </span><span class="kobospan" id="kobo.1212.2">By mastering UI design techniques using C#, you’ll be able to craft visually appealing and immersive interfaces. </span><span class="kobospan" id="kobo.1212.3">This chapter aims to augment your skills in designing effective visual hierarchies, layouts, and responsive UI elements, ultimately contributing to an enhanced user experience, including optimized </span><span><span class="kobospan" id="kobo.1213.1">UI elements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1214.1">As you embark on this ongoing journey of skill-building, the upcoming chapter holds exciting challenges and discoveries. </span><span><span class="kobospan" id="kobo.1215.1">Happy coding!</span></span></p>
</div>
</body></html>