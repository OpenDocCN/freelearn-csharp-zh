<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>1. An Introduction to Patterns and Pattern Catalogs</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;1.&#160;An Introduction to Patterns and Pattern Catalogs">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch01"></a>Chapter&#160;1.&#160;An Introduction to Patterns and Pattern Catalogs</h1>
            </div>
          </div>
        </div>
        <p>Design patterns have always fascinated software developers, yet true knowledge of their applicability and consequences has eluded many. The various solutions that have been created and applied to solve similar problems have been studied over time by experienced developers and architects. A movement slowly began to catalog such time-tested and successful solutions, which served as a blueprint for software design. The applicability of design patterns exhibited maturity (even though over-engineering was a perceived risk) in solution architecture (in terms of stability, consistency, maintainability, and extensibility), and became a core skill for serious developers and architects. In this introduction to patterns and pattern catalogs, the authors wish to provide a detailed illustration of the movement in the software development industry that led to the discovery and consolidation of the various patterns and pattern catalogs. It is equally important to understand the evolution of patterns, idioms, programming languages, and standards that led to standardization of these technology-agnostic blueprints, which form the basis of enterprise application development today. We will cover the following topics in this regard:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">History of <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>) techniques, idioms, and patterns</li>
            <li class="listitem" style="list-style-type: disc">Patterns and pattern movement</li>
            <li class="listitem" style="list-style-type: disc">Key patterns and pattern catalogs</li>
            <li class="listitem" style="list-style-type: disc">Key C# language features that facilitate implementation of OOP techniques, idioms, and patterns</li>
          </ul>
        </div>
        <div class="section" title="OOP - A short history">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch01lvl1sec7"></a>OOP - A short history</h1>
              </div>
            </div>
          </div>
          <p>OOP is a programming model that is supposed to combine structure (data) and behavior (methods) to deliver software functionality. This was a marked contrast from the procedural programming model, which was mostly in vogue when the OOP model gained prominence. The primary unit of composition in a procedural programming model is a procedure (mostly a function with side-effects). Data is fed into a series of procedures that constitutes the process or algorithm in a solution context. In the case of OOP, the data and related functions are represented together as a class, which acts as a fundamental unit in the programming model. Schematically it is as follows:</p>
          <pre class="programlisting">    Class Test 
    { 
      &lt;------ Static (Class Level) Variables ---------------&gt; 
      &lt;------ Instance (Object Level) Variables ------------&gt; 
      &lt;------ Private Methods ------------------------------&gt; 
      &lt;------ Public Methods -------------------------------&gt; 
    } 
</pre>
          <p>As a programmer, one can create many instances of a class during the execution of a program. Since class encapsulates data and its associated operations to provide a coherent entity, the problems (or rather side-effects) associated with global variables/data (being used as payload for the procedures) went away all of a sudden. This helped to manage the complexity of developing large software.</p>
          <p>OOP revolutionized the way programmers modeled the problem domain, with class compositions leveraging encapsulation, association, inheritance, and polymorphism. Additionally, with the flexibility to model hierarchies (that closely represent the problem domain) with ease, it became natural for developers to think in terms of objects.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note3"></a>Note</h3>
              <p>The origin of OOP can be traced back to the Simula programming language created by Kristen Nygaard and Ole-Johan Dahl, released in the year 1965. The advent of the&#160;<span class="strong"><strong>Smalltalk</strong></span> system helped the ideas of OOP to percolate to the academia and some consulting circles. Smalltalk was a dynamically typed language, and primarily designed as a message passing system. Later, they added Simula's class-based Object model. Alan Kay, Dan Inaglis, and Adele Goldberg at Xerox PARC designed the language.</p>
            </div>
          </div>
          <p>The OOP model reached a critical mass in the early 1990s, with the popularity of the C++ programming language. Even though Smalltalk and C++ were OOP languages, Smalltalk was a dynamically typed programming language, and C++ was a statically typed (though weakly enforced) programming language. The C++ programming language was created by Bjarne Stroustrup at the AT&amp;T Bell Laboratories, as an extension of C (for wider adoption). In this regard, C++, as a programming language, has issues in terms of usage because of the compulsion to make it C-compatible. The story of evolution of the language is well chronicled in, <span class="emphasis"><em>The Design and Evolution of C++</em></span>, a book written by Bjarne himself. The book deals with the rationale of designing the language and the design choices available for him to incorporate features such as single inheritance, multiple inheritance, virtual methods, exception handling, templates (Generics), I/O streams, and so on. Any serious C++ developer should not miss this particular book, as it helps to understand the reason why the C++ programming language is the way it is!</p>
          <p>There were attempts to make protocol-based development using middleware technologies like Microsoft's <span class="strong"><strong>Component Object Model</strong></span> (<span class="strong"><strong>COM</strong></span>) and OMG's <span class="strong"><strong>Common Object Request Broker Architecture</strong></span> (<span class="strong"><strong>CORBA</strong></span>). Both CORBA and COM were very similar, and both facilitated object interoperability at the binary level. Each protocol had its own binary encoding format, and interoperability between these two standards became a problem. Some enterprising companies made a living by writing COM/CORBA bridge to rectify this problem. Also, COM was mostly available only on Microsoft Windows, making it a platform-specific solution.</p>
          <p>Then, in 1996, Sun Microsystems came up with a language which was marketed as a programming language to write applications that are hosted in a browser (Applets). They named it Java. However, due to performance and political reasons, applet development did not took off. The language, along with its associated platform, was soon projected as a server-side programming system. This was a tremendous success, and the Java language made a strong comeback, further popularizing the OOP programming model. The primary architect of the Java language was James Gosling.</p>
          <p>In the year 2001, Microsoft released C#, a brand new OOP language for their new virtual machine development platform, known as .NET. Later, Microsoft did add support for generics, lambda, dynamic typing, and LINQ, among others, to make C# one of the most powerful programming languages in the world. The primary architect of the language was Anders Hejlsberg.</p>
          <p>Meanwhile, languages such as Ruby and Python made an appearance, and are still relevant in certain areas. Then, there were object-functional languages such as F#, Scala, Groovy, Clojure, and so on. However, the OOP model is symbolized by C++, C#, and Java.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Patterns and pattern movement">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch01lvl1sec8"></a>Patterns and pattern movement</h1>
            </div>
          </div>
        </div>
        <p>Programmers of the early 1990s struggled a lot to understand OOP, and how to effectively use them in large projects. Without a viral medium such as the Internet, it was quite a struggle for them. Early adopters published technical reports, wrote in periodicals/journals, and conducted seminars to popularize OOP techniques. Magazines such as&#160;<span class="emphasis"><em>Dr. Dobbs Journal</em></span> and <span class="emphasis"><em>C++ Report</em></span> carried columns featuring OOP.</p>
        <p>A need was felt to transfer the wisdom of the experts to the ever-increasing programming community, but this knowledge propagation was not happening. The legendary German mathematician Carl Friedrich Gauss once remarked, <span class="emphasis"><em>"Always learn from the masters"</em></span>. Even though Gauss had mathematics in mind, it is true for any non-trivial human endeavor. However,&#160;there were very few masters of the OOP techniques, and the apprenticeship model was not scaling well.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note4"></a>Note</h3>
            <p>James Coplien published an influential book titled&#160;<span class="emphasis"><em>Advanced C++ Programming Styles and Idioms</em></span>, which dealt with low-level patterns (idioms) associated with the usage of the C++ programming language. Despite being not widely cited, authors consider this a notable book towards cataloguing the best practices and techniques of OOP.</p>
          </div>
        </div>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">It was during this time that Erich Gamma began his work on a pattern catalog as part of his PhD thesis, inspired by an architect named Christopher Alexander. Christopher Alexander's <span class="emphasis"><em>A Pattern Language - Towns, Buildings, Construction</em></span> was a source of inspiration for Erich Gamma. Then, people with similar ideas, namely Ralph Johnson, John Vlissides, and Richard Helm, joined hands with Erich Gamma to create a catalog of 23 patterns, now popularly known as the <span class="strong"><strong>Gang of Four</strong></span> (<span class="strong"><strong>GoF</strong></span>) design patterns. Addison Wesley published the book&#160;<span class="emphasis"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></span> in the year 1994. This soon became a great reference for the programmer, and fueled software development based on patterns. The GoF catalog was mostly focused on software design.</li>
            <li class="listitem" style="list-style-type: disc">In the year 1996, a group of engineers from Siemens published a book titled <span class="emphasis"><em>Pattern-Oriented Software Architecture</em></span>, which focused mostly on the architectural aspects of building a system. The entire <span class="strong"><strong>Pattern-Oriented Software Architecture</strong></span> (<span class="strong"><strong>POSA</strong></span>) pattern catalog was documented in five books published by John Wiley and Sons. The group was joined by Douglas Schmidt, the creator of the <span class="strong"><strong>Adaptive Communication Environment</strong></span> (<span class="strong"><strong>ACE</strong></span>) network programming library and <span class="strong"><strong>TAO</strong></span> (<span class="strong"><strong>The ACE ORB</strong></span>). He later became the chair of <span class="strong"><strong>Object Management Group</strong></span> (<span class="strong"><strong>OMG</strong></span>), which develops, adopts, and maintains standards such as CORBA and UML.</li>
            <li class="listitem" style="list-style-type: disc">Another influential catalog was published by Martin Fowler in a book titled <span class="emphasis"><em>Patterns of Enterprise Application Architecture</em></span> in the year 2001. The book mostly focused on patterns that come up while developing enterprise applications using the JEE and .NET frameworks. Incidentally, most of the code snippets were in Java and C#.</li>
            <li class="listitem" style="list-style-type: disc">Gregor Hohpe and Bobby Woolf published a pattern catalog to document the patterns that arise in the enterprise integration scenario. Their catalog titled <span class="emphasis"><em>Enterprise Integration Patterns</em></span>, published as part of the Martin Fowler signature book series, is widely recognized as a source of ideas regarding enterprise integration techniques. The Apache Camel integration library is inspired by this book.</li>
            <li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Core J2EE Patterns: Best Practices and Design Strategies</em></span> (by Deepak Alur et al.), although a platform-specific catalog, is a rich source of ideas regarding the structuring of an enterprise application. The book includes patterns for presentation, data, and service tiers in web application development.</li>
            <li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Domain-Driven Design</em></span>, published by Eric Evans in the year 2003, deals with a technique called <span class="strong"><strong>domain-driven design</strong></span> (<span class="strong"><strong>DDD</strong></span>). The book uses GoF and <span class="strong"><strong>Patterns of Enterprise Application Architecture</strong></span> (<span class="strong"><strong>POEAA</strong></span>) patterns to put forward a design methodology that focuses on building a persistent ignorant domain model. The book also introduces some patterns and idioms for structuring domain logic.</li>
            <li class="listitem" style="list-style-type: disc">Jim Arlow and Ila Nuestadt published a book entitled <span class="emphasis"><em>Enterprise Patterns and MDA</em></span>, which catalogued a set of patterns based on the <span class="emphasis"><em>Jungian Archetypes</em></span>. This catalog contains nine top-level archetypes and 168 business archetypes for developing applications.</li>
          </ul>
        </div>
        <p>The following figure illustrates the evolution of design methodologies, programming languages, and pattern catalogs:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_01_01.jpg" alt="Patterns and pattern movement"/>
        </div>
        <p>
</p>
        <div class="section" title="Key pattern catalogs">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch01lvl2sec5"></a>Key pattern catalogs</h2>
              </div>
            </div>
          </div>
          <p>Patterns are most often catalogued in some kind of pattern repository. Some of them are published as books. The most popular and widely used pattern catalog is GoF, named after the four collaborators that produced them. They are Eric Gama, Ralph Johnson, John Vlissides, and Richard Helm.</p>
          <div class="section" title="GoF patterns">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec0"></a>GoF patterns</h3>
                </div>
              </div>
            </div>
            <p>The GoF catalog, named after the four creators of the catalog, started the pattern movement. The creators mostly focused on designing and architecting object-oriented software. The ideas of Christopher Alexander were borrowed to the software engineering discipline, and applied to application architecture, concurrency, security, and so on. The GoF divided the catalog into structural, creational, and behavioral patterns. The original book used C++ and Smalltalk to explain&#160;the concepts. These patterns have been ported and leveraged in most of the programming languages that exist today.</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern type</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Creational patterns</p>
</td>
                    <td>
<p>Abstract factory, builder, factory method, prototype, singleton.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Structural patterns</p>
</td>
                    <td>
<p>Adapter, bridge, composite, decorator, facade, flyweight, proxy.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Behavioral patterns</p>
</td>
                    <td>
<p>Chain of responsibility, command, interpreter, iterator, mediator, memento, observer, state, strategy, template method, visitor.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>We believe that a good understanding of the GoF patterns is necessary for any programmer. These patterns occur everywhere, regardless of the application domain. GoF patterns help us to communicate and reason about systems in a language-agnostic manner. They are widely implemented in the .NET and Java world.</p>
          </div>
          <div class="section" title="POSA catalog">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec1"></a>POSA catalog</h3>
                </div>
              </div>
            </div>
            <p>POSA Volume 5 is an influential book series, which covers most of the applicable patterns while developing mission-critical systems. An element of bias is seen towards native code programming; perhaps C++ was the prevalent OOP language during the time of research. The catalog, which spanned five published volumes, is listed as follows:</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern type</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Architectural</p>
</td>
                    <td>
<p>Layers, pipes and filters, blackboard, broker, MVC, presentation-abstraction-control, microkernel, reflection.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Design</p>
</td>
                    <td>
<p>Whole-part, mater-slave, proxy, command processor, view handler, forwarder-receiver, client-dispatcher-server, publisher-subscriber.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Service access and configuration patterns</p>
</td>
                    <td>
<p>Wrapper façade, component configurator, interceptor, extension interface.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>4</p>
</td>
                    <td>
<p>Event handling patterns</p>
</td>
                    <td>
<p>Reactor, proactor, asynchronous completion token, acceptor-connector.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>5</p>
</td>
                    <td>
<p>Synchronization patterns</p>
</td>
                    <td>
<p>Scoped locking, strategized locking, thread-safe interface, double-checked locking optimization.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>6</p>
</td>
                    <td>
<p>Concurrency patterns</p>
</td>
                    <td>
<p>Active object, monitor object, half-sync/half-async, leader/followers, thread-specific storage.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>7</p>
</td>
                    <td>
<p>Resource acquisition patterns</p>
</td>
                    <td>
<p>Lookup, lazy acquisition, eager acquisition, partial acquisition.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>8</p>
</td>
                    <td>
<p>Resource lifecycle</p>
</td>
                    <td>
<p>Caching, pooling, coordinator, resource lifecycle manager.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>9</p>
</td>
                    <td>
<p>Resource release patterns</p>
</td>
                    <td>
<p>Leasing, evictor.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>10</p>
</td>
                    <td>
<p>A pattern language for distributive computing</p>
</td>
                    <td>
<p>Consolidation of patterns from different catalogs in the context of distributed programming.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>11</p>
</td>
                    <td>
<p>On patterns and pattern languages</p>
</td>
                    <td>
<p>This last volume gives some meta information about patterns, pattern languages, and their usage.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>We believe the POSA catalog is very important (to the extent, one of the author feels, that if someone has not heard about the POSA catalog, he or she does not understand patterns) if one is writing middleware servers and scalable web infrastructure. For some reason, it has not got the kind of traction that it deserves. They are very useful for writing server-class software infrastructure such as web containers, application containers, and other middleware components.</p>
          </div>
          <div class="section" title="POEAA catalog">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec2"></a>POEAA catalog</h3>
                </div>
              </div>
            </div>
            <p>Martin Fowler, along with some co-authors, published a book entitled&#160;<span class="emphasis"><em>Patterns of Enterprise Application Architecture</em></span>. The book is a treasure trove of patterns, that helps one to structure and organize the design of enterprise applications using .NET and Java. Some of Fowler's pattern has been leveraged in the context of distributed computing by POSA-Volume 4 authors.</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern type</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Domain logic</p>
</td>
                    <td>
<p>Transaction script, domain model, table module, service layer.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Data source architectural patterns</p>
</td>
                    <td>
<p>Table data gateway, row data gateway, active record, data mapper.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Object-relational behavioral patterns</p>
</td>
                    <td>
<p>Unit of work, identity map, lazy load.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>4</p>
</td>
                    <td>
<p>Object-relational structural patterns</p>
</td>
                    <td>
<p>Identity field, foreign key mapping, association table mapping, dependent mapping, embedded value, serialized LOB, single table inheritance, class table inheritance, concrete table inheritance, inheritance mappers.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>5</p>
</td>
                    <td>
<p>Object-relational metadata mapping patterns</p>
</td>
                    <td>
<p>Metadata mapping, query object, repository.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>6</p>
</td>
                    <td>
<p>Web presentation patterns</p>
</td>
                    <td>
<p>Model view controller, page controller, front controller, template view, transform view, two-step view, application controller.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>7</p>
</td>
                    <td>
<p>Distribution patterns</p>
</td>
                    <td>
<p>Remote facade, data transfer object.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>8</p>
</td>
                    <td>
<p>Offline concurrency patterns</p>
</td>
                    <td>
<p>Optimistic offline lock, pessimistic offline lock, coarse grained lock, implicit lock.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>9</p>
</td>
                    <td>
<p>Session state patterns</p>
</td>
                    <td>
<p>Client session state, server session state, database session state.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>10</p>
</td>
                    <td>
<p>Base patterns</p>
</td>
                    <td>
<p>Gateway, mapper, layer supertype, separated interface, registry, value object, money, special case, plugin, service stub, record set.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>The POEAA catalog is a rich source of ideas when it comes to enterprise application software development. Some of these patterns are implemented by frameworks such as Spring (including Spring.NET), Nhibernate/Entity Framework, <span class="strong"><strong>Windows Communication Foundation</strong></span> (<span class="strong"><strong>WCF</strong></span>), and <span class="strong"><strong>Windows Presentation Foundation</strong></span> (<span class="strong"><strong>WPF</strong></span>). Awareness about the POEAA catalog helps one to reason about the architecture of pretty much everything happening in the .NET platform.</p>
          </div>
          <div class="section" title="EIP catalog">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec3"></a>EIP catalog</h3>
                </div>
              </div>
            </div>
            <p>A modern day enterprise requires information to flow from one application to another, in real time or while offline. Since applications use different implementation technologies, we require message passing systems to transfer the data. Most often, these communications happen in an asynchronous manner. The <span class="strong"><strong>Enterprise Integration Patterns</strong></span> (<span class="strong"><strong>EIP</strong></span>) catalog deals with time-tested solutions by professionals, who have cut their teeth on integration issues for recurring problems.</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern type</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Messaging systems</p>
</td>
                    <td>
<p>Message channel, message, pipes and filters, message router, message translator, message endpoint.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Messaging channels</p>
</td>
                    <td>
<p>Point-to-point channel, publish-subscribe channel, datatype channel, invalid message channel, dead letter channel, guaranteed delivery, channel adapter, messaging bridge, message bus.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Message construction</p>
</td>
                    <td>
<p>Command message, document message, event message, request-reply, return address, correlation identifier, message sequence, message expiration, format indicator.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>4</p>
</td>
                    <td>
<p>Message routing</p>
</td>
                    <td>
<p>Content-based router, message filter, dynamic router, recipient list, splitter, aggregator, resequencer, composed message processor, scatter-gather, routing slip, process manager, message broker.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>5</p>
</td>
                    <td>
<p>Message transformation</p>
</td>
                    <td>
<p>Envelope wrapper, content enricher, content filter, claim check, normalizer, canonical data model.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>6</p>
</td>
                    <td>
<p>Messaging endpoints</p>
</td>
                    <td>
<p>Messaging gateway, messaging mapper, transactional client, polling consumer, event-driven consumer, competing consumers, message dispatcher, selective consumer, durable subscriber, idempotent receiver, service activator.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>7</p>
</td>
                    <td>
<p>System management</p>
</td>
                    <td>
<p>Control bus, detour, wire tap, message history, message store, smart proxy, test message, channel purger.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>The EIP catalog is a very influential one in transferring knowledge about strategies for asynchronous messaging and point-to-point synchronous communication between applications. The Apache Camel library implements most of the commonly occurring patterns, while doing <span class="strong"><strong>Enterprise Application Integration</strong></span> (<span class="strong"><strong>EAI</strong></span>). The authors feel that this catalog is worth studying should one embark on a project that requires information/data flow from one system to another, including mobile device communication with backend services (MBAAS) that involves data synchronization and queuing mechanisms.</p>
          </div>
          <div class="section" title="J2EE design patterns catalog">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec4"></a>J2EE design patterns catalog</h3>
                </div>
              </div>
            </div>
            <p>This is a catalog that captures design experience in the form of a book entitled <span class="emphasis"><em>Core J2EE Patterns: Best Practices and Design Strategies</em></span> by Deepak Alur, John Crupi, and Dan Malks. The book and the associated website deals with common solutions that&#160;can be leveraged while writing enterprise web applications. Even though conceived for the J2EE platform, the patterns outlined in the catalog can be used in any context where there is a programming model similar to the J2EE platform. Fortunately, the .NET server-side model is very similar to J2EE.</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern class</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Business tier pattern</p>
</td>
                    <td>
<p>Business delegate, session facade, service locator, transfer object, composite entity, transfer object, assembler, value list handler, business object, application service.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Presentation tier patterns</p>
</td>
                    <td>
<p>Intercepting filter, front controller, composite view, view helper, service to worker, dispatcher view, context object, application controller.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Integration patterns</p>
</td>
                    <td>
<p>Data access object, service activator, domain store, web service broker.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>The authors believe that the J2EE catalog has been used extensively in the .NET platform, especially after Microsoft released the ASP.Net MVC programming model. The catalog is a rich source of ideas to structure your enterprise web application.</p>
          </div>
          <div class="section" title="DDD-based patterns">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec5"></a>DDD-based patterns</h3>
                </div>
              </div>
            </div>
            <p>The book entitled <span class="emphasis"><em>Domain-Driven Design</em></span> by Eric J. Evans, released in the year 2003, is not a book on patterns in itself. The primary goal of the book is to outline a method by which one can create persistent ignorant domain models by leveraging the ubiquitous language used by the stakeholders in a business scenario. The book contains a lot of patterns and idioms for architecture, design, and application integration, in a model-driven manner.</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern type</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Patterns for supple design</p>
</td>
                    <td>
<p>Intention-revealing interfaces, side-effect-free functions, assertions, conceptual contours, standalone classes, closure of operations, declarative design.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Patterns for domain model expression</p>
</td>
                    <td>
<p>Associations, entities (reference objects), value objects, services, modules (packages).</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Patterns for domain model integrity</p>
</td>
                    <td>
<p>Bounded context, context map, shared kernel, anticorruption layer, open host service, published language.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>4</p>
</td>
                    <td>
<p>Patterns for domain model distillation</p>
</td>
                    <td>
<p>Core domain, generic subdomains, segregated core, abstract core.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>This is one of the most influential books in terms of thought leadership towards creating a methodology that goes along with the Agile development models. The ideas from this book have percolated deep&#160;into building the present day software systems.</p>
          </div>
          <div class="section" title="Arlow/Nuestadt patterns">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a id="ch01lvl3sec6"></a>Arlow/Nuestadt patterns</h3>
                </div>
              </div>
            </div>
            <p>Jim Arlow and Ila Nuestadt published a book entitled <span class="emphasis"><em>Enterprise Patterns and MDA</em></span>. The book is based on the concept of an archetype borrowed from the works of Carl Gustav Jung. Archetypes are primordial entities that occur time and again in the sociocultural context across cultures. Business archetypes are entities that occur in a business context (where business is a socio-economic activity). The business archetypes covered in the book include party, CRM, product, business rules, order, inventory, units, and so on. Archetypes help model the business problem, and this gives a clear indication of the expected composition and behavior of the solution. Archetypes are a powerful meme that provide direct mapping between the business and solution models, thereby avoiding mismatch during business analysis, design, and implementation. The ideas and schema from the book can be used to write better enterprise software products.</p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col/>
                  <col/>
                  <col/>
                </colgroup>
                <tbody>
                  <tr>
                    <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Pattern type</strong></span>
</p>
</td>
                    <td>
<p>
<span class="strong"><strong>Patterns</strong></span>
</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>1</p>
</td>
                    <td>
<p>Party archetype pattern</p>
</td>
                    <td>
<p>PartyIdentifier, RegisteredIdentifier, PartySignature, PartyAuthentication, address, person, ISOGender, ethnicity, BodyMetrics, PersonName, organization, company, company names, identifiers for companies, company organizational units, partnerships and sole proprietors, preferences, PartyManager.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>2</p>
</td>
                    <td>
<p>Party relationship archetype pattern</p>
</td>
                    <td>
<p>PartyRole, PartyRoleType, PartyRelationshipType, responsibilities, capabilities.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>3</p>
</td>
                    <td>
<p>Customer relationship management archetype pattern</p>
</td>
                    <td>
<p>Customer, CustomerCommunicationManager, customer communication, CustomerServiceCase.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>4</p>
</td>
                    <td>
<p>Product archetype pattern</p>
</td>
                    <td>
<p>ProductType, ProductInstance, SerialNumber, batch, product specification, ProductCatalog, CatalogEntry, packages, PackageType, package instance, combining ProductTypes, rule-driven package specification, ProductRelationships, price, package pricing, measured products, services, ServiceType and ServiceInstance, product pleomorphs.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>5</p>
</td>
                    <td>
<p>Inventory archetype pattern</p>
</td>
                    <td>
<p>The inventory archetype, ProductInventoryEntry, ServiceInventoryEntry, inventory capacity planning, inventory management, availability, reservations.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>6</p>
</td>
                    <td>
<p>Order archetype pattern</p>
</td>
                    <td>
<p>The order archetype, PurchaseOrder, SalesOrder, OrderLine, PartySummaryRoleInOrder, DeliveryReceiver, ChargeLine, OrderManager, OrderEvents, order status, LifeCycleEvents, AmendEvents, AmendOrderLineEvent, AmendPartySummaryEvent, AmendTermsAndConditionsEvent, DiscountEvent, DespatchEvent, ReceiptEvent, OrderPayment, PaymentEvents, payment strategy, PurchaseOrder process, PurchaseOrder cancellation, process PurchaseOrder, SalesOrder process archetype, SalesOrder process, process SalesOrder, OrderProcess documentation.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>7</p>
</td>
                    <td>
<p>Quantity archetype pattern</p>
</td>
                    <td>
<p>Quantity archetype pattern, metric, units/SystemOfUnits, SIBaseUnit, DerivedUnit, ManHour, quantity, StandardConversion/UnitConverter.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>8</p>
</td>
                    <td>
<p>Money archetype pattern</p>
</td>
                    <td>
<p>Money archetype pattern, currency, locale, ISOCountryCode, ExchangeRate/CurrencyConverter, payment.</p>
</td>
                  </tr>
                  <tr>
                    <td>
<p>9</p>
</td>
                    <td>
<p>Rule archetype pattern</p>
</td>
                    <td>
<p>Rule archetype pattern, business rules/system rules, RuleElement, RuleContext, rule evaluation, ActivityRule, RuleSet, RuleOverride.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>The authors have borrowed ideas from the book, while creating an ontology for realizing a <span class="strong"><strong>domain-specific language</strong></span> (<span class="strong"><strong>DSL</strong></span>) on a mobile-based healthcare application. If one is embarking on creating a DSL-based system architecture, this book can be a good starting point for rich domain models based on business archetypes.</p>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Should we use all of these?">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch01lvl1sec9"></a>Should we use all of these?</h1>
            </div>
          </div>
        </div>
        <p>Pattern catalogs are available to deal with various concerns of software development, be it design, architecture, security, data, and so on. Most applications, or even frameworks, leverage only a fraction of the patterns listed earlier. Understanding the pattern catalogs and their applicability is a rich source of design ideas for any software developer. A developer should be careful to avoid the malady of so-called <span class="strong"><strong>pattern diarrhoea</strong></span>.</p>
        <div class="informaltable">
          <table border="1">
            <colgroup>
              <col/>
              <col/>
              <col/>
            </colgroup>
            <tbody>
              <tr>
                <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                <td>
<p>
<span class="strong"><strong>Pattern catalog</strong></span>
</p>
</td>
                <td>
<p>
<span class="strong"><strong>Primary use-case</strong></span>
</p>
</td>
              </tr>
              <tr>
                <td>
<p>1</p>
</td>
                <td>
<p>GoF patterns</p>
</td>
                <td>
<p>These are fundamental patterns which occur time and again, regardless of the domain. These are used in a context agnostic manner.</p>
</td>
              </tr>
              <tr>
                <td>
<p>2</p>
</td>
                <td>
<p>POSA catalog</p>
</td>
                <td>
<p>The areas where these patterns are relevant include concurrency management, distributed programming, middleware software, and so on.</p>
</td>
              </tr>
              <tr>
                <td>
<p>3</p>
</td>
                <td>
<p>POEAA catalog</p>
</td>
                <td>
<p>Enterprise web application development using .NET and JEE platforms.</p>
</td>
              </tr>
              <tr>
                <td>
<p>4</p>
</td>
                <td>
<p>EIP</p>
</td>
                <td>
<p>Application integration in modern enterprises.</p>
</td>
              </tr>
              <tr>
                <td>
<p>5</p>
</td>
                <td>
<p>J2EE design patterns</p>
</td>
                <td>
<p>Writing web applications using .NET and Java.</p>
</td>
              </tr>
              <tr>
                <td>
<p>6</p>
</td>
                <td>
<p>DDD</p>
</td>
                <td>
<p>In fact, this book is a framework for developing rich domain models in a persistent ignorant manner.</p>
</td>
              </tr>
              <tr>
                <td>
<p>7</p>
</td>
                <td>
<p>Arlow/Nuestadt</p>
</td>
                <td>
<p>Very useful when we are writing enterprise applications, and no need to break one's head to create the database schema. Most of the entities are available here as a business archetype.</p>
</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="The C# language and the .NET platform">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch01lvl1sec10"></a>The C# language and the .NET platform</h1>
            </div>
          </div>
        </div>
        <p>Microsoft (MS) initially placed their bets on an enterprise architecture strategy called <span class="strong"><strong>Windows DNA</strong></span>, centered on the <span class="strong"><strong>Distributed Component Object Model</strong></span> (<span class="strong"><strong>DCOM</strong></span>). The advent and traction of the Java programming model forced Microsoft to rework their strategy, so they decided to create a virtual machine platform called .NET. The .NET platform was released in 2002, and it was monikered Microsoft's Java. The old adage i<span class="emphasis"><em>mitation is the sincerest form of flattery</em></span> was echoed by industry pundits. Web development is done using the ASP.Net Web Forms programming model, and desktop development is based on Windows forms. They also created a new language for the new platform, named C#. For platform interoperability, they created .NET remoting architecture, which became the gateway for communication between homogeneous systems (including CLR-managed and unmanaged) via TCP and DCOM protocols. For communication with heterogeneous systems, open standards such as SOAP and WSDL were leveraged by remoting objects, either self-hosted or hosted, within an IIS context.</p>
        <p>In 2003, Microsoft released .NET v1.1, which fixed many of the bugs in .NET v1.0. The release of Microsoft .NET 1.1 encouraged people to bet their future on this platform. There was no application server in its offering. This led to some delay in the adoption of the platform. A code snippet in C#, which computes the average of a series of numbers through the command line, is shown as follows:</p>
        <pre class="programlisting">    // Chap1_01.cs 
    using System; 
    using System.Collections; 
    class Temp 
    { 
      public static void Main(String [] args) { 
      //---- accumulate command line arguments to  
      //---- to a list 
      ArrayList a = new ArrayList(); 
      for(int i=0; i&lt; args.Length; ++i) 
        a.Add(Convert.ToDouble(args[i])); 
      //----- aggregate value to a variable (sum) 
      double sum = 0.0; 
      foreach(double at in a) 
        sum = sum + at; 
      //------------ Compute the Average 
      double ar = sum/a.Count; 
      //------------ Spit value to the console 
      //------------ Wait for a Key  
      Console.WriteLine(ar); 
      Console.Read(); 
    } 
  } 
</pre>
        <p>In 2005, Microsoft added a lot of features to their platform, which included generics and anonymous delegates. With C# 2.0, we can rewrite the average computation program by using generics and anonymous delegates as follows:</p>
        <pre class="programlisting">    // -- Chap1_02.cs 
    using System; 
    using System.Collections; 
<span class="strong"><strong>    using System.Collections.Generic;public delegate double    
    Del(List&lt;double&gt; pa);</strong></span> 
    class Temp 
    { 
      public static void Main(String [] args) { 
      //----- Use a Generic List (List&lt;T&gt; ) 
      //----- to accumulate command line arguemnts 
      List&lt;double&gt; a = new List&lt;double&gt;(); 
      for(int i=0; i&lt; args.Length ; ++ i ) 
      a.Add(Convert.ToDouble(args[i])); 
      //--- Define a anonymous delegate and assign 
      //--- to the variable temp 
      //--- The delegate aggregates value and  
      //--- compute average 
<span class="strong"><strong>      Del temp = delegate(List&lt;double&gt; pa ) {</strong></span> 
        double sum = 0.0; 
        foreach( double at in pa ) 
          sum = sum + at; 
        return sum/pa.Count; 
      }; 
      //---- invoke the delegate 
      //---- and wait for the key 
      Console.WriteLine(temp(a)); 
      Console.Read(); 
     } 
   } 
</pre>
        <p>The release of .NET platform 3.0 overcame the shortcomings of the previous releases by introducing WCF, WPF, and <span class="strong"><strong>Windows Workflow Foundation</strong></span> (<span class="strong"><strong>WF</strong></span>), which coincided with the release of the Vista platform.</p>
        <p>Microsoft released version 3.5 of the platform with some key features including LINQ, lambda, and anonymous types. They also released the C# 3.0 programming language. Using type inference and lambda expressions, the average computation program is rewritten as follows:</p>
        <pre class="programlisting">    //--- Chap1_03.cs 
    using System; 
    using System.Collections; 
    using System.Collections.Generic; 
<span class="strong"><strong>    using System.Linq;</strong></span> 
    class Temp { 
      public static void Main(String [] args) { 
      //---- leverage type inference feature to assign 
      //---- a List&lt;T&gt; and accumulate values to that list 
      var a = new List&lt;double&gt;(); 
      for(int i=0; i&lt; args.Length ; ++ i ) 
        a.Add(Convert.ToDouble(args[i])); 
      //----- Define a Lambda function which passes 
      //----- through the value.  
<span class="strong"><strong>      Func&lt;double,double&gt; ar2 = (x =&gt; x );
</strong></span>
<span class="strong"><strong>      //------ use the Sum function available with List&lt;T&gt; </strong></span>
<span class="strong"><strong> 
      //------ to compute the average</strong></span> 
      var ar = a.Sum(ar2 )/a.Count; 
      //------ Spit the value to the console 
      Console.WriteLine(ar); 
      Console.Read(); 
    } 
  } 
</pre>
        <p>With Visual Studio 2010, Microsoft released C# 4.0 with support for dynamic programming. The following code snippet demonstrates dynamic typing (based on <code class="literal">DynamicObject</code>) and ExpandoObjects. The following code snippet shows how one can create a custom object that can add arbitrary properties and methods:</p>
        <pre class="programlisting">    // Chap1_04.cs 
    using System; 
    using System.Collections.Generic; 
    using System.Linq; 
    using System.Text; 
<span class="strong"><strong>    using System.Dynamic;</strong></span> 
 
    namespace TestVS 
    { 
      class DynamicClass : DynamicObject 
    { 
      //---- underlying container for storing  
      //---- Ibject memebers 
      private Dictionary&lt;string, Object&gt; props = 
      new Dictionary&lt;string, object&gt;(); 
 
      public DynamicClass() { } 
 
      //------- Retrieve value from a member 
      public override bool TryGetMember(GetMemberBinder binder,  
      out object result){ 
        string name = binder.Name.ToLower(); 
        return props.TryGetValue(name, out result); 
      } 
      public override bool TrySetMember(SetMemberBinder binder, 
      object value){ 
        props[binder.Name.ToLower()] = value; 
        return true; 
      } 
    } 
 
    class Program{ 
      static void Main(string[] args){ 
<span class="strong"><strong>        dynamic dc = new DynamicClass();</strong></span> 
        //--------- Adding a property 
        dc.hell = 10; 
        //--------read back the property... 
        Console.WriteLine(dc.hell); 
        //------- Creating an Action delegate... 
        Action&lt;int&gt; ts = new Action&lt;int&gt;( delegate(int i ) { 
          Console.WriteLine(i.ToString()); 
        }); 
        //------------Adding a method.... 
        dc.rs = ts; 
        //----------- invoking a method.... 
        dc.rs(100); 
        Console.Read(); 
      } 
    } 
  } 
</pre>
        <p>The following code snippet shows how one can use <code class="literal">ExpandoObject</code> to add a property to a type we created. We will be leveraging the dynamic feature of C# 4.0:</p>
        <pre class="programlisting">    using System; 
    using System.Collections.Generic; 
    using System.Linq; 
    using System.Text; 
    using System.Dynamic;  
 
    namespace TestVS 
    { 
      class Program 
    { 
      static void Main(string[] args){ 
<span class="strong"><strong>        dynamic ds = new ExpandoObject();</strong></span>
<span class="strong"><strong>      //---- Adding a property</strong></span> 
        ds.val = 20; 
        Console.WriteLine(ds.val); 
        //---- Assign a new value to the "val" property 
        //-----This is possible because of dynamic typing  
        ds.val = "Hello World..."; 
        Console.WriteLine(ds.val); 
        //---------------- Wait for the Keyboard input 
        Console.Read(); 
      } 
    } 
  } 
</pre>
        <p>In 2012, Microsoft released version 5.0 of the C# programming language, which incorporated a declarative concurrency model based on the <code class="literal">async</code>/<code class="literal">await</code> paradigm. The following C# code demonstrates the usage of <code class="literal">async</code>/<code class="literal">await</code>:</p>
        <pre class="programlisting">    //-- Chap1_05.cs 
    using System; 
    using System.IO; 
<span class="strong"><strong>    using System.Threading.Tasks;</strong></span> 
 
    class Program 
    { 
      static void Main() { 
        //--- Create a Task to Start processing 
        Task task = new Task(ProcessCountAsync); 
<span class="strong"><strong>        task.Start();</strong></span>
<span class="strong"><strong>    task.Wait();</strong></span> 
        Console.ReadLine(); 
      } 
 
<span class="strong"><strong>    static async void ProcessCountAsync()</strong></span> 
    { 
      // Start the HandleFile method. 
      Task&lt;int&gt; task = HandleFileAsync(@".\WordCount.txt"); 
      // 
      // -------- One can do some lengthy processing here 
      //  
      int x = await task; 
      Console.WriteLine("Count: " + x); 
    } 
 
<span class="strong"><strong>    static async Task&lt;int&gt; HandleFileAsync(string file)</strong></span> 
    { 
      int count = 0; 
      using (StreamReader reader = new StreamReader(file)) 
      { 
        string v = await reader.ReadToEndAsync(); 
        count += v.Length; 
      } 
      return count; 
    } 
  } 
</pre>
        <p>With Visual Studio 2015, Microsoft released C# 6.0, which mostly contains cosmetic changes to the language. Additionally,&#160;C# 7.0 does not add many features to the language. The .NET Core released by Microsoft runs on Windows GNU Linux and MAC OS X, promises to make C# a multiplatform/cross platform language. The acquisition of Xamarin has helped Microsoft to foray into cross-platform, native code-based mobile development.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="C# language and the singleton pattern">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch01lvl1sec11"></a>C# language and the singleton pattern</h1>
            </div>
          </div>
        </div>
        <p>The authors consider the singleton pattern, the way it was presented in the GoF book, as some kind of anti-pattern. A lot has been written about how to implement it in a multi-core/multi-threaded environment. Constructs such as the double-checked locking pattern have been implemented to incorporate lazy loading while implementing singleton.</p>
        <p>The C# programming language has got a nifty feature called a static constructor, which helps to implement the singleton pattern in a thread-safe manner. The static constructor is guaranteed to be called before any method (including the constructor) is called. We believe we can stop cutting down trees in order to write about the singleton pattern, at least in the .NET world.</p>
        <pre class="programlisting">    //--Chap1_06.cs 
    using System; 
 
    class SingleInstance 
    { 
      private int value = 10; 
      //----- In the case of Singleton Pattern, we make our 
      //----- ctor private to avoid instantiating the object using 
      //----- the new keyword 
      private SingleInstance() { } 
 
      //----- The static method acts as a mechanism to expose 
      //------ the internal instance 
      public static SingleInstance Instance {  
        get {  
          return Nested.instance; 
        }  
      } 
 
      private class Nested 
      { 
        static Nested() { } 
        internal static readonly SingleInstance instance 
        = new SingleInstance(); 
      } 
      public void Increment() 
      { 
        value++; 
      } 
      public int Value { get { return value; } } 
    } 
 
    public class SingletonExample 
    { 
      public static void Main(String[] args) 
    { 
      SingleInstance t1 = SingleInstance.Instance; 
      SingleInstance t2 = SingleInstance.Instance; 
      t1.Increment(); 
      if (t1.Value == t2.Value) 
        Console.WriteLine("SingleTon Object"); 
    } 
  } 
</pre>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch01lvl1sec12"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>The pattern movement has revolutionized the way people are developing software. By capturing the wisdom of experts in their respective areas, pattern catalogs can be used for software engineering, library design, and all areas where they are available. The famous GoF pattern book started the whole movement in the year 1994. Some notable catalogs include POSA, POEAA, EIP, J2EE, DDD, and Arlow/Nuestadt. We have also seen how a multi-paradigm language such as C# is well-suited for pattern-based software development, considering the language's evolution in terms of features. We will continue to explore the applicability and consequence of patterns in the following chapters. We will also be looking at the key design principles, and will explain the need for design patterns using an application case study.</p>
      </div>
    </div>
</body>
</html>