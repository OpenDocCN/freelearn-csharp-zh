- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Catching Exceptions with Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We always try to make our code as stable as possible when building web applications,
    but there are times when we can’t catch everything. This is why exceptions are
    considered a foundational part of development. Exception handling is essential
    for preventing web applications from crashing and displaying an ugly error message
    on a page. It’s tempting to wrap everything with `try`/`catch` or `try`/`finally`
    statements and move on. This should be avoided. Coding with `try`/`catch`/`finally`
    statements in an application should be the exception to the rule.
  prefs: []
  type: TYPE_NORMAL
- en: The common coding standards in this chapter are meant to remove those types
    of scenarios and provide a better developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine what exception handling means to developers and
    when to use it, along with where to handle global exceptions and examine performance
    considerations. Once we understand the basics of exception handling, the last
    section will cover some common practices of exception handling, such as applying
    the “prevention before exception” principle to code, using logging, learning how
    exception handling is similar to unit tests, and why empty catch blocks should
    be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll learn how to use .NET’s new exception filter, along with pattern
    matching, when to use `finally` blocks, and why it’s a good idea to rethrow exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common exception handling techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you’ll understand exception handling better,
    when and how to use it, how to implement global exception handling, and how to
    know if performance is a problem when using exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We recommend using a favorite editor to add the exception handling code snippets
    throughout this chapter. Our recommendations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio (preferably the latest version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Rider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work with the code.
  prefs: []
  type: TYPE_NORMAL
- en: Using exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll discuss what exception handling is, the two types of
    error handling, when to use error handling in an application, and how exceptions
    affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: What is exception handling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling is the ability to recover gracefully from unexpected situations
    in the code during runtime; how do we handle errors or problems we experience
    in applications? It also involves cleaning up allocated resources when issues
    occur to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime errors**: These are unexpected errors we experience when running
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArgumentNullException.ThrowIfNull()` at the beginning of a method to confirm
    whether a parameter is null or not).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this book focuses on intermediate to advanced developers, we’re assuming
    debugging an ASP.NET application is a common process; we all know debugging and
    exception handling go hand-in-hand. Developers should have a general understanding
    of what the code in question does when they wrap it with a `try`/`catch` block.
    The ability to create useful exceptions is extremely important. Exceptions should
    be clear and simple.
  prefs: []
  type: TYPE_NORMAL
- en: For example, early in my career, a developer was experiencing an error message
    telling them they were running out of disk space. Other developers were experiencing
    the same error in the application as well and were frantically trying to figure
    out the problem. The issue turned out to be a bad error message created by a developer
    along with a *server* running out of disk space, not individual developer machines.
    This could’ve been avoided by creating better log messages or detecting whether
    there was disk space available. While we can write better error messages in the
    exception handlers, we can only protect the code from so much.
  prefs: []
  type: TYPE_NORMAL
- en: Seriously, though – the ability to create a simple and clear error message can
    be a challenge while coding, but it does make a difference in the long run. We’ll
    cover some of the common exception handling techniques in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: When to use exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to identify whether or not code requires an exception handler can
    be tricky. In addition to whether a `try`/`catch`/`finally` block is required,
    are there resources involved that we need to clean up?
  prefs: []
  type: TYPE_NORMAL
- en: 'Context is important when it comes to exception handling. In my experience,
    I always ask three questions before adding exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TryParse` instead of a full `try`/`catch`/`finally` block or having to manually
    throw an error because of an invalid parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Will an external resource throw exceptions?** Examples include web APIs,
    storage issues, file missing, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do I have to clean up after myself if an error occurs?** Examples include
    losing a file connection, loading a bitmap, or a database connection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developers should only use exception handling when they encounter a line of
    code that they cannot handle and is considered outside of their control, similar
    to the possibility of not enough disk drive space.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed what exception handling was and when to use it
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Handling global exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, we can only handle so many errors when
    it comes to web applications. But what if we want to provide a catch-all for all
    unhandled exceptions?
  prefs: []
  type: TYPE_NORMAL
- en: 'For global exceptions, we need to revisit the middleware. There is a method
    called `UseExceptionHandler()` in the `Startup.cs` file that points to a `/Error`
    page (either Razor or MVC), as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Pay particular attention to the `env.IsDevelopment()` condition. *The* `/Error`
    *page is meant for non-development viewing only*. As we mentioned back in [*Chapter
    4*](B19493_04.xhtml#_idTextAnchor086) regarding security, always be careful what
    to show on this page. It may expose system data such as a database connection
    string that contains credentials or other sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the exception through the error page, we require the `IExceptionHandlerPathFeature`
    instance through `HttpContext.Features`. This can be seen in the following `OnGet()`
    method on the `/``Error` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpContext.Features` gives us access to the error. From there, we need to
    determine what to display on the page. In this case, we can see that the main
    page contains the error. Once we have identified the issue, we can create a public
    message, and log the error, and store it in `ErrorMessage` so that the main page
    can display it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is a simplistic example, alternatively, we can use our middleware
    to catch global errors as well. Instead of passing in a page location, we can
    use a Lambda for our exception handling in the middleware, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve the `ExceptionHandlerPathFeature` instance the same way as we did
    on the `/Error` page. Of course, we always want to log the error, so we know what
    to fix (“It’s that darn home page again”).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use middleware to create a global exception
    handler. This allows us to centralize the error handling and avoid too many exception
    handlers throughout our application. Next, we’ll focus on performance considerations
    when writing exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common myth about exception handling is that it doesn’t affect performance.
    If exceptions are significantly harming the application’s performance, that’s
    a sign that exceptions are being used too much. Exceptions should not control
    the flow of the application whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the code should flow with no interruptions. In small web applications
    with a few users, this type of approach may be adequate, but for high-performing,
    high-traffic websites, placing a `try`/`catch` block in frequently-called code
    may cause the site to suffer a performance hit.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered what exception handling was, reviewed the two types
    of errors in applications, identified where exception handling is ideal, and covered
    some of the performance myths regarding exceptions. Next, we’ll look at some common
    exception handling techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Common exception handling techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are expensive in .NET. When an exception occurs in the application,
    there are resources in place to begin the error handling process when an exception
    occurs, such as the stack trace process. Even when we are catching and handling
    the errors, ASP.NET is still creating the `Exception` object and everything associated
    with it along with walking up the call stack to locate the handler.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at common approaches in the industry to minimize
    the exceptions through “prevention before exception,” why to use logging, why
    unit testing is similar to exception handling, why empty catch blocks should be
    avoided, how to simplify exceptions using exception filtering and pattern matching,
    why blocks are important when releasing resources, and how to rethrow exceptions
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention before exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said in the previous section, exceptions interrupt the flow of an application
    when encountered and can cause more problems than intended, such as releasing
    resources that were previously allocated and triggering multiple exceptions up
    the call stack. If we’re writing `try`/`catch` blocks of code to control the flow
    of the program, we’re doing it wrong. It’s best to perform checks before wrapping
    code with `try`/`catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there’s one thing to take away from this chapter, let it be this principle:
    prevention before exception.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of prevention before exception refers to the idea of trying to prevent
    the error from happening using less destructive methods, such as stopping the
    execution of the website completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In a happy path, the number will be parsed and the result will be `2`. However,
    if the string contained a value of “hi”, the result will become a zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach would be using the newest `TryParse` with `var`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we are attempting to convert the number and store the converted
    value into a new variable called `result`. `TryParse` returns true if the conversion
    was successful and false if not. If the conversion fails, we set `result` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We prevented an exception by handling the conversion through easier means. There
    are a large number of conversion methods in .NET and we can accomplish the same
    thing without `try`/`catch`/`finally` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: For simpler exceptions, look at the `try`/`catch` block and ask if we can apply
    some sort of prevention before creating exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Use logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a `try`/`catch` block, it’s best to show the intent of what we
    want to get out of the code. Is the error something we can recover from or is
    it something that requires investigation when it occurs?
  prefs: []
  type: TYPE_NORMAL
- en: If it’s the latter, it’s best to send a well-constructed error message to the
    logger before throwing the error. As mentioned in various chapters, it’s best
    to use a logging strategy to identify issues throughout the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the previous example to determine the value that caused the error,
    we can create a log entry, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While this gives us a clear log entry for our `try`/`catch` block, we can copy
    this one-liner to our `TryParse` example as well.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to provide enough information to developers without jarring the
    user’s experience with errors.
  prefs: []
  type: TYPE_NORMAL
- en: Apply a unit testing methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have to use a `try`/`catch` block, look at it like a unit test. We mentioned
    that unit tests have the triple-A approach (Arrange, Act, and Assert). We want
    to create a minimal amount of code to get the job done and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the objects at the beginning (Arrange) and wrap a `try`/`catch` block
    around the suspecting line causing the error (Act). Minimize the amount of code
    inside the `try`/`catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we can apply this approach to the previous code example, which
    has been modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Anything above the `try` statement would be considered part of `Arrange`; the
    one-liner inside the try’s brackets is considered `Act`. The `Assert` piece would
    be part of the `catch` statement. This statement would be the equivalent of a
    failed `Assert`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid empty catch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While preventing errors is critical to our applications, consider an empty
    catch statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What happens when the `Deposit()` method doesn’t work? If we do have an error
    in the code, the `catch` statement should contain something to let the developer
    know an error occurred. At the very least, a `Log` statement should exist to notify
    the team about the issue.
  prefs: []
  type: TYPE_NORMAL
- en: While an empty `try`/`catch` block keeps the program from crashing, it causes
    a bigger problem. Once someone discovers there’s an error with depositing funds,
    it may be hard to find the issue since it doesn’t log the problem because it’s
    not logging or throwing an error.
  prefs: []
  type: TYPE_NORMAL
- en: Use exception filtering and pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are dealing with multiple exceptions for a section of code, a new feature
    in .NET called exception filtering can make the exception handling terser. If
    we have compact code, exception filtering can provide a more efficient and modern
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, file handling can often result in a wide variety of exceptions.
    Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we log each exception and provide a message based on
    the specific exception. With exception filtering, we can shorten the lines to
    something a little easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are grouping `DirectoryNotFoundException` and `FileNotFoundException`
    and logging them as warnings. When we encounter a `NotSupportedException` or `IOException`
    error, we consider that a little more of a problem and log those as errors. Anything
    else coming through will be caught as a general exception and logged as an error
    with the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with exception filtering, .NET introduced another new feature called
    pattern matching. With pattern matching, we can shorten the code even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses a `switch` statement inside the `catch` brackets to
    identify what type of exception we’re experiencing. Think of switch pattern matching
    as an inline `if` statement. The preceding line returns the value of `logLevel`
    based on the exception type.
  prefs: []
  type: TYPE_NORMAL
- en: The underscore (`_`) is called a discard variable (it’s like a default in a
    switch statement). If everything else falls through the switch, then we’ll just
    default the log level to `LogLevel.Error` and log the message with the current
    method, the name of the exception type, and the exception message.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling can be wordy with, for instance, I/O-based methods and connections.
    Exception filtering and pattern matching can help ease the wordiness of catching
    various exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Use finally blocks for cleanup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with database connections, file-based operations, or resources,
    it’s best to use `finally` for cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we’re connecting to a database and want to close the connection
    afterward, we’d have to create a piece of code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the connection object is passed into the `SqlCommand`
    constructor. When we execute the SQL query, the command is passed into the connection
    and executed. Once our code is executed, we close the connection in the `finally`
    statement. Since we have a `using` statement and the `SqlConnection` class implements
    `IDisposable`, it will automatically be disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we need `finally` statements to clean up, but there are
    exceptions when they aren’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing when to throw
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous code example, we issued `throw;` as opposed to `throw ex;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code example in the previous section with `throw;`, we see that
    the stack trace in Visual Studio is seen through the **Call** **Stack** pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Snapshot of a call stack with a simple throw;](img/B19493_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Snapshot of a call stack with a simple throw;
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we change the line to `throw ex;`?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Snapshot of a call stack with throw ex;](img/B19493_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Snapshot of a call stack with throw ex;
  prefs: []
  type: TYPE_NORMAL
- en: The stack trace completely disappears. The error will become harder to track
    if we don’t have a stack trace. There are times when we want to simply throw the
    exception. It’s always better to rethrow the exception so that the stack trace
    is left intact for locating errors.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered many standards of what is considered practical when
    applying exception handling in the code. We learned how to minimize exceptions
    with “prevention before exception,” why logging is important, and why exception
    handling is like unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned to avoid empty catch blocks, simplify exceptions using exception
    filtering and pattern matching, when to use finally blocks, and how to rethrow
    exceptions properly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is important but requires a level of experience when writing
    truly robust applications. Applications need to recover so that the user doesn’t
    have a jarring experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about exception handling, when to use it, and where
    it makes sense, as well as performance considerations.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter by learning about the common techniques of exception handling
    by understanding the “prevention before exception” principle, why logging is important,
    and why exception handling is like unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that empty catch blocks are wasteful, how to simplify exceptions
    using exception filtering and pattern matching, when to use finally blocks, and
    how to rethrow exceptions properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at web API standards and how they are extremely
    important to the ASP.NET Core ecosystem.
  prefs: []
  type: TYPE_NORMAL
