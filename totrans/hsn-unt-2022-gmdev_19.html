<html><head></head><body>
  <div><h1 class="chapterNumber">19</h1>
    <h1 id="_idParaDest-239" class="chapterTitle">Generating and Debugging an Executable</h1>
    <p class="normal">So, we have reached a point where the game is in good enough shape to test it with real people. The problem is that we can’t pretend people will install Unity, open a project, and hit <strong class="screenText">Play</strong>. They want to receive a nice executable file to double-click and play right away. In this chapter, we are going to discuss how we can convert our project into an easy-to-share executable format, seeing how to do that in the first section, and then in the second section, we will see how to apply the profiling and debugging techniques learned in <em class="chapterRef">Chapter 18</em>,<em class="italic"> Scene Performance Optimization</em>, but this time on the build. After reading this chapter, you will be able to detect potential performance bottlenecks and how to tackle the most common ones, leading to an increase in your game’s framerate.</p>
    <p class="normal">In this chapter, we will examine the following build concepts: </p>
    <ul>
      <li class="bulletList">Building a project</li>
      <li class="bulletList">Debugging the build</li>
    </ul>
    <p class="normal">Let’s start by seeing how we can build the project to get a shareable executable.</p>
    <h1 id="_idParaDest-240" class="heading-1">Building a project</h1>
    <p class="normal">In<a id="_idIndexMarker1256"/> software development (including video games), the process of taking the source files of our project and converting them into an executable format is called a<strong class="keyWord"> build</strong>. The<a id="_idIndexMarker1257"/> generated executable files are optimized to achieve the maximum performance possible given the configuration of the project. We can’t judge performance while editing the game due to the changing nature of a project. It would be time-consuming to prepare the assets in their final form while editing the game. </p>
    <p class="normal">Also, the generated files are in a difficult-to-read format. They won’t have the textures, audio, and source code files just there for the user to look at. They will be formatted in custom file structures, so in a way, they’re protected from users stealing them.</p>
    <div><p class="normal">Actually, there are several tools to extract source files from video games, especially from a widely used engine such as Unity. You can extract assets such as textures and 3D models, and there are even programs that extract those assets directly from the VRAM, so we cannot guarantee that the assets won’t be used outside the game. In the end, users have the data of those assets on their disks.</p>
    </div>
    <p class="normal">The <a id="_idIndexMarker1258"/>build process is <a id="_idIndexMarker1259"/>pretty simple when you target desktop platforms such as PC, Mac, or Linux, but there are a few settings we need to keep in mind before building. The first configuration we are going to see is the scenes list. We have already discussed this, but it’s a good moment to remember that it is important to set the first element of this list to the scene that will be loaded first. Remember, you can do this by going to <strong class="screenText">File </strong>|<strong class="screenText"> Build Settings</strong> and dragging your desired starter scene to the top of the list. In our case, we defined the game scene as the first scene, but in a real game, it would be ideal to create a <strong class="screenText">Main Menu</strong> scene using UI and some graphics: </p>
    <figure class="mediaobject"><img src="img/B18585_19_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.1: The Scenes in Build list order</p>
    <p class="normal">Another setting you can change here is the target platform, the target operating system that the build will be created for. Usually, this is set as the same operating system you are developing on, but in case you are, as an example, developing on a Mac, and you want to build for Windows, just set the <strong class="screenText">Target Platform</strong> setting to <strong class="screenText">Windows</strong>. That way, the result will be an .<code class="inlineCode">exe</code> file (a Windows executable file) instead of an .<code class="inlineCode">app</code> file (the Mac executable file). You may see Android and iOS as other target platforms, but making mobile games requires other considerations that we are not going to discuss in this book:</p>
    <figure class="mediaobject"><img src="img/B18585_19_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.2: Target Platform</p>
    <p class="normal">In the same window, you<a id="_idIndexMarker1260"/> can click the <strong class="screenText">Player Settings</strong> button at the bottom left, or just open the <strong class="screenText">Edit </strong>|<strong class="screenText"> Project Settings</strong> window and click on the <strong class="screenText">Player</strong> category to access the rest of the <strong class="screenText">Build Settings</strong>. Unity calls the generated executable the <code class="inlineCode">Player</code>. Here, we have a set of configurations that will affect how the build or player behaves, and here is a list of the basic ones:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Company Name</strong>: This is the name of the company that developed the game, which is used by Unity to create certain file paths and will be included in the executable information.</li>
      <li class="bulletList"><strong class="screenText">Product Name</strong>: This is the name of the game in the window title bar and executable file.</li>
      <li class="bulletList"><strong class="screenText">Default Icon</strong>: Here, you can select a texture to act as the executable icon.</li>
      <li class="bulletList"><strong class="screenText">Default Cursor</strong>: You can set a texture to replace the regular system cursor. In case you do that, remember to set the <strong class="screenText">Cursor Hotspot</strong> property to the pixel of the image you want the cursor to click on.</li>
      <li class="bulletList"><strong class="screenText">Resolution and Presentation</strong>: These are settings for how our game’s resolution is going to be handled.</li>
      <li class="bulletList"><strong class="screenText">Resolution and Presentation</strong><strong class="keyWord"> </strong>|<strong class="keyWord"> </strong><strong class="screenText">Fullscreen Mode</strong>: You can select if your game will start <strong class="screenText">Windowed</strong> or in different modes of <strong class="screenText">Fullscreen</strong>. You can change that later via scripting if necessary.</li>
      <li class="bulletList"><strong class="screenText">Resolution and Presentation</strong><strong class="keyWord"> </strong>| <strong class="screenText">Default is Native Resolution</strong>: When this option is checked and <strong class="screenText">Fullscreen Mode </strong>is set to use any<strong class="screenText"> Fullscreen</strong> option, the resolution currently used by the system will be the one used by Unity. You can uncheck this and set your desired resolution.</li>
      <li class="bulletList"><strong class="screenText">Splash Image</strong>:<strong class="keyWord"> </strong>These are settings for the splash image the game will show after loading for the first time.</li>
      <li class="bulletList"><strong class="screenText">Splash Image</strong> |<strong class="keyWord"> </strong><strong class="screenText">Show Splash Screen</strong>: This will enable a Unity splash screen that will display logos as an introduction to the game. If you have the Unity Plus or Pro license, you can uncheck this to create your custom splash screen, if you want.</li>
      <li class="bulletList"><strong class="screenText">Splash Image</strong> |<strong class="keyWord"> </strong><strong class="screenText">Logos List</strong>: Here, you can add a set of images that Unity will display when launching the game. If you are using a free version of Unity, you are forced to have the Unity logo displayed in this list.</li>
      <li class="bulletList"><strong class="screenText">Splash Image</strong><strong class="keyWord"> | </strong><strong class="screenText">Draw Mode</strong>: You can set this to <strong class="screenText">All Sequential</strong> to show each logo, one after the other, or to <strong class="screenText">Unity Logo Below</strong> to show your custom introductory<a id="_idIndexMarker1261"/> logos with the Unity logo always present below yours:</li>
    </ul>
    <figure class="mediaobject"><img src="img/B18585_19_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.3: Player settings</p>
    <p class="normal">After configuring these settings as you wish, the next step is to do the actual build, which can be accomplished by hitting the <strong class="screenText">Build</strong> button in the <strong class="screenText">File </strong>|<strong class="screenText"> Build Settings</strong> window. This will ask you to set where you want the build files to be created. I recommend you create an empty folder on your desktop to have easy access to the result. Be patient—this process can take a while depending on the size of the project:</p>
    <figure class="mediaobject"><img src="img/B18585_19_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.4: Building the game</p>
    <p class="normal">Something <a id="_idIndexMarker1262"/>that can fail here is having non-build-compatible scripts—scripts that are intended to be executed only in the Editor, mostly Editor extensions. We haven’t created any of those, so if you have an error message in the console after building, similar to the following screenshot, that can happen because of some script in an Asset Store package. In that case, just delete the files that are shown in the console before the <strong class="screenText">Build Error</strong> message. If, by any chance, there is one of your scripts there, be sure you don’t have any <code class="inlineCode">using UnityEditor;</code> lines in any of your scripts. </p>
    <p class="normal">That would try to use the Editor namespace, the one that is not included in the build compilation to save space on the disk:</p>
    <figure class="mediaobject"><img src="img/B18585_19_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.5: Build errors</p>
    <p class="normal">And that’s the minimum you need to know in order to configure the build. You have generated your game! Something to take into account is that every file that was created in the folder that you specified when building must be shared, not only the executable file. The data folder contains all assets and is important to include when sharing the game in the case of Windows builds. For Linux and Mac builds, there is just one file generated (<code class="inlineCode">x86/x86_64</code> for Linux and <code class="inlineCode">app packages</code> for Mac):</p>
    <figure class="mediaobject"><img src="img/B18585_19_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.6: A Windows-generated folder</p>
    <p class="normal">Now that we<a id="_idIndexMarker1263"/> have the build, you can test it by double-clicking the executable file. We can now discuss how we use the same debug and profiling tools we used in the Editor to debug our build.</p>
    <h1 id="_idParaDest-241" class="heading-1">Debugging the build</h1>
    <p class="normal">In an ideal world, the<a id="_idIndexMarker1264"/> Editor and the build would behave the same, but sadly that isn’t true. The Editor is prepared to work in a fast-iteration mode. Code and assets have minimum processing prior to being used to make changes often and fast, so we can test our game easily. When the game is built, a series of optimizations and differences from the Editor project will be applied to ensure the best performance we can get, but those differences can cause certain parts of the game to behave differently, making the profiling data of the player differ from the Editor. That’s why we are going to explore how we can debug and profile the game we have built. </p>
    <p class="normal">In this section, we will examine the following build debugging concepts:</p>
    <ul>
      <li class="bulletList">Debugging code</li>
      <li class="bulletList">Profiling performance</li>
    </ul>
    <p class="normal">Let’s start discussing how to debug the code of a build.</p>
    <h2 id="_idParaDest-242" class="heading-2">Debugging code</h2>
    <p class="normal">As player code is <a id="_idIndexMarker1265"/>compiled differently, we can get errors in the build that didn’t happen in the Editor, and we need to debug it somehow. We have two main ways to debug—by printing messages and through breakpoints. So, let’s start with the first one, messages. If you ran your executable file, you may have noticed that there’s no console available. It’s just the <strong class="screenText">Game View</strong> in fullscreen, which makes sense; we don’t want to distract the user with annoying testing messages. Luckily, the messages are still being printed, but in a file, so we can just go to that file and look for them.</p>
    <p class="normal">The location varies according to the operating system. In this list, you can find the possible locations:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Linux</strong>: <code class="inlineCode">~/.config/unity3d/CompanyName/ProductName/Player.log</code></li>
      <li class="bulletList"><strong class="keyWord">Mac</strong>: <code class="inlineCode">~/Library/Logs/Company Name/Product Name/Player.log</code></li>
      <li class="bulletList"><strong class="keyWord">Windows</strong>: <code class="inlineCode">C:\Users\username\AppData\LocalLow\CompanyName\ProductName\Player.log</code></li>
    </ul>
    <p class="normal">In these paths, you must change <code class="inlineCode">CompanyName</code> and <code class="inlineCode">ProductName</code> to the values of the properties in the <code class="inlineCode">Player</code> settings we set before, which are called the same, <strong class="screenText">Company Name</strong> and <strong class="screenText">Product Name</strong>. In Windows, you must replace <code class="inlineCode">username</code> with the name of the Windows account you are executing the game in. Consider that the folders might be hidden, so enable the option to show hidden files in your operating system. Inside that folder, you will find a file called <code class="inlineCode">Player</code>; you can open it with any text editor and look at the messages. </p>
    <p class="normal">Aside from<a id="_idIndexMarker1266"/> downloading any custom package from the Asset Store, there is a way to see the messages of the console directly in the game, at least the error messages: by creating a development build. This is a special build that allows extended debugging and profiling capabilities in exchange for not fully optimizing the code as the final build does, but it will be enough for general debugging. </p>
    <p class="normal">You can create this kind of build just by checking the <strong class="screenText">Development Build</strong> checkbox in the <strong class="screenText">File </strong>| <strong class="screenText">Build Settings</strong> window:</p>
    <figure class="mediaobject"><img src="img/B18585_19_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.7: The Development Build checkbox</p>
    <p class="normal">Remember<a id="_idIndexMarker1267"/> that just the error messages will be displayed here, so a little trick you can do is replace <code class="inlineCode">print</code> and <code class="inlineCode">Debug.Log</code> function calls with <code class="inlineCode">Debug.LogError</code>, which will also print the message in the console but with a red icon. Consider that using <code class="inlineCode">Debug.LogError</code> to show non-error messages is not a good practice, so limit the usage of this kind of message for temporal debugging. For permanent logging, use the log file or find a custom debugging console for runtime in the Asset Store.</p>
    <figure class="mediaobject"><img src="img/B18585_19_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.8: Debugging error messages</p>
    <p class="normal">Something interesting<a id="_idIndexMarker1268"/> regarding <strong class="screenText">development builds</strong> is that, unlike regular builds, the error messages are displayed directly in the build, allowing you to properly debug your project. In the next screenshot, you can see the error displayed in the runtime:</p>
    <figure class="mediaobject"><img src="img/B18585_19_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.9: Error messages in a development build</p>
    <p class="normal">You will notice that, aside from showing the error message, there’s an <strong class="screenText">Open Log File</strong> button on the right, allowing you to see the log file. This is a text file containing detailed info regarding all the messages and logs that happened in this run of the game to pinpoint the issue. Essentially, it is the same info the <strong class="screenText">Console</strong> panel shows in the editor.</p>
    <p class="normal">Remember that for <strong class="screenText">development builds</strong> to work, you need to build the game again; luckily, the first build is the one that takes the most time, and the next will be faster. This time, you can just click the <strong class="screenText">Build and Run</strong> button to do the build in the folder in which you did the previous build.</p>
    <p class="normal">Also, you can use regular breakpoints the same way as we explained in <em class="chapterRef">Chapter 5</em>, <em class="italic">Introduction to C# and Visual Scripting</em>. Attaching the IDE to the player, it will show up in the list of targets. But for that to work, you must not only check <strong class="screenText">Development Build</strong> in the <strong class="screenText">Build</strong> window but also <strong class="screenText">Script Debugging</strong>. Here, you have an additional option shown when that is checked that allows you to pause the entire game until a debugger is attached, the one called <strong class="screenText">Wait For Managed Debugger</strong>. This is useful in case you want to test something that happens immediately at the beginning and doesn’t allow you enough time to attach the debugger:</p>
    <figure class="mediaobject"><img src="img/B18585_19_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.10: Enabling script debugging</p>
    <p class="normal">We have <a id="_idIndexMarker1269"/>another way to see the messages, but that will require the Profiler to work, so let’s use this as an excuse to also discuss how to profile the editor.</p>
    <h2 id="_idParaDest-243" class="heading-2">Profiling performance</h2>
    <p class="normal">We are going to use the<a id="_idIndexMarker1270"/> same tools as we saw in the previous chapter, but to profile the player this time. Luckily, the difference is minimal. As we did in the previous section, you need to build the player in <strong class="screenText">Development</strong> mode, checking the <strong class="screenText">Development Build</strong> checkbox in the <strong class="screenText">Build</strong> window, and then the Profilers should automatically detect it. </p>
    <p class="normal">Let’s start using the Profiler<a id="_idIndexMarker1271"/> on the build by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Play the game through the build.</li>
      <li class="numberedList">Switch to Unity using <em class="italic">Alt</em> + <em class="italic">Tab</em> (<em class="italic">Cmd</em> + <em class="italic">Tab</em> on Mac).</li>
      <li class="numberedList">Open the Profiler.</li>
      <li class="numberedList">Click the menu that says <strong class="screenText">Play Mode</strong> and select the item that contains <strong class="screenText">Player</strong> in it. Because I have used Mac, it says <strong class="screenText">OSXPlayer</strong>, and the name will vary according to the build platform (for example, a Windows build will say <strong class="screenText">WindowsPlayer</strong>):</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18585_19_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.11: Profiling the player</p>
    <p class="normal">Notice that when you click a frame, the game won’t stop like in the Editor. If you want to focus your attention on the frames at a specific moment, you can click the record button (the red circle) to make the Profiler stop capturing data, so you can analyze the frames captured so far.</p>
    <p class="normal">Also, you can see that when <a id="_idIndexMarker1272"/>the Profiler is attached to the player, the console<a id="_idIndexMarker1273"/> will also be attached, so you can see the logs directly in Unity. Consider that this version requires Unity to be opened, and we cannot expect our friends who are testing our game to have it. You might need to click on the <strong class="screenText">Player</strong> button that appears on the <strong class="screenText">Console</strong> and check <strong class="screenText">Player Logging</strong> for this to work:</p>
    <figure class="mediaobject"><img src="img/B18585_19_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.12: Enabling Player Logging after attaching the Profiler</p>
    <p class="normal">The <strong class="screenText">Frame Debugger</strong> is also<a id="_idIndexMarker1274"/> enabled to work with the player. You need to click the <strong class="screenText">Editor</strong> button in the <strong class="screenText">Frame Debugger</strong> and again, you will see the player in the list of possible debugging targets; after selecting it, hit <strong class="screenText">Enable</strong> as usual. Consider that the preview of the <strong class="screenText">Draw Calls</strong> won’t be seen in the <strong class="screenText">Game View</strong> but in the build itself. If you are running the game in fullscreen mode, you might need to switch back and forth between Unity and the build:</p>
    <figure class="mediaobject"><img src="img/B18585_19_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.13: Debugging the frames of our game’s Player</p>
    <p class="normal">You may also run<a id="_idIndexMarker1275"/> the game in <strong class="screenText">Windowed</strong> mode, setting the <strong class="screenText">Fullscreen Mode</strong> property in <a id="_idIndexMarker1276"/>the player settings to <strong class="screenText">Windowed</strong>, and establishing a default resolution that is smaller than your desktop resolution, to have both Unity and the player visible:</p>
    <p class="packt_figref"><img src="img/B18585_19_14.png" alt=""/></p>
    <p class="packt_figref">Figure 19.14: Enabling Windowed mode</p>
    <p class="normal">Finally, the <strong class="screenText">Memory Profiler</strong> also <a id="_idIndexMarker1277"/>supports profiling the player, and as you might guess, you can just select the player in the list that is displayed when you click the <strong class="screenText">Editor</strong> button on the top bar of the window and then click <strong class="screenText">Capture</strong>:</p>
    <figure class="mediaobject"><img src="img/B18585_19_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 19.15: Taking memory snapshots of the player</p>
    <p class="normal">And that is it. As you <a id="_idIndexMarker1278"/>can see, Unity Profilers<a id="_idIndexMarker1279"/> are designed to be easily integrated with the player. If you start to take data from them, you will see the difference compared to editor profiling, especially in the <strong class="screenText">Memory Profiler</strong>.</p>
    <h1 id="_idParaDest-244" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we learned how to create an executable version of the game and properly configure it so you can share it with not only your friends but potentially the world! We also discussed how to profile our build; remember that doing that will give us more accurate data than profiling the editor, so we can better improve the performance of our game.</p>
    <p class="normal">Now that we have finished our game, let’s see a glimpse of how your next project could easily be an augmented reality application in Unity, exploring the AR Foundation package.</p>
  </div>
</body></html>