- en: Filter Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器管道
- en: 'In this chapter, we will cover another essential topic in ASP.NET Core: the
    filter pipeline. Filters are a vital component that we can use to achieve cross-cutting
    implementation in our services. Although we have already seen how to implement
    cross-functionalities using the middleware pipeline, filters are more specialized
    components that are linked to the MVC pipeline. Therefore, filters can be used
    to implement more specific logic, related to the controller''s execution. This
    chapter will show you how to implement these filters and will describe some concrete
    use cases.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍ASP.NET Core中的另一个重要主题：过滤器管道。过滤器是我们可以在服务中实现横切实现的一个关键组件。尽管我们已经看到了如何使用中间件管道实现横切功能，但过滤器是更专业的组件，它们与MVC管道相关联。因此，过滤器可以用来实现更具体的逻辑，与控制器的执行相关。本章将向您展示如何实现这些过滤器，并描述一些具体用例。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to filters in ASP.NET Core
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core中过滤器简介
- en: How to implement and apply filters to the filter pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现和应用过滤器到过滤器管道
- en: Some concrete use cases for filters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器的具体用例
- en: How to use resolve dependencies in the filter pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在过滤器管道中使用解析依赖项
- en: This chapter provides information about the filter stack in .NET Core and how
    to use filters to enhance the features of our web services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了有关.NET Core中过滤器堆栈的信息以及如何使用过滤器来增强我们Web服务的功能。
- en: Introduction to filters
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器简介
- en: 'Filters come in handy when we wish to build *cross-cutting concepts* in the
    MVC stack of ASP.NET Core. They are useful when we wish to implement features
    such as authorization or caching. ASP.NET Core provides some out-of-the-box filter
    types. Each of these can be used for a specific purpose in our service:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在ASP.NET Core的MVC堆栈中构建*横切概念*时，过滤器非常有用。当我们需要实现如授权或缓存等功能时，它们非常有用。ASP.NET
    Core提供了一些现成的过滤器类型。每个都可以在我们的服务中用于特定目的：
- en: '| **Filter type** | **Type description** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **过滤器类型** | **类型描述** |'
- en: '| Authorization | This kind of filter is related to the authorization of users.
    It is the first filter that''s executed in the filter pipeline and can short-circuit
    the pipeline of requests. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 授权 | 这种过滤器与用户的授权相关。它是过滤器管道中执行的第一个过滤器，并且可以短路请求管道。|'
- en: '| Resource | Resource filters run immediately after authorization filters and
    after the rest of the pipeline has completed. They''re useful when we wish to
    implement caching or for performance implementations. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 资源过滤器在授权过滤器之后以及管道中的其余部分完成后立即运行。当我们需要实现缓存或性能实现时，它们非常有用。|'
- en: '| Action | Action filters are focused on the life cycle of action methods.
    They intercept and change the arguments and the returning results of action methods.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | 动作过滤器专注于动作方法的生命周期。它们拦截并更改动作方法的参数和返回结果。|'
- en: '| Exception | Exception filters are used to intercept and apply cross-cutting
    policies to unhandled exceptions. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 异常 | 异常过滤器用于拦截并应用跨切面策略到未处理的异常。|'
- en: '| Result | Result filters are executed immediately before and after the execution
    of an action result. They are usually implemented to change the formatting of
    the outcome. It is essential to note that they are executed only when the action
    method is completed successfully. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 结果 | 结果过滤器在动作结果执行之前和之后立即执行。它们通常被实现来更改结果的格式。重要的是要注意，它们仅在动作方法成功完成后才会执行。|'
- en: It is crucial to note that filters act in the domain of the MVC middleware,
    which implies that action filters are unable to operate outside the MVC context.
    Therefore, filters are more specific than middleware; they can be applied to a
    subset of requests, and they have access to some MVC components, for example,
    `ModelState`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，过滤器在MVC中间件的领域中起作用，这意味着动作过滤器无法在MVC上下文之外操作。因此，过滤器比中间件更具体；它们可以应用于请求的子集，并且可以访问一些MVC组件，例如，`ModelState`。
- en: 'The following diagram shows the workflow of different types of action filters
    in a request-response workflow:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了不同类型的动作过滤器在请求-响应工作流程中的工作流程：
- en: '![](img/28daf453-5ea7-445f-af69-e684ee2c4393.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28daf453-5ea7-445f-af69-e684ee2c4393.png)'
- en: As you can see, in a request-response pipeline, different types of filters act
    at various stages. *Authorization filters* act before everything else and block
    the requests in the event any of the privileges are wrong. *Resource filters*
    operate before model validation and model binding of the request and also when
    the results of our request come back from the server. The *action filter* type
    acts before and after an action's invocation. Furthermore, if an action throws
    an exception, the *exception filter* is triggered. At the end of the pipeline,
    the *result filter* operates on the `IActionResult` final object instance. Now
    that we know about the different filter types that are provided by ASP.NET Core,
    we will look at some concrete implementation examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在请求-响应管道中，不同类型的过滤器在各个阶段发挥作用。*授权过滤器*在所有其他操作之前执行，并在任何权限错误的情况下阻止请求。*资源过滤器*在请求的模型验证和模型绑定之前以及我们的请求结果从服务器返回时操作。*操作过滤器*类型在操作调用之前和之后执行。此外，如果操作抛出异常，则触发*异常过滤器*。在管道的末尾，*结果过滤器*作用于`IActionResult`最终对象实例。现在我们了解了ASP.NET
    Core提供的不同过滤器类型，我们将查看一些具体的实现示例。
- en: Concrete filter implementations
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体过滤器实现
- en: 'In general, filters can be implemented by extending the built-in types provided
    by ASP.NET Core. Let''s walk through a simple declaration of a custom action filter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以通过扩展ASP.NET Core提供的内置类型来实现过滤器。让我们通过一个简单的自定义操作过滤器声明来了解一下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `CustomActionFilter` class implements the `IActionFilter` interface type,
    which offers two different methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomActionFilter`类实现了`IActionFilter`接口类型，该接口提供了两种不同的方法：'
- en: The `OnActionExecuting` method is triggered before the execution of the action.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActionExecuting`方法在操作执行之前触发。'
- en: The `OnActionExecuted` method is executed after the action.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActionExecuted`方法在操作之后执行。'
- en: Both methods receive the execution `context` as a callback parameter, which
    provides some useful information about the *filter's stack metadata*, the *controllers*,
    the *action arguments*, and *route data*. Furthermore, the `context` parameter
    also provides access to the `HttpContext` attribute we looked at in previous chapters.
    The `HttpContext` provides all the necessary properties so that we can access
    dependency injection services and the request/response data. ASP.NET Core heavily
    uses the asynchronous stack. This means it also provides an interface that we
    can use to implement asynchronous filters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都将执行`上下文`作为回调参数，该参数提供有关*过滤器堆栈元数据*、*控制器*、*操作参数*和*路由数据*的一些有用信息。此外，`上下文`参数还提供了访问我们在前几章中查看的`HttpContext`属性。`HttpContext`提供了所有必要的属性，以便我们可以访问依赖注入服务和请求/响应数据。ASP.NET
    Core大量使用异步堆栈。这意味着它还提供了一个接口，我们可以用它来实现异步过滤器。
- en: Asynchronous filters
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步过滤器
- en: 'Filters support both asynchronous and synchronous behaviors. As we saw in the
    previous example, `CustomActionFilter` implements two synchronous methods: `OnActionExecuting`
    and `OnActionExecuted`. In the case of an asynchronous filter, the implementation
    is different:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器支持异步和同步行为。正如我们在前面的示例中所见，`CustomActionFilter`实现了两个同步方法：`OnActionExecuting`和`OnActionExecuted`。对于异步过滤器，实现方式不同：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`CustomActionFilterAsync` implements the `async` version of the action filter
    class, that is, `IAsyncActionFilter`, and implements only one method, that is,
    `OnActionExecutionAsync`. This template is similar to a middleware implementation;
    the `next()` method triggers the execution of the rest of the pipeline. Therefore,
    everything before the `await next()` statement is executed before the execution
    of the action filter, while everything after the `await next()` statement is performed
    after the action''s execution. It is essential to note that the framework searches
    for the `async` implementation first and then for the *synchronous* implementation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomActionFilterAsync`实现了操作过滤器类的异步版本，即`IAsyncActionFilter`，并且只实现了一个方法，即`OnActionExecutionAsync`。这个模板与中间件实现类似；`next()`方法触发管道其余部分的执行。因此，在`await
    next()`语句之前执行的所有内容都在操作过滤器的执行之前执行，而在`await next()`语句之后执行的所有内容都在操作执行之后执行。重要的是要注意，框架首先搜索异步实现，然后搜索*同步*实现。'
- en: The scope of filters
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器的作用域
- en: 'Filters inherit a different scope based on their initialization in our codebase.
    In practice, a filter may have three different scopes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器根据我们在代码库中的初始化继承不同的作用域。在实践中，过滤器可能有三个不同的作用域：
- en: '**Global scope**: This means that the filter covers the whole MVC pipeline.
    Every call to a specific MVC route will pass through that filter.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局作用域**：这意味着过滤器覆盖了整个MVC管道。每次对特定MVC路由的调用都会通过该过滤器。'
- en: '**Controller scope**: In this case, the filter is initialized as an attribute
    in one or multiple controller classes. It will act only on requests that have
    been directed to the target controllers.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器作用域**：在这种情况下，过滤器被初始化为单个或多个控制器类中的一个属性。它只会在请求被定向到目标控制器时起作用。'
- en: '**Action scope:** The filter is initialized as an attribute in one or multiple
    action methods. It will act only on requests that have been directed to the target
    methods.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作作用域**：过滤器被初始化为单个或多个操作方法中的一个属性。它只会在请求被定向到目标方法时起作用。'
- en: 'It is also essential to understand that filters are executed, depending on
    the scope, in a specific order: first of all, all *global scope filters* run,
    followed by *controller scope filters*, and finally *action scope filters*. In
    the next subsection, we will look at the implementation of the different scopes
    in more detail.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要理解，根据作用域，过滤器会按照特定的顺序执行：首先，所有*全局作用域过滤器*运行，然后是*控制器作用域过滤器*，最后是*操作作用域过滤器*。在下一小节中，我们将更详细地探讨不同作用域的实现。
- en: The use of filters
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器的使用
- en: 'As we mentioned previously, filters can have three different scopes: *global*,
    *controller*, and *action*. In the first case, the filter is applied globally
    in the `Startup` class. In the other two cases, the filter is used in the form
    of an attribute and is usually applied to the controller class definition or the
    action method definition. Let''s take a closer look at these different approaches.
    The application of a filter in the `Startup` class means that the filter covers
    all the routes in the MVC pipeline, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，过滤器可以有三种不同的作用域：*全局*、*控制器*和*操作*。在第一种情况下，过滤器在`Startup`类中全局应用。在其他两种情况下，过滤器以属性的形式使用，通常应用于控制器类定义或操作方法定义。让我们更详细地看看这些不同的方法。在`Startup`类中应用过滤器意味着过滤器覆盖了MVC管道中的所有路由，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, `CustomFilter` has a *global scope.* The `config.Filters` attribute
    is a collection of `IFilterMetadata` interfaces. This interface is used to describe
    the filters that are present in our MVC pipeline. It should be noted that the
    collection doesn't check duplicates, which means that we may potentially add two
    filters of the same type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CustomFilter`具有*全局作用域*。`config.Filters`属性是一个`IFilterMetadata`接口的集合。该接口用于描述我们MVC管道中存在的过滤器。需要注意的是，该集合不检查重复项，这意味着我们可能潜在地添加了两个相同类型的过滤器。
- en: Since `FilterCollection` doesn't consider duplicates, it is possible that, in
    a large codebase, a filter type is accidentally initialized more than once, which
    may affect the performance of our service. It is vital to pay attention to code
    merges, especially in a distributed team. By using pull requests and holding code
    review meetings, this kind of silent issue can be avoided.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FilterCollection`不考虑重复项，因此在大型的代码库中，一个过滤器类型可能会意外地初始化多次，这可能会影响我们服务的性能。在分布式团队中，注意代码合并至关重要。通过使用拉取请求和举行代码审查会议，可以避免这类静默问题。
- en: 'On the other hand*,* the *controller scope* and the *action scope* are restricted
    to a specific controller or action. The best way to use a filter on a particular
    controller or action is by extending a filter attribute. ASP.NET Core provides
    some built-in filter attributes. For each filter type, the framework provides
    a corresponding class that provides methods for overriding. For example, this
    is the case for the `ActionFilterAttribute` type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*控制器作用域*和*操作作用域*仅限于特定的控制器或操作。在特定控制器或操作上使用过滤器的最佳方式是通过扩展过滤器属性。ASP.NET Core提供了一些内置的过滤器属性。对于每种过滤器类型，框架提供了一个相应的类，该类提供了重写方法。例如，这是`ActionFilterAttribute`类型的情况：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `CustomControllerFilter` extends the `ActionFilterAttribute` type, which
    contains the `OnActionExecuting` and `OnActionExecuted` methods. The filter can
    be applied to a specific controller class or action method using the syntax of
    the attributes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomControllerFilter`扩展了`ActionFilterAttribute`类型，它包含`OnActionExecuting`和`OnActionExecuted`方法。可以使用属性的语法将过滤器应用于特定的控制器类或操作方法：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Under the hood, `ActionFilterAttribute` is an abstract class and implements
    the `IActionFilter` interface type, which we looked at previously. Therefore,
    by taking a quick look at the `ActionFilterAttribute` class, we can assume that
    this abstract class also provides the `IAsyncActionFilter`, `IResultFilter`, and
    `IAsyncResultFilter` methods:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`ActionFilterAttribute` 是一个抽象类，并实现了之前我们提到的 `IActionFilter` 接口类型。因此，通过快速查看
    `ActionFilterAttribute` 类，我们可以假设这个抽象类也提供了 `IAsyncActionFilter`、`IResultFilter`
    和 `IAsyncResultFilter` 方法：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code snippet describes how ASP.NET Core always provides an easy
    way for us to customize and extend the behavior of our frameworks. Furthermore,
    the user has full control over the code and the interfaces provided by the framework.
    Eventually, we can easily create a custom abstract type that implements a custom
    behavior for the filter and can be extended by other concrete filter classes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段描述了 ASP.NET Core 总是提供一种简单的方法来让我们自定义和扩展框架的行为。此外，用户对框架提供的代码和接口有完全的控制权。最终，我们可以轻松创建一个自定义抽象类型，该类型实现了过滤器的自定义行为，并且可以被其他具体的过滤器类扩展。
- en: Life cycle and dependency injection
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期和依赖注入
- en: As we already said, Dependency injection is a core technique in ASP.NET Core.
    Filters usually rely on other components to provide the filter logic. Before discussing
    injecting dependencies in filters, we need to understand the life cycle process.
    In general, when we apply a filter as an attribute, the life cycle of the filter
    is restricted to the request, which means that it is reinitialized for each request.
    The `ServiceFilter` attribute provides a valid alternative to overriding this
    kind of behavior. Therefore, the `ServiceFilter` attribute uses the *service provider*
    to create filter objects, which means that our filter is managed just like any
    other service declared through the dependency injection system of ASP.NET Core.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，依赖注入是 ASP.NET Core 的核心技术。过滤器通常依赖于其他组件来提供过滤器逻辑。在讨论在过滤器中注入依赖项之前，我们需要了解生命周期过程。一般来说，当我们将过滤器作为属性应用时，过滤器的生命周期被限制在请求范围内，这意味着它为每个请求重新初始化。`ServiceFilter`
    属性提供了对这种行为的有效替代。因此，`ServiceFilter` 属性使用 *服务提供者* 来创建过滤器对象，这意味着我们的过滤器就像通过 ASP.NET
    Core 的依赖注入系统声明的任何其他服务一样被管理。
- en: 'For example, let''s consider the implementation of the `CustomActionFilter`
    class we defined previously:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑之前定义的 `CustomActionFilter` 类的实现：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is possible to initialize the `CustomActionFilter` type using the `AddSingleton`
    extension method in the `Startup` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Startup` 类中的 `AddSingleton` 扩展方法来初始化 `CustomActionFilter` 类型：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then use it in our controllers or action methods, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的控制器或操作方法中使用它，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This approach guarantees that we override the life cycle of the filters by
    explicitly defining the life cycle type in the *service provider*. Therefore,
    the filter pipeline is integrated and initialized using the dependency injection
    engine of ASP.NET Core. Moreover, it is also possible to resolve filter dependencies
    using the dependency injection engine. There are two injection techniques related
    to filters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过在 *服务提供者* 中显式定义生命周期类型来保证我们覆盖了过滤器的生命周期。因此，过滤器管道是通过 ASP.NET Core 的依赖注入引擎进行集成和初始化的。此外，还可以使用依赖注入引擎解析过滤器依赖项。与过滤器相关的有两种注入技术：
- en: Using the `ServiceFilter` technique
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ServiceFilter` 技术方法
- en: Using the `TypeFilterAttribute` technique
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TypeFilterAttribute` 技术方法
- en: 'As we saw previously, the `ServiceFilter` type adds the instance of filters
    in the service provider. It is possible to inject the dependency into a filter
    by adding it to the constructor. We can do this using *constructor injection*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，`ServiceFilter` 类型将过滤器实例添加到服务提供者中。可以通过将其添加到构造函数中来将依赖项注入到过滤器中。我们可以通过
    *构造函数注入* 来实现这一点：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code injects the `ILogger` interface into the constructor and
    uses the exposed `LogInformation` extension method. It is also possible to not
    pass through the *service provider* using `TypeFilterAttribute` by referring to
    our filter using the type and not the instance. We do this by declaring another
    class that extends `TypeFilterAttribute`, which passes the type of our filter
    to the base class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将 `ILogger` 接口注入到构造函数中，并使用暴露的 `LogInformation` 扩展方法。也可以通过使用 `TypeFilterAttribute`
    并通过类型而不是实例来引用我们的过滤器来不通过 *服务提供者* 传递。我们通过声明另一个扩展 `TypeFilterAttribute` 的类来实现这一点，该类将我们的过滤器类型传递给基类：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then it applies the attribute to the target controller:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将属性应用到目标控制器：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `CustomActionFilterAttribute` class extends the `TypeFilterAttribute` base
    class and calls the base constructor by referring to the `CustomActionFilter`
    type. This approach enhances the usability of filter attributes that depend on
    other classes. Now that we have a complete understanding of filters and know how
    to apply them to the filter pipeline, we can take a look at some concrete use
    cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomActionFilterAttribute`类扩展了`TypeFilterAttribute`基类，并通过引用`CustomActionFilter`类型调用基构造函数。这种方法增强了依赖于其他类的过滤器属性的可用性。现在，我们已经完全理解了过滤器，并知道如何将它们应用到过滤器管道中，我们可以看看一些具体用例。'
- en: Filter use cases
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器用例
- en: This section will show some concrete use cases for filters. In general, each
    time you have to replicate the behavior in an action or a controller, you can
    use filters to centralize the logic. Filters also provide a declarative approach,
    which helps us keep your code clean and readable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示一些过滤器的具体用例。一般来说，每次您需要在动作或控制器中复制行为时，您都可以使用过滤器来集中逻辑。过滤器还提供了一种声明式方法，这有助于我们保持代码的整洁和可读性。
- en: Existing entity constraints
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有实体约束
- en: 'Action methods of controllers usually perform constraints on incoming data.
    A common practice is to centralize that kind of logic in filters. Let''s take,
    for example, `OrderController`, which we discussed in the previous chapter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的动作方法通常对传入的数据执行约束。一种常见的做法是将这种逻辑集中到过滤器中。以我们在上一章中讨论的`OrderController`为例：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Three out of five action methods perform the same *existing check* by calling
    `_orderRepository`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 五个动作方法中有三个通过调用`_orderRepository`执行相同的*存在检查*：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A recommended practice is to extract this logic and put it somewhere else,
    possibly an action filter, so that it can be used across action methods. It is
    specific enough to be used only when necessary. Let''s start by setting up our
    filter and adding the dependency with `IOrderRepository`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一种推荐的做法是将这种逻辑提取出来并放在其他地方，可能是一个动作过滤器，这样它就可以在动作方法中使用。它足够具体，只有在必要时才使用。让我们首先设置我们的过滤器并添加`IOrderRepository`的依赖项：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `OrderExistsFilterImpl` class provides the basic setup for an action filter.
    It accepts `IOrderRepository` as a dependency and implements `OnActionExecutionAsync`.
    This implementation class is contained in an attribute class that implements `TypeFilterAttribute`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderExistsFilterImpl`类为动作过滤器提供了基本设置。它接受`IOrderRepository`作为依赖项并实现`OnActionExecutionAsync`。这个实现类包含在一个实现`TypeFilterAttribute`的属性类中。'
- en: 'After declaring the attribute class, we can proceed by implementing the logic.
    `OrderExistsAttribute` has three purposes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明属性类之后，我们可以通过实现逻辑来继续。`OrderExistsAttribute`有三个目的：
- en: To check whether the incoming request contains an `id`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查传入的请求是否包含`id`
- en: To check whether the requested `id` is a `Guid`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查请求的`id`是否为`Guid`
- en: To query `IOrderRepository` to check whether the entity exists
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询`IOrderRepository`以检查实体是否存在
- en: 'Let''s proceed by describing a possible implementation of the previous logic:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续描述之前逻辑的可能实现：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First of all, the code checks whether our action arguments, which are populated
    by the model binder, contain any key by using the `!context.ActionArguments.ContainsKey("id")`
    statement. If the check is not true, the action filters interrupt the pipeline
    by adding a `BadRequestResult` to the response and exiting from the method. Secondly,
    the code checks whether the requested `id` is a `Guid` using `!(context.ActionArguments["id"]
    is Guid id)`. In this case, if the condition fails, it returns a `BadRequestResult`
    and interrupts the pipeline. Finally, the action filter calls `IOrderRepository`
    and checks whether the requested entity exists. If the test is positive, it continues
    the pipeline by calling the `await next();` method; otherwise, it returns a `BadRequestResult`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码通过使用`!context.ActionArguments.ContainsKey("id")`语句检查我们的动作参数（由模型绑定填充）是否包含任何键。如果检查结果为假，动作过滤器通过向响应中添加`BadRequestResult`并退出方法来中断管道。其次，代码使用`!(context.ActionArguments["id"]
    is Guid id)`检查请求的`id`是否为`Guid`。在这种情况下，如果条件失败，它返回一个`BadRequestResult`并中断管道。最后，动作过滤器调用`IOrderRepository`并检查请求的实体是否存在。如果测试结果为正，它通过调用`await
    next();`方法继续管道；否则，它返回一个`BadRequestResult`。
- en: 'In conclusion, we can add our attribute on top of methods that perform the
    actual checks and remove the previously replicated code that''s inside each action
    method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以在执行实际检查的方法上添加我们的属性，并删除之前在每个动作方法中复制的代码：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This kind of approach is compliant with the *DRY principle*. Furthermore, we
    can reuse the filter and handle the logic in a unique entry point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法符合*DRY原则*。此外，我们可以重用过滤器，并在一个独特的入口点处理逻辑。
- en: Before ASP.NET Core 2.1, the same approach was used to check whether a model
    was valid. Instead of replicating the `Model.IsValid` *check-in* in each action,
    the logic was centralized in an action filter. With the introduction of the built-in
    `ApiController` attribute, the constraint has now become implicit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 2.1之前，同样的方法被用来检查模型是否有效。而不是在每个操作中复制`Model.IsValid` *检查*，逻辑被集中在一个操作过滤器中。随着内置的`ApiController`属性的引入，约束现在已成为隐式约束。
- en: Next, let's have a look at altering exceptions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何修改异常。
- en: Altering exceptions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改异常
- en: Another common use for filters is changing the response of a specific request.
    Filters are handy in these cases because they can only be applied to particular
    action methods. Some services need to return a custom format to the client, for
    example, when they are used by a legacy system that only accepts a specific format
    or when they need to provide a response that's been wrapped by a particular envelope.
    ASP.NET Core provides the `IExceptionFilter` interface for this, which allows
    us to overload the exceptions and send a custom response to the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的另一个常见用途是改变特定请求的响应。在这些情况下，过滤器很方便，因为它们只能应用于特定的操作方法。一些服务需要向客户端返回自定义格式，例如，当它们被一个只接受特定格式的旧系统使用时，或者当它们需要提供一个被特定信封包装的响应时。ASP.NET
    Core提供了`IExceptionFilter`接口来实现这一点，它允许我们重载异常并向客户端发送自定义响应。
- en: 'Furthermore, if an exception is thrown, it follows two different behaviors,
    depending on the environment. If the API triggers an exception and it is running
    in a development environment, it returns a current detailed exception page, which
    looks as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果抛出异常，根据环境的不同，会有两种不同的行为。如果API触发异常并且它正在开发环境中运行，它将返回一个当前详细的异常页面，如下所示：
- en: '![](img/522af6fe-6a31-491b-a5d1-24e2db25c19d.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/522af6fe-6a31-491b-a5d1-24e2db25c19d.png)'
- en: 'If we are in a *production environment,* it merely returns a generic `500 Internal
    Server Error`. These two behaviors are defined by default in the out of the box
    Web API template of ASP.NET Core:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于*生产环境*，它仅仅返回一个通用的`500 Internal Server Error`。这两种行为默认由ASP.NET Core的Web
    API模板定义：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In a real-world application, it is usually necessary to provide detailed information
    to the client, thereby guaranteeing reliable communication between the server
    and the client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，通常需要向客户端提供详细信息，从而确保服务器和客户端之间可靠的通信。
- en: In real-world applications, errors are an essential part of services. In some
    cases, companies institute an internal error code definition so that they can
    build more flexible APIs that can handle errors in a better way and establish
    resilient communication between themselves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，错误是服务的重要组成部分。在某些情况下，公司会制定内部错误代码定义，以便它们可以构建更灵活的API，更好地处理错误，并在彼此之间建立弹性的通信。
- en: 'To implement custom exceptions, we should extend the `IExceptionFilter` interface.
    The following code is a possible implementation of this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现自定义异常，我们应该扩展`IExceptionFilter`接口。以下代码是这种实现的可能示例：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The framework invokes the `HttpCustomExceptionFilterImpl` class each time an
    exception is thrown. The class has two dependencies: `ILogger` and `IWebHostEnvironment`.
    The `OnException` method logs the exception using the `ILogger` class and creates
    a new instance of `JsonErrorPayload`, which contains a generic message and some
    details about the exception. Finally, the `OnException` method returns the `500
    Internal server error` status code, as well as the `exceptionObject` that was
    just created.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每次抛出异常时，框架都会调用`HttpCustomExceptionFilterImpl`类。该类有两个依赖项：`ILogger`和`IWebHostEnvironment`。`OnException`方法使用`ILogger`类记录异常，并创建一个新的`JsonErrorPayload`实例，其中包含一个通用消息和一些关于异常的详细信息。最后，`OnException`方法返回`500
    Internal server error`状态码，以及刚刚创建的`exceptionObject`。
- en: The detailed exception message may have some value, depending on `IWebHostEvinronment`.
    This kind of approach is useful in a production context to avoid revealing sensitive
    information about the service.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 详细异常消息可能具有一些价值，这取决于`IWebHostEvinronment`。这种在生产环境中避免泄露关于服务敏感信息的方法是有用的。
- en: 'In conclusion, if our service throws an exception, our `IExceptionFilter` transforms
    it into a new JSON response:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果我们的服务抛出异常，我们的`IExceptionFilter`将其转换成一个新的JSON响应：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some filter concepts in ASP.NET Core. We introduced
    different types of filters, how they work, and the specific purpose of each kind
    in the MVC pipeline. We have also seen how to implement filters and explored some
    concrete use cases to understand and discover the power of filters so that we
    can achieve cross-cutting concerns.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 ASP.NET Core 中的一些过滤器概念。我们介绍了不同类型的过滤器，它们的工作方式以及每种类型在 MVC 管道中的具体用途。我们还看到了如何实现过滤器，并探讨了某些具体用例，以理解和发现过滤器的强大功能，以便我们能够实现横切关注点。
- en: The next chapter is dedicated to the data access layer methodologies in ASP.NET
    Core. You will be introduced to the repository pattern, which will describe the
    implementation of the data access layer using EF Core and Dapper. Furthermore,
    we will also describe some testing techniques that verify the data access layer
    part of an ASP.NET Core application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于 ASP.NET Core 中的数据访问层方法。您将了解到仓储模式，它将描述使用 EF Core 和 Dapper 实现数据访问层的方法。此外，我们还将描述一些测试技术，这些技术用于验证
    ASP.NET Core 应用程序的数据访问层部分。
