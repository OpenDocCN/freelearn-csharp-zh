- en: Testing JavaScript Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试JavaScript应用
- en: To get started testing in JavaScript, we will need to create a ReactJS application
    and configure it for testing using the Mocha, Chai, Enzyme, and Sinon libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用JavaScript进行测试，我们需要创建一个ReactJS应用，并使用Mocha、Chai、Enzyme和Sinon库来配置它进行测试。
- en: These steps were discussed in detail in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    up the JavaScript Environment*, so here, we will simply walk through the steps
    and not explain them in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在第3章中已详细讨论，“设置JavaScript环境”，因此在这里，我们只需概述这些步骤，而不进行详细解释。
- en: 'The goals for this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是：
- en: Create the Speaker Meet React application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建演讲者遇见React应用
- en: 'Talk through our plan of attack for testing the application:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论我们测试应用的行动计划：
- en: What is our approach?
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的方法是什么？
- en: What parts of the app can we even test?
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至可以测试应用的部分是什么？
- en: What part of the app do we start with?
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从应用的哪个部分开始？
- en: 'Write tests and complete a couple of features for the application:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用编写测试并完成几个功能：
- en: Speaker listing
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演讲者列表
- en: Speaker detail
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演讲者详情
- en: Once this chapter is finished, you should be capable of unit-testing any  React-based
    application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这一章完成，你应该能够对任何基于React的应用进行单元测试。
- en: Creating a React app
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建React应用
- en: For the application in this book, to maintain compatibility, you will want to
    use Node.js version 8.5.0, NPM version 5.4.2, and create-react-app version 1.4.0.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的应用，为了保持兼容性，您希望使用Node.js版本8.5.0、NPM版本5.4.2和create-react-app版本1.4.0。
- en: 'Execute the following commands to install and execute the app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来安装和执行应用：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All three commands should run successfully. After running `npm test`, you will
    need to exit the test run by hitting `<q>`. After running `npm start`, you will
    need to exit the server by hitting *Ctrl* + *C*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个命令都应该成功运行。运行`npm test`后，您需要通过按`<q>`退出测试运行。运行`npm start`后，您需要通过按*Ctrl* +
    *C*退出服务器。
- en: Ejecting the app
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推出应用
- en: Assuming the previous step went without a hitch, we can proceed to eject the
    React app. Again, as it has already been explained in detail in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    up the JavaScript Environment*, we will only do a short review here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的步骤没有遇到任何问题，我们可以继续执行将React应用“推出”的操作。同样，正如在[第3章](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195)中详细解释的，“设置JavaScript环境”，我们在这里只做简要回顾。
- en: There is only a single command to eject the application. After ejection, we
    will want to rerun the commands in the previous section to ensure that the application
    still works as expected.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 推出应用只有一个命令。推出后，我们将重新运行上一节中的命令，以确保应用仍然按预期工作。
- en: 'Execute the following command to eject:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来推出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configuring Mocha, Chai, Enzyme, and Sinon
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Mocha、Chai、Enzyme和Sinon
- en: Now, we are ready to add the testing facilities that we would like to use for
    this app. As before, the addition of these utilities has been covered in detail
    in a previous chapter. So, we will only be providing the commands to execute and
    the versions of the packages to install.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备添加我们希望用于此应用的测试设施。与之前一样，这些实用工具的添加已在之前的章节中详细说明。因此，我们只提供执行命令和要安装的包的版本。
- en: 'Execute the following commands to install the libraries we are going to use:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来安装我们将要使用的库：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are also a few other libraries we will be using as part of our Redux
    workflow:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一些其他库作为我们Redux工作流程的一部分：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Including the version in the install command will ensure that you are using
    the same version of the libraries that we are and will reduce the number of potential
    issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装命令中包含版本将确保您使用与我们相同的库版本，并将减少潜在问题的数量。
- en: 'To use the libraries we have just installed, we will also need to install an
    extra preset for babel:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们刚刚安装的库，我们还需要安装一个额外的babel预设：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Update your babel config in `package.json` to remove react-app and include `react`
    and `es2015`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中更新您的babel配置，以删除react-app并包括`react`和`es2015`。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As described in [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    up the JavaScript Environment*, delete the test configuration section from `package.json`.
    Then, update the test script to:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195)中所述，“设置JavaScript环境”，从`package.json`中删除测试配置部分。然后，更新测试脚本为：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add a test watch script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加一个测试监视脚本：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are now ready to update the test execution file `test.js` in the scripts
    folder so it''s compatible with Mocha. Change all the contents of the file to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新脚本文件夹中的测试执行文件`test.js`，使其与Mocha兼容。将文件中的所有内容更改为：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last step before we can use our new testing libraries is to update the
    `App.test.js` file to match the conventions used with Mocha and Chai. So, change
    the filename to `App.spec.js` and update the contents to match the code shown
    here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用新的测试库之前，最后一步是更新`App.test.js`文件以匹配与Mocha和Chai一起使用的约定。因此，将文件名更改为`App.spec.js`，并将内容更新为如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, as before, execute the test script and start the application to make sure
    nothing broke during our transformation to Mocha.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像之前一样，执行测试脚本并启动应用程序，以确保在转换到Mocha的过程中没有出现任何问题。
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All three of those commands should work. If you have an issue, check all the
    steps we have just discussed and look to [Chapter 3](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195), *Setting
    Up a JavaScript Environment*, for a more detailed explanation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个命令都应该能正常工作。如果你遇到问题，检查我们刚刚讨论的所有步骤，并查看[第3章](part0095.html#2QJ5E0-d186949d2da74f5c95dd1712efae1195)，*设置JavaScript环境*，以获取更详细的解释。
- en: The plan
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划
- en: Now that our testing config has been updated and is working correctly, we can
    begin thinking about test-driving our first feature.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们测试配置已经更新并且运行正确，我们可以开始考虑测试驱动我们的第一个功能。
- en: In earlier chapters, we discussed where to start testing and decided that if
    possible an inside-out approach is preferred. To keep with that approach, we want
    to determine the different parts of our React app so that we can target the purest
    business logic we can.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了从哪里开始测试，并决定如果可能的话，一个从内到外的方法更受欢迎。为了保持这种方法，我们想要确定我们React应用程序的不同部分，这样我们就可以针对最纯粹的业务逻辑。
- en: Right off the bat, regardless of any other architectural choices, we can identify
    the React component and a service representing communication with our data source.
    We are planning to use Redux in this app so that makes up the missing piece and
    connects our component with our data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无论其他架构选择如何，我们都可以识别出React组件和代表与我们的数据源通信的服务。我们计划在这个应用程序中使用Redux，这使得它成为缺失的部分，并将我们的组件与我们的数据连接起来。
- en: Which one of these is the business logic though? Out of those base options,
    what would we even test? Let's examine each one a little more closely and see
    what we could test that would be considered a unit test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些中的哪一个代表业务逻辑呢？从这些基本选项中，我们会测试什么呢？让我们更仔细地检查每一个，看看我们能测试什么，这将被视为单元测试。
- en: Considering the React component
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑React组件
- en: Generally, we want to avoid unit-testing third-party libraries. So, let's separate
    the third-party aspects of a React component from the parts that we would potentially
    unit-test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们想要避免对第三方库进行单元测试。因此，让我们将React组件的第三方方面与我们可能进行单元测试的部分分开。
- en: The third-party aspects include any inherited features and functionality; this
    includes to some degree any life cycle methods and the JSX. So, what's left? The
    answer to this question depends on whether the component in question is a presentational
    component or a container component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方方面包括任何继承的功能和特性；这包括一定程度上的任何生命周期方法和JSX。那么，剩下什么呢？这个问题的答案取决于所讨论的组件是呈现组件还是容器组件。
- en: Presentational components are almost pure HTML and view mechanisms. There is
    almost no traditionally unit-testable behavior. Certainly, there is no real business
    logic.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现组件几乎是纯HTML和视图机制。几乎没有传统上可进行单元测试的行为。当然，没有真正的业务逻辑。
- en: Container components are where the real action happens in a React application.
    These components can manipulate data and make business decisions that can control
    the flow of the application. So, let's keep container components in the list of
    possible places to start our unit-testing efforts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件是React应用程序中真正发生动作的地方。这些组件可以操作数据并做出业务决策，这些决策可以控制应用程序的流程。因此，让我们将容器组件保留在可能的单元测试起点列表中。
- en: Looking at Redux testability
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Redux的可测试性
- en: Redux is a third-party library, that controls data flow throughout the application
    and manages quite a bit of the normal data shuffling that we may want to unit
    test. Because it is third-party though, on the surface there doesn't seem to be
    too much that we can unit test. Let's take a closer look at the aspects of the
    Redux data flow to determine if there really is nothing to test or if we still
    need to unit test parts of Redux.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个第三方库，它控制着整个应用中的数据流，并管理了我们可能想要进行单元测试的大量正常数据交换。因为它是第三方库，所以表面上似乎没有太多可以单元测试的。让我们更仔细地看看Redux数据流的各个方面，以确定是否真的没有什么可以测试的，或者我们是否仍然需要单元测试Redux的部分。
- en: The store
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Store
- en: The Redux store is where all the data lives after it has been acquired by the
    application. Typically, there is only one store for each application using Redux.
    The store is almost completely contained within the Redux library and we have
    very few direct interactions with it. For this reason, there doesn't seem to be
    much we would or could test for the store and it falls squarely in the realm of
    third-party code that we must simply trust.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Redux store是应用获取所有数据后数据所在的地方。通常，每个使用Redux的应用只有一个store。store几乎完全包含在Redux库中，我们与它的直接交互非常少。因此，似乎没有太多我们可以或必须为store进行测试的，它完全属于我们必须简单地信任的第三方代码领域。
- en: Actions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actions
- en: Actions in Redux represent an event carrying a data packet. The event is usually
    a command to either retrieve or update data within the data source which should
    be reflected by the store. Because actions are just a key with some data attached,
    there doesn't seem to be much to test here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的Actions代表携带数据包的事件。这个事件通常是一个命令，用于从数据源中检索或更新数据，这些数据应该由store反映出来。因为actions只是一个带有一些数据的键，所以在这里似乎没有太多可以测试的。
- en: Reducers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: If there is anything to test within the Redux interactions, it is likely in
    the reducers. Reducers receive the actions and determine what to do, if anything,
    based on the actions requested and the data provided as part of those actions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Redux交互中有什么可以测试的，那很可能是在reducers中。Reducers接收actions，并根据请求的actions和作为这些actions一部分提供的数据来确定要做什么，如果需要的话。
- en: Typically, the reducer is going to simply call the API service once the appropriate
    service call is determined. It is possible that a reducer might also map the received
    data into a format that is more appropriate to the service call that must be made.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦确定了适当的service调用，reducer将简单地调用API服务。有可能reducer也可能将接收到的数据映射到更适合必须进行的service调用的格式。
- en: So, if the reducer is, in all reality, just going to call the service, what
    would we test for the reducer? Other than ensuring that the appropriate service
    method is called with the appropriate data there doesn't seem to be much. For
    completeness, we would want to test those things, but they do not represent the
    core of our business logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果实际上reducer只是将要调用服务，我们应该为reducer测试什么？除了确保使用适当的数据调用适当的service方法之外，似乎没有太多可以测试的。为了完整性，我们可能想要测试这些事情，但它们并不代表我们的业务逻辑的核心。
- en: In conclusion, it doesn't appear that much is testable in Redux and what is
    testable doesn't represent the core of our business logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Redux中似乎没有太多可以测试的内容，而且可以测试的内容并不代表我们的业务逻辑的核心。
- en: Unit-testing an API service
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试API服务
- en: Lastly, let's look at the API service. Normally, the service in a front-end
    application behaves much like the repository in a back-end application. The service's
    main function is to abstract data interactions with some data source. Those interactions
    don't necessarily contain any definable business logic. The real logic, if any,
    for a service exists on the server and doesn't need to be tested as part of a
    front-end application. At least it doesn't need to be tested the way you might
    think it does.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看API服务。通常，前端应用中的服务表现得就像后端应用中的仓库一样。服务的主要功能是抽象与某些数据源的数据交互。这些交互不一定包含任何可定义的业务逻辑。如果有的话，服务的真实逻辑存在于服务器上，并且不需要作为前端应用的一部分进行测试。至少，它不需要以你可能会认为的方式进行测试。
- en: So, if the service doesn't contain any business logic, and Redux doesn't contain
    much business logic, and the components don't contain much business logic, what
    do we test and how can it be unit-tested?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果服务不包含任何业务逻辑，Redux也不包含太多业务逻辑，组件也不包含太多业务逻辑，我们应该测试什么，以及如何进行单元测试呢？
- en: The short answer is that we are not off the hook for testing, but we will have
    to jump through some hoops to do any testing because it is difficult to remove
    ourselves from integration testing. In a typical front-end application, unlike
    in C#, there is no clear division between our code and their code. So, we will
    have to make some concessions and write quite a bit of code to abstract parts
    of third-party code to allow us to test what we need to be testing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，我们还没有摆脱测试的责任，但我们必须跳过一些障碍才能进行任何测试，因为从集成测试中抽身是很困难的。在典型的前端应用程序中，与C#不同，我们的代码和他们的代码之间没有明确的界限。因此，我们将不得不做出一些妥协，并编写大量的代码来抽象第三方代码的部分，以便我们可以测试我们需要测试的内容。
- en: So, where does this leave us when it comes to a testing direction?  Unfortunately,
    there doesn't seem to be a clear winner. For the purposes of this application,
    we will work from the data source up so that we have a clear understanding of
    the data manipulations available to us while we write user interface aspects of
    the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们谈论测试方向时，这又把我们带向何方呢？遗憾的是，似乎没有明确的胜者。为了这个应用程序的目的，我们将从数据源开始工作，这样在我们编写应用程序的用户界面方面时，我们可以清楚地了解我们可用的数据操作。
- en: Speaker listing
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演讲者列表
- en: Following the functionality in our C# backend, we will start by testing a listing
    of the speakers available. We are not yet ready to connect to the backend and,
    for any of the tests we will write here as unit tests, we will need to mock the
    behaviors that the backend would normally present.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的C#后端的功能，我们首先将测试可用的演讲者列表。我们还没有准备好连接到后端，并且对于我们将要在这里编写的任何测试（作为单元测试），我们需要模拟后端通常会呈现的行为。
- en: For the moment, we are not going to concern ourselves with any kind of authentication.
    So, the important functionality we will be looking to implement is that when no
    speakers exist we should let the user know, and when speakers do exist we should
    list them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不会关心任何类型的身份验证。因此，我们将要实现的重要功能是，当没有演讲者存在时，我们应该让用户知道，当演讲者存在时，我们应该列出他们。
- en: The way that we will produce both situations is through a mock API. As strange
    as it may seem, most of our business logic will be in the mock API. Because it
    will be crucial to all of the other tests we will write, we must unit test the
    mock API as if it were production code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将产生这两种情况的方式是通过模拟API。虽然这听起来可能很奇怪，但我们的大部分业务逻辑将位于模拟API中。因为它对于我们将要编写的所有其他测试都至关重要，我们必须像对待生产代码一样对模拟API进行单元测试。
- en: A mock API service
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟API服务
- en: To begin testing the mock API service, let's create a new services folder and
    add a `mockSpeakerService.spec.js` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始测试模拟API服务，让我们创建一个新的服务文件夹，并添加一个`mockSpeakerService.spec.js`文件。
- en: Inside that file, we need to import our assertion library, create our initial
    describe, and write an existence test.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件中，我们需要导入我们的断言库，创建我们的初始describe，并编写一个存在性测试。
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Start the npm test script with watch. The test we just wrote should fail. To
    make the test pass, we must create a `MockSpeakerService` object. Let's play devil's
    advocate a little and create an object in this file, but only enough of an object
    to make the test pass.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有watch的npm测试脚本开始。我们刚刚编写的测试应该失败。为了使测试通过，我们必须创建一个`MockSpeakerService`对象。让我们扮演一下魔鬼的代言人，在这个文件中创建一个对象，但只创建足够使测试通过的对象。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This line passes the currently failing test, but clearly isn't what we are after.
    It does, however, force us to write more robust tests. The next test we can write
    is one that proves that the `MockSpeakerService` can be constructed. This test
    should ensure that we have defined the `MockSpeakerService` as a class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过了目前失败的测试，但显然不是我们想要的。然而，它确实迫使我们编写更健壮的测试。我们可以编写的下一个测试是证明`MockSpeakerService`可以被构造。这个测试应该确保我们已经将`MockSpeakerService`定义为一个类。
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This test fails, stating that `MockSpeakerService` is not a constructor. The
    way to fix this is to change `MockSpeakerService` into a class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败了，显示`MockSpeakerService`不是一个构造函数。解决这个问题的方式是将`MockSpeakerService`改为一个类。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have a class that can be instantiated, the next test we write can
    start to test actual functionality. So, what functionality are we going to test?
    Looking at the requirements, we can see that the first scenario involves requesting
    all the speakers and receiving no speakers. That's a reasonably simple scenario
    to test. What would we call the function in the `MockSpeakerService` that would
    get all the speakers? Because we are trying to get all the speakers, a simple
    name that would not be redundant and fits the repository pattern we discussed
    in the C# backend is simply `getAll`. Let's create a nested describe and an existence
    test for a `getAll` class method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以实例化的类，接下来我们编写的测试可以开始测试实际的功能。那么，我们将测试哪些功能呢？查看需求，我们可以看到第一个场景涉及请求所有演讲者并接收没有演讲者。这是一个相对简单的测试场景。我们在`MockSpeakerService`中会称什么函数为获取所有演讲者的函数呢？因为我们试图获取所有演讲者，一个简单且不重复且符合我们在C#后端讨论的存储库模式的名称是简单地`getAll`。让我们创建一个嵌套的describe和一个`getAll`类方法的存活性测试。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As per usual, this test should fail and it should fail with `expected undefined
    to exist`. Making this test pass is relatively simple, just add a `getAll` method
    to the `MockSpeakerService` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，这个测试应该失败，并且应该以`expected undefined to exist`失败。让这个测试通过相对简单，只需在`MockSpeakerService`类中添加一个`getAll`方法。
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next thing we need to decide is the result we should expect when there are
    no speakers. Looking back at the backend, we should be receiving an empty array
    when no speakers are present. Looking at the requirements, the system should present
    a `NO_SPEAKERS_AVAILABLE` message. Should the service be responsible for displaying
    that message? In this case, the answer is no. The react component should be responsible
    for displaying the `NO_SPEAKERS_AVAILABLE` message when we get to that portion
    of the code. For now, we should expect, when no speakers exist, to receive an
    empty data set.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要决定的是当没有演讲者时我们应该期望什么结果。回顾后端，当没有演讲者时，我们应该收到一个空数组。查看需求，系统应该显示`NO_SPEAKERS_AVAILABLE`消息。服务应该负责显示这个消息吗？在这种情况下，答案是不了。当到达代码的这一部分时，react组件应该负责显示`NO_SPEAKERS_AVAILABLE`消息。现在，我们应该期望，当没有演讲者存在时，接收一个空的数据集。
- en: Because we are extending the context of the test, let's create another describe
    for that context extension.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在扩展测试上下文，让我们为这个上下文扩展创建另一个describe。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice the syntax we used for this test. We return the promise and make our
    assertions inside the then function. This is because we want our test to operate
    on asynchronous code from our service. The majority of backend operations will
    need to be asynchronous and one convention for dealing with that asynchronicity
    is to use promises. Asynchronous tests, that is, tests dealing with promises,
    in Mocha require that the promise be returned from the test so that Mocha can
    know to wait for the promise to resolve before closing out the test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这个测试中使用的语法。我们在`then`函数中返回承诺并做出断言。这是因为我们希望我们的测试在服务中的异步代码上操作。大多数后端操作将需要异步执行，处理这种异步性的一个惯例是使用承诺。在Mocha中，异步测试，即处理承诺的测试，要求承诺必须从测试中返回，这样Mocha就可以知道在关闭测试之前等待承诺解析。
- en: And now, to make the test pass, all we need to do is return a promise that resolves
    with an empty array from the `getAll` method. We are going to use a zero delay
    `setTimeout` here which will set us up to implement some kind of delay for development
    purposes later on. The reason we want a delay is so that we can test the operation
    of the UI in the event of a slow network response.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了让测试通过，我们只需要从`getAll`方法返回一个解析为空数组的承诺。在这里我们将使用一个零延迟的`setTimeout`，这样我们就可以为开发目的稍后实现某种延迟。我们想要延迟的原因是，这样我们就可以测试在慢速网络响应事件中UI的操作。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we have the first scenario passing and enough code to warrant a refactoring.
    We are declaring the service variable in multiple places and we don't have a context
    that represents a baseline instantiation of that variable. Let's create a describe
    to wrap all the post instantiation tests and add a `beforeEach` to initialize
    a service variable scoped to that describe and available to all the tests within
    it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过了第一个场景，并且有足够的代码可以进行重构。我们在多个地方声明了服务变量，并且我们没有表示该变量基线实例化的上下文。让我们创建一个describe来包裹所有后实例化测试，并添加一个`beforeEach`来初始化一个作用域在describe内的服务变量，并且使其对所有该describe内的测试可用。
- en: 'Here are the tests after the refactoring:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是重构后的测试：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next scenario, the speaker listing, is for when speakers do exist. The first
    test for this scenario will need to add at least one speaker to the mock API.
    Let's create a new describe inside `GetAll` but separate from `No Speakers Exist`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个场景，演讲者列表，是在演讲者存在时的情况。这个场景的第一个测试需要至少向模拟 API 添加一个演讲者。让我们在 `GetAll` 内创建一个新的
    `describe`，但与 `No Speakers Exist` 分开。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have added, as part of the setup for this test, a reference to a `Create`
    method. This method does not yet exist and our test can't pass without it. So,
    we need to temporarily ignore this test and write tests for `Create`. We can ignore
    this test by skipping it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个测试设置的一部分，我们已经添加了对一个 `Create` 方法的引用。这个方法目前还不存在，我们的测试没有它无法通过。因此，我们需要暂时忽略这个测试，并编写
    `Create` 的测试。我们可以通过跳过它来忽略这个测试。
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we can write a new describe block inside the `After Initialization` block
    for `Create`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `After Initialization` 块内为 `Create` 编写一个新的 `describe` 块。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And to make the test pass we add the `Create` method to the mock service class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们向模拟服务类中添加了 `Create` 方法。
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could, from this point, write a few tests to add validation logic to the
    `Create` method. However, we don't currently have any scenarios that reference
    a `Create` method on the API. Since this method exists only for testing purposes,
    we are going to leave it alone with just an exists test. Let's move back to our
    scenario test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们可以编写一些测试来向 `Create` 方法添加验证逻辑。然而，我们目前没有任何引用 API 上 `Create` 方法的场景。由于这个方法仅用于测试目的，我们将让它保持原样，只进行存在性测试。让我们回到我们的场景测试。
- en: Now that `Create` exists, we should receive the failure that the test is expecting,
    which is that we expected a length of 1 but instead we have a length of 0\. Remove
    skip from the test and verify.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Create` 存在了，我们应该收到测试预期的失败，即我们期望长度为 1，但实际长度为 0。从测试中移除 `skip` 并验证。
- en: To make this test pass, we essentially have to implement the basic logic for
    create and make a modification to `getAll`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们实际上必须实现创建的基本逻辑并对 `getAll` 进行修改。
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can consider the current tests sufficient to move forward and start testing
    our data flow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以认为当前的测试足够了，可以开始测试我们的数据流。
- en: The Get All Speakers action
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有演讲者的动作
- en: To begin testing with Redux, there are a few testing entry points we could start
    with. We could begin by testing actions, reducers, or even interactions with the
    store. The store tests would be more integration tests and we want to concentrate
    on unit tests in this chapter. That leaves actions and reducers. Either is a fine
    place to start, but we will start with actions because they are extremely simple
    and uncomplicated as a concept for testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Redux 进行测试，我们可以从几个测试入口点开始。我们可以从测试动作、reducer 或甚至与存储的交互开始。存储测试将更多是集成测试，而我们希望在这个章节中专注于单元测试。这留下了动作和reducer。两者都是良好的起点，但我们将从动作开始，因为它们在测试概念上非常简单且不复杂。
- en: The action that we need right now is one to request the retrieval of speaker
    information; in essence, a get all speakers action. As stated earlier, actions
    can be extremely simple; however, we have an issue in that our get all speakers
    service call is asynchronous. Actions were not really designed to handle asynchronous
    calls. For that reason, let’s start with something a little bit simpler and we
    will come back to this problem after we understand how to test a normal action.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要的动作是请求检索演讲者信息的一个动作；本质上，就是一个获取所有演讲者的动作。如前所述，动作可以非常简单；然而，我们有一个问题，那就是我们的获取所有演讲者的服务调用是异步的。动作并不是真正设计来处理异步调用的。因此，让我们从一个稍微简单一点的东西开始，等我们了解了如何测试正常动作后，再回来解决这个问题。
- en: Testing a standard action
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试标准动作
- en: We will need an action to notify Redux that we have the speakers after they
    have been loaded. There is no reason why we can't start there. So, let's write
    a test for the successful retrieval of speakers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在演讲者加载完毕后通知 Redux 我们已经获取了演讲者。我们没有理由不能从这里开始。所以，让我们编写一个测试来验证成功检索演讲者。
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Running this test should fail. To make the test pass, define a function named
    `getSpeakersSuccess`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试应该会失败。为了使测试通过，定义一个名为 `getSpeakersSuccess` 的函数。
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because of the simplicity of a typical action, our next test will essentially
    test the functionality of the action. We could break this into multiple tests,
    but all we are really doing is asserting on the structure of the data returned.
    Concerning the single assert rule, we are still only asserting one thing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于典型动作的简单性，我们的下一个测试实际上将测试动作的功能。我们可以将其分解成多个测试，但我们实际上只是在断言返回数据的结构。关于单一断言规则，我们仍然只断言了一件事情。
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To make this test pass, we need to make significant changes to our current implementation
    of the `getSpeakersSuccess` function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们需要对我们当前实现的 `getSpeakersSuccess` 函数进行重大修改。
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Redux, actions have an expected format. They must contain a type property
    and usually contain some data structure. In the case of `getSpeakersSuccess,`
    our type is a constant, `GET_SPEAKERS_SUCCESS`, and the data is an array of speakers
    passed into the action. To make them available to the application, let's move
    the action and the constant into their own files. We need a `speakerActions` file
    and an `actionTypes` file,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 中，动作有一个预期的格式。它们必须包含一个类型属性，通常包含某些数据结构。在 `getSpeakersSuccess` 的情况下，我们的类型是一个常量，`GET_SPEAKERS_SUCCESS`，数据是传递给动作的演讲者数组。为了让它们对应用程序可用，让我们将动作和常量移动到它们自己的文件中。我们需要一个
    `speakerActions` 文件和一个 `actionTypes` 文件，
- en: '`src/actions/speakerActions.js`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/actions/speakerActions.js`:'
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`src/reducers/actionTypes.js`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/reducers/actionTypes.js`:'
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add import statements to the test and all the tests should pass. For a typical
    action, this is the format for testing. The placement of the action types in the
    reducers folder is for dependency inversion reasons. From a SOLID standpoint,
    the reducers are defining a contract of interaction, which is represented by the
    action types. The actions are fulfilling that contract.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中添加导入语句，并且所有测试都应该通过。对于一个典型的动作，这是测试的格式。在 `reducers` 文件夹中放置动作类型是为了依赖反转的原因。从
    SOLID 的角度来看，`reducers` 定义了一个交互合同，这由动作类型表示。动作是履行这个合同的。
- en: Testing a thunk
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 `thunk`
- en: Because the `getSpeakersSuccess` action is intended to be the resulting action
    of a successful service call, we need a special kind of action to represent the
    service call itself. Redux does not inherently support asynchronous actions, as
    stated before. So, we need some other way to accomplish communication with the
    backend. Thankfully, Redux does support middleware and much middleware has been
    designed to add asynchronous capability to Redux. We are going to use `redux-thunk`
    for simplicity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `getSpeakersSuccess` 动作旨在表示成功服务调用的结果，我们需要一种特殊类型的动作来表示服务调用本身。如前所述，Redux 并不固有地支持异步动作。因此，我们需要其他方式与后端进行通信。幸运的是，Redux
    支持中间件，许多中间件已被设计为向 Redux 添加异步能力。我们将为了简单起见使用 `redux-thunk`。
- en: To start the next test, we need to first import `redux-thunk` and `redux-mock-store`
    to our speaker action tests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始下一个测试，我们首先需要将 `redux-thunk` 和 `redux-mock-store` 导入到我们的演讲者动作测试中。
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then we can test the getting speakers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以测试获取演讲者。
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As usual, we start with a test for existence. And, as usual, it is fairly easy
    to make this test pass. In the speaker actions file, add a definition for the
    `getSpeakers` function and export it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们从存在性测试开始。而且，如同往常，使这个测试通过相当容易。在演讲者动作文件中，添加 `getSpeakers` 函数的定义并将其导出。
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The next test is slightly more complicated than the tests we have been working
    on, so we will explain it in rather more detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试比我们之前工作的测试稍微复杂一些，所以我们将更详细地解释它。
- en: 'The first thing we will need to do is configure a mock store and add the thunk
    middleware. We need to do this because to properly test a thunk we will have to
    pretend that Redux is actually running so that we can dispatch our new action
    and retrieve the results. So, let''s add our mock store configuration to the `Async
    Actions` `describe`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是配置一个模拟存储库并添加 `thunk` 中间件。我们需要这样做，因为为了正确测试 `thunk`，我们必须假装 Redux 正在运行，这样我们才能派发我们的新动作并检索结果。所以，让我们将我们的模拟存储库配置添加到
    `Async Actions` 的 `describe` 中：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we have a store available to us, we are ready to begin writing the
    test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可用的存储库，我们就可以开始编写测试了。
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the arrange, we are configuring a bare minimum speaker. Then, we call the
    action we previously tested to build the proper data structure. Finally, we define
    a mock store and its initial state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排阶段，我们配置了一个最基础的演讲者。然后，我们调用之前测试过的动作来构建合适的数据结构。最后，我们定义了一个模拟存储库及其初始状态。
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, when testing asynchronously in Mocha, we can return a promise and Mocha
    will automatically know that test is asynchronous. Our assertions, for asynchronous
    tests, go in the resolve or the reject function of the promise. In the case of
    the get speaker action, we are going to assume a successful server interaction
    and test the resolved promise.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当在Mocha中进行异步测试时，我们可以返回一个promise，Mocha将自动知道这个测试是异步的。对于异步测试，我们的断言放在promise的resolve或reject函数中。在获取演讲者动作的情况下，我们将假设服务器交互成功，并测试解析的promise。
- en: Because we are not returning anything from our `getSpeakers` action, the `mockStore`
    throws an error stating that the action may not be an undefined. To move the test
    forward, we must return something. To move in the direction of using a `thunk`,
    we need to return a function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们从`getSpeakers`动作中没有返回任何内容，`mockStore`抛出一个错误，指出动作可能不是undefined。为了使测试继续进行，我们必须返回一些内容。为了朝着使用`thunk`的方向前进，我们需要返回一个函数。
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding the return of a function that does nothing else moves the test failure
    message forward and now presents us with a failure to read the property `then`
    of undefined. So, now we need to return a promise from our action. We already
    have the service endpoint built in the mock API service, so let's call that now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个什么也不做的函数的返回值将测试失败信息向前推进，现在呈现的是无法读取undefined的`then`属性。所以，现在我们需要从我们的动作中返回一个promise。我们已经在模拟API服务中构建了服务端点，所以现在让我们调用它。
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now the test passes and we have written our first test dealing with thunks.
    As you can see, both the test and the code to pass the test are fairly easy to
    write.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了，我们已经编写了第一个处理thunks的测试。如您所见，测试和通过测试的代码都相当容易编写。
- en: The Get All Speakers reducer
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有演讲者的reducer
- en: Now that we have tested the actions related to getting all the speakers, it's
    time to move on to testing the reducers. As usual, let's begin with an exists
    test.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了与获取所有演讲者相关的动作，是时候转向测试reducers了。像往常一样，让我们从一个存在性测试开始。
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To make this test pass, all we need to do is define a function named `speakersReducer`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们只需要定义一个名为`speakersReducer`的函数。
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our next test will check the functionality of the reducer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个测试将检查reducer的功能。
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This test is larger than we normally prefer, so let's walk through it. In the
    arrange, we configure the initial state and create an action result consisting
    of an array of a single speaker. When a reducer is called, the previous state
    of the application and the result of an action are passed to it. In this case,
    we start with an empty array and the modification is the addition of a single
    speaker.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试比我们通常喜欢的要大，所以让我们来分析一下。在安排阶段，我们配置初始状态并创建一个由单个演讲者组成的动作结果数组。当一个reducer被调用时，应用的前一个状态和动作的结果会被传递给它。在这种情况下，我们从一个空数组开始，修改是添加一个单个演讲者。
- en: Next, in the *Act* section of the test, we call the reducer passing in the `initialState`
    and the result of our action call. The reducer returns a new state for us to use
    in the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在测试的 *Act* 部分，我们调用reducer，传入`initialState`和我们的动作调用结果。reducer返回一个新的状态，供我们在应用中使用。
- en: Lastly, in the assert, we expect that the new state consists of a single speaker
    and that the speaker has the same data as the speaker we created for the action.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在断言中，我们期望新状态由单个演讲者组成，并且演讲者具有与我们为动作创建的演讲者相同的数据。
- en: To make the test pass we need to handle the action being passed into the reducer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要处理传递给reducer的动作。
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because, in an application using Redux, reducers are called for every action,
    we need to determine what to do for any action that is not the action we want
    to handle. The proper response in those cases is to simply return the state with
    no modification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在使用Redux的应用中，对于每个动作都会调用reducer，我们需要确定对于任何不是我们想要处理的动作，我们应该做什么。在这些情况下，适当的响应是简单地返回未修改的状态。
- en: For the action type that we do want to handle, in this case we are returning
    the actions speakers array. In other reducers, we might combine the initial state
    with the actions result, but for get speakers success we want to replace the state
    with the value we receive.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要处理的动作类型，在这种情况下，我们返回动作的演讲者数组。在其他reducers中，我们可能会将初始状态与动作结果合并，但对于获取演讲者成功，我们想要用我们接收的值替换状态。
- en: The last step, now that all our tests are passing, is to extract the speaker
    reducer from the test file and move it to `speakerReducer.js`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，现在所有测试都通过了，我们需要将演讲者reducer从测试文件中提取出来，并将其移动到`speakerReducer.js`
- en: The Speaker listing component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演讲者列表组件
- en: Another piece of the application that we can test is the components. There are
    two types of component in a typical React + Redux application. We have container
    and presentational components.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试应用的其他部分，即组件。在典型的React + Redux应用中，有两种类型的组件。我们有容器组件和表示性组件。
- en: Container components don't typically hold any real HTML in them. The render
    function for a container component simply references a single presentational component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件通常不包含任何真实的HTML。容器组件的渲染函数只是引用单个表示性组件。
- en: Presentational components don't typically have any business logic in them. They
    receive properties and display those properties.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表示性组件通常不包含任何业务逻辑。它们接收属性并显示这些属性。
- en: In our journey from the back-end to the front-end, we have been covering the
    retrieval and updating of data. Next, let's look at the container component that
    will use this data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从后端到前端的过程中，我们已经涵盖了数据的检索和更新。接下来，让我们看看将使用这些数据的容器组件。
- en: Our container component is going to be a simple one. Let's start with the typical
    existence test.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的容器组件将是一个简单的组件。让我们从典型的存在性测试开始。
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Simple and straightforward; now to make it pass.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 简单直接；现在来让它通过。
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next is the render function of the component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是组件的渲染函数。
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This test introduces some new concepts. Starting at the act portion of the test.
    We are using Enzyme's shallow render. A shallow render will render the React component
    but not the component's children. In this case, we are expecting that a `SpeakerList`
    component exists and that this component is rendering it. The Enzyme adapter configuration
    is shown here, but it can also be moved to `test.js` after the tests pass.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试引入了一些新的概念。从测试的act部分开始。我们使用Enzyme的浅渲染。浅渲染会渲染React组件，但不会渲染组件的子组件。在这种情况下，我们期望存在一个`SpeakerList`组件，并且这个组件正在渲染它。这里显示了Enzyme适配器的配置，但也可以在测试通过后将它移动到`test.js`文件中。
- en: We are also checking the props to make sure we pass the speakers into the presentational
    component. To make this test pass, we must make modifications to the `SpeakersPage`
    component, but we must also create a `SpeakerList` component. Let's do that now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在检查属性，以确保我们将演讲者传递给表示性组件。为了让这个测试通过，我们必须修改`SpeakersPage`组件，但我们也必须创建一个`SpeakerList`组件。现在让我们来做这件事。
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And then in a new file, we need to add the `SpeakerList`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在新的文件中，我们需要添加`SpeakerList`。
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You may have noticed that our container component doesn't have any logic. In
    fact, all it does is render the `SpeakerList` component. If that is all it does,
    why is it a container component? The reason is that this component is going to
    be a Redux-connected component. We want to keep the Redux code in our business
    logic and out of our display components. So, we are treating this as a higher
    order component and just using it to pass data through to the presentational components.
    Later, when we get to the speaker detail component you will see a container component
    with a little business logic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的容器组件没有任何逻辑。事实上，它所做的只是渲染`SpeakerList`组件。如果它只做这些，为什么它是一个容器组件呢？原因在于这个组件将是一个Redux连接组件。我们希望将Redux代码保留在我们的业务逻辑中，而不是在我们的显示组件中。因此，我们将它视为一个高阶组件，只是用它来将数据传递给表示性组件。稍后，当我们到达演讲者详情组件时，你会看到一个带有少量业务逻辑的容器组件。
- en: For now, our `SpeakerList` component looks a little anemic and doesn't really
    work as part of a React Redux app. Time to test our presentational components.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`SpeakerList`组件看起来有点瘦弱，并不能真正作为一个React Redux应用的一部分工作。是时候测试我们的表示性组件了。
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because of the last test, this test will automatically pass. Normally we would
    not write this test if we followed to progression what we just did. In reality,
    what we should have done is ignore the previous test, create this test, and then
    create the `SpeakerList` component. After which, we could have re-enabled the
    previous test and gotten it to pass.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一个测试，这个测试将自动通过。通常情况下，如果我们遵循我们刚才所做的进度，我们不会编写这个测试。实际上，我们应该忽略之前的测试，创建这个测试，然后创建`SpeakerList`组件。之后，我们可以重新启用之前的测试并让它通过。
- en: The next step is to test that a message of no speakers available is rendered
    when the speakers array is empty.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是测试当演讲者数组为空时，是否渲染了没有可用演讲者的消息。
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For this test, we created a helper function to initialize the component with
    the props that we need. To make the test pass we just need to return a `div` with
    the correct text.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次测试，我们创建了一个辅助函数来初始化组件，并传入我们需要的属性。为了让测试通过，我们只需返回一个包含正确文本的`div`。
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While we are only testing for the `no-speakers` `div`, we can have decoration
    that we decide not to test. In this case, we want a header on the page. Our tests
    should pass regardless.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只测试 `no-speakers` `div` 时，我们可以有装饰，但我们决定不测试它。在这种情况下，我们希望在页面上有一个标题。我们的测试应该通过。
- en: So, now we are ready to test for when speakers do exist.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们准备测试当演讲者存在的情况。
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this test, we check for two things. We want the correct number of speaker
    rows to display and we want them to be rendered by a new `SpeakerListRow` component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们检查了两件事。我们希望显示正确的演讲者行数，并且希望它们由新的 `SpeakerListRow` 组件渲染。
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The component code has changed significantly because of our latest test. We
    had to add some logic, and we also added a default error case if somehow the content
    were to make it through without being assigned.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最新的测试，组件代码已经发生了显著变化。我们不得不添加一些逻辑，并且我们还添加了一个默认错误情况，以防内容在没有分配的情况下通过。
- en: There is one more component to make the code work correctly for this section.
    We are not going to test that component in this book, though. The component has
    no logic inside it and is left as an exercise to you to create.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一部分的代码正确工作，我们还需要一个组件。虽然我们不会在这个书中测试该组件，但该组件内部没有逻辑，留作你的练习来创建。
- en: In order to create that component, it would be nice if the application ran.
    Right now, we have not wired up Redux so the application won't render anything.
    Let's walk through the configuration we are using for Redux now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建该组件，如果应用程序能够运行会更好。目前，我们没有连接 Redux，所以应用程序不会渲染任何内容。让我们回顾一下我们现在使用的 Redux 配置。
- en: 'Inside `index.js`, we need to add a few items to let Redux work. Your index
    should look similar to this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 中，我们需要添加一些项目以让 Redux 工作。你的索引应该看起来像这样：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The two parts that we have added are the Redux store including an initial call
    to dispatch the load speakers action, and markup to add the Redux provider.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的两个部分是 Redux 存储，包括一个初始调用以分发加载演讲者的动作，以及添加 Redux 提供者的标记。
- en: Where your other routes are defined, you will need to add routes for the speaker
    section. We are placing the Routes in `App.js`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义其他路由的地方，你需要为演讲者部分添加路由。我们将路由放在 `App.js` 中。
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Lastly, we have to convert our component to a Redux component. Add the following
    lines to the bottom of your speaker's page component file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将我们的组件转换为 Redux 组件。将以下行添加到演讲者页面组件文件底部。
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Starting at the bottom of the code sample, the connect function is provided
    by Redux and will wire up all the Redux functionality into our component. The
    two functions passed in, `mapStateToProps` and `mapDispatchToProps`, are passed
    in as a way to populate state and provide actions for our component to execute.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码示例的底部开始，`connect` 函数由 Redux 提供，它将所有 Redux 功能连接到我们的组件中。传入的两个函数 `mapStateToProps`
    和 `mapDispatchToProps` 是作为填充状态和为我们的组件提供执行动作的方式传入的。
- en: Inside `mapDispatchToProps` we are calling `bindActionCreators`; this is another
    Redux-provided function and will give us an object containing all the actions.
    By returning that object directly from `mapDispatchToProps,` we are adding the
    actions directly to props. We could also create our own object containing an actions
    property and then assign the result of the `bindActionCreators` to that property.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mapDispatchToProps` 中，我们调用 `bindActionCreators`；这是另一个 Redux 提供的函数，将给我们一个包含所有动作的对象。通过直接从
    `mapDispatchToProps` 返回该对象，我们将动作直接添加到 props 中。我们也可以创建一个包含动作属性的对象，然后将 `bindActionCreators`
    的结果分配给该属性。
- en: Anywhere inside the application that references `SpeakersPage` can now be changed
    to just `SpeakersPage`, which will grab our new default export. Do not make this
    change in the tests. Inside the tests we still want the named import.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序内部任何引用 `SpeakersPage` 的地方，现在都可以改为仅 `SpeakersPage`，这将获取我们新的默认导出。不要在测试中做这个更改。在测试中，我们仍然想要命名导入。
- en: With those things done, we should be able to run the application and navigate
    to the speakers route. If you have not added a link to the speakers route, now
    would be a good time so that you don't have to type the route directly in the
    URL every time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们应该能够运行应用程序并导航到演讲者路由。如果你还没有添加演讲者路由的链接，现在是一个好时机，这样你就不必每次都直接在 URL 中输入路由了。
- en: Once you arrive at the speakers route, you should see that there are no speakers
    and we receive our message. We need some way to populate the speakers so that
    we can test the listing. We will cover a way to populate speakers in the next
    section. For now, in the mock API modify the constructor to contain a couple of
    speakers. Modifying the service in this way will cause a few tests to break, so
    after you have visually verified that everything is looking good, be sure to remove
    or at least comment out the code you added.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达演讲者路由时，你应该看到没有演讲者，并且我们收到了我们的消息。我们需要某种方式来填充演讲者，这样我们就可以测试列表。我们将在下一节中介绍填充演讲者的方法。现在，在模拟API中修改构造函数以包含几个演讲者。以这种方式修改服务将导致一些测试失败，所以在你视觉上验证了一切看起来都很好之后，务必删除或至少注释掉你添加的代码。
- en: Speaker detail
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演讲者详情
- en: Now that we have our speakers listing nicely, it would be nice to be able to
    view a bit more information about a specific speaker. Let's look at the tests
    involved in retrieving and viewing a speakers-detailed information.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了演讲者列表，能够查看更多关于特定演讲者的信息会很好。让我们看看涉及检索和查看演讲者详细信息的测试。
- en: Adding to the mock API Service
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到模拟API服务
- en: In the mock API, we need to add a call to get the details for a specific speaker.
    We can assume that the speaker has an ID field that we can use to gather that
    information. As usual, let's start our tests with a simple exists check. We will
    need to add a new describe inside the `After Initialization` describe for getting
    a speaker by ID.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟API中，我们需要添加一个调用以获取特定演讲者的详细信息。我们可以假设演讲者有一个ID字段，我们可以用它来收集这些信息。像往常一样，让我们从简单的存在性检查开始我们的测试。我们需要在`After
    Initialization`描述中添加一个新的describe来通过ID获取演讲者。
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To make this test pass, we need to add a method to the mock API.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们需要向模拟API添加一个方法。
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, we can write a test to verify the functionality we expect when a matching
    speaker cannot be found. The functionality we want in this case is for a `SPEAKER_NOT_FOUND`
    message to be shown once we get to the user interface. At the mock API level,
    we could assume that a 404 will be sent from the server. We can respond from the
    mock API with an error containing the `SPEAKER_NOT_FOUND` type. This is similar
    to the way an action would be used.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个测试来验证当找不到匹配的演讲者时我们期望的功能。在这种情况下，我们想要的功能是在我们到达用户界面时显示`SPEAKER_NOT_FOUND`消息。在模拟API级别，我们可以假设服务器会发送一个404。我们可以从模拟API中响应一个包含`SPEAKER_NOT_FOUND`类型的错误。这类似于使用操作的方式。
- en: Let’s create another describe for our speaker not found scenario.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为演讲者未找到的场景创建另一个describe。
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You may have noticed that we snuck in `errorTypes`. The `errorTypes` are in
    their own folder, but build exactly like `actionTypes`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们悄悄地加入了`errorTypes`。`errorTypes`有自己的文件夹，但构建方式与`actionTypes`完全相同。
- en: To make this test pass, we must add a rejected promise to our mock API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们必须向我们的模拟API添加一个拒绝的承诺。
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We don't have any tests that enforce a positive result from this method, so
    we can reject every time for now.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有测试来强制该方法返回一个积极的结果，所以现在我们可以每次都拒绝。
- en: That brings us to our next test. What happens if the speaker is found? Ideally,
    the speaker and all the speakers details would be delivered back to the caller.
    Let's write that test now.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们到了下一个测试。如果找到演讲者会发生什么？理想情况下，演讲者和所有演讲者详情都应该返回给调用者。现在让我们编写这个测试。
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: To pass this test we will have to add some logic to the production code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过这个测试，我们将在生产代码中添加一些逻辑。
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To make the test pass, we need to first check to see if the speaker exists.
    If the speaker does exist, we return that speaker. If the speaker does not exist,
    we reject the promise and provide our error result.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要使测试通过，我们首先需要检查演讲者是否存在。如果演讲者存在，我们返回该演讲者。如果演讲者不存在，我们拒绝承诺并提供我们的错误结果。
- en: The Get Speaker action
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取演讲者操作
- en: We now have a mock API to call that behaves the way we want it to. Next on our
    list is creating the actions that will handle the results from our mock API. For
    the process of getting a speaker, we will need two actions. One of the actions
    will notify the application about a successful find and provide the found speaker
    to the reducers. The other action will notify the application about the failure
    to find the requested speaker.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个模拟API可以调用，它的行为方式符合我们的预期。接下来在我们的列表中是创建将处理模拟API结果的操作。对于获取演讲者的过程，我们需要两个操作。其中一个操作将通知应用程序成功找到并提供了找到的演讲者给reducers。另一个操作将通知应用程序请求的演讲者找不到。
- en: Let's write a test to confirm its existence. This test should be inside the
    synchronous tests section of the speaker actions tests. We will also want to create
    a new describe for the get speaker success action.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试来确认其存在。这个测试应该在演讲者动作测试的同步测试部分中。我们还将为获取演讲者成功动作创建一个新的describe。
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To make this test pass, we just create the action function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们只需创建动作函数。
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now we need to verify the return value of the action. Just like our get all
    speakers success action, the get speaker success action will receive the found
    speaker and return an object containing a type and the speaker data. Let's write
    the test for that now.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要验证动作的返回值。就像我们的获取所有演讲者的成功动作一样，获取演讲者成功动作将接收找到的演讲者并返回一个包含类型和演讲者数据的对象。现在让我们为这个动作编写测试。
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This test is fairly straightforward so let's look at the production code to
    pass it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试相当直接，所以让我们看看生产代码来通过它。
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Again, this code is straightforward. Next, let's handle the failure action.
    We will need to create a new describe for this test as well.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这段代码很简单。接下来，让我们处理失败动作。我们还需要为这个测试创建一个新的describe。
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Nothing new here, you should be starting to get a feel for the flow by now.
    Let's keep going and make this test pass.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的内容，你现在应该开始对流程有感觉了。让我们继续并使这个测试通过。
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The data we should be getting back for a failure to retrieve a speaker should
    be the `SPEAKER_NOT_FOUND` error type. In our next test, we will receive that
    error and create the action type from it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索演讲者失败时，我们应该得到的是`SPEAKER_NOT_FOUND`错误类型。在我们的下一个测试中，我们将收到这个错误并从中创建动作类型。
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Making this test pass is very similar to the implementation for the other synchronous
    actions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过的过程与其它同步动作的实现非常相似。
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Looking at the code, there is one important difference. This code doesn't have
    speaker data. The reason is because this action will need to be handled by a different
    reducer, an error reducer. We will create the error reducer and error component
    shortly. But first, we need to create the asynchronous action that will make the
    call to the mock API.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 看着代码，有一个重要的区别。这段代码没有演讲者数据。原因是这个动作需要由不同的reducer，即错误reducer来处理。我们将很快创建错误reducer和错误组件。但首先，我们需要创建一个异步动作，该动作将调用模拟API。
- en: In testing the asynchronous action to get speakers, we should start with the
    failure case. In this case, the failure case is `GET_SPEAKER_FAILURE`. Here is
    a test to ensure the correct secondary action is triggered.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试获取演讲者的异步动作时，我们应该从失败情况开始。在这种情况下，失败情况是`GET_SPEAKER_FAILURE`。这里有一个测试来确保触发了正确的次要动作。
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The code to make this test pass is similar to the code we have for getting all
    the speakers.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过的代码与我们获取所有演讲者的代码相似。
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, we have called the mock API and we expect it to reject the promise, resulting
    in the dispatching of the `getSpeakerFailure` action.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经调用了模拟API，并期望它拒绝承诺，从而导致`getSpeakerFailure`动作的派发。
- en: Our next test is the successful retrieval of a specific speaker. We do have
    a problem though. You may have noticed that we are creating a new `MockSpeakerService`
    for each asynchronous action. This is problematic because it prevents us from
    pre-populating our mock API with values for the test. Later in the development
    of this application, the back-end will be ready and we will want to point our
    front-end code to a real back-end. We can't do that as long as we are directly
    referencing and creating a mock API service.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的测试是成功检索一个特定的演讲者。不过，我们确实有一个问题。你可能已经注意到，我们为每个异步动作创建一个新的`MockSpeakerService`。这是有问题的，因为它阻止我们预先在我们的模拟API中填充测试值。在应用程序的开发后期，后端将准备就绪，我们希望将前端代码指向一个真实后端。只要我们直接引用并创建模拟API服务，我们就无法做到这一点。
- en: There are many solutions for the problem that we are facing. We will explore
    making a factory to decide what back-end to provide for us. A factory will also
    allow us to treat the mock API as a singleton. Treating the service as a singleton
    will allow us to prepopulate the service as part of the test setup.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的问题有很多解决方案。我们将探索创建一个工厂来决定为我们提供哪个后端。工厂还将允许我们将模拟API作为单例处理。将服务作为单例处理将允许我们在测试设置中预先填充服务。
- en: In the services folder, let's create a new set of tests for creating the factory
    class and functionality.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务文件夹中，让我们为创建工厂类和功能创建一组新的测试。
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: All we need to make this test pass is a class definition.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一个类就能使这个测试通过。
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we want a method to create a speaker service. Add a new describe to the
    factory tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个创建演讲者服务的方法。在工厂测试中添加一个新的describe。
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Notice the way we are using the factory, we are not initializing it. We want
    the factory to be a class with static methods. Having static functions will give
    us the singleton ability we want.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用工厂的方式，我们并没有初始化它。我们希望工厂成为一个具有静态方法的类。拥有静态函数将赋予我们想要的单例能力。
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Next up, we want to ensure that the `createSpeakerService` factory method will
    provide us with an instance of the mock API.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要确保`createSpeakerService`工厂方法能为我们提供一个模拟API的实例。
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Making this test pass is easy, just return a new mock speaker service from the
    factory method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过很简单，只需从工厂方法返回一个新的模拟演讲者服务。
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This isn't a singleton though. So, we still have some more work to do here.
    Let's write one more test in the factory before we swap out all the service calls
    in the application for factory calls. To verify that something is a singleton,
    we have to make sure it is the same throughout the application. We can do that
    by doing reference comparisons on successive calls. Another option is to create
    the speaker service, add a speaker to it, create a new speaker service, and try
    to pull the speaker from the second service. If we have done things correctly,
    the second option is the most thorough. We will do the first option here, but
    it would be a good exercise to do the second option on your own.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个单例。因此，我们在这里还有一些更多的工作要做。在我们替换应用中所有服务调用为工厂调用之前，让我们在工厂中再写一个测试。为了验证某个东西是单例，我们必须确保它在整个应用中都是相同的。我们可以通过在连续调用上进行引用比较来实现这一点。另一个选项是创建演讲者服务，向其中添加一个演讲者，创建一个新的演讲者服务，并尝试从第二个服务中拉取演讲者。如果我们正确地做了事情，第二个选项是最彻底的。我们将在这里执行第一个选项，但自己尝试第二个选项将是一个很好的练习。
- en: '[PRE78]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To pass the test, we must ensure that the same instance of the speaker service
    is returned every time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过测试，我们必须确保每次都返回相同的演讲者服务实例。
- en: '[PRE79]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The factory will now return the current value or create a new speaker service
    if the current value is `null`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，工厂将返回当前值，如果当前值为`null`，则创建一个新的演讲者服务。
- en: The next step is to go to each place where we are directly instantiating a mock
    speaker service and swap it out with a factory call. We will leave that as an
    exercise for you to do, but know that going forward we will assume that it has
    been done.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是前往每个直接实例化模拟演讲者服务的地方，并用工厂调用替换它。我们将把这个作为你的练习，但要知道，向前推进时，我们将假设它已经被完成。
- en: Now that we have the factory swapped out and it is generating a singleton, we
    can write the next action test. We want to test a successful retrieval of a speaker.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经替换了工厂，并且它正在生成单例，我们可以编写下一个动作测试。我们想要测试成功检索一个演讲者。
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: There is a lot going on in this test; let's walk through it. First in the arrange,
    we create a speaker object to be placed in the service, and used for the assertions.
    Next, still in the arrange, we create and configure the mock store. Lastly, in
    the arrange, we create the speaker service and we create our test speaker using
    the service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试中有很多事情在进行；让我们一步步来看。首先在arrange阶段，我们创建一个演讲者对象，将其放入服务中，并用于断言。接下来，仍然在arrange阶段，我们创建并配置模拟存储。最后，在arrange阶段，我们创建演讲者服务，并使用该服务创建我们的测试演讲者。
- en: Next, in the act, we dispatch a call to get the test speaker. Remember, this
    call is asynchronous. So, we must subscribe to then.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，在act中，我们派发一个调用以获取测试演讲者。记住，这个调用是异步的。因此，我们必须订阅then。
- en: When the promise is resolved, we store the actions in a variable and assert
    that the first action has the correct type and payload.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺解决时，我们将动作存储在一个变量中，并断言第一个动作具有正确的类型和有效载荷。
- en: Now to make this test pass we need to make some modifications to the `getById`
    method on the service.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了让这个测试通过，我们需要对服务上的`getById`方法进行一些修改。
- en: '[PRE81]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: All we have really done here is add a then to handle the resolving of the promise.
    We now have, for all current intents and purposes, a working speaker service.
    Let's move on to creating the reducers for handling the get speaker actions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正做的只是添加了一个then来处理承诺的解析。现在，从所有当前目的来看，我们有一个工作的演讲者服务。让我们继续创建处理获取演讲者动作的reducers。
- en: The Get Speaker reducer
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取演讲者reducer
- en: To handle the actions related to getting a speaker, we must create two reducers.
    The first reducer is extremely similar to the reducer we made for the get speakers
    actions. The second is going to need to be slightly different and is for handling
    the error case.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理与获取演讲者相关的动作，我们必须创建两个还原器。第一个还原器与为我们创建的获取演讲者动作的还原器非常相似。第二个将需要稍微不同，用于处理错误情况。
- en: Let's begin with the simplest of the two and create the speaker reducer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个中最简单的一个开始，创建演讲者还原器。
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Our typical existence test is easily passed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的典型存在测试很容易通过。
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The next test ensures that the reducer updates state properly, and will close
    out the tests needed for this reducer.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试确保还原器正确更新状态，并将结束这个还原器所需的测试。
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The changes from this test are the inputs to the reducer, and the output of
    a state. Let's make this test pass by modeling our reducer after the speakers
    reducer.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的变化是还原器的输入和状态的输出。让我们通过模仿演讲者还原器来使这个测试通过。
- en: '[PRE85]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Similar to the speakers reducer, this reducer simply checks the action type
    for `GET_SPEAKER_SUCCESS` and, if found, returns the speaker attached to the action
    as the new state. Otherwise, we just return the state object we received.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与演讲者还原器类似，这个还原器只是检查动作类型是否为`GET_SPEAKER_SUCCESS`，如果找到，则返回动作附加的演讲者作为新状态。否则，我们只返回我们收到的状态对象。
- en: Next up, we need an error reducer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个错误还原器。
- en: '[PRE86]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Passing this test is just as easy as all the other existence tests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个测试就像通过所有其他存在测试一样简单。
- en: '[PRE87]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The error reducer will have some interesting functionality. In the event that
    an error is received, we want multiple errors to stack up so we won't be replacing
    the state. Instead, we will be cloning and adding to the state. However, when
    an action is received that is not an error we will want to clear the errors and
    allow normal program execution to continue. We will also want to ignore duplicate
    errors. First, we will handle the error we know about.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 错误还原器将具有一些有趣的功能。在接收到错误的情况下，我们希望错误堆叠起来，这样我们就不会替换状态。相反，我们将克隆并添加到状态中。然而，当我们接收到不是错误的动作时，我们希望清除错误并允许正常程序执行继续。我们还想忽略重复的错误。首先，我们将处理我们已知的错误。
- en: '[PRE88]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Our test is slightly different from the previous reducer test. The main difference
    is that we are wrapping our expected value in an array. We are doing this to meet
    the need for having multiple errors potentially stack up and display for the user.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试与之前的还原器测试略有不同。主要区别在于我们正在将预期的值包裹在一个数组中。我们这样做是为了满足可能堆叠多个错误并显示给用户的需求。
- en: To make this test pass we follow the familiar reducer pattern we have been using.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们遵循熟悉的还原器模式，我们已经在使用。
- en: '[PRE89]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: For the same reasons as stated previously, notice how we use the rest of the
    parameter syntax to spread the existing state into a new array, effectively cloning
    state.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前所述的原因相同，注意我们如何使用其余的参数语法将现有状态展开到新数组中，从而有效地克隆状态。
- en: We have two more tests for the error reducer; the first is to ensure duplicate
    errors are not added. The second test will be to clear the errors when a non-error
    action is called.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个针对错误还原器的测试；第一个是确保不添加重复的错误。第二个测试将在调用非错误动作时清除错误。
- en: '[PRE90]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the test, to set the condition of having a prepopulated state, all we had
    to do was modify the `initialState` parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，为了设置具有预填充状态的条件，我们只需修改`initialState`参数。
- en: '[PRE91]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: All we must do to make this test pass is make sure that the error type is not
    already present in the state array. There are many ways to do this; we have chosen
    to use the `every` function as a check that none of the existing errors match.
    It is likely that this method is not extremely performant, but there should only
    be a couple errors at most so it shouldn't be a performance issue.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们只需确保错误类型尚未存在于状态数组中。有许多方法可以做到这一点；我们选择使用`every`函数作为一个检查，以确保现有的错误中没有匹配项。这种方法可能不是非常高效，但由于错误数量最多只有几个，因此不应该成为性能问题。
- en: The next test is to clear the error state when a non-error is received.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是在接收到非错误时清除错误状态。
- en: '[PRE92]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Making this test pass is exceedingly simple. All we have to do is replace the
    default functionality where the existing state is returned.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过极其简单。我们只需替换默认功能，即返回现有状态。
- en: '[PRE93]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The Speaker Detail component
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说话者详情组件
- en: We are now ready to create our `SpeakerDetailPage`. There isn't much to this
    component. It will need to be another container component so that it can use the
    get speaker action. Because it is a container component, we will not be placing
    any markup directly into this component. The good news for us is that it means
    our tests will be short and simple.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的`SpeakerDetailPage`。这个组件没有太多内容。它将需要成为一个容器组件，以便它可以使用获取演讲者动作。因为它是一个容器组件，所以我们将不会在这个组件中直接放置任何标记。对我们来说，好消息是这意味着我们的测试将会简短且简单。
- en: To get the tests started, create an existence test.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动测试，创建一个存在性测试。
- en: '[PRE94]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Create a `SpeakerDetailPage` file and add a component to it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SpeakerDetailPage`文件，并向其中添加一个组件。
- en: '[PRE95]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The next thing we want to test, the only other thing we can test without directly
    specifying the design, is that the model is received and somehow makes it to the
    screen. We only need to test one property of the model for now. We will write
    a test that shows that the first name of the speaker is displayed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想要测试的，在没有直接指定设计的情况下唯一可以测试的另一件事是，模型被接收并且以某种方式显示在屏幕上。现在我们只需要测试模型的一个属性。我们将编写一个测试来显示演讲者的名字被显示出来。
- en: '[PRE96]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If you are paying attention, you might have wondered why the get speaker action
    is just returning an empty resolved promise. We are not attached to Redux, so
    kicking off the action doesn't trigger a reducer, which doesn't update the store
    and doesn't trigger a refresh of the component state. We still want to complete
    the contract of the component in the test setup though and this component will
    call that function. We could leave this line out, but we will be adding it back
    as soon as we wire up Redux.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，你可能想知道为什么获取演讲者动作只是返回一个空的已解析的承诺。我们并没有绑定到Redux，所以启动动作不会触发reducer，这不会更新store，也不会触发组件状态的刷新。尽管如此，我们仍然想在测试设置中完成组件的合约，这个组件将调用那个函数。我们可以省略这一行，但一旦我们连接了Redux，我们就会将其添加回来。
- en: To make the test pass, we will need to make a couple of simple changes in the
    `SpeakerDetailPage` component, and create a whole new component. Following are
    the changes to this component, but it will be an exercise for you to create the
    next component. It is only for display and we are testing that it gets populated
    here so all you have to do is write the presentational component.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要在`SpeakerDetailPage`组件中做一些简单的修改，并创建一个全新的组件。以下是该组件的修改，但创建下一个组件将是你的练习。它仅用于显示，我们正在测试它是否在这里被填充，所以你只需要编写一个表现组件。
- en: '[PRE97]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The previous code will make the test pass, but now we have to connect the component
    to Redux. We will be adding a call to the `getSpeaker` action, binding to the
    `componentWillReceiveProps` life cycle event, and mapping props and dispatch using
    the connect function. Here is the final `SpeakerDetailPage` component.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将使测试通过，但现在我们必须将组件连接到Redux。我们将添加对`getSpeaker`动作的调用，绑定到`componentWillReceiveProps`生命周期事件，并使用connect函数映射属性和分发。以下是最终的`SpeakerDetailPage`组件。
- en: '[PRE98]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now that everything passes the tests, we have one last thing we need to do before
    we can properly develop further. Earlier we replaced the mock API with a call
    to a factory. We did this so that the tests could affect the state of the mock
    API in the actions. That same modification has made it possible to configure a
    starting point for our application. In the `index.js` file, add the following
    code after the store has been configured; now, when you run the app, you will
    have speakers available to test the UI with.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切测试都通过了，我们还需要完成最后一件事，才能正确地进一步开发。之前我们用对工厂的调用替换了模拟API。我们这样做是为了让测试能够影响动作中模拟API的状态。同样的修改使得我们可以为我们的应用程序配置一个起点。在`index.js`文件中，在配置完store之后添加以下代码；现在，当你运行应用程序时，你将会有可用的演讲者来测试UI。
- en: '[PRE99]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That does it for unit-testing a React application, for now. We still don't have
    an example of testing some kind of input. Try to test and implement a `CreateSpeakerPage`.
    What would you need to do from a React standpoint? What would Redux cause you
    to do? In this chapter, we have attacked the React components as if they were
    components. For display-only components, which is what these have been, this approach
    is probably better. However, for a component with some real functionality you
    might want to try testing the functionality as a plain old JavaScript class before
    even attaching it to React. We also left quite a bit of work for you to do in
    this chapter. Don't be shy about looking at the source related to this chapter
    if you get lost or need a hint while you are filling in the blanks to complete
    the code.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们已经完成了对React应用的单元测试。我们还没有一个测试某种输入的例子。尝试测试并实现一个`CreateSpeakerPage`。从React的角度来看，你需要做些什么？Redux会要求你做些什么？在本章中，我们像对待组件一样对待了React组件。对于仅用于显示的组件，这正是这些组件所做的工作，这种方法可能是更好的。然而，对于具有一些实际功能的组件，你可能希望在将其附加到React之前，先尝试以普通的JavaScript类测试其功能。我们也在本章中为你留下了相当多的工作要做。如果你在填写空白以完成代码时迷失方向或需要提示，不要害羞地去查看与本章相关的源代码。
