- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: The One with the Operating System Tango
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统探戈篇
- en: '*Working with Operating* *System Services*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*与操作系统服务一起工作*'
- en: Computers are complex machines. They can have many different forms, different
    peripherals, and different functions. Yet, a lot of different machines can run
    the same software. As long as the hardware fits in a pretty broad set of boundaries
    (for instance, running a specific CPU architecture), your software does not care
    what the underlying machine looks like.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是复杂的机器。它们可以有多种不同的形式，不同的外围设备，以及不同的功能。然而，许多不同的机器可以运行相同的软件。只要硬件符合相当广泛的边界（例如，运行特定的CPU架构），你的软件就不关心底层机器的外观。
- en: The reason this all works is that we have abstraction. You hardly ever deal
    with the actual hardware. There are always layers of software to go through, each
    layer adding a level of abstraction. That sounds complicated, but it is a good
    thing. Without this, we would have to rewrite our software for all possible combinations
    of hardware. Imagine a user swapping out an old-style hard drive with spinning
    discs for a more modern, faster SSD. Then, they have to come to you so you can
    recompile your system to accommodate that. I am sure you do not want to spend
    your time on that if possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切之所以能够工作，是因为我们有抽象。你几乎从不直接处理实际的硬件。总有一层层的软件需要通过，每一层都增加了一层抽象。这听起来很复杂，但这是好事。没有这个，我们就必须为所有可能的硬件组合重写我们的软件。想象一下，用户用一种带有旋转磁盘的老式硬盘驱动器换成了更现代、更快的SSD。然后，他们必须来找你，以便你可以重新编译系统以适应这种情况。我相信，如果可能的话，你肯定不想在这方面浪费时间。
- en: The lowest level of software, the one running closest to the hardware, is the
    **Basic Input/Output System** (**BIOS**). This system interfaces between the actual
    hardware and the levels above. The BIOS knows how to access a particular area
    on a storage medium. It knows how to reach a network card and get the bits and
    bytes to the levels on top of it. It is the gatekeeper to the actual hardware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的最底层，即最接近硬件运行的，是**基本输入/输出系统**（**BIOS**）。这个系统在实际硬件和其上层级之间进行接口。BIOS知道如何访问存储介质上的特定区域。它知道如何到达网络卡并获取位和字节传输到其上层的层级。它是实际硬件的看门人。
- en: In short, the next level of abstraction is the **operating system** (**OS**).
    These days, the difference between the OS and user programs is not very well defined
    anymore. Windows, for instance, is an OS. however, it also comes with many user
    programs, such as a photo viewer and a calculator. However, the OS does come with
    many utilities we, as systems programmers, can use. These utilities or systems
    in the OS help us do tasks without worrying about the little details while still
    being able to run on many different machines. This chapter explains some of the
    more handy utilities Windows offers us.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，下一层的抽象是**操作系统**（**OS**）。如今，操作系统和用户程序之间的区别已经不再非常明确了。例如，Windows是一个操作系统。然而，它也附带了许多用户程序，例如图片查看器和计算器。然而，操作系统确实附带了许多我们作为系统程序员可以使用的实用程序。这些实用程序或操作系统中的系统帮助我们完成任务，而无需担心细节，同时仍然能够在许多不同的机器上运行。本章将解释Windows为我们提供的一些更实用的实用程序。
- en: 'This chapter looks at some of the services Windows makes available to us. These
    are the items we will learn about in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨Windows为我们提供的一些服务。以下是本章我们将学习的内容：
- en: The Windows Registry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows注册表
- en: Worker Services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作者服务
- en: Windows Management Instrumentation (WMI)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows管理规范（WMI）
- en: Registry and WMI – risks and how to avoid them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表和WMI – 风险及其避免方法
- en: We also will look at the risks involved and how to minimize them. After all,
    we are probing deep into Windows, and when things go wrong, they usually go wrong
    very badly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨涉及的风险以及如何最小化它们。毕竟，我们正在深入Windows，当事情出错时，它们通常出错得很严重。
- en: Let’s begin with the Registry first!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从注册表开始吧！
- en: Technical requirement
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find all the sources and complete samples for all the things we discuss
    here in the GitHub repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库中找到我们讨论的所有内容的所有源代码和完整示例：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07)。
- en: If you, however, want to build the samples from scratch, you need to install
    some NuGet packages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从头开始构建示例，你需要安装一些NuGet包。
- en: For the WMI samples, you need to install the `System.Management` package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于WMI示例，你需要安装`System.Management`包。
- en: The Windows Registry
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows注册表
- en: Almost all systems have settings. These settings persist; they are still there
    after a system shutdown, reboot, or whatever reason. The contents of these settings
    vary; they could be anything your system needs. It could be a connection string
    to a database, a location where you can store files, the font used to generate
    reports, and so on. Anything you cannot know in advance while writing the software
    or that a user or system administrator might want to change should be in a separate
    location from your system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有系统都有设置。这些设置是持久的；系统关闭、重启或任何原因后它们仍然存在。这些设置的内容各不相同；它们可以是系统需要的任何内容。这可能是一个数据库的连接字符串，一个可以存储文件的地点，用于生成报告的字体，等等。任何在编写软件时无法预先知道的内容，或者用户或系统管理员可能想要更改的内容，都应该放在系统之外的一个单独位置。
- en: In the past, Windows applications and systems used `[` and `]` characters. The
    key/value data is a line such as `mykey=myvalue`. Each section or data line is
    on a separate line, and that is it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，Windows应用程序和系统使用`[`和`]`字符。键/值数据是一行，例如`mykey=myvalue`。每个部分或数据行都在单独的一行上，就是这样。
- en: We placed the INI file in a known location, usually in the same directory as
    the main application files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将INI文件放置在已知的位置，通常在主应用程序文件所在的同一目录中。
- en: These days, we do not use INI files that much anymore. The .NET BCL does not
    have classes for them, although third-party NuGet packages can help you if you
    decide to go with INI files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，我们不再那么频繁地使用INI文件了。.NET BCL没有为它们提供类，尽管如果你决定使用INI文件，第三方NuGet包可以帮助你。
- en: 'The most obvious alternative for the INI file is the settings file. The settings
    file is usually in a JSON format, making it easy to work with. You can find them
    in the same place we used to put INI files: we usually place them alongside the
    main application.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: INI文件最明显的替代品是设置文件。设置文件通常以JSON格式存储，这使得它易于处理。你可以在我们曾经放置INI文件的地方找到它们：我们通常将它们放置在主应用程序旁边。
- en: JSON allows for a much more complex structure with a hierarchy in your settings.
    JSON is still much readable for humans, just as the INI files were. That might
    be useful if a system administrator needs to change the settings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JSON允许在设置中有一个更复杂的结构，具有层次结构。JSON对于人类来说仍然很容易阅读，就像INI文件一样。这可能对系统管理员需要更改设置时很有用。
- en: However, a JSON file is not always the best way to store settings. There are
    downsides to this approach. One of the alternatives to the file-based settings
    is using the Windows Registry. Allow me to explain what that is and how to use
    that first, and then I will outline both options’ pros and cons.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JSON文件并不总是存储设置的最好方式。这种方法有一些缺点。基于文件的设置的替代方案之一是使用Windows注册表。让我先解释一下这是什么以及如何使用它，然后我将概述两种选项的优缺点。
- en: What is the Windows Registry?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Windows注册表？
- en: The Registry is a hierarchical database in Windows where systems can read and
    write all sorts of data. The data itself is a collection of key/value pairs. The
    keys are strings; the values can be strings, numeric, or binary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表是Windows中的一个分层数据库，系统可以读取和写入各种数据。数据本身是一系列键/值对。键是字符串；值可以是字符串、数字或二进制。
- en: Binary data in the Windows Registry
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Windows注册表中的二进制数据
- en: Yes, you can store binary data in the Registry. However, that doesn’t mean it
    is a good idea. The theoretical limit is 1 MB per value, but I vigorously recommend
    not doing that. If you only have a couple of bytes, then storing and reading binary
    data is a great idea, but if you want to store larger amounts of data, you are
    better off using a different mechanism. Having large amounts of binary data in
    your Registry might slow down the complete machine, not just your application.
    Microsoft recommends using a maximum of 1 or 2 KB per entry for your binary data.
    Above that, you should move your data away to another location.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以在注册表中存储二进制数据。然而，这并不意味着这是一个好主意。理论上的限制是每个值1 MB，但我强烈建议不要这样做。如果你只有几个字节，那么存储和读取二进制数据是一个很好的主意，但如果你想要存储大量数据，你最好使用不同的机制。在注册表中存储大量二进制数据可能会减慢整个机器的速度，而不仅仅是你的应用程序。微软建议每个条目使用最多1或2
    KB的二进制数据。超过这个量，你应该将你的数据移动到另一个位置。
- en: 'The Registry is organized in a tree-like structure. Each entry can be a key,
    a subkey, or an entry. The entry is the lowest level in the Registry: an entry
    cannot have a sub-entry.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表以树状结构组织。每个条目可以是键、子键或条目。条目是注册表中的最低级别：条目不能有子条目。
- en: Maybe I can clarify this by showing you a bit of the Registry on my machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过向您展示我机器上的一些注册表内容来澄清这一点。
- en: '![](img/B20924_08_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20924_08_01.jpg)'
- en: 'Figure 7.1: The Windows Registry'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：Windows注册表
- en: '*Figure 7**.1* shows a small part of the Windows Registry on my machine. On
    the left-hand side, you see the tree structure with all the keys; on the right-hand
    side are the contents of the currently selected key. This image shows the settings
    for the colors used in the Control Panel. These are the default settings; you
    can have different settings per user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7**.1* 展示了我机器上Windows注册表的一部分。在左侧，您可以看到包含所有键的树结构；在右侧是当前选中键的内容。此图像显示了控制面板中使用的颜色设置。这些是默认设置；您可以为每个用户设置不同的设置。'
- en: 'That is one of the big advantages of the Registry: you can store settings per
    user and have the system figure out which to use when. You do not have to deal
    with that.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是注册表的一个大优点：您可以按用户存储设置，并且系统会在需要时确定使用哪个设置。您不必处理这个问题。
- en: There are 5 top-level keys. I explain these in the following table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有5个顶级键。以下表格中解释了这些键。
- en: '| **Key** | **Description** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **描述** |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `HKEY_CLASSES_ROOT` | This mainly connects files to applications: for instance,
    what application should Windows start if you double-click a file in Explorer?
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `HKEY_CLASSES_ROOT` | 这主要将文件连接到应用程序：例如，如果您在资源管理器中双击文件，Windows应该启动哪个应用程序？
    |'
- en: '| `HKEY_CURRENT_CONFIG` | This contains information about the hardware profile
    used by the local computer at startup. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `HKEY_CURRENT_CONFIG` | 这包含有关本地计算机启动时使用的硬件配置信息。 |'
- en: '| `HKEY_CURRENT_USER` | All information about the current users and their preferences
    is stored here. If you change the theme of Windows, this is where it ends up.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `HKEY_CURRENT_USER` | 所有关于当前用户及其首选项的信息都存储在这里。如果您更改Windows的主题，它最终会在这里结束。 |'
- en: '| `HKEY_LOCAL_MACHINE` | Contains configuration information particular to this
    computer, as shared by all users. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `HKEY_LOCAL_MACHINE` | 包含特定于此计算机的配置信息，由所有用户共享。 |'
- en: '| `HKEY_USERS` | Here, you will find all user profiles known on this computer.
    For each user, their preferences and info are stored. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `HKEY_USERS` | 在这里，您将找到此计算机上所有已知的用户配置文件。对于每个用户，他们的首选项和信息均存储在此处。 |'
- en: 'Table 7.1: Top-level Registry keys'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：顶级注册表键
- en: I am not being truthful here. Some top-level keys I just mentioned are handy
    shortcuts to other keys. For instance, `HKEY_CURRENT_USER` maps the currently
    logged-in user in `HKEY_USERS`, and `HKEY_CLASSES_ROOT` is a subkey of `HKEY_LOCAL_MACHINE\Software`.
    But these root keys are there to help you. For instance, instead of looking up
    the ID of the current user and then finding that entry in `HKEY_USERS`, you can
    open the `HKEY_CURRENT_USER` key and be assured you get the correct data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里并不诚实。我刚才提到的某些顶级键是其他键的便捷快捷方式。例如，`HKEY_CURRENT_USER` 将当前登录用户映射到 `HKEY_USERS`
    中的 `HKEY_CURRENT_USER`，而 `HKEY_CLASSES_ROOT` 是 `HKEY_LOCAL_MACHINE\Software` 的子键。但这些根键是为了帮助您。例如，您不必查找当前用户的ID，然后在
    `HKEY_USERS` 中找到该条目，而是可以直接打开 `HKEY_CURRENT_USER` 键，并确信您会得到正确的数据。
- en: Each top-level key can have sub-keys. Each sub-key can have its own sub-keys.
    In total, you can go to 512 levels deep. Each top-level and sub-level key can
    have one or more key/value data pairs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶级键都可以有子键。每个子键都可以有自己的子键。总共可以深入到512层。每个顶级和子级键都可以有一个或多个键/值数据对。
- en: This data has a data type. The following table shows the available data types.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据有一个数据类型。以下表格显示了可用的数据类型。
- en: '| **Win** **32 type** | **C# type** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **Win** **32类型** | **C#类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `REG_NONE` | `None` | No data type |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `REG_NONE` | `None` | 没有数据类型 |'
- en: '| `REG_SZ` | `String` | A null-terminated string |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `REG_SZ` | `String` | 一个以空字符终止的字符串 |'
- en: '| `REG_EXPAND_SZ` | `ExpandString` | A string containing unexpanded references
    to environment variables |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `REG_EXPAND_SZ` | `ExpandString` | 包含未展开的环境变量引用的字符串 |'
- en: '| `REG_BINARY` | `Binary` | Binary data in any form |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `REG_BINARY` | `Binary` | 任何形式的二进制数据 |'
- en: '| `REG_DWORD` | `Dword` | A 32-bit binary number |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `REG_DWORD` | `Dword` | 一个32位的二进制数 |'
- en: '| `REG_MULTI_SZ` | `MultiString` | An array of null-terminated strings, terminated
    by a double null character |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `REG_MULTI_SZ` | `MultiString` | 一个以空字符终止的字符串数组，以双空字符终止 |'
- en: '| `REG_QWORD` | `Qword` | A 64-bit binary number |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `REG_QWORD` | `Qword` | 一个64位的二进制数 |'
- en: '| `-` | `Unknown` | An unsupported registry data type |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `Unknown` | 一个不受支持的注册表数据类型 |'
- en: 'Table 7.2: .NET Registry data types'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '表 7.2: .NET 注册表数据类型'
- en: '*Table 7.2*, however, could use a little explanation.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 7.2* 然而，可能需要一点解释。'
- en: The Win32 API supports many data types. However, the CLR has fewer of them available.
    The ones we can use are part of an enum called `RegistryValueKind`. These enums
    defined are the ones I list in the C# type column.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API 支持许多数据类型。然而，CLR 可用的类型较少。我们可以使用的类型是 `RegistryValueKind` 枚举的一部分。这些枚举定义的是我在
    C# 类型列中列出的那些。
- en: The types that are provided should be enough for you. However, sometimes, you
    need to use specialized ones. For instance, the Win32 API supports a datatype
    named `REG_RESOURCE_LIST`. You use this type to store resource-related data. Unfortunately,
    the C# enum does not provide an equivalent for that. In those cases, you can use
    the `Unknown` type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的类型应该足够你使用。然而，有时你需要使用特定的类型。例如，Win32 API 支持一个名为 `REG_RESOURCE_LIST` 的数据类型。你使用这种类型来存储资源相关的数据。不幸的是，C#
    枚举没有提供等效的类型。在这些情况下，你可以使用 `Unknown` 类型。
- en: '`ExpandString` can be pretty valuable. If you want to store information about
    the location of a file, you can use a macro such as `%PATH%`. This macro is the
    current path in your system. However, the path is stored like that string: `%PATH%`.
    If you specify `ExpandString` as the type, the OS translates that string into
    the actual value if you read that data.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExpandString` 可以非常有价值。如果你想存储有关文件位置的详细信息，你可以使用一个宏，例如 `%PATH%`。这个宏是系统中的当前路径。然而，路径是以这样的字符串存储的：`%PATH%`。如果你指定
    `ExpandString` 作为类型，操作系统会在读取数据时将那个字符串转换为实际值。'
- en: But honestly, you probably use `String`, `Binary`, and `DWord` the most. The
    others are there in case you need them, though.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但说实话，你可能最常使用 `String`、`Binary` 和 `DWord`。其他的虽然也有，但只是以防万一需要它们。
- en: How to access and store data with the Windows Registry
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 Windows 注册表访问和存储数据
- en: When writing to the Registry, you must first decide where to store that data.
    For instance, if you want to store something specific for the current user, you
    would probably use `HKEY_CURRENT_USER` as your root key. As systems programmers,
    we are more likely to choose a key such as `HKEY_LOCAL_MACHINE` or `HKEY_CURRENT_CONFIG`.
    These locations are independent of the current user, which is a more likely scenario
    for us. But, of course, if your use case warrants it, use any key you want.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当向注册表写入数据时，你必须首先决定在哪里存储那些数据。例如，如果你想为当前用户存储一些特定信息，你可能使用 `HKEY_CURRENT_USER` 作为你的根键。作为系统程序员，我们更有可能选择
    `HKEY_LOCAL_MACHINE` 或 `HKEY_CURRENT_CONFIG` 这样的键。这些位置与当前用户独立，这更符合我们的情况。但当然，如果你的用例需要，你可以使用任何你想要的键。
- en: Since the Registry is a hierarchical database, you must specify a hierarchy.
    In other words, you must think of a tree-like structure to store your data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注册表是一个分层数据库，你必须指定一个层次结构。换句话说，你必须考虑一个树状结构来存储你的数据。
- en: 'I see several subkeys in my machine’s root key: `HKEY_LOCAL_MACHINE`: `HARDWARE`,
    `SAM`, `SECURITY`, `SOFTWARE`, and `SYSTEM`. In the `SOFTWARE` subkey, I see a
    lot of sub-subkeys, many of which are names of software vendors on my machine.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '我在我的机器的根键中看到几个子键：`HKEY_LOCAL_MACHINE`: `HARDWARE`、`SAM`、`SECURITY`、`SOFTWARE`
    和 `SYSTEM`。在 `SOFTWARE` 子键中，我看到很多子子键，其中许多是我机器上软件供应商的名称。'
- en: 'If you want to write to the Registry, you have to think about this: the location
    does not matter much, but for administrators who are maintaining the machines
    our software runs on, it has to be logical where you put things.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要向注册表写入数据，你必须考虑这一点：位置并不重要，但对于维护我们软件运行的机器的管理员来说，放置东西的逻辑性很重要。
- en: 'Let’s assume we want to store the first time our software runs on a particular
    machine. If it has never run before, we store the current date-time. If it has
    run before, we retrieve that data: we never change the `first-run` date.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要存储软件在特定机器上第一次运行的时间。如果它之前从未运行过，我们存储当前的日期和时间。如果它之前运行过，我们检索那些数据：我们永远不会更改
    `first-run` 日期。
- en: 'To store that information, we need to take the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储该信息，我们需要采取以下步骤：
- en: Find the `HKEY_LOCAL_MACHINE\SOFTWARE` key.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `HKEY_LOCAL_MACHINE\SOFTWARE` 键。
- en: Create a subkey called `SystemProgrammers`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SystemProgrammers` 的子键。
- en: Create another subkey called `Usage`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `Usage` 的子键。
- en: Store the date-time in binary, in a key called `FirstAccess`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `FirstAccess` 的键中以二进制形式存储日期和时间。
- en: Of course, we can only take the last step if that key doesn’t exist yet. If
    it does, the software has run already. In that case, we retrieve the value belonging
    to that key and show that the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果那个键还不存在，我们才能采取最后一步。如果它已经存在，那么软件已经运行了。在这种情况下，我们检索属于那个键的值，并展示给用户。
- en: 'This is what that all looks like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we create the subkey. If it already exists, we get a reference to it.
    We don’t have to specify each subkey individually; we can give this method the
    whole path. In our case, `Software\SystemsProgrammers\Usage`, which we store in
    the `LocalMachine` root key.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建子键。如果它已经存在，我们就获取它的引用。我们不需要逐个指定每个子键；我们可以给这个方法整个路径。在我们的例子中，`Software\SystemsProgrammers\Usage`，我们将其存储在`LocalMachine`根键中。
- en: 'Then, we try to read the value belonging to the `FirstAccess` key. If that
    is `null`, we haven’t created it yet. So, we do that by calling `key.SetValue`.
    I specify the type to be `QWord`, but the API is smart enough to figure that out
    by itself: you can omit that if you want to. I like to be clear in my intentions,
    so I specify it anyway.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试读取`FirstAccess`键的值。如果它是`null`，那么我们还没有创建它。因此，我们通过调用`key.SetValue`来完成这个操作。我指定类型为`QWord`，但API足够智能，可以自己推断出来：如果你想的话，可以省略它。我喜欢明确我的意图，所以我还是指定了它。
- en: If the key does exist, we retrieve it. We have to do some casting from `long`
    before we get to `DateTime`, but after that casting, we can show the results.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键确实存在，我们检索它。在我们得到`DateTime`之前，我们必须进行一些从`long`到`DateTime`的类型转换，但转换之后，我们可以显示结果。
- en: Running this sample
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个示例
- en: 'Working with the Registry usually means you have to run with elevated privileges.
    This code only works if you run Visual Studio as Admin. But don’t worry: the OS
    informs you soon enough if you forget that. You cannot write to the Registry on
    this level as a regular user.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与注册表一起工作通常意味着你必须以提升的权限运行。这段代码只有在以管理员身份运行Visual Studio时才有效。但别担心：如果你忘记了，操作系统会很快通知你。作为普通用户，你无法在这个级别上写入注册表。
- en: If you want to be more careful with the data you store in the Registry, you
    can apply some security. After all, since anybody can open the Registry by using
    the Registry Editor application, you might want to limit access to specific keys.
    Fortunately, the people who designed the Registry thought of the same thing. So,
    they enabled security features on it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更小心地处理你在注册表中存储的数据，你可以应用一些安全措施。毕竟，任何人都可以通过注册表编辑器应用程序打开注册表，你可能希望限制对特定键的访问。幸运的是，设计注册表的人也想到了这一点。因此，他们在上面启用了安全功能。
- en: If we want our key to only be accessible to the current user, we can add some
    security info.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的键只对当前用户可访问，我们可以添加一些安全信息。
- en: 'So, in our sample code, after creating the key, add the following snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例代码中，在创建键之后，添加以下片段：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we get the name of the current user, which we store in the appropriately
    named `currentUser` variable. We need this to tell the Registry whom we want to
    give access to (or deny access from) our key.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取当前用户的名称，并将其存储在名为`currentUser`的相应变量中。我们需要这个信息来告诉注册表我们想要给哪个用户（或拒绝哪个用户）访问我们的键。
- en: We create a new instance of the `RegistrySecurity` class. Then, we create a
    new `RegistryAccessRule`, giving it the name of the user, and decide we want this
    rule to apply to everything (complete control), that it is not going to be inherited
    by child classes, not propagated to child classes, and that we want to allow this
    user to take complete control (the other option is to deny access).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`RegistrySecurity`类的新实例。然后，我们创建一个新的`RegistryAccessRule`，给它指定用户的名称，并决定我们希望这个规则应用于所有内容（完全控制），它不会被子类继承，不会被传播到子类，并且我们希望允许这个用户拥有完全控制权（另一种选择是拒绝访问）。
- en: Then, we add the access rule to the security object, which is applied to the
    key. There you go – a secured key!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将访问规则添加到安全对象中，该对象应用于键。就这样——一个受保护的关键！
- en: A word of advice – limit what you store in the Registry
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一点建议——限制你在注册表中存储的内容
- en: 'Working with the Registry is straightforward. However, I want to stress something:
    do not fill out the Registry if you do not need to. Also, if you have an installer
    of your service, make sure that the uninstaller removes all keys you have created.
    A cluttered Registry is one of the best ways to slow down Windows. There is a
    reason companies make money selling Registry cleaner apps. Don’t be one of those
    developers who mess up their users’ Registry!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与注册表一起工作很简单。然而，我想强调一点：如果您不需要，请不要填写注册表。另外，如果您有您服务的安装程序，请确保卸载程序会删除您创建的所有键。一个杂乱的注册表是减慢
    Windows 的最佳方式之一。公司之所以能从销售注册表清理应用程序中赚钱，是有原因的。不要成为那些搞乱用户注册表的开发者之一！
- en: Of course, the Registry is not the only place we can store our values. Sometimes,
    the overhead is just too much and we do need that to achieve our goal. Let’s have
    a look at the difference between using the Registry and using plain JSON settings
    files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，注册表并不是我们存储值的唯一地方。有时，开销实在太大，我们确实需要这样做来实现我们的目标。让我们看看使用注册表和使用纯 JSON 设置文件之间的区别。
- en: Comparing the Windows Registry to JSON settings files
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 Windows 注册表和 JSON 设置文件
- en: You might be surprised how easy it is to work with the Registry. With only a
    couple of lines of code, you can store and retrieve the information you need.
    You can easily distinguish between current and other users’ data. Or, more likely
    in our case, you can ensure the data is accessible for all services on the current
    machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现与注册表一起工作是多么容易。只需几行代码，您就可以存储和检索所需的信息。您可以轻松地区分当前用户和其他用户的数据。或者，更可能在我们这个案例中，您可以确保数据对当前机器上的所有服务都是可访问的。
- en: However, there is nothing wrong with having a local file with settings. After
    all, there is a reason Microsoft gives you a `settings.json` file if you create
    a new project. That’s the best way to isolate your settings. The settings you
    use in your application are right next to your executable. Anyone who needs to
    change them can go to that folder and make changes if needed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拥有一个带有设置的本地文件并没有什么不妥。毕竟，如果你创建了一个新项目，微软会给你一个 `settings.json` 文件，这是隔离设置的最佳方式。您在应用程序中使用的设置就紧挨着可执行文件。任何需要更改它们的人都可以进入那个文件夹并在需要时进行更改。
- en: What do you choose? Which one do you use when?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您会选择什么？您在什么时候使用哪一个？
- en: Well, let’s compare them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们进行比较。
- en: Windows Registry
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 注册表
- en: 'The Windows Registry has a couple of specific features that make it a good
    choice for certain scenarios. This is what they are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 注册表有一些特定的功能，使其在某些场景下成为不错的选择。以下是它们：
- en: '**Centralized storage**: The Registry is centralized and controlled by Windows.
    This location is where people tend to look for settings.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中存储**：注册表是集中并由 Windows 控制的。人们通常会在这里寻找设置。'
- en: '**User and machine-specific settings**: With the Registry, you can have specific
    settings for the current user, all users, the local machine, or everybody. You
    can place your settings in one or more of these locations and have the OS figure
    out when to use which one.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户和机器特定设置**：使用注册表，您可以针对当前用户、所有用户、本地机器或所有人设置特定的设置。您可以将设置放置在一个或多个这些位置，让操作系统确定何时使用哪一个。'
- en: '**Security features**: Adding rights or revoking rights is built in the Registry.
    You can specify on a very granular level what users can and cannot do with your
    keys.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全功能**：添加或撤销权限是内置在注册表中的。您可以在非常细粒度的层面上指定用户可以使用或不能使用您的密钥做什么。'
- en: '**Performance**: Reading from the Registry can be faster than reading files,
    especially if the data you are working with is small.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：从注册表读取可能比读取文件更快，尤其是如果您处理的数据很小。'
- en: '**Support for complex types**: The Registry can handle more than just strings
    and numbers. If your use case demands a more exotic data type, chances are the
    Registry has got you covered.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持复杂类型**：注册表可以处理不仅仅是字符串和数字。如果您的用例需要更复杂的数据类型，那么注册表很可能已经为您提供了支持。'
- en: Local JSON files
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地 JSON 文件
- en: 'JSON files are used a lot. There are several reasons people like this structure.
    Here are some of them:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文件被广泛使用。人们喜欢这种结构有几个原因。以下是一些原因：
- en: '**Simplicity and portability**: JSON files are straightforward. They are easy
    to write to and read from. Another bonus is that these files are easy to transfer
    between systems.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性和便携性**：JSON 文件简单易懂。它们易于写入和读取。另一个优点是这些文件易于在不同系统之间传输。'
- en: '**Human readable and editable**: You can easily edit the JSON files: they are
    just text files, and the structure is easily understood.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人类可读和可编辑**：你可以轻松编辑JSON文件：它们只是文本文件，结构易于理解。'
- en: '**No dependencies on Windows**: The Registry is Windows only. JSON files are
    everywhere.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不依赖Windows**：注册表仅适用于Windows。JSON文件无处不在。'
- en: '**Version control-friendly**: Since JSON files are text, systems such as Git
    can handle and version them.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制友好**：由于JSON文件是文本，像Git这样的系统可以处理和版本控制它们。'
- en: '**Avoiding system corruption**: If you mess up the Registry, you risk bringing
    Windows to a complete halt. Or, in a slightly less lousy case, wreak havoc on
    other applications. With JSON files, the worst that could happen is that you render
    your application useless.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免系统损坏**：如果你搞乱了注册表，你可能会让Windows完全停止运行。或者，在稍微好一点的情况下，会对其他应用程序造成破坏。使用JSON文件，最坏的情况就是让你的应用程序变得无用。'
- en: So, if your app is Windows only, and you need security and want to benefit from
    centralized, multi-user settings, go for the Registry.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你的应用程序仅限于Windows，你需要安全性和想要从集中式、多用户设置中受益，那么选择注册表。
- en: If you value simplicity, cross-platform compatibility, and easy version control,
    local JSON files are a better choice.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重视简洁性、跨平台兼容性和易于版本控制，本地JSON文件是一个更好的选择。
- en: Just make a decision based on what you need.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只要根据你的需求做出决定。
- en: To summarize, most applications need to have access to settings. You could store
    them in local JSON files or go for the more versatile but slightly more complex
    Registry.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，大多数应用程序都需要访问设置。你可以将它们存储在本地JSON文件中，或者选择更灵活但稍微复杂一些的注册表。
- en: We have looked at what the Registry does, how to read data from it, and how
    to write data to it. We compared the Registry to local JSON files, and we can
    now decide when to use which one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了注册表的作用，如何从中读取数据，以及如何向其中写入数据。我们比较了注册表和本地JSON文件，现在我们可以决定何时使用哪一个。
- en: Worker Services
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作服务
- en: So far, all of the samples I gave you are console apps; straightforward but
    aimed at you, the reader, so you can see what happened. However, in real life,
    systems programmers do not need a console to write output or read input. We deal
    with software that talks and listens to other software. Systems software usually
    does not have a user interface. A **console window** is a form of user interface,
    which we do not need.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我给你们提供的所有示例都是控制台应用程序；简单直接，但针对读者你，以便你可以看到发生了什么。然而，在现实生活中，系统程序员不需要控制台来写入输出或读取输入。我们处理的是与其他软件交谈和监听的软件。系统软件通常没有用户界面。**控制台窗口**是一种用户界面，我们不需要它。
- en: I will continue to use the console since that is a straightforward way to show
    you what happens, and in those applications, we can focus on the core of what
    I am trying to show you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续使用控制台，因为这是展示发生情况的直接方式，在这些应用程序中，我们可以专注于我试图展示的核心内容。
- en: However, in the real world, our applications work mainly behind the scenes.
    One of the ways to do that is to build services.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实世界中，我们的应用程序主要在幕后工作。实现这一目标的一种方法就是构建服务。
- en: 'A **service** is a standalone application that has no user interface. It does
    the work quietly behind the scenes. It does communicate with the outside world,
    but it does so through one of the many ways described in previous chapters: through
    network connections, files, pipes, and so on.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**是一个没有用户界面的独立应用程序。它在幕后默默工作。它确实会与外界通信，但它是通过前面章节中描述的许多方式之一进行的：通过网络连接、文件、管道等等。'
- en: 'Traditionally, if you wanted a service, you had to create a **Windows Service**.
    Before you say: “Well, duh, of course,” let me explain that a Windows Service
    is a different type of application and project in Visual Studio. Just as a console
    application differs from a WPF application, a Windows Service is its own type.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，如果你想获得一项服务，你必须创建一个**Windows服务**。在你想说：“嗯，当然啦”之前，让我解释一下Windows服务在Visual Studio中是一种不同类型的应用程序和项目。就像控制台应用程序与WPF应用程序不同一样，Windows服务是其自己的类型。
- en: A Windows Service is an application that runs without a user interface. Starting
    and operating them is not something a user does. Windows is responsible for that.
    There are dozens of services running on a Windows machine at all times, controlling
    your system and providing the background services you need.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Windows服务是一个没有用户界面的应用程序。启动和操作它们不是用户做的事情。Windows负责这一点。在Windows机器上始终运行着数十个服务，控制着你的系统，并提供你需要的后台服务。
- en: The following image shows a part of the list of services running on my machine.
    As you can see by the scrollbar, this is just a tiny part of the total amount
    of services.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了在我机器上运行的服务列表的一部分。正如您通过滚动条所看到的，这只是总服务量的一小部分。
- en: "![Figure\uFEFF7.2: Running Windows Services](img/B20924_08_02.jpg)"
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：运行Windows服务](img/B20924_08_02.jpg)'
- en: 'Figure7.2: Running Windows Services'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：运行Windows服务
- en: As you can see, the services have a name, a description, a status, a startup
    type, and a specific kind of user that controls them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务有一个名称、描述、状态、启动类型和特定的用户，该用户控制它们。
- en: The name and description are self-explanatory. The status can be one of a set
    of possibilities, but in most cases, they are either running or stopped. There
    are other statuses, but you hardly ever see those.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和描述是显而易见的。状态可以是多种可能性之一，但在大多数情况下，它们要么是正在运行，要么是已停止。还有其他状态，但您几乎很少看到这些状态。
- en: 'The startup type tells us how the service is started. It can be done automatically
    as soon as Windows starts. It can be done automatically but with a delay, so Windows
    waits a bit before starting them. This allows you to have other services up and
    running first. It can also be manual: Windows doesn’t start them at all. There
    are some other options as well. Last, we see the **Log On As** column. This column
    defines under what security principle the service runs. The security principle
    defines what rights the service has.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 启动类型告诉我们服务是如何启动的。它可以自动完成，在Windows启动时立即进行。它也可以自动完成，但会有延迟，因此Windows会在启动它们之前等待一段时间。这允许您先让其他服务运行。它也可以是手动启动：Windows根本不会启动它们。还有一些其他选项。最后，我们看到**登录为**列。此列定义了服务在哪个安全原则下运行。安全原则定义了服务拥有的权限。
- en: Windows Services are powerful, and they are still around. However, in Visual
    Studio, you can’t create them anymore. That’s not entirely true but bear with
    me for a moment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Windows服务功能强大，并且仍然存在。然而，在Visual Studio中，您不能再创建它们了。但这并不完全正确，请稍等片刻。
- en: The current way to write service-like applications is by using the Worker Service
    template.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当前编写类似服务应用程序的方式是使用Worker服务模板。
- en: Worker Services are the cross-platform equivalent of Windows Services. If you
    run a Worker Service on Windows, you can still benefit from the features of Windows
    Services. That’s why I said it wasn’t entirely true that you cannot create them
    anymore. The CLR has incorporated the Windows Services into the Worker Service.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Worker服务是Windows服务的跨平台等效物。如果您在Windows上运行Worker服务，您仍然可以受益于Windows服务的功能。这就是为什么我说您不能再创建它们了并不完全正确。CLR已经将Windows服务纳入了Worker服务中。
- en: A Worker Service is much easier to build and debug than a Windows Service. Since
    Windows controls the Windows Service, you had to perform tricks and magic to debug
    them. However, a Worker Service can run like a console application, albeit with
    added benefits.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Worker服务比Windows服务更容易构建和调试。由于Windows控制Windows服务，您必须进行技巧和魔法才能调试它们。然而，Worker服务可以像控制台应用程序一样运行，尽管增加了额外的功能。
- en: Docker support
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker支持
- en: 'If you create a new `Worker Service Project` in Visual Studio, you first get
    the standard dialog asking you about the name of the project, the location of
    the project, and the name of the solution. That is hardly surprising; you get
    that with every type of project. However, if you enter those details and click
    **Next**, you get a different version of the following dialog. For a console application,
    Visual Studio wants to know which version of the runtime you want (and whether
    you want to use top-level statements or not). With a Worker Service, Visual Studio
    asks you whether you want a Docker container. Your screen probably looks like
    the following image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Visual Studio中创建一个新的`Worker Service项目`，您首先会看到一个标准对话框，询问您项目的名称、项目位置和解决方案名称。这几乎不足为奇；您在每种类型的项目中都会得到这个。然而，如果您输入这些详细信息并点击**下一步**，您会看到一个不同版本的以下对话框。对于控制台应用程序，Visual
    Studio会询问您想要哪个版本的运行时（以及是否想要使用顶级语句）。对于Worker服务，Visual Studio会询问您是否想要一个Docker容器。您的屏幕可能看起来像以下图像：
- en: "![Figure \uFEFF7.3: Extra information needed to create a Worker Service](img/B20924_08_03.jpg)"
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：创建Worker服务所需额外信息](img/B20924_08_03.jpg)'
- en: 'Figure 7.3: Extra information needed to create a Worker Service'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：创建Worker服务所需额外信息
- en: If you check the box before **Enable Docker**, you can select the OS you want
    to use. This is usually a choice between Windows and Linux if you have WSL2 installed.
    Visual Studio creates a docker file for you, and you can now run your service
    in a container. Isn’t that awesome?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你勾选了 **启用 Docker** 前面的复选框，你可以选择你想要使用的操作系统。如果你安装了 WSL2，这通常是在 Windows 和 Linux
    之间进行选择。Visual Studio 会为你创建一个 Docker 文件，现在你可以在一个容器中运行你的服务了。这不是很酷吗？
- en: Developing your services and running them on Docker is extremely powerful. Visual
    Studio allows you to write your source files on your Windows machine, then deploy
    them to a Docker image and spin up a container with your code running. The debugger
    even allows you to debug your service from Visual Studio while running in the
    Docker container.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 上开发和运行你的服务非常强大。Visual Studio 允许你在 Windows 机器上编写源文件，然后将它们部署到 Docker
    镜像，并启动一个运行你的代码的容器。调试器甚至允许你在 Docker 容器中运行时从 Visual Studio 调试你的服务。
- en: 'Unfortunately, I shall not be covering that here in this book. That topic warrants
    a book on its own. However, to show you your options, we will write a bare-bones
    worker service and run it on a Docker if you have that installed. If you haven’t,
    that’s also fine: the worker runs the same on Windows as on Linux in a Docker
    container. So, you pick the strategy you think works best for you.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我将在本书中不涉及这一点。这个主题值得一本自己的书。然而，为了展示你的选项，我们将编写一个裸骨工作服务并在安装 Docker 的情况下运行它。如果你没有安装，那也行：工作服务在
    Docker 容器中在 Windows 和 Linux 上运行是一样的。所以，你选择你认为最适合你的策略。
- en: Dissecting the Worker Service
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆解工作服务
- en: 'In Visual Studio, you can select Worker Service as a template. If you do that,
    you get asked the question we already discussed: what version of the framework
    do you want, and do you want Docker support? If you do, what OS should it run
    on?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，你可以将工作服务作为模板选择。如果你这样做，你会被问到我们之前讨论过的问题：你想要哪个框架版本，你想要 Docker
    支持？如果你想要，它应该运行在哪个操作系统上？
- en: 'In my example, I have enabled Docker support and chosen Linux as the OS. It
    does not matter what you decide to do: the C# code is the same no matter what.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，我启用了 Docker 支持，并选择了 Linux 作为操作系统。无论你决定做什么：无论什么情况下，C# 代码都是相同的。
- en: The bare minimum of a Worker Service has a bit more code than a regular console
    application, but the main files are `Program.cs` and `Worker.cs`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作服务的基本版本比一个常规控制台应用程序的代码要多一些，但主要文件是 `Program.cs` 和 `Worker.cs`。
- en: 'My application looks like this in the Visual Studio solution window:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我的应用程序在 Visual Studio 解决方案窗口中看起来是这样的：
- en: "![Figure \uFEFF7.4: The layout of the Worker Service in Visual Studio](img/B20924_08_04.jpg)"
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：Visual Studio 中工作服务的布局](img/B20924_08_04.jpg)'
- en: 'Figure 7.4: The layout of the Worker Service in Visual Studio'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：Visual Studio 中工作服务的布局
- en: 'The `Program` class is not even that interesting. It contains, next to the
    namespace declaration, the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` 类甚至没有多么有趣。它除了包含命名空间声明外，还包含以下代码：'
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let me outline the steps I took to get to these results:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我概述一下我为了得到这些结果所采取的步骤：
- en: First, we create an instance of the `HostApplicationBuilder` class. We do that
    by calling `CreateApplicationBuilder` on the static `Host` class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建 `HostApplicationBuilder` 类的一个实例。我们通过在静态 `Host` 类上调用 `CreateApplicationBuilder`
    来做到这一点。
- en: 'The `builder` instance allows us to register classes. That way, we can use
    dependency injection. The template adds one service for us: the `Worker` class.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder` 实例允许我们注册类。这样，我们可以使用依赖注入。模板为我们添加了一个服务：`Worker` 类。'
- en: Next, we build `host` (of the `IHost` type), and finally, we run it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建 `host`（`IHost` 类型），最后运行它。
- en: The more exciting code is in the `Worker` class. As the name implies, that’s
    where all the work happens. We do not call it a Worker Service for nothing!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是 `Worker` 类中的代码。正如其名所示，所有的工作都发生在这里。我们不是没有理由称之为工作服务！
- en: 'Let’s take a look at that `Worker` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看那个 `Worker` 类：
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to rename this class, you can do that, of course, as long as you
    also change the registered class in the `Program` class. Also, if you want to
    build multiple classes next to `Worker`, you can also do that. Again, do not forget
    to add them to `builder` in the `Program` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重命名这个类，当然可以，只要你也在 `Program` 类中更改注册的类。此外，如果你想在 `Worker` 旁边构建多个类，你也可以这样做。再次提醒，不要忘记在
    `Program` 类中将它们添加到 `builder` 中。
- en: So, what is going on here?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？
- en: The base class is `BackgroundService`. This class takes care of all the plumbing.
    It is an abstract class with the `ExecuteAsync(CancellationToken stoppingToken)`
    abstract method. So, you must write that method yourself (or let the template
    do that, as we did here.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基类是 `BackgroundService`。这个类负责所有管道。它是一个具有 `ExecuteAsync(CancellationToken stoppingToken)`
    抽象方法的抽象类。因此，你必须自己编写该方法（或者像我们在这里做的那样，让模板来做这件事。）
- en: The constructor of our class gets a default instance of `logger` that allows
    us to write things to the console when running. This `logger` is available to
    us through the magic of dependency injection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的构造函数获取一个 `logger` 的默认实例，这允许我们在运行时将内容写入控制台。这个 `logger` 通过依赖注入的魔力对我们可用。
- en: In the `ExecuteAsync` method, we keep looping until `CancellationToken` signals
    we want to stop. In the loop, we output a message and wait for a second before
    going to the next iteration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ExecuteAsync` 方法中，我们持续循环，直到 `CancellationToken` 信号表示我们想要停止。在循环中，我们输出一条消息，然后等待一秒钟再进行下一次迭代。
- en: If you run this, you will see the output. If you have Docker Desktop running,
    you can also run it on Docker. Just select Docker as what you want to run instead
    of your application. Visual Studio builds the image, deploys it, starts a container,
    and hooks the debugger to allow debugging.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会看到输出。如果你正在运行 Docker Desktop，你还可以在 Docker 上运行它。只需选择 Docker 作为你想要运行的内容而不是你的应用程序。Visual
    Studio 构建镜像，部署它，启动一个容器，并将调试器连接起来以允许调试。
- en: 'In the output window of Visual Studio and Docker Desktop itself, you can see
    the results: the output of our loop is printed there.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 和 Docker Desktop 本身的输出窗口中，你可以看到结果：我们的循环输出被打印在那里。
- en: Controlling the lifetime of the service
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制服务的生命周期
- en: A Worker Service is meant to run forever. Well, maybe not forever, but at least
    as long as your machine runs. It is in there in the background, doing its job.
    It might be doing something worthwhile or waiting for incoming messages over a
    file, network, or any other way we discussed. It does its job and then returns
    to waiting for the next assignment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 工作服务旨在永远运行。嗯，也许不是永远，但至少要长到你机器运行的时间。它在后台运行，完成其工作。它可能在进行一些有价值的工作，或者等待通过文件、网络或我们讨论的任何其他方式传入的消息。它完成工作后，然后返回等待下一个任务。
- en: But what if you want to stop the service when it has fulfilled its purpose?
    Let’s rewrite the code a bit. Add a private variable to our Worker Service `call
    _counter` of the `int` type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在服务完成其目的后停止它怎么办？让我们稍微重写一下代码。在我们的工作服务 `WorkerService` 中添加一个私有变量 `call _counter`，其类型为
    `int`。
- en: 'Then, change the loop in `ExecuteAsync` to look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `ExecuteAsync` 中的循环更改为如下所示：
- en: '[PRE4]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After waiting one second, we checked to see whether the loop had been run 10
    times. If it has, we break out of the loop. Then, we print a message to tell you
    it has done so.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一秒钟后，我们检查循环是否运行了 10 次。如果是，我们就跳出循环。然后，我们打印一条消息告诉你它已经完成了。
- en: 'Run it and watch. You notice that it works as expected but that Visual Studio
    does not return to normal: it keeps debugging. However, there is nothing to debug!
    If you break, you see that Visual Studio still executes the call to `Host.Run()`
    in `Program`. Apparently, there is no way out!'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它并观察。你会注意到它按预期工作，但 Visual Studio 并没有恢复正常：它继续调试。然而，没有东西可以调试！如果你中断，你会看到 Visual
    Studio 仍然在 `Program` 中执行对 `Host.Run()` 的调用。显然，没有出路！
- en: Well, of course, there is. In this case, all we have to do is tell `Host` that
    we want it to stop working. We can do that quite easily.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当然有。在这种情况下，我们只需要告诉 `Host` 我们想要它停止工作。我们可以非常容易地做到这一点。
- en: 'We use dependency injection again. One of the services available to us is an
    instance of a class that implements the `IHostApplicationLifetime` interface.
    Let’s add that to the constructor of the `Worker` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用依赖注入。我们可用的服务之一是一个实现了 `IHostApplicationLifetime` 接口类的实例。让我们将其添加到 `Worker`
    类的构造函数中：
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We get that instance and store it in a local field.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取该实例并将其存储在局部字段中。
- en: 'Then, in the `ExecuteAsync` method, just after where we log that we have finished
    the loop, add the following line:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `ExecuteAsync` 方法中，在记录我们完成循环之后，添加以下行：
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s all there is to it. The `Host` instance now gets the message telling
    it to stop working and return to the OS.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。`Host` 实例现在收到一条消息，告诉它停止工作并返回到操作系统。
- en: Wrapping up Worker Services
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结工作服务
- en: Worker Services are excellent if you want a piece of code running in the background
    without any user interface, only meant to be called by other software. Does that
    sound familiar? That is precisely what systems programmers strive for. Worker
    Services are your best bet here. They can do anything you want. They can open
    ports on a TCP connection, watch folders for files, have named pipes to wait for
    data and process it, wait for network connections, and much more.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 工作服务非常适合您想要在后台运行代码，没有用户界面，只供其他软件调用的场景。这听起来熟悉吗？这正是系统程序员所追求的。工作服务是您的最佳选择。它们可以做您想要做的任何事情。它们可以在TCP连接上打开端口，监视文件夹中的文件，拥有命名管道等待数据并处理它，等待网络连接，等等。
- en: In short, they are a much better place to do all that work than the console
    applications we have been writing so far. You can still register them as services
    in Windows, so they start up automatically as soon as Windows starts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它们是完成所有这些工作的比我们迄今为止编写的控制台应用程序更好的地方。您仍然可以将它们注册为Windows中的服务，这样它们就会在Windows启动时自动启动。
- en: The code is simple enough. Ensure your code is initiated from the `Worker` class,
    and you are good to go.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码足够简单。确保您的代码是从`Worker`类启动的，这样您就可以开始了。
- en: 'We will stick with the console applications in the rest of this book. Not because
    they are a better way to do systems programming (they are not) but because they
    are so easy and do not get in the way when I am working on explaining new topics.
    But now you know: everything you can do in a console application can (and should)
    be done in a Worker Service. You can deploy your code on Linux machines or Docker
    platforms if it is cross-platform and does not use Windows-only APIs. It is all
    up to you!'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分坚持使用控制台应用程序。不是因为它们是做系统编程的更好方式（它们不是），而是因为它们非常简单，在我解释新主题时不会妨碍我。但现在您知道了：您在控制台应用程序中能做的所有事情都可以（并且应该）在工作服务中完成。如果您的代码是跨平台的并且不使用仅限Windows的API，您可以将代码部署到Linux机器或Docker平台上。一切尽在您的掌握！
- en: WMI
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WMI
- en: System programmers work closer to the OS than other, more user-oriented programmers.
    We often need to know more about the state of the OS than others do. We might
    need to keep track of the memory used, the hardware state, and other lower-level
    items. Luckily, Windows allows us to do just that. We can have a window (no pun
    intended) into the engine room, so to speak.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 系统程序员比其他更面向用户的程序员更接近操作系统。我们往往需要比其他人更多地了解操作系统的状态。我们可能需要跟踪内存使用情况、硬件状态和其他底层项目。幸运的是，Windows允许我们做到这一点。我们可以打开一个窗口（无意中用了双关语），就像进入机房一样。
- en: WMI is the tool to use. It’s like the Swiss Army knife for managing items in
    Windows. WMI is part of the Windows OS that allows you to access and manipulate
    all sorts of system information and settings. This is Windows only, of course.
    In Linux, there is no built-in, out-of-the-box alternative to WMI. If you want
    to do this on a Linux machine, use external libraries and tools.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: WMI是您需要使用的工具。它就像管理Windows中项目的瑞士军刀。WMI是Windows操作系统的一部分，允许您访问和操作各种系统信息和设置。当然，这仅限于Windows。在Linux中，没有内置的、开箱即用的WMI替代品。如果您想在Linux机器上做这件事，请使用外部库和工具。
- en: 'What can you do with WMI? You’d better ask, “What can’t you do with WMI?” Let
    me show you some of the more common uses of WMI:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用WMI做什么？您最好问，“您不能用WMI做什么？”让我向您展示一些WMI更常见的用途：
- en: '**Monitoring system health**: You can check on CPU load, available memory,
    disk usage, and so on.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控系统健康**：您可以检查CPU负载、可用内存、磁盘使用情况等等。'
- en: '**Managing hardware and software**: You can get information about installed
    software, manage printers, and even play around with BIOS settings.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理硬件和软件**：您可以获取有关已安装软件的信息，管理打印机，甚至可以玩弄BIOS设置。'
- en: '**Automating tasks**: You can use WMI to automate tasks, such as monitoring
    and restarting a service if necessary.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化任务**：您可以使用WMI来自动化任务，例如在必要时监控和重启服务。'
- en: '**Event notifications**: We already saw the possibility of watching a folder
    or a file, but we can do much more. We can get notifications for almost anything
    that happens on the system.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件通知**：我们已经看到了监视文件夹或文件的可能性，但我们能做的远不止这些。我们可以为系统上发生的几乎所有事情获取通知。'
- en: 'There are many more things you can do with WMI. However, let’s focus on these
    first. Before we begin looking at some samples, you need to install a NuGet package:
    `System.Management` from Microsoft. This package replaces the older `System.Management`
    assembly that was part of the .NET Framework.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WMI，你可以做很多事情。然而，让我们先关注这些。在我们开始查看一些示例之前，你需要安装一个NuGet包：来自Microsoft的`System.Management`。这个包替换了.NET
    Framework中的一部分较旧的`System.Management`程序集。
- en: How to use WMI
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用WMI
- en: The primary way of interacting with Windows is by querying it. The `System.Management`
    NuGet package gives us access to a class named `ManagementObjectSearcher`. This
    class allows us to create queries and run them against Windows. The searcher usually
    returns a collection of `ManagementObject` instances, which you can interact with.
    These `ManagementObject` instances reflect something in your system. This class
    has an indexer, so you can query that object to get the information you are searching.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows交互的主要方式是通过查询它。`System.Management` NuGet包为我们提供了一个名为`ManagementObjectSearcher`的类。这个类允许我们创建查询并在Windows上运行它们。搜索器通常会返回一个`ManagementObject`实例的集合，你可以与之交互。这些`ManagementObject`实例反映了你系统中的某些内容。这个类有一个索引器，因此你可以查询该对象以获取你正在搜索的信息。
- en: '`ManagementObjectSearcher` can search over a lot of different types of data
    providers. That means you might have to limit the search by giving it a scope
    first.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagementObjectSearcher`可以搜索很多不同类型的数据提供者。这意味着你可能需要先给它一个范围来限制搜索。'
- en: The query itself is a string that starts with `SELECT`. It is just like a database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 查询本身是一个以`SELECT`开头的字符串，就像数据库一样。
- en: Be careful what you do, though; we are opening the hood of the engine and poking
    around in places we are usually not meant to be poking around in. Most of the
    queries run on WMI require elevated privileges. You need to be a local administrator
    to make some changes or see some of the data. That means that all safeguards are
    out of the window. You are on your own. With great power comes great responsibility,
    right?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然要小心行事；我们正在打开引擎盖，在我们通常不应该乱动的地方乱摸。大多数在WMI上运行的查询都需要提升的权限。你需要是本地管理员才能进行一些更改或查看一些数据。这意味着所有的安全措施都失效了。你只能靠自己。权力越大，责任越大，对吧？
- en: 'All of the following samples only run on Windows. Visual Studio is smart enough
    to see that: if you follow along, you will see many warnings about that. To be
    specific, you get the `CA1416` warning a lot. This warning says `This call is
    reachable on all platforms. ManagementObjectSearcher is only supported` `on: Windows`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下示例都只能在Windows上运行。Visual Studio足够智能，能够看到这一点：如果你跟着做，你会看到很多关于这个的警告。具体来说，你会经常收到`CA1416`警告。这个警告说：“这个调用在所有平台上都是可到达的。ManagementObjectSearcher仅在以下平台上受支持：Windows”。
- en: 'To get rid of that, add a pragma to the top of the file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这一点，请在文件顶部添加一个pragma：
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This instruction tells the compiler not to bother: we know what we are doing.
    Now, the compiler gets out of your way and lets you be responsible for all damages
    that might occur if you still try to run this on Linux.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令告诉编译器不要管：我们知道我们在做什么。现在，编译器不再妨碍你，让你负责所有可能发生的损害，即使你仍然尝试在Linux上运行此代码。
- en: But enough of the scaremongering. Before we get into a heated debate on the
    pros and cons of being a local admin, we have to measure the heat a bit. Let’s
    measure the temperature of our CPU!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要吓唬人。在我们开始就本地管理员角色的利弊进行激烈辩论之前，我们必须稍微测量一下热度。让我们测量一下我们的CPU温度！
- en: Reading the CPU temperature
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取CPU温度
- en: 'Most of the BIOS implementations allow the system to read the current CPU temperature.
    Other vendors of motherboards might have other ways of reading temperatures in
    the system, one of which might be the CPU. It all depends on the vendor. However,
    if your system supports it, you can easily read the current temperature. You could
    use that information to scale down your work in your system if you notice you
    are making the CPU work too hard. But how do we get that temperature? The code
    is relatively simple:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数BIOS实现都允许系统读取当前的CPU温度。其他主板供应商可能有其他读取系统温度的方法，其中之一可能是CPU。这完全取决于供应商。然而，如果你的系统支持它，你可以轻松地读取当前的温度。如果你注意到CPU工作得太辛苦，你可以使用这些信息来降低系统中的工作量。但我们是怎样得到这个温度的呢？代码相对简单：
- en: '[PRE8]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, I identify the scope of the query. In this case, it is `root\\WMI`. Then,
    I create the query string, where we select everything from the `MCAcpi_ThermalZoneTemperature`
    class. As I said before, this results in a collection of `ManagementObject` instances.
    In this case, the collection consists of one item. This item has an indexer, and
    if we request the `CurrentTemperature` field, we get the current temperature of
    the CPU in tenths of Kelvin. We multiply that result by ten to get to the actual
    Kelvin value and then convert that to degrees Celsius. If you want to go to Fahrenheit,
    be my guest.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我确定了查询的范围。在这个例子中，它是 `root\\WMI`。然后，我创建了查询字符串，其中我们选择了 `MCAcpi_ThermalZoneTemperature`
    类中的所有内容。正如我之前所说的，这会产生一个 `ManagementObject` 实例的集合。在这种情况下，集合中只有一个项目。这个项目有一个索引器，如果我们请求
    `CurrentTemperature` 字段，我们将得到 CPU 的当前温度，单位是千分之一开尔文。我们将该结果乘以十以得到实际的千分之一开尔文值，然后将其转换为摄氏度。如果你想转换成华氏度，请随意。
- en: As I said, not all vendors supply this option. I use an older laptop from 2018
    quite frequently, but it does not give me this information. I see `ManagementException`
    on that machine when I try to get the results. However, I got the results on my
    beefy desktop machine as expected.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，并不是所有供应商都提供这个选项。我经常使用一台 2018 年的老款笔记本电脑，但它没有提供这些信息。当我尝试获取结果时，我在那台机器上看到了
    `ManagementException`。然而，在我的强大台式机上，我如预期地得到了结果。
- en: There is another class you can use to query for the temperature. The query for
    that is `SELECT * FROM Win32_TemperatureProbe`, and the scope for that query is
    `root\\CIMV2`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用另一个类来查询温度。那个查询是 `SELECT * FROM Win32_TemperatureProbe`，而那个查询的范围是 `root\\CIMV2`。
- en: However, there can be multiple probes in your machine. Some motherboards also
    support measuring the temperature of other components, such as the GPU. To be
    honest, `Win32_TemperatureProbe` is even less commonly implemented than `MCAcpi_ThermalZoneTemperature`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的机器中可能有多个探头。一些主板还支持测量其他组件的温度，例如 GPU。坦白说，`Win32_TemperatureProbe` 的实现甚至比
    `MCAcpi_ThermalZoneTemperature` 更不常见。
- en: Reading the BIOS
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 BIOS
- en: The BIOS is the lowest level of abstraction on your machine. This level is where
    all the logic gets translated into voltages fed into the hardware. Wouldn’t it
    be nice to see what is going on there? Well, you can, with the power of WMI!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 是您机器上抽象层次最低的部分。在这个层次，所有的逻辑都被转换成电压，并输入到硬件中。看到那里发生了什么不是很好吗？嗯，你可以，利用 WMI 的力量！
- en: 'Let’s get some basic information out of the BIOS and display that. Here we
    go:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 BIOS 中获取一些基本信息并显示出来。下面是：
- en: '[PRE9]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For this example, I have used a different constructor. Instead of passing in
    the scope and query as strings, I construct these two items first using the managed
    `ManagementScope` and `ObjectQuery` wrapper classes. This way of working achieves
    the same result but might be more readable to future developers working on this
    code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我使用了不同的构造函数。不是将范围和查询作为字符串传递，而是首先使用托管的 `ManagementScope` 和 `ObjectQuery`
    包装类构建这两个项目。这种方式可以达到相同的结果，但可能对将来在此代码上工作的开发者来说更易于阅读。
- en: The structure is similar to the previous example. We create an instance of a
    `ManagmentObjectSearchers` class, feed it the scope and query, and then query
    the results. In our example, we get the manufacturer, name, and version.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结构与上一个例子类似。我们创建了一个 `ManagmentObjectSearchers` 类的实例，向其提供范围和查询，然后查询结果。在我们的例子中，我们得到了制造商、名称和版本。
- en: You can read many more properties from the BIOS, such as the capabilities. These
    describe what hardware is supported on that machine. As a systems programmer,
    you probably can imagine how this could be handy to know.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 BIOS 中读取许多其他属性，例如功能。这些描述了在该机器上支持哪些硬件。作为一个系统程序员，你可能可以想象知道这些信息是多么有用。
- en: Controlling the Windows Update service
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制Windows更新服务
- en: We discussed Worker Services earlier in this chapter. However, wouldn’t it be
    nice if we could write software that allows us to monitor the state of those services
    and act upon them if needed? Well, we can with WMI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面讨论了工作服务。然而，如果我们能够编写软件来监控这些服务的状态并在需要时对其采取行动，那不是很好吗？嗯，我们可以用 WMI 来做到这一点。
- en: 'In the following sample, we look at the status of a generic service: the Windows
    Update service. This service is part of the OS and is responsible for dealing
    with updates: monitoring, downloading, and installing them. Ideally, that service
    should always be up and running. Let’s see what we can do with WMI to achieve
    that:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们查看一个通用服务的状态：Windows更新服务。这个服务是操作系统的一部分，负责处理更新：监控、下载和安装。理想情况下，该服务应该始终处于运行状态。让我们看看WMI能做些什么来实现这一点：
- en: '[PRE10]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, I do not specify a scope. Windows then assumes the default
    scope of `root\CIMV2`, as we saw before. Generally, it would be best if you used
    a scope. Specifying a scope limits the areas where WMI executes your query, which
    improves the speed tremendously. I just wanted to show you this approach here
    so you know it is an option.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我没有指定作用域。Windows随后假定默认的作用域为`root\CIMV2`，就像我们之前看到的那样。通常，最好使用作用域。指定作用域限制了WMI执行查询的区域，这可以极大地提高速度。我只是想在这里展示这种方法，让你知道这是一个选项。
- en: We are looking for a service with the name of `wuauserv`, the Windows Update
    service. If we find it, we get the current state. It should be “running.” If it
    is, we stop it, wait for two seconds and restart it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找一个名为`wuauserv`的服务，即Windows更新服务。如果我们找到它，我们获取当前状态。它应该是“正在运行”。如果是，我们停止它，等待两秒然后重新启动它。
- en: 'There you have it: you can now control services inside your code!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：你现在可以在代码中控制服务了！
- en: Watching USB devices
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察USB设备
- en: Sometimes, you might be depending on specific hardware. Let’s assume you are
    reading data from a USB device. Wouldn’t it be nice to be informed when the user
    removes the device? That would prevent embarrassing errors in your code, right?
    Again, we have WMI coming to our aid!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会依赖于特定的硬件。假设你正在从USB设备读取数据。当用户移除设备时，你会不会希望得到通知？这可以防止你的代码中出现尴尬的错误，对吧？再次，WMI来帮助我们！
- en: 'This is the code to do just that:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现这一点的代码：
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The query tells the system to look at an event called `__InstanceDeletionEvent`.
    This is the event that Windows raises once something is deleted on the computer.
    In this case, we look for something in the list of devices registered in `ISA'Win32_USBHub'`.
    In other words, we want to be notified if a USB device is deleted from the system.
    `WITHIN 2` means we want to check every 2 seconds. So, there might be a delay.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 查询告诉系统查看一个名为`__InstanceDeletionEvent`的事件。这是当计算机上删除某个东西时Windows引发的事件。在这种情况下，我们在`ISA'Win32_USBHub'`注册的设备列表中寻找某个东西。换句话说，我们希望当USB设备从系统中删除时得到通知。`WITHIN
    2`意味着我们希望每2秒检查一次。所以，可能会有延迟。
- en: This time, we create a new object. The watcher is a new instance of the `ManagementEventWatcher`
    class. We give it the query, set up a callback in case the event happens, and
    start watching. When we are done, we stop watching again.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们创建了一个新的对象。观察者（watcher）是`ManagementEventWatcher`类的一个新实例。我们给它一个查询，设置一个回调以备事件发生，然后开始观察。当我们完成时，我们再次停止观察。
- en: 'The event handler looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器看起来像这样：
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As soon as the event occurs, this code gets called. `eventargs` of the `EventArrivedEventArgs`
    type contains much information. Amongst others, it has `TargetInstance` in it.
    `TargetInstance` has all sorts of information we can display.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件发生，这段代码就会被调用。`EventArrivedEventArgs`类型的`eventargs`包含了很多信息。其中之一是`TargetInstance`。`TargetInstance`包含我们可以显示的各种信息。
- en: 'We could have used another approach: we could have queried the `Win32_DeviceChangedEvent`
    class. That would have been a bit easier, but that gives us less information than
    our current solution. This is typical for WMI: there is usually more than one
    way to get the desired results.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一种方法：我们可以查询`Win32_DeviceChangedEvent`类。那会容易一些，但那给我们提供的信息比我们当前的方法要少。这是WMI的典型情况：通常有不止一种方法可以得到期望的结果。
- en: Play around with it; start the code and unplug several devices from your machine.
    See what happens!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看；启动代码，然后从你的机器上拔掉几个设备。看看会发生什么！
- en: Final words about WMI
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于WMI的结束语
- en: 'WMI is very powerful. You can do all sorts of things that are typically unavailable
    to a regular .NET application. However, there are downsides: WMI is highly resource
    intensive. We set the event watcher in the last sample to only run once every
    two seconds to mitigate that a little bit.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: WMI非常强大。你可以做很多通常对普通.NET应用程序不可用的事情。然而，也有缺点：WMI非常资源密集。我们在上一个示例中将事件观察者设置为每两秒运行一次，以稍微减轻这一点。
- en: 'WMI is somewhat obscure. You have to figure out the queries yourself; there
    is not much information that teaches you all the available options. Of course,
    the Microsoft documentation has plenty to say about this topic, but it is not
    as straightforward as you might be used to. There is quite a steep learning curve
    if you want to dive into this. That leads to another risk: you can quickly get
    things wrong.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: WMI有些神秘。你必须自己找出查询；关于所有可用选项的信息并不多。当然，微软的文档有很多关于这个主题的内容，但它并不像你习惯的那样直接。如果你想要深入研究，学习曲线相当陡峭。这导致另一个风险：你可能会很快出错。
- en: WMI allows you to interact with lower parts of the system, which can cause catastrophic
    results. Another risk is that it unadvertly displays security-sensitive information.
    So, be careful what you do with it. As always, test what happens if you use this
    technique.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: WMI允许你与系统的较低部分进行交互，这可能导致灾难性的后果。另一个风险是它无意中显示敏感信息。所以，在使用它时要小心。一如既往，测试一下如果你使用这种技术会发生什么。
- en: However, if you are careful, you can do many cool things!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你小心谨慎，你可以做很多酷的事情！
- en: 'We have seen some really nice things here. You might be tempted to sprinkle
    a lot of Registry and WMI code over your systems. However, before you do that,
    let’s take a peek into the downsides: there are potential risks we should talk
    about!'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了一些真正不错的东西。你可能会被诱惑在你的系统中添加大量的注册表和WMI代码。然而，在你这样做之前，让我们看看它的缺点：有一些潜在的风险我们应该讨论！
- en: Registry and WMI – risks and how to avoid them
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册表和WMI – 风险及如何避免
- en: 'Nothing comes for free. That also applies to OS services: there is a price
    to pay. The complexity of the code isn’t too high; I am sure you could follow
    along. No, the price you have to pay lies elsewhere: mistakes can be hard to spot
    and even harder to fix. The risks are pretty high: an error could lead to unpredictable
    behavior of the machine. You could bring down a complete server if you do things
    wrong.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么是免费的。这也适用于操作系统服务：你必须付出代价。代码的复杂性并不高；我确信你能跟上。不，你必须付出的代价在于：错误可能很难发现，甚至更难修复。风险相当高：一个错误可能导致机器出现不可预测的行为。如果你操作不当，可能会使整个服务器崩溃。
- en: Of course, we are all brilliant developers. We do not make mistakes, right?
    However, just in case we have a moment of weakness (we all know that 14 hours
    of developing software in one sitting is not the best idea), I want to tell you
    about the risks and how to avoid them as much as possible.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们都是杰出的开发者。我们不会犯错误，对吧？然而，以防万一我们有一瞬间的不坚定（我们都知道连续14小时开发软件并不是最佳选择），我想告诉你一些风险以及如何尽可能地避免它们。
- en: But before I do that, we have a whole chapter ([*Chapter 11*](B20924_12.xhtml#_idTextAnchor237),
    to be exact) about debugging. That’s where we will dive into the nitty gritty
    details of that topic. But here, I want to focus on what might go wrong when working
    with the Registry and WMI.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们有一个完整的章节（[第11章](B20924_12.xhtml#_idTextAnchor237)，确切地说）是关于调试的。那是我们将深入探讨该主题的细节的地方。但在这里，我想关注的是在处理注册表和WMI时可能会出现的问题。
- en: The Windows Registry
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows注册表
- en: As mentioned before, the Windows Registry is where the OS and most applications
    running on it store and read their settings. These could range from simple values
    about the user preferences to details about installed peripherals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Windows注册表是操作系统和大多数在其上运行的应用程序存储和读取其设置的地方。这些可能从关于用户偏好的简单值到关于已安装外围设备的详细信息。
- en: Making a mistake here could result in an application not working as expected.
    However, it could also result in the machine breaking down completely. So, you’d
    better be careful when dabbling around in the Registry!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里犯错误可能会导致应用程序无法按预期工作。然而，它也可能导致机器完全崩溃。所以，你在注册表周围摸索时最好要小心！
- en: There are several steps you can take to mitigate the risks. Let’s go through
    them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取几个步骤来减轻风险。让我们逐一来看。
- en: Backup
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份
- en: If you start experimenting with the Registry, the best tip I can give you is
    to back up your current settings. You can export and import keys and subkeys in
    the Registry Editor tool (`regedit.exe` in your Windows directory). That means
    you can easily roll back your changes when you make a mistake. If you are doing
    this in your application, you might consider reading your app’s settings and storing
    them before applying changes. Of course, you do not do that when storing simple
    settings, but this might save you when you need it for more threatening situations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始对注册表进行实验，我能给出的最好建议是备份你的当前设置。你可以在注册表编辑器工具（Windows目录中的`regedit.exe`）中导出和导入键和子键。这意味着当你犯错时，你可以轻松地回滚你的更改。如果你在应用程序中这样做，你可能需要考虑在应用更改之前读取你的应用程序设置并将它们存储起来。当然，当存储简单的设置时，你不需要这样做，但这可能会在你需要时救你一命。
- en: Proper tools
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确的工具
- en: In the end, the Registry itself is a collection of files on the storage medium
    of your computer. After all, the data needs to be stored somewhere. It is no secret
    where these files are stored. For instance, you can find the `HKEY_LOCAL_USER`
    settings in the `UsrClass.dat` file in the `%UserProfile%\Local Settings\Application
    Data\Microsoft\Windows` folder. However, I would not recommend messing around
    with these files yourself. Use the tools. The aforementioned Registry Editor is
    a great way to read and change settings. If you want to do this in your software,
    use the tools the BCL and the Win32 API give you. If you are curious about what
    happens to the Registry in run time, the free Process Monitor tool from SysInternals
    is invaluable. It can give you a live view of all processes working with the Registry.
    It might surprise you how often the Registry is used!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注册表本身是你计算机存储介质上的文件集合。毕竟，数据需要存储在某处。这些文件存储的位置并不保密。例如，你可以在`%UserProfile%\Local
    Settings\Application Data\Microsoft\Windows`文件夹中的`UsrClass.dat`文件中找到`HKEY_LOCAL_USER`设置。然而，我不建议你自己随意操作这些文件。使用工具。上述的注册表编辑器是读取和更改设置的好方法。如果你想在你的软件中这样做，请使用BCL和Win32
    API提供的工具。如果你对运行时注册表发生的事情感到好奇，SysInternals提供的免费Process Monitor工具是无价的。它可以实时查看所有与注册表协同工作的进程。可能会让你惊讶注册表被使用的频率有多高！
- en: Keep it minimal
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持最小化
- en: 'The Registry is not meant to store large amounts of data. It is for smaller
    items, such as settings and preferences. Use it wisely: do not store too much
    data there. A good solution would be to have larger amounts of data stored in
    a file and store the location of that file in the Registry in a well-known place.
    This way, you can differentiate between different users (since the Registry keeps
    track of the user and presents you with the correct `HKEY_LOCAL_USER` instance)
    but still have a place to store more data.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表不是为了存储大量数据而设计的。它是用于存储较小的项目，如设置和首选项。明智地使用它：不要在那里存储太多数据。一个好的解决方案是将大量数据存储在文件中，并在注册表中以一个已知的位置存储该文件的存储位置。这样，你可以区分不同的用户（因为注册表跟踪用户并向你展示正确的`HKEY_LOCAL_USER`实例），但仍然有一个地方可以存储更多数据。
- en: Logging is your friend
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录日志是你的朋友
- en: Loggings is always a great tool when debugging your code, but this is especially
    true when dealing with the Registry. When something goes wrong, logs can be a
    lifesaver. Next to that, logs can help you understand your software’s flow and
    clarify why specific paths in your code were taken. When developing, you can never
    have too many log files. However, you might want to turn down the amount and verbosity
    of your logs when you go into production.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志始终是调试代码时的一个好工具，但当你处理注册表时，这一点尤其正确。当出现问题的时候，日志可以救命。除此之外，日志可以帮助你理解你的软件流程，并阐明为什么你的代码中采取了特定的路径。在开发过程中，你永远不会拥有太多的日志文件。然而，当你进入生产环境时，你可能希望减少日志的数量和详细程度。
- en: Error handling
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling should be a no-brainer. Use try-catch blocks as much as you can.
    Do not catch the generic `Exception` class, but be specific. After all, the *only
    catch the exceptions you can handle* rule is still valid.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理应该是不言而喻的。尽可能多地使用try-catch块。不要捕获通用的`Exception`类，而要具体。毕竟，*只捕获你能处理的异常*规则仍然有效。
- en: Software that works with the Registry might encounter exceptions such as `SecurityException`,
    `IOException`, and `UnauthorizedAccessException`. Be mindful of those. Catch them
    and return your software in a known state before continuing the flow.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与注册表协同工作的软件可能会遇到诸如`SecurityException`、`IOException`和`UnauthorizedAccessException`等异常。请注意这些异常。在继续流程之前，捕获它们并使你的软件返回到一个已知的状态。
- en: Also, please log these instances!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记录这些实例！
- en: Test in an isolated environment
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在隔离环境中进行测试
- en: When dealing with the more risky areas of the Registry, you might want to do
    that on a different machine than your daily device. You do not need to switch
    to a different machine but can use other techniques. You can quickly deploy a
    **virtual machine** (**VM**) locally or in the cloud. With Azure, making a VM
    and deploying and running your code is extremely easy. If it all works, that’s
    fine. If it doesn’t, all you have to do is delete the VM and try again.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理注册表的更危险区域时，你可能想在不同于日常设备的另一台机器上操作。你不需要切换到另一台机器，但可以使用其他技术。你可以在本地或云中快速部署一个 **虚拟机**（**VM**）。使用
    Azure，创建 VM、部署和运行你的代码非常简单。如果一切顺利，那就没问题。如果不顺利，你只需要删除 VM 再试一次。
- en: Another good approach is to use Docker. If you switch Docker from Linux containers
    to Windows containers, you can deploy your Worker Services to Docker and then
    work on the isolated, local Registry in that container. If it goes wrong, no harm
    is done. If you also log to a persistent file stored outside the container so
    that it lives on after the container crashes, you can do a post-mortem conveniently.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好方法是使用 Docker。如果你将 Docker 从 Linux 容器切换到 Windows 容器，你就可以将你的 Worker 服务部署到 Docker
    中，然后在容器中的隔离、本地注册表中工作。如果出了问题，也不会造成伤害。如果你还记录到一个存储在容器外部的持久文件，以便在容器崩溃后它仍然存在，你可以方便地进行事后分析。
- en: Potential risks when dealing with WMI
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 WMI 时的潜在风险
- en: WMI can be very powerful. You can query your system without having to resort
    to the Registry. You can also change settings, start services, configure network
    settings, and much more.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 可以非常强大。你可以查询你的系统而无需求助于注册表。你还可以更改设置、启动服务、配置网络设置等等。
- en: However, WMI is not easy. The documentation is out there, but you must look
    for it and piece it together yourself. However, there are some tips and tricks
    I can give you to get up to speed with WMI and use it to your advantage.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，WMI 并不容易。文档是有的，但你必须自己寻找并拼凑起来。不过，我可以给你一些提示和技巧，帮助你快速掌握 WMI 并利用它。
- en: Start with the basics
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从基础知识开始
- en: Know your **WMI Query Language** (**WQL**). It is a bit like SQL for the WMI
    system. Since you often pass in the queries to the WMI in strings, you should
    be careful not to make typos. They are notoriously hard to spot. Knowing the syntax
    of WQL can help in those cases.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的 **WMI 查询语言**（**WQL**）。它有点像 WMI 系统的 SQL。由于你经常以字符串的形式将查询传递给 WMI，你应该小心不要犯拼写错误。它们很难被发现。了解
    WQL 的语法可以帮助你解决这些问题。
- en: One often-made mistake is not using the correct namespace when querying the
    system. Although most queries run against the `ROOT\CMIV2` namespace, not all
    do. Make sure you use the correct namespace.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 常犯的一个错误是在查询系统时没有使用正确的命名空间。尽管大多数查询都是针对 `ROOT\CMIV2` 命名空间运行的，但并非所有都是。确保你使用正确的命名空间。
- en: Use the right tools
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正确的工具
- en: When learning about WMI, you might want to play around with it first. There
    is an almost unknown tool that comes with Windows called `WBEMTest`. You can start
    that by entering that term into the **Search** field in Windows.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习关于 WMI 的知识时，你可能想先玩一玩。Windows 中有一个几乎鲜为人知的小工具，叫做 `WBEMTest`。你可以在 Windows 的
    **搜索** 字段中输入该术语来启动它。
- en: 'This tool is a quick entry into the WMI. The user interface looks like it comes
    straight out of Windows 95, but it is a nice way to investigate WMI. For instance,
    if I want to know more about my BIOS vendor, I can use the code we looked at before
    or enter that in `WBEMTest`. That looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是快速进入 WMI 的一个途径。用户界面看起来像是直接从 Windows 95 出来的，但它是调查 WMI 的好方法。例如，如果我想了解更多关于我的
    BIOS 供应商的信息，我可以使用我们之前看过的代码，或者在 `WBEMTest` 中输入它。它看起来像这样：
- en: "![Figure \uFEFF\uFEFF7.5: WBEMTest querying the BIOS](img/B20924_08_05.jpg)"
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：WBEMTest 查询 BIOS](img/B20924_08_05.jpg)'
- en: 'Figure 7.5: WBEMTest querying the BIOS'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：WBEMTest 查询 BIOS
- en: This image shows `WBEMTest` in action. In the top left corner, I connected the
    app to the `ROOT\CMIV2` namespace. Then, I clicked on `SELECT * FROM Win32_BIOS`
    query. I got the results you see in the bottom right window.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片展示了 `WBEMTest` 的实际应用。在左上角，我将应用程序连接到了 `ROOT\CMIV2` 命名空间。然后，我点击了 `SELECT *
    FROM Win32_BIOS` 查询。你可以在右下角的窗口中看到结果。
- en: 'Powershell is also a great way to interact with WMI before incorporating WMI
    into your system. You can use the `Get-WMIObject` cmdlets to interrogate the system.
    For instance, getting the information about the BIOS results in the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 也是在将 WMI 集成到系统之前与 WMI 交互的绝佳方式。你可以使用 `Get-WMIObject` cmdlets 来查询系统。例如，获取
    BIOS 的信息会导致以下结果：
- en: "![Figure \uFEFF7.6: Get-WMIObject in PowerShell](img/B20924_08_06.jpg)"
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：PowerShell中的Get-WMIObject](img/B20924_08_06.jpg)'
- en: 'Figure 7.6: Get-WMIObject in PowerShell'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：PowerShell中的Get-WMIObject
- en: As you can see, I can enter `Get-WMIObject`, then pass the name of the object
    I want to interrogate (`Win32_Bios`), and I get all results nicely formatted.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我可以输入`Get-WMIObject`，然后传递我想查询的对象的名称（`Win32_Bios`），然后我会得到所有格式良好的结果。
- en: Improve your code
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高你的代码
- en: 'The tips I gave you for handling the Registry also apply here: catch the right
    exceptions and log as much as possible.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我给出的处理注册表的技巧也适用于这里：捕获正确的异常并尽可能多地记录。
- en: The most seen exception when working with WMI is `ManagementException`. Of course,
    we also saw queries not supported on specific platforms. Be aware of those issues
    and handle them appropriately.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用WMI时最常见的异常是`ManagementException`。当然，我们也看到了在特定平台上不支持查询的情况。注意这些问题，并适当处理。
- en: Logging is also a great way to debug your WMI code. Log as much as you can during
    development to know what is happening when things go south.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志也是调试你的WMI代码的绝佳方式。在开发过程中尽可能多地记录，以便在事情出错时知道发生了什么。
- en: Performance and memory considerations
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能和内存考虑
- en: As systems programmers, we care deeply about performance and memory usage. WMI
    can significantly slow down your app. Especially when polling too often, you will
    see a degradation of your performance. Avoid frequent polling. You do not need
    to check the temperature every millisecond, anyway.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统程序员，我们非常关注性能和内存使用。WMI可能会显著减慢你的应用程序。特别是当频繁轮询时，你会看到性能的下降。避免频繁轮询。你根本不需要每毫秒都检查温度。
- en: Also, do not forget to dispose of all CLR classes dealing with the WMI properly.
    If handles to those classes remain open too long, you might exhaust the available
    resources. That is a great way to bring your system to a screeching halt. Let’s
    not do that!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了妥善处理所有与WMI相关的CLR类。如果那些类的句柄保持打开时间过长，你可能会耗尽可用资源。这是让你的系统突然停止的绝佳方法。让我们不要这么做！
- en: 'One final note: WMI relies on the WMI service. Yes, that is a Windows Service.
    If that service is not running, WMI does not work. That will not likely ever happen,
    but that situation might occur. So, if things do not work as you expect, please
    also check that service.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：WMI依赖于WMI服务。是的，那是一个Windows服务。如果该服务没有运行，WMI将无法工作。这种情况不太可能发生，但可能会发生。所以，如果事情没有按预期进行，请也检查那个服务。
- en: Of course, all other tips and tricks I gave you throughout this book also apply.
    There is nothing magical about WMI, Worker Services, and the Registry. It is just
    that they might need a bit more attention to avoid getting into weird situations.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我在这本书中给出的所有其他技巧和窍门也适用。WMI、Worker Services和注册表并没有什么神奇之处。只是它们可能需要更多的关注，以避免陷入奇怪的情况。
- en: Next steps
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Windows gives you many tools to use. These tools are deeply integrated into
    the system. Most of them are never used by applications used by users. But for
    us, as systems programmers, this is different. We are working closer to the metal,
    so it is good to know what that metal offers us.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Windows为你提供了许多工具。这些工具与系统深度集成。其中大多数工具用户的应用程序几乎从未使用过。但对我们这些系统程序员来说，情况就不同了。我们更接近底层工作，所以了解底层能提供什么是有好处的。
- en: I suggest you play with the Registry Editor and see what hidden gems you can
    find there. Next to that, learn WQL. Many tools offer a nice interface to the
    WMI, but in the end, you will have WQL strings in your application. You might
    as well start to learn about them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你玩玩注册表编辑器，看看你能在那里找到什么隐藏的宝藏。在那旁边，学习WQL。许多工具都提供了对WMI的友好界面，但最终，你会在你的应用程序中拥有WQL字符串。你不妨开始了解它们。
- en: Finally, learn Docker. Docker is a great way to package your applications and
    a valuable debugging tool. You can use Docker to isolate your potentially dangerous
    code. If things go wrong, all you need to do is delete the running container and
    start again. Of course, everything we discussed in this chapter is only available
    on Windows, so you must use Windows containers on Docker. When you are sure your
    code works fine, you can use it on real Windows machines.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，学习Docker。Docker是打包应用程序的绝佳方式，也是一款宝贵的调试工具。你可以使用Docker来隔离可能危险的代码。如果出了问题，你只需要删除正在运行的容器并重新开始。当然，我们本章讨论的所有内容都仅在Windows上可用，所以你必须使用Docker上的Windows容器。当你确定你的代码运行正常时，你可以在真实的Windows机器上使用它。
- en: In this chapter, we looked at all the tools that Windows give us; tools we can
    use in our code to do things that are hard to do if we had to write everything
    ourselves. We learned about the centralized settings storage mechanism called
    the Registry.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Windows为我们提供的所有工具；我们可以在代码中使用这些工具来完成如果我们必须自己编写一切时难以完成的事情。我们学习了被称为注册表的集中式设置存储机制。
- en: We also learned about the ways we can query the OS and even the underlying hardware
    through the use of WMI. We talked about how to use them and we talked about how
    to avoid some of the risks involved.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了我们可以通过使用WMI来查询操作系统甚至底层硬件的方法。我们讨论了如何使用它们，以及如何避免其中的一些风险。
- en: Now, with these skills under our belt, it is time to escape the confinement
    of the single machine and venture into the land of networking. Systems these days
    rarely run in isolation on one machine. They communicate. They talk to each other.
    We should be looking into networking next. So, hook up your dial-up modem and
    follow along for the road down the network protocols!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们掌握了这些技能，是时候摆脱单机的限制，进入网络的世界了。现在的系统很少在单个机器上独立运行。它们会进行通信。它们会互相交谈。我们应该开始关注网络。所以，连接你的拨号调制解调器，跟随我们探索网络协议的道路！
