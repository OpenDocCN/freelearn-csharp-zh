<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with NGUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with NGUI</h1></div></div></div><p>In this first chapter, we will talk about the overall workflow of NGUI before we import the plugin and create our first UI. Then we will look into the UI's structure, important parameters, and general behavior.</p><div class="section" title="What is NGUI?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is NGUI?</h1></div></div></div><p>The <span class="strong"><strong>Next-Gen User Interface</strong></span> kit <a id="id0" class="indexterm"/>is a plugin for Unity 3D. It has the great advantage of being easy to use, very powerful, and optimized compared to Unity's built-in GUI system, <span class="strong"><strong>UnityGUI</strong></span>. Since<a id="id1" class="indexterm"/> it is written in C#, it is easily understandable and you may tweak it or add your own features, if necessary.</p><p>The <span class="strong"><strong>NGUI Standard License</strong></span>
<a id="id2" class="indexterm"/> costs $95. With this, you will have useful example scenes included. I recommend this license to start comfortably—a free evaluation version is available, but it is limited, outdated, and not recommended.</p><p>The <span class="strong"><strong>NGUI Professional License</strong></span>
<a id="id3" class="indexterm"/>, priced at $200, gives you access to NGUI's GIT repository to access the latest beta features and releases in advance.</p><p>A $2000 <span class="strong"><strong>Site License</strong></span>
<a id="id4" class="indexterm"/> is available for an unlimited number of developers within the same studio.</p><p>Let's have an overview of the main features of this plugin and see how they work.</p><div class="section" title="UnityGUI versus NGUI"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>UnityGUI versus NGUI</h2></div></div></div><p>With Unity's GUI, <a id="id5" class="indexterm"/>you must create the entire UI in code by adding lines that display labels, textures, or any other UI element on the screen. These lines have to be written inside a special function, <code class="literal">OnGUI()</code>, that is called for every frame. This is no longer necessary; with NGUI, UI elements are simple GameObjects!</p><p>You can create widgets—this is what NGUI calls labels, sprites, input fields, and so on—move them, rotate them, and change their dimensions using handles or the Inspector. Copying, pasting, creating prefabs, and every other useful feature of Unity's workflow is also available.</p><p>These widgets<a id="id6" class="indexterm"/> are viewed by a camera and rendered on a layer that you can specify. Most of the parameters are accessible through Unity's Inspector, and you can see what your UI looks like directly in the Game window, without having to hit the Play button.</p></div><div class="section" title="Atlases"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Atlases</h2></div></div></div><p>Sprite<a id="id7" class="indexterm"/>s and fonts are all contained in a large texture called atlas. With only a few clicks, you can easily create and edit your atlases. If you don't have any images to create your own UI assets, simple default atlases come with the plugin.</p><p>That system means that for a complex UI window composed of different textures and fonts, the same material and texture will be used when rendering. This results in only one draw call for the entire window. This, along with other optimizations, makes NGUI the perfect tool to work on mobile platforms.</p></div><div class="section" title="Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Events</h2></div></div></div><p>NGUI also <a id="id8" class="indexterm"/>comes with an easy-to-use event framework that is written in C#. The plugin comes with a large number of additional components that you can attach to GameObjects. These components can perform advanced tasks depending on which events are triggered: hover, click, input, and so on. Therefore, you may enhance your UI experience while keeping it simple to configure. Code less, get more!</p></div><div class="section" title="Localization"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Localization</h2></div></div></div><p>NGUI comes<a id="id9" class="indexterm"/> with its own localization system, enabling you to easily set up and change your UI's language with the push of a button. All your strings are located in the <code class="literal">.txt</code> files: one file per language.</p></div><div class="section" title="Shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Shaders</h2></div></div></div><p>Lighting, <a id="id10" class="indexterm"/>normal mapping, and refraction shaders are supported in NGUI, which can give you beautiful results. Clipping is also a shader-controlled feature with NGUI, used for showing or hiding specific areas of your UI.</p><p>We've now covered what NGUI's main features are, and how it can be useful to us as a plugin, and now it's time to import it inside Unity.</p></div></div></div>
<div class="section" title="Importing NGUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Importing NGUI</h1></div></div></div><p>After<a id="id11" class="indexterm"/> buying the product from the Asset Store or getting the evaluation version, you have to download it. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new Unity project.</li><li class="listitem">Navigate to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Asset Store</strong></span>. Select your download library.</li><li class="listitem">Click on the <span class="strong"><strong>Download</strong></span> button next to <span class="strong"><strong>NGUI: Next-Gen UI</strong></span>.</li><li class="listitem">When the download completes, click on the NGUI icon / product name in the library to access the product page.</li><li class="listitem">Click on the <span class="strong"><strong>Import</strong></span> button and wait for a pop-up window to appear.</li><li class="listitem">Check the checkbox for <span class="strong"><strong>NGUI v.3.0.2.unitypackage</strong></span> and click on <span class="strong"><strong>Import</strong></span>.</li><li class="listitem">In the Project view, navigate to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>NGUI</strong></span> and double-click on <span class="strong"><strong>NGUI v.3.0.2</strong></span>.</li><li class="listitem">A new imported pop-up window will appear. Click on <span class="strong"><strong>Import</strong></span> again.</li><li class="listitem">Click any button on the toolbar to refresh it. The NGUI tray will appear!</li></ol></div><p>The NGUI tray will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/8667OT_01_01.jpg" alt="Importing NGUI"/></div><p>You have now successfully imported NGUI to your project. Let's create your first 2D UI.</p></div>
<div class="section" title="Creating your UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating your UI</h1></div></div></div><p>We will <a id="id12" class="indexterm"/>now create our first 2D user interface<a id="id13" class="indexterm"/> with NGUI's UI Wizard. This wizard will add all the elements needed for NGUI to work.</p><p>Before we continue, please save your scene as <code class="literal">Menu.unity</code>.</p><div class="section" title="UI Wizard"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>UI Wizard</h2></div></div></div><p>Create your<a id="id14" class="indexterm"/> UI by opening the UI Wizard by navigating to <span class="strong"><strong>NGUI</strong></span> | <span class="strong"><strong>Open</strong></span> | <span class="strong"><strong>UI Wizard</strong></span> from the toolbar. Let's now take a look at the UI Wizard window and its parameters.</p><div class="section" title="Window"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Window</h3></div></div></div><p>You should <a id="id15" class="indexterm"/>now have the following pop-up window with two parameters:</p><div class="mediaobject"><img src="graphics/8667OT_01_02.jpg" alt="Window"/></div></div><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Parameters</h3></div></div></div><p>The two<a id="id16" class="indexterm"/> parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layer</strong></span>: This is the layer on which your UI will be displayed</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Camera</strong></span>: This will decide if the UI will have a camera, and its drop-down options are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>None</strong></span>: No camera will be created</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Simple 2D</strong></span>: Uses a camera with orthographic projection</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Advanced 3D</strong></span>: Uses a camera with perspective projection</li></ul></div></li></ul></div></div></div><div class="section" title="Separate UI Layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Separate UI Layer</h2></div></div></div><p>I recommend that<a id="id17" class="indexterm"/> you separate your UI from other usual layers. We should do it as shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on the drop-down menu next to the <span class="strong"><strong>Layer</strong></span> parameter.</li><li class="listitem">Select <span class="strong"><strong>Add Layer</strong></span>.</li><li class="listitem">Create a new layer and name it <code class="literal">GUI2D</code>.</li><li class="listitem">Go back to the UI Wizard window and select this new <span class="strong"><strong>GUI2D</strong></span> layer for your UI.</li></ol></div><p>You can now click on the <span class="strong"><strong>Create Your UI</strong></span> button. Your first 2DUI has been created!</p></div></div>
<div class="section" title="Your UI structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Your UI structure</h1></div></div></div><p>The wizard<a id="id18" class="indexterm"/> has created four new GameObjects on the scene for us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">UI Root (2D)</li><li class="listitem" style="list-style-type: disc">Camera</li><li class="listitem" style="list-style-type: disc">Anchor</li><li class="listitem" style="list-style-type: disc">Panel</li></ul></div><p>Let's now review each in detail.</p><div class="section" title="UI Root (2D)"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>UI Root (2D)</h2></div></div></div><p>The <a id="id19" class="indexterm"/>
<span class="strong"><strong>UIRoot</strong></span> component<a id="id20" class="indexterm"/> scales widgets down to keep them at a manageable size. It is also responsible for the <span class="strong"><strong>Scaling Style</strong></span>—it will either scale UI elements to remain pixel perfect or to occupy the same percentage of the screen, depending on the parameters you specify.</p><p>Select the <span class="strong"><strong>UI Root (2D)</strong></span> GameObject in the Hierarchy. It has the <code class="literal">UIRoot.cs</code> script attached to it. This script adjusts the scale of the GameObject it's attached to in order to let you specify widget coordinates in pixels, instead of Unity units as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8667OT_01_03.jpg" alt="UI Root (2D)"/></div><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Parameters</h3></div></div></div><p>The <span class="strong"><strong>UIRoot</strong></span> component<a id="id21" class="indexterm"/> has four parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scaling Style</strong></span>: The following are the available scaling styles:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PixelPerfect</strong></span>: This will ensure that your UI will always try to remain at the same size in pixels, no matter what resolution. In this scaling mode, a 300 x 200 window will be huge on a 320 x 240 screen and tiny on a 1920 x 1080 screen. That also means that if you have a smaller resolution than your UI, it will be cropped.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FixedSize</strong></span>: This will ensure that your UI will be proportionally resized depending on the screen's height. The result is that your UI will not be pixel perfect but will scale to fit the current screen size.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FixedSizeOnMobiles</strong></span>: This will ensure fixed size on mobiles and pixel perfect everywhere else.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manual Height</strong></span>: With the <span class="strong"><strong>FixedSize</strong></span> scaling style, the scale will be based on this height. If your screen's height goes over or under this value, it will be resized to be displayed identically while maintaining the aspect ratio (width/height proportional relationship).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Minimum Height</strong></span>: With the <span class="strong"><strong>PixelPerfect</strong></span> scaling style, this parameter defines the <a id="id22" class="indexterm"/>minimum height for the screen. If your screen height goes below this value, your UI will resize. It will be as if the <span class="strong"><strong>Scaling Style</strong></span> parameter was set to <span class="strong"><strong>FixedSize</strong></span> with <span class="strong"><strong>Manual Height</strong></span> set to this value.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Maximum Height</strong></span>: With the <span class="strong"><strong>PixelPerfect</strong></span> scaling style, this parameter defines the maximum height for the screen. If your screen height goes over this value, your UI will resize. It will be as if the <span class="strong"><strong>Scaling Style</strong></span> parameter was set to <span class="strong"><strong>FixedSize</strong></span> with <span class="strong"><strong>Manual Height</strong></span> set to this value.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Please set the <span class="strong"><strong>Scaling Style</strong></span> parameter to <span class="strong"><strong>FixedSize</strong></span> with a <span class="strong"><strong>Manual Height</strong></span> value of 1080. This will allow us to have the same UI on any screen size up to 1920 x 1080.</p></div></div></li></ul></div><p>Even though the UI will look the same on different resolutions, the <span class="strong"><strong>aspect ratio</strong></span> is still a problem since the rescale is based on the screen's height only. If you want to cover both 4:3 and 16:9 screens, your UI should not be too large—try to keep it square. Otherwise, your UI might be cropped on certain screen resolutions.</p><p>On the other hand, if you want a 16:9 UI, I recommend you force this aspect ratio only. Let's do it now for this project by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Inspector</strong></span> option, unfold the <span class="strong"><strong>Resolution and Presentation</strong></span> group.</li><li class="listitem">Unfold the <span class="strong"><strong>Supported Aspect Ratios</strong></span> group.</li><li class="listitem">Check only the <span class="strong"><strong>16:9</strong></span> box.</li></ol></div><p>Now that we have seen the UI Root's different parameters, let's discuss the camera.</p></div></div><div class="section" title="Camera"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Camera</h2></div></div></div><p>Select the<a id="id23" class="indexterm"/> <span class="strong"><strong>Camera</strong></span> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. It has the <a id="id24" class="indexterm"/>
<code class="literal">UICamera.cs</code> script attached to it. This script must be attached to any camera that needs to interact with your UI.</p><p>Its purpose is to send different messages concerning events that happen to UI elements such as colliders attached to a button. Some of the more frequently used events are <code class="literal">OnClick()</code> and <code class="literal">OnHover()</code>.</p><p>You may have multiple cameras if you consider it necessary; for example, you can have an orthographic camera for 2D in-game UI elements and a separate perspective camera for a 3D pause menu.</p><p>For the purpose of this book, we will stick with only one camera.</p><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Parameters</h3></div></div></div><p>The <code class="literal">UICamera.cs</code> script <a id="id25" class="indexterm"/>has a large number of parameters as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8667OT_01_04.jpg" alt="Parameters"/></div><p>These<a id="id26" class="indexterm"/> parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Event Type</strong></span>: Select which event type this camera will send.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>World</strong></span>: This is used for interacting with 3D-world GameObjects</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UI</strong></span>: This is used for interacting with the 2D UI</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Event Mask</strong></span>: Select which layer will be used to receive events.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In our case, we will set it to <span class="strong"><strong>GUI2D</strong></span> since our UI will reside on it.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Debug</strong></span>: This consists of the enable or disable debug mode options. This option is useful when you have unwanted behavior.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enabled: When <span class="strong"><strong>Debug</strong></span> is enabled, the currently hovered object will be displayed on the top left-hand corner of the screen</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Allow Multi Touch</strong></span>: This consists of the enable or disable touch mode options that allow simultaneous touches. This is mandatory if you want to use pinch-to-zoom or other such gestures on mobile platforms.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sticky Press</strong></span>: <a id="id27" class="indexterm"/>This consists of the enable or disable sticky press mode options.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enabled: If you drag your finger out of a pressed button, it will remain in the pressed state and no other element will receive upcoming events from that finger until it is released</li><li class="listitem" style="list-style-type: disc">Disabled: If you drag your finger out of a pressed button, it will no longer be pressed and other elements will receive upcoming events from that finger</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sticky Tooltip</strong></span>: It consists of the enable or disable sticky tool tip mode options.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enabled: The tool tip disappears when the mouse moves out of the widget</li><li class="listitem" style="list-style-type: disc">Disabled: The tool tip disappears as soon as the mouse moves</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tooltip Delay</strong></span>: It consists of the required stationary time in seconds before the widget's tool tip is displayed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Raycast Range</strong></span>: A raycast is an invisible ray that is cast from one point towards a specific direction and is stopped if it encounters another object. The camera uses raycasts from the mouse or touch position towards the camera's forward direction to detect collisions and handle events. You may set the range of this raycast if you need to limit the interaction to a certain range. The default <span class="strong"><strong>-1</strong></span> value implies that the raycast's range will be as far as the camera can see.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Event Sources</strong></span>: These Booleans let you specify what events this camera listens to.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mouse</strong></span>: This is used for mouse movements, left/right/middle click, and scroll wheel.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Touch</strong></span>: This is used for touch-enabled devices.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Keyboard</strong></span>: This is used for keyboard input. It uses the <code class="literal">OnKey()</code> event.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Controller</strong></span>: This is used for joystick-based devices. It uses the <code class="literal">OnKey()</code> event.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Thresholds</strong></span>: These values come in handy when you want to specify the minimum values before a particular event is triggered. This may vary from one game/app to another.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mouse Drag</strong></span>: When a mouse button is pressed (the <code class="literal">OnPress()</code> event is triggered), this value determines how far in pixels the mouse must move before it is considered a drag, and sends <code class="literal">OnDrag()</code> events to the dragged object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mouse Click</strong></span>: When a mouse button is pressed (the <code class="literal">OnPress()</code> event is triggered), this value determines how far in pixels the mouse can travel before the button release has no effect (the <code class="literal">OnClick()</code> event is not triggered)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Touch Drag</strong></span>: This is the same as <span class="strong"><strong>Mouse Drag</strong></span>, but for touch-based devices</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Touch Tap</strong></span>: This is the same as <span class="strong"><strong>Mouse Click</strong></span>, but for touch-based devices</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Axes and Keys</strong></span>: These <a id="id28" class="indexterm"/>parameters let you assign Unity input axes and keys to NGUI's input system.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Horizontal</strong></span>: This is the input axis for horizontal movement (the left and right key events)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertical</strong></span>: This is the input axis for vertical movement (the up and down key events)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scroll</strong></span>: This is the input axis for scrolling</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Submit 1</strong></span>: This is the primary keycode for validation</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Submit 2</strong></span>: This is the secondary keycode for validation</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cancel 1</strong></span>: This is the primary keycode for cancel.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cancel 2</strong></span>: This is the secondary keycode for cancel.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>You can edit Unity inputs at any time by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Input</strong></span>.</p></div></div></li></ul></div><p>Ok, we have seen what the main parameters of the <code class="literal">UICamera</code> component are. We have to see what the camera's anchor child is.</p></div></div><div class="section" title="Anchor"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Anchor</h2></div></div></div><p>An<a id="id29" class="indexterm"/> anchor is used to attach GameObjects to the same area<a id="id30" class="indexterm"/> inside the camera view. For example, you can attach them to borders or corners of the screen, or another widget.</p><p>Select the <span class="strong"><strong>Anchor</strong></span> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. It has the <span class="strong"><strong>UIAnchor</strong></span> component attached to it. It is configured to center content on the screen based on the parent camera.</p><p>Before we create widgets, we must understand how these <span class="strong"><strong>UIAnchor</strong></span> parameters modify their placement behavior.</p><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Parameters</h3></div></div></div><p>The <span class="strong"><strong>UIAnchor</strong></span> component<a id="id31" class="indexterm"/> has seven parameters as seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/8667OT_01_05.jpg" alt="Parameters"/></div><p>These parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ui Camera</strong></span>: This is the reference camera from which our anchor bounds are determined. By default, it is set to the camera used by the UI.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Container</strong></span>: If you drag and drop a GameObject in this field, it will overwrite the camera anchoring. This can be useful if you need to anchor your panels or widgets based on a container GameObject, instead of a camera. Your content will be placed using the assigned container's position.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Side</strong></span>: Do you want your child GameObjects to be centered or attached to one side or corner of your referenced camera/container? You can choose your anchor point here.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Half Pixel Offset</strong></span>: You should leave this Boolean checked. It makes widget positions pixel perfect on Windows machines.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Run Only Once</strong></span>: This Boolean can be checked if your screen resolution never changes, or if you want it to remove it on start. As a result, your anchor will be executed at the start and then removed and no longer be updated.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Relative Offset</strong></span>: This <code class="literal">Vector2</code> class takes two values between -1 and 1 to add a relative offset to the final position. With a value of 0.12 for <span class="strong"><strong>X</strong></span> and 0.32 for <span class="strong"><strong>Y</strong></span>, it will result in an offset of 12% horizontally and 32% vertically—it will look the same<span class="strong"><strong> </strong></span>on any resolution because the offset depends on the screen size.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pixel Offset</strong></span>: This parameter is like <span class="strong"><strong>Relative Offset</strong></span>, but it is absolute instead of relative. You can enter the offset in pixels—it will look different<span class="strong"><strong> </strong></span>depending on the resolution because the offset will stay identical in pixels on all screen sizes.</li></ul></div><p>We have <a id="id32" class="indexterm"/>explained the different <span class="strong"><strong>UIAnchor</strong></span> parameters, but what is this last child, Panel? Let's look into that, and we'll be ready to create our first widget!</p></div></div><div class="section" title="Panel"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Panel</h2></div></div></div><p>Select <a id="id33" class="indexterm"/>the <span class="strong"><strong>Panel</strong></span> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. It has a <span class="strong"><strong>UIPanel</strong></span> component attached.</p><p>A panel's purpose <a id="id34" class="indexterm"/>is to hold widgets and render geometry in only one draw call. You may create multiple panels to split your UI, but it will add a draw call per new panel.</p><div class="section" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Parameters</h3></div></div></div><p>The <a id="id35" class="indexterm"/>
<code class="literal">UIPanel.cs</code> script has eight parameters as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8667OT_01_06.jpg" alt="Parameters"/></div><p>These parameters<a id="id36" class="indexterm"/> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Alpha</strong></span>: You may change the <span class="strong"><strong>transparency level</strong></span><a id="id37" class="indexterm"/> of the entire panel. All child widgets will be affected by this alpha value, but nested panels won't.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Depth</strong></span>: This is used to define which panel is rendered over another. A panel with a depth value of 1 will appear in front of a panel with a depth value of 0. You can use either the <span class="strong"><strong>Back</strong></span> or <span class="strong"><strong>Forward</strong></span> button to change the <span class="strong"><strong>Depth</strong></span> or simply enter a number in the field. Panels can also have negative depth.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Normals</strong></span>: This Boolean must be checked if you need it to react to lighting<span class="strong"><strong> </strong></span>using shaders. It will calculate normals for your UI geometry.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cull</strong></span>: This Boolean gives you the ability to disable the child widgets rendering while the panel is being dragged, which improves performance.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Static</strong></span>: If all your panel's widgets are static and won't ever move, check this—it will improve performance!</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Show All</strong></span>: This <a id="id38" class="indexterm"/>will show all draw calls in the <span class="strong"><strong>Inspector</strong></span> view.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Panel Tool</strong></span>: This is a panel managing tool. You can visualize and select each panel in the scene. You can open it with <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span> or navigate to <span class="strong"><strong>NGUI</strong></span> | <span class="strong"><strong>Open</strong></span> | <span class="strong"><strong>Panel Tool</strong></span>. Will this panel show in the <span class="strong"><strong>Panel Tool</strong></span> parameter? This should be unchecked for dynamically created temporary panels through code, like a warning message or ammo pick-up notification.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Clipping</strong></span>: This will let us hide widgets outside a given rectangle. When turned on, you will be able to choose the clipping rectangle's dimensions with the <code class="literal">Center</code> and <code class="literal">Size</code> parameters. Anything outside this rectangle will be hidden.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>None</strong></span>: No clipping—the entire panel will be displayed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hard Clip</strong></span>: Clipping enabled—rough clipping of widgets outside the box.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Soft Alpha</strong></span>: Clipping enabled—soft clipping with fade-out / fade-in borders.</li></ul></div><p>We've now taken a look at the parameters of the <span class="strong"><strong>UIPanel</strong></span> component, which will be used to hold our widgets.</p></li></ul></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>During this chapter, we discussed NGUI's basic workflow—it works with GameObjects, uses atlases to combine multiple textures in one large texture, has an event system, can use shaders, and has a localization system.</p><p>After importing the NGUI plugin, we created our first 2D UI with the UI Wizard, reviewed its parameters, and created our own GUI 2D layer for our UI to reside on.</p><p>Finally, we analyzed the four GameObjects that were created automatically for us by NGUI. After reviewing their parameters, we can summarize their roles as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>UI Root</strong></span> holds the UI and scales it for pixel perfect or fixed sizes</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Camera</strong></span> views the UI and sends messages to the widgets for interactions</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Anchor</strong></span> can attach elements to the borders of screen or objects and add offsets</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Panel</strong></span> holds our widgets and renders them, with or without clipping</li></ul></div><p>We are now ready to create our first widget. It's time to move on to the next chapter.</p></div></body></html>