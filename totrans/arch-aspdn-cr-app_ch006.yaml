- en: 5 Minimal API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter covers Minimal APIs, a simplified way of setting up and running
    .NET applications. We explore what makes Minimal Hosting and Minimal APIs a pivotal
    update in ASP.NET Core as we unravel the simplicity of creating APIs with less
    ceremony. We cover many possibilities that ASP.NET Core Minimal API brings, like
    how to configure, customize, and organize those endpoints.We also explore using
    Minimal APIs with Data Transfer Objects (DTOs), combining simplicity with effective
    data management to structure API contracts effectively.Inspired by other technologies,
    these topics bring a fresh perspective to the .NET world, allowing us to build
    lean and performant APIs without compromising resiliency.In this chapter, we cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Top-level statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal Hosting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Minimal APIs with Data Transfer Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin with Top-level statements.
  prefs: []
  type: TYPE_NORMAL
- en: Top-level statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The .NET team introduced top-level statements to the language in .NET 5 and
    C# 9\. From that point, writing statements before declaring namespaces and other
    members is possible. Under the hood, the compiler emits those statements into
    a `Program.Main` method.With top-level statements, a minimal .NET “Hello World”
    console program looked like this (`Program.cs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we still need a project to run it, so we have to create a `.csproj`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we can use the .NET CLI to `dotnet run` the application, and it
    will output the following in the console before the program terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On top of such statements, we can also declare other members, like classes,
    and use them in our application. However, we must declare classes at the end of
    the top-level code.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the top-level statement code is not part of any namespace, and
    creating classes in a namespace is recommended, so you should limit the number
    of declarations done in the `Program.cs` file to what is internal to its inner
    workings, if anything.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Top-level statements are great for getting started with C#, writing code samples,
    and cutting out boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted line of the preceding C# code (`using System;`) is unnecessary
    when the *implicit usings* feature is enabled, which is the default in .NET 6+
    projects. The templates add the following line to the `.csproj` file:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we explore the minimal hosting model built using top-level statements.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal Hosting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET 6 introduced the minimal hosting model. It combines the `Startup` and
    `Program` classes into a single `Program.cs` file. It leverages top-level statements
    to minimize the boilerplate code necessary to bootstrap the application. It also
    uses *global using directives* and the *implicit usings* feature to reduce the
    amount of boilerplate code further. This model only requires one file with the
    following three lines of code to create a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s call that way leaner than before. Of course, the preceding code starts
    an app that does nothing, but doing the same before would have required tens of
    lines of code.The minimal hosting code is divided into two pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: The *web application builder* we use to configure the application, register
    services, settings, environment, logging, and more (the highlighted code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *web application* we use to configure the HTTP pipeline and routes (the
    non-highlighted lines).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That simplified model led to minimal APIs that we explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core’s Minimal APIs are built on the minimal hosting model and bring
    a lean approach to constructing web applications. Highly inspired by Node.js,
    they facilitate the development of APIs by reducing the boilerplate code. By emphasizing
    simplicity and performance, they enhance readability and maintainability. They
    are an excellent fit for microservices architecture and applications that aim
    to remain lean.
  prefs: []
  type: TYPE_NORMAL
- en: You can also build large applications using Minimal APIs; the word minimal refers
    to their lean approach, not the type of application you can make with them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This minimalist approach does compromise a little on functionalities but improves
    flexibility and speed, ensuring you have complete control over your API’s behavior
    while keeping your project lean and efficient. Minimal APIs include the necessary
    features we need for most applications, like model binding, dependency injection,
    filters, and a route-to-delegate model. If you need all the features from MVC,
    you can still opt to use MVC. You can even use both; this is not one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: We explore the Model-View-Controller (MVC) pattern in *Chapter 6*, *MVC*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s have a look at how to map routes next.
  prefs: []
  type: TYPE_NORMAL
- en: Map route-to-delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How does it work? Minimal APIs bring multiple extension methods to configure
    the HTTP pipeline and configure endpoints. We can use those methods to map a route
    (a URL pattern) to a `RequestDelegate` delegate.We can use the following methods
    to map different HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `MapGet` | Maps a `GET` request to a `RequestDelegate` . |'
  prefs: []
  type: TYPE_TB
- en: '| `MapPost` | Maps a `POST` request to a `RequestDelegate` . |'
  prefs: []
  type: TYPE_TB
- en: '| `MapPut` | Maps a `PUT` request to a `RequestDelegate` . |'
  prefs: []
  type: TYPE_TB
- en: '| `MapDelete` | Maps a `DELETE` request to a `RequestDelegate` . |'
  prefs: []
  type: TYPE_TB
- en: '| `MapMethods` | Maps a route pattern and multiple HTTP methods to a `RequestDelegate`
    . |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | Maps a route pattern to a `RequestDelegate` . |'
  prefs: []
  type: TYPE_TB
- en: '| `MapFallback` | Maps a fallback `RequestDelegate` which runs when no other
    routes match. |'
  prefs: []
  type: TYPE_TB
- en: '| `MapGroup` | Allows configuring a route pattern and properties that apply
    to all endpoints defined under that group. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Map route-to-delegate extension methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a minimal GET example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the program, navigating to the `/minimal-endpoint-inline` URI
    routes the request to the registered `RequestDelegate` (highlighted code), which
    outputs the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As simple as that, we can route requests to delegates and create endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: On top of registering endpoints, we can also register middleware like any other
    ASP.NET Core application. Moreover, the built-in middlewares, like authentication
    and CORS, work the same with Minimal APIs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore ways to configure endpoints so we can create better APIs than
    an endpoint returning a literal string.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know that with minimal APIs, we map routes to delegates and that
    we have learned of a few methods to do that, let’s explore how to register the
    delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline, as with the preceding example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To declare the delegate inline, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a method, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When enabled, ASP.NET Core registers the class name that contains the method
    with the `ApiExplorer` as a tag. We dig deeper into metadata further in the chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All the concepts we explore in this chapter apply to both ways of registering
    delegates. Let’s start by studying how to input data in our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An endpoint rarely has no parameter (no input value). Minimal APIs, like MVC,
    support a wide variety of binding sources. A binding source represents the conversion
    from the HTTP request into a strongly typed C# object, inputted as a parameter.
    Most of the parameter binding happens implicitly, but in case you need to bind
    a parameter explicitly, here are the supported binding sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source** | **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Route` | `[FromRoute]` | Binds the route value that matches the name of
    the parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Query` | `[FromQuery]` | Binds the query string value that matches the name
    of the parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Header` | `[FromHeader]` | Binds the HTTP header value that matches the
    name of the parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Body` | `[FromBody]` | Binds the JSON body of the request to the parameter’s
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Form` | `[FromForm]` | Binds the form value that matches the name of the
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Services` | `[FromServices]` | Inject the service from the ASP.NET Core
    dependency container. |'
  prefs: []
  type: TYPE_TB
- en: '| `Custom` | `[AsParameters]` | Binds the form values to a type. The matches
    happen between the form keys and the properties'' names. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: supported binding sources'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is a demo where we implicitly bind the `id` parameter from the route (highlighted
    code) to a parameter in the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, the bindings work implicitly. However, you can explicitly bind
    the delegate’s parameters like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implicitly inject dependencies into our delegates and even mix
    that with a route parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Following this pattern opens endless possibilities to input data into our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with Dependency Injection (DI), we explore DI more in-depth
    in *Chapter 8*, *Dependency Injection*. Meanwhile, remember that we can bind objects
    to parameters, whether they are a DTO or a service.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On top of that, ASP.NET Core provides us with a few special types, which we
    explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Special types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can inject the following objects into our delegates as parameters, and ASP.NET
    Core manages them for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpContext` | The `HttpContext` encompasses all the current HTTP request
    and response details.The `HttpContext` exposes all the other special types we
    are exploring here, so if you need more than one, you can inject the `HttpContext`
    directly to reduce the number of parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpRequest` | We can use the `HttpRequest` to do basic HTTP operations
    on the current request, like query the parameters manually and bypass the ASP.NET
    Core data-binding mechanism. Same as the `HttpContext.Request` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpResponse` | Like the `HttpRequest` , we can leverage the `HttpResponse`
    object to execute manual operations on the HTTP response, like writing directly
    to the response stream, managing HTTP headers manually, etc. Same as the `HttpContext.Response`
    property. |'
  prefs: []
  type: TYPE_TB
- en: '| `CancellationToken` | Passing a cancellation token to an asynchronous operation
    is a recommended practice. In this case, it allows canceling the operation when
    the request is canceled. Same as the `HttpContext.RequestAborted` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `ClaimsPrincipal` | To access the current user, we can inject a `ClaimsPrincipal`
    instance. Same as the `HttpContext.User` property. |'
  prefs: []
  type: TYPE_TB
- en: 'Tabel 5.3: special HTTP types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example where two endpoints write to the response stream, one using
    the `HttpContext` and the other the `HttpResponse` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can treat those special types like any other bindings and seamlessly integrate
    them with other types, such as route values and services.We cover one last piece
    of data-binding next.
  prefs: []
  type: TYPE_NORMAL
- en: Custom binding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can manually bind data from the request to an instance of a custom class.
    We can achieve this in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a static `TryParse` method that parses a string from a route, query,
    or header value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a static `BindAsync` method that directly controls the binding process
    using the `HttpContext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must write those static methods in the class we intend to create using the
    HTTP request’s data. We explore those two scenarios next.
  prefs: []
  type: TYPE_NORMAL
- en: Manual parsing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `TryParse` method takes a string and an `out` parameter of the type itself.
    The framework uses that method to parse a value into the desired type.The parsing
    API supports the implementation of one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the `IParsable<TSelf>` interface provides the appropriate `TryParse`
    method.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is an example that parses latitude and longitude coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the endpoint returns a JSON representation of the `Coordinate`
    class, while the `TryParse` method parses the input string into a `Coordinate`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Parse` method of the `Coordinate` class comes from the `IParsable<TSelf>`
    interface and is not needed for model binding.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, if we request the following URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Parsing a string into an object is a viable choice for simple scenarios. However,
    more complex scenarios require another technique that we explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Manual binding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `BindAsync` method takes an `HttpContext` and a `ParameterInfo` parameter
    and returns a `ValueTask<TSelf>` where `TSelf` is the type we are writing data
    binding for. The `HttpContext` represents the source of the data (the HTTP request),
    and the `ParameterInfo` represents the delegate’s parameter, from which we could
    want to know something, like its name.The data-binding API supports the implementation
    of one of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the `IBindableFromHttpContext<TSelf>` interface provides the appropriate
    `BindAsync` method.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is an example that binds a `Person` from the HTTP request’s query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns a JSON representation of the person. For example,
    if we request the following URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `BindAsync` method is way more powerful than the `TryParse`
    method because we can access a broader range of options using the `HttpContext`,
    allowing us to cover complex use cases.However, in this case, we could have leveraged
    the `[AsParameters]` attribute to achieve the same result and get the data from
    the query without needing to write the data-binding code manually. What a great
    opportunity to explore this attribute; here’s the updated version of the same
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That’s it; the `AsParameters` attribute did the work for us!Now that we covered
    reading the input values from different places in the HTTP request, it is time
    to explore how to output results.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are several ways to output data from our delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a serializable object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return an `IResult` implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a `Results<TResult1, TResult2, …, TResultN>` where the `TResult` generic
    parameters represent the different `IResult` implementation the endpoint can return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explore those possibilities next.
  prefs: []
  type: TYPE_NORMAL
- en: Serializable object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first is to return a serializable object, as we did in the previous section
    about inputs. ASP.NET Core serializes the object into a JSON string and sets the
    `Content-Type` header to `application/json`. This is the easiest way to do it
    but also the less flexible.For example, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Outputs the following JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this approach is that we don’t control the status code, nor
    can we return multiple different results from the endpoint. For example, if the
    endpoint returns `200 OK` in one case and `404 Not Found` in another. To help
    us with this, we explore the `IResult` abstraction next.
  prefs: []
  type: TYPE_NORMAL
- en: IResult
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next option is to return the `IResult` interface. We can leverage the `Results`
    or `TypedResults` classes from the `Microsoft.AspNetCore.Http` namespace to do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend defaulting to using `TypedResults`, which .NET 7 introduced.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The main difference between the two is that the methods in the `Results` class
    return `IResult`, while those in `TypedResults` return a typed implementation
    of the `IResult` interface. This difference may sound insignificant, but it changes
    everything regarding discoverability by the API Explorer. The API Explorer can’t
    automatically discover the API contract of the former, while it can for the latter.
    This is possible because the compiler can infer the return type, but it creates
    challenges when returning more than one result type.
  prefs: []
  type: TYPE_NORMAL
- en: This choice impacts the amount of work you’ll have to put into getting well-crafted
    OpenAPI specifications automatically (or not so automatically).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following two endpoints explicitly state the result is 200 OK, one with
    each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When looking at the generated OpenAPI specifications, the first endpoint has
    no return value, while the other has a `Coordinate` definition mimicking our C#
    class. Next, we dig deeper into the `TypedResults` class.
  prefs: []
  type: TYPE_NORMAL
- en: Typed results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can use the methods of the `TypedResults` class to generate strongly-typed
    outputs. They allow us to control the output while informing ASP.NET Core of the
    specifics, like the status code and return type.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that for the sake of simplicity, I've omitted variants and overloads,
    focusing solely on the fundamental of each method in the tables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s start with the successful status code, where the `200 OK` status code
    is most likely the most common:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Accepted` | Produces a `202 Accepted` response, indicating the beginning
    of an asynchronous process. |'
  prefs: []
  type: TYPE_TB
- en: '| `Created` | Produces a `201 Created` response, indicating the system created
    the entity, the location of the entity, and the entity itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `Ok` | Produces a `200 OK` response, indicating the operation was successful.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.4: TypedResults successful status code methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of the successes, we must know how to tell clients about the errors.
    For example, the `400 Bad Request` and `404 Not Found` are very common to point
    out the issues with the request. The following table contains methods to assist
    in indicating such issues to the clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `BadRequest` | Produces a `400 Bad Request` response, indicating an issue
    with the client request, often a validation error. |'
  prefs: []
  type: TYPE_TB
- en: '| `Conflict` | Produces a `409 Conflict` response, indicating a conflict occurred
    when processing the request, often a concurrency error. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotFound` | Produces a `404 Not Found` response, indicating the resource
    was not found. |'
  prefs: []
  type: TYPE_TB
- en: '| `Problem` | Produces a response adhering to the *Problem Details* structure
    defined by **RFC7807** , providing a standardized encapsulation of the error.
    We can modify the status code, which defaults to a `500 Internal Server Error`
    . |'
  prefs: []
  type: TYPE_TB
- en: '| `UnprocessableEntity` | Produces a `422 Unprocessable Content` response,
    indicating that while the server comprehends the request''s content type and the
    syntax is correct, it cannot process the instructions or the entity. |'
  prefs: []
  type: TYPE_TB
- en: '| `ValidationProblem` | Produces a `400 Bad Request` response adhering to the
    *Problem Details* structure defined by **RFC7807** . We can use this method to
    communicate input validation problems to the client. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.5: TypedResults problematic status code.'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the *Problem Details* structure improves the interoperability of
    our API by choosing a standard instead of crafting a custom way of returning our
    API errors.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It is rarer in APIs than with conventional web applications to send redirections
    to clients, yet, we can redirect the clients to another URL with one of the following
    methods when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `LocalRedirect` | Produces a `301 Moved Permanently`, `302 Found`, `307 Temporary
    Redirect`, or `308 Permanent Redirect` based on the specified arguments.This method
    throws an exception at runtime if the URL is not local, which is an excellent
    option to ensure dynamically generated URLs are not sending users away. For example,
    when the URL is composed using user inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| `Redirect` | Produces a `301 Moved Permanently` , `302 Found` , `307 Temporary
    Redirect` , or `308 Permanent Redirect` based on the specified arguments. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.6: TypedResults redirection status code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending files to the client is another helpful feature; for example, the API
    could protect the files using authorization. The following table showcases a few
    helper methods to send files to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `File` | Writes the file content to the response stream.The `File` methods
    are aliases for the `Bytes` and `Stream` methods. We look at those soon. |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicalFile` | Writes the content of a physical file to the response using
    an absolute or relative path.Caution: Do not expose this method to raw user inputs
    because it can read files outside the web content root. So a malicious actor could
    craft a request to access restricted files. |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualFile` | Writes the content of a physical file to the response using
    an absolute or relative path.This method limits the file''s location to the web
    content root and is safer when dealing with user inputs. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.7: TypedResults methods for downloading files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of the methods we have explored so far, the following table lists ways
    to handle the content directly in its raw format. These content-handling methods
    can become handy when you need more control over what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Bytes` | Writes the byte-array or `ReadOnlyMemory<byte>` content directly
    to the response. It defaults to sending an `application/octet-stream` MIME Type
    to the client. This default behavior can be customized as needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `Content` | Writes the specified content `string` to the response stream.
    It defaults to sending a `text/plain` MIME Type to the client. This default behavior
    can be customized as needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `Json` | Serializes the specified object to JSON. It defaults to sending
    an `application/json` MIME Type to the client with a `200 OK` status code. These
    default behaviors can be customized as needed.Compared to the other methods, like
    the `Ok` method, the primary advantage is that it allows us to use a non-default
    instance of the `JsonSerializerOptions` class to configure the serialization of
    the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `NoContent` | Produces an empty `204 No Content` response. |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusCode` | Produces an empty response with the specified status code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Stream` | Allows writing directly to the response stream from another `Stream`.
    It defaults to sending an `application/octet-stream` MIME Type to the client.
    This default behavior can be customized as needed.This method is highly customizable,
    returns a `200 OK` status code by default, and supports range requests that produce
    a status code `206 Partial Content` or `416 Range Not Satisfiable`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Text` | Writes the content string to the HTTP response. It defaults to sending
    a `text/plain` MIME Type to the client. This default behavior can be customized
    as needed, as well as the text encoding. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.8: TypedResults raw content handling methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The `application/octet-stream` MIME Type suggests that the response body is
    a file without specifying its type, which typically prompts the browser to download
    the file.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, we can leverage the following methods of the `TypedResults` class
    to create security flows. Most of these methods rely on the current implementation
    of the `IAuthenticationService` interface, which dictates their behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Challenge` | Initiates a challenge for authentication when an unauthenticated
    user requests an endpoint that necessitates authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `Forbid` | Invoke when an authenticated user tries to access a resource for
    which they do not have the necessary permissions.By default, it produces a `403
    Forbidden` response, although the behavior may vary depending on the specific
    authentication scheme. |'
  prefs: []
  type: TYPE_TB
- en: '| `SignIn` | Commences the sign-in process for a user, based on the specified
    authentication scheme. |'
  prefs: []
  type: TYPE_TB
- en: '| `SignOut` | Initiates the sign-out process for the given authentication scheme.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Unauthorized` | Produces a `401 Unauthorized` response. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.9: TypedResults security-related methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the `TypedResults` possibilities, we explore how to
    return those typed results next.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple typed results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'While returning a single typed result is helpful, the capability to produce
    multiple results is better aligned with real-life scenarios. As we previously
    examined, it''s possible to return multiple `IResult` objects, but we''re restricted
    to a single typed result. This limitation arises from the compiler''s inability
    to identify a shared interface and deduce an `IResult` return type from the typed
    results. Even if the compiler could, that wouldn''t enhance discoverability.To
    overcome this limitation, .NET 7 introduced the `Results<T1, TN>` types, allowing
    us to return up to six different typed results.Here’s an example that returns
    `200 OK` when the random number is even and `209 Conflict` when it is odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works with methods like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adopting this approach enhances the API Explorer's comprehension of the API,
    thereby allowing libraries like Swagger and Swagger UI to automatically generate
    more accurate and detailed API documentation.Next, we explore adding more metadata
    to endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, relying solely on automatic metadata is not enough. That’s why ASP.NET
    Core offers different helper methods to fine-tune the metadata of our endpoints.
    We can use most helper methods with groups and routes. In the case of a group,
    the metadata cascades to its children, whether it is another group or a route.
    However, a child can override the inherited values by changing the metadata.Here’s
    a partial list of helpers and their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Accepts` | Specifies the supported request content types.*Only applicable
    to routes.* |'
  prefs: []
  type: TYPE_TB
- en: '| `AllowAnonymous` | Specifies that anonymous users can access the endpoint(s).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CacheOutput` | Adds an output caching policy to the endpoint(s). |'
  prefs: []
  type: TYPE_TB
- en: '| `DisableRateLimiting` | Turns off the rate-limiting feature on the endpoint(s).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ExcludeFromDescription` | Excludes the item from the API Explorer data.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Produces``ProducesProblem``ProducesValidationProblem` | Describes a response,
    including its type, content type, and status code.*Only applicable to routes.*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RequireAuthorization` | Specifies that only authorized users can access
    the endpoint(s). We can be more granular by using one of the overloads. For example,
    we can specify a policy name or an `AuthorizationPolicy` instance.*You must configure
    authorization for this to work*. |'
  prefs: []
  type: TYPE_TB
- en: '| `RequireCors` | Specifies that the endpoint(s) must follow a CORS policy.*You
    must configure CORS for this to work*. |'
  prefs: []
  type: TYPE_TB
- en: '| `RequireRateLimiting` | Adds a rate-limiting policy to the endpoint(s).*You
    must configure rate-limiting for this to work*. |'
  prefs: []
  type: TYPE_TB
- en: '| `WithDescription` | Describes the route.When used on a group, the description
    cascades to all routes within that group. |'
  prefs: []
  type: TYPE_TB
- en: '| `WithName` | Attributes a name to the route. We can use this name to identify
    the route, which must be unique.For example, we can use the route name with the
    `LinkGenerator` class to generate the URL of that endpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| `WithOpenApi` | Ensure the builder adds the compatible metadata about the
    endpoint so tools like Swagger can generate the Open API specifications.We can
    also use this method to configure the operation and parameters instead of the
    other extension methods.*You must call this method for many others to work.* |'
  prefs: []
  type: TYPE_TB
- en: '| `WithSummary` | Add a summary to the route.When used on a group, the summary
    cascades to all routes within that group. |'
  prefs: []
  type: TYPE_TB
- en: '| `WithTags` | Add tags to the route.When used on a group, the tags cascade
    to all routes within that group. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.10: Metadata helper methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example that creates a group, tags it, then ensures that all
    routes under that group have their metadata harvestable by SwaggerGen (the API
    Explorer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define endpoints on that group using the `metadataGroup` as if it
    was the `app` variable. Next, we create an endpoint that we name `"Named Endpoint"`
    and describe it using the `WithOpenApi` method, including deprecating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we generate a URL based on the preceding named endpoint, we describe
    the endpoint using the `WithDescription` method and add metadata to the `endpointName`
    parameter, including an example. Once again we leverage the `WithOpenApi` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When requesting the preceding endpoint, we get the URL of the specified route.
    By default, we get the URL of the `"Named Endpoint"` route—our only named route—in
    the following JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last example, we can exclude a route from the metadata with the `ExcludeFromDescription`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When looking at the Swagger UI, we can see the following section representing
    the group we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: a screenshot of the Swagger UI “Metadata Endpoints” route group.](img/file25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: a screenshot of the Swagger UI “Metadata Endpoints” route group.'
  prefs: []
  type: TYPE_NORMAL
- en: We can see two endpoints in the preceding screenshot and, as expected, the third
    endpoint was excluded.The first route is marked as deprecated and shows a summary.
    When we open it, we see a warning, a description, no parameters, and one 200 OK
    response with a mime-type `text/plain`.
  prefs: []
  type: TYPE_NORMAL
- en: I omitted to add a screenshot of the Swagger UI for the first endpoint since
    it does not add much and would be hard to read. It is better to run the `Minimal.API`
    program and navigate to the `/swagger/index.html` URL instead.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The second route does not have a summary, but when we open it, we have a description.
    The metadata we added for the `endpointName` parameter is there, and most interestingly,
    the example became the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: a screenshot of the Swagger UI showcasing the metadata of the
    endpointName parameter.](img/file26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: a screenshot of the Swagger UI showcasing the metadata of the `endpointName`
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI can become very handy for manually calling our API during development
    or leveraging other Open API compatible tools. For example, we could generate
    code based on the Open API specs, like a TypeScript client.Next, we explore how
    to configure the Minimal API JSON serializer.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JSON serialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In ASP.NET Core, we can customize the JSON serializer globally or create a
    new one for a specific scenario.To change the default serializer behaviors, we
    can invoke the `ConfigureHttpJsonOptions` method, which configures the `JsonOptions`
    object. From there, we can change the options like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code in the `Program.cs` file, we tell the serializer to
    serialize the property name following a `lower-case-kebab` naming convention.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **Response** |'
  prefs: []
  type: TYPE_TB
- en: '| jsonGroup.MapGet("kebab-person/",() => new {FirstName = "John",LastName =
    "Doe"}); | {"first-name": "John","last-name": "Doe"} |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.11: Showcasing the output of the JsonNamingPolicy.KebabCaseLower policy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve the same for specific endpoints by using the `TypedResults.Json`
    method and specifying an instance of `JsonSerializerOptions`. The following code
    accomplishes the same outcome while preserving the default serialization options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I highlighted the changes between this code and the previous example. First,
    we create an instance of the `JsonSerializerOptions` class. To simplify the configuration,
    we start with the default web serialization values by passing the `JsonSerializerDefaults.Web`
    argument to the constructor. Then, in the object initializer, we set the value
    of the `PropertyNamingPolicy` property to `JsonNamingPolicy.KebabCaseLower`, which
    end up with the same result as before. Finally, to use our options, we pass the
    `kebabSerializer` variable as the second argument of the `TypedResults.Json` method.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing enums as string
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'I often find myself changing a configuration to output the string representation
    of an `enum` value. To do so, we must register an instance of the `JsonStringEnumConverter`
    class. Afterward, enums will be serialized as strings. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the preceding code, we obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the default options yields the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: I usually change this option globally since having a human-readable value instead
    of a number is more explicit, easier to understand for a human, and easier to
    leverage for a client (machine).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many other options exist to tweak the serializer, but we can’t explore them
    all here. Next, we look at endpoint filters.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging endpoint filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ASP.NET Core 7.0 added the possibility to register endpoint filters. This way,
    we can encapsulate and reuse cross-cutting concerns and logic across endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of reusability is that I prefer FluentValidation to .NET attributes,
    so I created an open-source project implementing a filter that ties Minimal APIs
    with FluentValidation. I can then reuse that filter across projects by referencing
    a NuGet package. We explore FluentValidation in *Section 4: Application Patterns*,
    and I left a link to that project in the *Further Reading* section.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does it work?
  prefs: []
  type: TYPE_NORMAL
- en: We can register endpoint filters inline or by creating a class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add filters to an endpoint or a group using the `AddEndpointFilter` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding a filter to a group, it applies to all its children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add multiple filters per endpoint or group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core executes the filters in the order they are registered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at a simple inline filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code represents the filter in the form of a delegate. The filter
    does nothing but executes the next delegate in the chain, in this case, the endpoint
    delegate itself.In the following example, we use the `Rating` enum and only accept
    positive ratings in the endpoint. To achieve this, we add a filter that validates
    the input value before reaching the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'From the filter, we leveraged the `EndpointFilterFactoryContext` to access
    the rating argument. The code then validates that the rating is not `Bad`. If
    the rating is `Bad`, the filter immediately returns a *problem details* with a
    `400 Bad Request` status code before reaching out to the endpoint delegate. Otherwise,
    the endpoint code is executed.You probably wonder how useful writing code like
    this can be; well, this case is purely educational and not that useful in a real-world
    scenario. We could have validated the parameter in the endpoint delegate directly
    and saved ourselves the trouble of accessing it through its index. Nonetheless,
    it shows how filters work so that you can build helpful real-life filters with
    this knowledge; remember that coding is like playing LEGO® blocks.To improve on
    this foundation and make the previous example reusable, we can extract the filter
    logic into a class and apply it to multiple endpoints. We could also move the
    inline implementation to a group so it affects all its children. Let’s have a
    look at making our inline filter a class.A filter class must implement the `IEndpointFilter`
    interface. Here’s the reimplementation of the previous logic in the `GoodRatingFilter`
    class, and two endpoints using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `GoodRatingFilter` class `InvokeAsync` method code is the same as the inline
    version. However, we used it twice, keeping our code DRY.Encapsulating pieces
    of logic in filters can be very beneficial, whether it is input validation, logging,
    exception handling, or another scenario.And this is not it; there is one more
    thing about filters we must explore.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the endpoint filter factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use an endpoint filter factory to run code when ASP.NET Core builds the
    endpoint (makes the `RequestDelegate`) before declaring the filter. Then, from
    the factory, we control the creation of the filter itself.
  prefs: []
  type: TYPE_NORMAL
- en: We explore the factory pattern in *Chapter 7*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code registers an endpoint filter factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds an endpoint filter factory that logs some information
    to the console, which allows us to track what is happening. The highlighted code
    represents the filter itself. For example, we could write the same code as the
    `GoodRatingFilter` class there.Next, let’s look at what happens when we execute
    the program and load the endpoint five times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what happened from the preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: The API starts (the first ten lines).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ASP.NET Core executes the factory code when building the `RequestDelegate` from
    the `EndpointRoutingMiddleware` (the next two lines).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SwaggerGen`, using the `ApiExplorer`, also does the same from the `SwaggerMiddleware`,
    hence the second factory call (the next two lines).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterward, ASP.NET Core only executes the filters during requests—in this case,
    five times (the last 10 lines).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve seen how it runs, it is time to learn how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t understand how the `GetRequiredService` method or the
    `ILoggerFactory` interface work; we explore those topics in *Chapter 8*, *Dependency
    Injection*, and *Chapter 10*, *Logging*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We start by registering the endpoint filter factory using the `AddEndpointFilterFactory`
    method, which applies to groups and individual routes (we dig deeper into groups
    next). The factory delegate is of type `Func<EndpointFilterFactoryContext, EndpointFilterDelegate,
    EndpointFilterDelegate>`.Inside the delegate, using the `EndpointFilterFactoryContext`
    parameter named `filterFactoryContext`, we have access to the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ApplicationServices` property provides access to an `IServiceProvider`
    interface, allowing us to extract services from the container, as demonstrated
    with the `ILoggerFactory` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MethodInfo` property offers a `MethodInfo` object granting access to the
    caller to which we add the endpoint filter factory. This object encapsulates the
    reflection data, including types, generic parameters, attributes, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the factory delegate returns the filter ASP.NET Core executes when
    a request hits the endpoint(s). In this case, the filter is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `next` parameter (highlighted code) represents the next filter in line or
    the endpoint itself—it works the same here as with any endpoint filter. Not calling
    the `next` parameter means ASP.NET Core will never execute the endpoint code,
    which is a way to control the flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: To make an endpoint filter factory more reusable, we could create a class, an
    extension method, or return an existing filter class. We can also combine those
    ways to craft a more testable and DRY implementation of an endpoint filter factory.
    While we won't delve into these specific approaches in this context, by the end
    of the book, you should have acquired enough knowledge to achieve these tasks
    by yourself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we look at organizing our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grouping endpoints using the `MapGroup` method is an effective organizational
    strategy. However, defining all routes directly within the `Program.cs` file can
    result in a long and challenging-to-navigate file. To mitigate this, we can arrange
    these groups of endpoints in separate classes and create an extension method to
    add these endpoints to the `IEndpointRouteBuilder`. We can also encapsulate the
    groups, or even multiple groups, within another assembly, which we can load from
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explore ways to design applications in *Section 4: Application Patterns*,
    including in *Chapter 18*, *Request-EndPoint-Response (REPR)*, and *Chapter 20*,
    *Modular Monolith*.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s start with simple groups.
  prefs: []
  type: TYPE_NORMAL
- en: MapGroup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating groups is the first tool to organize the routes of our APIs. It comes
    with the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a shared URL prefix for the group’s children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add metadata that applies to the group’s children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add endpoint filters that apply to the group’s children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a group that configures those three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configures the `organizing-endpoints` URL prefix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `Organizing Endpoints` tag (metadata).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an inline filter that logs information about the requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can reach the endpoints at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/organizing-endpoints/demo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/organizing-endpoints/demo/123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the following Swagger UI screenshot shows, the two endpoints are tagged
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: The two endpoints under the Organizing Endpoints tag](img/file27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The two endpoints under the Organizing Endpoints tag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after requesting the two endpoints, we end up with the following logs
    excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated, leveraging groups for shared configuration streamlines the
    process of setting up aspects like authorization rules, caching, and more. By
    adopting this approach, we uphold the DRY (Don't Repeat Yourself) principle, improving
    the maintainability of our code.Next, we encapsulate mapping endpoints into classes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom Map extension method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we explored how to create groups, it is time to move the endpoints
    out of the `Program.cs` file. One way is to create an extension method that registers
    the route. To achieve this, we must extend the `IEndpointRouteBuilder` interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we must call our extension method in the `Program.cs` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we''ve seen how a simple technique allows us to group our routes
    together, offering an organized way to structure our APIs.We can improve on this
    technique by returning the `IEndpointRouteBuilder` instead of `void` in our extension
    method, which makes our extension “fluent”, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then from the `Program.cs` file, we can call multiple maps in a “single line
    of code” like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Creating fluent APIs is very convenient, especially in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: This technique allows you to create fluent APIs for anything, not just registering
    routes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another variation of this pattern exists that''s worth noting. Rather than
    returning the `IEndpointRouteBuilder`, the extension method can return the `RouteGroupBuilder`
    instead, granting the caller access to the group itself. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can use such methods to create a complex hierarchy of routes and groups by
    splitting the registration into multiple files. The second version is the most
    common way. It does not expose the group to the outside (encapsulation) and allows
    fluent chaining of other method calls.And voilà! We now know how basic extension
    methods can help us organize our endpoints. Next, we explore how to move those
    extension methods into class libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Class libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This last technique allows us to create and register routes from class libraries
    using the previously explored techniques.First, we must create a class library
    project, which we can do using the `dotnet new classlib` CLI command.Unfortunately,
    a class library project cannot access everything we need, like the `IEndpointRouteBuilder`
    interface. The good news is that it is trivial to change this fact. All we have
    to do is add a `FrameworkReference` element in an `ItemGroup` element in the `csproj`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: That minor addition equips us with everything necessary to create an ASP.NET
    Core-enabled library, including mapping endpoints! Transferring the preceding
    C# code into this class library project should yield the same functional results
    as in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: I used this technique in the `Shared` project of the solution we explore in
    this chapter and the next. If you are curious, the complete source code is available
    on GitHub.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we mix Minimal APIs and DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Minimal APIs with Data Transfer Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explores leveraging the **Data Transfer Object** (**DTO**) pattern
    with minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: This section is the same as we explore in *Chapter 6*, *MVC*, but in the context
    of Minimal APIs. Moreover, the two code projects are part of the same Visual Studio
    solution for convenience, allowing you to compare the two implementations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a reminder, DTOs aim to *control the inputs and outputs of an endpoint* by
    decoupling the API contract from the application’s inner workings. DTOs empower
    us to define our APIs without thinking about the underlying data structures, leaving
    us to craft our REST APIs how we want.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss REST APIs and DTOs more in-depth in *Chapter 4*, *REST APIs*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Other possible objectives are to save bandwidth by limiting the amount of information
    the API transmits, flattening the data structure, or adding API features that
    cross multiple entities.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by analyzing a diagram that shows how minimal APIs work with DTOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO](img/file28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO'
  prefs: []
  type: TYPE_NORMAL
- en: 'DTOs allow the decoupling of the domain (3) from the request (1) and the response
    (5). This model empowers us to manage the inputs and outputs of our REST APIs
    independently from the domain. Here’s the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ASP.NET Core leverages its data binding and parsing mechanism to convert the
    information of the HTTP request to C# (input DTO).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The endpoint does what it is supposed to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ASP.NET Core serializes the output DTO to the HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives and handles the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s explore some code to understand the concept better.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Minimal API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This code sample is the same as the next chapter but uses Minimal APIs instead
    of the MVC framework*.**Context**: we must build an application to manage customers
    and contracts. We must track the state of each contract and have a primary contact
    in case the business needs to contact the customer. Finally, we must display the
    number of contracts and the number of opened contracts for each customer on a
    dashboard.The model is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is straightforward. The only piece of logic is the `WorkStatus.State`
    property that returns `WorkState.New` when the work has not yet started on that
    contract, `WorkState.Completed` when all the work is completed, or `WorkState.InProgress`
    otherwise.The endpoints (`CustomersEndpoints.cs`) leverage the `ICustomerRepository`
    interface to simulate database operations. The implementation is unimportant.
    It uses a `List<Customer>` as the database. Here’s the interface that allows querying
    and updating the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know about the underlying foundation, we explore CRUD endpoints
    that do not leverage DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Raw CRUD endpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many issues can arise if we create CRUD endpoints to manage the customers directly
    (see `CustomersEndpoints.cs`). First, a little mistake from the client could erase
    several data points. For example, if the client forgets to send the contracts
    during a `PUT` operation, that would delete all the contracts associated with
    that customer. Here’s the controller code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code represents the customer update. So to mistakenly remove
    all contracts, a client could send the following HTTP request (from the `Minimal.API.http`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'That request would result in the following response entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, however, that customer had contracts (seeded when we started the
    application). Here’s the original data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by exposing our entities directly, we are giving a lot of power
    to the consumers of our API. Another issue with this design is the dashboard.
    The user interface would have to calculate the statistics about the contracts.
    Moreover, if we implement paging the contracts over time, the user interface could
    become increasingly complex and even overquery the database, hindering our performance.
  prefs: []
  type: TYPE_NORMAL
- en: I implemented the entire API, which is available on GitHub but without UI.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore how we can fix those two use cases using DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: DTO-enabled endpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To solve our problems, we reimplement the endpoints using DTOs. These endpoints
    use methods instead of inline delegates and returns `Results<T1, T2, …>` instead
    `IResult`. So, let’s start with the declaration of the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to make it easier to follow along, here are all the DTOs as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s fix our update problem, starting with the reimplementation of
    the update endpoint leveraging DTOs (see the `DTOEndpoints.cs` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the main differences are (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: The request body is now bound to the `UpdateCustomer` class instead of the `Customer`
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action method returns an instance of the `CustomerDetails` class instead
    of the `Customer` itself when the operation succeeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, we can see more code in our endpoint than before. That’s because it
    now handles the changes instead of the clients. The action now does:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the data from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the entity exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the input DTO to update the data, limiting the clients to a subset of properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proceed with the update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the entity still exists (handles conflicts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Customer into the output DTO and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By doing this, we now control what the clients can do when they send a `PUT`
    request through the input DTO (`UpdateCustomer`). Moreover, we encapsulated the
    logic to calculate the statistics on the server. We hid the computation behind
    the output DTO (`CustomerDetails`), which lowers the complexity of our user interface
    and allows us to improve the performance without impacting any of our clients
    (loose coupling).Furthermore, we now use the `customerId` parameter.If we send
    the same HTTP request as before, which sends more data than we accept, only the
    customer''s name will change. On top of that, we get all the data we need to display
    the customer’s statistics. Here’s a response example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding response, only the customer’s name changed,
    but we now received the `statusWorkDone` and `statusTotalWork` fields. Lastly,
    we flattened the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs are a great resource to flatten data structures, but you don’t have to.
    You must always design your systems, including DTOs and data contracts, for specific
    use cases.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As for the dashboard, the “get all customers” endpoint achieves this by doing
    something similar. It outputs a collection of `CustomerSummary` objects instead
    of the customers themselves. In this case, the endpoint executes the calculations
    and copies the entity''s relevant properties to the DTO. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the action method:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the entities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the DTOs and calculate the number of open contracts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the DTOs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As simple as that, we now encapsulated the computation on the server.
  prefs: []
  type: TYPE_NORMAL
- en: You should optimize such code based on your real-life data source. In this case,
    a `static` `List<T>` is low latency. However, querying the whole database to get
    a count can become a bottleneck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Calling the endpoint results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It is now super easy to build our dashboard. We can query that endpoint once
    and display the data in the UI. The UI offloaded the calculation to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: User interfaces tend to be more complex than APIs because they are stateful.
    As such, offloading as much complexity to the backend helps. You can use a Backend-for-frontend
    (BFF) to help with this task. We explore ways to layer APIs, including the BFF
    pattern in *Chapter 19*, *Introduction to Microservices Architecture*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Lastly, you can play with the API using the HTTP requests in the `MVC.API.DTO.http`
    file. I implemented all the endpoints using a similar technique. If your endpoints
    become too complex, it is good practice to encapsulate them into other classes.
    We explore many techniques to organize application code in *Section 4*: *Applications
    patterns*.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A data transfer object allows us to design an API endpoint with a specific
    data contract (input and output) instead of exposing the domain or data model.
    This separation between the presentation and the domain is a crucial element that
    leads to having multiple independent components instead of a bigger, more fragile
    one.We use DTOs to control the endpoints'' inputs and outputs, giving us more
    control over what the clients can do or receive.Using the data transfer object
    pattern helps us follow the SOLID principles in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: A DTO adds clear boundaries between the domain or data model and the
    API contract. Moreover, having an input and an output DTO help further separate
    the responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: A DTO is a small, specifically crafted data contract (abstraction) with
    a clear purpose in the API contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Due to those smaller interfaces (ISP), DTOs allow changing the implementation
    details of the endpoint without affecting the clients because they depend only
    on the API contract (the abstraction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now understand the added value of DTOs and what part in an API contract
    they play. Finally, you should have a strong base of Minimal APIs possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the chapter, we explored ASP.NET Core Minimal APIs and their integration
    with the DTO pattern. Minimal APIs simplify web application development by reducing
    boilerplate code. The DTO pattern helps us decouple the API contract from the
    application's inner workings, allowing flexibility in crafting REST APIs. DTOs
    can also save bandwidth and flatten or change data structures. Endpoints exposing
    their domain or data entities directly can lead to issues, while DTO-enabled endpoints
    offer better control over data exchanges. We also discussed numerous Minimal APIs
    aspects, including input binding, outputting data, metadata, JSON serialization,
    endpoint filters, and endpoint organization. With this foundational knowledge,
    we can begin to design ASP.NET Core minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Minimal APIs and what they have to offer, you can
    visit the *Minimal APIs quick reference* page of the official documentation: [https://adpg.link/S47i](https://adpg.link/S47i)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the next chapter, we revisit the same notions in an ASP.NET Core MVC context.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How to map different HTTP requests to delegates with Minimal APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use middleware with Minimal APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you name at least two binding sources that minimal APIs supports?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between using the `Results` and `TypedResults` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of endpoint filters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some links to build on what we have learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimal APIs quick reference: [https://adpg.link/S47i](https://adpg.link/S47i)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problem Details for HTTP APIs (RFC7807): [https://adpg.link/1hpM](https://adpg.link/1hpM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FluentValidation.AspNetCore.Http: [https://adpg.link/sRtU](https://adpg.link/sRtU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minimal APIs provide extension methods such as `MapGet`, `MapPost`, `MapPut`,
    and `MapDelete` to configure the HTTP pipeline and map specific HTTP requests
    to delegates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, we can use middleware with Minimal APIs, just like any other ASP.NET Core
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minimal APIs support various binding sources, including `Route`, `Query`, `Header`,
    `Body`, `Form`, and `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The methods in the `Results` class return `IResult`, while those in `TypedResults`
    return a typed implementation of the `IResult` interface. This difference is significant
    because the API Explorer can automatically discover the API contract from the
    typed results (`TypedResults` methods) but not from the generic `IResult` interface
    (`Results` methods).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Endpoint filters allow encapsulation and reuse of cross-cutting logic across
    endpoints. For example, they're helpful for input validation, logging, exception
    handling, and promoting code reusability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
