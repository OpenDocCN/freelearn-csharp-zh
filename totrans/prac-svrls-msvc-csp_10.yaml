- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Security and Observability for Serverless and Microservices Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器和微服务应用程序的安全和可观察性
- en: There are studies that indicate that cybercrime can be considered the third
    economy in the world. Besides that, the investment made in many companies in cyber
    security has increased a lot in the last few years. When we talk about serverless
    and microservices, we cannot ignore this topic. In fact, the area of attack of
    a distributed system is bigger than a simple monolith application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有研究表明，网络犯罪可以被认为是世界上第三大经济体。除此之外，许多公司在网络安全上的投资在过去几年里大幅增加。当我们谈论无服务器和微服务时，我们不能忽视这个话题。事实上，分布式系统的攻击面比简单的单体应用程序要大。
- en: Considering this challenging scenario, security and observability cannot be
    discussed in a single moment of the development process. The approach of security
    and privacy by design indicates that you will only achieve success and reduce
    risk in cyber security if you start thinking about it just after you start thinking
    about your solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个具有挑战性的场景，安全和可观察性不能在开发过程的某个时刻单独讨论。安全性和隐私设计的方法表明，只有在你开始考虑解决方案之后立即开始考虑它时，你才能在网络安全中取得成功并降低风险。
- en: The goal of this chapter is to discuss how to secure applications, enable monitoring
    for both performance and security, and improve incident response, considering
    the tools and techniques we currently have.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是讨论如何确保应用程序的安全，启用性能和安全的监控，并改进事件响应，考虑到我们目前拥有的工具和技术。
- en: Application Security Best Practices
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全最佳实践
- en: A good approach to thinking about security in an application is to define it
    as an onion – with different layers of protection. The most important thing about
    any application is the data that is stored and processed by it. Considering this,
    the databases of an application must be designed to have the correct access and
    protection. However, securing the database is not enough to deliver a good solution,
    so you must also think about the security of the application itself, defining
    authentication and authorization for any user who will access it. Besides that,
    you need to understand that your application will probably use third-party components
    that must also be protected. Infrastructure also needs to be monitored and secure,
    and there are sophisticated ways to do so nowadays. Last, but not least, there
    are alternative solutions that can monitor our applications by intercepting the
    traffic that arrives at it, guaranteeing another layer of security. Let’s check
    each layers of security in detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中考虑安全性的一个良好方法是将其定义为洋葱——具有不同的保护层。任何应用程序最重要的东西就是它存储和处理的**数据**。考虑到这一点，应用程序的数据库必须设计成具有正确的访问和保护。然而，仅仅保护数据库还不足以提供良好的解决方案，因此你还必须考虑应用程序本身的安全性，为任何将访问它的用户定义身份验证和授权。除此之外，你需要理解你的应用程序可能会使用必须得到保护的第三方组件。基础设施也需要被监控和确保安全，如今有复杂的方法来实现这一点。最后，但同样重要的是，有替代解决方案可以通过拦截到达应用程序的流量来监控我们的应用程序，从而保证另一层安全。让我们详细检查每一层的安全。
- en: Network Security
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络安全
- en: It can be a little confusing for developers to think about managing a network
    in the cloud, since you might imagine that any resource provided must be public.
    The point is exactly this – we cannot consider any component as public when we
    are using public cloud providers. To do so, you must design a proper network that
    will safeguard applications. For this, a **Virtual Private Cloud (VPC)** must
    be provided.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，思考在云中管理网络可能会有些困惑，因为你可能会想象任何提供的资源都必须是公开的。重点是正好如此——当我们使用公共云提供商时，我们不能将任何组件视为公开的。为了做到这一点，你必须设计一个能够保护应用程序的适当网络。为此，必须提供**虚拟专用云（VPC）**。
- en: A VPC provides a logically isolated section within a public cloud, where you
    can launch resources in a virtual network that you define. This isolation ensures
    that your resources are protected from external threats and unauthorized access.
    The focus of this is to reduce the attack surface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: VPC（虚拟专用云）在公共云中提供了一个逻辑上隔离的部分，你可以在你定义的虚拟网络中启动资源。这种隔离确保了你的资源免受外部威胁和未经授权的访问。重点是减少攻击面。
- en: With VPC configurations, you will have fine-grained network control. By defining
    subnets, route tables, and network gateways, you can control the flow of traffic
    to and from your serverless functions and microservices. With this, only trusted
    sources can access your resources, and only exactly what you want will be exposed
    to the public internet.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VPC 配置，您将拥有细粒度的网络控制。通过定义子网、路由表和网络网关，您可以控制流量流向和离开您的无服务器函数和微服务。这样，只有受信任的来源才能访问您的资源，并且只有您希望公开的内容才会暴露给公共互联网。
- en: When you think about microservices, there is no direct need to have them exposed
    to the internet. So, this protection is crucial for sensitive data and critical
    applications, minimizing the risk of external attacks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当您考虑微服务时，没有直接将它们暴露给互联网的需求。因此，这种保护对于敏感数据和关键应用至关重要，最大限度地降低外部攻击的风险。
- en: In Azure, there are two great services that can help you set the private architecture
    of your subsystems, guaranteeing that only the surfaces that really need to be
    exposed. The first one is Azure Virtual Network, which is the component that will
    enable you to design a VPC according to the configuration you decide. The second
    one is Azure Private Link, which will enable your services to connect over a private
    endpoint in a virtual network. This will give you the opportunity to reduce the
    need to expose a service to the public internet, using the Microsoft backbone
    network to do so.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 中，有两个出色的服务可以帮助您设置子系统的私有架构，确保只有真正需要暴露的表面。第一个是 Azure 虚拟网络，这是将使您能够根据您决定的配置设计
    VPC 的组件。第二个是 Azure 私有链接，它将使您的服务能够通过虚拟网络中的私有端点进行连接。这将为您提供一个机会，减少将服务暴露给公共互联网的需求，同时使用微软骨干网络来实现这一点。
- en: Obviously, if you have a better network design, you will be able to monitor
    and protect your solution with more efficiency. For instance, you can define Azure
    network security groups to define specific rules according to a group. You have
    the option of monitoring the traffic of the network by enabling Virtual Network
    flow logs. You can also define inbound and outbound traffic and prohibitions using
    Azure Firewall. In summary, Azure Virtual Network and its components are a powerful
    tool for securing communication between services in the cloud, ensuring data confidentiality,
    integrity, and availability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果您有一个更好的网络设计，您将能够更有效地监控和保护您的解决方案。例如，您可以通过启用虚拟网络流日志来定义根据组定义的特定规则。您可以选择通过启用
    Azure 网络安全组来监控网络流量。您还可以使用 Azure 防火墙定义入站和出站流量以及禁止。总之，Azure 虚拟网络及其组件是确保云中服务之间通信安全的强大工具，确保数据机密性、完整性和可用性。
- en: Data Security
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据安全
- en: The data that arrives at a database generally comes from a user or a system.
    This means that the transmission of this data needs to be guaranteed, and we must
    consider ways to protect the interception and eventual changing of this data.
    The best way to do so is to encrypt data from the client to the server. **Hyper
    Text Transfer Protocol Secure (HTTPS)** is the alternative that, generally, all
    web servers use to do so. Together with the **Transport Layer Security (TLS)**
    protocol, we enable a secure channel to transfer data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到达数据库的数据通常来自用户或系统。这意味着需要保证这些数据的传输，我们必须考虑保护数据被拦截和最终更改的方法。这样做最好的方式是从客户端到服务器加密数据。**超文本传输协议安全（HTTPS）**是所有网络服务器通常使用的替代方案来执行此操作。与**传输层安全性（TLS）**协议一起，我们启用了一个安全通道来传输数据。
- en: In a function app, for instance, HTTPS is the only protocol accepted by default.
    This means that any HTTP (which is not secure) request will be redirected to HTTPS,
    providing better security for the transfer of data. You can check it in the configuration
    of App Service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在函数应用中，HTTPS 是默认接受的唯一协议。这意味着任何 HTTP（不安全）请求都将被重定向到 HTTPS，从而为数据传输提供更好的安全性。您可以在
    App Service 的配置中检查它。
- en: '![](img/B31916_10_01.png) Figure 10.1: HTTPS Only in App Service'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1：App Service 仅支持 HTTPS](img/B31916_10_01.png)'
- en: Besides that, you may also want to increase the security of this transfer layer
    by defining a specific certificate for your service. In Azure, you can do this
    by defining a domain for your app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可能希望通过为您的服务定义一个特定的证书来提高此传输层的安全性。在 Azure 中，您可以通过为您的应用程序定义一个域来实现这一点。
- en: By default, Azure delivers to you a certificate created by Microsoft, where
    the domain used is azurewebsites.net. However, you can buy a custom domain outside
    Azure, or even inside it, which is much easier to manage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Azure 会向您提供一个由 Microsoft 创建的证书，其中使用的域是 azurewebsites.net。然而，您可以在 Azure
    外部购买一个自定义域名，甚至在其内部，这将更容易管理。
- en: Custom domains will represent a cost to your Azure account. You can get more
    details about custom domains at [https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate](https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义域名将代表您 Azure 账户的成本。您可以在[https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate](https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate)了解更多关于自定义域的详细信息。
- en: In the same way as you need to secure the transfer layer, you must secure your
    environment variables and secrets. Azure provides three services to do so. The
    first one is called **Azure Managed Identities** and it will let you access data
    in Azure SQL, Cosmos DB, Azure Storage, and so on without the need for a credential.
    On the other hand, if you do need to manage variables and secrets, **Azure Key
    Vault** is the correct service to store client application secrets, connection
    strings, passwords, shared access keys, and SSH keys. However, access to Azure
    Key Vault may cause performance issues for the application’s startup. That is
    why you should use **Azure App Configuration** to store non-secrets, such as client
    IDs, endpoints, and application parameters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与您需要保护传输层一样，您必须保护您的环境变量和机密。Azure 提供了三个服务来做到这一点。第一个被称为**Azure 管理标识**，它将允许您无需凭证即可访问
    Azure SQL、Cosmos DB、Azure Storage 等数据。另一方面，如果您需要管理变量和机密，**Azure 密钥保管库**是存储客户端应用程序机密、连接字符串、密码、共享访问密钥和
    SSH 密钥的正确服务。然而，访问 Azure 密钥保管库可能会对应用程序的启动造成性能问题。这就是为什么您应该使用**Azure 应用配置**来存储非机密，例如客户端
    ID、端点和应用程序参数。
- en: Another important resource that you must consider while protecting data is the
    options you have for data encryption in the database service. For instance, in
    SQL databases, there is the possibility to use the **Transparent data encryption**
    setting.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在保护数据时，您必须考虑数据库服务中数据加密的选项。例如，在 SQL 数据库中，可以使用**透明数据加密**设置。
- en: '![Figure 10.2: Transparent data encryption setting](img/B31916_10_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：透明数据加密设置](img/B31916_10_02.png)'
- en: 'Figure 10.2: Transparent data encryption setting'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：透明数据加密设置
- en: With this setting, you will prevent situations where a stolen database file
    can be restored on a different server from yours. Besides that, in general, database
    servers also have **firewall rules** that will restrict direct access to them,
    which is a very important approach to not expose the database server to the public
    cloud.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，您将防止被盗数据库文件在您的不同服务器上恢复的情况。除此之外，通常数据库服务器也有**防火墙规则**，这将限制对它们的直接访问，这是防止数据库服务器暴露在公共云中的非常重要的方法。
- en: Authentication and Authorization
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和授权
- en: When you are creating an application, it is essential that you know the actor
    that will access it. To do so, you must provide an **authentication** method,
    that is, the process of verifying the identity of a user or system, ensuring that
    the entity requesting access is indeed who or what it claims to be. To do so,
    you must use credentials such as passwords, tokens, or biometric data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序时，了解将访问它的角色至关重要。为此，您必须提供一个**认证**方法，即验证用户或系统身份的过程，确保请求访问的实体确实是其所声称的身份。为此，您必须使用密码、令牌或生物识别数据等凭证。
- en: Once you have the user or system identified, there is another process that will
    let this actor access resources or execute activities in the system you are designing.
    The process that enables it is called **authorization**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您识别了用户或系统，还有一个过程将允许这个角色访问您正在设计的系统中的资源或执行活动。使这成为可能的过程被称为**授权**。
- en: 'There are some alternatives to deliver authentication and authorization. We
    will discuss three of them in this topic: **JSON Web Tokens (JWTs)**, OAuth 2.0,
    and OpenID Connect. They are useful techniques to provide access to websites and
    APIs, guaranteeing security for the system you are designing.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些替代方案可以提供认证和授权。我们将在这个主题中讨论其中的三个：**JSON Web Tokens (JWTs**)、OAuth 2.0 和 OpenID
    Connect。它们是提供对网站和 API 访问的有用技术，为您的系统设计提供安全保障。
- en: JSON Web Tokens
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: JSON Web Token (JWT) enables security between the client and the server using
    an encoded JSON object, called a token, that is transferred in the HTTP header
    in a compact and stateless format. The token is created by the server as it verifies
    the authentication of the requestor. The authorization is given to ensure that
    the requestor can access the resources. JWTs pertain to industry standard RFC
    7519.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token (JWT)通过使用一个编码的JSON对象（称为令牌），以紧凑和无状态的方式在HTTP头中传输，从而在客户端和服务器之间实现安全性。令牌由服务器在验证请求者的身份时创建。授权是为了确保请求者可以访问资源。JWT符合行业标准RFC
    7519。
- en: The code provided in the chapter will give you an idea about how to implement
    JWTs using .NET. It is worth noting that this code is not ready for use, since
    the authentication method is not resolved.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码将向您展示如何使用.NET实现JWT。值得注意的是，此代码尚未准备好使用，因为认证方法尚未解决。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Build` method in the `JWTBuilder` class is responsible for constructing
    a JWT based on the properties and claims that have been configured in the builder.
    A `List<Claim>` is initialized with two default claims: (1) `sub` (subject), which
    represents the subject of the token; (2) `jti` (JWT ID), a unique identifier for
    the token, generated using `Guid.NewGuid()`. Additional claims from the claims
    dictionary are appended using **Union**. Each key-value pair in the dictionary
    is converted into a Claim object. A `JwtSecurityToken` object is created with
    the following parameters:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTBuilder`类中的`Build`方法负责根据在构建器中配置的属性和声明构建JWT。一个`List<Claim>`初始化为两个默认声明：（1）`sub`（主题），代表令牌的主题；（2）`jti`（JWT
    ID），令牌的唯一标识符，使用`Guid.NewGuid()`生成。使用**Union**将声明字典中的额外声明附加。字典中的每个键值对都转换为Claim对象。使用以下参数创建一个`JwtSecurityToken`对象：'
- en: '**issuer**: The entity that issued the token.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者**: 发行令牌的实体。'
- en: '**audience**: The intended recipient of the token.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受众**: 令牌的预期接收者。'
- en: '**claims**: The list of claims created earlier.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**: 之前创建的声明列表。'
- en: '**expires**: The expiration time, calculated as the current UTC time plus the
    configured `expiryInMinutes`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期时间**: 过期时间，计算方式为当前UTC时间加上配置的`expiryInMinutes`。'
- en: '**signingCredentials**: Specifies how the token is signed. It uses the provided
    `securityKey` and the `HmacSha256` algorithm.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名凭证**: 指定如何签名令牌。它使用提供的`securityKey`和`HmacSha256`算法。'
- en: The method wraps the `JwtSecurityToken` in a custom `JWT` object and returns
    it. The `JWT` class provides additional properties like `ValidTo` (expiration
    time) and `Value` (string representation of the token).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将`JwtSecurityToken`封装在一个自定义的`JWT`对象中，并返回它。`JWT`类提供了额外的属性，如`ValidTo`（过期时间）和`Value`（令牌的字符串表示）。
- en: As soon as the client requestor receives the token, it can be encapsulated in
    the following requests to the server as authorization header information using
    the prefix **Bearer**. The server, when it receives this header information, implements
    middleware software that analyzes whether the request is appropriate for the requester.
    The great thing about it is that if the request path is protected by the JWT process,
    and the request sent does not have the proper token, the request does not arrive
    at the server for processing, only being processed by the middleware.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端请求者收到令牌，它就可以封装在以下对服务器的请求中，作为使用前缀**Bearer**的授权头信息。当服务器接收到此头信息时，它实现中间件软件来分析请求是否适合请求者。它的好处是，如果请求路径受到JWT过程的保护，并且发送的请求没有适当的令牌，则请求不会到达服务器进行处理，只会被中间件处理。
- en: In the example presented in the chapter, you will find two APIs. The first one
    gives you a token for usage. The second one is the WeatherForecast API generally
    available when you create an API app using .NET. To make better use of the example,
    the Swagger documentation was implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章展示的示例中，您将找到两个API。第一个API为您提供令牌用于使用。第二个API是当您使用.NET创建API应用时通常可用的WeatherForecast
    API。为了更好地使用示例，实现了Swagger文档。
- en: '![Figure 10.3: JWT Swagger implementation ](img/B31916_10_03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：JWT Swagger实现](img/B31916_10_03.png)'
- en: 'Figure 10.3: JWT Swagger implementation'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：JWT Swagger实现
- en: If you try to run the WeatherForecast API without delivering a Bearer token,
    the response will be refused with a 401 error code, which means unauthorized.
    On the other hand, if you use the Token API to generate the token needed and use
    this token for authorization with the padlock icon available in the Swagger interface,
    the result of the API will be properly delivered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在没有提供Bearer令牌的情况下运行WeatherForecast API，响应将被拒绝，返回401错误代码，这意味着未授权。另一方面，如果你使用Token
    API生成所需的令牌，并使用Swagger界面中可用的锁形图标进行授权，API的结果将被正确地交付。
- en: '![Figure 10.4: Defining the Bearer token](img/B31916_10_04.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4：定义Bearer令牌](img/B31916_10_04.png)'
- en: 'Figure 10.4: Defining the Bearer token'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：定义Bearer令牌
- en: Notice that the token provided respects the JWT standard and can be checked
    on the jwt.io web page, confirming what you defined in your solution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意提供的令牌遵守JWT标准，可以在jwt.io网页上检查，确认你在解决方案中定义的内容。
- en: '![Figure 10.5: Decoding JWT on the jwt.io web page](img/B31916_10_05.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：在jwt.io网页上解码JWT](img/B31916_10_05.png)'
- en: 'Figure 10.5: Decoding JWT on the jwt.io web page'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：在jwt.io网页上解码JWT
- en: Based on the sample provided, you may consider JWT as a good way to implement
    a standard method for **Authorization**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的示例，你可以考虑JWT作为实现**授权**标准方法的良好方式。
- en: OAuth 2.0 and OpenID Connect (OIDC)
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth 2.0 和 OpenID Connect (OIDC)
- en: OAuth 2.0 is an open standard that enables third-party providers to give applications
    **Authorization** to access user resources without exposing their credentials.
    There are many great providers that enable you to use this technique, such as
    Google, Microsoft, Facebook, and GitHub.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 是一个开放标准，允许第三方提供者授予应用程序访问用户资源的**授权**，而不暴露其凭证。有许多优秀的提供者允许你使用这项技术，例如Google、Microsoft、Facebook和GitHub。
- en: The simple use of logins with passwords for authorization is considered too
    risky for enterprises nowadays. Besides that, transferring this kind of data via
    APIs is also very dangerous, considering the potential cyberattacks that we need
    to deal with currently. For this reason, **OpenID Connect (OIDC)** is a good option
    for **Authentication**, since it enables the confirmation of a user’s existence
    without exposing passwords.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于企业来说，使用密码进行登录认证被认为风险太大。除此之外，通过API传输这类数据也非常危险，考虑到我们目前需要应对的潜在网络攻击。因此，**OpenID
    Connect (OIDC)** 是一个很好的认证选项，因为它允许确认用户的存在而不暴露密码。
- en: To do so, there are three important things to consider. The first one is that
    this is also an open standard, which means that we have many servers offering
    this service. The second one is that you will need to consider the usage of a
    third-party service, so the definition of a good provider must be considered.
    The third, but not less important, is that OIDC is implemented above OAuth 2.0,
    which means that, with it, you will have an entire solution for authentication
    and authorizing your users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，有三个重要的事情需要考虑。首先，这也是一个开放标准，这意味着我们有很多服务器提供这项服务。其次，你需要考虑第三方服务的使用，因此必须考虑良好提供商的定义。第三，虽然不是最重要的，但OIDC是在OAuth
    2.0之上实现的，这意味着，有了它，你将有一个完整的解决方案来认证和授权你的用户。
- en: In .NET, we have the possibility to use OAuth 2.0 and OIDC based on the **Microsoft
    Authentication Library (MSAL)**. To do so using Azure, you first need to register
    an app in Microsoft Entra ID.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，我们有使用基于**Microsoft身份验证库（MSAL）**的OAuth 2.0和OIDC的可能性。要使用Azure实现这一点，你首先需要在Microsoft
    Entra ID中注册一个应用。
- en: '![Figure 10.6: Registering an App in Microsoft Entra ID](img/B31916_10_06.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：在Microsoft Entra ID中注册应用](img/B31916_10_06.png)'
- en: 'Figure 10.6: Registering an App in Microsoft Entra ID'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：在Microsoft Entra ID中注册应用
- en: Depending on the type of project you are developing, you will have different
    ways to get the authentication of the users you want. The following code gets
    the user profile in a console app, based on a prompt that will redirect the user
    to the browser.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你正在开发的项目类型，你将会有不同的方式来获取你想要的用户的认证。以下代码在一个控制台应用程序中根据一个将用户重定向到浏览器的提示获取用户配置文件。
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result will be the need to log in using Microsoft. In this case, OIDC is
    using Microsoft Entra ID as the provider to identify the user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是需要使用Microsoft进行登录。在这种情况下，OIDC使用Microsoft Entra ID作为提供者来识别用户。
- en: '![Interface gráfica do usuário, Aplicativo  O conteúdo gerado por IA pode estar
    incorreto.](img/B31916_10_07.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，应用 O conteúdo gerado por IA pode estar incorreto.](img/B31916_10_07.png)'
- en: 'Figure 10.7: Log in using Microsoft Entra ID'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：使用Microsoft Entra ID登录
- en: Once you are logged in, Microsoft will ask if you allow it to share information
    about your account with the desired application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录，Microsoft会询问您是否允许它与应用程序共享您的账户信息。
- en: '![Figure 10.8: Authorizing app to read your data](img/B31916_10_08.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8：授权应用读取您的数据](img/B31916_10_08.png)'
- en: 'Figure 10.8: Authorizing app to read your data'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：授权应用读取您的数据
- en: There are two great things when you use this approach. The first one is that
    you don’t need to worry about user management. This management will be held by
    Microsoft Entra ID, which means that it will be centralized and customized using
    the expertise and experience of the provider, even in aspects of different ways
    of authenticating, such as Multiple Factors for Authentication. The second one,
    and more important, is the user will not need to remember another account, since
    they will use the one that they already use in their common work, which makes
    OIDC a popular choice for creating secure and user-friendly authentication mechanisms.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法有两个优点。第一个优点是您无需担心用户管理。这项管理将由Microsoft Entra ID负责，这意味着它将采用提供者的专业知识和经验进行集中和定制，甚至在不同的认证方式方面，如多因素认证。第二个优点，也是更重要的一点，是用户无需记住另一个账户，因为他们将使用他们在日常工作中已经使用的账户，这使得OIDC成为创建安全且用户友好的认证机制的热门选择。
- en: Securing Dependencies
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护依赖项
- en: The **Open Worldwide Application Security Project (OWASP)** is a foundation
    that works to improve the security of software in a nonprofit approach. One of
    their most well-known initiatives is the Top 10 list, which presents the riskiest
    situations in relation to your software. This list indicates situations such as
    injection attacks, broken authentication, sensitive data exposure, and security
    misconfigurations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放式网络应用安全项目（OWASP）**是一个以非营利方式致力于提高软件安全性的基金会。他们最著名的倡议之一是“十大风险”列表，该列表展示了与您的软件相关的风险最高的情况。该列表指出了诸如注入攻击、认证失败、敏感数据泄露和安全配置错误等情况。'
- en: When developing solutions, the usage of vulnerable and outdated components is
    considered one of the Top 10 risks. Libraries, frameworks, and APIs play a significant
    role in modern web application development, but these components can also introduce
    vulnerabilities into the application if not carefully managed. The decision to
    use third-party components can provide attackers with a vector to exploit the
    application, potentially leading to data breaches, unauthorized access, and other
    security incidents.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发解决方案时，使用有漏洞和过时的组件被认为是十大风险之一。库、框架和API在现代Web应用程序开发中发挥着重要作用，但如果管理不当，这些组件也可能将漏洞引入应用程序。使用第三方组件的决定可能会为攻击者提供利用应用程序的途径，可能导致数据泄露、未经授权的访问和其他安全事件。
- en: Considering the .NET environment, the usage of components is always connected
    to NuGet. Since NuGet is the package provider, in Visual Studio, it is quite simple
    to check if you are using a library that is outdated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到.NET环境，组件的使用总是与NuGet相关联。由于NuGet是包提供者，在Visual Studio中，检查您是否正在使用过时的库相当简单。
- en: '![Figure 10.9: Using NuGet to check outdated libraries](img/B31916_10_09.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9：使用NuGet检查过时的库](img/B31916_10_09.png)'
- en: 'Figure 10.9: Using NuGet to check outdated libraries'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：使用NuGet检查过时的库
- en: On the other hand, you must be aware that not only .NET packages need to be
    updated in a solution. When it comes to microservices, depending on the approach
    decided on to implement them, you will need to handle components that could be
    in the container or even in the infrastructure that manages the containers of
    the solution, and these parts of the application must also be continuously checked,
    evaluating whether there are any vulnerabilities that could cause damage to your
    solution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您必须意识到，在解决方案中不仅需要更新.NET包。当涉及到微服务时，根据决定实施的方法，您将需要处理可能位于容器中或甚至位于管理解决方案容器的基础设施中的组件，并且这些应用程序的部分也必须持续检查，评估是否存在可能损害您的解决方案的漏洞。
- en: If you are using GitHub as a repository, you may consider using **GitHub Dependabot**
    as a tool for automatically scanning your GitHub projects for outdated dependencies
    and known vulnerabilities, and then opening PRs to update them. **Sonar** and
    **Sync** are other tools that you may consider in your pipeline to prevent third-party
    security issues.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 GitHub 作为代码仓库，你可以考虑使用 **GitHub Dependabot** 作为工具，自动扫描你的 GitHub 项目中的过时依赖和已知漏洞，然后打开
    PR 来更新它们。**Sonar** 和 **Sync** 是你可以在你的管道中考虑的其他工具，以防止第三方安全问题的发生。
- en: The purpose of the CVE program ([https://www.cve.org/](https://www.cve.org/))
    is to help us with that. CVE means Common Vulnerabilities and Exposures, and it
    is a list of publicly disclosed computer security issues.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CVE 程序（[https://www.cve.org/](https://www.cve.org/））的目的就是帮助我们。CVE 代表通用漏洞和暴露，它是一份公开披露的计算机安全问题列表。
- en: Kubernetes and Azure Container Apps Security
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 和 Azure 容器应用安全
- en: 'Orchestrators’ security is twofold: on one side, we have user access security,
    and on the other side, we have network security. Here, we refer to the users of
    the orchestrator, not the users of the application hosted by the orchestrator,
    that is developers, administrators, and other operators that maintain both the
    orchestrator installation and its applications.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器的安全有两层含义：一方面，我们有用户访问安全，另一方面，我们有网络安全。在这里，我们指的是编排器的用户，而不是编排器托管的应用程序的用户，即开发者、管理员和其他维护编排器安装及其应用程序的操作员。
- en: The security of application users is taken care of by the application itself
    with the usual web application tools that are not specific for microservices,
    that is security tokens such as authentication cookies and bearer tokens, user
    claims, roles, and authorization policies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序用户的安全由应用程序本身通过通常的 Web 应用程序工具来保障，这些工具并非专为微服务定制，即安全令牌，如认证cookies和携带令牌，用户声明，角色和授权策略。
- en: Orchestrator network security refers to orchestrator tools for isolating both
    different applications running in the same cluster and different parts of the
    same application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器网络安全是指用于隔离同一集群中运行的不同应用程序以及同一应用程序的不同部分的编排器工具。
- en: This section discusses both the orchestrator user’s access security and network
    security for Kubernetes and Azure Container Apps, each in a dedicated subsection.
    Let’s start with Kubernetes network security.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 Kubernetes 和 Azure 容器应用的编排器用户访问安全和网络安全，每个都在专门的子节中。让我们从 Kubernetes 网络安全开始。
- en: Kubernetes network security
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 网络安全
- en: Kubernetes network security enriches the usual IP-based firewall rules with
    constraints on higher-level software entities like Kubernetes Pods and namespaces.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 网络安全通过在更高层次的软件实体（如 Kubernetes Pods 和命名空间）上施加约束，丰富了基于 IP 的防火墙规则。
- en: Thus, for instance, we may isolate two applications running in the same Kubernetes
    cluster by placing them into two different namespaces and then forbidding any
    communication between those two namespaces.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，我们可以通过将它们放置在两个不同的命名空间中并禁止这两个命名空间之间的任何通信，来隔离同一 Kubernetes 集群中运行的两个应用程序。
- en: We may also run sensitive Microservices in a “militarized zone” implemented
    as a namespace that exposes just a few **filtering Pods** to external communications.
    This way, the **filtering Pods** can look for adequate credentials and potential
    threats before routing the incoming communication to the microservices that must
    process them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在作为命名空间实现的“军事化区域”中运行敏感的微服务，该命名空间仅暴露少量 **过滤 Pods** 以进行外部通信。这样，**过滤 Pods**
    可以在将传入通信路由到必须处理它们的微服务之前查找适当的凭证和潜在威胁。
- en: Pod- and namespace-based network rules are more modular and flexible than IP-address-based
    rules since they directly constrain application-level entities instead of hardware-related
    entities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Pods 和命名空间的网络规则比基于 IP 地址的规则更模块化和灵活，因为它们直接约束应用层实体，而不是与硬件相关的实体。
- en: 'Network security rules are defined through **NetworkPolicy** resources defined
    with the `.yaml` below:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全规则是通过以下 `.yaml` 定义的 **NetworkPolicy** 资源来定义的：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The policy applies to all Pods selected by `podSelector` that are in the same
    namespace of the **NetworkPolicy** resource.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略适用于由 `podSelector` 选定的所有与 **NetworkPolicy** 资源处于同一命名空间的 Pods。
- en: If `policyType` contains the `Ingress` item, then the policy constrains input
    communications through rules that must be listed in the `ingress` section. If
    `Ingress` is not listed in `policyType`, the `ingress` section must be omitted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`policyType`包含`Ingress`项，则策略通过必须在`ingress`部分列出的规则来约束输入通信。如果`Ingress`未列在`policyType`中，则必须省略`ingress`部分。
- en: If `policyType` contains the `Egress` item, then the policy constrains output
    communications through rules that must be listed in the `egress` section. If `Egress`
    is not listed in `policyType`, the `egress` section must be omitted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`policyType`包含`Egress`项，则策略通过必须在`egress`部分列出的规则来约束输出通信。如果`Egress`未列在`policyType`中，则必须省略`egress`部分。
- en: Communication from/to each Pod must satisfy the constraints of all **NetworkPolicy**
    resources that select it with their `podSelector`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从/到每个Pod的通信必须满足所有选择它的**NetworkPolicy**资源通过其`podSelector`指定的约束。
- en: Each `from` section selects possible sources of communication that sum up to
    the sources of communication selected by all other `from` sections. Analogously,
    each `to` section selects possible destinations of communication that sum up to
    the destinations of communication selected by all other `to` sections.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`from`部分选择可能的通信源，这些源的总和等于所有其他`from`部分选择的通信源。类似地，每个`to`部分选择可能的通信目的地，这些目的地的总和等于所有其他`to`部分选择的通信目的地。
- en: 'Each `from` and each `to` contains a list of constraints that must be *all*
    satisfied by the allowed sources or destinations. There are three kinds of constraints
    that can be added:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`from`和每个`to`包含一个必须由允许的源或目的地**全部**满足的约束列表。可以添加三种类型的约束：
- en: 'Constraints on IP addresses:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址的约束：
- en: '[PRE3]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A selector expression that selects Pods of the same namespace of the **NetworkPolicy**
    resource:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**NetworkPolicy**资源相同命名空间Pod的选择器表达式：
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A selector expression that selects other allowed namespaces:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器表达式，用于选择其他允许的命名空间：
- en: '[PRE5]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you would like to receive or send communications just to some Pods of the
    selected namespaces, you can also nest a `podSelector` inside the `namespaceSelector`
    based item as shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想与所选命名空间的一些Pod进行通信，您也可以在`namespaceSelector`基于的项内部嵌套一个`podSelector`，如下所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each `from` and `to` can also limit the allowed communication to a list of
    ports and port intervals as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`from`和`to`也可以限制允许的通信到一个端口列表和端口范围，如下所示：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the item contains both `port` and `endPort`, it specifies a port interval.
    Otherwise, if it contains just `port`, it specifies a single port.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项包含`port`和`endPort`，则指定一个端口范围。否则，如果只包含`port`，则指定单个端口。
- en: 'Here is a policy that selects all Pods of the `mysample` namespace and accepts
    traffic from all Pods of the same namespace and from all Pods of the `mysafe`
    namespace:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个策略，它选择`mysample`命名空间的所有Pod，并接受来自同一命名空间的所有Pod以及来自`mysafe`命名空间的所有Pod的流量：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is a policy that selects all Pods of the `mysample` namespace, and accepts
    traffic from all Pods of the same namespace and from all Pods of the `mysafe`
    namespace, but only on port 80:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个策略，它选择`mysample`命名空间的所有Pod，并接受来自同一命名空间的所有Pod以及来自`mysafe`命名空间的所有Pod的流量，但仅限于端口80：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is a policy that enables all input traffic of the `militarized-zone` namespace
    to pass through the Pods labeled with `role: access-control`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是一个策略，它允许`militarized-zone`命名空间的所有输入流量通过标记为`role: access-control`的Pod：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can force all traffic to pass just through the Pods with `role: access-control`
    by adding another rule that prevents traffic from external namespaces to all other
    Pods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过添加另一条规则，防止外部命名空间的所有流量到达其他所有Pod，来强制所有流量仅通过带有`role: access-control`的Pod：'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`NetworkPolicy` entities constrain direct communication between Pods, that
    is communication based on Kubernetes services. However, what happens to communication
    mediated by message brokers?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkPolicy`实体约束Pod之间的直接通信，即基于Kubernetes服务的通信。然而，由消息代理介导的通信会发生什么？'
- en: We may use a different broker for each namespace we would like to isolate, so
    that we can use `NetworkPolicy` entities to constrain access to the various message
    brokers, too. If the message broker servers run outside of the Kubernetes cluster,
    we may use `NetworkPolicy` rules that filter the message broker IP addresses.
    Otherwise, we can deploy each message broker in the same namespace it serves,
    so that its Pods are also constrained by the same `NetworkPolicy` entities that
    constrain direct communication between microservices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个我们想要隔离的命名空间使用不同的代理，这样我们就可以使用 `NetworkPolicy` 实体来限制对各种消息代理的访问。如果消息代理服务器运行在
    Kubernetes 集群之外，我们可以使用 `NetworkPolicy` 规则来过滤消息代理的 IP 地址。否则，我们可以在它服务的相同命名空间中部署每个消息代理，这样它的
    Pods 也受到相同的 `NetworkPolicy` 实体的约束，这些实体限制了微服务之间的直接通信。
- en: If instead, we use a single message broker cluster, we are forced to use the
    message broker’s internal authorization policies to filter the access to the various
    message queues.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用单个消息代理集群，我们就被迫使用消息代理的内部授权策略来过滤对各种消息队列的访问。
- en: Azure Container Apps has simpler but less powerful network security.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 容器应用具有更简单但功能较弱的网络安全。
- en: Azure Container Apps Network Security
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 容器应用网络安全
- en: 'To configure network security in Azure Container Apps, you must use a custom
    Azure **Virtual Network (VNET)**. This requirement introduces the need for specific
    configurations and profiles. The setup typically follows these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Azure 容器应用中配置网络安全，您必须使用自定义的 Azure **虚拟网络 (VNET)**。这一需求引入了特定的配置和配置文件的需求。设置通常遵循以下步骤：
- en: Define a custom Azure **VNet**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个自定义的 Azure **VNet**。
- en: Associate a **dedicated subnet** from the VNet to each **Container Apps environment**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 VNet 中的 **专用子网** 与每个 **容器应用环境** 相关联。
- en: Assign a **subnet from each environment** to its respective **application**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个环境的 **子网** 分配给相应的 **应用程序**。
- en: Express communication constraints between environments and applications as **firewall
    rules** on the VNet subnets.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VNet 子网上以 **防火墙规则** 的形式表达环境与应用之间的通信约束。
- en: 'For detailed guidance on associating custom subnets with environments and applications,
    refer to the official documentation: [https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli](https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将自定义子网与环境和应用程序关联的详细指南，请参阅官方文档：[https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli](https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli)。
- en: However, this approach has some limitations. Because network rules are defined
    using **IP-address-based constraints**, rather than explicit software-level policies,
    the result is **reduced modularity** and **limited scalability**. This model may
    be sufficient for small-scale applications with a few communication restrictions,
    but as your microservices ecosystem grows, the approach can become too complicated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有一些局限性。因为网络规则是使用基于 **IP 地址的约束** 定义的，而不是显式的软件级策略，结果是 **模块化程度降低** 和 **可扩展性有限**。这种模式可能适用于具有少量通信限制的小规模应用程序，但随着您的微服务生态系统的发展，这种方法可能会变得过于复杂。
- en: If your system’s communication is handled through **external message brokers**,
    a simpler and more scalable solution is to manage access via the **broker’s authorization
    policies**, controlling which services can access specific message queues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统通信是通过 **外部消息代理** 处理的，那么通过 **代理的授权策略** 管理访问将是一个更简单且更可扩展的解决方案，它可以控制哪些服务可以访问特定的消息队列。
- en: Kubernetes User Security
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 用户安全
- en: 'Kubernetes user security is based on four concepts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 用户安全基于四个概念：
- en: '**User**: This represents the user who logs in with Kubectl. Each user has
    a unique username and authenticates with a client certificate. Both certificate
    and username must be added to the user’s Kubectl configuration file as explained
    in the *Interacting with Kubernetes: Kubectl, Minikube, and AKS* section of [*Chapter
    8*](Chapter_8.xhtml#_idTextAnchor205)*, Practical Microservices Organization with
    Kubernetes*.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户**：这代表使用 Kubectl 登录的用户。每个用户都有一个唯一的用户名，并使用客户端证书进行身份验证。证书和用户名都必须添加到用户的 Kubectl
    配置文件中，具体操作请参阅 [*第 8 章*](Chapter_8.xhtml#_idTextAnchor205) “与 Kubernetes 交互：Kubectl、Minikube
    和 AKS” 部分的说明，*《使用 Kubernetes 的实用微服务组织》*。'
- en: '**User Group**: Each user group is just a name – a string that may be associated
    to each user and inserted in its client certificate. User groups simplify the
    assignation of permissions to users, since each privilege can be assigned to a
    single user or to a whole user group.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户组**: 每个用户组只是一个名称——一个可能与每个用户关联并插入其客户端证书的字符串。用户组简化了权限分配给用户的过程，因为每个特权可以分配给单个用户或整个用户组。'
- en: '**Role**: Each role represents a set of permissions.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**角色**: 每个角色代表一组权限。'
- en: '**Role bindings**: Each role binding associates a role, that is a set of permissions,
    to several users and user groups. Put simply, role bindings encode a one-to-many
    relationship between roles and both users and user groups.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**角色绑定**: 每个角色绑定将一个角色（即一组权限）关联到多个用户和用户组。简单来说，角色绑定编码了角色与用户和用户组之间的一对多关系。'
- en: Permissions can be scoped either to a single namespace or to the whole Kubernetes
    cluster. Role and role bindings representing namespace-scoped permissions are
    encoded respectively in `Role` and `RoleBinding`Kubernetes resources, while role
    and role bindings representing cluster-scoped permissions are encoded respectively
    in `ClusterRole` and `ClusterRoleBinding` Kubernetes resources.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以作用域到单个命名空间或整个 Kubernetes 集群。表示命名空间作用域权限的角色和角色绑定分别编码在 `Role` 和 `RoleBinding`
    Kubernetes 资源中，而表示集群作用域权限的角色和角色绑定分别编码在 `ClusterRole` 和 `ClusterRoleBinding` Kubernetes
    资源中。
- en: 'A `RoleBinding` can only refer to a `Role`, while a `ClusterRoleBinding` can
    only refer to a `ClusterRole`. Here are the definitions of a `Role`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `RoleBinding` 只能引用一个 `Role`，而一个 `ClusterRoleBinding` 只能引用一个 `ClusterRole`。以下是
    `Role` 的定义：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each **Role** is identified by its name and by the namespace it applies to.
    Permissions are specified as a list of rules, where each rule contains:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 **Role** 都通过其名称和它应用的命名空间来识别。权限通过规则列表指定，其中每个规则包含：
- en: '`apiGroups`: The API that contains the operations and the resources involved
    in the permission. For instance, the API group for Deployments is “apps,” while
    the API group for Pods is the core API that is represented by the empty string.
    The API groups string corresponds to the API name contained in each resource `apiVersion`
    property. Each rule can specify several API groups.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiGroups`: 包含操作和涉及权限的资源 API。例如，Deployments 的 API 组是 “apps”，而 Pods 的 API 组是表示为空字符串的核心
    API。API 组字符串对应于每个资源 `apiVersion` 属性中包含的 API 名称。每个规则可以指定多个 API 组。'
- en: 'r`esources`: The name of the resources that can be manipulated with permission
    (Pods, Deployments, Services, etc.).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`: 可以用权限操作的资源名称（Pods、Deployments、Services 等）。'
- en: '`verbs`: The operations allowed on the resources:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verbs`: 允许在资源上执行的操作：'
- en: '`get`: Getting information on specific resource instances.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 获取特定资源实例的信息。'
- en: '`watch`: Observing resource instance properties as they change in time. That
    is, performing a `Kubectl get` or a `Kubectl describe` with the `–watch` flag
    on the resource.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watch`: 观察资源实例属性随时间变化。也就是说，在资源上使用 `–watch` 标志执行 `Kubectl get` 或 `Kubectl describe`。'
- en: '`list`: Listing the resource in any list of results.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`: 在任何结果列表中列出资源。'
- en: '`create`: Creating an instance of the resource.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`: 创建资源的实例。'
- en: '`delete`: Deleting an instance of the resource.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`: 删除资源的实例。'
- en: '`update`: Updating a resource instance by providing a new object that represents
    the instance. This is a case of the resource being updated with `Kubectl apply`.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`: 通过提供一个表示实例的新对象来更新资源实例。这是资源通过 `Kubectl apply` 更新的一个例子。'
- en: '`patch`: Updating a resource instance with `Kubectl patch`. In this case, we
    specify an existing resource and then replace just a property with the value contained
    in the `-p` option. The property may also be a complex object, in which case the
    properties specified in the object tree recursively replace existing values, while
    properties not specified in the object tree are left unchanged. Here’s an example:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`: 使用 `Kubectl patch` 更新资源实例。在这种情况下，我们指定一个现有的资源，然后用 `-p` 选项中包含的值替换其属性。该属性也可以是一个复杂对象，在这种情况下，对象树中指定的属性将递归地替换现有值，而未在对象树中指定的属性将保持不变。以下是一个示例：'
- en: '[PRE13]'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s a role that might be adequate for developers of an application that
    runs in the `my-app` namespace:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可能适合在 `my-app` 命名空间中运行的应用程序的开发者的角色示例：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All of `apiGroups`, r`esources`, and `verbs` accept the wildcard “*” string
    that matches everything.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `apiGroups`、`resources` 和 `verbs` 都接受通配符字符串 “*”，它可以匹配所有内容。
- en: 'A `ClusterRole` definition is completely analogous, the only difference being
    that no namespace must be specified and that `type: Role` is replaced by `type:
    ClusterRole`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRole` 定义完全类似，唯一的区别是无需指定命名空间，并且将 `type: Role` 替换为 `type: ClusterRole`。'
- en: 'Here is the definition of a `RoleBinding`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `RoleBinding` 的定义：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A `RoleBinding` contains a name and the reference namespace and specifies the
    `Role` it is bound to in its `roleRef` property. The `subjects` property contains
    a list of both users and users’ groups, where each item specifies the user or
    group name and the kind of subject.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleBinding` 包含一个名称和引用命名空间，并在其 `roleRef` 属性中指定它所绑定到的 `Role`。`subjects` 属性包含用户和用户组的列表，其中每个项目指定用户或组名称和主体类型。'
- en: 'Here is a `RoleBinding` that matches the example `developer-user-role` `Role`
    we have seen before, with all users belonging to the `developers` group:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个与之前看到的示例 `developer-user-role` `Role` 匹配的 `RoleBinding`，其中所有属于 `developers`
    组的用户：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A `ClusterBindingRole` definition is completely analogous, the only difference
    being that no namespace must be specified, `roleRef` must refer a `ClusterRole`,
    and that `type: BindingRole` is replaced by `type: ClusterBindingRole`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterBindingRole` 定义完全类似，唯一的区别是无需指定命名空间，`roleRef` 必须引用 `ClusterRole`，并且将
    `type: BindingRole` 替换为 `type: ClusterBindingRole`。'
- en: 'Client certificates do not need to be issued by a public certification authority
    but need just to be approved by the Kubernetes cluster. Here is the complete procedure
    for creating an approved certificate:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书不需要由公共认证机构颁发，只需经过 Kubernetes 集群的批准。以下是创建批准证书的完整流程：
- en: 'As the first step, you must create the certificate key. This can be done by
    opening a Linux console and using **openssl**:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，你必须创建证书密钥。这可以通过打开 Linux 控制台并使用 **openssl** 来完成：
- en: '[PRE17]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You must store the `mynewuser.key` file containing the certificate key since
    it is needed to configure the Kubectl configuration file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须存储包含证书密钥的 `mynewuser.key` 文件，因为配置 Kubectl 配置文件需要它。
- en: 'Now let’s extract the public part `mynewuser.key` in a certificate approval
    request. Again, we can do it with **openssl**:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们提取证书批准请求中的公钥部分 `mynewuser.key`。同样，我们可以使用 **openssl** 来完成：
- en: '[PRE18]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The above instruction generates the `mynewuser.csr` file, containing a certificate
    approval request. `mynewuser` must be replaced by the actual username, while `example:mygroup`
    must be replaced by the name of the user group you would like to add the user
    to.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述指令生成了 `mynewuser.csr` 文件，其中包含证书批准请求。`mynewuser` 必须替换为实际的用户名，而 `example:mygroup`
    必须替换为你希望添加用户的用户组名称。
- en: 'Now you must encode the certificate request in base 64:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你必须将证书请求编码为 base 64：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous command returns the base-64-encoded certificate in the Linux console.
    Please select and copy it. You must insert it in a `.yaml` file that encodes the
    approval request for the Kubernetes cluster:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令在 Linux 控制台中返回 base-64 编码的证书。请选择并复制它。你必须将其插入一个 `.yaml` 文件中，该文件编码了 Kubernetes
    集群的批准请求：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only fields you must change are the `name`, that is the approval request
    name, and `expirationSeconds`, which contains the certificate validity in seconds.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须更改的唯一字段是 `name`，即批准请求名称，以及 `expirationSeconds`，它包含证书有效期的秒数。
- en: 'Now let’s open the Windows console to interact with Minikube. Let’s start Minikube
    if it’s not started and then pass the previous .yaml file with:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开 Windows 控制台以与 Minikube 交互。如果 Minikube 尚未启动，请先启动它，然后使用以下命令传递之前的 .yaml
    文件：
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can approve the certificate with:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令批准证书：
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After the approval, we can get the final certificate in base 64 format:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批准后，我们可以获取最终的 base 64 格式证书：
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we must base 64 – decode `mytempfile.txt` to get the certificate in
    binary format. We can do it by opening a Linux console in the folder that contains
    `mytempfile.txt`, and then issuing:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须对 `mytempfile.txt` 进行 base 64 解码以获取二进制格式的证书。我们可以在包含 `mytempfile.txt`
    的文件夹中打开 Linux 控制台，然后执行以下操作：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can use both `mynewuser.key` and `mynewuser.crt` to update the Kubectl
    configuration file of the new user as explained in the *Interacting with Kubernetes:
    Kubectl, Minikube, and AKS* section of [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205)*,
    Practical Microservices Organization with Kubernetes*.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `mynewuser.key` 和 `mynewuser.crt` 来更新新用户的 Kubectl 配置文件，正如在 [*第 8 章*](Chapter_8.xhtml#_idTextAnchor205)
    “使用 Kubernetes 的实际微服务组织”部分的 *与 Kubernetes 交互：Kubectl、Minikube 和 AKS* 部分中所述。
- en: As an exercise, you can use the above procedure to define a new Minikube user
    belonging to the `developers` user group, and then you can assign it developer
    privileges on the `myapp` namespace with the example `developer-user-role Role`
    and `developers-binding RoleBinding` we defined before.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以使用上述过程定义一个属于`developers`用户组的新的Minikube用户，然后您可以使用我们之前定义的示例`developer-user-role
    Role`和`developers-binding RoleBinding`在`myapp`命名空间中分配开发权限。
- en: That’s all! Let’s move on to Azure Container Apps user security.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！让我们继续讨论Azure容器应用的用户安全。
- en: Azure Container Apps User Security
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure容器应用用户安全
- en: 'Azure Container Apps has no dedicated user security like Kubernetes but uses
    Azure security. Roles can be assigned to specific users either through the Azure
    portal or with the Azure CLI with this command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Azure容器应用没有像Kubernetes那样的专用用户安全，而是使用Azure安全。可以通过Azure门户或使用Azure CLI通过以下命令将角色分配给特定用户：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All available roles can be inspected on the Environment and Application page
    of the Azure portal. Both the application/environment resource ID and the user
    identity resource ID are available on their respective pages.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的角色都可以在Azure门户的环境和应用程序页面上进行检查。应用程序/环境资源ID和用户身份资源ID分别可在各自的页面上找到。
- en: Threat Detection and Mitigation
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁检测和缓解
- en: The number of threats we need to deal with in an application is quite huge and
    OWASP, as mentioned before, helps us with that. There are many common attacks
    that an application will need to handle and not only the protection of its network,
    data, entrance, and dependencies will be enough to deal with these attacks.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在应用程序中处理的大量威胁，OWASP，如前所述，帮助我们处理这些威胁。应用程序将需要处理许多常见的攻击，而仅仅保护其网络、数据、入口和依赖关系是不够的，以应对这些攻击。
- en: Threats
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 威胁
- en: The most difficult point of this scenario is detecting a threat on the fly while
    an application is running. But to detect them, we need to understand basically
    what they are, so let’s check out, in the following topics, some of the common
    attacks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中最困难的一点是在应用程序运行时即时检测威胁。但为了检测它们，我们需要基本了解它们是什么，所以让我们在以下主题中检查一些常见的攻击。
- en: Event Injection
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件注入
- en: When an attacker manipulates input data to execute unauthorized actions within
    an application, leading to data breaches, service disruptions, or unauthorized
    access, we are under an event injection attack.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者操纵输入数据以在应用程序内执行未经授权的操作，导致数据泄露、服务中断或未经授权的访问时，我们面临事件注入攻击。
- en: There are several strategies of mitigation, which include validating and sanitizing
    the input, guaranteeing strict input data; using strong-validation libraries,
    to define well-established libraries and framework connections; and restricting
    the privilege of users to the minimum necessary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种缓解策略，包括验证和清理输入，确保严格的输入数据；使用强验证库，以定义已建立的库和框架连接；以及将用户权限限制在最低必要范围内。
- en: Privilege Escalation
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 权限提升
- en: In an application where you have different levels of access, privilege escalation
    occurs when an attacker gains access beyond what they need to have, accessing
    resources or functions that they are not authorized to use. The result can be
    catastrophic, leading to unauthorized data access, total system control, and further
    exploitation of the application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有不同访问级别的应用程序中，当攻击者获得超出其所需访问权限时，就会发生权限提升，访问他们未经授权使用的资源或功能。结果可能是灾难性的，可能导致未经授权的数据访问、完全的系统控制以及应用程序的进一步利用。
- en: Fine-grained access control to restrict users must be well implemented. Also,
    there is the possibility to use an **Identity and Access Management (IAM)** solution,
    which will enforce user permissions. Regular audits and **Multi-Factor Authentication
    (MFA)** will also help to mitigate possible scenarios where unauthorized users
    may access relevant data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 精细访问控制以限制用户必须得到良好实施。此外，还有可能使用**身份和访问管理（IAM）**解决方案，这将强制执行用户权限。定期的审计和**多因素认证（MFA）**也将有助于减轻可能出现的未经授权用户访问相关数据的情况。
- en: Denial of Service (DoS) Attacks
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拒绝服务（DoS）攻击
- en: Let’s suppose you have massive and excessive traffic in your application caused
    by an attacker who wants to disrupt the availability of your solution, making
    the site simply stop responding accordingly. This is what we call a **Denial of
    Service (DoS)** attack. A DoS attack is caused by a single attacker, from a single
    point. If you have an event where multiple origins of attacks are observed, you
    must be experiencing a DDoS attack, which means that the attack is distributed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序因攻击者想要破坏你解决方案的可用性，导致网站简单地停止响应，从而造成了大量且过度的流量。这就是我们所说的**拒绝服务（DoS）攻击**。DoS攻击通常由单个攻击者从单一地点发起。如果你观察到攻击来源有多个，那么你可能正在经历DDoS攻击，这意味着攻击是分布式的。
- en: Obviously, the main way to mitigate this kind of attack is by blocking the traffic
    generated by its origin, so traffic filtering can be the best option. There is
    also the possibility of limiting the rate of access from a specific client for
    a period, minimizing the impact of DDoS attacks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，减轻此类攻击的主要方式是阻止其来源产生的流量，因此流量过滤可能是最佳选择。也有可能限制特定客户端在一定时间内的访问速率，以最小化DDoS攻击的影响。
- en: Besides that, if you have a solution with great availability, focused on delivering
    high levels of requests, you can suffer less with this kind of attack, especially
    if we are talking about DoS. So, auto-scaling strategies, which automatically
    adjust the number of active instances of a service based on the current load,
    are a good approach for that. **Content delivery network (CDN)** implementations,
    which approximate content to the ones who are using it by implementing the content
    across multiple geographically dispersed servers, can be also a good way to protect
    from this kind of attack.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你有一个具有高度可用性的解决方案，专注于提供高水平的请求，你可以减少这种攻击的影响，尤其是如果我们谈论DoS攻击。因此，自动扩展策略，根据当前负载自动调整服务的活动实例数量，是一种很好的方法。**内容分发网络（CDN）**的实施，通过在多个地理位置分散的服务器上实现内容，将内容近似到使用它的人，也可以是保护此类攻击的好方法。
- en: Man-in-the-Middle (MitM) Attacks
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间人（MitM）攻击
- en: '**Man-in-the-Middle (MitM)** attacks occur when you have an interception of
    communication between two parts of a system, altering data, which can cause inconsistent
    information in the solution you provide.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在系统的两个部分之间拦截通信，篡改数据时，就会发生**中间人（MitM）攻击**，这可能导致你提供的解决方案中信息不一致。
- en: As we have checked before, implementing a secure communication channel, using
    encryption protocols to secure data in transit, is certainly the best way to reduce
    the risk of this threat. Authentication mechanisms can also help in this case,
    especially if there is a way to verify the identities of communicating parties.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前检查的那样，实施安全的通信通道，使用加密协议来保护传输中的数据，无疑是降低此类威胁风险的最佳方式。认证机制也可以在这方面提供帮助，特别是如果有一种方法可以验证通信方的身份。
- en: Code Injection
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码注入
- en: Software code is certainly one of the ways to cause an attack in an application,
    especially if the code enables the injection of malicious code. Malicious code
    can be added in SQL commands that do not properly restrict what is executed in
    the database, enabling leaks, changes, or even data exclusion. In cases where
    your application enables the execution of scripts, the risk is also high, and
    unauthorized actions can happen due to this. You can also have cases where code
    is injected by attackers into web pages viewed by other users. This is called
    **cross-site scripting (XSS)**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 软件代码当然是在应用程序中造成攻击的一种方式，尤其是如果代码允许注入恶意代码。恶意代码可以添加到SQL命令中，这些命令没有正确限制在数据库中执行的内容，从而可能导致泄露、更改或甚至数据排除。在应用程序允许执行脚本的情况下，风险也很高，由于这个原因可能会发生未经授权的操作。你也可能遇到攻击者将代码注入到其他用户查看的网页中的情况。这被称为**跨站脚本（XSS）**。
- en: Implementing a serious code review process, applying secure coding practices,
    is mandatory in enterprises where the software is crucial for the business. To
    help with this, the usage of a static analysis tool must be considered, based
    on the amount of code that is generated daily by the company.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件对业务至关重要的企业中，实施严格的代码审查流程，应用安全的编码实践是强制性的。为了帮助实现这一点，必须考虑使用静态分析工具，这取决于公司每天生成的代码量。
- en: Detection and Mitigation with Web Application Firewalls
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Web应用程序防火墙进行检测和缓解
- en: Since you now understand the number of threats available, it is reasonable to
    say that there is no way to be entirely protected from them without a tool that
    can monitor the entire traffic, inspect it according to the different known threats,
    and alert you to take action once you have something suspicious. That is exactly
    what a **Web Application Firewall (WAF)** does.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您现在了解了可用的威胁数量，那么可以说，没有一种工具可以监控整个流量、根据不同的已知威胁进行检查并在您发现可疑内容时提醒您采取行动，您就无法完全免受这些威胁的保护。这正是**Web应用防火墙（WAF）**所做的事情。
- en: SQL injection, XSS, and other common web exploits can be handled by WAFs, so
    you must consider their use crucial for securing serverless and microservices
    applications. This is only possible because WAFs in general monitor HTTP/HTTPS
    traffic, giving you the possibility to block malicious requests from a specific
    client, even before they reach your application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入、XSS和其他常见的Web攻击可以通过WAF处理，因此您必须考虑它们的使用对于确保无服务器和微服务应用程序的安全性至关重要。这仅因为WAF通常监控HTTP/HTTPS流量，让您有机会阻止来自特定客户端的恶意请求，甚至在它们到达您的应用程序之前。
- en: They also provide a centralized panel for monitoring traffic and logging, which
    really simplifies the administration and increases your knowledge about the attacks
    you are suffering. It is important to mention that if you are running a public
    cloud solution, you are constantly under attack.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还提供了一个用于监控流量和日志记录的集中式面板，这确实简化了管理并增加了您对所遭受攻击的了解。重要的是要提到，如果您正在运行公共云解决方案，您将不断受到攻击。
- en: The service Microsoft offers as a WAF is called Azure Web Application Firewall.
    It is worth noting that Azure WAF works at Layer 7 (the application layer) of
    the OSI model and analyzes HTTP(S) traffic. To do so, it will be necessary to
    check the requests and responses passing through a channel. One of the alternatives
    for this channel is called Azure Application Gateway. This component is a web
    traffic load balancer that also works on OSI Layer 7\. It enables you to manage
    the traffic of your web applications. All the inspected traffic that suggests
    a threat is sent to Azure Monitor as an alert so that an administrator of the
    application can analyze it and take action.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供的作为WAF（Web应用防火墙）的服务称为Azure Web应用防火墙。值得注意的是，Azure WAF在OSI模型第7层（应用层）工作，并分析HTTP(S)流量。为此，需要检查通过通道传输的请求和响应。这个通道的替代方案之一被称为Azure应用网关。该组件是一个工作在OSI第7层的网络流量负载均衡器。它使您能够管理您的Web应用的流量。所有被检查的表明存在威胁的流量都会作为警报发送到Azure
    Monitor，以便应用程序管理员可以分析它并采取行动。
- en: As you may imagine, a solution that monitors the entire traffic of your application
    is obviously a concern when it comes to budget. So, this is certainly a point
    of discussion about investment and the trade-off of it must be analyzed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，一个监控您应用程序全部流量的解决方案在预算方面显然是一个问题。因此，这当然是一个关于投资和必须分析的权衡点的讨论。
- en: '![Figure 10.10: Sample solution architecture for enabling WAF](img/B31916_10_10.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10：启用WAF的示例解决方案架构](img/B31916_10_10.png)'
- en: 'Figure 10.10: Sample solution architecture for enabling WAF'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：启用WAF的示例解决方案架构
- en: The preceding diagram represents a solution architecture using the components
    that were described in this topic. As you can see, common users access the system
    via HTTPS, Azure Application Gateway handles traffic routing, and Azure WAF protects
    the solution against web threats. There is also the implementation of a Container
    Apps environment for scaling workloads using containers, and the microservices
    are running inside a virtual network. Azure Monitor is being used for the logging
    and observability of the system, so administrator access to Azure Monitor is used
    for insights. Observability is exactly the next topic that we will discuss. Let’s
    have a look at it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表示的是使用本主题中描述的组件的解决方案架构。如您所见，普通用户通过HTTPS访问系统，Azure应用网关处理流量路由，Azure WAF保护解决方案免受Web威胁。还有使用容器进行工作负载扩展的容器应用环境实现，微服务运行在虚拟网络内部。Azure
    Monitor用于系统的日志记录和可观察性，因此管理员访问Azure Monitor用于洞察。可观察性正是我们将要讨论的下一个主题。让我们看看它。
- en: Observability for Serverless and Microservices
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器和微服务的可观察性
- en: As we have seen up to this point of the book, distributed systems contain a
    complexity that brings to a solution some concerns that you can’t ignore. The
    implementation of a single microservice, using techniques such as serverless or
    containerization, is generally quite simple, but observing the entire solution
    is a difficult task and is certainly one of these concerns. The adoption of the
    observability concept is a good answer to this problem.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本书的这一部分所看到的那样，分布式系统包含的复杂性带来了一些你无法忽视的问题。单个微服务的实现，使用如无服务器或容器化等技术，通常相当简单，但观察整个解决方案是一项困难的任务，这无疑是这些关注点之一。采用可观测性概念是解决这个问题的好方法。
- en: 'Observability is defined by three primary signals: logs, metrics, and traces.
    A log is an immutable, time-stamped record of an event. A metric is a numerical
    representation of system performance over time. A trace represents the journey
    of a request across services in a distributed system. Together, these three signals
    provide insight into system behavior, enabling proactive maintenance and fast
    troubleshooting.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性由三个主要信号定义：日志、指标和跟踪。日志是一个事件不可变、带时间戳的记录。指标是系统性能随时间变化的数值表示。跟踪代表请求在分布式系统中跨越服务的旅程。这三个信号共同提供了对系统行为的洞察，使得主动维护和快速故障排除成为可能。
- en: Different from traditional monitoring, which generally focuses on predefined
    metrics and system health indicators, and is often reactive, observability defends
    a proactive approach, where the monitoring is continuous to avoid critical problems,
    and fast root-cause detection is the goal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的监控方式不同，传统的监控通常关注预定义的指标和系统健康指标，并且通常是反应式的，而可观测性则主张一种主动的方法，监控是持续的，以避免关键问题，快速定位根本原因是目标。
- en: There are several tools available to help implement observability in distributed
    systems. For logs, tools like Seq and the ELK Stack offer powerful log aggregation
    and visualization capabilities. For metrics, Prometheus is a widely used open-source
    monitoring solution, often paired with Grafana for visualization. For distributed
    tracing, Jaeger and Zipkin are popular open-source options.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以帮助在分布式系统中实现可观测性。对于日志，Seq和ELK Stack等工具提供了强大的日志聚合和可视化功能。对于指标，Prometheus是一个广泛使用的开源监控解决方案，通常与Grafana配合使用进行可视化。对于分布式跟踪，Jaeger和Zipkin是流行的开源选项。
- en: However, Application Performance Monitoring (APM) tools like Azure Monitor,
    Datadog, and New Relic allow you to centralize logs, metrics, and traces in one
    place, providing a full picture of system behavior. Choosing between them depends
    on your infrastructure, cloud provider, and integration needs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序性能监控（APM）工具，如Azure Monitor、Datadog和New Relic，允许你将日志、指标和跟踪集中在一个地方，提供系统行为的全面视图。选择它们取决于你的基础设施、云提供商和集成需求。
- en: Let’s understand each signal of observability in detail to make it easier to
    understand.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解可观测性的每个信号，以便更容易理解。
- en: Logging
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: Contextual-rich data is necessary to understand exactly where and when in the
    distributed system the issue monitored started. For example, understanding the
    sequence of service calls and the data passed between them can reveal whether
    an error originated from a specific service or from the interaction between services.
    This level of detail is crucial for effective debugging and for ensuring the resilience
    and reliability of distributed systems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富的上下文数据对于理解在分布式系统中问题监控开始的确切位置和时间至关重要。例如，了解服务调用的顺序以及它们之间传递的数据可以揭示错误是否来自特定的服务或来自服务之间的交互。这种详细程度对于有效的调试和确保分布式系统的弹性和可靠性至关重要。
- en: So, to enhance the usability of logs, it is essential to adopt a structured
    format that is easy to query and process. One of the most common approaches is
    to use JSON for log entries, as it offers readability and broad compatibility
    across systems. However, structured logging goes beyond using a structured format.
    It requires purposefully defining the meaning (semantics) of each log field. This
    ensures consistency, improves observability, and enables better filtering, indexing,
    and correlation across logs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了提高日志的可使用性，采用一种易于查询和处理的格式至关重要。最常见的方法之一是使用JSON作为日志条目的格式，因为它提供了可读性和跨系统的广泛兼容性。然而，结构化日志不仅仅使用结构化格式。它需要有意定义每个日志字段的含义（语义）。这确保了一致性，提高了可观测性，并使得日志之间的过滤、索引和关联更加有效。
- en: Besides that, effective logging needs the use of different logging categories
    to define the severity and importance of log entries.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有效的日志记录需要使用不同的日志类别来定义日志条目的严重性和重要性。
- en: 'Debug: Detailed information for technical internal purposes.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试：用于技术内部目的的详细信息。
- en: 'Info: General information about the application.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息：关于应用程序的一般信息。
- en: 'Warning: Alerts that may indicate potential issues, but that did not cause
    the halting of the application.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告：可能表明潜在问题，但并未导致应用程序停止的警报。
- en: 'Error: Problems that impact the application’s operation and that need to be
    analyzed.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：影响应用程序运行并需要分析的问题。
- en: 'Fatal: Critical errors that cause the application to terminate.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 致命：导致应用程序终止的严重错误。
- en: The correct usage of logging levels minimizes efforts in analyzing issues, focusing
    on critical ones in an efficient and effective approach.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用日志级别可以最小化分析问题的努力，以有效和高效的方法关注关键问题。
- en: Metrics
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: When it comes to metrics that need to be monitored and evaluated for serverless
    and microservices architectures, there are specific indicators that can be monitored.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到需要监控和评估的无服务器和微服务架构的指标时，有一些特定的指标可以监控。
- en: For instance, Azure Functions measures the time it takes for a function to execute
    from start to finish. This is called **Function Execution Time**. Shorter execution
    times generally indicate better performance.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Azure Functions测量一个函数从开始到结束的执行时间。这被称为**函数执行时间**。较短的执行时间通常表明更好的性能。
- en: Azure Functions also measures the latency between a serverless function being
    triggered and the moment the function essentially starts running. This is called
    **Cold Start** and reducing it causes improvement of the user experience.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions还会测量无服务器函数被触发到函数实际上开始运行之间的延迟。这被称为**冷启动**，减少它会导致用户体验的改善。
- en: The number of **invocations** and the number of **errors** also illustrate how
    the function is working, helping in the analysis of performance and possible problematic
    code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用次数**和**错误次数**也说明了函数的工作情况，有助于性能分析和可能存在问题的代码的分析。'
- en: On the other hand, when you have containerized environments, **CPU** and **Memory
    Usage** may be good metrics to monitor. The first one can affect performance if
    it is too high, and scaling may be considered. The second one can also impact
    performance, and the the cause of memory leaks can be addressed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你有容器化环境时，**CPU**和**内存使用**可能是需要监控的良好指标。第一个如果过高可能会影响性能，可能需要考虑扩展。第二个也可能影响性能，并且可以解决内存泄漏的原因。
- en: '**Network Traffic** may also be a concern in containerized environments and
    can indicate issues related to communication between microservices. **Pod Health**
    can help in identifying failing or unhealthy Pods.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络流量**在容器化环境中也可能是一个关注点，并可能表明与微服务之间通信相关的问题。**Pod健康**有助于识别失败的或不健康的Pod。'
- en: These and other metrics can not only be monitored but also alerted using **threshold-based**
    algorithms and alerts. Today, in Azure, we also have some **anomaly detection**
    done by machine models that generally detect deviation of behaviors in some situations,
    like time-response.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他指标不仅可以被监控，还可以使用基于**阈值**的算法和警报进行警报。今天，在Azure中，我们也有一些由机器模型执行的**异常检测**，通常检测某些情况下的行为偏差，如时间响应。
- en: Once alerts are properly set, it is also important to have a clear protocol
    for responding to these alerts. This is normally called the **Incident Response
    Process**. The process needs to determine how to deal with the incident (alert),
    how to communicate it, and how to discover the root cause, so the incident does
    not happen again.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了适当的警报，制定一个明确的响应这些警报的协议也很重要。这通常被称为**事件响应流程**。该流程需要确定如何处理事件（警报），如何沟通，以及如何发现根本原因，以确保事件不再发生。
- en: Tracing
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪
- en: When you have a distributed application, understanding the complete path from
    a request to its end is important to effectively diagnose situations across the
    microservices that are chained. That is why tracing is so important, and .NET
    applications together with Azure have a very good package of libraries to help
    you with it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个分布式应用程序时，理解从请求到其结束的完整路径对于有效地诊断跨链式微服务的情况非常重要。这就是为什么跟踪如此重要的原因，而.NET应用程序与Azure一起提供了一套非常好的库来帮助你完成这项工作。
- en: The usage of Azure Monitor here is crucial for success. Of course, there are
    other APM systems that can be used to observe the traceability of an application,
    but Azure Monitor gives us facilities that you may consider using. Besides that,
    the `OpenTelemetry` library will give you the versatility needed for enterprise
    solutions. OpenTelemetry (OTel) is a cross-platform, open standard for collecting
    and emitting telemetry data.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用Azure Monitor对于成功至关重要。当然，还有其他APM系统可以用来观察应用程序的可追溯性，但Azure Monitor为我们提供了您可能考虑使用的设施。除此之外，`OpenTelemetry`库将为您提供企业解决方案所需的灵活性。OpenTelemetry（OTel）是一个跨平台、开放标准，用于收集和发射遥测数据。
- en: 'In .NET the OpenTelemetry implementation uses well-known platform APIs for
    instrumentation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，OpenTelemetry实现使用众所周知的平台API进行仪表化：
- en: '`Microsoft.Extensions.Logging.ILogger<TCategoryName>` for logging'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Logging.ILogger<TCategoryName>` 用于日志记录'
- en: '`System.Diagnostics.Metrics.Meter` for metrics'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Metrics.Meter` 用于指标'
- en: '`System.Diagnostics.ActivitySource` and `System.Diagnostics.Activity` for distributed
    tracing'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.ActivitySource` 和 `System.Diagnostics.Activity` 用于分布式跟踪'
- en: These APIs are used by OTel for collecting telemetry and exporting this data
    to an APM service selected by the developer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API由OTel用于收集遥测数据并将这些数据导出到开发者选择的APM服务。
- en: It is also important to notice that the implementation of trace propagation
    using OTel for .NET and Azure Monitor is fully automated, which accelerates the
    process of observing the application’s behavior in Azure Monitor.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，使用OTel为.NET和Azure Monitor实现跟踪传播是全自动的，这加速了在Azure Monitor中观察应用程序行为的进程。
- en: Centralized Observability with Azure Monitor
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Azure Monitor实现集中可观察性
- en: The following example will give you an idea of how powerful Azure Monitor is
    as an APM system to centralize logging, metrics, and tracing as a professional
    observability tool, accelerating diagnosing and enabling proactive management
    with rapid troubleshooting.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将向您展示Azure Monitor作为APM系统在集中日志记录、指标和跟踪方面的强大功能，作为一个专业的可观察性工具，加速诊断并允许快速故障排除，实现主动管理。
- en: 'The code provided in startup uses Azure Monitor for registering the telemetry
    collected by `OpenTelemetry` libraries, as we can see here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动程序中提供的代码使用Azure Monitor来注册由`OpenTelemetry`库收集的遥测数据，正如我们在这里所看到的：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The same code has two APIs. The APIs will obtain data via another route, but
    one of them will try to access an unknown URL.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 同一段代码有两个API。这些API将通过另一条路径获取数据，但其中之一将尝试访问一个未知的URL。
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that the API that is working with a successful endpoint will try to access
    the Packt website.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与成功端点一起工作的API将尝试访问Packt网站。
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Both results are impressive. The first one indicates the endpoint with an error
    can be tracked entirely in the Azure Monitor End-to-end transaction view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 两个结果都令人印象深刻。第一个结果表示带有错误的端点可以在Azure Monitor端到端事务视图中完全跟踪。
- en: '![Figure 10.11: Endpoint with an error in Azure Monitor End-to-end transaction
    view](img/B31916_10_11.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11：Azure Monitor端到端事务视图中带有错误的端点](img/B31916_10_11.png)'
- en: 'Figure 10.11: Endpoint with an error in Azure Monitor End-to-end transaction
    view'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：Azure Monitor端到端事务视图中带有错误的端点
- en: This monitoring would be useful to detect this endpoint error, facilitating
    the correction of this bug.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种监控对于检测此端点错误，便于修复此错误非常有用。
- en: The second result is also interesting because it detects a redirection that
    could improve the performance of the request.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个结果也很有趣，因为它检测到一个可以改善请求性能的重定向。
- en: '![Figure 10.12: Endpoint with a successful result in Azure Monitor End-to-end
    transaction view](img/B31916_10_12.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12：Azure Monitor端到端事务视图中成功结果的端点](img/B31916_10_12.png)'
- en: 'Figure 10.12: Endpoint with a successful result in Azure Monitor End-to-end
    transaction view'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：Azure Monitor端到端事务视图中成功结果的端点
- en: The point here is that every call will take 67.2 milliseconds only to redirect
    to the page that is desired. Maybe an alternative solution would be to directly
    access the correct URL. We need to understand this example as a hypothetical case,
    but in real-world cases, this can increase the performance of the application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是每个调用只需67.2毫秒就能重定向到所需的页面。也许一个替代方案是直接访问正确的URL。我们需要将这个例子视为一个假设情况，但在现实世界中，这可以提高应用程序的性能。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had the opportunity to discuss security and observability
    strategies for serverless and microservices applications. We need to understand
    that the increase in threats posed by cybercrime moves us to integrate security
    from the initial stages of product development. To do so, we must apply, in our
    security by design approach, security best practices for databases, implementing
    authentication and authorization mechanisms like **JSON Web Tokens (JWTs)**, OAuth
    2.0, and **OpenID Connect (OIDC)**, and using network protection methods like
    **Virtual Private Clouds (VPCs)** and Azure Private Link. Encryption, HTTPS enforcement,
    and the use of Azure Key Vault for managing secrets are also important for modern
    application development.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有机会讨论无服务器和微服务应用程序的安全和可观察性策略。我们需要理解，网络犯罪带来的威胁增加促使我们在产品开发的初始阶段就整合安全。为此，我们必须在我们的安全设计方法中应用数据库的安全最佳实践，实施如**JSON
    Web Tokens (JWTs)**、OAuth 2.0和**OpenID Connect (OIDC)**等身份验证和授权机制，并使用如**虚拟私有云
    (VPCs)**和Azure Private Link等网络保护方法。加密、强制HTTPS和使用Azure Key Vault管理密钥对于现代应用程序开发也很重要。
- en: Another focus of the chapter was network security, particularly in Kubernetes
    and Azure Container Apps environments. That is why the chapter explained how Kubernetes
    network policies enhance security through the isolation of applications and services
    using namespaces and Pod-based network rules. Azure’s network security strategies
    involve virtual networks, firewalls, and private links to limit exposure to public
    threats. The chapter also discussed user security, emphasizing role-based access
    control (RBAC) in Kubernetes and Azure role assignments. It also addressed securing
    dependencies by ensuring that third-party components, libraries, and containers
    are regularly updated to prevent vulnerabilities.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的另一个重点是网络安全，尤其是在Kubernetes和Azure Container Apps环境中。因此，本章解释了Kubernetes网络策略如何通过使用命名空间和基于Pod的网络规则来隔离应用程序和服务，从而增强安全性。Azure的网络安全策略涉及虚拟网络、防火墙和私有链接，以限制对公共威胁的暴露。本章还讨论了用户安全，强调了Kubernetes和Azure的角色分配中的基于角色的访问控制（RBAC）。它还通过确保第三方组件、库和容器定期更新以防止漏洞来讨论保护依赖项。
- en: The chapter also emphasized the importance of threat detection, using web application
    firewalls (WAFs) and proactive security strategies to mitigate threats such as
    injection attacks, denial-of-service (DoS) attacks, and privilege escalation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还强调了威胁检测的重要性，使用网络应用防火墙（WAFs）和主动安全策略来减轻注入攻击、拒绝服务（DoS）攻击和权限提升等威胁。
- en: 'To finish, observability was another critical topic presented, which was defined
    through three primary signals: logs, metrics, and traces. The chapter explained
    how structured logging, categorized by severity levels, can help diagnose issues
    efficiently. It also covered key performance metrics for both serverless functions
    and containerized applications, such as execution times, resource consumption,
    and error rates. Tracing techniques, including OpenTelemetry and Azure Monitor,
    were presented as solutions for tracking distributed transactions and enhancing
    system monitoring.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可观察性是本章提出的另一个关键主题，它通过三个主要信号来定义：日志、指标和跟踪。本章解释了如何通过按严重程度分类的结构化日志来有效地诊断问题。它还涵盖了无服务器函数和容器化应用程序的关键性能指标，例如执行时间、资源消耗和错误率。包括OpenTelemetry和Azure
    Monitor在内的跟踪技术被提出作为跟踪分布式事务和增强系统监控的解决方案。
- en: Questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '**Why is security a critical concern in serverless and microservices architectures
    compared to monolithic applications?**'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么与单体应用程序相比，安全在无服务器和微服务架构中是一个关键关注点？**'
- en: Security is more critical in serverless and microservices architectures because
    they significantly expand the attack surface. Unlike monolithic applications,
    distributed systems involve multiple independent services communicating over networks,
    which increases the potential entry points for cyberattacks. Each microservice,
    API, or function might expose vulnerabilities, and the complexity of managing
    security across them demands a more comprehensive and layered approach.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器和微服务架构中，安全更为关键，因为它们显著扩大了攻击面。与单体应用程序不同，分布式系统涉及多个独立服务通过网络进行通信，这增加了网络攻击的潜在入口点。每个微服务、API或功能可能会暴露漏洞，而管理它们之间的安全性的复杂性需要更全面和分层的方法。
- en: '**What are the key layers of security in an application, and why is the “onion
    model” a useful analogy?**'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用程序中的关键安全层有哪些，为什么“洋葱模型”是一个有用的类比？**'
- en: 'The key layers of security include:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的关键层包括：
- en: Data security (e.g., encryption, secure database access)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据安全（例如，加密、安全数据库访问）
- en: Application security (e.g., authentication and authorization)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序安全（例如，认证和授权）
- en: Third-party components (e.g., library updates)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方组件（例如，库更新）
- en: Infrastructure and network security (e.g., VPCs, firewalls)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施和网络安全（例如，VPCs、防火墙）
- en: Traffic interception and monitoring (e.g., WAFs)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量拦截和监控（例如，WAFs）
- en: The “onion model” is useful because it emphasizes that security must be implemented
    in multiple concentric layers. Each layer reinforces the others, reducing the
    likelihood of a single point of failure.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: “洋葱模型”之所以有用，是因为它强调安全必须在多个同心层中实现。每一层都加强了其他层，减少了单点故障的可能性。
- en: '**How does a Virtual Private Cloud (VPC) improve security in cloud environments,
    and what are its key benefits?**'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**虚拟私有云（VPC）如何提高云环境中的安全性，以及它的主要好处是什么？**'
- en: 'A VPC creates a logically isolated network within the public cloud, allowing
    you to define custom subnets, routing rules, and gateways. Key benefits include:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: VPC在公共云中创建一个逻辑上隔离的网络，允许您定义自定义子网、路由规则和网关。主要好处包括：
- en: Reduced exposure to public threats
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少对公共威胁的暴露
- en: Fine-grained traffic control
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精细流量控制
- en: Integration with services like Azure Private Link
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Azure Private Link等服务集成
- en: Enhanced monitoring and protection through network security groups and flow
    logs
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络安全组和流量日志增强监控和保护
- en: '**What is the difference between authentication and authorization, and what
    are some commonly used authentication mechanisms?**'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**认证和授权之间的区别是什么，以及一些常用的认证机制有哪些？**'
- en: '**Authentication** is the process of verifying the identity of a user or system.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**是验证用户或系统身份的过程。'
- en: '**Authorization** determines what an authenticated user is allowed to do.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**决定了经过身份验证的用户可以执行的操作。'
- en: 'Common mechanisms include:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的机制包括：
- en: JSON Web Tokens (JWTs)
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON Web Tokens (JWTs)
- en: OAuth 2.0
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: OpenID Connect (OIDC)
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID Connect (OIDC)
- en: '**How does a JSON Web Token (JWT) ensure secure communication between a client
    and a server?**'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**JSON Web Token (JWT)如何确保客户端和服务器之间的安全通信？**'
- en: A JWT encodes user claims in a signed JSON object transferred via HTTP headers.
    After successful authentication, the server issues a token. This token is then
    included in subsequent requests by the client. Middleware on the server verifies
    the token before allowing access. The stateless and signed nature of JWTs helps
    ensure message integrity and secure access control.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: JWT通过HTTP头部传输一个签名JSON对象来编码用户声明。在身份验证成功后，服务器发放一个令牌。然后客户端在后续请求中包含这个令牌。服务器端的中间件在允许访问之前验证令牌。JWT的无状态和签名特性有助于确保消息完整性和安全的访问控制。
- en: '**What are Kubernetes resources for handling network security?**'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes中用于处理网络安全的资源有哪些？**'
- en: 'Kubernetes handles network security using:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用以下方式处理网络安全：
- en: Namespaces for isolating applications
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于隔离应用程序的命名空间
- en: Pods with specific labels and rules
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有特定标签和规则的Pod
- en: 'NetworkPolicy resources to define ingress/egress rules based on:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据以下内容定义入站/出站规则的NetworkPolicy资源：
- en: IP blocks
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP块
- en: Pod selectors
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod选择器
- en: Namespace selectors
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间选择器
- en: Ports and protocols
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口和协议
- en: These policies constrain communication between services in a modular, application-centric
    way.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略以模块化、以应用程序为中心的方式约束服务之间的通信。
- en: '**What are Kubernetes resources for handling users’ security?**'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes中用于处理用户安全性的资源有哪些？**'
- en: 'User security in Kubernetes is managed through:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的用户安全通过以下方式管理：
- en: Users and Groups
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和组
- en: Roles and RoleBindings (namespace-scoped)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色和角色绑定（命名空间范围）
- en: ClusterRoles and ClusterRoleBindings (cluster-wide)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群角色和集群角色绑定（集群范围）
- en: Permissions are defined through verbs (get, list, create, delete, etc.) and
    bound to users/groups via role bindings. Authentication typically uses client
    certificates.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动词（获取、列出、创建、删除等）定义权限，并通过角色绑定绑定到用户/组。认证通常使用客户端证书。
- en: '**Does Azure Container Apps have specific facilities for users and network
    security?**'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Azure容器应用是否有针对用户和网络安全的特定设施？**'
- en: 'Yes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 是的：
- en: Network security is handled through Azure Virtual Networks and subnets.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全通过Azure虚拟网络和子网来处理。
- en: User access is managed via Azure Role-Based Access Control (RBAC), where roles
    are assigned to users through the Azure portal or CLI.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户访问通过Azure基于角色的访问控制（RBAC）进行管理，其中角色通过Azure门户或CLI分配给用户。
- en: Azure does not have a dedicated user security model like Kubernetes but relies
    on the broader Azure identity platform.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure没有像Kubernetes那样的专用用户安全模型，而是依赖于更广泛的Azure身份平台。
- en: '**What are some common cyber threats, such as privilege escalation and denial-of-service
    attacks, and what strategies can be used to mitigate them?**'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**常见的网络威胁有哪些，例如权限提升和拒绝服务攻击，以及可以用来减轻它们的影响的策略有哪些？**'
- en: 'Common threats:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 常见威胁：
- en: '**Event injection**: Mitigated by input validation/sanitization.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件注入**: 通过输入验证/清理来缓解。'
- en: '**Privilege escalation**: Mitigated by fine-grained access controls, IAM solutions,
    audits, and MFA.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升**: 通过细粒度访问控制、IAM解决方案、审计和多因素认证来缓解。'
- en: '**DoS/DDoS attacks**: Mitigated by rate limiting, traffic filtering, auto-scaling,
    and CDNs.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DoS/DDoS攻击**: 通过速率限制、流量过滤、自动扩展和CDNs来缓解。'
- en: '**MitM attacks**: Mitigated by HTTPS/TLS encryption and authentication.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间人攻击**: 通过HTTPS/TLS加密和身份验证来缓解。'
- en: '**Code injection** (e.g., SQL Injection, XSS): Mitigated by secure coding practices,
    static analysis, and WAFs.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码注入**（例如，SQL注入，XSS）：通过安全编码实践、静态分析和WAFs来缓解。'
- en: '**What role do Web Application Firewalls (WAFs) play in securing microservices
    applications, and what are their main advantages?**'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Web应用防火墙（WAFs）在保护微服务应用中扮演什么角色，它们的主要优势是什么？**'
- en: 'WAFs monitor and filter HTTP/HTTPS traffic, blocking malicious requests before
    they reach the application. Advantages include:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: WAFs监控和过滤HTTP/HTTPS流量，在恶意请求到达应用程序之前将其阻止。优势包括：
- en: Protection against known web exploits (e.g., SQL injection, XSS)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御已知的网络漏洞（例如，SQL注入，XSS）
- en: Centralized logging and alerting (e.g., via Azure Monitor)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式日志记录和警报（例如，通过Azure Monitor）
- en: Ability to block specific clients
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够阻止特定客户端
- en: Simplified security administration
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化的安全管理
- en: Azure’s WAF integrates with Application Gateway and operates at OSI Layer 7.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Azure的WAF与Application Gateway集成，并在OSI第7层运行。
- en: '**What are the three primary signals of observability, and how do they contribute
    to maintaining a secure and efficient system?**'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可观测性的三个主要信号是什么，它们如何有助于维护一个安全且高效的系统？**'
- en: 'The three primary signals are:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要信号是：
- en: '**Logs**: Immutable event records that help in debugging and auditing.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**: 不可变的事件记录，有助于调试和审计。'
- en: '**Metrics**: Quantitative performance indicators (e.g., execution time, memory
    usage).'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**: 定量性能指标（例如，执行时间，内存使用）。'
- en: '**Traces**: Visualize request paths across services for root-cause analysis.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追踪**: 可视化服务间的请求路径，以进行根本原因分析。'
- en: Together, they allow proactive monitoring, help detect anomalies, and support
    rapid incident response—crucial for secure and resilient systems.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它们共同允许主动监控，帮助检测异常，并支持快速事件响应——这对于安全且弹性的系统至关重要。
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Azure Container Apps Networking: [https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli](https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure容器应用网络: [https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli](https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli).'
- en: 'Buy a custom domain: [https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain](https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '购买自定义域名: [https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain](https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain)'
- en: 'Storing app secrets: [https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/](https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '存储应用程序密钥: [https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/](https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/)'
- en: 'Transparent Data Encryption: [https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption](https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '透明数据加密: [https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption](https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption)'
- en: 'JSON Web Tokens: [https://jwt.io/](https://jwt.io/)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSON Web Tokens: [https://jwt.io/](https://jwt.io/)'
- en: 'OAuth 2.0: [https://oauth.net/](https://oauth.net/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OAuth 2.0: [https://oauth.net/](https://oauth.net/)'
- en: 'MSAL: [https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview](https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MSAL: [https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview](https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview)'
- en: 'What is OIDC?: [https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc](https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是 OIDC？: [https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc](https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc)'
- en: 'OIDC: [https://openid.net/](https://openid.net/)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OIDC: [https://openid.net/](https://openid.net/)'
- en: 'OWASP: [https://owasp.org/](https://owasp.org/)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OWASP: [https://owasp.org/](https://owasp.org/)'
- en: 'Azure Private Link: [https://learn.microsoft.com/en-us/azure/private-link/private-link-overview](https://learn.microsoft.com/en-us/azure/private-link/private-link-overview)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure Private Link: [https://learn.microsoft.com/en-us/azure/private-link/private-link-overview](https://learn.microsoft.com/en-us/azure/private-link/private-link-overview)'
- en: 'Network security groups: [https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview](https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '网络安全组: [https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview](https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview)'
- en: 'Virtual Network flow logs: [https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview](https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '虚拟网络流量日志: [https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview](https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview)'
- en: 'Azure Virtual Network: [https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview](https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 虚拟网络: [https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview](https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview)'
- en: 'Azure Managed Identities: [https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 管理标识: [https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)'
- en: 'Azure Firewall: [https://learn.microsoft.com/en-us/azure/firewall/overview](https://learn.microsoft.com/en-us/azure/firewall/overview)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 防火墙: [https://learn.microsoft.com/en-us/azure/firewall/overview](https://learn.microsoft.com/en-us/azure/firewall/overview)'
- en: 'Azure Web Application Firewall: [https://azure.microsoft.com/en-us/products/web-application-firewall](https://azure.microsoft.com/en-us/products/web-application-firewall)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure Web 应用程序防火墙: [https://azure.microsoft.com/en-us/products/web-application-firewall](https://azure.microsoft.com/en-us/products/web-application-firewall)'
- en: 'Azure Application Gateway: [https://learn.microsoft.com/en-us/azure/application-gateway/](https://learn.microsoft.com/en-us/azure/application-gateway/)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 应用网关: [https://learn.microsoft.com/en-us/azure/application-gateway/](https://learn.microsoft.com/en-us/azure/application-gateway/)'
- en: 'OpenTelemetry: [https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenTelemetry: [https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel)'
- en: 'GitHub Dependabot: [https://github.com/dependabot](https://github.com/dependabot)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitHub Dependabot: [https://github.com/dependabot](https://github.com/dependabot)'
- en: 'Sonar: [https://www.sonarsource.com/](https://www.sonarsource.com/)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sonar: [https://www.sonarsource.com/](https://www.sonarsource.com/)'
- en: 'Synk: [https://snyk.io/](https://snyk.io/)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Synk: [https://snyk.io/](https://snyk.io/)'
- en: 'Seq: [https://datalust.co/seq](https://datalust.co/seq)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Seq: [https://datalust.co/seq](https://datalust.co/seq)'
- en: 'ELK Stack: [https://www.elastic.co/elastic-stack/](https://www.elastic.co/elastic-stack/)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ELK Stack: [https://www.elastic.co/elastic-stack/](https://www.elastic.co/elastic-stack/)'
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
- en: 'Grafana: [https://grafana.com/](https://grafana.com/)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Grafana: [https://grafana.com/](https://grafana.com/)'
- en: 'Jaeger: [https://www.jaegertracing.io/](https://www.jaegertracing.io/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jaeger: [https://www.jaegertracing.io/](https://www.jaegertracing.io/)'
- en: 'Zipkin: [https://zipkin.io/](https://zipkin.io/)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Zipkin: [https://zipkin.io/](https://zipkin.io/)'
- en: 'Datadog: [https://www.datadoghq.com/](https://www.datadoghq.com/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Datadog: [https://www.datadoghq.com/](https://www.datadoghq.com/)'
- en: 'New Relic: [https://newrelic.com/](https://newrelic.com/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'New Relic: [https://newrelic.com/](https://newrelic.com/)'
- en: Join our community on Discord
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI生成的内容可能不正确。](img/B31916_Discord-QR-Code.png)'
