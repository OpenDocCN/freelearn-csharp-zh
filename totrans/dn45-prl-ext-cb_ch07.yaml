- en: Chapter 7. Profiling and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Threads and Call Stack windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Parallel Stacks window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching values in a thread with Parallel Watch window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting deadlocks with the parallel tasks window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring CPU utilization with Concurrency Visualizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Concurrency Visualizer Threads view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Concurrency Visualizer Cores view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel programming can create complex problems. Maybe you didn't get the performance
    gain you expected from parallelizing your application. It could even be running
    slower that a sequential version of the same algorithm. Maybe you are getting
    consistently or occasionally incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: The problems that can occur in a parallel program are numerous and can be hard
    to detect. Perhaps oversubscription is causing poor performance because of the
    high number of context switches. Maybe you have inadvertently created a lock convoy,
    which is a condition that occurs when multiple threads of equal priority contend
    repeatedly for the same lock, and can lead to significant lock contention and
    serialization of the program even though multiple threads are in use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a look at the Visual Studio 2012 debugging
    features for multi-threaded applications, and how to use those features to solve
    concurrency related issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Threads and Call Stack windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want a thread-centric view of our application, the Threads window is
    the place to start. We can use the Threads window to see the location of all of
    our threads, see the thread call stack, and more. We can use the Call Stack window
    to view the stack frames of our application, or the function, or procedure calls
    that are currently on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to see how to use the Threads and Call Stack windows
    in Visual Studio 2012 to view the call stack information for the threads in our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start looking at the debugging features of Visual Studio 2012, we
    need an application to debug. Let's create a `Console` application that spins
    up a few tasks so we can take a look at their call stack information.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `LockExample` as the **Solution name.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `using` directives to the top of your `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a few `static` methods on the `Program` class. Add a
    method named `Method1` that loops three times, creating tasks. The tasks just
    need to call `Method2` with an `integer` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create a method named `Method2`. `Method2` just adds a random number to
    the parameter, writes the parameter to `Console`, and calls `Method4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next create `Method3`, which just starts a third task that calls `Method2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, create `Method4` which contains our breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method, create a task that calls `Method1` and `Task` that calls
    `Method3`. Wait for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start a debugging session and take a look at the window.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2012, press *F5* to run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu
    of Visual Studio 2012, and click on **Windows**, and click on **Call Stack** to
    view the **Threads** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The active thread is the thread that is currently selected in the **Threads**
    window, indicated by the arrow icon. By default, the active thread is the one
    that hits the breakpoint. Switch the active thread via the **Threads** window
    by double-clicking on a different thread in the view.![How to do it…](img/0225OT_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **Debug** menu, click on **Windows,** and click on **Threads**
    to show the **Call** **Stack** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Call Stack** window indicates the top of stack of the active thread with
    a arrow icon. This is known as the active stack frame. When switching threads,
    the active stack frame changes. When execution resumes, the execution continues
    from the active stack frame onwards.![How to do it…](img/0225OT_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current stack frame is the stack frame that drives the rest of the debugger
    tools and windows. Change the current stack frame by double-clicking on a different
    entry in the **Call Stack** window. When changing the current stack frame to be
    something other than the active stack frame, it shows a tapered arrow.![How to
    do it…](img/0225OT_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can navigate to the source code for any entry in stack frame. In the **Call
    Stack** window, right-click on the function whose source code you want to see
    and click on **Go To Source Code** from the shortcut menu.![How to do it…](img/0225OT_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Parallel Stacks window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the degree of parallelism in our applications continues to grow, we need
    the ability to view and navigate multiple threads call stacks from a single view.
    A developer debugging a multi-threaded application needs the ability to view call
    stacks of multiple threads at the same time, in order to see an overall picture
    of the application's status.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use the Parallel Stacks window in Visual
    Studio 2012 to get a graphical view of the call stacks of all tasks in our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's go back to Visual Studio 2012 and take a look at the Parallel Stacks
    window.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2012, press *F5* to run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu,
    click on **Windows**, and click on **Parallel Stacks** to display the **Parallel
    Stacks** window.![How to do it…](img/0225OT_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your **Parallel Stacks** view may differ slightly from the image, but you can
    see the call stacks of all of our tasks in a single graph view. The Parallel Stacks
    window in the preceding screenshot shows that we have one thread that went from
    an anonymous method in `Main` to `Method3`, as was called out to **External Code**.
    One thread is in `Main`, and had gone out to the **External Code**. Two other
    threads started, have gone through an anonymous method in `Method1`, through `Method2`,
    to `Method4`. This is also the active stack frame and this is the current thread,
    as indicated by the flag on the active thread. Visual Studio 2012 groups threads
    that have the same call stack information together into the same box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse over the boxes and notice the tool tips that show the stack
    frame information, including method name and parameter values for each thread
    grouped into the box.![How to do it…](img/0225OT_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can double-click on any item in the stack frame of the thread to navigate
    to the code.![How to do it…](img/0225OT_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To switch to another thread, right-click on the stack frame of the desired thread
    and click on **Switch To Frame**. Notice that highlight has changed to the selected
    stack frame, and there is a green arrow in the box indicating that this is the
    current stack frame that the debugger is focusing on, as opposed to the active
    stack frame which is indicated by an arrow.![How to do it…](img/0225OT_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can switch back to the active stack frame by double-clicking on it in the
    **Parallel Stacks** windows. Notice that it has a thread icon rather than an arrow
    while the different stack frame has the focus of the debugger. Once you double-click
    on it, the arrow returns, indicating that this is the active and current thread.![How
    to do it…](img/0225OT_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the **Threads** that have called a method by clicking on the current
    stack frame, and then click on the **Method View** button on the **Parallel Stacks**
    window menu. After clicking on the button, the view will change to show which
    methods the threads are calling.![How to do it…](img/0225OT_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Watching values in a thread with Parallel Watch window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, debuggers have been designed to work in the context of a single
    thread at a time. In order to work with a different thread, you needed to first
    switch the thread context. Visual Studio 2012 has a feature known as Parallel
    Watch window that allows you to display the values of a variable or expression
    on multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to see how to view the value of a variable across
    multiple threads using the Parallel Watch window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how the Parallel Watch window can help us view variable values across
    multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2012, press *F5* to run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu
    of Visual Studio 2012, and click on **Windows**. Then click on **Parallel Watch**
    and **Parallel Watch 1** to view the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the **Parallel Watch** window brings up all the threads currently
    executing in the process. In order to add new watches, we need to click on **<Add
    Watch>** column which allows us to enter an expression. Click on **<Add Watch>**
    and enter numbers as the expression to watch. As soon as the watch is added we
    can now see the expression evaluated across all the different threads in the **Watch**
    window.![How to do it…](img/0225OT_07_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a Boolean expression in the **Filter by Boolean Expression** box. The
    debugger evaluates the expression for each thread context. Only rows where the
    value is true are displayed.![How to do it…](img/0225OT_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detecting deadlocks with the Parallel Tasks window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very useful feature of the Visual Studio 2012 debugger is the ability to detect
    deadlocks in your tasks. A deadlock occurs when two or more tasks permanently
    block each other by each task having a lock on a resource which the other tasks
    are trying to lock, or by waiting for each other to finish.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to find a deadlock in your application is to use the Parallel
    Tasks window of Visual Studio 2012\. The Parallel Tasks window is very similar
    to the Threads window, except that it shows information about each `Task` or `task_handle`
    object instead of each thread, along with the status of the task.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a `Console` application that will create
    several tasks in a loop. The tasks will deadlock because each task will be waiting
    for the next task to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we use the Parallel Task window to see the deadlocks in our code, we
    need to create an application that has some deadlocks for us to see.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `DetectDeadlock` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, let's start by creating a variable
    for the number of tasks to create `CountDownEvent`, and an array of `tasks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, just below the previous code, let's create the blocked `tasks` in a `for`
    loop. Each task should wait for the next task to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create and start a couple of tasks that won't block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `Main` method by waiting for `CountDownEvent` and setting a breakpoint
    for `Debugger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Visual Studio 2012, press *F5* to run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the debugger hits the `Debug.Break` statement, go to the **Debug** menu
    of Visual Studio 2012 and click on **Windows**. Then click on **Parallel Tasks**
    to view the window.![How to do it…](img/0225OT_07_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Parallel Tasks** window you can see all of the tasks that have been
    identified to be deadlocked. Hover your mouse over any of the blocked tasks to
    see what the task is waiting for.![How to do it…](img/0225OT_07_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For applications with a lot of tasks, it can be useful to group the tasks by
    their status. Right-click anywhere in the **Parallel Tasks** window, click on
    **Group By** and then click on **Status**.![How to do it…](img/0225OT_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure CPU utilization with Concurrency Visualizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel applications are not only prone to common sources of inefficiency that
    are found in sequential applications, but they can also suffer from uniquely parallel
    performance issues such as load imbalance, excessive synchronization overhead,
    or thread migration.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding such performance issues can be a difficult and time-consuming
    process. However, Visual Studio 2012 includes a profiling tool, the Concurrency
    Visualizer, which can significantly reduce the burden of parallel performance
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will be looking at the CPU Utilization view of the Concurrency
    Visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at the Concurrency Visualizer, we need to create a `Console`
    application that is going to exercise the processor on your development machine
    a bit. This `Console` application will be a slight variation of the `MultipleProducerConsumer`
    application we created in [Chapter 5](ch05.html "Chapter 5. Concurrent Collections"),
    *Concurrent Collections*. The application will use a `for` loop to create some
    producer `tasks` that the producers use to perform a mathematic operation on some
    numbers, and add the results to `BlockingCollection`. `BlockingCollection`, which
    is a class that provides blocking and bounding capabilities for thread safe collections
    that implement `IProducerConsumerCollection<T>`. There will also be four consumer
    `tasks` that retrieve the results from `BlockingCollection` and write them to
    `Console`.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `MultipleProducerConsumer` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's add a `static` method to the `Program` class which the producer tasks
    will call to perform the calculation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, just below the previous method, let's create another `static` method that
    consumer `tasks` will use to write the results to `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method, let's start by creating `BlockingCollection`, to be the
    buffer between the producers and consumers, list of tasks, and the definition
    for four consumer `tasks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `for` loop that spins up some producer `tasks`, performs
    the calculations, and adds the results to `BlockingCollection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create a continuation that calls `CompleteAdding` on `BlockingCollection`
    when all producer `tasks` finish. Wait for the user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how we can use Concurrency Visualizer to report on the performance
    and efficiency of parallel code.
  prefs: []
  type: TYPE_NORMAL
- en: On Visual Studio 2012 menu, click on **Analyze**, and then click on **Concurrency
    Visualizer**, and **Start with Current Project**. You will see the application
    running while Visual Studio 2012 collects data and builds a report in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the application finishes running, close the application. Visual Studio
    2012 will then finalize and open the performance report.![How to do it…](img/0225OT_07_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the report is completed and loaded, you will see the **Utilization** view
    of the Concurrency Visualizer. The X axis shows the **Elapsed Time** since the
    trace started. The Y axis shows the number of logical processor cores in your
    system. The green area shows the **Number of Logical Cores** that the application
    is using at any given point in the analysis run. The rest of the cores are either
    idle, or are being used by **Other Processes** which are shown by the gray lines
    coming from the top of the graph. There is a **Zoom** slider at the top which
    can be used to narrow the time scale of the graph.![How to do it…](img/0225OT_07_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When tuning your parallel application, this view allows you to confirm the degree
    of parallelism. You can get hints of common parallel performance problems by reviewing
    the graph. Load imbalances among the processor's cores appear as stair-step patterns
    in the graph. Contention for synchronization objects appear on the graph, such
    as serial execution when parallel is expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Concurrency Visualizer Threads view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads view is probably the most useful and frequently used view in the Concurrency
    Visualizer. By using this view, you can identify whether the threads are executing
    or blocking because of synchronization or some other reason. Threads view assigns
    a category to each context switch when a thread has stopped executing.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the Concurrency Visualizer to show all of
    the context switch events for each application thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same sample application as in the previous
    recipe. If you have closed the `MultipleProducerConsumer` solution, please reopen
    it, and go to the Concurrency Visualizer through the Visual Studio 2012 menu,
    and click on **Analyze**. Then, click on **Concurrency Visualizer**, and **Open
    Trace.** Alternately, you can rerun the Concurrency Visualizers as in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at what we can do with the Concurrency Visualizer Threads
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Concurrency Visualizer** for the **MultipleProducerConsumer** solution
    and click on the **Threads** view.![How to do it…](img/0225OT_07_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the **Threads** view opens, you will notice that the X axis is again a
    **Timeline**. However, the Y axis is divided into horizontal channels. If the
    physical disks on your machine have any activity during the running of the application
    (which in this case they don't), the top channels will depict your physical disks.
    In our case, the channels are all threads in our application. You will see the
    `Main` thread, a debugger helper thread, and all of your worker threads. Below
    the list of **Threads**, you will see the **Execution Categories** that are assigned
    by Concurrency Visualizer. In the following screenshot, you can see that the application
    spent **16%** of the **Timeline** in **Execution** and **71%** of the **Timeline**
    in **Synchronization**.![How to do it…](img/0225OT_07_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on one of the CLR worker threads in the top channel. The **Timeline**
    next to the channel for the **CLR Worker Thread** will be divided into the **Time
    slices** for the thread. Click on the **Current** tab in the **Profile Report**
    tab. You will see the call stack for the thread at the time of the context switch,
    the reason for the context switch, and **Category** assigned by the report. You
    can see on the **Current** tab that this thread was context switched because it
    arrived at a **Monitor.Wait** call.![How to do it…](img/0225OT_07_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the most valuable features of the **Threads** view is the ability to
    determine thread dependencies. Select a synchronization segment for a worker thread
    (a pink segment). On the **Current** tab you will see the thread that unblocked
    the current thread. Click on the **Unblocking Stack** tab and you will see the
    call stack of the thread that unblocked the current thread.![How to do it…](img/0225OT_07_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Concurrency Visualizer Cores view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frequent context switching can seriously degrade application performance, especially
    when threads migrate across cores when they resume execution. The reason for this
    performance impact is that running threads load instructions and data they need
    into the cache hierarchy, and when a thread resumes execution on a different core,
    there can be latency while working data is reloaded from memory or other caches.
  prefs: []
  type: TYPE_NORMAL
- en: The Cores view of the Concurrency Visualizer is a tool that aids in identifying
    excessive context switches. In this recipe, we will return to the `MultipleProducerConsumer`
    solution to see how we can examine the context switching that occurs in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same sample application as in the previous
    recipe. If you have closed the `MultipleProducerConsumer` solution, please reopen
    it and go to the Concurrency Visualizer through the Visual Studio 2012 menu. Click
    on **Analyze**, and then click on **Concurrency Visualizer**, and **Open Trace**.
    Alternately, you can rerun the Concurrency Visualizers as in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the Concurrency Visualizer for the `MultipleProducerConsumer` solution
    and click on the **Cores** view.![How to do it…](img/0225OT_07_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like the other views, the **Cores** view displays the timeline on the X axis.
    The logical cores of the system are shown on the Y axis. Each thread in the application
    is shown in a different color, and thread execution segments are displayed on
    the core channels.![How to do it…](img/0225OT_07_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The statistics shown in the **Cores** view help the developer to identify **Threads**
    that have excessive context switches and incur core migrations. The list of threads
    at the bottom of the **Cores** view is sorted by the number of **Cross-Core Context
    Switches**. Click on the thread with the highest number of core switches (the
    top thread in the list). Notice how the thread execution is spread across the
    available **Cores** in your system.![How to do it…](img/0225OT_07_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
