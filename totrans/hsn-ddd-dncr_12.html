<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Bounded Context</h1>
                </header>
            
            <article>
                
<p>So far, we have spent quite a lot of time working on our <kbd>Marketplace</kbd> system, as it will be a single application with one API and, possibly, one web UI that will talk to that API to serve its users. However, now it is time to take a step back and look at the big picture.</p>
<p>I've been writing software since the age of 15; so, as of writing this book, my experience in the industry is close to 30 years. Some systems that I've built have been replaced by something new and some are still very active, being developed further by other developers. Today, as I go along in the industry as a software architect and a consultant, I am involved in many hands-on activities, such as prototyping, modeling, and writing production code. Over the years, not only have I progressed as a developer so I write better-quality code, but I have also understood more about the foundational principles of building complex systems. This knowledge and experience allow me to be more successful with the companies I work for to create systems that will evolve and not need major rewrites in a couple of years.</p>
<p>One of the things that I believe made me a better developer and architect is the realization that systems can rarely be modeled as something singular and unbreakable, as a single unit. We already discussed the contextual nature of language in <a href="6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml" target="_blank">Chapter 2</a>, <em>Language and Context</em>, and that hopefully led you to understand the importance of context.</p>
<p>During my career, I have seen many complex systems that were implemented as a single code base, with a single data model supporting it. In this chapter, we are going to look closer at this approach and, hopefully, I will convince you that it does not always work and there is a better way. We will spend some time discussing how the language context can be used to discover parts of the whole system that could be developed more efficiently with a good degree of isolation and autonomy.</p>
<p>In this chapter, you will learn:</p>
<ul>
<li>How linguistic boundaries can help identify system boundaries</li>
<li>The definition of Bounded Context</li>
<li>The benefits of splitting systems into parts</li>
<li>Which factors need to be considered when context boundaries aren't clear</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The single model trap</h1>
                </header>
            
            <article>
                
<p>Let's take a look at how software usually starts its life, when developers first get their hands on keyboards and start writing code, hoping to build something useful. We will follow the usual progress that software companies (or IT departments) make while addressing the needs of their users, over the years they spent, working to make the software more useful, adding features and fixing issues. What I describe next is the usual evolutionary growth of software solutions that can be found everywhere. It is possible that some parts of the picture that I am going to paint will be recognizable to you and will resonate with your experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting small</h1>
                </header>
            
            <article>
                
<p>We rarely find ourselves working for a company that has colossal plans to conquer the world with majestic software that solves a huge problem for humanity. Well, some businesses try but inevitably fail, and that's probably one of the well-learned lessons that people rarely forget. More often than not, businesses are trying to solve real problems that people are dealing with frequently. At least, that's what people that run the company believe. So, as a developer, you probably would work on a system with a reasonable scale, unless you work for a software giant such as Microsoft or SAP. But make no mistake, they started small as well, although most people forget that.</p>
<p>When a couple of developers start working on a system, everything works quite well because the team is small and the goal is hopefully quite clear. If the problem they are aiming to solve is real and the solution is viable, the company would probably start making some money rather quickly, after spending a year or two to build the first version of the software. By that time, the system would still be reasonably small and the number of people building it won't exceed a handful of engineers. Companies such as Uber, AirBnB, and GitHub all started that way.</p>
<p>In the beginning, everything is fine. Then, at some point, the system becomes quite large and the productivity starts to decrease due to the size of the system. One single data model is being changed for many different reasons, conflicting interests of multiple product owners of project managers that all have their own teams working on different parts of the system start to struggle with a growing number of conflicts. The coordination effort grows since different teams touch places in the systems that they didn't expect to, but they must in order to do their work. But often such changes interfere with other teams' work. Releases are being heavily coordinated and the effort of making a release sometimes exceeds the effort of creating features. The company never releases on Friday, because the risk is too high and people are almost certain that there are bugs that weren't caught during the testing phase, although the QA team is doing their best. Fixing bugs becomes a challenging and daunting task; by fixing one bug developers create two more.</p>
<p>Does this sound familiar to you? If not—you are very lucky, probably the company you work for is already doing DDD or something similar. For me, after spending decades in the industry, this is a very common situation. To be honest, I've never worked in a company that hasn't had those issues. So, how did such a small and concise system eventually become an unmanageable monster that developers don't dare touch?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Complexity, again</h1>
                </header>
            
            <article>
                
<p>If you have some years of experience in the software development industry and have worked at one or more companies, you've probably worked on some production systems. Systems that are in production usually bring value to their users in one way or another. Such a system could be a product that people around the world use to solve their daily tasks, such as buying goods online or tracking their pets on a live map. Other systems are used internally to support company employees in what they do and by doing so, contributing indirectly to the value chain. That could be, for example, supply management, finance, billing, scheduling, or yield-management systems. Many companies develop their internal systems, which embrace the highest level of the domain knowledge that has been inherited by a long, successful history of a company's way of doing things over the years.</p>
<p>Usually, people need software to solve complex problems. Complex problems can rarely be solved by simple solutions; we spent a good deal of time discussing this matter in <a href="948b7834-c47c-4321-a91c-2ba58068c52e.xhtml" target="_blank">Chapter 1</a>, <em>Why Domain-Driven Design?</em> and <a href="6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml" target="_blank">Chapter 2</a>, <em>Language and Context</em>. One inevitable aspect of dealing with a complex system is that such systems grow over time. Engineers grasp more and more of the business insight and capture the ever-changing needs of their users in code. Unavoidably, such evolutionary progress leads to the ever-increasing complexity of the software, reflecting the complexity of business problems that the software is trying to address.</p>
<p>So, even if the original plan is to build a rather simple solution to fix one or two things that we think people struggle with in their daily work, hoping that they will thank us for it by buying our product, we find ourselves on a slippery slope from the start. Our users would never be fully satisfied. No one wants to pay continuously for something that doesn't evolve. So, unless you are building a simple, catchy game app for a smartphone, hoping for millions of users to pay you once, you are probably building software that evolves over time.</p>
<p>More often than not, we cannot create a model for our software that will be valid for many years. Our understanding of the domain changes, our ignorance decreases, and we learn more about our users and their wishes. Something that was clear three months ago is not as clear today, and the model that was perfectly fine last year is now an obstacle. But, do we keep spending the time to find a better model and refactor our code to reflect these new insights? Well, not always.</p>
<p>When the system is new and the market pressure is high, developers are being pushed to deliver new features instead. So, the software just grows, in the number of features, number of lines of code, number of database tables, and the relations between them. We have no time to take a break, take a deep breath, and look at the model to see whether it can be improved. I won't even mention the time to refactor the code for features that have already been delivered—what's done is done; the project manager would rarely understand the need to rewrite code that already works.</p>
<p>But that is not the worst part of it. As I mentioned before, nearly all systems start with a small code base. A small persistence model, or what we hear more often, the <em>data model</em>, comes along. We might not even have a class diagram, but most certainly someone spent time creating a relational model for the system, because relational databases are seen as the <em>default</em> choice to persist almost anything in this world, especially if you are working in a .NET space that is dominated by enterprises and companies that prefer using everything from Microsoft. So, SQL Server it is, most of the time.</p>
<p>New features lead to changes in the data model, new tables are added, new fields are added to the existing tables and before you realize, when you want to get anything from your database, you have to write a query with five inner joins because your DBA says that the database must be normalized and data duplication is evil. But some tables have so much data that you cannot just add a new field with a <kbd>NOT NULL</kbd> constraint, so you must add a couple of left outer joins as well. Of course, there are a couple of hundred stored procedures here and there, since it is faster that way and some people who worked here before you were better at writing SQL than C#. But stored procedures cannot be tested in isolation, and everything is tested on a copy of the production database. To add an insult to injury, there are no unit tests for the SQL code because the QA engineer will do regression tests manually anyway. Some stored procedures are so old that people prefer adding code at the end and don't dare touch the existing code for fear of breaking things because, well, there are no tests for stored procedures. Tables are well-known to be unavailable for the <em>find usages</em> feature of Visual Studio, so nobody really knows whether that particular table is being used for any query, although it occupies one gigabyte of the disk space that we tried to save by applying the third-level normalization to the database in the first place.</p>
<p>Maybe the picture I had drawn here is too dark, but I've seen it some many times during my decades of working in the industry that it is very hard for me to make it any softer. Does all or some of it sound familiar to you as well?  So, where exactly did it go wrong? Surely, we can blame SQL databases for everything and try to change them to something fancier, but would we ever be sure that by doing such a thing we solve any of the aforementioned issues? At the end of the day, databases are just tools and like any other tool, it is used or misused.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Big ball of mud</h1>
                </header>
            
            <article>
                
<p>What I described in the previous section is a pattern (or, more precisely, anti-pattern) known as <em>Big Ball of Mud</em>. The term was suggested by Brian Marick and then popularized by Brian Foote and Joseph Yoder in their paper called, unsurprisingly, <em>Big Ball of Mud</em>, published in 1997 (<a href="http://www.laputan.org/mud/">http://www.laputan.org/mud/</a>).</p>
<p>Developers don't intentionally create software that later can be characterized by this awful term. We constantly work under pressure of the management, who want to get value from the software that we build and they see the value as new features. So, we don't really find time to improve the structure of our software. At least, this is the most common excuse that we give when someone asks us why the code is so convoluted and hard to maintain.</p>
<p>But, is it true? Is that the sole reason that exists for us to forget about the architecture and design? Certainly, the given reason is a valid one, but not the only one. What we tend to forget is that we don't really build systems. Such systems already exist and our software becomes part of some system.</p>
<p>Think about any kind of business. If you work for a bank, the bank is the system. It probably existed before without the software that is currently being used by the bank employees. Banks are interconnected and heavily regulated. They have customers with certain expectations about the reliability of the service provided by banks and the safety of their funds. This is just one of the countless examples that we can find around us.</p>
<p>Repeatedly, we make the same mistake of developing software that we see as a system on its own, ignoring the fact that it is just a part of something bigger, which is, in itself, a system. As I wrote before, software usually solves complex problems and therefore exists as a part of a larger landscape of some complex system. So, what is the system?</p>
<p>In the book <em>Thinking in Systems</em> by Donella H. Meadows, has defined system as an element set, which is interconnected. Such elements are organized in a coherent manner.</p>
<p>There are surprisingly many things we can learn from such a short definition; for now, let's concentrate on the fact that no system consists of just one part and the parts of the system are always interconnected, exchanging information between them, and that is something we often forget about. System parts are not classes, modules, database tables, or stored procedures. These are atoms of a certain system part. What we usually do is try to put too many parts in one box and call it a software system. Let's check one trivial example to illustrate the inevitable path that leads us to the big ball of mud.</p>
<p>Think about an e-commerce system that deals with customer orders. Obviously, we need somewhere to keep information about all the products we sell. Definitely, we must be able to place orders and follow the order cycle, from the moment an order is placed until it is delivered. We start small and create a simple model, such as this one:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9cd7ad90-e3a6-4a8a-91d1-557b6b7cbd50.png" style="width:43.83em;height:24.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Simple e-commerce model</div>
<p>Of course, after a little while, we realize that the price on each order line cannot refer to the product price and must be fixed at the moment the line is created, so we implement that as well. Later, we get a requirement to keep the supplier information as well. Then, we must add a product image URL. When we start doing things for real, we must keep the stock-level information. Not long after that, we get a requirement to add the product-packaging information and the dimensions along with the weight, to be able to calculate shipping costs. Before we know it, our model looks quite a bit different:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/616e2b0b-c1a5-40ba-b411-bab7a3631f2e.png" style="width:54.92em;height:42.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The model becomes larger with time</div>
<p>You might notice that the full model is certainly different since you can find references such as <kbd>PaymentMethodId</kbd>, <kbd>PaymentTermsId</kbd>, and <kbd>PaymentId</kbd>, which must point to some tables as well. But I think this is enough to show the essence of it.</p>
<p>My point here is that we can clearly see that a small original model uncontrollably grew, following the requirements coming from different directions, trying to satisfy all needs at once. You might notice one field of the <kbd>Product</kbd> table, called <kbd>UpdatedAt</kbd>. I haven't invented it but found it on a sample model, posted as the answer to some question on Stack Overflow. Now, let's imagine what the significance of the date we put in this field was. Was the name of the product updated on that date? Or the price? Or, perhaps, the stock level? All those changes have completely different reasons; however, we only have one field to keep the date and time of the change.</p>
<p>What is the danger of having a model such as this? At the end of the day, there are countless products that have such models in their backend and some of them are even quite successful. Not so much, I would say. Such companies and products usually thrive despite having such a model, not because of it. Let's see what happens when features are requested by different stakeholders:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3a82bde-4532-4ccf-99b5-8b5f61e090af.png" style="width:44.50em;height:34.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Coupling is not only for code. It applies to the whole organization.</div>
<p>The sales team is now interested in selling the product in packages. They tell us that it is quite simple—we just need to create <em>a special type of product</em> and a simple child-parent relationship. They don't really think about the supply chain but we currently have all this information in one place. If different components of this fictitious packaged product come from different suppliers, who will actually be <em>the</em> supplier for it? The stock level is even trickier, it seems like we must calculate on-demand?</p>
<p>The sales team also wants to have a tighter relationship with customers and give them a call when they stop buying from us. Maybe they have found another supplier and we can offer them a discount? To do that, we <em>simply</em> need to keep track of the running total of all sales for each customer and compare the numbers with our history. But, we don't have any history, so where do we get such data in the first place?</p>
<p>The finance team wants to see the total outstanding amount of customers who pay after they get the product, so-called <strong>credit line customers</strong>. If they are late with their payment, the finance department should decide different strategies for the debt collection, based on the amount. They see it as <em>just add another field</em> to the <kbd>Customer</kbd> table.</p>
<p>We also have to address the request of the marketing team. They want to improve sales by showing more photos of a product. Right now, we have only one and they want at least three; but ideally, they need an unlimited number of pictures for any product. So, we either need to <em>just add two more fields</em> to the <kbd>Product</kbd> table or add a new table for photos with the many-to-many relationship; but in the latter case, we'll have to deal with data migrations.</p>
<p>All those requests are potentially conflicting. We can clearly see that the same parts of the model will be touched when developers will be working on those new features. Let's add more damage to the picture and remember that we have three development teams. One team is only doing changes at the backend, two other teams are doing the frontend work—one for the web and the other for the legacy WinForm client.</p>
<p>The issue now is that we have three conflicting forces that push their requests through to developers, and in addition, we have three conflicting development teams working on the same parts of the model. It is hard to imagine that any of the frontend teams will be able to finish their work before the backend team will do the necessary changes to the database model and for all necessary layers if they have any.</p>
<p>Overall, we can see that the singular model for anything less trivial than a <kbd>Hello World</kbd> application would most probably lead to a big ball of mud. It might happen in a couple of months, but with a small team of good developers, a company might be happy with such a model for quite a while. But as soon as the business and the system grow, the mud monster will come and potentially do a lot of harm. At the very least, productivity will suffer. At most, the customers will get so annoyed by the lack of progress and the overall application performance that they will leave.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structuring systems</h1>
                </header>
            
            <article>
                
<p>I know I've been painting a somewhat horrifying picture so far now—when software undeniably slips toward becoming an unmanageable clew of spaghetti code. You might be wondering: what's the point if we end up in the land of horror anyway? When we find ourselves there, we can start fresh, and learn from the past to build a new, shiny, bright system, with the newest technology and everything will be fine again. We will get back to the big rewrite topic later on, but for now, let's think about why the new system would be better than the old one.</p>
<p>No matter whether we are planning to create a new software system or to refactor the old one, there is at least one thing we can do to ensure that we keep our software in good shape for quite a long time. We might not be able to use the most beloved programming language, the new, shiny silver-bullet framework, or a fancy new database, because our organization has certain constraints that are hard or impossible to fight against. These constraints rarely impose significant limitations on how we design our models. In the design of domain, models are where we can find the key to building better software.</p>
<p>In <a href="07ee37fb-0189-467c-865d-18e72868b137.xhtml" target="_blank">Chapter 3</a>, <em>EventStorming</em>, we discussed domain models. We should remember that models don't represent the real world. Instead, models provide a simplified version of the real world that is relevant for building a particular piece of software. Throughout this book, we've learned to avoid giving more information and behavior to our models than was absolutely necessary in order to solve the specific problems that we are aiming to solve with our software.</p>
<p>But now we see that as the number of concerns for the software grows, the amount of required information in the model grows as well. At the same time, we clearly see that this information is put together into a single model deliberately by developers, who tend to enrich the domain object with unrelated properties. It usually happens because the domain object name seems to be the same across different domains, but developers don't realize this.</p>
<p>Now, we are going to look at how we can structure our software better, providing clear separation for concepts with similar names but different meanings. DDD offers the concept of <em>Bounded Context</em> to define such separation and we are going to look at how to find and define boundaries for such contexts.</p>
<p>Make no mistake, when I write about structuring the system, going away from a single model and introducing boundaries, this doesn't imply having multiple executables, using microservices, migration to Docker, and so on. Bringing sanity to domain models is the most important topic and we will touch upon the implementation details in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linguistic boundaries</h1>
                </header>
            
            <article>
                
<p>Remember that we talked about the <em>speed of change</em> when we were going through the aggregate design topic? So, you might wonder if we are going in circles right now. Indeed, we can clearly see that things such as the thumbnail URL or the photo URL of the product have nothing to do with the product price or stock level. The stock level might change every second if the product is popular and we have enough customers. The price might be dynamic as well, but we could expect it to be more stable. Photos, however, will probably never change, along with the weight and the packaging size. Keeping all this information in one aggregate is not something we'd embrace and we learned about this already.</p>
<p>Where, then, do we keep it? Do we create several aggregates, all called <kbd>Product</kbd>? Although that might sound weird, the answer could be <em>yes</em> if we can identify the boundaries where each of those aggregates will live. We must also talk to our domain experts and gain more insight, at least about the language. Some new discoveries could await us there, such as the inventory level is indeed being referred to as <kbd>Inventory</kbd> and not <kbd>Product</kbd>. But for some other areas, such as sales, marketing, and procurement, they may use the same term and mean different things. As we learned in <a href="6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml" target="_blank">Chapter 2</a>, <em>Language and Context</em>, we can see the context is changing there.</p>
<p>When I see very common words such as <kbd>Customer</kbd>, <kbd>Person</kbd>, <kbd>Contact</kbd>, or <kbd>Order</kbd> scattered upon a large code base, an alarm bell goes off in my head. Here be dragons or, to be more specific, the big ball of mud. Developers of this system weren't cautious enough to dive deeper into the domain specifics to find what these terms mean in different parts of the business. If we look at the <kbd>Product</kbd> example in the previous diagram, we could see unrelated concepts placed in one object for no particular reason.</p>
<p>I can't stress enough how dangerous this approach is for the software and beyond. Think about a meeting you might have with two domain experts. One would be telling you about adding more pictures to the product to enrich the catalog. Another one is only interested in the delivery process and needs to have the product weight and packaging details to calculate the shipping costs. You might notice the difference in their language, and from such a conversation you might learn that the single model that you already have or plan to implement won't suit the business.</p>
<p>So, defining bounded contexts about the meaning of words, looking for particularities, and being eager to truly understand the context where these words are being used is the first and the most powerful method to find context boundaries:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ac75fdbe-476c-4f73-ae09-e1d64424241a.png" style="width:57.33em;height:42.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Words change meaning in a context</div>
<p>As you can see, one single term that is used in a different context with a different meaning can be modeled inside its own context with a concise meaning. Instead of a single object with unrelated properties, we now have several. Those new objects are much smaller and contain only the information that is relevant to the specific context. Making a change to an object in one context should have no effect on all other objects with the same name in other contexts, and it can be made freely by the developer that works with the context where these changes are being made, eliminating, or at least minimizing, the risk of introducing issues elsewhere. Naturally, this brings us to the next purpose and benefit of bounded contexts: the autonomy of development teams.</p>
<p>Another aspect of context boundaries is the extended <em>Tell, Don't Ask</em> principle. The original principle was formulated by Alec Sharp in his book <em>Smalltalk by Example</em>, published in 1997.</p>
<p>As you might have noticed from your own experience, there is a lot of code out there in production software that uses procedural style, even if it is written in an object-oriented language. Unfortunately, .NET-based projects suffer from this a lot, especially those that are written using WinForms and ASP.NET (<a href="https://dotnet.microsoft.com/apps/aspnet">https://dotnet.microsoft.com/apps/aspnet</a>) WebForms. I've seen many applications where the business logic is concentrated inside the code—behind UI elements, scattered across numerous <kbd>OnClick</kbd> event handlers.</p>
<p>Better-designed software uses separate classes to implement business logic. The pattern that embraces the isolation of the business logic from the UI logic and the persistence is known as <strong>multilayer architecture</strong> or <strong>n-tier architecture</strong>. Wikipedia defines this term as a <em>client-server</em> type of architecture, but that is not exactly correct. You can have multiple layers without separating client and server code if the application is a desktop rich-client application or a web application with server-side rendering, where all actions cause a roundtrip to the server.</p>
<p>When we are looking for context boundaries, one of the indicators that can help in finding them is the availability of information that is needed to make decisions. When users (which could potentially include other systems) send commands to the domain model, the model itself must be able to handle this command without going to other parts of the system to fetch information. That might be confusing at the beginning because, at first glance, we might see that some commands require a lot of information that we considered to be located outside of the context where the command is executed. Let's take a look at the e-commerce example again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9e6a4f14-4746-4b78-8de2-56e386cf6d33.png" style="width:46.08em;height:22.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Several queries are needed to make a decision</div>
<p>When we tell the domain model of the <kbd>Sales</kbd> context to place an order, it seems to require a lot of information from other contexts to make decisions for the command's execution. This can create quite a lot of confusion, and if we follow our gut without thought, we would hardly resist the urge to put all the information from the whole system in one place. And, the big ball of mud strikes again.</p>
<p>In reality, we only need a fraction of the information from other contexts to make that decision. Besides, if we consider commands that affect that information, we could quite clearly see that none of them will be touching the sales context. For example, the inventory level is updated solely inside the <kbd>Inventory</kbd> context. The available credit limit for a customer is balanced between the agreed initial credit limit and the number of unpaid invoices. Contact details of the customer are updated in a completely independent fashion from anything else.</p>
<p>But, you might have noticed that there is still some level of information exchange. How does the inventory level change? How does the unpaid amount for the customer get updated? Surely, there are some actions that trigger those updates. We feel that somehow these triggers are linked to the order processing and that might even increase our certainty to put everything together, again.</p>
<p>But wait a minute. The inventory level doesn't necessarily decrease when the order is placed. We might need to clarify that with domain experts, but most certainly, the inventory only gets updated when the order is shipped and that's probably not handled by <kbd>Sales</kbd> but by the <kbd>Shipment</kbd> context instead. The same happens with the total outstanding amount—it probably only gets updated when we send an invoice for the order. That, in turn, might only happen when the order is shipped or even delivered. So, you can see that these links between contexts are not really that direct and straightforward. There is more logic involved that we might not even consider at first glance.</p>
<p>The topic of cross-context communication will be briefly touched upon in the next chapter, but even now I can tell you that it happens by the same <em>Tell, Don't Ask</em> principle. Contexts emit domain events after executing each command, as we learned in <a href="07ee37fb-0189-467c-865d-18e72868b137.xhtml" target="_blank">Chapter 3</a>, <em>EventStorming,</em> and even implemented in the earlier chapters. We never used those events to share the information, but that's exactly how the necessary—and only the necessary—data gets across context boundaries. So, we might need to have some context-specific objects that we haven't originally considered. Let's look at the revised diagram of the <kbd>Place an order</kbd> command and the details needed to execute it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/045a56d0-a7ba-4210-bc39-3a5e4e800619.png" style="width:51.17em;height:25.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Tell-only flow</div>
<p>Here, you can see that there are no <em>ask</em> arrows anymore. All we do is <em>tell</em> others either to do something, or that something has been done.</p>
<p>There are two points that I would like to draw your attention to:</p>
<ul>
<li>You might wonder why the CRM context is not sharing any information with the <kbd>Sales</kbd> context. Don't we need customer details to place an order? Not exactly. We might need this information to know the customer's name and contact details to know where the order needs to be delivered. But none of those details is required to decide whether we can place the order. Of course, we might get more complicated requirements, when orders for certain delivery addresses cannot be placed, but that is something that needs to be clarified with domain experts and, clearly, some more domain knowledge is required to get such constraints into the system.</li>
<li>I often hear complaints that keeping the information about the same physical entity in different contexts leads to data duplication. In the model shown in the previous diagram, that is not the case. The information we share is not exactly the same as the data we keep inside each context. For example, the number of product items available for sale doesn't necessarily replicate the current stock item. Some more complicated rules might be involved and the sales domain is kept happily ignorant to those rules, which are completely internal to the <kbd>Inventory</kbd> context. But then, some data will definitely be duplicated and that is a small price to pay to keep our models clean. There is no harm in keeping the same data in multiple places, the disk space is not a big issue these days.</li>
</ul>
<p>But we definitely must ensure that keeping the information in sync is reliable, which is something we will be looking in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Team autonomy</h1>
                </header>
            
            <article>
                
<p>If you ever used Kanban or at least learned about it, you probably remember that the holy grail of this methodology is to reduce <strong>work in progress</strong> (<strong>WIP</strong>). There is a lot you can learn from Kanban practitioners, but if you don't limit the WIP, you aren't doing Kanban. That, by the way, is why teams often fail when trying the methodology.</p>
<p>Originally, the idea of doing the work in small batches to eliminate queues and stocking up materials along the value creation stream comes from the manufacturing industry. You've probably heard of the <em>Toyota Way</em>, where Kanban originates from, or the <strong>Theory of Constraints</strong> (<strong>ToC</strong>) formulated by Eliyahu M. Goldratt. Although the philosophy of those methods comes from a rather different industry, where some of the aspects are drastically different from the software industry, I'd like to emphasize the following two principles that we can directly apply to our work in order to be more efficient in delivering business value: limiting work in progress and improving throughput.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limiting work in progress</h1>
                </header>
            
            <article>
                
<p>When a team or an individual developer is working on a list of things at the same time, completing any single item from the list would always take more time than if they were working solely on one thing. That happens, above all, due to the context switching, which I mentioned in <a href="6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml" target="_blank">Chapter 2</a>, <em>Language and Context</em>. When we change our focus from one task to another, there will always be some time lost to bring our mind to the state when we can work on the new task efficiently. The more things we have unfinished, the more things that need to be remembered and then recovered—from memory and notes—when we go back to an unfinished task.</p>
<p>When teams that are working on a system that has a single model and single monolithic code base, those teams will have to coordinate with each other. Coordination might be required to prevent changes in share classes that are being changed for unrelated reasons. They might also need to ensure that before one team makes their changes, the other team does some prerequisite work. Data migration, regression testing, coordinated releases, and so on—we are quite familiar with those type of dependencies between teams.</p>
<p>But management rarely cares about such dependencies. If during the stand-up meeting, one team reports that they are waiting for another team to complete their work, their manager will ask them to do something else while they are waiting. When that happens, they get one more WIP item that cannot be completed right now, so they pull another item from the backlog and start working on it. That item might get some dependency as well and so the number of unfinished work snowballs. Teams start to blame each other for not delivering anything at all since they were all waiting for someone else.</p>
<p>What suffers most in these situations is the throughput.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving throughput</h1>
                </header>
            
            <article>
                
<p>If there is a step in the delivery pipeline that is slow, the whole pipeline cannot produce more than this single step does. When teams work on a single codebase and a single model, they can have two major issues. First, there's the always-growing work in progress, as described in the previous paragraph. A constant need for coordination and continuous waiting leads to a lot of unfinished business. Some items from the <em>in progress</em> list will eventually be worked on again after the wait is over, but then comes the context switching. Sometimes, teams spend days or weeks picking up the work they put on hold a couple of months before. The time that is spent on the cross-team coordination—waiting for the others to complete the prerequisite job and to get back to the new context—is wasted. During that time, no value is produced but the money is spent as if the teams were doing something useful.</p>
<p>One more thing that could affect the throughput is a bottleneck. If all changes need to be done by two teams, no matter how fast or brilliant one team is, if the other team is slow or suffers from being understaffed of not skilled enough, the work will not be finished before the slowest of the two teams completes their part. Such a situation usually happens in organizations that split their teams not based on domain expertise or function, but on technological skill. A typical example would be the frontend team, the backend team, and the database team. You don't need to have all three, having just two of those will do enough damage to slow down the value chain tremendously. Before the database schema is changed, no work can be completed at the backend. Before the backend job took shape, at least in a form of the API contract (if the company is skilled enough to embrace contract-based development), the frontend team can do very little without having a risk of rewriting half of their code.</p>
<p>When teams are structured in this way, we can observe the worst example of Conway's law in real life.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conway's law</h1>
                </header>
            
            <article>
                
<p>Fifty years ago, in 1968, Melvin E. Conway published his paper called <em>How Do Committees Invent</em>? (<a href="http://www.melconway.com/research/committees.html">http://www.melconway.com/research/committees.html</a>). Perhaps the most cited part of that paper is the formulation of what we now call <strong>Conway's law</strong>, which states that if an organization designs a system, it will produce a design with a copy of that organization's communication structure.</p>
<p>I don't really want to overload you with details now but remember that this definition became so relevant that the 2017 edition of the DDD Europe conference had Conway's law as the main topic.</p>
<p>In the context of this chapter, my personal observations that how organizations structure their teams directly impacts the structure of their software, very much confirm the hypothesis of Mel Conway. I gave an example of technically-oriented teams because I experienced it during my career more than once. In one organization, I saw that the team that worked on a web part of the system user interface came so much in conflict with the team that was working on the rich-client for the same system, that they decided to create a separate domain model, backed by a separate database model, for them to use. That was done solely to avoid having blocking dependencies between those teams since they couldn't find a good way to coordinate. A lot of blood was spilled between those teams blaming each other, but in my view the situation was inevitable and there was no one to blame except the management that decided to structure teams like that.</p>
<p>Coordination between teams rarely works and most often leads to delays, tons of time spent on meetings and context switching. It also creates tensions between teams and create risks to slide into the blame-game. We can talk about <em>improving communication</em> for years and it won't improve the coordination even slightly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loose coupling, high alignment</h1>
                </header>
            
            <article>
                
<p>I probably drowned you in the sea of problems that our industry suffers from on a large scale today. Let me bring some light to the picture and give you some clues as to how we can improve the situation.</p>
<p>As developers, we hear that we need to strive toward loose coupling and high cohesion in our code. Overall, the principle of one unit is responsible for one thing applies not only for classes in our code but also, for example, for services in the <strong>service-oriented architecture</strong> (<strong>SOA</strong>). It also applies to the responsibilities of teams. Structuring teams around their technical proficiency are suboptimal. Let's look at how such teams might work when we have two distinct feature requests:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c9416cb-57f5-4c33-9ce2-6158645f76e9.png" style="width:55.42em;height:22.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Flow when coordination is required</div>
<p>The flow shown in this diagram is greatly simplified, but you get the idea. All those white spots in between chunks of work that the teams are doing to complete those two stories are mostly wasted. That time could be spent on waiting, context switching, and small-scale coordination when developers from different teams need to agree on the sequence of work and issues discovered in the deliverables of other teams. In the end, there is not a single delivery done during the time frame, teams keep switching between tasks but the release is being constantly postponed.</p>
<p>If, however, teams are organized around business functions, or domains, the picture would be completely different:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6ba01d02-141b-425d-bc92-f33bd8c56ec1.png" style="width:57.08em;height:16.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Flow without coordination</div>
<p>Don't be mistaken by the linear flow of work, since it is placed on a singular timeline. All these steps can be done in iterations, but iterations itself won't save you if teams require coordination.</p>
<p>Even if the amount of work is more or less the same, although it would probably be less due to a better focus and deeper domain knowledge, the coordination effort is gone along with context switching. Both teams are able to release independently and be ready to pick up new tasks.</p>
<p>Highly-aligned and loosely-coupled teams are one of the fundamental principles of the highly-praised Netflix culture, for example. One of the prerequisites to make such a structure even feasible is to have clear boundaries where each team operates. It doesn't mean, however, that teams must be assigned to work with a single bounded context. You might identify six contexts and have only three teams. In such a case, you need to look at the team size first. If each team has 10 members, maybe you want to have more teams that are smaller. Teams of five are fine in keeping the information-sharing tight and the feedback loop short.</p>
<p>But, there is no limitation to how many contexts one team can own. I can easily imagine a rather complex system that is being developed by a startup company that only has 10 engineers. They might identify that due to the complexity of the problem they are trying to solve, the system would need to be modeled with 10 bounded contexts. If they divide all developers into two teams of five, each team can handle multiple contexts. The most important aspect here is the ownership of the context, so teams should not share contexts. Transferring of the ownership is definitely possible, but it should be rare and complete so that after the transfer is complete, only one team owns the context.</p>
<p>The match between bounded contexts and teams can also give an indication of how many engineers the company might need. If the core business domain is properly identified, most probably all developers will work on the core domain With time it might happen that one team is solely engaged with the core business problem and another team is doing the work with all the supportive subdomains, such as account management, payment processing, and billing. When the complexity of the software grows, those supportive subdomains might be transferred to new teams. If a new core domain has been identified, some other team needs to take charge.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Geography</h1>
                </header>
            
            <article>
                
<p>The last point that I would like to make in relation to Conway's law is the physical location of teams. It might come as a surprise, but this aspect is very important. Nowadays, more and more companies hire remote workers that work from home and also keep open offices on different parts of the planet. Keep in mind that such a distribution of the workforce, despite getting wider access to talent, also brings the burden of communication that is completely different for co-located teams and distributed teams.</p>
<p>If one bounded context is given to a team that contains members in different countries, or even worse, in different time zones, there will be a high level of risk involved. If engineers in such a team are experienced remote workers, it might be not a problem at all. But if people in that team are used to working in the office and suddenly they are asked to work together with someone that wakes up when they plan to go home, it might not work at all. So, it is a good idea to keep the geography consolidated if your company doesn't have much experience working with a remote workforce.</p>
<p>That shouldn't be seen as an obstacle to hire people in other countries and let them work remotely. But you might want to have several people that can sit in one place or at least live in one town, so they can communicate efficiently, meet <span>regularly </span>or even share one office, and call them a team. Such a team can easily take ownership of one or more of the bounded contexts of your software. The reduced burden of coordination and the high level of autonomy—those benefits of clearly defined bounded contexts will most certainly allow making even remote teams be much more successful and productive.</p>
<p>In fact, I believe that most of the failures that we hear about, when companies open remote offices and after some time declare the experience as a failure, are related to the fact that these companies weren't able to articulate the work they were giving to remote teams as bounded contexts. If teams are working on a shared code base, they must coordinate. They may make conflicting changes and all the burden and frustration that co-located teams are struggling with is multiplied by 10 when the teams are geographically distributed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we finally started to use the term Bounded Context. It is often overlooked by people who started learning DDD. In Eric Evans's book, <em>Bounded Context</em>, it is explained in the strategic design part, which starts quite late in the book. A lot of useful patterns are introduced in that book before getting to the concept of Bounded Context and naturally, people start using what they know and sometimes find that to be enough.</p>
<p>But make no mistake, the power of DDD is not in aggregates and repositories. If you have a single model for a large, complex software system, having aggregates and repositories won't help you. When a large number of developers work with a single model, they suffer from an extensive need for coordination, conflicting changes, regression bugs, cognitive overload, and constant context switching. The fact that contexts aren't articulated properly in such a system doesn't remove them from existence. These contexts still exist as long as the business has people that are specialized in executing different business functions. Contexts lurk in a massive number of lines of code, numerous classes, and database tables that contain information about everything that happens. So, context switching is there, whether you like it or not.</p>
<p>As I first heard from Vaughn Vernon, DDD is a Ubiquitous Language developed within a Bounded Context. I like this definition a lot. It brings two of the most important principles of DDD into the spotlight. There is nothing more important than getting the language right, then finding linguistic boundaries for terms that are expressed by the same words but have a different meaning. And that would be the first obvious step toward finding the context boundaries.</p>
<p>Conway's law is something you must not ignore. If teams aren't structured by business capability and function, and instead are specialized by technical responsibility, even perfect Bounded Contexts won't help you. Only proper cross-functional teams that are organized around functional aspects of the system, that take ownership of one or more bounded contexts, will be able to work effectively and successfully. That is due to the fact that well-defined context boundaries bring the greatest level of autonomy to teams, as soon as no more than one team owns one bounded context. That doesn't imply that your organization must have as many teams as the number of identified bounded contexts. One team can probably handle more than one context, but not the other way around. High alignment and loose coupling are not only applicable for classes and services; these principles are fundamental for building successful teams that deliver.</p>
<p>Don't forget about the location of your colleagues. Distributed teams could work if they consist of people that have experience working remotely. But a remote team can take responsibility for one or more bounded contexts since they will not require a lot of coordination with other teams.</p>


            </article>

            
        </section>
    </body></html>