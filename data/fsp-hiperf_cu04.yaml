- en: Chapter 4. Introduction to Concurrency in F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. F# 并发简介
- en: Performance optimizations are not just about understanding the underlying platform,
    profiling, toolings and measurements, and data structures. Now, with the rising
    trend of multicore processors and at the same time, the increasing needs of responsive
    applications to be achieved as and when required, concurrency is not just becoming
    more relevant but also a necessary requirement across all kinds of enterprise
    applications, especially applications across all full stacks of layers of multi-tier
    architecture applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化不仅仅是理解底层平台、分析、工具和度量以及数据结构。现在，随着多核处理器的兴起，以及响应式应用程序按需实现的需求不断增加，并发不仅变得更加相关，而且成为各种企业应用程序，尤其是全栈多层架构应用程序的必要要求。
- en: It is also evident that concurrency is one of those performance optimizations
    that are often misunderstood. Some common misunderstood samples have already been
    described in [Chapter 1](fsp-hiperf_cu01.html#aid-E9OE2 "Chapter 1. Performing
    Common Optimizations in F#"), *Performing Common Optimizations in F#*. In this
    chapter, we will focus on concurrency features in F# and also get to know the
    basic strategy behind the deciding factor of the actual implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并发是那些常被误解的性能优化之一。一些常见的误解示例已在第 1 章 [在 F# 中执行常见优化](fsp-hiperf_cu01.html#aid-E9OE2
    "Chapter 1. Performing Common Optimizations in F#") 中描述。在本章中，我们将关注 F# 中的并发特性，并了解实际实现决策因素背后的基本策略。
- en: To understand the background reasoning for the chosen strategy, first we must
    get to know the features of concurrency in F# especially in F# 4.0\. There is
    no noticeable difference between F# 3.0 and F# 4.0 in terms of the existing concurrency
    features. There are F# 4.0 additional features to have interop with .NET Task
    Parallel Library, as these interop features will be explained in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解选择策略的背景推理，首先我们必须了解 F# 的并发特性，特别是在 F# 4.0 中。在现有的并发特性方面，F# 3.0 和 F# 4.0 之间没有明显的区别。F#
    4.0 有额外的特性可以与 .NET Task Parallel Library 互操作，这些互操作特性将在本章中解释。
- en: Having a knowledge of measurement tooling, covered in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement*, qualitative
    knowledge of the mechanism of running F# code (the IL, tooling, and the GC), and
    having quantitative measures (the execution durations using timers and unit tests)
    are requirements in order to easily understand the importance of concurrency and
    the decisive factor of choosing the right concurrent model.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 了解测量工具，如第 2 章 [性能测量](fsp-hiperf_cu02.html#aid-K0RQ2 "Chapter 2. Performance
    Measurement") 中所述，以及运行 F# 代码（IL、工具和 GC）的定性知识，以及使用计时器和单元测试的定量度量，是轻松理解并发的重要性以及选择正确并发模型的决定性因素所必需的。
- en: Throughout this chapter, we will see that there is no silver bullet for all
    kinds of concurrency problems. For example, using only parallel computation to
    handle I/O operations is not recommended because I/O operation is a good sample
    of a blocking thread. However, it is also important to identify which threads
    or processes are blocking threads. Combining this with asynchronous computation
    is recommended. Also, there is not a single concurrency feature that cannot be
    combined with other kinds of concurrency features, as will be introduced in this
    chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到对于各种并发问题并没有一劳永逸的解决方案。例如，仅使用并行计算来处理 I/O 操作是不推荐的，因为 I/O 操作是阻塞线程的一个很好的例子。然而，识别哪些线程或进程是阻塞线程也很重要。结合异步计算是推荐的。此外，正如本章将要介绍的那样，没有哪个并发特性不能与其他类型的并发特性结合使用。
- en: This chapter gives a gentle overview of the concurrency features of F#, focusing
    on F# 4.0\. We will also provide an overview of the best practices to implement
    and optimize it. Advanced topics of concurrency optimizations in F#, such as combining
    asynchrony and parallelism, the F# message passing agent, `MailboxProcessor`,
    and further interop with .NET TPL, will be described in [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2
    "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency Support
    in F#*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了 F# 的并发特性，重点关注 F# 4.0。我们还将提供实现和优化它的最佳实践的概述。F# 并发优化的高级主题，例如结合异步和并行处理、F#
    消息传递代理 `MailboxProcessor` 以及与 .NET TPL 的进一步互操作性，将在第 5 章 [高级并发支持在 F#](fsp-hiperf_cu05.html#aid-164MG2
    "Chapter 5. Advanced Concurrency Support in F#") 中描述。
- en: 'This chapter covers the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introducing concurrency support in F# 4.0
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍F# 4.0中的并发支持
- en: Identifying blocking threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别阻塞线程
- en: Introducing asynchronous workflow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍异步工作流
- en: Introducing concurrency support in F# 4
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍F# 4中的并发支持
- en: 'It is important to have concurrency support from the programming language perspective,
    especially as built-in language features. In F#, concurrency support in F# was
    available before F# 4.0\. Two of the concurrency features: the asynchronous workflow
    and `MailboxProcessor` have been available since F# 1.9.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程语言的角度来看，拥有并发支持非常重要，尤其是作为内置语言特性。在F#中，在F# 4.0之前就提供了F#的并发支持。其中两个并发特性：异步工作流和`MailboxProcessor`自F#
    1.9以来就可用。
- en: 'In a quick overview, F# has the following concurrency features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 快速概述，F#具有以下并发特性：
- en: Asynchronous workflow
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作流
- en: Asynchronous message passing using actor model and an F# special class that
    functions as an agent for message passing, `MailboxProcessor`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用actor模型和F#的一个特殊类`MailboxProcessor`作为消息传递的代理进行异步消息传递
- en: Parallel programming support for asynchronous workflow
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作流的并行编程支持
- en: Interop with .NET Task Parallel Library (TPL)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与.NET Task Parallel Library (TPL)的互操作性
- en: Asynchronous workflow is actually an implementation of a computation expression
    that is escalated as syntactic sugar. It is escalated within a block of asynchronous
    code that has calls to asynchronous functions, marked in the beginning with `async`
    as keyword.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流实际上是一种计算表达式的实现，它作为语法糖被提升。它在一个异步代码块中被提升，该代码块包含对异步函数的调用，并在开头用`async`作为关键字标记。
- en: 'From the perspective of conceptual concurrency, it is quite intuitive and easier
    to understand that F# has support for the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念并发的角度来看，F#支持以下内容是相当直观且易于理解的：
- en: '**Asynchronous concurrency**: in `async` and `MailboxProcessor`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步并发**：在`async`和`MailboxProcessor`中'
- en: '**Parallel concurrency**: parallel supports in asynchronous workflow and interop
    with .NET TPL'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行并发**：支持异步工作流中的并行操作以及与.NET TPL的互操作性'
- en: Each of the supports is not a static solution for a single problem; for example,
    `MailboxProcessor` can be combined with parallel concurrency as well. It is also
    quite common to combine `MailboxProcessor` with async workflow, and then execute
    it in parallel as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个支持都不是针对单个问题的静态解决方案；例如，`MailboxProcessor`也可以与并行并发结合使用。将`MailboxProcessor`与异步工作流结合，然后并行执行也是相当常见的。
- en: There is no comparable built-in asynchronous message passing support in other
    languages such as C#/VB in the release of Visual Studio 2015\. Even in .NET BCL,
    there is no message passing agent implementation at all. Some known message passing
    agents are available from outside .NET BCL, in the form of message passing combined
    with the actor model. Usually, they come in the form of a NuGet package available
    for download or in the form of a commercialized class library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio 2015的发布中，其他语言如C#/VB没有可比较的内置异步消息传递支持。即使在.NET BCL中，也没有消息传递代理的实现。一些已知的消息传递代理可以从.NET
    BCL外部获得，以消息传递与actor模型相结合的形式。通常，它们以NuGet包的形式可供下载，或者以商业化的类库形式存在。
- en: The discussion on the best practices and usage of `MailboxProcessor` will be
    discussed in [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced
    Concurrency Support in F#"), *Advanced Concurrency Support in F#*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`MailboxProcessor`的最佳实践和使用的讨论将在[第5章](fsp-hiperf_cu05.html#aid-164MG2 "第5章。F#的高级并发支持")中讨论，*F#的高级并发支持*。
- en: 'There is a known actor-based library of concurrency that comes from Microsoft
    Research; it is called Orleans. It is open source but it is unfortunately only
    optimized for cloud development and deployment especially in Azure. For more information
    about Orleans, visit:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 来自微软研究的一个基于actor的并发库是已知的；它被称为Orleans。它是开源的，但遗憾的是，它仅针对云开发和部署进行了优化，尤其是在Azure上。有关Orleans的更多信息，请访问：
- en: '[https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/)'
- en: Fortunately, F# concurrency can be used and implemented in accordance with the
    other languages as well, as long as it's based on a common version of .NET CLR.
    We could also leverage the async-await model of C#/VB into the F# async workflow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，F#的并发可以在与其他语言兼容的.NET CLR版本上使用和实现。我们还可以利用C#/VB的async-await模型到F#的异步工作流中。
- en: To use and to have interop with asynchronous methods in the .NET Framework that
    are designed for other asynchronous models with the F# asynchronous programming
    model, you create a function that returns an F# `async` object. The F# library
    has functions that make this easy to do.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用并与其他异步模型设计的 .NET Framework 中的异步方法进行互操作，使用 F# 异步编程模型，你需要创建一个返回 F# `async`
    对象的函数。F# 库中有函数可以简化这一过程。
- en: 'On the implementation detail, F# concurrency support has the following building
    blocks:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现细节上，F# 的并发支持有以下构建块：
- en: '**Control.Async<''T>**: This is a type in the `Microsoft.FSharp.Control` namespace
    to contain asynchronous operation.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Control.Async<''T>**：这是 `Microsoft.FSharp.Control` 命名空间中的一个类型，用于包含异步操作。'
- en: '**The Control.Async**: This is a class in the `Microsoft.FSharp.Control` namespace
    that contains all of the supports for asynchronous operations, support for .NET
    TPL, and for executing asynchronous workflow in parallel.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Control.Async**：这是 `Microsoft.FSharp.Control` 命名空间中的一个类，它包含所有异步操作的支持、.NET
    TPL 的支持以及并行执行异步工作流的支持。'
- en: '**Control.AsyncBuilder**: This is a builder class in `Microsoft.FSharp.Control`,
    to construct F# asynchronous workflow, including the implementation of `let!`
    and `use!` for containing the result of asynchronous operations.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Control.AsyncBuilder**：这是 `Microsoft.FSharp.Control` 中的一个构建器类，用于构建 F# 异步工作流，包括实现
    `let!` 和 `use!` 以包含异步操作的结果。'
- en: '**F# asynchronous primitives**: These are classes that may extend the existing
    .NET BCL with methods that implement F# asynchronous workflow, such as the `Control.WebExtension`
    and `Control.CommonExtension` modules. Both of them are in the `Microsoft.FSharp.Control`
    namespace.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**F# 异步原语**：这些是可能通过实现 F# 异步工作流的方法扩展现有 .NET BCL 的类，例如 `Control.WebExtension`
    和 `Control.CommonExtension` 模块。它们都位于 `Microsoft.FSharp.Control` 命名空间中。'
- en: To further illustrate the relations, all of the asynchronous types, parallel
    types, and builders for asynchronous workflow are concentrated under the `Microsoft.FSharp.Control`
    namespace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明关系，所有的异步类型、并行类型和异步工作流的构建器都集中在 `Microsoft.FSharp.Control` 命名空间下。
- en: 'The hierarchical illustration is as shown in the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构图如下所示：
- en: '![Introducing concurrency support in F# 4](img/image00288.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![在 F# 4 中引入并发支持](img/image00288.jpeg)'
- en: F# asynchronous primitives are called **asynchronous primitives** because they
    perform a single asynchronous task and return the result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的异步原语被称为 **异步原语**，因为它们执行单个异步任务并返回结果。
- en: It is quite common that asynchronous workflow is often used to handle blocking
    threads. Whether we are aware of the existence of blocking threads or not, it
    is very important to know the traits or characteristics the blocking threads have
    and not just to understand the definitions of a blocking thread.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流通常用于处理阻塞线程是非常常见的。无论我们是否意识到阻塞线程的存在，了解阻塞线程的特性或特征，而不仅仅是理解阻塞线程的定义，这一点非常重要。
- en: Identifying blocking threads
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别阻塞线程
- en: 'A thread, from the perspective of interactions with other threads, is divided
    into two kinds: *non-blocking thread* and *blocking thread*. A non-blocking thread
    is usually a thread that does not block any other thread.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从与其他线程交互的角度来看，线程可以分为两种：*非阻塞线程*和*阻塞线程*。非阻塞线程通常是指不会阻塞其他线程的线程。
- en: A blocking thread means a thread that does operations that often force the execution
    context to wait for other *operations*. By nature, in this context of operations,
    there can be many kinds of operations and interactions with other kinds of subsystem
    components such as I/O and CPU thread counter such as the operation performed
    in `System.Threading.Thread.Sleep`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞线程意味着执行那些经常迫使执行上下文等待其他 *操作* 的操作的线程。本质上，在这种操作和与其他子系统组件（如 I/O 和 CPU 线程计数器）交互的上下文中，可能存在许多种类的操作和交互，例如在
    `System.Threading.Thread.Sleep` 中执行的操作。
- en: Overview of the background technical reasons for the blocking nature of I/O
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 阻塞特性的背景技术原因概述
- en: I/O is never separated from the implementation and usage of our application,
    especially applications that deal with networking and sending commands to an output
    device outside the scope of the subsystem, such as printers. It is often ignored,
    but it is becoming relevant that as a running application is expected to be as
    responsive as possible, the nature of any I/O operation cannot be ignored.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: I/O永远不会与我们的应用程序的实现和使用分离，特别是处理网络和向子系统范围之外的输出设备发送命令的应用程序，如打印机。这通常被忽视，但随着运行中的应用程序被期望尽可能有响应性，任何I/O操作的性质不容忽视。
- en: I/O operations have a tendency to force us to wait, although this wait should
    be treated as being placed in a different execution context rather than in the
    current thread. This is why the concept of having asynchronous operations is more
    relevant as the wait should not be synchronous.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: I/O操作有强迫我们等待的趋势，尽管这种等待应该被视为放置在不同的执行上下文中，而不是在当前线程中。这就是为什么异步操作的概念更为相关，因为等待不应是同步的。
- en: Then why are I/O operations really *blocking threads*?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么I/O操作实际上是*阻塞线程*呢？
- en: 'Consider the following sample facts/scenarios:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例事实/场景：
- en: You send I/O commands to a printer (with the data) to print some data (usually,
    any kind of data formats supported by the underlying OS). There is no guarantee
    that the printer is always turned ON or that the printer is not busy. There can
    also be some forms of latency that we cannot control directly, such as network
    latency when transferring commands and data to be printed. Even when you are connecting
    your machine directly to the printer, there is no guarantee that the printer is
    always on and ready to process your commands. For example, your machine might
    have other running background processes that deal with other I/O, such as hard
    disks, especially when performing virus scans.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你向打印机发送I/O命令（附带数据）以打印某些数据（通常，任何底层操作系统支持的数据格式）。没有保证打印机总是开启或打印机不忙。也可能存在一些我们无法直接控制的形式的延迟，例如在传输命令和数据到打印机时的网络延迟。即使你直接将机器连接到打印机，也无法保证打印机总是开启并准备好处理你的命令。例如，你的机器可能运行着其他处理其他I/O的后台进程，如硬盘，尤其是在进行病毒扫描时。
- en: You send HTTP requests on a host that you have tested with a ping before. There
    is no guarantee that at the time of sending the HTTP requests, the destination
    host is still available or that the host is even ready to process your requests
    and return responses. If the host is available and ready to process your requests,
    you cannot control exactly how quickly the destination host would reply with responses
    and how responsive it would be. Again, network latency also plays a huge role
    in dealing with roundtrips of HTTP request-response.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在之前用ping测试过的主机上发送HTTP请求。没有保证在发送HTTP请求时，目标主机仍然可用，或者主机甚至准备好处理你的请求并返回响应。如果主机可用并准备好处理你的请求，你无法控制目标主机以多快的速度回复响应以及其响应性。再次强调，网络延迟在处理HTTP请求-响应往返中也起着巨大的作用。
- en: A simple ping to any other host is also an I/O operation in action. Again, there
    is no guarantee that the destination host will respond to your ping (usually in
    ICMP packets).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向任何其他主机发送简单的ping操作也是一种正在进行的I/O操作。再次强调，没有保证目标主机会对你的ping做出响应（通常是在ICMP数据包中）。
- en: You are performing defragmentation on your local hard disk and expecting to
    do something else. Even with most of the Windows or other modern OSes such as
    Linux's distributions with latest kernel, there is no guarantee that you won't
    have to wait for the defragmentation to finish completely or that you can do other
    operations without interruptions from the defragmentation operations. Normally,
    you should not interrupt or even interfere with the current intentional I/O operations
    such as storage defragmentation. This is often misunderstood by a common computer
    user as bugs, although it is defragmentation that is obviously impacting storage
    as I/O. Therefore, it should not be considered as a bug in our code.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在对本地硬盘进行碎片整理，并期望做其他事情。即使是在大多数Windows或其他现代操作系统（如Linux的最新内核发行版）中，也无法保证你不需要等待碎片整理完成，或者你可以在碎片整理操作的中断下进行其他操作。通常，你不应该中断或干扰当前的有意I/O操作，如存储碎片整理。这通常被普通计算机用户误解为错误，尽管碎片整理显然是在影响存储作为I/O。因此，它不应被视为我们代码中的错误。
- en: 'Based on the preceding common facts, these I/O operations all have one thing
    in common: *we have to wait*. It also clearly defines that I/O operation is one
    sample of a side-effect because we cannot control it fully and it is out of the
    scope of the current execution thread of our code.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的共同事实，这些I/O操作都有一个共同点：*我们必须等待*。这也清楚地定义了I/O操作是副作用的一个示例，因为我们无法完全控制它，并且它超出了我们代码当前执行线程的范围。
- en: 'The conclusion is obvious and quite clear: any I/O operation must be considered
    as a blocking thread.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结论很明显且非常明确：任何I/O操作都必须被视为阻塞线程。
- en: These side effects should not be considered as bugs based on the nature of the
    operations running out of the scope boundary of the execution, but any errors,
    especially exceptions that might have occurred, must be handled. In other terms,
    these side effects must not be ignored and cannot be treated in a normal synchronous
    way because we have to wait for them to complete.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作超出执行范围边界的本质，这些副作用不应被视为错误，但任何错误，特别是可能发生的异常，都必须被处理。换句话说，这些副作用不应被忽略，也不能以正常同步的方式处理，因为我们必须等待它们完成。
- en: The best practices of exception handling (including the details when dealing
    with concurrency problems) will be discussed in detail in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimization*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的最佳实践（包括处理并发问题的细节）将在[第7章](fsp-hiperf_cu07.html#aid-1ENBI1 "第7章。语言特性和结构优化")中详细讨论，*语言特性和结构优化*。
- en: It is easier to summarize blocking threads as part of operations that are also
    considered as blocking threads, such as I/O operations described previously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将阻塞线程总结为也是被视为阻塞线程的操作的一部分，例如之前描述的I/O操作，这更容易。
- en: Obvious trait of a blocking thread
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞线程的明显特征
- en: In a simple definition, a blocking thread is part of any operation or function
    that *waits for an event to occur or a time period to elapse*. While a blocking
    call is waiting, the operating system can often remove that thread from the scheduler,
    so it takes no CPU time until the event has occurred or the time has elapsed.
    Once the event has occurred, then the thread is placed back in the scheduler and
    can run when allocated a time slice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单定义中，阻塞线程是任何操作或函数的一部分，*等待事件发生或时间间隔过去*。当阻塞调用等待时，操作系统通常可以将其线程从调度程序中移除，因此它不占用CPU时间，直到事件发生或时间过去。一旦事件发生，则该线程被放回调度程序，并在分配到时间片时运行。
- en: It seems quite difficult to relate with I/O, but all I/O operations again always
    have a waitable behavior and can always be considered as blocking operations.
    This is not just a strong sample of a side effect. The operations that require
    us to wait are also available in other kinds of operations, especially if the
    operations are doing many things either in a definite amount of time or indefinite
    amount of time. We can parallelize this, but there is always a limited amount
    of computations available as opposed to the nature of most applications that usually
    do not care about this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与I/O相关联似乎相当困难，但所有I/O操作再次总是具有可等待的行为，并且始终可以被视为阻塞操作。这不仅仅是一个副作用强烈的表现。需要我们等待的操作也存在于其他类型的操作中，尤其是如果操作在确定的时间或不确定的时间内做很多事情。我们可以并行化这些操作，但可用的计算量总是有限的，这与大多数应用程序的本质不同，通常不关心这一点。
- en: The context of waitable operations is the source of inspiration for the introduction
    of TPL in .NET 4.0, especially to define any task that is waitable as identified
    by the async-await pattern and the `TaskAwaiter` implementation. All of these
    waitable tasks can be used in asynchronous blocks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可等待操作的上下文是.NET 4.0中引入TPL的灵感来源，特别是为了定义任何可等待的任务，这些任务通过异步-await模式以及`TaskAwaiter`实现来识别。所有这些可等待的任务都可以用于异步块。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is also in sync with the C# 4 and VB 10 releases: the async models leverage
    these waitable patterns by enforcing all the tasks to be awaitable, wrapped in
    an awaiter of `TaskAwaiter`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它也与C# 4和VB 10的发布同步：异步模型通过强制所有任务都是可等待的，并使用`TaskAwaiter`的awaiter来利用这些可等待模式。
- en: For example, you cannot always consider that your application will always run
    using the fastest CPU with many cores. Any assumption that your application will
    run successfully in many cores without paying attention to how you treat the concurrent
    running of your application can slow down your application performance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你并不能总是认为你的应用程序将始终在具有许多核心的最快CPU上运行。任何假设你的应用程序在没有注意如何处理应用程序的并发运行的情况下，能够在多个核心中成功运行，都可能降低你的应用程序性能。
- en: Any successful enterprise application must be able to scale itself in a sense
    that it must consider that the number of users of the application can grow and
    that the operations they will engage when they use the applications can be arbitrarily
    complex. Therefore, paying attention to how the code will run across many CPU
    cores and also paying attention to the responsiveness of the application, especially
    paying attention to any blocking operations, are requirements, not just recommendations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何成功的企业应用程序都必须能够在某种程度上自我扩展，这意味着它必须考虑应用程序的用户数量可能会增长，以及他们使用应用程序时将参与的运算可能是任意复杂的。因此，注意代码如何在多个CPU核心上运行，以及注意应用程序的响应性，特别是注意任何阻塞操作，都是要求，而不仅仅是建议。
- en: It also brings a more interesting fact that it is easier to get used to identifying
    blocking threads by identifying blocking operations first. Identifying blocking
    threads first is also a good practice to have a best practice mindset because
    we often misunderstand blocking threads as non-blocking threads due to common
    assumptions that applications usually running in modern CPUs are always fast by
    default.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它还带来一个更有趣的事实，即通过首先识别阻塞操作，更容易习惯于识别阻塞线程。首先识别阻塞线程也是一种良好的实践心态，因为我们常常由于常见的假设，即现代CPU上运行的应用程序默认情况下总是很快，而错误地将阻塞线程视为非阻塞线程。
- en: The context of *does not block any other thread* is often misunderstood. A thread
    can block other threads even if it was considered a non-blocking thread. For example,
    a very intensive computation that requires CPU-intensive operations, such as complex
    number-related calculations that are targeted for a specific CPU core, can block
    other threads that want to use any available core if the other core might be busy
    processing other calculations or processes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “不会阻塞任何其他线程”的上下文常常被误解。即使被认为是非阻塞线程，一个线程也可能阻塞其他线程。例如，一个非常密集的计算，需要CPU密集型操作，如针对特定CPU核心的复杂数值计算，如果其他核心可能正忙于处理其他计算或进程，它可能会阻塞想要使用任何可用核心的其他线程。
- en: 'Consider this sample illustrated scenario running on the 4th generation of
    Intel core i5 that has two physical cores:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例场景，它运行在第4代英特尔酷睿i5上，该处理器有两个物理核心：
- en: '![Obvious trait of a blocking thread](img/image00289.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![阻塞线程的明显特征](img/image00289.jpeg)'
- en: 'The details of the scenario are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的详细信息如下：
- en: The running code runs on a machine that has the 4^(th) generation of Intel core
    i5 processor. This processor has two physical cores and each core has two hyper-threading
    units.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行中的代码在具有第4代英特尔酷睿i5处理器的机器上运行。该处理器有两个物理核心，每个核心有两个超线程单元。
- en: The running code (it acts as a process under the runtime context) asks to run
    on the 1^(st) core explicitly, so it assumes that the remaining core (in this
    case, only one core) should be available for others.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行中的代码（在运行时上下文中充当进程）明确请求在第一个核心上运行，因此它假设剩余的核心（在这种情况下，只有一个核心）应该对其他人可用。
- en: Then the other process suddenly runs in the background, and it needs a high
    thread affinity, for example, processes by antivirus software. Most antivirus
    software always try to ask for a higher thread affinity when they are scheduled
    to run a full scan at a scheduled time. Another sample is when a Windows update
    is performing a background installation update after it has finished downloading
    all of the updates available at the time the code runs.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，另一个进程突然在后台运行，它需要一个高线程亲和度，例如，由防病毒软件处理的进程。大多数防病毒软件在计划在预定时间进行全盘扫描时，总是试图请求更高的线程亲和度。另一个例子是在代码运行时，Windows更新在下载完所有可用更新后，在后台执行安装更新。
- en: All of these other processes, therefore, are cramped into only one core, and
    they can interfere with each other so that one process may take over the entire
    CPU core cycle.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，所有这些其他进程都挤在一个核心中，它们可能会相互干扰，以至于一个进程可能会占用整个CPU核心周期。
- en: Based on this scenario, a blocking thread can be caused by non I/O operations
    as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个场景，阻塞线程也可以由非I/O操作引起。
- en: 'It is quite important to know or to keep up with the latest of x86/x64 processors
    as we should never assume that our code runs automatically in parallel, although
    we must not rely on the number of actual physical cores. It is also closely related
    to paying more attention to concurrency because the trends for the last 6 years
    have been leaning toward having more cores instead of having a higher speed of
    CPU clock. The intention here is clear: *the awareness that concurrency is increasingly
    more relevant as the age of multicores outweigh the free increase of higher-speed
    CPUs*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 了解或跟上x86/x64处理器的最新信息非常重要，因为我们永远不能假设我们的代码会自动并行运行，尽管我们不应该依赖于实际物理核心的数量。这也与更加关注并发性密切相关，因为过去6年的趋势是向更多核心倾斜，而不是提高CPU时钟速度。这里的意图很明确：*随着多核时代超过免费增加的更高速度CPU，并发性越来越相关*。
- en: It is also a strong evidence that *free lunch is over*, stated by Herb Sutter
    (we first mentioned this article in [Chapter 1](fsp-hiperf_cu01.html#aid-E9OE2
    "Chapter 1. Performing Common Optimizations in F#"), *Performing Common Optimizations
    in F#*), is correct.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是强有力证据，Herb Sutter 所说的“免费午餐已结束”是正确的（我们首次在[第一章](fsp-hiperf_cu01.html#aid-E9OE2
    "第一章。F#中的常见优化")中提到这篇文章，《F#中的常见优化》），*免费午餐已结束*。
- en: Therefore, this book is not going to describe the full characteristic details
    of Intel or AMD processors because it is outside the scope of this F# book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本书不会描述英特尔或AMD处理器的完整特性细节，因为这超出了这本书的范围。
- en: For more information on the full specifications of Intel processors, please
    consult [http://ark.intel.com/](http://ark.intel.com/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解英特尔处理器完整规格的更多信息，请参阅 [http://ark.intel.com/](http://ark.intel.com/)。
- en: For more information on the specifications of AMD, please consult [http://www.amd.com/en-us/products/processors/desktop](http://www.amd.com/en-us/products/processors/desktop).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解AMD规格的更多信息，请参阅 [http://www.amd.com/en-us/products/processors/desktop](http://www.amd.com/en-us/products/processors/desktop)。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other processors supported by .NET, but most processors today are
    dominated by Intel and AMD. A sample of this is ARM, powering some WinRT machines
    for Windows 8 and Windows 8.1 tablets and Microsoft's own tablet, Surface. The
    ARM architecture is different from that of Intel and AMD, although it has multiple
    cores as well, and the market share for these processor-based devices is also
    very small. It can be safely assumed that since the introduction of Visual Studio
    2015, the target processor architecture is for x86 and x64 only, unless you are
    targeting other kind of devices, such as mobile phones.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 支持其他处理器，但今天的大多数处理器都是由英特尔和AMD主导的。一个例子是ARM，为Windows 8和Windows 8.1平板电脑以及微软自己的平板电脑Surface提供动力。尽管ARM架构与英特尔和AMD不同，尽管它也有多个核心，但这些基于处理器的设备的市场份额也非常小。可以安全地假设，自从Visual
    Studio 2015推出以来，目标处理器架构仅为x86和x64，除非你针对其他类型的设备，例如手机。
- en: Now that we have a basic knowledge of what a blocking thread is, the next challenge
    is whether we have to wait and not do anything else or whether *we can do other
    things while waiting*. Doing other things while waiting is actually an implementation
    of the asynchronous way. It is conceptually the same as the restaurant waiting
    problem we had visited in [Chapter 1](fsp-hiperf_cu01.html#aid-E9OE2 "Chapter 1. Performing
    Common Optimizations in F#"), *Performing Common Optimizations in F#*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对阻塞线程有了基本了解，下一个挑战是是否必须等待而不做其他任何事情，或者是否*可以在等待时做其他事情*。在等待时做其他事情实际上是异步方式的一种实现。从概念上讲，这与我们在[第一章](fsp-hiperf_cu01.html#aid-E9OE2
    "第一章。F#中的常见优化")中遇到的餐厅等待问题相同，《F#中的常见优化》。
- en: F# provides support for implementing asynchronous operations using asynchronous
    workflow without any complexity of having callback implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供了使用异步工作流实现异步操作的支持，无需任何回调实现的复杂性。
- en: Introducing asynchronous workflow
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍异步工作流
- en: Asynchronous support in F# is implemented nicely using async workflow computations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的异步支持通过异步工作流计算实现得很好。
- en: The initial release of F# 1.0 did not have it. Asynchronous workflow was introduced
    in F# 1.9.2.9, and it is categorized as a workflow because it is actually an implementation
    of a computation expression (builder) that is escalated as a language block of
    `async`. It is also a good sample of a best practice in implementing function
    compositions and in expressively implementing **Monad**. Monad is one of the functional
    composition implementations, an idea taken from or inspired by the category theory
    knowledge domain.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: F# 1.0 的最初版本没有它。异步工作流程是在 F# 1.9.2.9 中引入的，它被归类为工作流程，因为它实际上是一个计算表达式（构建器）的实现，它被提升为
    `async` 的语言块。它也是一个在实现函数组合和在表达性实现 **Monad** 方面的最佳实践的范例。Monad 是函数组合实现之一，这个想法是从或受到范畴论知识领域启发的。
- en: Function composition is actually a composition of computation operations; they
    can be functions or composite statements such as for loop constructs. It is also
    quite intuitive, and it's also easier to use as the necessary detailed composition
    operations are hidden. Usually, there is a `bind` operator to compose two functions
    (or computations).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合实际上是计算操作的组合；它们可以是函数或复合语句，如 for 循环结构。它也非常直观，并且使用起来也更容易，因为必要的详细组合操作被隐藏了。通常，有一个
    `bind` 操作符来组合两个函数（或计算）。
- en: 'The foundational theory of this is quite common, back to the world of set theory.
    Set theory is further extended in Category theory where composition is more emphasized
    between functions. For example, consider the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础理论相当常见，回到集合论的世界。集合论在范畴论中得到了进一步扩展，其中函数之间的组合被更加强调。例如，考虑以下内容：
- en: '*f => f(x)*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*f => f(x)*'
- en: '*g => g(x)*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*g => g(x)*'
- en: '*f o g = f(g(x))*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*f o g = f(g(x))*'
- en: Here, the *f o g* is read as *f circle g* where *circle* is the composition
    between the functions *f* and *g*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*f o g* 被读作 *f 圆 g*，其中 *圆* 是函数 *f* 和 *g* 之间的组合。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Usually the composition in a Monad is expressed by the `bind` operator, symbolized
    as *>>=* in many other functional programming languages such as Haskell. This
    composition of a function also implies that the return type of *g* must be the
    same as the type of the parameter of *f*. From the perspective of real-world functional
    programming, type safety is always enforced even though the type is not mentioned.
    Everything will always be inferred based on the type inference of the function's
    return type and the result of the currying functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 Monad 中的组合是通过 `bind` 操作符来表达的，在许多其他函数式编程语言（如 Haskell）中，这种组合用 *>>=* 符号表示。这种函数组合也意味着函数
    *g* 的返回类型必须与函数 *f* 的参数类型相同。从现实世界的函数式编程角度来看，即使没有提及类型，类型安全始终得到强制执行。所有内容都将始终基于函数返回类型的类型推断和柯里化函数的结果进行推断。
- en: The built-in workflows in F# are not just limited to the asynchronous workflow;
    there are Sequence and LINQ query workflows as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中内置的工作流程不仅限于异步工作流程；还有序列和 LINQ 查询工作流程。
- en: In asynchronous workflow, there is a `bind` builder (it is conceptually similar
    to bind in Monad) implemented to compose operations, but the implementation is
    hidden by the syntax of the `let!` keyword.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步工作流程中，有一个 `bind` 构建器（在概念上与 Monad 中的 bind 相似）被实现来组合操作，但它的实现被 `let!` 关键字的语法隐藏了。
- en: The implementation and optimization of a builder in F# to compose a workflow
    will be further discussed in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中构建器（用于组合工作流程）的实现和优化将在第 7 章[语言特性和结构优化](fsp-hiperf_cu07.html#aid-1ENBI1 "第
    7 章。语言特性和结构优化")中进一步讨论。
- en: The implementation of F# computation expressions is also called a workflow because
    it usually defines the compositions of functions as the results of binding (`bind`)
    operations and control flows.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: F# 计算表达式的实现也被称为工作流程，因为它通常将函数的组合定义为绑定（`bind`）操作和控制流的结果。
- en: 'The goals of F# asynchronous workflow are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: F# 异步工作流程的目标如下：
- en: Increase responsiveness by not blocking the running thread and get the other
    process done first.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不阻塞运行线程并首先完成其他进程来提高响应性。
- en: Ease programming in asynchronous concurrency without worrying about callback
    and explicit continuations.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步并发中简化编程，无需担心回调和显式延续。
- en: Intuitively, the code flows more naturally because the flow is not looking like
    going back and forth between a function that contains an asynchronous call and
    callback since callback is not called explicitly in the code.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直观地，代码的流程更加自然，因为流程看起来不像在包含异步调用的函数和回调之间来回切换，因为回调在代码中不是显式调用的。
- en: Compositional nature of asynchronous workflow means that it can be composed
    with other concurrencies such as parallelization.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作流程的组合性质意味着它可以与其他并发性（如并行化）组合。
- en: The asynchronous block implies that some basic I/O operations on the web usually
    have their own *begin* and *end* web operations. It is further supported and wrapped
    into F# Async primitives to ease interoperability with asynchronous models such
    as .NET Asynchronous Programming Model.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步块意味着Web上的基本I/O操作通常有自己的*开始*和*结束*Web操作。它进一步得到支持并被封装成F#异步原语，以简化与异步模型（如.NET异步编程模型）的互操作性。
- en: The asynchronous block also provides exception handling in a compositional way
    and also in a safe manner without losing too much referential transparency.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步块还以组合方式提供异常处理，并且以安全的方式处理，不会丢失太多的引用透明性。
- en: 'Asynchronous workflow is nicely wrapped in the following common syntax:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流程被很好地封装在以下常见语法中：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The term `expression` is not only a single line of expression but can also be
    a compound expression. This means it can contain more than one statement as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`expression`不仅是一行表达式，也可以是一个复合表达式。这意味着它还可以包含多个语句。
- en: Getting to know asynchronous workflow
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解异步工作流程
- en: We can start looking at the first sample of `async` from MSDN Library. I have
    added the necessary detail on handling specific exceptions that may occur when
    we are dealing with HTTP request/response operations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从MSDN库中的第一个`async`样本开始查看。我已经添加了处理HTTP请求/响应操作时可能发生的特定异常的必要细节。
- en: 'This is the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's visit the details of this sample.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个样本的细节。
- en: The intention of this sample code is to download the content of a web page from
    a collection of URLs asynchronously while also executing the download of the web
    page of all URLs in parallel.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码的目的是异步地从一组URL中下载网页内容，同时并行执行所有URL的网页下载。
- en: The `urlList` variable contains all URLs as a collection. F# will infer this
    collection as a list of tuple of *string * string*. Then, this list is passed
    as a parameter to the `fetchAsync` function, which is then continued to be passed
    to the next sequence in the pipeline of the `|>` pipeline operator. The `fetchAsync`
    function returns an `async` block, implying that it returns an `async` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlList`变量包含所有URL作为一个集合。F#将这个集合推断为字符串字符串元组的列表。然后，这个列表作为参数传递给`fetchAsync`函数，然后继续传递给`|>`管道操作符的管道中的下一个序列。`fetchAsync`函数返回一个`async`块，这意味着它返回一个`async`函数。'
- en: 'In a simplified flow, the entire chain of function compositions is composed
    nicely using the pipelines of `|>` within the `runAll` function as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在简化的流程中，整个函数组合链通过`runAll`函数内的`|>`管道操作符的管道很好地组合在一起，如下所示：
- en: The `urlList` is passed to the `Seq.map` function.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`urlList`被传递给`Seq.map`函数。'
- en: 'The `Seq.map` function still needs one more parameter: the `map` function.
    The `map` function takes `fetchAsync` as a parameter. The result of `map` returns
    a sequence of functions.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Seq.map`函数还需要一个额外的参数：`map`函数。`map`函数接受`fetchAsync`作为参数。`map`函数的结果返回一个函数序列。'
- en: The sequence of functions is executed in parallel by `Async.Parallel`, which
    then returns an array of `async` functions. The executions are not yet run.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数序列通过`Async.Parallel`并行执行，然后返回一个`async`函数数组。执行尚未开始。
- en: The `async` block includes exception handlings. The difference from the code
    in MSDN Library is the way the handling of the exceptions. In our sample code,
    exception handling is more specific than the original code in MSDN Library. This
    specific exception handling model is very important, because the exception occurred
    might have resulted as different types of exceptions caused by any errors in HTTP
    request/response operations and the specific exception should be handled differently.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async`块包括异常处理。与MSDN库中的代码的不同之处在于异常处理的方式。在我们的示例代码中，异常处理比MSDN库中的原始代码更具体。这种特定的异常处理模型非常重要，因为发生的异常可能是由HTTP请求/响应操作中的任何错误引起的不同类型的异常，并且应该以不同的方式处理。'
- en: The array of functions is then executed immediately by `Async.RunSynchronously`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数数组随后立即由`Async.RunSynchronously`执行。
- en: The ignore construct ignores the returning result. It will be inferred further
    as a unit.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略构造函数忽略返回的结果。它将被进一步推断为单元。
- en: 'Execute the code in F# scripting/interactive; then, within the interactive
    window, we will see the types inferred for `urlList`, `fetchAsync`, and `runAll`
    functions as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#脚本/交互式环境中执行代码；然后，在交互式窗口中，我们将看到`urlList`、`fetchAsync`和`runAll`函数的类型推断如下：
- en: '![Getting to know asynchronous workflow](img/image00290.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![了解异步工作流](img/image00290.jpeg)'
- en: The declaration of let for asynchronous workflow can be written in two ways,
    using `let` and `let!` (pronounced *let bang*).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 异步工作流的`let`声明可以有两种写法，使用`let`和`let!`（发音为*let bang*）。
- en: The sample uses `let!`; it means that the computation is focusing on returning
    a result. It means that the intention of the `async` operation is to execute the
    `download` function, `webClient.AsyncDownloadString(uri)`, and return the result,
    not the operation. Then, the thread on the `fetchAsync` scope is suspended. In
    other words, it is blocked because it waits for an event to be raised to notify
    that the process being waited for is completed. The outer thread (outside the
    `fetchAsync`) is not blocked.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用`let!`；这意味着计算专注于返回结果。这意味着`async`操作的目的在于执行`download`函数、`webClient.AsyncDownloadString(uri)`并返回结果，而不是操作。然后，`fetchAsync`作用域上的线程被挂起。换句话说，它被阻塞，因为它等待一个事件被触发以通知所等待的过程已完成。外部的线程（在`fetchAsync`外部）没有被阻塞。
- en: All the code after the line of `webClient.AsyncDownloadString(uri)` is executed
    later, after the download is finished. However, the execution will not have to
    wait for the download to be completed; instead it will go outside the `async`
    block and execute the code after `fetchAsync` is called. In this sample, it will
    execute the code after the call to `fetchAsync`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webClient.AsyncDownloadString(uri)`行之后的代码将在下载完成后执行。然而，执行不需要等待下载完成；相反，它将退出`async`块并执行`fetchAsync`调用之后的代码。在这个示例中，它将在调用`fetchAsync`之后执行代码。
- en: After the download is completed, the execution context returns to the code within
    the `async` block; it will point to the execution point of code after the call
    to `webClient.AsyncDownloadString(uri)`. The code at this point will be executed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，执行上下文返回到`async`块内的代码；它将指向`webClient.AsyncDownloadString(uri)`调用之后的代码执行点。这一点上的代码将被执行。
- en: Because there is `Async.Parallel`, which executes all of the `fetchAsync` in
    parallel, the execution looks sequential, although the execution of the `AsyncDownloadString`
    calls is parallel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有`Async.Parallel`，它并行执行所有的`fetchAsync`，所以执行看起来是顺序的，尽管`AsyncDownloadString`调用的执行是并行的。
- en: In the sample, the execution is triggered by the call to the `Async.RunSynchronously`
    function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，执行是由对`Async.RunSynchronously`函数的调用触发的。
- en: The `let` means that the execution is not performed immediately; it is stored
    in a variable to be executed later. It does not return the result immediately.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`意味着执行不是立即进行的；它被存储在变量中以供稍后执行。它不会立即返回结果。'
- en: 'Consider the following sample of `let` and `let!`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`let`和`let!`的示例：
- en: '[PRE2]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`let!` is conceptually equal to await in C# and VB as it awaits the actual
    result of `Task<T>`. It is still semantically different in its implementation.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`let!`在概念上等同于C#和VB中的await，因为它等待`Task<T>`的实际结果。但在实现上仍然在语义上有所不同。'
- en: Using asynchronous with Dispose pattern
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步与Dispose模式
- en: 'There is another equivalent declaration to define the result of an asynchronous
    workflow using the `use!` keyword as compared to `let!`. The difference between
    `let!` and `use`/`use!` is in the usage: `use!` is used to handle asynchronous
    calls that will later dispose the object.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与`let!`相比，使用`use!`关键字定义异步工作流的结果是另一种等效声明。`let!`和`use`/`use!`之间的区别在于用法：`use!`用于处理稍后需要销毁对象的异步调用。
- en: The `use!` keyword is the asynchronous counterpart of F#'s synchronous `use`
    and `using` keywords. In C#/VB, the concept of disposable is equal to the `using`
    keyword in C# and the `Using` keyword in VB, except that there is no comparable
    using model for disposable to be used in an asynchronous way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`use!`关键字是F#同步`use`和`using`关键字的异步对应物。在C#/VB中，可处置的概念等同于C#中的`using`关键字和VB中的`Using`关键字，只是没有可用的等效使用模型来以异步方式使用可处置对象。'
- en: The capture of a pattern, which is going to be disposed when not in use anymore
    before going out of scope, is called the Dispose pattern. It is also a sample
    of a coding design pattern. In today's programming language terms, the Dispose
    pattern is often escalated to have syntactic sugar, which is then translated as
    `try...finally` or (something else with similar semantics). Many programming languages
    have leveraged this Disposable pattern, not just C#, VB, and F#. It is also used
    in C++, Java, and other modern programming languages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再使用时，在作用域之外销毁的模式称为 Dispose 模式。它也是一个编码设计模式的示例。在今天的编程语言术语中，Dispose 模式通常被提升为具有语法糖，然后被翻译为
    `try...finally` 或具有类似语义的其他内容。许多编程语言都利用了这种 Disposable 模式，不仅仅是 C#、VB 和 F#，C++、Java
    和其他现代编程语言也使用了它。
- en: 'The following are the requirements for wrapping an object or type for usage
    in `use`/`use!`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包装对象或类型以在 `use`/`use!` 中使用的需求：
- en: The result object must implement the `IDisposable` interface; therefore it must
    explicitly implement the `Dispose` method. However, in the real semantic of the
    Disposable pattern, it only looks for the implementation of the `Dispose()` method
    that has a `void Dispose()` signature.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果对象必须实现 `IDisposable` 接口；因此它必须显式实现 `Dispose` 方法。然而，在 Dispose 模式的实际语义中，它只寻找具有
    `void Dispose()` 签名的 `Dispose()` 方法的实现。
- en: An unmanaged resource is highly recommended to implement `IDisposable`. The
    main reason for why it must explicitly implement the `Dispose` method is because
    the object with an explicit `Dispose` method is usually an unmanaged resource
    wrapped as a CLR object, such as `File`, network `Socket`, and database connection
    object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强烈建议实现非托管资源时实现 `IDisposable`。必须显式实现 `Dispose` 方法的最主要原因是，具有显式 `Dispose` 方法的对象通常是作为
    CLR 对象包装的非托管资源，例如 `File`、网络 `Socket` 和数据库连接对象。
- en: A managed object, if it is guaranteed to have no side effects, is also welcome
    to implement `IDisposable`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保证没有副作用，托管对象也可以实现 `IDisposable`。
- en: The advantages of implementing the `IDisposable` interface and, at the same
    time, implementing our own `Dispose` method is that it minimizes the garbage collection
    overhead because implementing the `Dispose` method means that we decide the lifetime
    of the object before disposed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口 `IDisposable` 并同时实现我们自己的 `Dispose` 方法的好处是，它可以最小化垃圾回收的开销，因为实现 `Dispose`
    方法意味着我们在对象被销毁之前决定其生命周期。
- en: Basically, the `use` and `use!` constructs in F# involve wrapping the `try...finally`
    pattern in the generated IL.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，`use` 和 `use!` 构造涉及在生成的 IL 中包装 `try...finally` 模式。
- en: 'For example, consider the following scenario:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下场景：
- en: We are going to implement code that has usage of `use!`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现使用 `use!` 的代码。
- en: In the following sample, we are going to use the `SqlDataReader` class because
    it implements the `IDisposable` interface. This instance of `SqlDataReader`, the
    `dataReader` object, will be disposed after the execution of the asynchronous
    call is completed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用 `SqlDataReader` 类，因为它实现了 `IDisposable` 接口。这个 `SqlDataReader` 实例，即
    `dataReader` 对象，将在异步调用执行完成后被销毁。
- en: 'Here is the sample code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例代码：
- en: '[PRE3]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's dive deeper into the previous sample code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨之前的示例代码。
- en: The code will only refer to `System.Data` and `System.Data.SqlClient`. Any references
    to `System`, `System.Data`, and `System.Data.Common` do not need the external
    reference to the library outside of BCL. Some of the classes (especially .NET
    primitive types) used in the code have namespace prefix of `System` are available
    at `mscorlib.dll` and `System.dll`. The F# compiler will automatically know the
    location of `mscorelib.dll` and `System.dll`. For SQL server-related database
    connections, we have to add reference to `System.Data.SqlCient.dll` in our project.
    This is the same for another library such as `System.Web.dll`. If you want to
    use other libraries such as `System.Web.dll`, you have to add a reference to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将仅引用 `System.Data` 和 `System.Data.SqlClient`。对于 `System`、`System.Data` 和 `System.Data.Common`
    的引用，不需要在 BCL 外部库的外部引用。代码中使用的某些类（尤其是 .NET 原始类型）具有 `System` 命名空间前缀，它们在 `mscorlib.dll`
    和 `System.dll` 中可用。F# 编译器将自动知道 `mscorelib.dll` 和 `System.dll` 的位置。对于与 SQL Server
    相关的数据库连接，我们必须在我们的项目中添加对 `System.Data.SqlClient.dll` 的引用。对于其他库，如 `System.Web.dll`，也是如此。如果你想使用其他库，如
    `System.Web.dll`，你必须添加对该库的引用。
- en: For normal F# code, you can add reference by adding library references to the
    project reference.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的 F# 代码，你可以通过向项目引用中添加库引用来添加引用。
- en: For F# scripting, you have to inform the compiler about the location of the
    DLL that you want to use by registering it manually before using it. It is recommended
    that you register it before any open statement so as to ensure that you have registered
    the necessary DLL at the first section of the script. The registration is done
    by using the compiler directive of `#r`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 F# 脚本，你必须在使用之前手动注册你想要使用的 DLL 的位置。建议你在任何 open 语句之前注册它，以确保你在脚本的第一个部分注册了必要的
    DLL。注册是通过使用编译器指令 `#r` 来完成的。
- en: For more information about the `#r` compiler directive of F#, please visit the
    MSDN Library at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 F# 的 `#r` 编译器指令的更多信息，请访问 MSDN 图书馆中的[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d)。
- en: The `use!` keyword (called *use bang*) will treat the `WebResponse` result from
    `req.AsyncGetResponse`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`use!` 关键字（称为 *use bang*）将处理 `req.AsyncGetResponse` 的 `WebResponse` 结果。'
- en: We can examine the compiler result of the code sample by copying and pasting
    the code into any `.fs` code, or we can simply put the source code into the F#
    console project of a default file containing the main `EntryPoint`, `Program.fs`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将代码复制粘贴到任何 `.fs` 代码中，或简单地将源代码放入包含主 `EntryPoint`、`Program.fs` 的默认 F# 控制台项目中来检查代码样本的编译结果。
- en: 'Compile it and open the executable file of the EXE using ILDASM. We will roughly
    see the following layout in the disassembled view:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编译它，并使用 ILDASM 打开 EXE 可执行文件。我们将在反汇编视图中大致看到以下布局：
- en: '![Using asynchronous with Dispose pattern](img/image00291.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Dispose 模式进行异步操作](img/image00291.jpeg)'
- en: 'Let''s dive into the IL of the `async` block, starting from the `UseBangSample`
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到 `async` 块的 IL 中，从 `UseBangSample` 方法开始：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method calls `UseBangSample@10` by instantiating it, and then it calls the
    `Invoke` method. It is quite common in the generated IL as the class is treated
    as an executable operation like a delegate.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过实例化 `UseBangSample@10` 来调用它，然后调用 `Invoke` 方法。这在生成的 IL 中很常见，因为类被当作一个可执行操作，就像委托一样。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ignore the cryptic names of the generated type and method of the IL. If you
    compile the code on your own, the resulting type and method might have different
    names. The source code and the related IL from ILDASM for this chapter is already
    set up and available for us to examine the IL assembly code with the related F#
    code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略生成的 IL 类型和方法中难以理解的名称。如果你自己编译代码，生成的类型和方法可能具有不同的名称。本章的源代码和相关 IL 已经设置好，并可供我们检查与相关
    F# 代码相关的 IL 程序集代码。
- en: The common flow is actually the execution of the `Invoke` method. In this context,
    the `Invoke` method of `UseBangSample@10` will be executed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的流程实际上是 `Invoke` 方法的执行。在这个上下文中，`UseBangSample@10` 的 `Invoke` 方法将被执行。
- en: 'Let''s dive into the IL of `UseBangSample@10.Invoke`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到 `UseBangSample@10.Invoke` 的 IL 中：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line `IL_001d` explains the correlation between the IL and the corresponding
    code, the `use!` declaration. This `use!` will actually call the `FSharpAsyncBuilder.Using`
    builder to do the actual dispose pattern by instantiating `FSharp.AsyncBuilder`
    first.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 行 `IL_001d` 解释了 IL 和对应代码之间的关联，即 `use!` 声明。实际上，这个 `use!` 将调用 `FSharpAsyncBuilder.Using`
    构建器，通过首先实例化 `FSharp.AsyncBuilder` 来执行实际的 dispose 模式。
- en: 'All of these complex details are nicely hidden in the implementation detail
    of builders, in the implementations of the following three related Async types:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些复杂细节都很好地隐藏在构建器的实现细节中，在以下三个相关异步类型的实现中：
- en: '`Control.Async` for the `Async.*` methods'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Control.Async` 用于 `Async.*` 方法'
- en: '`Control.AsyncBuilder` for the builder implementation of asynchronous workflow'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Control.AsyncBuilder` 用于异步工作流的构建器实现'
- en: '`Control.Async<''T>` type to contain the implementation result of asynchronous
    workflow'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Control.Async<''T>` 类型用于包含异步工作流的实现结果'
- en: Again, never mind the cryptic name of the generated code. As long as the name
    alias of the method and the classes is correct, we can simply deduce the use of
    `AsyncBuilder.Using` to handle the `use!` declaration in order to implement the
    Disposable pattern.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，不要在意生成的代码中难以理解的名称。只要方法和类的名称别名正确，我们就可以简单地推断出 `AsyncBuilder.Using` 的使用来处理 `use!`
    声明，以实现 Disposable 模式。
- en: F# also comes with built-in asynchronous support for HTTP requests. This additional
    asynchronous operation is available in the `WebRequest` type, and it has been
    available under the `Microsoft.FSharp.Control.WebExtensions` namespace since F#
    3.0\. In F# version 2.0, it is available under the `Microsoft.FSharp.Control.CommonExtensions`
    namespace.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: F# 还内置了对 HTTP 请求的异步支持。这个额外的异步操作在 `WebRequest` 类型中可用，并且自 F# 3.0 起在 `Microsoft.FSharp.Control.WebExtensions`
    命名空间下可用。在 F# 2.0 版本中，它位于 `Microsoft.FSharp.Control.CommonExtensions` 命名空间下。
- en: There has been a namespace reorganization in F# 3.0 and above as it is more
    aligned to the purpose or intent of the types and operations inside the namespace.
    For example, `WebRequest` related operations, now inside `Microsoft.FSharp.Control.WebExtensions`,
    were previously available under `Microsoft.FSharp.Control.CommonExtensions`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 3.0 及以上版本中，由于命名空间中的类型和操作的目的或意图更加一致，因此进行了命名空间重组。例如，与 `WebRequest` 相关的操作，现在位于
    `Microsoft.FSharp.Control.WebExtensions` 命名空间中，之前在 `Microsoft.FSharp.Control.CommonExtensions`
    下可用。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main reason for this reorganization is the stabilization and standardization
    of intents because F#, since F# 2.0 in Visual Studio 2010, is not just a research
    product anymore, it is becoming a commercial product or being productized. Again,
    the reorganization is also a working result of responding to developer feedbacks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这次重组的主要原因是意图的稳定化和标准化，因为自 F# 2.0 在 Visual Studio 2010 中以来，F# 已不再仅仅是一个研究产品，它正在成为一个商业产品或被产品化。再次强调，重组也是对开发者反馈的响应的结果。
- en: Always consult MSDN Library documentation for F# 4 and above. It is highly recommended
    to focus on F# 4 and the later versions. Further namespace changes are very unlikely
    in the next version, unless the feedback from the F# community is crucial and
    is agreed upon by the F# developer and designer team at Microsoft.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 始终参考 F# 4 及以上版本的 MSDN 库文档。强烈建议关注 F# 4 及后续版本。在下一个版本中，进一步的命名空间更改的可能性非常小，除非 F#
    社区的反馈至关重要，并且得到微软的 F# 开发者和设计团队的一致同意。
- en: 'For more information on the starting guide to F# asynchronous workflow as computation
    expressions, please consult MSDN Library:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 F# 异步工作流作为计算表达式的入门指南的更多信息，请参阅 MSDN 库：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d)'
- en: The details of computation expressions themselves and optimizing computation
    expressions will be discussed in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式本身的细节以及优化计算表达式将在[第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化")中讨论，*语言特性和结构优化*。
- en: Operations in asynchronous workflow
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步工作流中的操作
- en: The first sample in this chapter shows `Async.Parallel` and `Async.RunSynchronously`
    in action. These two belong to the F# `Control.Async` class with other functions
    as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个示例展示了 `Async.Parallel` 和 `Async.RunSynchronously` 的实际应用。这两个函数属于 F# 的 `Control.Async`
    类以及其他函数。
- en: The `Control.Async` class is available in the `Microsoft.FSharp.Control` namespace
    as we have witnessed by disassembling the code demonstrated in the *Using asynchronous
    with Dispose pattern* section covered earlier. `Control.Async` cannot function
    alone when used in an asynchronous workflow block; it depends on the builders
    in the `Control.AsyncBuilder` type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control.Async` 类在 `Microsoft.FSharp.Control` 命名空间中可用，正如我们在之前“使用 Dispose 模式异步操作”部分所展示的代码反汇编中见证的那样。当在异步工作流块中使用时，`Control.Async`
    不能独立工作；它依赖于 `Control.AsyncBuilder` 类型中的构建器。'
- en: A complete starting point of reference for `Control.Async` as a type is available
    at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b't%5d-type-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b't%5d-type-%5bfsharp%5d).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control.Async` 作为类型的完整入门参考点可在[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b''t%5d-type-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b''t%5d-type-%5bfsharp%5d)找到。'
- en: All operations of the async workflow in F# are available at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中异步工作流的全部操作可在 [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
    找到。
- en: 'The following is a table of interesting operations (commonly used) in F# `async`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 F# `async` 中的一些有趣的操作（常用）表：
- en: '| **Function** | **Quick Remark** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **简要说明**|'
- en: '| `AsBeginEnd` | Creates three functions that can be used to implement the
    .NET Framework **Asynchronous Programming Model** (**APM**) for the supplied asynchronous
    computation. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `AsBeginEnd` | 创建三个函数，可用于为提供的异步计算实现 .NET Framework **异步编程模型**（**APM**）。|'
- en: '| `AwaitEvent` | Creates an asynchronous computation that waits for a single
    invocation of a CLI event by adding a handler to the event. Once the computation
    completes or is cancelled, the handler is removed from the event.`AwaitEvent`
    is the best fit to handle .NET EAP model. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `AwaitEvent` | 通过向事件添加处理程序来创建一个等待 CLI 事件单次调用的异步计算。一旦计算完成或被取消，处理程序将从事件中移除。`AwaitEvent`
    是处理 .NET EAP 模型的最佳选择。|'
- en: '| `AwaitIAsyncResult` | Creates an asynchronous computation that will wait
    on the `IAsyncResult`. It is used for the .NET APM model. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `AwaitIAsyncResult` | 创建一个将等待 `IAsyncResult` 的异步计算。它用于 .NET APM 模型。|'
- en: '| `AwaitTask` | Returns an asynchronous computation that waits for the given
    task (.NET TPL `Task`) to complete and returns its result. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `AwaitTask` | 返回一个等待给定任务（.NET TPL `Task`）完成并返回其结果的异步计算。|'
- en: '| `CancellationToken` | Creates an asynchronous computation that returns the
    `System.Threading.CancellationToken` that manages the execution of the computation.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `CancellationToken` | 创建一个返回管理计算执行的 `System.Threading.CancellationToken`
    的异步计算。|'
- en: '| `DefaultCancellationToken` | Gets the default cancellation token to run asynchronous
    computations. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultCancellationToken` | 获取用于运行异步计算的默认取消令牌。|'
- en: '| `FromBeginEnd` | Creates an asynchronous computation in terms of a Begin/End
    pair of actions in the style used in CLI APIs. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `FromBeginEnd` | 以 CLI API 中使用的 Begin/End 动作对的形式创建异步计算。|'
- en: '| `FromContinuations` | Creates an asynchronous computation that includes the
    current success, exception, and cancellation continuations. The callback function
    must eventually call exactly one of the given continuations.This exact map of
    one cancellation for one continuation is also the same concept as .NET APM. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `FromContinuations` | 创建一个包含当前成功、异常和取消延续的异步计算。回调函数最终必须调用给定的延续之一。这种一对一的取消与延续映射也是
    .NET APM 的相同概念。|'
- en: '| `Ignore` | Creates an asynchronous computation that runs the given computation
    and ignores its result. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Ignore` | 创建一个运行给定计算并忽略其结果的异步计算。|'
- en: '| `Parallel` | Creates an asynchronous computation that executes all the given
    asynchronous computations, initially queueing each as work items and using a fork/join
    pattern. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `Parallel` | 创建一个异步计算，它将执行所有给定的异步计算，最初将每个异步计算排队作为工作项，并使用分叉/合并模式。|'
- en: '| `RunSynchronously` | Runs the provided asynchronous computation and awaits
    its result.When `RunSynchronously` is used to run an `async` block, it will run
    the code in the `async` block immediately in a separate runtime context as long
    as the code in the `async` block follows the pattern as defined in asynchronous
    workflow. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `RunSynchronously` | 运行提供的异步计算并等待其结果。当使用 `RunSynchronously` 运行 `async` 块时，只要
    `async` 块中的代码遵循异步工作流中定义的模式，它就会立即在单独的运行时上下文中执行 `async` 块中的代码。|'
- en: '| `Sleep` | Creates an asynchronous computation that will sleep for the given
    time. This is scheduled using a `System.Threading.Timer` object. The operation
    will not block operating system threads for the waiting duration. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `Sleep` | 创建一个将在给定时间内休眠的异步计算。这是使用 `System.Threading.Timer` 对象安排的。在等待期间，操作不会阻塞操作系统线程。|'
- en: '| `Start` | Starts the asynchronous computation in the thread pool but does
    not await its result. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `Start` | 在线程池中启动异步计算，但不等待其结果。|'
- en: '| `StartAsTask` | Executes a computation in the thread pool. Returns a `Task`
    that will be completed in the corresponding state once the computation terminates
    (produces the result, throws an exception, or gets canceled). If no cancellation
    token is provided, then the default cancellation token is used. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `StartAsTask` | 在线程池中执行计算。返回一个 `Task`，一旦计算终止（产生结果、抛出异常或被取消），它将在相应的状态完成。如果没有提供取消令牌，则使用默认的取消令牌。|'
- en: '| `StartChild` | Starts a child computation within an asynchronous workflow.
    This allows multiple asynchronous computations to be executed simultaneously (in
    parallel). The child computation can be composed to start in parallel with other
    child computations using `Async.Parallel`. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `StartChild` | 在异步工作流内启动子计算。这允许同时执行多个异步计算（并行）。可以使用 `Async.Parallel` 将子计算组合起来，与其他子计算并行启动。|'
- en: '| `StartChildAsTask` | Creates an asynchronous computation that starts the
    given computation as a `Task`. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `StartChildAsTask` | 创建一个异步计算，将给定的计算作为 `Task` 启动。|'
- en: '| `StartImmediately` | Runs an asynchronous computation, starting immediately
    on the current operating system thread. The main difference between `Start` and
    `StartImmediately` is quite subtle but important: `StartImmediately` uses `ThreadPool`.
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `StartImmediately` | 在当前操作系统线程上立即运行异步计算。`Start` 和 `StartImmediately` 之间的主要区别非常微妙但很重要：`StartImmediately`
    使用 `ThreadPool`。|'
- en: 'The operations in `ControlAsync` are not all targeted at working with .NET
    TPL. From the perspective of the available asynchronous model in .NET, the operations
    of `Control.Async` provide supports for the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`ControlAsync` 中的操作并非全部针对与 .NET TPL 的工作。从 .NET 可用的异步模型角度来看，`Control.Async`
    的操作提供了以下支持：'
- en: .NET Asynchronous Programming Model (APM)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 异步编程模型 (APM)
- en: .NET Event-based Asynchronous Pattern (EAP)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 基于事件的异步模式 (EAP)
- en: .NET Task Parallel Library (TPL), only available for .NET 4 with added asynchrony
    operations or programming support in .NET 4.5 and later. The Task asynchrony is
    called Task-based Asynchrony Pattern or TAP.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 任务并行库 (TPL)，仅适用于 .NET 4，并在 .NET 4.5 及以后的版本中添加了异步操作或编程支持。任务异步性被称为基于任务的异步模式或
    TAP。
- en: Let's dive into the supports.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这些支持。
- en: 'It is worth assessing that .NET TPL (including TAP) is considered to be a modern
    concurrency model. The legacy .NET asynchronous models are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，.NET TPL（包括 TAP）被认为是一种现代并发模型。传统的 .NET 异步模型如下：
- en: Asynchronous Programming Model, often abbreviated as APM
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程模型，通常缩写为 APM
- en: Event-based Asynchronous Programming pattern (EAP)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的异步编程模式 (EAP)
- en: You might wonder why they are called **legacy models**. They are legacy models
    in the sense that they are not supposed to be used anymore. Since .NET 4.0, the
    preferred model to be used is the .NET Task Parallel Library (TPL) model.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么它们被称为 **旧模型**。在意义上，它们是旧模型，因为它们不再应该被使用。自 .NET 4.0 以来，首选的模型是 .NET 任务并行库
    (TPL) 模型。
- en: Using .NET TPL is recommended, not just because it is easier to use and more
    intuitive but also because every operation is wrapped as `Task` or `Task<T>` and
    it is easier to reason about your code. In F#, APM and EAP are usually handled
    using asynchronous-related operation methods but it is quite difficult to do in
    a real APM or EAP way.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用 .NET TPL，不仅因为它更容易使用且更直观，还因为每个操作都被封装为 `Task` 或 `Task<T>`，这使得对代码进行推理更加容易。在
    F# 中，APM 和 EAP 通常使用异步相关操作方法来处理，但在实际的 APM 或 EAP 方式中做起来相当困难。
- en: It is recommended that APM and EAP should not be used anymore although they
    are still available in .NET 4.6\. EAP is harder to implement than APM because
    it focuses on event handling, which usually happens on any action or operation
    that has event handling; otherwise, we have to handle the completed event on our
    own by implementing custom completed action's event handler.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在 .NET 4.6 中仍然可用，但建议不再使用 APM 和 EAP。与 APM 相比，EAP 更难实现，因为它侧重于事件处理，这通常发生在任何具有事件处理功能的行为或操作上；否则，我们必须通过实现自定义完成动作的事件处理程序来自己处理完成事件。
- en: Creating child asynchronous workflow
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子异步工作流
- en: In F#, it is possible to create a nested asynchronous operation within an `async`
    block as the child or children of the current asynchronous workflow.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，可以在 `async` 块内创建嵌套的异步操作，作为当前异步工作流的子工作流或子工作流。
- en: These children asynchronous workflows are executed in a sequence at first (based
    on the sequence of creation) but they do not have to finish simultaneously. They
    can run or start in parallel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子异步工作流最初是按顺序执行的（基于创建的顺序），但它们不需要同时完成。它们可以并行运行或启动。
- en: 'There are two operations to create a child asynchronous workflow: `Async.StartChild`
    and `Async.StartChildAsTask`. The `Async.StartChildAsTask` will return the resulting
    asynchronous workflow as `Task<T>` based asynchrony of Task-based Asynchronous
    Pattern or TAP.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子异步工作流有两种操作：`Async.StartChild`和`Async.StartChildAsTask`。`Async.StartChildAsTask`将基于基于任务的异步模式（TAP）的异步性返回结果异步工作流作为`Task<T>`。
- en: This method is generally used with `let!` because it is supposed to return the
    result of a child asynchronous process, and this is why it is supposed to be bound
    to a process that returns a result, which is then to be observed or used by the
    parent asynchronous block.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通常与`let!`一起使用，因为它应该返回子异步进程的结果，这也是为什么它应该绑定到一个返回结果的进程，然后由父异步块观察或使用。
- en: 'The returning result of `Async.StartChild` is usually called **completor**
    because it is typed as a computation that has to wait for completion. This is
    also described by the MSDN Library as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.StartChild` 返回的结果通常被称为**completor**，因为它被定义为必须等待完成的计算。这一点也被MSDN库如下描述：'
- en: '*"When used in this way, each use of StartChild starts an instance of childComputation
    and returns a completor object representing a computation to wait for the completion
    of the operation. When executed, the completor awaits the completion of childComputation."*'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"当以这种方式使用时，每次调用StartChild都会启动一个childComputation实例，并返回一个表示等待操作完成的completor对象。当执行时，completor将等待childComputation的完成。"*'
- en: Putting it simply, the completor is an object to contain the operation of the
    asynchronous process and wait for it to be completed. This is why the returning
    value of `Async.StartChild` is typed as `Async<Async<'T>>` instead of just `Async<'T>`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，completor是一个包含异步操作并等待其完成的对象。这就是为什么`Async.StartChild`的返回值被定义为`Async<Async<'T>>`而不是仅仅`Async<'T>`。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WARNING: The use of `use!` is not allowed to capture an asynchronous child;
    it will yield an unpredictable result. Future releases of F# will not allow this
    to be used. It is required to use `let!` instead. The main reason is that the
    nature of the asynchronous child is not for disposable objects as it is focused
    on the process, not on the object that is part of the result to be awaited, although
    the process contains an asynchronous function that may have a result as denoted
    by the `Async<Async<''T>>` type.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：不允许使用`use!`来捕获异步子进程；它将产生不可预测的结果。F#的未来版本将不允许这样做。必须使用`let!`。主要原因在于异步子进程的本质不是用于可处置对象，因为它关注的是过程，而不是作为等待结果的组成部分的对象，尽管该过程包含一个可能具有结果的异步函数，如`Async<Async<'T>>`类型所示。
- en: 'The following is a simple example from MSDN Library:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从MSDN库中的一个简单示例：
- en: '[PRE6]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ensure that `System.Windows.Forms` is available on the project references to
    run this sample.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 确保项目引用中包含`System.Windows.Forms`以运行此示例。
- en: For more information on `Async.StartChild`, including the sample code, visit
    the MSDN Library at [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Async.StartChild`的更多信息，包括示例代码，请访问MSDN库中的[https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d)。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Async.StartChild` is not recommended to be used with the legacy .NET EAP.
    The result of the child asynchronous process can be placed in a different execution
    context and thread because EAP can be implemented during the event-driven nature
    of UI threads such as Windows Forms thread or WPF thread.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议将`Async.StartChild`与传统的.NET EAP一起使用。子异步进程的结果可以放置在不同的执行上下文和线程中，因为EAP可以在UI线程的事件驱动特性期间实现，例如Windows
    Forms线程或WPF线程。
- en: The risk of getting unpredictable results (side effects) may outweigh the comfort
    and ease of creating child asynchronous processes. The side effects of cross threads
    are also very hard to identify and debug. The only way to avoid the risks is by
    simply not using `Async.StartChild` against EAP or against the possibility of
    operating inside a UI thread such as Windows Forms or WPF.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 获得不可预测结果（副作用）的风险可能超过了创建子异步过程时的舒适和便捷。跨线程的副作用也很难识别和调试。避免这些风险的唯一方法就是简单地不要在 EAP
    或在可能操作于 UI 线程（如 Windows Forms 或 WPF）的情况下使用 `Async.StartChild`。
- en: F# asynchronous workflow support for legacy .NET APM and EAP
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 对遗留 .NET APM 和 EAP 的异步工作流支持
- en: The F# asynchronous workflow still provides support for legacy .NET APM and
    EAP model, but the support is meant *to consume* the model because it is not intended
    to fully implement our own custom APM and EAP models. It is called *to consume*
    as F# has no support for implementing our own APM and EAP model, so it is not
    recommended to implement a custom APM or EAP in F#.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: F# 异步工作流仍然支持遗留的 .NET APM 和 EAP 模型，但这种支持是为了 *消费* 模型，因为它并不打算完全实现我们自己的自定义 APM 和
    EAP 模型。由于 F# 没有支持实现我们自己的 APM 和 EAP 模型，所以不建议在 F# 中实现自定义 APM 或 EAP。
- en: There is another reason why these APM and EAP models are not recommended anymore,
    especially when implementing your own custom models in F#. The complexity of going
    back and forth of having callbacks with side effects computation such as crossing
    CPU thread and UI thread is also a very strong reason.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个原因，为什么这些 APM 和 EAP 模型不再被推荐，尤其是在 F# 中实现自己的自定义模型时。在回调和副作用计算（如跨 CPU 线程和 UI
    线程）之间来回切换的复杂性也是一个非常强烈的理由。
- en: 'The following operations are targeted at any .NET Asynchronous Programming
    Model (APM):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作针对任何 .NET 异步编程模型 (APM)：
- en: '`AsBeginEnd`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsBeginEnd`'
- en: '`AwaitIAsyncResult`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AwaitIAsyncResult`'
- en: '`FromBeginEnd`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromBeginEnd`'
- en: The .NET APM is one of the legacy asynchronous models in .NET. It has a distinct
    pattern of having an operation prefixed with `Begin`, an operation prefixed with
    `End`, and a callback function to be called. For example, .NET `System.IO.FileStream`
    has `BeginRead` and `EndRead` methods. Each method has a delegate parameter that
    functions as callback.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: .NET APM 是 .NET 中遗留的异步模型之一。它有一个独特的模式，即操作以 `Begin` 前缀开头，操作以 `End` 前缀开头，以及一个将被调用的回调函数。例如，.NET
    `System.IO.FileStream` 有 `BeginRead` 和 `EndRead` 方法。每个方法都有一个作为回调功能的委托参数。
- en: The preferred way to support .NET APM in F# is by using `Async.FromBeginEnd`
    in order to be as flexible as we can to include the `Begin` operation, the `End`
    operation, and the parameter for the `Begin` and `End` operations. Using `Async.FromBeginEnd`
    is also the easiest way to leverage the existing .NET APM, which is usually available
    when dealing with I/O. For example, `System.IO.FileStream` and `System.Net.Sockets.Socket`
    have the pattern of `BeginXXX` and `EndXXX` methods.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中支持 .NET APM 的首选方法是使用 `Async.FromBeginEnd`，以便尽可能灵活地包括 `Begin` 操作、`End`
    操作以及 `Begin` 和 `End` 操作的参数。使用 `Async.FromBeginEnd` 也是利用现有的 .NET APM 的最简单方法，这通常在处理
    I/O 时可用。例如，`System.IO.FileStream` 和 `System.Net.Sockets.Socket` 有 `BeginXXX` 和
    `EndXXX` 方法的模式。
- en: Let's start by consulting the documentation for `Async.FromBeginEnd` (that has
    no parameter) in MSDN at [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 MSDN 上的 `[https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d)`
    中咨询 `Async.FromBeginEnd`（没有参数）的文档开始（该链接没有参数）。
- en: 'The link has the shortest form of `Async.FromBeginEnd` (that does not need
    a parameter and only returns a result) syntax:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该链接具有 `Async.FromBeginEnd`（不需要参数且仅返回结果）语法的最简形式：
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you need parameters (from 1 to 3 parameters), the syntaxes are as follows
    (the `static` member modifier is the same as the previous; it is omitted for simplicity):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要参数（1 到 3 个参数），语法如下（`static` 成员修饰符与之前相同；为了简单起见省略）：
- en: '[PRE8]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just looking at the signature might be confusing at first; fortunately, a sample
    usage of `Async.FromBeginEnd` is available in the MSDN Library.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最初仅看签名可能会感到困惑；幸运的是，MSDN 库中提供了 `Async.FromBeginEnd` 的示例用法。
- en: The sample leverages `System.Net.Socket` by enhancing it using an implicit extension
    method, added on the existing `Socket` class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例通过在现有的 `Socket` 类上添加一个隐式扩展方法来增强 `System.Net.Socket`。
- en: 'Here is the code definition of the asynchronous operations sample:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是异步操作示例的代码定义：
- en: '[PRE9]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The name of the method that contains an asynchronous call follows common guidelines:
    it has an `Async` suffix. For example, the `this.MyConnectAsync` method contains
    an asynchronous call to `Socket.BeginConnect` that follows the APM naming conventions.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 包含异步调用的方法的名称遵循通用指南：它有一个 `Async` 后缀。例如，`this.MyConnectAsync` 方法包含对 `Socket.BeginConnect`
    的异步调用，该调用遵循 APM 命名约定。
- en: '`Async.FromBeginEnd` uses the syntax for two parameters. It is also used to
    wrap and simultaneously handle the following pairs of the asynchronous Socket:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.FromBeginEnd` 使用两个参数的语法。它也用于包装并同时处理以下异步 Socket 的以下成对操作：'
- en: '`BeginAccept` and `EndAccept` pair'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginAccept` 和 `EndAccept` 成对'
- en: '`BeginConnect` and `EndConnect` pair'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginConnect` 和 `EndConnect` 成对'
- en: '`BeginSend` and `EndSend` pair'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginSend` 和 `EndSend` 成对'
- en: '`BeginReceive` and `EndReceive` pair'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginReceive` 和 `EndReceive` 成对'
- en: The related syntax on the MSDN Library is `Async.FromBeginEnd<'Arg1,'Arg2,'T>`
    because it needs two parameters (or arguments in MSDN Library terms).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN Library 上的相关语法是 `Async.FromBeginEnd<'Arg1,'Arg2,'T>`，因为它需要两个参数（或 MSDN Library
    术语中的参数）。
- en: 'To test those `Socket` methods in the `async` block, consider the following
    partial sample:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `async` 块中的那些 `Socket` 方法，请考虑以下部分示例：
- en: '[PRE10]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the complete documentation of `System.Net.Socket`, consult the MSDN Library
    at [https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `System.Net.Socket` 的完整文档，请查阅 MSDN Library 中的 [https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx)。
- en: For more information, consult .NET APM on the MSDN Library at [https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 MSDN Library 上的 .NET APM [https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx)。
- en: The EAP model simply models the implementation of asynchronous event-driven
    programming by using an event as the handler of the completed event. Unfortunately,
    it is not quite clear how the flow of waiting is implemented as the pattern focuses
    on what will happen when the operation is completed. It is also not clear about
    deciding the implementation detail of how the EAP is used to handle the I/O operations
    that are blocking by default.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: EAP 模型简单地通过使用事件作为完成事件的处理器来模拟异步事件驱动编程的实现。不幸的是，由于该模式侧重于操作完成时会发生什么，因此等待流的实现并不十分清楚。关于如何实现
    EAP 用于处理默认情况下阻塞的 I/O 操作的详细实现细节也不明确。
- en: F# supports EAP by providing one method, the `Async.AwaitEvent` operation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: F# 通过提供一种方法，即 `Async.AwaitEvent` 操作，支持 EAP。
- en: Compared to APM, EAP focuses more on the completion of the action and the state
    of an object instead of getting the result of an operation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与 APM 相比，EAP 更侧重于动作的完成和对象的状态，而不是获取操作的结果。
- en: 'For more information about the legacy .NET EAP model, consult:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于旧版 .NET EAP 模型的更多信息，请参阅：
- en: '[https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx)
    To illustrate F# support for EAP, we must understand and focus on the event programming
    model first.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx)
    要说明 F# 对 EAP 的支持，我们必须首先理解和关注事件编程模型。'
- en: The event programming model is actually not so different from the event-based
    approach of Windows UI programing, where a UI control has events for any kind
    of event happening to it, such as clicked, mouse over, focus, or lost focus. But
    there are some events that need to be handled with care, such as timer events.
    When a timer is active, it ticks on every period based on how long it takes to
    tick between intervals. Usually, when an interval is set, the timer implicitly
    makes us to wait until some time period has elapsed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 事件编程模型实际上与 Windows UI 编程中的基于事件的编程方法没有太大区别，其中 UI 控件对任何发生在其上的事件都有事件，例如点击、鼠标悬停、焦点或失去焦点。但有一些事件需要小心处理，例如计时器事件。当一个计时器处于活动状态时，它会在每个间隔期间基于间隔之间的滴答声持续滴答。通常，当设置间隔时，计时器隐式地让我们等待直到某个时间段过去。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of a timer is crucial as sometimes the time elapsed may vary depending
    on what kind of timer we use. Avoid the use of a UI timer as much as possible
    because the resolution (the precision of timing) of a UI timer is lower than `System.Threading.Timer`
    or any other non-UI timer, as highlighted in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计时器至关重要，因为有时经过的时间可能会根据我们使用的计时器类型而变化。尽可能避免使用 UI 计时器，因为 UI 计时器的分辨率（时间的精度）低于
    `System.Threading.Timer` 或任何其他非 UI 计时器，正如在[第 2 章](fsp-hiperf_cu02.html#aid-K0RQ2
    "第 2 章。性能测量") *性能测量* 中所强调的。
- en: All of the execution is based on the sequence of events; it is also natural
    to call it an event-driven model. Unfortunately, this wait might take some time
    blocking the current thread. It is therefore recommended to handle this asynchronously.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 所有执行都是基于事件序列的；因此，自然地将其称为事件驱动模型。不幸的是，这种等待可能需要一些时间，从而阻塞当前线程。因此，建议异步处理此操作。
- en: If we look at the documentation for `Async.AwaitEvent` on the online MSDN Library,
    the documentation does not have a good explanation on how we relate this to .NET
    EAP.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看在线 MSDN Library 中 `Async.AwaitEvent` 的文档，该文档没有很好地解释我们如何将其与 .NET EAP 相关联。
- en: 'The following is the sample code from the MSDN Library documentation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 MSDN Library 文档中的示例代码：
- en: '[PRE11]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This sample is quite simple, and at the same time, it directly shows the sample
    usage of `Async.AwaitEvent`. The sample `await` construct for any file or folder
    changes in a folder. If any changes occur (as a changed event), it will continue
    to print the file name and do some I/O operations, such as opening the file. The
    file is then read asynchronously.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例相当简单，同时直接展示了 `Async.AwaitEvent` 的示例用法。该示例 `await` 构造用于文件夹中任何文件或文件夹的变化。如果发生任何变化（作为一个改变事件），它将继续打印文件名并执行一些
    I/O 操作，例如打开文件。然后文件异步读取。
- en: For more information on `Async.AwaitEvent`, check out [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `Async.AwaitEvent` 的信息，请查看[https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d)。
- en: We now have basic knowledge of how F# interops with .NET EAP, although the interoperability
    is not quite as straightforward as using the async-based `Task<T>`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了 F# 如何与 .NET EAP 进行交互，尽管这种交互并不像使用基于异步的 `Task<T>` 那样直接。
- en: Ignoring asynchronous operation asynchronously
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步忽略异步操作
- en: '`Async.Ignore` is essentially the same as using `ignore`. However, it is semantically
    different as `Async.Ignore` must only be used to ignore asynchronous operations,
    not non-asynchronous operations.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.Ignore` 实质上与使用 `ignore` 相同，但在语义上有所不同，因为 `Async.Ignore` 必须仅用于忽略异步操作，而不是非异步操作。'
- en: 'The signature of `Async.Ignore` is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.Ignore` 的签名如下：'
- en: '[PRE12]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Async.Ignore` implies that it cannot be used independently as it needs an
    `async` operation as its parameter.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.Ignore` 表明它不能独立使用，因为它需要一个 `async` 操作作为其参数。'
- en: '`Async.Ignore` has its ignore implementation asynchronously; therefore, it
    is guaranteed not to block the current thread synchronously. This means that it
    will not block the current thread of the calling function as well.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.Ignore` 有其异步的忽略实现；因此，它保证不会同步地阻塞当前线程。这意味着它也不会阻塞调用函数的当前线程。'
- en: 'The common place of `Async.Ignore` is generally used to ignore the returning
    result of the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.Ignore` 的常见用途通常用于忽略以下操作的返回结果：'
- en: All EAP-based asynchronous operations.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有基于 EAP 的异步操作。
- en: All asynchronous operations that return nothing (`unit` in F#, `void` in C#,
    or the `Sub` procedure/method in VB).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有返回无值（在 F# 中为 `unit`，在 C# 中为 `void`，或 VB 中的 `Sub` 过程/方法）的异步操作。
- en: Therefore, we must not use `Async.Ignore` if we want to examine or get the results
    from asynchronous operations. Also, `Async.Ignore` is already optimized for non-returning
    result of any asynchronous workflow.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想检查或获取异步操作的结果，则不能使用 `Async.Ignore`。此外，`Async.Ignore` 已经针对任何异步工作流的非返回结果进行了优化。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please do not confuse the non-returning result of asynchronous operations with
    the F# unit. The term non-returning result should be treated as simply intuitive-not
    returning any result-because the main focus here is the on completion of any actions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要将异步操作的非返回结果与F#单元混淆。术语非返回结果应被视为简单的直观——不返回任何结果——因为这里的主要重点是任何动作的完成。
- en: It is recommended that you use `Async.Ignore` on F#-specific asynchronous workflows
    (including F# support on EAP) and .NET TPL instead of using it on other kinds
    of asynchronous models, as it is more predictable and more optimized.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在F#特定的异步工作流（包括EAP上的F#支持）和.NET TPL上使用`Async.Ignore`，而不是在其他类型的异步模型上使用它，因为它更可预测，更优化。
- en: Using `Async.Ignore` is also fine when combining with F#'s `MailboxProcessor`
    because `MailboxProcessor` is designed to be compatible; it's also recommended
    to use `MailboxProcessor` in asynchronous workflow blocks.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当与F#的`MailboxProcessor`结合使用时，使用`Async.Ignore`也是可以的，因为`MailboxProcessor`被设计成兼容的；也建议在异步工作流块中使用`MailboxProcessor`。
- en: Delaying asynchronous workflow
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟异步工作流
- en: What if we delay an asynchronous implementation without blocking the outside
    calling thread? We could do this easily by using `Thread.Sleep`, but `Thread.Sleep`
    always blocks the calling thread and not just the current execution thread. Therefore,
    `Thread.Sleep` always enforces us to wait synchronously instead of asynchronously.
    It is also often misunderstood that `Thread.Sleep` would not block as it actually
    blocks the current thread. We can wrap `Thread.Sleep` into an `async` block, but
    then the outside thread still has to wait for `Thread.Sleep` to finish first.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不阻塞外部调用线程的情况下延迟异步实现，我们会怎么做？我们可以通过使用`Thread.Sleep`轻松地做到这一点，但`Thread.Sleep`总是阻塞调用线程，而不仅仅是当前执行线程。因此，`Thread.Sleep`总是强制我们同步等待，而不是异步等待。也常常误解为`Thread.Sleep`不会阻塞，因为它实际上会阻塞当前线程。我们可以将`Thread.Sleep`包裹在一个`async`块中，但这样外部线程仍然必须等待`Thread.Sleep`完成。
- en: 'There is the `Async.Sleep` method to support delay asynchronously. The syntax
    is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有`Async.Sleep`方法来支持异步延迟。其语法如下：
- en: '[PRE13]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Consider the following sample usage:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例用法：
- en: '[PRE14]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's still better to assume that any asynchronous delay implementation uses
    `Async.Sleep` instead of `Thread.Sleep` because `Async.Sleep` never blocks the
    current operating system threads.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然假设任何异步延迟实现使用`Async.Sleep`而不是`Thread.Sleep`会更好，因为`Async.Sleep`永远不会阻塞当前操作系统线程。
- en: 'According to a short description on MSDN Library, `Async.Sleep`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 根据MSDN库中的简要描述，`Async.Sleep`：
- en: '*Creates an asynchronous computation that will sleep for the given time. This
    is scheduled using a System.Threading.Timer object. The operation will not block
    operating system threads for the duration of the wait.*'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*创建一个异步计算，将在给定的时间内休眠。这是通过使用System.Threading.Timer对象来安排的。在等待期间，操作不会阻塞操作系统线程。*'
- en: This is not the actual implementation detail because it depends on the current
    runtime. Internally, `Async.Sleep` creates an asynchronous operation that inserts
    the delay by calling `Task.Delay` internally if it's run under .NET Core or by
    using the asynchronous timer mechanism utilizing `System.Threading.Timer` for
    non-.NET Core, with the *trampoline* algorithm in place.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是实际的实现细节，因为它依赖于当前的运行时。在内部，`Async.Sleep`通过调用`Task.Delay`（如果是在.NET Core下运行）或使用`System.Threading.Timer`异步计时器机制（对于非.NET
    Core）来创建一个异步操作，以实现延迟，并使用*跳板*算法。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term *actual implementation detail* means that the actual internal implementation
    detail will be changed in the next release of F#. We must also include the fact
    that F# core class libraries are open source as part of the Microsoft Visual F#
    open source repo on GitHub.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*实际实现细节*意味着实际的内部实现细节将在F#的下一个版本中改变。我们还必须包括F#核心类库是开源的事实，作为GitHub上Microsoft Visual
    F#开源仓库的一部分。
- en: Therefore, there is a high possibility that the actual source code implementation
    of F# will change by the time this book is published. It could change based on
    the progress of feedbacks from Microsoft and external contributors. It is also
    quite common to always assume that the actual implementation will always be changed,
    based on the nature of open source contributions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有很大可能性，到这本书出版时，F#的实际源代码实现会有所改变。它可能会根据微软和外部贡献者的反馈进展而改变。根据开源贡献的本质，总是假设实际实现会发生变化也是很常见的。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting from this chapter, we will sometimes visit the internal implementation
    of F# 4 core class libraries by looking at its source code. This is very important
    because we have to dig deeper than just using the libraries in order to fully
    understand what is happening behind the scenes of calling F# core functions. It
    is also a common best practice to increase our knowledge of the internal workings
    of how F# presents its features.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将通过查看其源代码来有时访问 F# 4 核心类库的内部实现。这非常重要，因为我们必须比仅仅使用库更深入地挖掘，才能完全理解调用 F# 核心函数背后的场景。了解
    F# 展示其功能的内部工作方式也是一个常见的最佳实践。
- en: 'We can *peek* at the source code of `Async.Sleep` on the F# GitHub repo (some
    comments have been omitted):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看 F# GitHub 仓库中 `Async.Sleep` 的源代码（一些注释已被省略）：
- en: '[PRE15]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The full source code is available at [https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在 [https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs)
    找到。
- en: For more information about `Async.Sleep` visit the MSDN Library, at [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `Async.Sleep` 的信息，请访问 MSDN 库，网址为 [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d)。
- en: So far, we have covered how to declare an `async` block and delay it. Now, we
    need to know how to cancel it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何声明一个 `async` 块并延迟它。现在，我们需要知道如何取消它。
- en: Handling cancellation in asynchronous workflow
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异步工作流程中的取消
- en: It is quite possible that the user may cancel the ongoing asynchronous process
    even in the middle of an asynchronous operation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在异步操作进行中甚至可能取消正在进行的异步过程。
- en: 'In F#, the common way to have support for cancellation that can be done in
    the middle of any running asynchronous operation is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，支持在任意运行中的异步操作中取消的常见方式如下：
- en: Requesting a token in the form of the `CancellationToken` type structure.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 `CancellationToken` 类型结构的形式请求一个令牌。
- en: This `CancellationToken` instance is obtained from `System.Threading.CancellationTokenSource`.
    Internally, `CancellationToken` will always be loaded and pushed onto a stack,
    which is later popped after use when the ongoing asynchronous operation is canceled.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `CancellationToken` 实例是从 `System.Threading.CancellationTokenSource` 获得的。内部，`CancellationToken`
    总是会被加载并推入一个栈中，在使用后取消当前进行的异步操作时，这个栈会被弹出。
- en: '`CancellationToken` needs to know which one of the asynchronous operations
    to have cancellation support for. This can be done by linking `CancellationToken`
    with the asynchronous function by calling `Async.Start` or `Async.StartImmediate`
    with an override that has `CancellationToken` as a parameter.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CancellationToken` 需要知道哪个异步操作需要支持取消。这可以通过通过调用带有 `CancellationToken` 参数的重载的
    `Async.Start` 或 `Async.StartImmediate` 来将 `CancellationToken` 与异步函数链接来实现。'
- en: Before using `CancellationToken` and `CancellationTokenSource`, you need to
    ensure that references to the `System.Threading.dll` assembly are available on
    the project reference setting when the code is in an FS file or that you have
    registered the assembly manually when the code is in an FSX file and executed
    in scripting mode (in F# Interactive mode).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `CancellationToken` 和 `CancellationTokenSource` 之前，你需要确保当代码在 FS 文件中时，项目引用设置中可用的
    `System.Threading.dll` 程序集引用，或者当代码在 FSX 文件中且以脚本模式执行（在 F# Interactive 模式下）时，你已经手动注册了该程序集。
- en: To add cancellation support as mentioned in Step 3, the linking of the asynchronous
    operation (usually wrapped as an `async` block) is done by linking the `async`
    function with `CancellationToken`, and this linking must be done carefully. This
    `CancellationToken` instance is a *value typed object, so the instance of this
    CancellationToken must not be derived, and it must not be used and linked to other
    async functions*. It is also implicitly immutable, including the referential transparency
    of the initial design of `CancellationToken`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加如步骤 3 中提到的取消支持，异步操作（通常封装为 `async` 块）的链接是通过将 `async` 函数与 `CancellationToken`
    链接来完成的，并且这个链接必须谨慎进行。这个 `CancellationToken` 实例是一个 *值类型对象，因此这个 CancellationToken
    的实例不能被派生，也不能被使用并链接到其他异步函数*。它也是隐式不可变的，包括 `CancellationToken` 初始设计的引用透明性。
- en: This linking of the asynchronous operation is crucial; if the same value is
    linked to more than one `async` block, it will cancel each of the linked functions
    unpredictably because the same object value may interfere with other linked `async`
    blocks as well. This will violate the referential transparency and may therefore
    raise many unwanted side effects. Such multiple function linking is a bad practice
    as it will cause side effects such as unpredictable cancellation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步操作的链接至关重要；如果相同的值链接到多个 `async` 块，它将不可预测地取消每个链接的函数，因为相同的对象值可能会干扰其他链接的 `async`
    块。这将违反引用透明性，并可能因此引发许多不希望出现的副作用。这种多函数链接是坏习惯，因为它会导致如不可预测取消等副作用。
- en: Because of the nature of `CancellationToken` as a structure (value type), multiple
    instances of different tokens of `CancellationToken` will always be stored and
    pushed into stacks, which is fast to store and retrieve (pop) as well.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CancellationToken` 作为结构（值类型）的性质，不同的 `CancellationToken` 令牌的多个实例将始终被存储并推入堆栈，这使存储和检索（弹出）变得非常快。
- en: Therefore, multiple linking to multiple `async` blocks from the same `CancellationToken`
    is not recommended and should not be allowed.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不建议从同一个 `CancellationToken` 链接到多个 `async` 块，并且不应允许这样做。
- en: To see the usage sample of `CancellationToken`, we can revisit our existing
    `use!` sample and leverage the overloaded method of `ExecuteReaderAsync` with
    an additional `CancellationToken` parameter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `CancellationToken` 的使用示例，我们可以回顾我们现有的 `use!` 示例，并利用 `ExecuteReaderAsync`
    方法的重载版本，该版本包含一个额外的 `CancellationToken` 参数。
- en: 'The existing code sample now looks as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的代码示例现在如下所示：
- en: '[PRE16]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding sample code highlights the following steps to add cancellation
    support:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码突出了以下步骤以添加取消支持：
- en: The `UseBangCancellationSample` function shows that it takes a parameter, `tokenSource`
    typed as `CancellationTokenSource`. Then `CancellationToken` is taken from the
    `CancellationTokenSource.Token` property.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UseBangCancellationSample` 函数显示它接受一个参数，参数类型为 `CancellationTokenSource`。然后从
    `CancellationTokenSource.Token` 属性中获取 `CancellationToken`。'
- en: To cancel the ongoing asynchronous operation, call the `Cancel` method of the
    `CancellationToken` instance, which is passed into the related asynchronous operation
    started.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要取消正在进行的异步操作，请调用 `CancellationToken` 实例的 `Cancel` 方法，该实例被传递到启动的相关异步操作中。
- en: It is important that the instance of `CancellationToken` knows which asynchronous
    process it needs to cancel. In the preceding sample, `CancellationToken` is linked
    to `ExecuteReaderAsync` by setting it as a parameter.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的是 `CancellationToken` 实例知道它需要取消哪个异步过程。在前面的示例中，通过将其设置为参数，将 `CancellationToken`
    链接到 `ExecuteReaderAsync`。
- en: We now know how to utilize `CancellationToken` and `CancellationTokenSource`
    by leveraging the `System.Threading.Tasks` namespace. This also serves as a warm
    starter to the introduction to interoperability with the Task library and.NET
    TPL.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何通过利用 `System.Threading.Tasks` 命名空间来使用 `CancellationToken` 和 `CancellationTokenSource`。这也为介绍与
    Task 库和 .NET TPL 的互操作性提供了一个良好的开端。
- en: Common conventions when implementing asynchronous operations
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现异步操作时的常见约定
- en: We have seen samples of implementing calling asynchronous operations and wrapping
    them in asynchronous blocks. There are some patterns and best practices that we
    must follow in accordance with the F# implementation and .NET standards.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了实现调用异步操作并将它们包装在异步块中的示例。我们必须遵循一些模式和实践，这些模式和实践与 F# 实现 和 .NET 标准相一致。
- en: There are certain guidelines or standards that must be followed not only to
    enhance the code's readability but also because it will become easier to understand
    the code and reason about what it will do.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些指南或标准必须遵循，这不仅是为了提高代码的可读性，而且还因为这将使理解代码和推理其行为变得更加容易。
- en: 'The following are some common conventions of implementing asynchronous workflow:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些实现异步工作流程的常见约定：
- en: A method that has an asynchronous call inside it should be suffixed with Async,
    to define that this function or method contains an asynchronous call and must
    be called inside the asynchronous block.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中包含异步调用的方法应带有 Async 后缀，以定义该函数或方法包含异步调用，并且必须在异步块内调用。
- en: Any kind of event handling that has an asynchronous call should not be suffixed
    with Async, for example, the `Button1_Click` method to handle the Click event
    that has a call to `DownloadWebAsync`.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何具有异步调用的事件处理程序都不应带有 Async 后缀，例如，`Button1_Click` 方法用于处理调用 `DownloadWebAsync`
    的 Click 事件。
- en: An `async` block that needs to delay some operations should use `Async.Sleep`
    instead of `Thread.Sleep`. Otherwise, the current thread will be blocked; the
    execution will be observed as synchronous and will be executed synchronously instead
    of asynchronously.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要延迟某些操作的 `async` 块应使用 `Async.Sleep` 而不是 `Thread.Sleep`。否则，当前线程将被阻塞；执行将被观察到是同步的，并且将以同步方式而不是异步方式执行。
- en: All I/O operations must be treated asynchronously. This includes I/O operations
    to send commands to other output devices such as printers, not just I/O in network
    or I/O to storage devices.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 I/O 操作都必须以异步方式处理。这包括发送命令到其他输出设备（如打印机）的 I/O 操作，而不仅仅是网络或存储设备的 I/O 操作。
- en: Now that we know the basic usage of the `Control.Async` operations in F#, we
    will dive into the basic interop of asynchronous workflow with .NET TPL.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 F# 中 `Control.Async` 操作的基本用法，我们将深入探讨异步工作流与 .NET TPL 的基本互操作性。
- en: Introduction to interop with .NET TPL
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET TPL 互操作性的简介
- en: F# has a high compatibility support for .NET TPL; it can nicely use the .NET
    TPL objects of `Task` and `Task<T>` back and forth. This means that F# can also
    use the `Task`/`Task<T>` results from other languages as well and not just from
    F#.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: F# 对 .NET TPL 有很高的兼容性支持；它可以很好地在 `Task` 和 `Task<T>` 之间来回使用 .NET TPL 对象。这意味着 F#
    也可以使用来自其他语言的 `Task`/`Task<T>` 结果，而不仅仅是来自 F#。
- en: In .NET TPL, the concurrency support is not just for parallel programming, but
    also for the awaiter of the async-await model that has currently started in C#
    5.0 and VB 11, as related in .NET 4.5 and later.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET TPL 中，并发支持不仅用于并行编程，还用于当前在 C# 5.0 和 VB 11 中启动的异步-等待模型（async-await）的等待者，如
    .NET 4.5 及以后的描述。
- en: In this chapter, we will start from the overview of .NET TPL support in F# in
    terms of leveraging `Task` and `Task<T>`. We will discuss the interop perspective
    from outside of F#, such as interop with F# asynchronous workflow, in [Chapter
    5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency Support in
    F#"), *Advanced Concurrency Support in F#*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 F# 中利用 `Task` 和 `Task<T>` 的 .NET TPL 支持概述开始。我们将从 F# 异步工作流等外部视角讨论互操作性，如第
    5 章[Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency
    Support in F#")中所述的*高级并发支持在 F# 中*。
- en: A quick overview of asynchronous programming in .NET TPL
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET TPL 中异步编程的快速概述
- en: For asynchronous operations (or asynchronous programming, as is mostly mentioned
    in C#/VB documentation in MSDN) the async-await model relies heavily on the `Task`
    and `Task<T>` classes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步操作（或异步编程，如 MSDN 中的 C#/VB 文档中通常提到的）异步-等待模型严重依赖于 `Task` 和 `Task<T>` 类。
- en: The `Task` class is for asynchronous operations that have no result; `Task<T>`
    is for asynchronous operations that have results. The generic parameter `T` is
    the type of the result.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类用于没有结果的异步操作；`Task<T>` 用于有结果的异步操作。泛型参数 `T` 是结果类型。'
- en: '`Task<T>` contains the result in a property called `result`.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task<T>` 在一个名为 `result` 的属性中包含结果。'
- en: The `Task` and `Task<T>` classes are available under the `System.Threading.Tasks`
    namespace. For more information, consult the landing page of `System.Threading.Tasks`
    in .NET 4.6 on the MSDN Library at [https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 和 `Task<T>` 类在 `System.Threading.Tasks` 命名空间下可用。更多信息，请参阅 MSDN 库中 .NET
    4.6 的 `System.Threading.Tasks` 的着陆页 [https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx)。'
- en: 'In F#, the following are the operations that support `Task`/`Task<T>`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '在 F# 中，以下操作支持 `Task`/`Task<T>`:'
- en: '`Async.AwaitTask`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Async.AwaitTask`'
- en: '`Async.StartAsTask`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Async.StartAsTask`'
- en: '`Async.StartChildAsTask`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Async.StartChildAsTask`'
- en: All these methods have two overrides in common, one for dealing with `Task`
    with no result and the other for dealing with `Task<T>` that will return a `Task`
    with a result typed `T`. Dealing in this context means having interoperability
    with the Task-based Asynchrony Pattern (TAP) of .NET TPL
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法有两个共同的重载，一个用于处理没有结果的 `Task`，另一个用于处理将返回结果类型为 `T` 的 `Task<T>`。在此上下文中处理意味着与
    .NET TPL 的基于 Task 的异步模式 (TAP) 兼容。
- en: We are not going to reintroduce the detail of .NET TAP because we are focusing
    on best practices. For more information on .NET TAP in .NET 4.5 and 4.6 on MSDN
    Library, visit [https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重新介绍.NET TAP的详细信息，因为我们专注于最佳实践。有关.NET 4.5和4.6中.NET TAP的更多信息，请访问MSDN库中的[https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx)。
- en: The documentation for `Async.AwaitTask` and `Async.StartChildAsTask` does not
    provide a sample code for us at all. Only `Async.StartAsTask` has a very simple
    sample code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async.AwaitTask`和`Async.StartChildAsTask`的文档没有为我们提供任何示例代码。只有`Async.StartAsTask`有一个非常简单的示例代码。'
- en: Work to address these shortcomings in the Visual F# documentation repository
    is still in progress, and all of us are welcome to participate.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些不足的工作仍在Visual F#文档存储库中进行，我们所有人都欢迎参与。
- en: 'The following is the sample code in the `Async.StartAsTask` documentation,
    and we have to modify it to successfully run it under the UI thread:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Async.StartAsTask`文档中的示例代码，我们必须对其进行修改才能在UI线程下成功运行：
- en: '[PRE17]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code is explained as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：
- en: The asynchronous code is running within the UI thread of Windows Forms. Therefore,
    it is advisable that the main method be marked with the `System.STAThread` attribute.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步代码正在Windows Forms的UI线程中运行。因此，建议主方法带有`System.STAThread`属性。
- en: The `async` block is contained in the `async1` function. It is then executed
    using `Async.StartAsTask` with no result. It will then return a `Task` instead
    of `Task<T>`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async`块包含在`async1`函数中。然后使用`Async.StartAsTask`执行，不返回任何结果。它将返回一个`Task`而不是`Task<T>`。'
- en: '`Async.StartAsTask` is written inside an inline event handler of the Click
    event, `button.Click`, by using addition to the current event handler of event
    Click. It is the same as `AddHandler` in VB or the syntactic sugar of the `+=`
    operator in C#.'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Async.StartAsTask`是在点击事件的内联事件处理器`button.Click`中编写的，通过添加到当前的事件处理器来使用。这与VB中的`AddHandler`或C#中`+=`操作符的语法糖相同。'
- en: 'The original sample code in the MSDN Library does not have this `STAThread`
    attribute and it will yield an exception because `System.InvalidOperationException`
    has occurred due to the invalid cross thread, although the error message is quite
    confusing:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN库中的原始示例代码没有这个`STAThread`属性，并且会引发异常，因为由于无效的跨线程操作，发生了`System.InvalidOperationException`，尽管错误信息相当令人困惑：
- en: '![A quick overview of asynchronous programming in .NET TPL](img/image00292.jpeg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![.NET TPL中异步编程的快速概述](img/image00292.jpeg)'
- en: 'It literally gives the following as the reason:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上给出了以下原因：
- en: '[PRE18]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is not the real error. The real error is in the code where we put the code/function
    that calls `Application.Run` marked with `STAThreadAttribute`. It is also quite
    common as it is often demonstrated by C#/VB samples in the default project template
    of Windows Forms.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是真正的错误。真正的错误在于放置带有`STAThreadAttribute`标记的`Application.Run`代码/函数的代码中。这种情况很常见，因为它经常在Windows
    Forms的默认项目模板中的C#/VB示例中演示。
- en: Not just Windows Forms, the terms of operating under `STAThread` are also valid
    for WPF as well.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅Windows Forms适用，在`STAThread`下运行的条件也适用于WPF。
- en: 'For a detailed explanation of `STAThread`, visit:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`STAThread`的详细解释，请访问：
- en: '[https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx)'
- en: And for more information about the Thread apartment model (including STA and
    MTA with respect to COM), visit the MSDN Library at [https://msdn.microsoft.com/library/ms809971.aspx](https://msdn.microsoft.com/library/ms809971.aspx).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有关线程公寓模型（包括与COM相关的STA和MTA）的更多信息，请访问MSDN库中的[https://msdn.microsoft.com/library/ms809971.aspx](https://msdn.microsoft.com/library/ms809971.aspx)。
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, F# and C# use MTA; VB uses STA. For a Windows Forms application,
    the default is using STA. STA and MTA have nothing to do with how you create `System.Threading.Thread`.
    It is a threading apartment model, not a general multithreading model.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，F#和C#使用MTA；VB使用STA。对于Windows Forms应用程序，默认使用STA。STA和MTA与您如何创建`System.Threading.Thread`无关。它是一个线程公寓模型，而不是一个通用的多线程模型。
- en: 'For the other `Async.AwaitTask` and `Async.StartChildAsTask` samples, let''s
    revisit the sample of `UseBangSample`: (with `Async.AwaitTask` highlighted):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他`Async.AwaitTask`和`Async.StartChildAsTask`示例，让我们回顾一下`UseBangSample`的示例：（突出显示`Async.AwaitTask`）：
- en: '[PRE19]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code demonstrates how to await a result from an asynchronous operation
    by awaiting `Task<T>`. The `T` in this context is typed as `SqlDataReader`, inferred
    by the return builder of asynchronous workflow. The return builder is coded implicitly
    in the `use!` construct/keyword as nicely captured from the execution of the `ExecuteReaderAsync`
    method.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了如何通过等待`Task<T>`来从异步操作中获取结果。在这个上下文中，`T`被类型化为`SqlDataReader`，这是由异步工作流的返回构建器推断出来的。返回构建器在`use!`构造/关键字中被隐式编码，这很好地捕捉了`ExecuteReaderAsync`方法的执行。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When we are developing any applications, starting from small mobile applications
    to a large-scale enterprise application, concurrency is becoming very relevant,
    not just because of the trend of multi-core CPUs but also because having optimizations
    on concurrency gives us many advantages as described in this chapter. Although
    there is no single solution for all concurrency problems and optimizations, we
    know that we could leverage concurrency support in F# and .NET.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发任何应用程序时，从小型移动应用程序到大型企业应用程序，并发性变得越来越相关，这不仅是因为多核CPU的趋势，而且还因为对并发性的优化给我们带来了许多优势，正如本章所述。尽管没有针对所有并发问题和优化的单一解决方案，但我们知道我们可以利用F#和.NET中的并发支持。
- en: 'In [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency
    Support in F#"), *Advanced Concurrency Support in F#*, we will discuss the advanced
    topic of concurrency in F#, including one of F#''s unique features: the message-passing
    agent, `MailboxProcessor`.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](fsp-hiperf_cu05.html#aid-164MG2 "第5章。F#的高级并发支持")，*F#的高级并发支持*中，我们将讨论F#中的高级并发主题，包括F#的一个独特特性：消息传递代理，`MailboxProcessor`。
