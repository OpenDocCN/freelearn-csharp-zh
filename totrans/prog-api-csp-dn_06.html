<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-77">
    <a id="_idTextAnchor077">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor078">
    </a>
    
     Azure Functions
    
   </h1>
   <p>
    
     Determining the execution environment of your APIs can have a large impact on how they run, how they scale, how much they cost, and what features come out of the box.
    
    
     Azure Functions provides a different hosting option that complements existing Azure services with a focus on event-driven execution.
    
    
     While Functions provides many ways to react to different things in a system, we’ll focus on a specific event: the
    
    
     
      HTTP request.
     
    
   </p>
   <p>
    
     In this chapter, we’ll cover some technical aspects related to hosting and billing and finish with a walkthrough that includes cloud deployment
    
    
     
      and configuration.
     
    
   </p>
   <p>
    
     By the end of this chapter, you’ll have a good base to continue your API journey by knowing about the
    
    
     
      following aspects:
     
    
   </p>
   <ul>
    <li>
     
      Hosting considerations that affect certain runtime options and limitations based on the needs of
     
     
      
       your application.
      
     
    </li>
    <li>
     
      How certain aspects of your application can
     
     
      
       affect billing.
      
     
    </li>
    <li>
     
      The structure, general familiarity, and possibilities of code design related specifically to
     
     
      
       HTTP APIs.
      
     
    </li>
    <li>
     
      Deploying to Azure from Visual Studio.
     
     
      Automated builds, continuous integration, and continuous delivery will be covered later in
     
     
      
       this book.
      
     
    </li>
    <li>
     
      Making runtime configuration changes
     
     
      
       without redeployment.
      
     
    </li>
    <li>
     
      How to adjust scaling settings to reduce the potential cost of a public endpoint, colloquially known as a
     
     
      
       Denial-of-Wallet attack.
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor079">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To build Azure Functions in Visual Studio, you’ll need the Azure development workload available in Visual Studio Installer.
    
    
     The source code for this chapter is available
    
    
     
      at
     
    
    
     
      https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter06
     
    
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-80">
    <a id="_idTextAnchor080">
    </a>
    
     Understanding Functions
    
   </h1>
   <p>
    
     Azure Functions
    
    <a id="_idIndexMarker116">
    </a>
    
     fills a large role in execution environments while focusing on event-based data processing.
    
    
     Traditionally, those environments have a lot of overhead in terms of hardware or
    
    <strong class="bold">
     
      virtual machines
     
    </strong>
    
     (
    
    <strong class="bold">
     
      VMs
     
    </strong>
    
     ) and
    
    <a id="_idIndexMarker117">
    </a>
    
     boilerplate code.
    
    
     Functions is Microsoft’s execution environment to allow ease of development, deployment, and scaling.
    
    
     While a few types of underlying execution environments are available, it defaults to consumption, which brings a set of defaults that are well suited to a large variety of different data processing scenarios and are billed per event execution.
    
    
     If you need more CPU cores or memory, other environments are available; these will be covered later in this chapter.
    
    
     While all execution environments in Functions are considered serverless in the sense that you don’t have to manage individual instances, other non-consumption environments are not pay-per-use and instead are charged based on the amount of CPU cores and memory allocated to each instance.
    
    
     C# is the predominant language that’s used, although a variety of languages and bindings
    
    
     
      are supported.
     
    
   </p>
   <p>
    
     The main entry points for the execution of these applications are triggers.
    
    
     A variety of these triggers exist to react to external events.
    
    
     From queue polling to ServiceBus pushing, reacting to blob, or database record changes, many ready-to-go bindings allow you to mix and match your solution.
    
    
     For APIs, the triggers we care most about are
    
    
     
      HTTP triggers.
     
    
   </p>
   <p>
    
     HTTP triggers are exactly what they
    
    <a id="_idIndexMarker118">
    </a>
    <a id="_idIndexMarker119">
    </a>
    
     sound like: a request-response to a normal API request.
    
    
     These requests can come from all the usual suspects: browsers, webhooks, service-to-service calls, and so on.
    
    
     They can be routed to individual functions using the built-in routing template support.
    
    
     Incoming data from these routes can be automatically matched to the specified data types, deserialized,
    
    
     
      and bound.
     
    
   </p>
   <p>
    
     Built-in authorization is either none or API key-based, with the latter available in two flavors: function-specific or a single global application key.
    
    
     Other standard authorization can be implemented with Entra ID, manually in code,
    
    
     
      or both.
     
    
   </p>
   <p>
    
     Hosting should also be considered since your application will need to run somewhere – likely, though not necessarily, in the cloud.
    
    
     Various hosting and packaging options are provided, allowing you to tailor deployment to accommodate your application’s needs.
    
    
     ZIP files, Docker, plain file copy (xcopy), and on-premises are all available.
    
    
     AMD64 Windows and Linux are
    
    <a id="_idIndexMarker120">
    </a>
    
     supported on Azure, while ARM64 is supported in
    
    
     
      other scenarios.
     
    
   </p>
   <p>
    
     At this point, you should have a good understanding of the environment in which Azure Functions operates and what’s available
    
    
     
      to you.
     
    
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor081">
    </a>
    
     Hosting
    
   </h2>
   <p>
    
     There are a variety of hosting
    
    <a id="_idIndexMarker121">
    </a>
    
     options available to suit practically any need.
    
    
     Each has its pros and cons.
    
    <strong class="bold">
     
      Consumption
     
    </strong>
    
     is the default and will be used in this
    
    <a id="_idIndexMarker122">
    </a>
    
     chapter.
    
    <strong class="bold">
     
      Flex Consumption
     
    </strong>
    
     (in preview at the time of
    
    <a id="_idIndexMarker123">
    </a>
    
     writing),
    
    <strong class="bold">
     
      Premium
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Application Service Environment
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ASE
     
    </strong>
    
     ), and
    
    <strong class="bold">
     
      Kubernetes
     
    </strong>
    
     are additional supported offerings that won’t
    
    <a id="_idIndexMarker124">
    </a>
    
     be discussed in
    
    
     
      this
     
    
    
     <a id="_idIndexMarker125">
     </a>
    
    
     
      book.
     
    
   </p>
   <p>
    
     Although powerful, Consumption comes with several limitations.
    
    
     First, the instance memory is limited to 1.5 GB, which can put a hard limit on the types of applications that can be run directly inside this Functions option.
    
    
     The second is that the instance only has a single core.
    
    
     The third is timeout.
    
    
     Azure only allows a timeout limit of 5 to
    
    
     
      10 minutes.
     
    
   </p>
   <p>
    
     However, many workloads do fit
    
    <a id="_idIndexMarker126">
    </a>
    
     well within these constraints.
    
    
     From standard
    
    <strong class="bold">
     
      Software-as-a-Service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SaaS
     
    </strong>
    
     ), APIs, and periodic updates to CRUD and Durable Functions-related calls (explained in the next chapter), the potential is there for the vast majority of these to fit well within
    
    
     
      the limits.
     
    
   </p>
   <p>
    
     Needing more compute resources can be common in artificial intelligence workloads, for example.
    
    
     While Consumption is conceptually easy to think about, Premium is the next step up.
    
    
     You’re billed for individual CPU vCores and GBs of memory allocated together in classic VM form.
    
    
     Managing these VMs is completely delegated to Azure.
    
    
     You set the maximum (and/or minimum) of the number of instances that the application can scale out to, and Azure handles the rest.
    
    
     The current limitations are 4 vCores and 14 GB of memory per host.
    
    
     Windows allows up to 100 hosts, and Linux between 20 and
    
    
     
      100 hosts.
     
    
   </p>
   <h2 id="_idParaDest-82">
    <a id="_idTextAnchor082">
    </a>
    
     Application packaging
    
   </h2>
   <p>
    
     There are a few application packaging
    
    <a id="_idIndexMarker127">
    </a>
    
     and deployment options available as well, depending on what size of resource you require.
    
    
     Docker is supported on Premium and App Service, allowing you to control the runtime environment with precision.
    
    
     ZIP files (published archives containing your entire application) are supported for all runtimes and required
    
    
     
      with Consumption.
     
    
   </p>
   <h3>
    
     History
    
   </h3>
   <p>
    
     Note that most of the runtime hosting modes, while they may still be available, are now considered deprecated.
    
    
     Originally, compiled functions were loaded inside the same physical operating system process that the function host was running in.
    
    
     This “in-proc” model allowed direct function calling between the host and custom functions but introduced potential issues with library dependencies and language updates.
    
    
     Hard dependencies on specific library versions couldn’t be changed, and new C# language versions couldn’t be used if they were incompatible with the existing runtime.
    
    
     Assembly loading quirks were also common, with varying success
    
    
     
      in workarounds.
     
    
   </p>
   <p>
    
     Azure Functions initially launched with an Azure-based browser editor, and although it was serverless, the model had room for improvement.
    
    
     Later, a new version allowed standard .NET assemblies to be compiled so that the function host, starting the physical operating system process, would load.
    
    
     This introduced dependency resolution conflicts and required pinning functions to the same runtime version as the host, highlighting the need for
    
    
     
      further solutions.
     
    
   </p>
   <p>
    
     Today, with out-of-process hosting, the majority of the aforementioned problems go away.
    
    
     Your function application runs in its own operating system process, managing its own startup, dependency injection, language, and .NET version.
    
    
     Communication is handled through an internal channel between the host application and your function application.
    
    
     This is the recommended way forward for .NET 6 and .NET
    
    
     
      8 functions.
     
    
   </p>
   <p>
    
     Though historical context is worth knowing for completeness, the defaults guide you through the recommended experience out of the box.
    
    
     So, how does the Consumption plan measure the usage of your API?
    
    
     Let’s take
    
    
     
      a look.
     
    
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor083">
    </a>
    
     Billing
    
   </h2>
   <p>
    
     The billing model for
    
    <a id="_idIndexMarker128">
    </a>
    
     Consumption is a new metric that you may not be familiar with unless you’ve dealt with cloud cost estimation before.
    
    <strong class="bold">
     
      Gigabytes per second
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GB/s
     
    </strong>
    
     ) is
    
    <a id="_idIndexMarker129">
    </a>
    
     the measure that’s used in Consumption to accurately bill for applications and is the first part of the billing process.
    
    
     Whether they’re quick and fast responses or memory-hungry multi-second responses, this style of metric allows it to be reported as a single numeric value.
    
    
     For example, a single request that takes 1 second to respond, using 1 GB of memory, would result in
    
    <strong class="source-inline">
     
      1*1s*1GB=1GB/s
     
    </strong>
    
     for billing.
    
    
     As for the inverse, four requests taking 250 milliseconds using the same 1 GB of memory would also equal 1 GB/s:
    
    <strong class="source-inline">
     
      4*250ms*1GB=1GB/s
     
    </strong>
    
     .
    
    
     At the time of writing, Azure’s free tier grants 400,000 GB/s of free usage per month.
    
    
     With each request potentially taking an average of 100ms and using 256 MB of memory, that works out to be 16 million requests.
    
    
     The second part of billing is more straightforward: the number of requests.
    
    
     Azure grants 1 million requests for free per month, and it’s $0.20 per million requests
    
    
     
      after that.
     
    
   </p>
   <h1 id="_idParaDest-84">
    <a id="_idTextAnchor084">
    </a>
    
     Project walkthrough
    
   </h1>
   <p>
    
     In this section, we’ll begin creating a new Functions project, adding an additional HTTP trigger with an API route, and setting up some configuration that practically all applications
    
    
     
      will require.
     
    
   </p>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor085">
    </a>
    
     Starting up
    
   </h2>
   <p>
    
     Creating a new Functions project
    
    <a id="_idIndexMarker130">
    </a>
    
     is just like creating any other project.
    
    
     There are templates available in Visual Studio’s new project wizard to aid you with this.
    
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Select
     
     <strong class="bold">
      
       Azure Functions
      
     </strong>
     
      or search for it using the
     
     <strong class="source-inline">
      
       functions
      
     </strong>
     
      keyword and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.1 – New project wizard" src="img/B21988_06_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.1 – New project wizard
    
   </p>
   <ol>
    <li value="2">
     
      Name your
     
     <a id="_idIndexMarker131">
     </a>
     
      project and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.2 – Project configuration" src="img/B21988_06_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.2 – Project configuration
    
   </p>
   <ol>
    <li value="3">
     
      Select the runtime and
     
     <a id="_idIndexMarker132">
     </a>
     
      hosting configuration options.
     
     
      Usually, the latest
     
     <strong class="bold">
      
       Long Term Support
      
     </strong>
     
      option is a
     
     
      
       safe bet:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.3 – Functions worker configuration" src="img/B21988_06_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.3 – Functions worker configuration
    
   </p>
   <ol>
    <li value="4">
     
      Select the
     
     <strong class="bold">
      
       Http trigger
      
     </strong>
     
      option, choose
     
     <strong class="bold">
      
       Anonymous
      
     </strong>
     
      under
     
     <strong class="bold">
      
       Authorization level
      
     </strong>
     
      , and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Create
       
      </strong>
     
     
      
       .
      
     
     <p class="list-inset">
      
       We’ll cover authentication and authorization later in this book.
      
      
       As mentioned earlier, Docker containers are supported, but leave this option unchecked for now.
      
      
       Ensure the
      
      <strong class="bold">
       
        Azurite
       
      </strong>
      
       option is selected.
      
      
       This supports backend state management for various things and is also the “Durable” in Durable Functions, something that will be covered in the next chapter.
      
      
       Other triggers can be
      
      
       
        added later:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 6.4 – Additional Functions authorization options" src="img/B21988_06_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.4 – Additional Functions authorization options
    
   </p>
   <ol>
    <li value="5">
     
      Many different
     
     <a id="_idIndexMarker133">
     </a>
     
      triggers are available, and you can mix and match as needed.
     
     
      Right-click on the project in the
     
     <strong class="bold">
      
       Solution Explorer
      
     </strong>
     
      area and select
     
     <strong class="bold">
      
       Add
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New
      
     </strong>
     
      <strong class="bold">
       
        Azure Function
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.5 – Adding a new Azure Function" src="img/B21988_06_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.5 – Adding a new Azure Function
    
   </p>
   <ol>
    <li value="6">
     
      You may need to
     
     <a id="_idIndexMarker134">
     </a>
     
      search for
     
     <strong class="source-inline">
      
       Function
      
     </strong>
     
      in the list, then
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Add
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.6 – New item dialog" src="img/B21988_06_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.6 – New item dialog
    
   </p>
   <ol>
    <li value="7">
     
      A list of triggers
     
     <a id="_idIndexMarker135">
     </a>
     
      should appear.
     
     
      Select
     
     <strong class="bold">
      
       Http trigger
      
     </strong>
     
      , choose
     
     <strong class="bold">
      
       Anonymous
      
     </strong>
     
      for
     
     <strong class="bold">
      
       Authorization level
      
     </strong>
     
      , and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Add
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.7 – The New Azure Function dialog" src="img/B21988_06_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.7 – The New Azure Function dialog
    
   </p>
   <p>
    
     Note that templates are revised over time, and this new one may look different compared to the original Function.
    
    
     It also may add some interesting new objects that may look familiar to you, including
    
    <strong class="source-inline">
     
      IActionResult
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      OkObjectResult
     
    </strong>
    
     .
    
    
     These come from ASP.NET Core libraries.
    
    
     Install the latest
    
    <strong class="source-inline">
     
      Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore
     
    </strong>
    
     NuGet package if it wasn’t referenced
    
    
     
      by default.
     
    
   </p>
   <p>
    
     With that, you’ve created two HTTP endpoints that
    
    
     
      should compile.
     
    
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor086">
    </a>
    
     Options
    
   </h2>
   <p>
    
     Most applications will need options or
    
    <a id="_idIndexMarker136">
    </a>
    <a id="_idIndexMarker137">
    </a>
    
     configuration in some form.
    
    
     .NET provides built-in support for passing options in many forms, including custom ones, to your application when it starts up.
    
    
     These different instances, such as environment variables, JSON (
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     ) and XML files, and command-line arguments, are all layered on top of one another so that individual settings can be overridden as needed.
    
    
     Note that this is different from settings that are altered while the application is running, which are more advanced and circumstantial when creating APIs, and thus won’t be covered in
    
    
     
      this book.
     
    
   </p>
   <p>
    
     To add support for these options, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Add a new class called
     
     <strong class="source-inline">
      
       MyOptions
      
     </strong>
     
      , make it
     
     <strong class="source-inline">
      
       public
      
     </strong>
     
      , and add a standard
     
     <strong class="source-inline">
      
       string
      
     </strong>
     
      property called
     
     <strong class="source-inline">
      
       MyReturnValue
      
     </strong>
     
      .
     
     
      We’ll use this to control the return value of
     
     
      
       the Function.
      
     
    </li>
    <li>
     
      Go ahead and default the property value in the
     
     <strong class="source-inline">
      
       MyOptions
      
     </strong>
     
      class to anything you like.
     
     
      We’ll override it in the
     
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
     
      file in a moment, and change it at startup time during deployment later in
     
     
      
       this chapter.
      
     
    </li>
    <li>
     
      Add a new property to the
     
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
     
      file named
     
     <strong class="source-inline">
      
       MyReturnValue
      
     </strong>
     
      , and a different value than you originally defaulted to in
     
     
      
       the code.
      
     
     <p class="list-inset">
      
       Now, we must configure the application so that it can use the configuration framework
      
      
       
        at startup.
       
      
     </p>
    </li>
    <li>
     
      Modify
     
     <strong class="source-inline">
      
       .ConfigureServices
      
     </strong>
     
      in
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      to add an additional argument to the
     
     <strong class="source-inline">
      
       context
      
     </strong>
     
      Lambda.
     
     
      Add calls to
     
     <strong class="source-inline">
      
       .AddOptions&lt;MyOptions&gt;
      
     </strong>
     
      to the services variable, or chain them onto the end of
     
     <strong class="source-inline">
      
       .ConfigureFunctionsApplicationInsights
      
     </strong>
     
      .
     
     
      Chain a call after
     
     <strong class="source-inline">
      
       .AddOptions
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       .BindConfiguration
      
     </strong>
     
      , taking an empty string.
     
     
      This binds values in the root configuration path to matching property names in the
     
     
      <strong class="source-inline">
       
        MyOptions
       
      </strong>
     
     
      
       class.
      
     
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        Program.cs
       
      </strong>
      
       file should
      
      
       
        look this:
       
      
     </p>
     <pre class="source-code">
var host = new HostBuilder()
    .ConfigureFunctionsWebApplication()
    .ConfigureServices((context, services) =&gt;
    {
        services.AddApplicationInsightsTelemetryWorkerService()
            .ConfigureFunctionsApplicationInsights()
            .AddOptions&lt;MyOptions&gt;()
            .BindConfiguration("");
    })
    .Build();
host.Run();</pre>
     <p class="list-inset">
      
       The
      
      <strong class="source-inline">
       
        MyOptions.cs
       
      </strong>
      
       file should
      
      <a id="_idIndexMarker138">
      </a>
      <a id="_idIndexMarker139">
      </a>
      
       look
      
      
       
        like this:
       
      
     </p>
     <pre class="source-code">public class MyOptions
{
    public string? MyReturnProperty { get; set; } = "my value in 
    code";
}</pre>
    </li>
    <li>
     
      Modify
     
     <strong class="source-inline">
      
       Function1.cs
      
     </strong>
     
      so that it includes
     
     <strong class="source-inline">
      
       IOptions&lt;MyOptions&gt;
      
     </strong>
     
      in the constructor, then save a reference to that as a class member.
     
     
      Have
     
     <strong class="source-inline">
      
       OkObjectResult
      
     </strong>
     
      return
     
     <strong class="source-inline">
      
       _options.Value.MyReturnProperty
      
     </strong>
     
      so that we can see
     
     
      
       values changing.
      
     
    </li>
   </ol>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Function1.cs
     
    </strong>
    
     file should look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
public class Function1
{
    private readonly IOptions&lt;MyOptions&gt; _options;
    private readonly ILogger&lt;Function1&gt; _logger;
    public Function1(IOptions&lt;MyOptions&gt; options, ILogger&lt;Function1&gt; 
    logger)
    {
        _options = options;
        _logger = logger;
    }
    [Function("Function1")]
    public IActionResult Run([HttpTrigger(AuthorizationLevel.
    Anonymous, "get", "post")] HttpRequest req)
    {
        _logger.LogInformation("C# HTTP trigger function processed a 
        request.");
        return new OkObjectResult(_options.Value.MyReturnProperty);
    }
}</pre>
   <p>
    
     Test this out by running it.
    
    
     You should see the standard output console window with some informational Function messages including the visible routes.
    
    
     Hold
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     and click (on Windows) to run them in your browser, or use any standard HTTP software.
    
    
     You should see your hard-coded string
    
    
     
      as output:
     
    
   </p>
   <div><div><img alt="Figure 6.8 – Expected output in the browser" src="img/B21988_06_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.8 – Expected output in the browser
    
   </p>
   <p>
    
     Congratulations!
    
    
     Not only is your Function
    
    <a id="_idIndexMarker140">
    </a>
    <a id="_idIndexMarker141">
    </a>
    
     running, but it’s been set up so that its values can be altered at deployment time.
    
    
     Now, let’s learn how to route incoming requests to different sections
    
    
     
      of code.
     
    
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor087">
    </a>
    
     Routing
    
   </h2>
   <p>
    
     You’ll almost certainly need multiple routes in your Function API, including routing parameters, query parameters, and so on.
    
    
     This forms part of the “shape” or public
    
    <a id="_idIndexMarker142">
    </a>
    <a id="_idIndexMarker143">
    </a>
    
     contract of your API.
    
    
     Routing supports this concept.
    
    
     If you’re familiar with ASP.NET Core routes, then you’ll be right at home as they’re also supported,
    
    
     
      including constraints.
     
    
   </p>
   <p>
    
     How do different requests know where to enter into your application?
    
    
     How should you describe what types of data should be allowed to be processed?
    
    
     Let’s start with a classic storefront
    
    
     
      products endpoint:
     
    
   </p>
   <ol>
    <li>
     
      Duplicate
     
     <strong class="source-inline">
      
       Function1.cs
      
     </strong>
     
      and rename it
     
     <strong class="source-inline">
      
       Products.cs
      
     </strong>
     
      , ensuring that you include all the references to
     
     <strong class="source-inline">
      
       Function1
      
     </strong>
     
      
       in it.
      
     
    </li>
    <li>
     
      Add
     
     <strong class="source-inline">
      
       string category
      
     </strong>
     
      and an
     
     <strong class="source-inline">
      
       int id
      
     </strong>
     
      parameter to the
     
     
      <strong class="source-inline">
       
        Run
       
      </strong>
     
     
      
       method.
      
     
    </li>
    <li>
     
      Instead of returning a string in
     
     <strong class="source-inline">
      
       OkObjectResult
      
     </strong>
     
      , return an anonymous object containing
     
     <strong class="source-inline">
      
       category
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       id
      
     </strong>
     
      so that we can see the values that are passed in from
     
     
      
       the route.
      
     
    </li>
   </ol>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Product.cs
     
    </strong>
    
     file should look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
public class Products
{
    private readonly IOptions&lt;MyOptions&gt; _options;
    private readonly ILogger&lt;Products&gt; _logger;
    public Products(IOptions&lt;MyOptions&gt; options, ILogger&lt;Products&gt; 
    logger)
    {
        _options = options;
        _logger = logger;
    }
    [Function(nameof(Products))]
    public IActionResult Run([HttpTrigger(AuthorizationLevel.
    Anonymous, "get", Route = "products/{category:alpha}/{id:int?}")] 
    HttpRequest req,
        string category, int id = 0)
    {
        _logger.LogInformation("C# HTTP trigger function processed a 
        request.");
        return new OkObjectResult(new
        {
            category,
            id
        });
    }
}</pre>
   <p>
    
     Note the new
    
    <strong class="source-inline">
     
      Route
     
    </strong>
    
     property in the
    
    <strong class="source-inline">
     
      HttpTrigger
     
    </strong>
    
     attribute,
    
    <strong class="source-inline">
     
      "products/{category:alpha}/{id:int?}"
     
    </strong>
    
     .
    
    
     This allows us to customize, restrict, and parse out the arguments from the desired endpoint.
    
    
     Since these route designs will likely be part of a larger web API for third-party consumers to use, you’ll want to take care in creating them.
    
    
     You know that the product ID must be numeric, but you may want to restrict the category so that it only
    
    <a id="_idIndexMarker144">
    </a>
    <a id="_idIndexMarker145">
    </a>
    
     contains letters.
    
    
     When implemented as a route template, it would look like the one we mentioned previously:
    
    <strong class="source-inline">
     
      "products/{category:alpha}/{id:int?}"
     
    </strong>
    
     .
    
    
     This will only match incoming requests that have your desired URI segments in the specified format.
    
    
     The question mark (
    
    <strong class="source-inline">
     
      ?
     
    </strong>
    
     ) denotes that the specified parameter is optional, and can be defaulted in the
    
    
     
      method parameters.
     
    
   </p>
   <p>
    
     Did you notice that
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .8
     
    </em>
    
     had the
    
    <strong class="source-inline">
     
      api
     
    </strong>
    
     URL segment prefixed to it when it wasn’t specified in the route?
    
    
     Where does this prefix come from?
    
    
     By default,
    
    <strong class="source-inline">
     
      api
     
    </strong>
    
     is the default prefix for Functions.
    
    
     This can be changed in the
    
    <strong class="source-inline">
     
      host.json
     
    </strong>
    
     file under the
    
    <strong class="source-inline">
     
      extensions
     
    </strong>
    
     &gt; http &gt;
    
    
     <strong class="source-inline">
      
       routePrefix
      
     </strong>
    
    
     
      setting:
     
    
   </p>
   <pre class="source-code">
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      },
      "enableLiveMetricsFilters": true
    }
  },
  "extensions": {
    "http": {
      "routePrefix": "myapi"
    }
  }
}</pre>
   <p>
    
     More details on overriding settings after
    
    <a id="_idIndexMarker146">
    </a>
    <a id="_idIndexMarker147">
    </a>
    
     deployment can be found in the
    
    <em class="italic">
     
      Post-deployment
     
    </em>
    
     <em class="italic">
      
       reconfiguration
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     Now, let’s create the necessary Azure cloud resources
    
    
     
      and environment.
     
    
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor088">
    </a>
    
     Deploying
    
   </h1>
   <p>
    
     First, we need to create some resources before we can view them in
    
    
     
      Visual Studio.
     
    
   </p>
   <h2 id="_idParaDest-89">
    <a id="_idTextAnchor089">
    </a>
    
     Azure resource creation
    
   </h2>
   <p>
    
     Let’s deploy your Function to
    
    <a id="_idIndexMarker148">
    </a>
    <a id="_idIndexMarker149">
    </a>
    
     production!
    
    
     To do so, create a
    
    <a id="_idIndexMarker150">
    </a>
    <a id="_idIndexMarker151">
    </a>
    
     new
    
    <strong class="bold">
     
      Consumption Linux Function
     
    </strong>
    
     and follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Go to
     
     <a href="https://portal.azure.com">
      
       https://portal.azure.com
      
     </a>
     
      and create a new resource group if you don’t have
     
     
      
       one already:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.9 – Creating a new resource group" src="img/B21988_06_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.9 – Creating a new resource group
    
   </p>
   <p class="list-inset">
    
     Place it in an Azure region geographically close to you.
    
    
     We’ll use this same region when we create other resources to minimize lag and
    
    <a id="_idIndexMarker152">
    </a>
    <a id="_idIndexMarker153">
    </a>
    
     potential bandwidth.
    
    
     Click on the
    
    <strong class="bold">
     
      Review + create
     
    </strong>
    
     tab,
    
    
     
      then
     
    
    
     <strong class="bold">
      
       Create
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.10 – Successfully creating a new resource group" src="img/B21988_06_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.10 – Successfully creating a new resource group
    
   </p>
   <ol>
    <li value="2">
     
      Inside this resource group, create a new
     
     
      
       Function app:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.11 – Creating a new resource inside the resource group" src="img/B21988_06_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.11 – Creating a new resource inside the resource group
    
   </p>
   <ol>
    <li value="3">
     
      Search for
     
     <strong class="source-inline">
      
       function
      
     </strong>
     
      if you don’t see it in the default
     
     <a id="_idIndexMarker154">
     </a>
     <a id="_idIndexMarker155">
     </a>
     
      selection.
     
     
      Select
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Function App
      
     </strong>
     
      
       to continue:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.12 – Selecting Function App as the resource to create" src="img/B21988_06_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.12 – Selecting Function App as the resource to create
    
   </p>
   <ol>
    <li value="4">
     
      Next, select
     
     <strong class="bold">
      
       Consumption
      
     </strong>
     
      as your
     
     
      
       hosting
      
     
     
      <a id="_idIndexMarker156">
      </a>
      <a id="_idIndexMarker157">
      </a>
     
     
      
       option:
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 6.13 – Function hosting configuration" src="img/B21988_06_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.13 – Function hosting configuration
    
   </p>
   <ol>
    <li value="5">
     
      Select
     
     <strong class="bold">
      
       .NET
      
     </strong>
     
      for
     
     <strong class="bold">
      
       Runtime stack
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       8 (LTS), isolated worker model
      
     </strong>
     
      for
     
     <strong class="bold">
      
       Version
      
     </strong>
     
      , and
     
     <strong class="bold">
      
       Linux
      
     </strong>
     
      for
     
     <strong class="bold">
      
       Operating system
      
     </strong>
     
      .
     
     
      Select the
     
     <a id="_idIndexMarker158">
     </a>
     <a id="_idIndexMarker159">
     </a>
     
      region that you selected when you created the resource group and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.14 – Function details" src="img/B21988_06_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.14 – Function details
    
   </p>
   <ol>
    <li value="6">
     
      A
     
     <strong class="bold">
      
       storage account
      
     </strong>
     
      resource will also need to be created to hold various things for the Function runtime, including logs, your deployment
     
     <a id="_idIndexMarker160">
     </a>
     <a id="_idIndexMarker161">
     </a>
     
      package, and optionally the Durable state, something we’ll discuss in the next chapter.
     
     
      Disable
     
     <strong class="bold">
      
       Blob service diagnostic settings
      
     </strong>
     
      
       for now:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.15 – Storage configuration" src="img/B21988_06_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.15 – Storage configuration
    
   </p>
   <ol>
    <li value="7">
     
      Enable
     
     <strong class="bold">
      
       public access
      
     </strong>
     
      .
     
     
      Then, choose
     
     <strong class="bold">
      
       No
      
     </strong>
     
      for
     
     <strong class="bold">
      
       Enable
      
     </strong>
     
      <strong class="bold">
       
        Application Insights
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.16 – Application Insights creation" src="img/B21988_06_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.16 – Application Insights creation
    
   </p>
   <ol>
    <li value="8">
     
      Disable
     
     <strong class="bold">
      
       continuous deployment
      
     </strong>
     
      , an aspect that will also be covered in
     
     <a href="B21998_10.xhtml#_idTextAnchor136">
      
       <em class="italic">
        
         Chapter 10
        
       </em>
      
     </a>
     
      .
     
     
      We can use
     
     <strong class="bold">
      
       Tags
      
     </strong>
     
      to filter or group resources, and so on.
     
     
      Add tags if desired, or leave this section empty and click
     
     <strong class="bold">
      
       Review + create
      
     </strong>
     
      .
     
     
      Review your
     
     <a id="_idIndexMarker162">
     </a>
     <a id="_idIndexMarker163">
     </a>
     
      settings; if everything looks good,
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Create
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      At this point, the deployment process will continue.
     
     
      Click
     
     <strong class="bold">
      
       Go to resource
      
     </strong>
     
      ; you’ll be taken to your brand
     
     
      
       new Function!
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.17 – Portal overview blade for your Azure Function" src="img/B21988_06_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.17 – Portal overview blade for your Azure Function
    
   </p>
   <ol>
    <li value="10">
     
      Click on the URL listed on the right-hand side.
     
     
      You’ll be taken to a default page indicating that your Function
     
     
      
       is running:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.18 – Default Azure Functions landing page﻿" src="img/B21988_06_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.18 – Default Azure Functions landing page
    
   </p>
   <p class="callout-heading">
    
     Tip
    
   </p>
   <p class="callout">
    
     While these steps and screenshots are accurate at the time of writing, Azure often changes and upgrades its design, features, flow, and so on.
    
    
     It’s recommended that you check out the official documentation for
    
    
     
      updated guidance.
     
    
   </p>
   <p>
    
     Now that the Function resource is running with
    
    <a id="_idIndexMarker164">
    </a>
    <a id="_idIndexMarker165">
    </a>
    
     a default template, let’s deploy from
    
    
     
      Visual Studio.
     
    
   </p>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor090">
    </a>
    
     Publishing from Visual Studio
    
   </h2>
   <p>
    
     Let’s walk through deploying manually from
    
    <a id="_idIndexMarker166">
    </a>
    <a id="_idIndexMarker167">
    </a>
    
     Visual Studio.
    
    
     Automated deployments, also known as continuous delivery, will be covered in
    
    <a href="B21998_10.xhtml#_idTextAnchor136">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     
      :
     
    
   </p>
   <ol>
    <li>
     
      Back in
     
     <strong class="bold">
      
       Visual Studio
      
     </strong>
     
      , right-click on the
     
     <strong class="bold">
      
       FunctionsChapter6
      
     </strong>
     
      project and
     
     
      
       select
      
     
     
      <strong class="bold">
       
        Publish…
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.19 – Publishing our project" src="img/B21988_06_19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.19 – Publishing our project
    
   </p>
   <ol>
    <li value="2">
     
      Then, select
     
     <strong class="bold">
      
       Azure
      
     </strong>
     
      and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.20 – Types of publishing" src="img/B21988_06_20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.20 – Types of publishing
    
   </p>
   <ol>
    <li value="3">
     
      Select
     
     <strong class="bold">
      
       Azure Function App (Linux)
      
     </strong>
     
      and
     
     <a id="_idIndexMarker168">
     </a>
     <a id="_idIndexMarker169">
     </a>
     
      
       click
      
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.21 – Azure publishing targets" src="img/B21988_06_21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.21 – Azure publishing targets
    
   </p>
   <ol>
    <li value="4">
     
      Select the
     
     <strong class="bold">
      
       Microsoft account
      
     </strong>
     
      and
     
     <strong class="bold">
      
       subscription
      
     </strong>
     
      you created the Function resource under.
     
     
      Search or locate your Function by name, select it, and
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Finish
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.22 – Selecting the account, subscription, and resource to publish to" src="img/B21988_06_22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.22 – Selecting the account, subscription, and resource to publish to
    
   </p>
   <ol>
    <li value="5">
     
      Click
     
     <strong class="bold">
      
       Finish
      
     </strong>
     
      , then
     
     <strong class="bold">
      
       Close
      
     </strong>
     
      when you’re done.
     
     
      Details
     
     <a id="_idIndexMarker170">
     </a>
     <a id="_idIndexMarker171">
     </a>
     
      about your published profile will appear, including its
     
     <strong class="bold">
      
       Configuration
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Target Runtime
      
     </strong>
     
      , as well as any dependencies that
     
     
      
       it needs:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.23 – Function publish profile" src="img/B21988_06_23.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.23 – Function publish profile
    
   </p>
   <p>
    
     When you’re ready, click
    
    <strong class="bold">
     
      Publish
     
    </strong>
    
     .
    
    
     Once that succeeds, you can view your new API route at https://&lt;my resource name&gt;.azurewebsites.net/api/products/electronics/471337.
    
    
     Note that you can see the default data if you
    
    <a id="_idIndexMarker172">
    </a>
    <a id="_idIndexMarker173">
    </a>
    
     go to https://&lt;my
    
    
     
      resource name&gt;.azurewebsites.net/api/Function
     
    
    
     
      .
     
    
   </p>
   <p>
    
     As mentioned previously in this chapter, we’ll now look at changing a configuration value without recompiling the Function, and without
    
    
     
      redeploying it.
     
    
   </p>
   <h2 id="_idParaDest-91">
    <a id="_idTextAnchor091">
    </a>
    
     Post-deployment reconfiguration
    
   </h2>
   <p>
    
     Now, let’s change the configuration to
    
    <a id="_idIndexMarker174">
    </a>
    <a id="_idIndexMarker175">
    </a>
    
     a
    
    
     
      different value:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       Environment variables
      
     </strong>
     
      blade, under the
     
     <strong class="bold">
      
       Settings
      
     </strong>
     
      section of the Function resource in the Azure portal, create a new key to override the setting we hard-coded earlier.
     
     
      Use
     
     <strong class="source-inline">
      
       MyReturnProperty
      
     </strong>
     
      as the key since we’re reading the configuration variables from the
     
     
      
       root namespace:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.24 - Adding a new environment variable to override a setting" src="img/B21988_06_24.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.24 - Adding a new environment variable to override a setting
    
   </p>
   <ol>
    <li value="2">
     <strong class="bold">
      
       Apply
      
     </strong>
     
      this addition,
     
     <strong class="bold">
      
       Apply
      
     </strong>
     
      the changes, and
     
     <strong class="bold">
      
       Confirm
      
     </strong>
     
      the save; your Function application will be restarted.
     
     
      Navigate to https://&lt;my resource name&gt;.azurewebsites.net/api/Function1 so that you can see the new
     
     
      
       configuration value:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.25 – Overridden configuration value" src="img/B21988_06_25.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.25 – Overridden configuration value
    
   </p>
   <p>
    
     This can be nested arbitrarily deep.
    
    
     For example, if your
    
    <strong class="source-inline">
     
      MyOptions
     
    </strong>
    
     class’s
    
    <strong class="source-inline">
     
      MyReturnValue
     
    </strong>
    
     was a complex type with its own
    
    <strong class="source-inline">
     
      MyOtherReturnValue
     
    </strong>
    
     property, the
    
    <a id="_idIndexMarker176">
    </a>
    <a id="_idIndexMarker177">
    </a>
    
     path for the key in Azure would be
    
    <strong class="source-inline">
     
      MyReturnValue__MyOtherReturnValue
     
    </strong>
    
     .
    
    
     Note that there are two underscores between the
    
    
     
      property names.
     
    
   </p>
   <p>
    
     Since this is publicly accessible, it has the potential to cost you money if a rogue process becomes aware of your new endpoint.
    
    
     Securing this new site with what’s colloquially known as
    
    <strong class="bold">
     
      Easy Auth
     
    </strong>
    
     will be discussed later in
    
    
     
      this book.
     
    
   </p>
   <p>
    
     But in the meantime, you can adjust some hosting options to limit the
    
    
     
      potential cost.
     
    
   </p>
   <ol>
    <li>
     
      Navigate to
     
     <strong class="bold">
      
       Settings
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Scale out
      
     </strong>
     
      and change
     
     <strong class="bold">
      
       Maximum Scale Out Limit
      
     </strong>
     
      to
     
     <strong class="bold">
      
       1
      
     </strong>
     
      .
     
     
      Then,
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Save
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.26 – Limiting scale out" src="img/B21988_06_26.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.26 – Limiting scale out
    
   </p>
   <ol>
    <li value="2">
     
      Then, navigate to
     
     <strong class="bold">
      
       Settings
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Configuration
      
     </strong>
     
      , change
     
     <strong class="bold">
      
       Daily Usage Quota
      
     </strong>
     
      to
     
     <strong class="bold">
      
       1
      
     </strong>
     
      , and click
     
     <strong class="bold">
      
       Save
      
     </strong>
     
      ,
     
     
      
       then
      
     
     
      <strong class="bold">
       
        Continue
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.27 – Adding a daily quota" src="img/B21988_06_27.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.27 – Adding a daily quota
    
   </p>
   <p>
    
     At this point, while you haven’t secured your
    
    <a id="_idIndexMarker178">
    </a>
    <a id="_idIndexMarker179">
    </a>
    
     site against bots or malicious actors, you have at least taken a few steps to mitigate any
    
    
     
      potential damage.
     
    
   </p>
   <h1 id="_idParaDest-92">
    <a id="_idTextAnchor092">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we walked through creating multiple HTTP endpoints inside a single Azure Function, adding a route template to assist with managing differing URI segments at runtime.
    
    
     Then, we added configuration options to our project, deployed it to Azure, and adjusted the configuration options after deployment.
    
    
     To limit the potential cost of a deployed, live HTTP endpoint, we adjusted two settings until authorization was
    
    
     
      in place.
     
    
   </p>
   <p>
    
     Now that you understand how HTTP triggers work in Azure Functions, in the next chapter, we’ll explore other types of triggers we can use to build reliable, stateful, and
    
    
     
      scalable workflows.
     
    
   </p>
   <h1 id="_idParaDest-93">
    <a id="_idTextAnchor093">
    </a>
    
     You try it
    
   </h1>
   <p>
    
     Write an API using Azure Functions, create a Function resource in Azure, and then deploy your Function to it with
    
    
     
      Visual Studio.
     
    
   </p>
  </div>
 </body></html>