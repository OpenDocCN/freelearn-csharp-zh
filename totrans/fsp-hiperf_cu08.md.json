["```cs\nbuilder-name { expression } \n\n```", "```cs\nlet fetchAsync(name, url:string) = \n    async {  \n        try  \n            let uri = new System.Uri(url) \n            let webClient = new WebClient() \n            let! html = webClient.AsyncDownloadString(uri) \n            printfn \"Read %d characters for %s\" html.Length name \n        with \n            | ex -> printfn \"%s\" (ex.Message); \n    } \n\n```", "```cs\nM<'T> * ('T -> M<'U>) -> M<'U> \n\n```", "```cs\n'T -> 'U -> M<'V'> \n\n```", "```cs\nM<'T> -> ('T -> 'U -> M<'V>) -> M<'V> \n\n```", "```cs\n[<AbstractClass>] \n[<LocalizabilityAttribute(LocalizationCategory.Ignore)>] \n[<ContentPropertyAttribute(\"Children\")>] \ntype Panel =  \n    class \n        inherit FrameworkElement \n        interface IAddChild \n    end \n\n```", "```cs\n[LocalizabilityAttribute(LocalizationCategory.Ignore)] \n[ContentPropertyAttribute(\"Children\")] \npublic abstract class Panel : FrameworkElement, IAddChild \n\n```", "```cs\n#r \"C:\\\\Program Files (x86)\\\\Reference Assemblies\\\\Microsoft\\\\Framework\\\\.NETFramework\\\\v4.6.1\\\\WindowsBase.dll\" \n#r \"C:\\\\Program Files (x86)\\\\Reference Assemblies\\\\Microsoft\\\\Framework\\\\.NETFramework\\\\v4.6.1\\\\PresentationCore.dll\" \n#r \"C:\\\\Program Files (x86)\\\\Reference Assemblies\\\\Microsoft\\\\Framework\\\\.NETFramework\\\\v4.6.1\\\\PresentationFramework.dll\" \n#r \"C:\\\\Program Files (x86)\\\\Reference Assemblies\\\\Microsoft\\\\Framework\\\\.NETFramework\\\\v4.6.1\\\\System.Xaml.dll\" \n\n```", "```cs\nopen System \nopen System.Windows \nopen System.Windows.Controls \n\n```", "```cs\n[<AbstractClass>] \ntype IComposableControl<'a when 'a :> FrameworkElement> () = \n    abstract Control : 'a \n    abstract Bind : System.Windows.FrameworkElement * (System.Windows.FrameworkElement -> 'a) -> 'a \n    abstract Bind : IComposableControl<'b> * (System.Windows.FrameworkElement -> 'a)  -> 'a \n    member this.Return (e: unit)  = this.Control \n    member this.Zero () = this.Control \n\n```", "```cs\ntype WindowBuilder() = \n    inherit IComposableControl<Window>() \n    let win = Window(Topmost=true) \n    override this.Control = win \n    override this.Bind(c: FrameworkElement, body: FrameworkElement -> Window) : Window = \n        win.Content <- c \n        body c \n    override this.Bind(c: IComposableControl<'b>, body: FrameworkElement -> Window) : Window = \n        win.Content <- c.Control \n        body c.Control \n\n```", "```cs\ntype PanelBuilder(panel: Panel) = \n    inherit IComposableControl<Panel>() \n    override this.Control = panel \n    override this.Bind(c: FrameworkElement, body: FrameworkElement -> Panel) : Panel= \n        if c :? Window then \n            raise (ArgumentException(\"Window cannot be added to panel\")) \n        else \n            panel.Children.Add(c) |> ignore \n            body c \n    override this.Bind(c: IComposableControl<'b>, body: FrameworkElement -> Panel) : Panel= \n        panel.Children.Add(c.Control) |> ignore \n        body c.Control \n    // Implement the code for constructor with no argument. \n    new() = PanelBuilder(StackPanel()) \n\n```", "```cs\nlet win = \n    WindowBuilder() \n        {   let! panel = \n                PanelBuilder(StackPanel()) \n                    {   let! btn1 = Button(Content = \"Hello\") \n                        let! btn2 = Button(Content = \"World\") \n                        return () } \n            return () } \n\ndo win.Show() // Pops up the window in FSI.  \n\n```", "```cs\nlet winzero = WindowBuilder()  \n               { Console.WriteLine(\"sample Zero\") } \ndo winzero.Show() \n\n```", "```cs\nlet windowexp = WindowBuilder() \nlet secondWindow = windowexp  \n                        {  \n                            let! panel = \n                                PanelBuilder(StackPanel()) \n                                    {  \n                                        let! btn1 = Button(Content = \"Hello\") \n                                        let! btn2 = Button(Content = \"Second computation expression\") \n                                        return () \n                                    } \n                           return () \n                        } \n\n```", "```cs\n    type AsyncBuilder() = \n        member b.Zero()                 = doneA \n        member b.Delay(f)               = delayA(f) \n        member b.Return(x)              = resultA(x) \n        member b.ReturnFrom(x:Async<_>) = x \n        member b.Bind(p1, p2)           = bindA p1 p2 \n        member b.Using(g, p)            = usingA g p \n        member b.While(gd, prog)        = whileA gd prog \n        member b.For(e, prog)           = forA e prog \n        member b.Combine(p1, p2)        = sequentialA p1 p2 \n        member b.TryFinally(p, cf)      = tryFinallyA cf p \n        member b.TryWith(p, cf)         = tryWithExnA cf p \n\n```", "```cs\n        // The primitive bind operation. Generate a process that runs the first process, takes \n        // its result, applies f and then runs the new process produced. Hijack if necessary and  \n        // run 'f' with exception protection \n        let bindA p1 f  = \n            unprotectedPrimitive (fun args -> \n                if args.aux.token.IsCancellationRequested then \n                    cancelT args \n                else \n\n                    let args = \n                        let cont a = protectNoHijack args.aux.econt f a (fun p2 -> invokeA p2 args) \n                        { cont=cont; \n                          aux = args.aux \n                        } \n                    // Trampoline the continuation onto a new work item every so often  \n                    let trampoline = args.aux.trampolineHolder.Trampoline \n                    if trampoline.IncrementBindCount() then \n                        trampoline.Set(fun () -> invokeA p1 args) \n                        FakeUnit \n                    else \n                        // NOTE: this must be a tailcall \n                        invokeA p1 args) \n\n```", "```cs\nmember Bind: computation: Async<'T> * binder: ('T -> Async<'U>) -> Async<'U> \n\n```", "```cs\nmember b.Return(x)              = resultA(x) \nmember b.ReturnFrom(x:Async<_>) = x \n\n```", "```cs\n   public static void Main() \n   { \n      var t = Task<int>.Run( () => { \n         for (int ctr = 0; ctr <= 1000000; ctr++) { \n            if (ctr == max / 2 && DateTime.Now.Hour <= 12) { \n               ctr++; \n               break; \n            } \n         } \n         return ctr; \n      } ); \n Console.WriteLine(\"Finished {0:N0} iterations.\", t.Result); \n   } \n\n```", "```cs\nmember Result : 'T with get \n\n```", "```cs\nlet testUnimplementedYieldWindow = \n    windowexp  \n        { \n            let! panel =  \n                PanelBuilder(StackPanel()) \n                    { \n                        let! textblock01 = TextBox(Text = \"test\") \n                        yield button = Button(\"World\") // <- use to test not implemented yield \n                        return () \n                    } \n            return () \n        } \n\n```", "```cs\n// without delay method \ntype ComputeExpression1Builder() = \n  /// Combine two values \n  member sm.Combine(a,b) = a + b \n  /// Zero value \n  /// sm.Zero() \n  member sm.Zero() = 0 \n  /// Return a value  \n  /// sm.Yield expr \n  member sm.Yield(a) = a \n  /// For loop \n  member sm.For(e, f) = \n    Seq.fold(fun s x -> sm.Combine(s, f x)) (sm.Zero()) e \n\n```", "```cs\nlet compute1 = ComputeExpression1Builder() \nlet computeEx1 x = compute1 { for x in [1 .. x] do yield x * x } \nlet computeEx1Result = computeEx1 50 \n\n```", "```cs\n// Add delay method \ntype ComputeExpression2Builder() = \n  /// Combine two values \n  member sm.Combine(a,b) = a + b \n  /// Zero value \n  /// sm.Zero() \n  member sm.Zero() = 0 \n  /// Return a value  \n  /// sm.Yield expr \n  member sm.Yield(a) = a \n  /// For loop \n  member sm.For(e, f) = \n    Seq.fold(fun s x -> sm.Combine(s, f x)) (sm.Zero()) e \n /// Delay a computation\n member sm.Delay (f: unit -> int) =\n System.Console.WriteLine(\"Test\") \n f() \n\n```", "```cs\nlet compute2 = ComputeExpression2Builder() \nlet computeEx2 x = compute2 { for x in [1 .. x] do yield x * x } \nlet computeEx2Result = computeEx2 50 \n\n```"]