<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Working with Images – Real-time Postprocessing and Effects</h1></div></div></div><p>In this chapter we will talk about basic approaches of using built-in Cinder classes for applying effects to still and moving images.</p><p>In this chapter we will learn the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the difference between CPU and GPU image processing</li><li class="listitem" style="list-style-type: disc">Applying basic effects to images</li><li class="listitem" style="list-style-type: disc">Looping through pixels of an image as well as a movie frame</li><li class="listitem" style="list-style-type: disc">Making use of the pixel-level access</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Introducing Texture, Surface, and Channel</h1></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Making Use of Images – Loading and Displaying">Chapter 5</a>, <em>Making Use of Images – Loading and Displaying</em>, we already learned how to load an image into Cinder. The following is the essence of the code we used there:</p><div><pre class="programlisting">gl::Texture texture = loadImage( loadAsset( "image.jpg" ) );</pre></div><p>With this line of code we<a class="indexterm" id="id216"/>
<a class="indexterm" id="id217"/>
<a class="indexterm" id="id218"/> load pixels from the <code class="literal">image.jpg</code> image file into the GPU memory. <code class="literal">Texture</code> is meant for storing the image data but not for manipulating or displaying it. To show the image on the screen, we use the following line of code:</p><div><pre class="programlisting">gl::draw( texture );</pre></div><p>Say we want to do some image processing in between the load and draw stages. To process images on the GPU (where the image data is stored by the <code class="literal">Texture</code> objects), we would use shaders. Shaders <a class="indexterm" id="id219"/>make use of the OpenGL Shading Language<a class="indexterm" id="id220"/> and we won't go in detail about this now as it is way outside the scope of this book.</p><p>There is another <a class="indexterm" id="id221"/>
<a class="indexterm" id="id222"/>
<a class="indexterm" id="id223"/>way of processing the image, that is by loading the image on the CPU. To make use of the CPU, we have to use the <code class="literal">Surface</code> class. It is similar to the <code class="literal">Texture</code> class<a class="indexterm" id="id224"/> but the main difference is that it stores the image data on the CPU. By loading an image on the CPU, we can do the image processing with the C++ code.</p><p>To draw a surface, <a class="indexterm" id="id225"/>
<a class="indexterm" id="id226"/>we will need to convert it to a <code class="literal">Texture</code> instance. It is possible to convert the <code class="literal">Surface</code> data to the <code class="literal">Texture</code> class instances for drawing something similar to the following:</p><div><pre class="programlisting">Surface surface;
gl::Texture texture = gl::Texture( surface );</pre></div><p>By performing the preceding code, we create a GPU friendly texture for displaying it on the screen.</p><p>There is a third image datatype in Cinder, the <code class="literal">Channel</code> class<a class="indexterm" id="id227"/>. If the <code class="literal">Surface</code> class<a class="indexterm" id="id228"/> is able to hold red, green, blue, and alpha values in separate channels within one object, then <code class="literal">Channel</code> makes use of just one channel (can hold one of the channels mentioned) and can be used to store grayscale images.</p><p>It is possible to create a <code class="literal">Surface</code> instance from a <code class="literal">Channel</code> class by adding the following line:</p><div><pre class="programlisting">Surface surface( channel );</pre></div><p>The preceding line of code makes it is possible to create a high-quality, grayscale image as a <code class="literal">Channel</code> class instance by passing a <code class="literal">Surface</code> instance to the <code class="literal">Channel</code> directly.</p><div><pre class="programlisting">Channel channel( surface );</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Applying the grayscale effect</h1></div></div></div><p>In the previous section, we <a class="indexterm" id="id229"/>already discussed one of the basic effects that can be applied in almost every image processing software out there, grayscale. Let's create a simple application that loads an image and converts it to grayscale by using methods we just discussed.</p><p>Open up <strong>TinderBox</strong> and make a new application with the name <code class="literal">BasicEffects</code>. Place an image (let's call it <code class="literal">OurImage.png</code>, I will be using a simple, digitally enhanced hand-drawn sketch from my own archives) in the assets directory of the project and open the <code class="literal">xcode/BasicEffects.xcodeproj</code> project file. Windows users can open the <code class="literal">vc10\BasicEffects.sln</code> file.</p><p>Open <code class="literal">BasicEfectsApp.cpp</code> in your editor and include a couple of headers that we will need later:</p><div><pre class="programlisting">#include "cinder/ImageIo.h"
#include "cinder/gl/Texture.h"
#include "cinder/Surface.h"</pre></div><p>Now declare the variables/objects of type <code class="literal">Texture</code> and <code class="literal">Surface</code> as follows:</p><div><pre class="programlisting">Surface surface;
gl::Texture texture;</pre></div><p>Also, load an image into the <code class="literal">surface</code> object and pass it to the <code class="literal">Texture</code> constructor so we can draw it afterwards (this goes in to the <code class="literal">setup()</code> method implementation):</p><div><pre class="programlisting">surface = Surface( loadImage( loadAsset("<strong>OurImage.png</strong>") ) );
texture = gl::Texture(surface);</pre></div><p>Finally go to the <code class="literal">draw()</code> method<a class="indexterm" id="id230"/> implementation and add the following lines of code to draw the texture:</p><div><pre class="programlisting">if ( texture ) gl::draw( texture );</pre></div><p>Before we draw the texture, we need to make sure that it actually exists.</p><p>When you <a class="indexterm" id="id231"/>compile and run the project our image should appear on the screen. If it does not, make sure that the image really exists in our project's <code class="literal">assets</code> directory and that the image filename argument in the <code class="literal">loadAsset("OurImage.png")</code> is correct.</p><p>We have made the very basic structure for image processing on the CPU. To make the image in grayscale, we will make use of the<a class="indexterm" id="id232"/> <code class="literal">Channel</code> class. First, we will include the <code class="literal">Channel.h</code> file<a class="indexterm" id="id233"/> as follows:</p><div><pre class="programlisting">#include "cinder/Channel.h"</pre></div><p>Next, in the <code class="literal">setup()</code> method<a class="indexterm" id="id234"/> implementation, where we load the image, create a <code class="literal">Channel</code> instance from the <code class="literal">Surface</code> instance and construct the texture by using the newly created channel:</p><div><pre class="programlisting">surface = Surface( loadImage( loadAsset("image.png") ) );
<strong>Channel channel( surface );</strong>
texture = gl::Texture( <strong>channel</strong> );</pre></div><p>Compile and run the project. The following screenshot is a comparison image that shows the difference between the result when we use the <code class="literal">Surface</code> object for constructing a texture and <code class="literal">Channel</code>:</p><div><img alt="Applying the grayscale effect" src="img/9564_07_01.jpg"/></div><p>The image is <a class="indexterm" id="id235"/>automatically converted to grayscale once we pass it to the <code class="literal">Channel</code> constructor and we use the result for creating the texture. You should see it yourself when you compile and run the program.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Using threshold</h1></div></div></div><p>Now we are going to use <a class="indexterm" id="id236"/>some per-pixel manipulation. We will choose one certain threshold value between 0 and 255 and compare each channel of each pixel to that value. If the value is above the threshold, we will change the channel value to maximum (255). If the value is less, we will change it to the minimum (0).</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Previously we were using floating point numbers from 0 to 1 to describe R, G, and B channels. When using <code class="literal">Surface</code> objects and images in general, you might want to know that each pixel of each channel of the <code class="literal">Surface (Surface8u)</code> object consists of 8 bits that can hold 256 values from 0 to 255 if not defined otherwise.</p></div></div><p>As we are dealing with a still image, we have to do this process only once, in the <code class="literal">setup()</code> method<code class="literal"> </code>between the <code class="literal">surface</code> and <code class="literal">texture</code> object initialization. We will make use of a really handy helper class, <code class="literal">Surface::Iter</code>, that will allow us to loop seamlessly through lines (rows) and individual pixels of each line.</p><p>So this is the code that we have to add to the <code class="literal">setup()</code> method<a class="indexterm" id="id237"/> implementation between the <code class="literal">surface</code> and <code class="literal">texture</code> variable initialization lines as follows:</p><div><pre class="programlisting">surface = Surface( loadImage( loadAsset("OurImage.png") ) );

int threshold = 200;
Area area = surface.getBounds();
Surface::Iter iter = surface.getIter( area );
while( iter.line() ) {
  while( iter.pixel() ) {
    iter.r() = iter.r() &gt; threshold ? 255 : 0;
    iter.g() = iter.g() &gt; threshold ? 255 : 0;
    iter.b() = iter.b() &gt; threshold ? 255 : 0;
  }
}

texture = gl::Texture( surface );</pre></div><p>First we define the<a class="indexterm" id="id238"/> threshold, all the values above that will be changed to 255 and all the values below or equal will be changed to 0. Say goodbye to smooth gradients. Next we get the area of the image that we will change. To change the whole image, we have to get the bounds of the whole surface. We have to get an iterator (<code class="literal">iter</code>) to construct a nice nested loop afterwards. Finally we use the iterator to loop through all the lines (rows) and pixels (columns inside the row) of the surface and change it's pixels one by one.</p><p>Don't forget to change the <code class="literal">Texture</code> initialization (you have to use our <code class="literal">Surface</code> instance again instead of <code class="literal">Channel</code>):</p><div><pre class="programlisting">texture = gl::Texture( <strong>surface</strong> );</pre></div><p>Note that we initialize the texture after we make changes to the pixels of the surface. Every time you make changes to the <code class="literal">Surface</code> object that you will be using as a <code class="literal">Texture</code> afterwards, you have to reinitialize the <code class="literal">texture</code> variable from the changed <code class="literal">Surface</code> object.</p><p>Compile and run the project, and see what happens! The following screenshot shows the comparison between the source image and the one with our threshold filter applied:</p><div><img alt="Using threshold" src="img/9564_07_02.jpg"/></div><p>Try to <a class="indexterm" id="id239"/>experiment a bit by changing the threshold value and the way pixel values are being changed before we move on to the next part.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Animating effects</h1></div></div></div><p>Let's make a simple effect animation<a class="indexterm" id="id240"/> by using the tricks we just learned and the<a class="indexterm" id="id241"/> <code class="literal">update()</code> method. We have to modify the code in the <code class="literal">setup()</code> method implementation so it looks similar to the following:</p><div><pre class="programlisting">surface = Surface( loadImage( loadAsset("OurImage.png") ) );
  
<strong>// int threshold = 200; // comment or remove this line</strong>
Area area = surface.getBounds();
Surface::Iter iter = surface.getIter( area );
while( iter.line() ) {
  while( iter.pixel() ) {
<strong>    iter.r() += 1;</strong>
<strong>    iter.g() += 2;</strong>
<strong>    iter.b() += 3;</strong>
  }
}

texture = gl::Texture( surface );</pre></div><p>Next we have to cut and paste all the code except the <code class="literal">surface</code> initialization to the <code class="literal">update()</code> method implementation as follows:</p><div><pre class="programlisting">void BasicEffectsApp::setup() {
  surface = Surface( loadImage( loadAsset("OurImage.png") ) );
}

void BasicEffectsApp::update() {
  Area area = surface.getBounds();
  Surface::Iter iter = surface.getIter( area );
  while( iter.line() ) {
    while( iter.pixel() ) {
      iter.r() += 1;
      iter.g() += 2;
      iter.b() += 3;
    }
  }
  
  texture = gl::Texture( surface );
}</pre></div><p>With that done, <a class="indexterm" id="id242"/>compile and run the project, and see what happens:</p><div><img alt="Animating effects" src="img/9564_07_03.jpg"/></div><p>In the preceding screenshot you can see an animation that looks like some kind of acid eating and that transforms all the surfaces of the image.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Applying effects to moving images</h1></div></div></div><p>We just saw how to <a class="indexterm" id="id243"/>
<a class="indexterm" id="id244"/>get moving effects, let's try to add effects to a moving image.</p><p>Before we do that, it is a good idea to make a copy of our project (<code class="literal">BasicEffects</code>). Let's rename the folder of the new project to <code class="literal">BasicEffectsMotion</code>. Open the project file (<code class="literal">xcode/BasicEffects.xcodeproj</code> on Ma OS X  or <code class="literal">vc10\BasicEffects.sln</code> on Windows).</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>For Windows users, you will have to add <code class="literal">QTMLClient.lib</code> and <code class="literal">CVClient.lib</code> to <strong>Linker</strong> | <strong>Input</strong> | <strong>Additional Dependencies</strong> in the project properties. You will also have to add path to the QuickTime SDK (<code class="literal">C:\QuickTimeSDK-7.3\Libraries</code>) in <strong>Linker</strong> | <strong>General</strong> | <strong>Additional Library Directories</strong> in the project properties. You can access project properties from the menu bar by clicking on <strong>Project</strong> | <strong>BasicEffects Properties</strong>.</p></div></div><p>First we need to find a movie file that we can use. <a class="ulink" href="http://vimeo.com/groups/freehd">http://vimeo.com/groups/freehd</a> seems a good place where you can find free video footage. I found one with a footage of an industrial site.</p><p>Place the movie file in the <code class="literal">assets</code> folder of the project, open the code editor, and start with including the <code class="literal">QuickTime.h</code> file:</p><div><pre class="programlisting">#include "cinder/qtime/QuickTime.h"</pre></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>In case you are using the AppRewrite version of Cinder, you should know that QuickTime has been made as a separate block. Blocks are extensions of Cinder that you can add to your project when you need a specific extra functionality.</p></div></div><p>Next we have to declare some new variables. Since we have a surface and a texture already, we just need to declare a variable for the movie:</p><div><pre class="programlisting">qtime::MovieSurface movie;</pre></div><p>With that done, let's move to the <code class="literal">setup()</code> method part and load the movie by adding the following highlighted code:</p><div><pre class="programlisting">// comment out or remove this line
// surface = Surface( loadImage( loadAsset("OurImage.png") ) );

<strong>// add these lines</strong>
<strong>movie = qtime::MovieSurface( getAssetPath("OurMovie.mp4") );</strong>
<strong>movie.setLoop();</strong>
<strong>movie.play();</strong>
</pre></div><p>Next we have to copy each frame to a surface and transform that surface to a texture so we can draw it on the screen. Let's move to the <code class="literal">update()</code> method implementation to do that, remove all the previous code and add the following:</p><div><pre class="programlisting">if ( movie.checkNewFrame() ) {
  surface = movie.getSurface();
  // add effects here
  if ( surface ) texture = gl::Texture( surface );
}</pre></div><p>As loading the<a class="indexterm" id="id245"/>
<a class="indexterm" id="id246"/> movie is an asynchronous process, we have to check if there is a surface before we pass it to the texture. In the same way we have to check if we have a texture before we draw it. Change the <code class="literal">gl::draw</code> part in the <code class="literal">draw()</code> method to the following:</p><div><pre class="programlisting">if ( texture ) gl::draw( texture, <strong>getWindowBounds()</strong> );</pre></div><p>We need to make sure that the movie is being drawn within the bounds of our application window. We make sure of that by passing the result of the <code class="literal">getWindowBounds()</code> function as the second parameter to the <code class="literal">gl::draw()</code> function.</p><p>Compile and run the project now. You should see the movie playing. Now we are going to combine this with the effect we made earlier. Find the place in the <code class="literal">update()</code> method between the <code class="literal">surface</code> and <code class="literal">texture</code> initialization (I left a comment <code class="literal">// add effects here</code> there). Add the following code there:</p><div><pre class="programlisting">if ( surface ) {
  Area area = surface.getBounds();
  Surface::Iter iter = surface.getIter( area );
  while( iter.line() ) {
    while( iter.pixel() ) {
      iter.r() += addR;
      iter.g() += addG;
      iter.b() += addB;
    }
  }
  addR += 1;
  addG += 2;
  addB += 3;
}</pre></div><p>As you probably must have already guessed, now we have to declare the <code class="literal">addR</code>, <code class="literal">addG</code>, and <code class="literal">addB</code> variables and set their initial values as follows:</p><div><pre class="programlisting">// add this in the class declaration
uint8_t addR, addG, addB;

// add this in the setup() implementation
addR = addG = addB = 0;</pre></div><p>Compile<a class="indexterm" id="id247"/>
<a class="indexterm" id="id248"/> and run the project. You should see the colors of the movie changing as shown in the following screenshot:</p><div><img alt="Applying effects to moving images" src="img/9564_07_04.jpg"/></div><p>Experiment with the <code class="literal">addR</code>, <code class="literal">addG</code>, and <code class="literal">addB</code> values to see what kind of different effects you are able to get out of this.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, we learned the basic methods of applying effects to still and moving images. It is possible to do a lot more by studying the raw image processing algorithms and applying them as per-pixel operations. So if you do that and you are able to reproduce most of the image effects that one can find in Photoshop or Gimp—congratulations! You may also want to bring your knowledge to the next level by learning something about shaders and OpenGL Shading Language.</p></div></body></html>