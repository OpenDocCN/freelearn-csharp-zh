- en: Chapter 7. Optimizing Application's Performance Using Physics in Unity3D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：使用 Unity3D 中的物理优化应用程序性能
- en: In this chapter, you will learn how to optimize your game or application during
    development with Unity3D. There are several factors that need to be kept in mind
    to run the app or game smoothly. We will handle optimization using Physics best
    practices. Although, this chapter will cover Physics tricks primary to handle
    the performance optimization, you will learn other Unity3D tricks for performance
    handling as bonus topics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在 Unity3D 开发过程中优化你的游戏或应用程序。为了使应用程序或游戏顺利运行，需要考虑几个因素。我们将使用物理最佳实践来处理优化。尽管本章主要涵盖物理技巧以处理性能优化，但你还将作为额外内容学习其他
    Unity3D 性能处理技巧。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Developing an optimized application and game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个优化的应用程序和游戏
- en: Checking performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查性能
- en: Moving the static collider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动静态碰撞体
- en: Mesh Colliders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格碰撞体
- en: The complex collider shape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的碰撞体形状
- en: Rigidbodies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体
- en: Joints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接器
- en: The Cloth component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布料组件
- en: Optimized graphics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化图形
- en: Low timestep
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低时间步长
- en: Pros of performance optimization
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化的优点
- en: Developing an optimized application and game
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个优化的应用程序和游戏
- en: Performance is a critical factor for games and applications, and for a fast-paced
    action game, it becomes the key point. For those features where fast Physics combined
    with fully animated characters and a 3D world are required, performance optimization
    is the most important factor. Any game or application needs 60 frames per seconds
    of performance, and so we will need to optimize our game for target devices to
    achieve that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是游戏和应用程序的关键因素，对于快节奏的动作游戏来说，它成为关键点。对于需要快速物理、全动画角色和 3D 世界的地方，性能优化是最重要的因素。任何游戏或应用程序都需要每秒
    60 帧的性能，因此我们需要针对目标设备优化我们的游戏以实现这一点。
- en: Checking performance
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查性能
- en: '**Unity Profiler** is the first thing that we should use to check the performance
    of a game or application. Profiler is a great tool that comes with Unity Pro,
    using which we determine where any frame rate issues are coming from.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity Profiler** 是我们检查游戏或应用程序性能的第一件事。Profiler 是 Unity Pro 附带的一个强大工具，通过它我们可以确定任何帧率问题来自何处。'
- en: 'Profiler uses a graph to show the CPU usage while we play the game. Profiler
    is divided in categorizes such as **Rendering**, **Scripts**, **Physics**, **Garbage**
    **Collector**, **VSync**, and others. This is how it looks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们玩游戏时，Profiler 使用图表来显示 CPU 使用情况。Profiler 被分为多个类别，如 **渲染**、**脚本**、**物理**、**垃圾回收器**、**VSync**
    以及其他。它看起来是这样的：
- en: '![Checking performance](img/00097.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![检查性能](img/00097.jpeg)'
- en: Now, let's see how we handle optimization during the Physics implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在物理实现过程中如何处理优化。
- en: Moving static colliders
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动静态碰撞体
- en: To make less expensive performance, we should avoid moving static colliders.
    You learned in previous chapters that a static collider is a game object with
    a collider component on it; however, it does not have a Rigidbody component. Moving
    static colliders is one of the top causes of performance issues in Unity games
    and it is expensive. If we need to create them with codes, we should add the collider
    and Physic Materials *after* its positioning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少昂贵的性能，我们应该避免移动静态碰撞体。你从前几章中学到，静态碰撞体是一个带有碰撞组件的游戏对象；然而，它没有刚体组件。移动静态碰撞体是 Unity
    游戏中性能问题的首要原因之一，而且成本很高。如果我们需要通过代码创建它们，我们应该在定位后添加碰撞体和物理材料。
- en: Mesh Colliders
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格碰撞体
- en: '**Mesh Colliders** are slow compared to the primitive Box/Sphere Collider.
    A sphere has many more vertices than a cube but the uniform distance from the
    center makes the calculation much easier in comparison to the many individual
    triangles. Mesh colliders have a much higher performance overhead than primitive
    colliders.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格碰撞体** 相比于原始的 Box/Sphere 碰撞体较慢。球体比立方体有更多的顶点，但由于从中心到各点的距离均匀，与许多单独的三角形相比，计算要容易得多。网格碰撞体的性能开销比原始碰撞体要高得多。'
- en: The complex collider shape
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的碰撞体形状
- en: 'To get better performance for more complex shapes, we should combine primitive
    colliders. Let''s have a look at an example. If we have a parent object with a
    Box Collider and Rigidbody component, we should add child objects with just a
    Box Collider. The collision for an entire object will have one multipart object.
    Rather than having several objects linked together, we can add more child objects
    with Rigidbodies and colliders and use joints to connect them to the parent object.
    As shown in the following screenshot, we used a Capsule Collider for the complex
    object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更复杂形状的更好性能，我们应该结合原始碰撞器。让我们看看一个例子。如果我们有一个具有箱式碰撞器和刚体组件的父对象，我们应该添加仅具有箱式碰撞器的子对象。整个对象的碰撞将有一个多部分对象。我们不是将多个对象链接在一起，而是可以添加更多具有刚体和碰撞器的子对象，并使用关节将它们连接到父对象。如下所示，我们为复杂对象使用了胶囊碰撞器：
- en: '![The complex collider shape](img/00098.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![复杂的碰撞器形状](img/00098.jpeg)'
- en: Rigidbodies
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚体
- en: Less use of Rigidbodies and materials saves performance. Again, the use of interpolation
    and extrapolation on Rigidbodies is discouraged all together. The total amount
    of Physics calculation depends on the number of nonsleeping Rigidbodies and colliders
    in the scene and the complexity of the colliders. We should handle performance
    by reducing calculation as much as possible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 减少刚体和材料的使用可以节省性能。再次强调，不建议在刚体上使用插值和外推。总的物理计算量取决于场景中非休眠刚体和碰撞器的数量以及碰撞器的复杂性。我们应该通过尽可能减少计算来处理性能。
- en: Joints
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关节
- en: We cannot use multiple basic joints on one game object as it is not supported,
    but we can use multiple configurable joints, which helps a lot in performance
    optimization. Rather than having a network of joint objects, we should use configurable
    joints wherever possible to avoid unnecessary memory consumption.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不支持在一个游戏对象上使用多个基本关节，因此我们不能这样做，但我们可以使用多个可配置关节，这在性能优化方面非常有帮助。我们应尽可能使用可配置关节，而不是使用关节对象网络，以避免不必要的内存消耗。
- en: The Cloth component
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布料组件
- en: The use of multiple Cloth components in one game is very expensive so should
    minimize the use of multiple Cloth components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个游戏中使用多个布料组件非常昂贵，因此应尽量减少使用多个布料组件。
- en: Lower timestep
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 较低的时间步长
- en: A lower frame rate gives breathing room and helps in memory optimization. I
    personally find a 0.03 fixed timestep with a maximum of about 0.05 to be good
    for better performance. We can reduce the time spent on Physics updates by adjusting
    the fixed timestep setting. Increasing the timestep will reduce the CPU overhead
    but sometimes, the accuracy of Physics gets affected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 较低的帧率提供了更多的呼吸空间，有助于内存优化。我个人发现0.03的固定时间步长，最大约为0.05，对更好的性能是有益的。我们可以通过调整固定时间步长设置来减少物理更新的时间。增加时间步长将减少CPU开销，但有时会影响物理的准确性。
- en: Precalculation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预计算
- en: Precalculation during development can be very important to achieve high performance
    and make certain effects possible. Taking the approach of calculating as much
    as possible at the start of execution can have a great impact on performance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中进行预计算对于实现高性能和实现某些效果非常重要。在执行开始时尽可能计算的方法可以对性能产生重大影响。
- en: Apart from Physics-based performance optimizations, there are other factors
    too that we should use to optimize our game or app. Let's have a few examples.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于物理的性能优化外，还有其他因素我们也应该用来优化我们的游戏或应用。让我们举几个例子。
- en: Optimizing graphics
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化图形
- en: Performance optimization depends upon how fast we can render by GPU, which is
    mostly limited by the number of pixels rendered and by the memory bandwidth. The
    CPU performance is also limited by the amount of draw calls processed. We can
    use GPU Profiler to find out how much time and how many draw calls are in the
    scene. To save rendering time, we should remove as many draw calls as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化取决于GPU的渲染速度，这主要受渲染像素数和内存带宽的限制。CPU性能也受处理绘制调用的数量的限制。我们可以使用GPU分析器来找出场景中有多少时间和多少绘制调用。为了节省渲染时间，我们应该尽可能多地移除绘制调用。
- en: 'As shown in the following screenshot, by clicking on **Stats**, we can see
    the **Statistics** window:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，通过点击**Stats**，我们可以看到**统计信息**窗口：
- en: '![Optimizing graphics](img/00099.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![优化图形](img/00099.jpeg)'
- en: 'To improve CPU performance, we should take into account the following points:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高CPU性能，我们应该考虑以下要点：
- en: For high performance, don't use more than a few hundred draw calls per frame
    while draw call counts vary for older devices
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得高性能，每帧不要使用超过几百个绘制调用，而绘制调用数量对于旧设备会有所不同
- en: By combining nearby objects into single meshes, we can reduce draw calls
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将附近的对象组合成单个网格，我们可以减少绘制调用
- en: By using automatically Unity's draw call batching, we can reduce draw calls
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Unity自动的绘制调用批处理，我们可以减少绘制调用
- en: Using fewer different materials enables better batching of meshes
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更少的材料可以更好地批处理网格
- en: By using a textures atlas where possible, we can reduce draw calls
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用纹理图集，我们可以减少绘制调用
- en: 'To improve GPU performance, we should note the following points:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高GPU性能，我们应该注意以下要点：
- en: By reducing the texture quality in the **Quality** settings, we can make the
    game run faster; we limit memory bandwidth by applying this
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在**质量**设置中降低纹理质量，我们可以使游戏运行得更快；我们通过这种方式限制内存带宽
- en: We can reduce shader complexity using mobile GPUs and avoid alpha-testing shader.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用移动GPU减少着色器复杂性并避免alpha测试着色器。
- en: Use texture compression or 16-bit textures
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理压缩或16位纹理
- en: Reduce the texture size
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少纹理大小
- en: Script call optimization for an iOS build
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS构建的脚本调用优化
- en: 'To make a big impact on project completion, from the initial phase of project,
    we should use slow but safe option of **Script Call Optimization**. Using this
    unhandled exception will crash the Unity build but if handled, we can get a higher
    performance at the end of the project. To apply this, navigate to the **Player**
    setting and select **iOS** as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要对项目完成产生重大影响，从项目的初始阶段开始，我们应该使用缓慢但安全的**脚本调用优化**选项。使用这个未处理的异常会导致Unity构建崩溃，但如果处理得当，我们可以在项目结束时获得更高的性能。要应用此选项，请导航到**玩家**设置并选择**iOS**，如图下截图所示：
- en: '![Script call optimization for an iOS build](img/00100.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![iOS构建的脚本调用优化](img/00100.jpeg)'
- en: 'There are some simple rules for handling performance such as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理性能有一些简单的规则，例如：
- en: Pixel lights are too expensive, so we should avoid them to get high performance
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素灯光太昂贵了，因此我们应该避免它们以获得高性能
- en: Keep your draw call count low because graphics rendering is CPU expensive
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持你的绘制调用数量低，因为图形渲染是CPU密集型的
- en: We should mark the objects that don't move as static
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该将不移动的对象标记为静态
- en: For moving objects, try to keep the vertex count below 300
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于移动对象，尽量保持顶点数低于300
- en: We should avoid instantiating or destroying objects in runtime as the memory
    is slow
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该避免在运行时实例化或销毁对象，因为内存较慢
- en: Avoid alpha because it rejects pixels on iOS devices and it is slow; use alpha
    blend instead
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用alpha通道，因为它在iOS设备上拒绝像素并且速度慢；使用alpha混合代替
- en: Pros of performance optimization
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化的优点
- en: For a successful game or application, the most important and required key point
    is good performance. Smooth game play attracts players; similarly, a better and
    fast user experience allows to capture a large audience.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个成功的游戏或应用，最重要的和必需的关键点是良好的性能。流畅的游戏吸引玩家；同样，更好的快速用户体验可以吸引大量观众。
- en: A great game or application but with a slow speed or that crashes often never
    succeeds. Thus, the most important advantage of performance optimization is that
    using it, we provide fast and smooth gameplay and better user experience, and
    avoid lags or crashes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个伟大的游戏或应用，但如果速度慢或经常崩溃，永远不会成功。因此，性能优化的最重要的优势是，使用它，我们提供快速流畅的游戏体验和更好的用户体验，避免卡顿或崩溃。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the different ways to handle performance. You learned
    about different Physics components and the ways they can be used for better performance.
    You learned how to use a single collider for a complex object, that we should
    not use multiple cloth components in one game, and that we can optimize graphics
    by reducing the number of draw calls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了处理性能的不同方法。你学习了不同的物理组件以及它们如何用于提高性能。你学习了如何为复杂对象使用单个碰撞器，不应该在一个游戏中使用多个布料组件，以及我们可以通过减少绘制调用数量来优化图形。
- en: This book is all about learning Physics with Unity3D. We saw that Unity has
    a powerful Physics engine. You learned about the different Physics components
    provided by Unity3D to make a developer's life easier. You learned how to use
    Physics when creating animations. Now, you are set to learn about networking and
    multiplayer game and application using Unity3D.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书全部关于使用Unity3D学习物理。我们看到了Unity拥有强大的物理引擎。你学习了Unity3D提供的不同物理组件，以使开发者的生活更轻松。你学习了如何在创建动画时使用物理。现在，你准备好学习使用Unity3D进行网络和多人游戏及应用的开发了。
