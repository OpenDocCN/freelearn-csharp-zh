<html><head></head><body>
		<div id="_idContainer057">
			<h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor207"/>Chapter 14</em>: Creating a Custom ActionFilter</h1>
			<p>We will keep on customizing on the controller level in this chapter. We'll have a look into action filters and how to create your own <strong class="source-inline">ActionFilter</strong> class to keep your Actions small and readable. </p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Introducing <strong class="source-inline">ActionFilter</strong></li>
				<li>Using <strong class="source-inline">ActionFilter</strong></li>
			</ul>
			<p>The topics of this chapter belong to the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) layer of the ASP.NET Core architecture, depicted here:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_14.1_B17996.jpg" alt="Figure 14.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – ASP.NET Core architecture </p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor208"/>Technical requirements</h1>
			<p>To follow the exercises in this chapter, you will need to create an ASP.NET Core MVC application. Open your console, shell, or Bash terminal and change to your working directory. Use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new web -n ActionFilterSample -o ActionFilterSample</p>
			<p>Now, open the project in Visual Studio by double-clicking the project file or in <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) by typing the following command in the already open console:</p>
			<p class="source-code">cd ActionFilterSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter14">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter14</a>.</p>
			<h1 id="_idParaDest-117">I<a id="_idTextAnchor209"/><a id="_idTextAnchor210"/>ntroducing ActionFilter</h1>
			<p>Action filters are a little bit like middleware because they can manipulate the input and the output but are <a id="_idIndexMarker208"/>executed immediately on a specific action or on all actions of a specific controller on the MVC layer, and MiddleWare works directly on the request object on the hosting layer. An <strong class="source-inline">ActionFilter</strong> class is created to execute code right before or after an action is executed. They are introduced to execute aspects that are not part of the actual action logic: <strong class="bold">authorization</strong> is one example of these aspects. <strong class="source-inline">AuthorizeAttribute</strong> is used to allow users or groups to access specific Actions or Controllers. <strong class="source-inline">AuthorizeAttribute</strong> is an <strong class="source-inline">ActionFilter</strong>. It checks whether the logged-on user is authorized or not. If not, it redirects to the login page. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you apply an <strong class="source-inline">ActionFilter</strong> globally, it executes on all actions in your application.</p>
			<p>The next code sample shows the skeletons of a normal action filter and an async <strong class="source-inline">ActionFilter</strong>:</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc.Filters;</p>
			<p class="source-code"> </p>
			<p class="source-code">namespace ActionFilterSample;</p>
			<p class="source-code">public class SampleActionFilter : IActionFilter</p>
			<p class="source-code">{</p>
			<p class="source-code">    public void OnActionExecuting(</p>
			<p class="source-code">        ActionExecutingContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // do something before the action executes</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void OnActionExecuted(</p>
			<p class="source-code">        ActionExecutedContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // do something after the action executes</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">public class SampleAsyncActionFilter : IAsyncActionFilter</p>
			<p class="source-code">{</p>
			<p class="source-code">    public async Task OnActionExecutionAsync(</p>
			<p class="source-code">        ActionExecutingContext context,</p>
			<p class="source-code">        ActionExecutionDelegate next)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // do something before the action executes</p>
			<p class="source-code">        var resultContext = await next();</p>
			<p class="source-code">        // do something after the action executes; </p>
			<p class="source-code">        // resultContext.Result will be set</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see here, there are always two methods to place code to execute before and after the target <a id="_idIndexMarker209"/>action is executed. These action filters cannot be used as attributes. If you want to use action filters as attributes in your Controllers, you need to derive them from <strong class="source-inline">Attribute</strong> or from <strong class="source-inline">ActionFilterAttribute</strong>, as shown in the following code snippet:</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc;</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc.Filters;</p>
			<p class="source-code"> </p>
			<p class="source-code">namespace ActionFilterSample;</p>
			<p class="source-code">public class ValidateModelAttribute : ActionFilterAttribute</p>
			<p class="source-code">{</p>
			<p class="source-code">    public override void OnActionExecuting(</p>
			<p class="source-code">        ActionExecutingContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (!context.ModelState.IsValid)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            context.Result = new BadRequestObjectResult(</p>
			<p class="source-code">                context.ModelState);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code snippet shows a simple <strong class="source-inline">ActionFilter</strong> that always returns <strong class="source-inline">BadRequestObjectResult</strong> if <strong class="source-inline">ModelState</strong> is not valid. This may be useful within a web <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) as a default check on <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">PATCH</strong> requests. This could <a id="_idIndexMarker210"/>be extended with a lot more validation logic. We'll see how to use it later on.</p>
			<p>Another possible use case for an <strong class="source-inline">ActionFilter</strong> is logging. You don't need to log in controller actions directly. You can do this in an action filter to keep your actions readable with <a id="_idIndexMarker211"/>relevant code, as illustrated in the following snippet:</p>
			<p class="source-code">using Microsoft.AspNetCore.Mvc.Filters;</p>
			<p class="source-code"> </p>
			<p class="source-code">namespace ActionFilterSample;</p>
			<p class="source-code">public class LoggingActionFilter : IActionFilter</p>
			<p class="source-code">{</p>
			<p class="source-code">    ILogger _logger;</p>
			<p class="source-code">    public LoggingActionFilter(ILoggerFactory </p>
			<p class="source-code">      loggerFactory)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _logger =</p>
			<p class="source-code">         loggerFactory.CreateLogger&lt;LoggingActionFilter&gt;();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void OnActionExecuting(</p>
			<p class="source-code">        ActionExecutingContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _logger.LogInformation(</p>
			<p class="source-code">          $"Action '{context.ActionDescriptor.DisplayName}'</p>
			<p class="source-code">            executing");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void OnActionExecuted(</p>
			<p class="source-code">        ActionExecutedContext context)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _logger.LogInformation(</p>
			<p class="source-code">          $"Action '{context.ActionDescriptor.DisplayName}'</p>
			<p class="source-code">            executed");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This logs an informational message out to the console. You can get more information about the current <a id="_idIndexMarker212"/>action out of <strong class="source-inline">ActionExecutingContext</strong> or <strong class="source-inline">ActionExecutedContext</strong>—for example, the arguments, the argument values, and so on. This makes action filters pretty useful.</p>
			<p>Let's see how action filters work in practi<a id="_idTextAnchor211"/><a id="_idTextAnchor212"/>ce.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor213"/>Using ActionFilter</h1>
			<p>Action filters that are <a id="_idIndexMarker213"/>actually attributes can be registered as an attribute of an Action or a Controller, as illustrated in the following code snippet:</p>
			<p class="source-code">[HttpPost]</p>
			<p class="source-code">[ValidateModel] // ActionFilter as attribute</p>
			<p class="source-code">public ActionResult&lt;Person&gt; Post([FromBody] Person model)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // save the person</p>
			<p class="source-code">    return model; //just to test the action</p>
			<p class="source-code">}</p>
			<p>Here, we use <strong class="source-inline">ValidateModel</strong> attribute that checks the <strong class="source-inline">ModelState</strong> and returns <strong class="source-inline">BadRequestObjectResult</strong> in case the <strong class="source-inline">ModelState</strong> is invalid; we don't need to check the <strong class="source-inline">ModelState</strong> in the actual Action.</p>
			<p>To register action filters globally, you need to extend the MVC registration in the <strong class="source-inline">ConfigureServices</strong> method of the <strong class="source-inline">Startup.cs</strong> file, as follows:</p>
			<p class="source-code">builder.Services.AddControllersWithViews()</p>
			<p class="source-code">    .AddMvcOptions(options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        options.Filters.Add(new SampleActionFilter());</p>
			<p class="source-code">        options.Filters.Add(new SampleAsyncActionFilter());</p>
			<p class="source-code">    });</p>
			<p>Action filters <a id="_idIndexMarker214"/>registered like this will be executed on every action. This way, you are able to use action filters that don't derive from an attribute.</p>
			<p>The <strong class="source-inline">LoggingActionFilter</strong> we created previously is a little more special. It is dependent on <a id="_idIndexMarker215"/>an instance of <strong class="source-inline">ILoggerFactory</strong>, which needs to be passed <a id="_idIndexMarker216"/>into the constructor. This won't work well as an attribute, because <strong class="source-inline">Attributes</strong> don't support <strong class="bold">constructor injection</strong> (<strong class="bold">CI</strong>) via <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>). <strong class="source-inline">ILoggerFactory</strong> is registered in the ASP.NET Core DI container and needs to be injected into <strong class="source-inline">LoggingActionFilter</strong>.</p>
			<p>Because of this, there are some more ways to register action filters. Globally, we are able to register them as a type that gets instantiated by the DI container, and the dependencies can be solved by the container, as illustrated in the following code snippet:</p>
			<p class="source-code">builder.Services.AddControllersWithViews()</p>
			<p class="source-code">    .AddMvcOptions(options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        options.Filters.Add&lt;LoggingActionFilter&gt;();</p>
			<p class="source-code">    })</p>
			<p>This works well. We now have <strong class="source-inline">ILoggerFactory</strong> in the filter.</p>
			<p>To support automatic resolution in <strong class="source-inline">Attributes</strong>, you need to use the <strong class="source-inline">ServiceFilter</strong> attribute on the Controller or Action level, as illustrated here:</p>
			<p class="source-code">[ServiceFilter(typeof(LoggingActionFilter))]</p>
			<p class="source-code">public class HomeController : Controller</p>
			<p class="source-code">{</p>
			<p>In addition to the global filter registration, <strong class="source-inline">ActionFilter</strong> needs to be registered in <strong class="source-inline">ServiceCollection</strong> before we can use it with <strong class="source-inline">ServiceFilter</strong> attribute, as follows:</p>
			<p class="source-code">builder.Services.AddSingleton&lt;LoggingActionFilter&gt;();</p>
			<p>To be complete, there is another way to use action filters that needs arguments passed into the constructor. You can <a id="_idIndexMarker217"/>use the <strong class="source-inline">TypeFilter</strong> attribute to automatically instantiate the filter. But using this attribute, the filter <em class="italic">isn't</em> instantiated by the DI container; the arguments need to be specified as arguments of the <strong class="source-inline">TypeFilter</strong> attribute. </p>
			<p>See the next snippet from the official documentation:</p>
			<p class="source-code">[TypeFilter(typeof(AddHeaderAttribute),</p>
			<p class="source-code">    Arguments = new object[] { "Author", "Juergen Gutsch </p>
			<p class="source-code">      (@sharpcms)" })]</p>
			<p class="source-code">public IActionResult Hi(string name)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return Content($"Hi {name}");</p>
			<p class="source-code">}</p>
			<p>The type of the filter and the arguments are specified with the <strong class="source-inline">TypeFilter</strong> at<a id="_idTextAnchor214"/>tribute.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor215"/>Summary</h1>
			<p>Action filters give us an easy way to keep actions clean. If we find repeating tasks inside our Actions that are not really relevant to the actual responsibility of the Action, we can move those tasks out to an <strong class="source-inline">ActionFilter</strong>, or maybe a <strong class="source-inline">ModelBinder</strong> or some MiddleWare, depending on how it needs to work globally. The more relevant it is to an Action, the more appropriate it is to use an <strong class="source-inline">ActionFilter</strong>.</p>
			<p>There are more kinds of filters, all of which work in a similar fashion. To learn more about the different kinds of filters, reading the documentation is definitely recommended.</p>
			<p>In the next chapter, we speed up your web application by using<a id="_idTextAnchor216"/> caches.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor217"/>Further reading</h1>
			<ul>
				<li>Microsoft ASP.NET Core filters: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters</a> </li>
			</ul>
		</div>
	</body></html>