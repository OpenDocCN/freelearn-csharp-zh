<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Introduction to WinUI</h1>
			<p><strong class="bold">WinUI 3</strong> is<a id="_idIndexMarker000"/> a set of <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) controls and libraries that Windows developers can leverage in their desktop applications. It is the UI part of the Windows App SDK, which was previously <a id="_idIndexMarker001"/>known as <strong class="bold">Project Reunion</strong>. UWP developers use the <strong class="bold">Windows Software Development Kit</strong> (<strong class="bold">Windows SDK</strong>) to<a id="_idIndexMarker002"/> build their applications and are required to select a target SDK version in a project’s properties. By extracting the UWP controls and UI components from the Windows SDK, rewriting them for use with .NET, and releasing them as a set of libraries in the <strong class="bold">Windows App SDK</strong> under <a id="_idIndexMarker003"/>the name WinUI, Microsoft has been able to release versions at a faster cadence than Windows itself (as Windows SDK versions are linked to those of Windows). This separation also enables the controls to be used on older versions of Windows 10. While building desktop applications with WinUI is the current recommendation, it is important to learn where WinUI and the Windows App SDK fit into the larger Windows development landscape.</p>
			<p>In this book, you will learn how to build applications for Windows with the WinUI 3 libraries. Throughout the course of the book, we will build a real-world application using the recommended patterns and practices for Windows application development.</p>
			<p>Before we start building our WinUI app, it’s important to have a good foundation in Windows client<a id="_idIndexMarker004"/> development, the different types of <strong class="bold">Extensible Application Markup Language</strong> (<strong class="bold">XAML</strong>) UI markup, and how WinUI compares to other Windows desktop development frameworks. Therefore, in this first chapter, you will start by learning some background on UWP and WinUI.</p>
			<p>In this chapter, we will learn about the following topics:</p>
			<ul>
				<li>What UWP is and why Microsoft created yet another application framework</li>
				<li>How XAML can be leveraged to create great UIs on many device sizes and families</li>
				<li>Why WinUI was created and how it relates to UWP</li>
				<li>Where WinUI fits into the Windows developer landscape</li>
				<li>What WinUI 3 brings to the table</li>
			</ul>
			<p>Don’t worry! It won’t take very long to cover the background stuff, and it will help provide some context as you start building your WinUI app. In the next chapter, you will get your hands on some code when you create your first WinUI project.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software is required:</p>
			<ul>
				<li>Windows 10 version 1809 or later or Windows 11. You can find your version of Windows in <strong class="bold">Settings</strong> | <strong class="bold">About</strong>.</li>
				<li>Visual Studio 2022 version 17.0 or later with the following workload: .NET Desktop Development. On the <strong class="bold">Installation details</strong> tab of the <strong class="bold">Visual Studio Installer</strong>, ensure that <strong class="bold">Windows App SDK C# Templates</strong> is selected.</li>
			</ul>
			<p>The source code for this chapter is available on GitHub at this URL: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter01">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter01</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Windows App SDK site on Microsoft Learn has up-to-date guidance on setting up a developer workstation for WinUI 3 development: <a href="https://learn.microsoft.com/windows/apps/windows-app-sdk/set-up-your-development-environment">https://learn.microsoft.com/windows/apps/windows-app-sdk/set-up-your-development-environment</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Before UWP – Windows 8 XAML applications</h1>
			<p>Before <a id="_idIndexMarker005"/>UWP applications were launched with Windows 10 in 2015, there were XAML applications for Windows 8 and 8.1. The XAML syntax and many of <a id="_idIndexMarker006"/>the <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) were the same, and they were Microsoft’s next step to achieve universal app development across desktop, mobile, and other platforms (Xbox, mixed reality, and so on). A XAML app could be written for Windows 8 and Windows Phone. These projects would generate separate sets of binaries that could be installed on a PC or a Windows Phone.</p>
			<p>These<a id="_idIndexMarker007"/> apps had many other limitations that modern UWP apps do not. For instance, they only ran full-screen, as shown in the following screenshot:</p>
			<div><div><img src="img/B20908_01_01.jpg" alt="Figure 1.1 – Windows 8 full-screen app (sourced from Stack Overflow; reproduced under CC BY-SA 4.0 – https://creativecommons.org/licenses/by-sa/4.0/)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Windows 8 full-screen app (sourced from Stack Overflow; reproduced under CC BY-SA 4.0 – https://creativecommons.org/licenses/by-sa/4.0/)</p>
			<p>Many other early restrictions on Windows 8 apps have been lessened or completely removed in UWP app development. <em class="italic">Figure 1</em><em class="italic">.2</em>, which follows, documents these changes:</p>
			<div><div><img src="img/B20908_01_02.jpg" alt="Figure 1.2 – Windows 8 and Windows 10 app comparison table"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Windows 8 and Windows 10 app comparison table</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Windows application UI design</h2>
			<p>The term <em class="italic">Metro style</em> was <a id="_idIndexMarker008"/>used to define the design and layout of<a id="_idIndexMarker009"/> Windows 8 apps. Metro style apps were designed to be usable with touch input, a mouse and keyboard, or a stylus. Microsoft’s introduction of the first Windows Phone was a driving factor for Metro style design. Metro style later became Modern UI design, with the introduction of Surface devices. Aspects of Metro live on today in UWP apps and Windows 10.</p>
			<p>Live Tiles<a id="_idIndexMarker010"/> were born with Metro Style. These tiles on the user’s Windows 8 home screen and Windows 10 Start menu can update to display live updates to users without having to open the app. Most of Microsoft’s own apps for Windows 10 supported Live Tiles. The Weather app could show live updates to current weather conditions on the tile, based on the user’s current location. Live tiles are no longer part of the operating system in Windows 11. They have been replaced by widgets, which app developers can also create. We will discuss widgets further in <a href="B20908_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring </em><em class="italic">WinUI Controls</em>.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Windows Runtime (WinRT)</h2>
			<p>Another<a id="_idIndexMarker011"/> term that has its roots in Windows 8 app development is <strong class="bold">WinRT</strong>. The letters RT became a source of great confusion. WinRT was short for <strong class="bold">Windows Runtime</strong>, the underlying APIs used by Windows XAML apps. There was also a version of Windows 8 called Windows RT that supported Arm processors. The <a id="_idIndexMarker012"/>first Surface PC was the Surface RT, which ran the Windows 8 RT operating system.</p>
			<p>Although WinRT can still be used today to define the WinRT APIs consumed by UWP apps, you will not see the term as often. We will also avoid using WinRT in this book and instead refer to the APIs as the UWP or Windows APIs.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>User backlash and the path forward to Windows 10</h2>
			<p>While Microsoft pushed hard to win over users with Modern UI design, a new app model, Surface PCs, and Windows 8 and 8.1, the idea of a full-screen, touch-first app experience and a deemphasized Windows desktop was never embraced by customers. It turns out that Windows users really liked the Start menu experience they had used for years with Windows XP and Windows 7.</p>
			<p>The next step in Windows app development was a big one—so big, in fact, that Microsoft decided to skip a number in their versioning, jumping straight from Windows 8.1 to Windows 10.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/>Windows 10 and UWP application development</h1>
			<p>While taking a leap forward with the launch of Windows 10, Microsoft also blended the best of what worked in previous versions of Windows. It brought back the start menu, but its contents look an awful lot like the Windows 8 home screen experience. In addition to an alphabetized list of all installed apps, there is a resizable area for pinned app tiles. In fact, when running Windows in Tablet mode, the start menu can transform into the Windows 8-style home screen experience for better usability on a touchscreen.</p>
			<p>When Microsoft launched<a id="_idIndexMarker013"/> Windows 10, it also introduced UWP applications to Windows developers. While UWP apps have their roots in the XAML apps of Windows 8, some key differences give developers some major advantages when building apps for the platform.</p>
			<p>A key advantage is the universal aspect of these apps. Microsoft builds versions of Windows 10 to run on different device families, listed as follows:</p>
			<ul>
				<li>Desktop (PC)</li>
				<li>Xbox</li>
				<li>Mobile (Windows Phone)</li>
				<li>HoloLens</li>
				<li>IoT</li>
				<li>IoT Headless</li>
				<li>Team (Surface Hub)</li>
			</ul>
			<p>UWP developers <a id="_idIndexMarker014"/>can build apps to target any of these devices. There is a single base set of Windows APIs shared across all these targets, and specialized SDKs available for the device-specific APIs of some families—for example, there is a Mixed Reality Toolkit and SDK for HoloLens development. With UWP, it is possible to create a single project to target many device families—for instance, you can create a project that creates apps for Desktop, Xbox, and Team families.</p>
			<p>Because the UWP XAML for building the app’s UI is the same, the learning curve for cross-device development is lowered and code reusability is very high. The nature of XAML provides UI flexibility to adapt to different device sizes and aspect ratios.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Language choice with UWP development</h2>
			<p>While <a id="_idIndexMarker015"/>the underlying UWP APIs were written in C++, UWP developers can choose from several programming languages when building apps for Windows. UWP projects can be created with any of these popular languages:</p>
			<ul>
				<li><strong class="bold">C#</strong></li>
				<li><strong class="bold">C++</strong></li>
				<li><strong class="bold">F#</strong></li>
				<li><strong class="bold">Visual Basic .</strong><strong class="bold">NET</strong> (<strong class="bold">VB.NET</strong>)</li>
				<li><strong class="bold">JavaScript</strong></li>
			</ul>
			<p>You may be surprised to see JavaScript on the list. During the Windows 8.x days, developers could create JavaScript apps with APIs known as WinJS apps. Today, Microsoft has created a branch of <strong class="bold">React Native for Windows</strong> developers, known as React Native for Windows. These<a id="_idIndexMarker016"/> JavaScript client apps have full access to the same Windows APIs as other UWP apps and can be packaged and deployed through the Windows Store.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">React Native for Windows<a id="_idIndexMarker017"/> is an open source project hosted by Microsoft on GitHub at <a href="https://github.com/Microsoft/react-native-windows">https://github.com/Microsoft/react-native-windows</a>.</p>
			<p>While many of the UWP apps developed for Windows 10 and Windows 11 by Microsoft are created with C++, most other developers choose C#. We will also use C# when building our applications throughout the course of this book.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Lifting app restrictions</h2>
			<p>As<a id="_idIndexMarker018"/> discussed earlier, apps built for Windows 8 had several restrictions that have been either removed or relaxed with UWP.</p>
			<p>First and foremost, modern UWP apps can run in resizable windows, just like any other Windows desktop application. The trade-off is that developers now need to test for and handle the resizing of their app to almost any size. The dynamic nature of XAML can handle a lot of the resizing very well, but below a certain minimum size, scroll bars will need to be employed.</p>
			<p>For end users, one of the benefits of using UWP apps is the inherent security they provide due to the limited access of apps to the PC’s filesystem. By default, each app can only access its own local storage. In 2018, the Windows developer team announced a new feature for UWP developers. By adding some app configuration declaring which additional types of access the app requires, applications can request access to additional parts of the filesystem. Among them are the following:</p>
			<ul>
				<li>User libraries, including documents, pictures, music, and videos</li>
				<li>Downloads</li>
				<li>Removable devices</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There are additional filesystem permissions<a id="_idIndexMarker019"/> that can be requested. See the Microsoft Learn documentation for an entire list: <a href="https://learn.microsoft.com/windows/uwp/files/file-access-permissions">https://learn.microsoft.com/windows/uwp/files/file-access-permissions</a>.</p>
			<p>Any additional permissions requested will be declared on the app’s listing on the Microsoft Store.</p>
			<p>Some less-common scenarios are now available to UWP apps on Windows. Developers can add some configuration and startup code to enable multiple instances of their app to launch. While many believe the hallmark of a UWP app is the XAML UI, it was also possible to create a UWP console app. The app ran at the command line and had access to Universal C runtime calls. These are no longer supported, as developers can now create .NET console apps and package them with MSIX to provide them with package identity in Windows.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will discuss app packaging, MSIX, and package identity in detail in <a href="B20908_14.xhtml#_idTextAnchor582"><em class="italic">Chapter 14</em></a>, <em class="italic">Packaging and Deploying </em><em class="italic">WinUI Applications</em>.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>UWP backward compatibility</h2>
			<p>No UWP app is<a id="_idIndexMarker020"/> compatible with any version of Windows before Windows 10. Beyond this, each UWP app must declare a <strong class="bold">target version</strong> and a <strong class="bold">minimum version</strong> of Windows with which it is compatible. The target version is your recommended version, which will enable all the app’s features and functionality. The minimum version is, unsurprisingly, the minimum version of Windows that users must have to be able to install an app from the Microsoft Store.</p>
			<p>Visual Studio will prompt you to select these versions when creating a new UWP project. If the two are the same, it keeps things simple. You will have all the APIs of that SDK version available to the app. If the target version is greater than the minimum version, you need to add some conditional code to light up the features of any versions greater than the minimum. The app must still be useful to users running the minimum version; otherwise, it is advisable to increase the minimum. If any of the newer APIs or controls are fundamental to the app, it is also recommended that the minimum version be increased to one where those are available.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on writing the<a id="_idIndexMarker021"/> conditional or version-adaptive code, see the Microsoft Learn documentation here: <a href="https://learn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code">https://learn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code</a>.</p>
			<p>If you are creating .NET libraries that will be referenced by your UWP project and you would like to share them across other platforms, perhaps by a .NET MAUI mobile app, a .NET Standard version should be targeted by the shared library project. The most common .NET Standard version today is .NET Standard 2.0. To reference a .NET Standard 2.0 project from a UWP project, the target version of the UWP project should be 16299 or later.</p>
			<p>The primary benefit of WinUI over UWP is that it lessens the dependency of Windows apps on a particular version of Windows. Instead, the controls, styles, and APIs are maintained outside of the Windows SDK. At the time of writing, the minimum and target versions required for a WinUI 3 app must be set to 17763 or higher. Check the latest WinUI 3 documentation for the current minimum requirements.</p>
			<p>The hope for WinUI is to bring a greater number of controls and features to more supported versions of Windows as the project matures.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>What is XAML?</h1>
			<p><strong class="bold">XAML</strong> is based on <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>). This would seem like a great thing as XML is a flexible <a id="_idIndexMarker022"/>markup language familiar to most<a id="_idIndexMarker023"/> developers. It is indeed flexible and powerful, but it has some drawbacks.</p>
			<p>The primary problem with Microsoft’s implementations of XAML is that there have been so many variations of the XAML language created for different development platforms over the years. Currently, WinUI/UWP, <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>), and .NET MAUI (formerly Xamarin.Forms) applications<a id="_idIndexMarker024"/> all use XAML as their UI markup language, in addition to some third-party UI frameworks. However, each of these uses a different XAML implementation or schema, and the markup cannot be shared across the platforms. In the past, Windows 8, Silverlight, and Windows Phone apps also had additional.</p>
			<p>If you have never worked with XAML before, you’re probably ready to see an example of some UI markup. The following XAML is a fragment that defines <code>Grid</code> containing several other of the basic WinUI controls (you can download the code for this chapter from GitHub here: <a href="https://github.com/PacktPublishing/-Learn-WinUI-3-second-edition/tree/master/Chapter01">https://github.com/PacktPublishing/-Learn-WinUI-3-second-edition/tree/master/Chapter01</a>):</p>
			<pre class="source-code">
&lt;Grid Width="400" Height="250" Padding="2"
   HorizontalAlignment="Center"
     VerticalAlignment="Center"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="*"/&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto"/&gt;
        &lt;ColumnDefinition Width="*"/&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;TextBlock Grid.Row="0" Grid.Column="0"
               Text=»Name:»
               Margin=»0,0,2,0»
               VerticalAlignment="Center"/&gt;
    &lt;TextBox Grid.Row="0" Grid.Column="1"
             Text=»»/&gt;
    &lt;Button Grid.Row="1" Grid.Column="1" Margin="0,4,0,0"
            HorizontalAlignment="Right"
            VerticalAlignment="Top"
            Content=»Submit»/&gt;
&lt;/Grid&gt;</pre>			<p>Let’s break down the <a id="_idIndexMarker025"/>XAML here. The top level of a WinUI window is <code>Window</code>. WinUI 3 app navigation is Window-based (unlike UWP, which is Page-based), and the initial navigation happens in the <code>App.xaml</code> file in the project. You will learn more about navigation in <a href="B20908_04.xhtml#_idTextAnchor097"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced MVVM Concepts</em>. A <code>Window</code> must contain only one child, and it will be some type of layout panel such as a <code>Grid</code> or <code>StackPanel</code>. By default, a <code>StackPanel</code> is inserted as that child. We will discuss other types of panels that serve as good parent containers in the next chapter. I made a few modifications and replaced the <code>StackPanel</code> with a <code>Grid</code>.</p>
			<p>The <code>Height</code> and <code>Width</code> properties provide a static size for the example, and the <code>HorizontalAlignment</code> and <code>VerticalAlignment</code> properties will center the <code>Grid</code> within the <code>Window</code>. Fixed sizes are uncommon at this level of the XAML and limit the flexibility of the layout, but they illustrate some of the available attributes.</p>
			<p>A <code>Grid</code> is a layout panel that allows developers to define rows and columns to arrange its elements. The rows and columns can have their sizes defined as fixed, relative to each other, or auto-sized based on their contents. For more information, you can read the Microsoft Learn article <em class="italic">Responsive layouts with </em><em class="italic">XAML</em>: <a href="https://learn.microsoft.com/windows/uwp/design/layout/layouts-with-xaml">https://learn.microsoft.com/windows/uwp/design/layout/layouts-with-xaml</a>.</p>
			<p>The <code>Grid.RowDefinitions</code> block defines the number and behavior of the grid’s rows. Our grid will have two rows. The first one has <code>Height="Auto"</code>, which means it will resize itself to fit its contents, provided enough space is available. The second row has <code>Height="*"</code>, which means the rest of the grid’s vertical space will be allocated to this row. If multiple rows have their height defined like this, they will evenly split the available space. We will discuss additional sizing options in the next chapter.</p>
			<p>The <code>Grid.ColumnDefinitions</code> block <a id="_idIndexMarker026"/>does for the grid’s columns what <code>RowDefinitions</code> did for the rows. Our grid has two columns defined. The first <code>ColumnDefinition</code> has <code>Height</code> set to <code>Auto</code>, and the second has <code>Height="*"</code>.</p>
			<p><code>TextBlock</code> defines a label in the first <code>Grid.Row</code> and <code>Grid.Column</code>. When working with XAML, all indexes are <code>0</code>-based. In this case, the first <code>Row</code> and <code>Column</code> are both at position <code>0</code>. The <code>Text</code> property conveniently defines the text to display, and the <code>VerticalAlignment</code> in this case will vertically center the text for us. The default <code>VerticalAlignment</code> for a <code>TextBlock</code> is <code>Top</code>. The <code>Margin</code> property adds some padding around the outside of the control. A margin with the same amount of padding on all sides can be set as a single numeric value. In our case, we only want to add a couple of pixels to the right side of the control to separate it from <code>TextBox</code>. The format for entering these numeric values is <code>"&lt;LEFT&gt;,&lt;TOP&gt;,&lt;RIGHT&gt;,&lt;BOTTOM&gt;"</code>, or <code>"</code><code>0,0,2,0"</code> here.</p>
			<p><code>TextBox</code> is a text entry field defined in the second column of the grid’s first row.</p>
			<p>Finally, we’ve added a <code>Button</code> control to the second column of the grid’s second row. A few pixels of upper margin are added to separate it from the controls above. The <code>VerticalAlignment</code> is set to <code>Top</code> (the default is <code>Center</code>) and <code>HorizontalAlignment</code> is set to <code>Right</code> (the default is <code>Center</code>). To set the text of <code>Button</code>, you don’t use the <code>Text</code> property as we did with <code>TextBlock</code>, as you might think. In fact, there is no <code>Text</code> property. The <code>Content</code> property of <code>Button</code> is used here. <code>Content</code> is a special property that we will discuss in more detail in the next chapter. For now, just know that a <code>Content</code> property can contain any other control: text, <code>Image</code>, or even a <code>Grid</code> control containing <a id="_idIndexMarker027"/>multiple other children. The possibilities are virtually endless.</p>
			<p>Here is the UI that gets rendered by the preceding markup:</p>
			<div><div><img src="img/B20908_01_03.jpg" alt="Figure 1.3 – WinUI XAML rendered"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – WinUI XAML rendered</p>
			<p>This is a very simple example to give you a first taste of what can be created with XAML. As we move ahead, you will learn how powerful the language can be.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Creating an adaptive UI for any device</h2>
			<p>In the<a id="_idIndexMarker028"/> previous example, <code>Grid</code> had fixed <code>Height</code> and <code>Width</code> properties. I mentioned that setting fixed sizes can limit a UI’s flexibility. Let’s remove the fixed size properties and use the alignment properties to guide the UI elements to render how we want them to appear at different sizes and aspect ratios, as follows:</p>
			<pre class="source-code">
&lt;Grid VerticalAlignment="Top" HorizontalAlignment="Stretch" Padding="2"&gt;</pre>			<p>The rest of the<a id="_idIndexMarker029"/> markup remains unchanged. The result is <code>TextBox</code> resizing to fit the width of the window, and <code>Button</code> remains anchored to the right of the window as it resizes. See the window resized a couple of different ways here:</p>
			<div><div><img src="img/B20908_01_04.jpg" alt="Figure 1.4 – Resized windows"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Resized windows</p>
			<p>If you <a id="_idIndexMarker030"/>were using this app on a smaller PC such as the Surface Go Laptop, the contents would resize themselves to fit in the available space. That is the power of XAML’s adaptive nature. When building a UI, you will usually want to choose relative and adaptive properties such as alignment to fixed sizes and positions.</p>
			<p>It’s this adaptive layout that makes XAML work so well on mobile devices with .NET MAUI, and this is why WPF developers have loved using it since its launch with Windows Vista.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Powerful data binding</h2>
			<p>Another <a id="_idIndexMarker031"/>reason why XAML-based frameworks are so popular is the ease and power of their data-binding capabilities. Nearly all properties on WinUI controls can be data-bound. The source of the data can be an object or a list of objects on the data source. In most cases, that source will be a <code>ViewModel</code> class. Let’s have a very quick look at using WinUI’s <code>Binding</code> syntax for data-binding to a property on a <code>ViewModel</code> class, as follows:</p>
			<ol>
				<li>First, we will create a simple <code>MainViewModel</code> class with a <code>Name</code> property, like this:<pre class="source-code">
public class MainViewModel : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler
      PropertyChanged;
    private string _name;
    public MainViewModel()
    {
        _name = "Bob Jones";
    }
    public string Name
    {
        get
        {
            return _name;
        }
        set
        {
            if (_name == value) return;
            _name = value;
            PropertyChanged?.Invoke(this, new
              PropertyChangedEventArgs(nameof(Name)));
        }
    }
}</pre><p class="list-inset">The <code>MainViewModel</code> class implements an interface called <code>INotifyPropertyChanged</code>. This interface is key to the UI receiving updates<a id="_idIndexMarker032"/> when data-bound properties have changed. This interface implementation is <a id="_idIndexMarker033"/>typically wrapped<a id="_idIndexMarker034"/> either by a <code>ViewModelBase</code> class. For now, we will directly invoke a <code>PropertyChanged</code> event inside the <code>Name</code> property’s setter. We will learn more about <code>ViewModels</code> and the <code>INotifyPropertyChanged</code> interface in <a href="B20908_03.xhtml#_idTextAnchor073"><em class="italic">Chapter 3</em></a>, <em class="italic">MVVM for Maintainability </em><em class="italic">and Testability</em>.</p></li>				<li>The next step is to create an instance of the <code>MainViewModel</code> class and set it as <code>ViewModel</code> for our <code>MainWindow</code>. This happens in the code-behind file for the page, <code>MainWindow.xaml.cs</code>, as illustrated in the following code snippet:<pre class="source-code">
public sealed partial class MainWindow : Window
{
    public MainWindow()
    {
        this.InitializeComponent();
        ViewModel = new MainViewModel();
    }
    public MainViewModel ViewModel { get; private set; }
}</pre><p class="list-inset">We have added a <code>ViewModel</code> property to <code>MainWindow</code> and set it to a new instance of our <code>MainViewModel</code> class in the constructor.</p></li>			</ol>
			<p class="callout-heading">Tip</p>
			<p class="callout">Any code added to a window’s constructor that interacts with any UI elements must be added after the call to <code>InitializeComponent()</code>.</p>
			<ol>
				<li value="3">Now it’s <a id="_idIndexMarker036"/>time to add the data-binding code to the XAML markup for <code>TextBox</code>, as follows:<pre class="source-code">
&lt;TextBox Grid.Row="0" Grid.Column="1" Text="{x:Bind
  Path=ViewModel.Name, Mode=TwoWay}"/&gt;</pre><p class="list-inset">Some markup has been added to set the <code>Text</code> property using the <code>x:Bind</code> markup extension. The data-binding <code>Path</code> is set to the <code>Name</code> property on the <code>ViewModel</code>, which was assigned in the code-behind file in <em class="italic">step 2</em>. By setting the data-binding mode to <code>TwoWay</code>, updates in the <code>ViewModel</code> will display in the UI, and any updates by the user in the UI will also be persisted in the <code>Name</code> property of the <code>MainViewModel</code> class. Now, running the app will automatically populate the name that was set in the constructor of the <code>ViewModel</code>, as illustrated in the following screenshot:</p></li>			</ol>
			<div><div><img src="img/B20908_01_05.jpg" alt="Figure 1.5 – Data-binding the TextBox"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Data-binding the TextBox</p>
			<ol>
				<li value="4">To illustrate <a id="_idIndexMarker037"/>data-binding to another property on another UI element on the page, we will first modify the grid to add a name, as follows:<pre class="source-code">
&lt;Grid <strong class="bold">x:Name="ParentGrid"</strong>
      VerticalAlignment="Top"
      HorizontalAlignment="Stretch"
      Padding="2"&gt;</pre></li>				<li>Now add another <code>RowDefinition</code> to the <code>Grid</code> to fit the new UI element on the page:<pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    <strong class="bold">&lt;RowDefinition Height="Auto"/&gt;</strong>
    &lt;RowDefinition Height="*"/&gt;
&lt;/Grid.RowDefinitions&gt;</pre></li>				<li>Next, add a <code>TextBlock</code> element and use the <code>Binding</code> markup extension to bind its <code>Text</code> property to the <code>ActualWidth</code> of the <code>ElementName</code> set to <code>ParentGrid</code>. We are also adding a <code>TextBlock</code> to label this as <strong class="bold">Actual Width</strong>:<pre class="source-code">
&lt;TextBlock Grid.Row="1" Grid.Column="0"
           Text="Actual Width:"
           Margin="0,0,2,0"
           VerticalAlignment="Center"/&gt;
&lt;TextBlock Grid.Row="1" Grid.Column="1"
           Text="{Binding ElementName=ParentGrid,
                          Path=ActualWidth}"/&gt;</pre></li>				<li>Next, update the <code>Grid.Row</code> 2.</li>
				<li>Now the <a id="_idIndexMarker038"/>new <code>TextBlock</code> control displays the width of <code>ParentGrid</code> when the page is loaded. Note that it will not update the value if you resize the window. The <code>ActualWidth</code> property does not raise a property change notification. This is documented in the <code>FrameworkElement.ActualWidth</code> documentation: <a href="https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.frameworkelement.actualwidth">https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.frameworkelement.actualwidth</a>:</li>
			</ol>
			<div><div><img src="img/B20908_01_06.jpg" alt="Figure 1.6 – Data-binding to another element"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Data-binding to another element</p>
			<p>The <strong class="bold">Submit</strong> button does not function yet. You will learn how to work with <strong class="bold">Events</strong> and <strong class="bold">Commands</strong> with MVVM in <a href="B20908_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring </em><em class="italic">WinUI Controls</em>.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Styling your UI with XAML</h2>
			<p>When<a id="_idIndexMarker039"/> working with XAML, styles can be defined and applied at almost any scope, global to the application in <code>App.xaml</code>, in the current <code>Window</code> inside a <code>Window.Resources</code> declaration, or inside any level or nested control on the page. The <code>Style</code> element specifies a <code>TargetType</code> property, which is the data type of the elements to be targeted by the style. It can optionally have a <code>Key</code> property defined as a unique identifier, like a class identifier in <code>Key</code> property can be used to apply the style to only selected elements of that type. Only one <code>Key</code> property can be assigned to an element, unlike with CSS classes.</p>
			<p>In the next example, we will modify the page to define a <code>Style</code> property for all buttons on the window, as follows:</p>
			<ol>
				<li>Start by moving the <code>StackPanel</code> element. A <code>StackPanel</code> element stacks all child elements in a horizontal or vertical orientation, with vertical being the default orientation. Some of the button’s properties will need to be moved to the <code>StackPanel</code> element, as it is now the direct child of <code>Grid</code>. After adding a second button to the <code>StackPanel</code> element to act as a <code>StackPanel</code> and <code>Button</code> elements should look like this:<pre class="source-code">
&lt;StackPanel Grid.Row="2" Grid.Column="1"
            Margin="0,4,0,0"
            HorizontalAlignment="Right"
            VerticalAlignment="Top"
            Orientation="Horizontal"&gt;
    &lt;Button Content="Submit" Margin="0,0,4,0"/&gt;
    &lt;Button Content="Cancel"/&gt;
&lt;/StackPanel&gt;</pre><p class="list-inset">A new <code>Margin</code> attribute has been added to the first button to add some space between the elements.</p></li>				<li>Next, we <a id="_idIndexMarker040"/>will add a <code>Style</code> block to a <code>Grid.Resources</code> section nested inside <code>Grid</code> before all its controls to style the buttons. Because no <code>Key</code> is assigned to the <code>Style</code> block, it will apply to all <code>Button</code> elements that do not have their styles overridden in an inner scope. This is known as an <em class="italic">implicit style</em>. The code for this is shown here:<pre class="source-code">
&lt;Grid.Resources&gt;
    &lt;Style TargetType="Button"&gt;
        &lt;Setter Property="BorderThickness"
                Value="2" /&gt;
        &lt;Setter Property="Foreground"
                Value="LightGray" /&gt;
        &lt;Setter Property="BorderBrush"
                Value="GhostWhite"/&gt;
        &lt;Setter Property="Background"
                Value="DarkBlue" /&gt;
    &lt;/Style&gt;
&lt;/Grid.Resources&gt;</pre></li>				<li>Now, when you run the app, you will see that the new style has been applied to both the <strong class="bold">Submit</strong> and <strong class="bold">Cancel</strong> buttons without adding any styling directly to each control, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B20908_01_07.jpg" alt="Figure 1.7 – Styled buttons"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Styled buttons</p>
			<p>If we moved the <code>Style</code> block to the <code>Application.Resources</code> section in <code>App.xaml</code>, the defined style would get applied to every button in the entire app unless the developer had individually overridden some of the properties in the style. For instance, if the <code>Background</code> property set to <code>DarkGreen</code>, only the <strong class="bold">Cancel</strong> button <a id="_idIndexMarker041"/>would appear as dark blue.</p>
			<p>We will spend more time on styles and design in <a href="B20908_07.xhtml#_idTextAnchor152"><em class="italic">Chapter 7</em></a>, <em class="italic">Fluent Design System for </em><em class="italic">Windows Applications</em>.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Separating presentation from business logic</h2>
			<p>We looked briefly at the MVVM pattern in the earlier section on data binding. MVVM is key to the separation of presentation logic from business logic in WinUI <a id="_idIndexMarker042"/>application development. The XAML elements only need to know that there is a property with a particular name somewhere in its data context. The <code>ViewModel</code> classes have no knowledge of the <code>View</code> (our XAML file).</p>
			<p>This separation provides several benefits. First, <code>ViewModels</code> can be tested independently of the UI. If any WinUI elements are referenced by the system under test, the UI thread is needed. This will cause tests to fail when they’re running on background threads locally or on <a id="_idIndexMarker043"/>a <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) server. See this Microsoft blog post for more information on unit testing WinUI applications: <a href="https://devblogs.microsoft.com/ifdef-windows/winui-desktop-unit-tests/">https://devblogs.microsoft.com/ifdef-windows/winui-desktop-unit-tests/</a>.</p>
			<p>The next benefit of <code>View</code>/<code>ViewModel</code> separation is that businesses with dedicated <code>ViewModels</code>. When it is time to sync up the two, the developer can add the necessary data-binding properties to the XAML, or perhaps the UX designer and developer have already agreed upon the names of the properties in the shared data context. Visual Studio includes another tool geared toward designers in this workflow, called <strong class="bold">Blend for Visual Studio</strong>. Blend was first<a id="_idIndexMarker045"/> released by Microsoft in 2006 as Microsoft Expression Blend, as a tool for designers to create UIs for WPF. Support was later added for other XAML languages such as Silverlight and UWP. Blend is still included with the .NET desktop development workload when installing Visual Studio.</p>
			<p>A final benefit we will discuss here is that a good separation of concerns between any layers of your application will always lead to better maintainability. If there are multiple components involved in a single responsibility or if logic is duplicated in multiple places, this leads to buggy code and unreliable applications. Follow good design patterns, and you will save yourself a lot of work down the road.</p>
			<p>Now that you have a good understanding of the history of UWP applications, it’s time to look at WinUI: what it is, and why it was created.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor031"/>What is WinUI?</h1>
			<p>The WinUI library<a id="_idIndexMarker046"/> is a set of controls and UI components that has been extracted from the Windows SDK and included in the Windows App SDK. After this separation, many controls have been enhanced and others have been added. The Windows App SDK is being developed in the open. Its issues are tracked on GitHub and with input from Microsoft and the Windows developer community.</p>
			<p>So, if these WinUI libraries are based on UWP libraries in the Windows SDK, you may be wondering why you should choose WinUI as your UI framework instead of UWP. UWP has been around since the launch of Windows 10 and is quite robust and stable. There are several very good reasons to consider WinUI.</p>
			<p>Choosing WinUI brings with it many of the benefits<a id="_idIndexMarker047"/> of <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>). OSS is typically very reliable. When software is developed in the open by an active developer community, issues are found and resolved quickly. In fact, if you find an issue with an open source package, you can fix it yourself and submit a pull request to have the fix made available to the rest of the community. Open source projects can iterate quickly without having to remain in sync with product groups in a large enterprise such as the Windows team. Windows releases feature updates at a regular cadence now, but this is still less frequent than with a typical control library. Although the Windows App SDK and WinUI 3 are not yet open source, it is part of the product roadmap.</p>
			<p>The best reason to use <a id="_idIndexMarker048"/>WinUI is its backward compatibility. When using a UWP control, the features and fixes in a specific version of the control cannot be deployed in apps to older versions of Windows. With WinUI, so long as you are targeting the minimum version of Windows supported by WinUI as a whole, you can use those new controls and features in multiple Windows versions. Controls not previously available to UWP developers in one version of Windows are now available there as WinUI controls.</p>
			<p>For instance, Microsoft did not introduce the Fluent UI design to Windows until the Fall 2017 release (version 16299). However, WinUI controls can be included in apps targeting a minimum Windows version of Windows 10, version 1809, the Fall 2019 release. The controls in WinUI support Fluent UI styles. WinUI adds controls and other features that are not available at all in UWP and the Windows SDK.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>The first WinUI release</h2>
			<p>The first version of WinUI<a id="_idIndexMarker049"/> was released in July 2018 as a preview release for Windows developers. It was released as the following two NuGet packages:</p>
			<ul>
				<li><code>Microsoft.UI.Xaml</code>: The WinUI controls and Fluent UI styles</li>
				<li><code>Microsoft.UI.Xaml.Core.Direct</code>: Components for middleware developers to access the <code>XamlDirect</code> API</li>
			</ul>
			<p>3 months later, WinUI 2.0 was released. Despite the version number, it was the first production release of WinUI. The release included more than 20 controls and brushes. A few notable controls included the following:</p>
			<ul>
				<li><code>TreeView</code>: A staple <a id="_idIndexMarker050"/>of any UI library.</li>
				<li><code>ColorPicker</code>: A rich<a id="_idIndexMarker051"/> visual color picker with a color spectrum.</li>
				<li><code>DropDownButton</code>: A <a id="_idIndexMarker052"/>button with the ability to open a menu.</li>
				<li><code>PersonPicture</code>: An image<a id="_idIndexMarker053"/> control for displaying an avatar. It can fall back to displaying initials or a generic placeholder image.</li>
				<li><code>RatingControl</code>: Allows <a id="_idIndexMarker054"/>users to enter star ratings for items.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">WinUI 2.x versions are libraries that are used by UWP projects. WinUI 3 is part of the Windows App SDK and is its own project type, although it shares the same XAML schema as a UWP project.</p>
			<p>Let’s add a few of these<a id="_idIndexMarker055"/> controls to our WinUI project and see how they look. Change the contents of <code>StackPanel</code> to look like this:</p>
			<pre class="source-code">
&lt;StackPanel Grid.Row="1" Grid.Column="1" Margin="0,4,0,0"
            HorizontalAlignment="Right"
            VerticalAlignment="Top"
            Orientation="Horizontal"&gt;
    &lt;PersonPicture Initials="MS" Margin="0,0,8,0"/&gt;
    &lt;DropDownButton Content="Submit" Margin="0,0,4,0"&gt;
        &lt;DropDownButton.Flyout&gt;
            &lt;MenuFlyout Placement="Bottom"&gt;
                &lt;MenuFlyoutItem Text="Submit + Print"/&gt;
                &lt;MenuFlyoutItem Text="Submit + Email"/&gt;
            &lt;/MenuFlyout&gt;
        &lt;/DropDownButton.Flyout&gt;
    &lt;/DropDownButton&gt;
    &lt;Button Content="Cancel"/&gt;
&lt;/StackPanel&gt;</pre>			<p>A <code>PersonPicture</code> control <a id="_idIndexMarker056"/>with the initials <code>MS</code> has been added as the first item in <code>StackPanel</code>, and the first of the two buttons has been replaced by a <code>DropDownButton</code> control. The <code>DropDownButton</code> control has a <code>FlyoutMenu</code> serving as a drop-down list, and there are two <code>MenuFlyoutMenuItem</code> elements. Now, users can simply click the <code>DropDownButton</code> menu shown:</p>
			<div><div><img src="img/B20908_01_08.jpg" alt="Figure 1.8 – Adding a PersonPicture and DropDownButton control"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Adding a PersonPicture and DropDownButton control</p>
			<p>We’re only scratching the surface of what WinUI can do for Windows developers. Don’t worry, as we will dive much deeper in the chapters ahead. Let’s briefly look at what was added in subsequent versions before WinUI 3.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>The road to WinUI 3</h2>
			<p>There have been five additional minor releases of WinUI following version 2.0, in addition to many incremental bug fixes and pre-release versions.</p>
			<h3>WinUI 2.1</h3>
			<p>The WinUI 2.1 <a id="_idIndexMarker057"/>release brought several new controls and features to the library. These are some highlights:</p>
			<ul>
				<li><code>TeachingTip</code>: Think of <code>TeachingTip</code> as a rich, context-sensitive tooltip. It is linked to another element on the <a id="_idIndexMarker058"/>page and displays informative details <a id="_idIndexMarker059"/>about the target element to help guide users with non-intrusive content as needed.</li>
				<li><code>AnimatedVisualPlayer</code>: This<a id="_idIndexMarker060"/> hosts Lottie<a id="_idIndexMarker061"/> animations. Lottie files are a popular animation format created in <strong class="bold">Adobe After Effects</strong> used by<a id="_idIndexMarker062"/> designers across Windows, the web, and mobile platforms. There are libraries available to host Lottie animations for most modern development frameworks.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Get more information about Lottie files<a id="_idIndexMarker063"/> on their website at <a href="https://airbnb.design/lottie/">https://airbnb.design/lottie/</a> and check out this great repository of Lottie animation<a id="_idIndexMarker064"/> files: <a href="https://lottiefiles.com/">https://lottiefiles.com/</a>.</p>
			<ul>
				<li><code>CompactDensity</code>: Adding <a id="_idIndexMarker065"/>this resource dictionary to your app can provide the ability to switch between <em class="italic">Compact</em> and <em class="italic">Normal</em> display <a id="_idIndexMarker066"/>modes. <code>CompactDensity</code> will reduce the spacing within and between elements on the page, providing up to 33% more visible content to users. This Fluent UI design concept was introduced to developers at Microsoft’s Build 2018 conference.</li>
			</ul>
			<h3>WinUI 2.2</h3>
			<p>This release brought <a id="_idIndexMarker067"/>many enhancements to existing features. However, the single new control added to the library is one that many Windows developers will find useful.</p>
			<p>The <code>TabView</code> control <a id="_idIndexMarker068"/>creates a familiar tabbed UX on the screen. Each tab can <a id="_idIndexMarker069"/>host a page in your WinUI project.</p>
			<h4>WinUI 2.2 enhancements</h4>
			<p>A few of the notable updated controls and libraries in version 2.2 are listed here:</p>
			<ul>
				<li><code>NavigationView</code> control was enhanced to allow the back button to remain <a id="_idIndexMarker070"/>visible when the panel is collapsed. Other visual <a id="_idIndexMarker071"/>updates maximize the viewable content of the control.</li>
				<li><code>CornerRadius</code>, <code>BorderThickness</code>, <code>CheckBox</code>, and <code>RadioButton</code>. The updates all make the WinUI visuals more consistent and in line with Fluent UI design guidelines.</li>
			</ul>
			<h3>WinUI 2.3</h3>
			<p>In the<a id="_idIndexMarker073"/> WinUI 2.3 release, <code>ProgressBar</code> received some updates, and a couple of new controls were added to the library.</p>
			<p>There are now two modes available when creating a <code>ProgressBar</code> element in a WinUI application: <strong class="bold">determinate</strong> and <strong class="bold">indeterminate</strong>. A determinate progress bar has a known amount of the task to complete and a known current state of the task. An indeterminate control indicates that a task is ongoing without a known completion time. Its purpose is like that of a busy indicator.</p>
			<h4>New controls in WinUI 2.3</h4>
			<p>The following are a few new controls in this update:</p>
			<ul>
				<li><code>NumberBox</code>: A <code>NumberBox</code> control<a id="_idIndexMarker074"/> is an input editor that makes it easy<a id="_idIndexMarker075"/> to support numeric formatting, up/down incrementing buttons, and inline mathematic calculations. It is a seemingly simple but practical and powerful control.</li>
				<li><code>RadioButtons</code>: You <a id="_idIndexMarker076"/>might be thinking, <em class="italic">radio buttons have always been available. How is this a new control?</em> <code>RadioButtons</code> is a <a id="_idIndexMarker077"/>control that groups a set of <code>RadioButton</code> (<em class="italic">singular</em>) controls, making it easier to work with them as a single unit.</li>
			</ul>
			<h3>WinUI 2.4</h3>
			<p>When it was released <a id="_idIndexMarker078"/>in May 2020, two new features were made available in WinUI 2.4: a <code>RadialGradientBrush</code> visual and a <code>ProgressRing</code> control.</p>
			<p>The brush is <a id="_idIndexMarker079"/>similar in use to the <code>RadialGradientBrush</code> used by WPF developers. It makes it easy to add a gradient to a visual element that radiates out <a id="_idIndexMarker080"/>from a central point.</p>
			<p>The <code>ProgressRing</code> control, as it<a id="_idIndexMarker081"/> sounds, recreates progress bar functionality <a id="_idIndexMarker082"/>in a circular format. The control is available with a determinate state and an indeterminate state in version 2.4. An indeterminate <code>ProgressRing</code> control displays a repeating animation and is the default state of the control.</p>
			<p>Several controls were updated in version 2.4. The <code>TabView</code> control was updated to provide more control over how tabs are rendered, including <code>TextBox</code> controls received a <em class="italic">dark mode</em> enhancement to keep the content area of the control dark, with white text by default. Finally, the <code>NavigationView</code> control was updated with hierarchical navigation, with <code>Left</code>, <code>Top</code>, and <code>LeftCompact</code> modes.</p>
			<h3>WinUI 2.5</h3>
			<p>WinUI 2.5 was <a id="_idIndexMarker083"/>released in December 2020 and included a new <code>InfoBar</code> control. Several control enhancements and bug fixes were also included in the release.</p>
			<p>The <code>InfoBar</code> control<a id="_idIndexMarker084"/> provides a way to display important status <a id="_idIndexMarker085"/>messages to users. The control can display an alert or informational icon, a status message, and a link or button allowing users to act on a message. There is also an option to display a close button to the right of the message. By default, the control includes an icon, message, and close button. Microsoft Learn provides usage guidelines for this new control. This is the documentation for the WinUI 3 version of the control: <a href="https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.infobar">https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.infobar</a>.</p>
			<p>Several <a id="_idIndexMarker086"/>updates are also available in version 2.5. The <code>ProgressRing</code> control<a id="_idIndexMarker087"/> received enhancements to the determinate state of the control. The <code>NavigationView</code> control<a id="_idIndexMarker088"/> was updated to provide customizable <code>FooterMenuItems</code>. In previous versions <a id="_idIndexMarker089"/>of the <code>NavigationView</code> control, the footer area could be shown or hidden but not customized.</p>
			<p>WinUI 2.x continued adding controls and features in versions 2.6, 2.7, and 2.8. For a complete listing of the new features in each version, see the following release notes pages on Microsoft Learn:</p>
			<ul>
				<li>WinUI 2.6<a id="_idIndexMarker090"/> release notes: <a href="https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.6&#13;">https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.6</a></li>
				<li>WinUI 2.7 <a id="_idIndexMarker091"/>release notes: <a href="https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.7&#13;">https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.7</a></li>
				<li>WinUI 2.8<a id="_idIndexMarker092"/> release notes: <a href="https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.8&#13;">https://learn.microsoft.com/windows/apps/winui/winui2/release-notes/winui-2.8</a></li>
			</ul>
			<p>We’ve seen what was available to UWP developers in WinUI 2. Now, let’s see what you get with WinUI 3 and the Windows App SDK.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>What’s new in WinUI 3?</h1>
			<p>Unlike WinUI 2.0 and the<a id="_idIndexMarker093"/> incremental versions that followed, WinUI 3 is a major update featuring more than new and improved controls and libraries to use with Windows desktop apps. In fact, the primary goal of WinUI 3 was not to add new controls and features beyond its current UWP counterparts. The Windows App SDK team has made WinUI a complete UI framework that can sit atop the Windows desktop .NET platform.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Goodbye UWP?</h2>
			<p>So, what is happening to UWP? Will our UWP apps stop working?</p>
			<p>As previously<a id="_idIndexMarker094"/> mentioned, the plan for the UWP UI libraries is to keep providing important security updates, but they will not receive any new features going forward. It is likely that WinUI 2.8 will be the final 2.x version. All new features and updates will be developed for WinUI and the Windows App SDK. New applications will be developed in WinUI with either .NET, written in C# or VB, or with native C++. These clients will sit on top of the Win32 platform. This is all possible because the Windows App SDK is developed completely in C++.</p>
			<p>The fact that it is developed in C++ <a id="_idIndexMarker095"/>enables <strong class="bold">React Native for Windows</strong> client apps to interoperate with the Windows App SDK platform. Between React Native and Uno Platform, WinUI has some great cross-platform potential.</p>
			<p>There will be multiple paths available for developers to create apps for Windows PCs and tablet devices. Other Windows devices, such as Xbox and HoloLens, will need to continue to develop UWP apps and use WinUI 2.x controls.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>New features for WinUI 3 and the Windows App SDK</h2>
			<p>Are there any new features in WinUI 3?</p>
			<p>While it sounded like the team was very busy creating a UI framework to replace the UWP UI libraries, they did find some time to add a few new features. The major new control available in WinUI 3 is the new <code>WebView2</code> control. It is a web browser host control based on the new<a id="_idIndexMarker096"/> Chromium-based <strong class="bold">Microsoft Edge</strong> browser. Compatibility is also a feature. All XAML and Composition features available in the Spring 2019 Windows SDK will be backward-compatible, back to the Windows 10 1809 update and later.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>The Windows App SDK and WinUI</h2>
			<p>WinUI 3 is bringing desktop application developers together on a single set of UI libraries, but that is only the beginning. At Microsoft’s Build 2020 conference, the Windows team announced <strong class="bold">Project Reunion</strong>, a<a id="_idIndexMarker097"/> long-term plan to bring all Windows developers together on a single platform. When WinUI was released in 2021, Project Reunion was renamed the Windows App SDK. WinUI 3 is focused on the UI layer, while the Windows App SDK will encompass WinUI and the entire Windows developer platform. In 2021, Microsoft released three versions of the Windows App SDK and <a id="_idIndexMarker098"/>WinUI 3.</p>
			<p>To read more about the Windows App SDK and to follow its progress, you can check out the team’s GitHub repository at <a href="https://github.com/microsoft/WindowsAppSDK">https://github.com/microsoft/WindowsAppSDK</a>. Now, let’s see how WinUI compares to other Windows development frameworks.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>WinUI 3 compared to other Windows development frameworks</h1>
			<p>Where does WinUI fit into the overall landscape of Microsoft’s Windows development frameworks? Let’s draw some comparisons to help answer that question, starting with those that are most like WinUI.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>WinUI versus UWP</h2>
			<p>This is a tricky<a id="_idIndexMarker099"/> comparison because<a id="_idIndexMarker100"/> WinUI apps today share the same XAML schema as UWP apps. In fact, WinUI 2.x are controls for UWP applications. They share the same XAML schema, base visuals, and underlying Windows APIs. Any UWP app that has the same minimum and target versions of Windows specified can add the WinUI 2.x libraries to leverage the new and updated features. However, UWP will not receive any feature updates beyond WinUI 2.8. Only security and bug-fix updates will be released as 2.8x minor releases.</p>
			<p>A key difference between apps that use WinUI versus traditional UWP apps is access to new and updated controls and other visual elements without requiring an updated Windows SDK. This enables developers to bring apps with the same look and features to more users across multiple versions of Windows 10 or Windows 11. This differentiator makes for happier developers and users.</p>
			<p>WinUI 3 also has the advantage of using the latest .NET version and C# language features. It will continue to benefit from these as new versions of .NET are released. As true .NET desktop apps, they are not constrained by the UWP sandbox. They have full access to hardware and the filesystem and can use most APIs. WinUI 3 apps also have more control over their Window size and appearance than UWP apps. However, developers who want to target platforms such as HoloLens or Xbox must stick with UWP development.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>WinUI versus WPF</h2>
			<p>WinUI and WPF have many similarities. Both <a id="_idIndexMarker101"/>are application frameworks, and both types of apps rely on XAML to define UI elements. This means that they both offer the same separation of UI and business logic when implementing the MVVM pattern. WPF XAML has the same concepts of styles, resources, data binding, and adaptiveness as the UI layout.</p>
			<h3>WinUI advantages</h3>
			<p>A significant performance <a id="_idIndexMarker102"/>advantage of <a id="_idIndexMarker103"/>WinUI is the availability of <code>x:Bind</code> syntax in XAML, rather than <code>Binding</code>.</p>
			<p>Unless your WinUI app is MSIX-packaged with <code>uap10:TrustLevel="appContainer"</code>, both WinUI and WPF have full access to users’ filesystems and devices. Their access is only limited by the configuration of <strong class="bold">Windows User Account Control</strong> (<strong class="bold">UAC</strong>) on <a id="_idIndexMarker104"/>the PC. WinUI has the advantage of using GPU-accelerated features such as Mica and Acrylic brushes to support the latest Windows styles such as Microsoft’s in-box apps. These styles are not available to WPF apps, making them feel less modern.</p>
			<h3>WPF advantages</h3>
			<p>The primary advantage <a id="_idIndexMarker105"/>of WPF applications is the fact that they are not directly tied to minimum versions of Windows. WPF apps target a .NET version. Any version of Windows that supports the target .NET version can run that WPF app. This significantly increases the potential user base of WPF apps. In fact, WPF apps can be deployed and run on Windows 7 with .NET Framework, something not possible with UWP or WinUI.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is a product called <strong class="bold">Uno Platform</strong> that <a id="_idIndexMarker106"/>enables WinUI XAML to run on iOS, Android, macOS, Linux, and even Samsung Tizen watches, and on the web with <strong class="bold">WebAssembly</strong>. These <a id="_idIndexMarker107"/>WinUI web apps can run in the browser on previous versions of Windows, including Windows 7. The Uno Platform goal and tagline is <em class="italic">WinUI Everywhere</em>.</p>
			<p class="callout">Learn more about Uno<a id="_idIndexMarker108"/> Platform at <a href="https://platform.uno/">https://platform.uno/</a>. We will create an Uno Platform project in <a href="B20908_13.xhtml#_idTextAnchor570"><em class="italic">Chapter 13</em></a>, <em class="italic">Taking Your App Cross-Platform with </em><em class="italic">Uno Platform</em>.</p>
			<p class="callout">Learn more about <a id="_idIndexMarker109"/>WebAssembly at <a href="https://webassembly.org/">https://webassembly.org/</a>.</p>
			<p>A new WPF advantage <a id="_idIndexMarker110"/>emerged with the releases of .NET Core 3.x and .NET 5 and later. .NET developers can now create WPF apps with .NET Core, bringing performance and deployment advantages of the modern .NET to WPF developers. For instance, applications targeting different versions of .NET can be deployed side by side on a machine without creating version conflicts. However, as mentioned previously, WinUI 3 apps also leverage the latest .NET features and performance.</p>
			<p>The difference in deployment models can be debated as to which framework has an advantage. The easiest way to deploy a WinUI app is through the Microsoft Store. The easiest way to deploy a WPF app with .NET is via an installer package. WPF apps can be deployed through the Store by adding a Windows MSIX packaging project, and WinUI apps can be <a id="_idIndexMarker111"/>deployed without the Store with MSIX installers or <strong class="bold">Windows Package Manager</strong>. WinUI deployment will be covered in detail in <a href="B20908_14.xhtml#_idTextAnchor582"><em class="italic">Chapter 14</em></a>, <em class="italic">Packaging and Deploying </em><em class="italic">WinUI Applications</em>.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>WinUI versus Windows Forms (WinForms)</h2>
			<p>WinForms is a .NET UI<a id="_idIndexMarker112"/> framework that was introduced with .NET Framework 1.0. Developers can easily create a WinForms UI with the visual design surface in Visual Studio, which generates C# or VB code that creates the UI at runtime. Most of the<a id="_idIndexMarker113"/> advantages and disadvantages of WPF also apply to WinForms: security, deployment, and .NET—WinForms apps can also be created with .NET Core 3.x and later.</p>
			<h3>WinUI advantages</h3>
			<p>Similarities between WinUI and <a id="_idIndexMarker114"/>WPF are their primary advantages over WinForms: data binding, adaptive layout, and a flexible styling model. These advantages all stem from the use of XAML for UI layout. Another advantage of XAML is offloading render processing from<a id="_idIndexMarker115"/> the <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) to the <strong class="bold">graphics processing unit</strong> (<strong class="bold">GPU</strong>). WinUI controls inherit the Windows styles by default and have a <a id="_idIndexMarker116"/>more modern appearance than WinForms controls. WinUI applications also handle <strong class="bold">dots per inch</strong> (<strong class="bold">DPI</strong>) scaling<a id="_idIndexMarker117"/> and touch input well. The WinForms UI framework matured before touch input and DPI scaling were a concern for Windows developers. Localization and UI performance are also big advantages of WinUI 3 over WinForms.</p>
			<h3>WinForms advantages</h3>
			<p>In addition to the advantages<a id="_idIndexMarker118"/> that WinForms shares with WPF over WinUI—greater access to Windows, .NET app, and Windows compatibility—WinForms also has a well-deserved reputation for rapid UI development. If you need to create a simple Windows application in a minimal amount of time, the drag-and-drop WinForms designer is easy and intuitive. WinForms has also received some recent updates to improve its data binding support, and it now has ICommand support for MVVM. For more information about these enhancements, see this .NET blog post: <a href="https://devblogs.microsoft.com/dotnet/winforms-cross-platform-dotnet-maui-command-binding/">https://devblogs.microsoft.com/dotnet/winforms-cross-platform-dotnet-maui-command-binding/</a>.</p>
			<p>Many experienced Windows developers still default to WinForms when tasked with creating a simple utility or UI test harness for a .NET library.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/>Summary</h1>
			<p>We covered a lot of the history of Windows application development in this chapter. We learned about the origins of UWP and its roots in Windows 8 apps and learned of the benefits of XAML when building Windows UIs. We had a taste of what some simple WinUI app code and UIs look like. Finally, we examined the recent history of WinUI versions and how WinUI 3 is a complete replacement for the UWP UI libraries and a viable option for WPF developers going forward.</p>
			<p>This will give you a good foundation of what’s to come as we start building an app with WinUI in the chapters ahead. In the next chapter, you will set up your development environment, learn about the app project that we will create throughout the book, and create your first WinUI 3 project. When we get to <a href="B20908_03.xhtml#_idTextAnchor073"><em class="italic">Chapter 3</em></a>, <em class="italic">MVVM for Maintainability and Testability</em>, we will refactor the app to use the MVVM pattern. This will set us up with a solid, maintainable design as we later add to and extend the app throughout the rest of the book.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>Questions</h1>
			<ol>
				<li>Which version of Windows first introduced UWP apps to developers?</li>
				<li>What is the name of the pattern commonly used by WinUI and other XAML developers to separate the UI logic from the business logic?</li>
				<li>WinUI and WPF apps can share the same XAML. True or false?</li>
				<li>Which was the first Microsoft UI framework to use XAML to define the UI?</li>
				<li>What was the version number of the first WinUI release?</li>
				<li>What is one of the benefits of developing with WinUI over WinForms?</li>
				<li>Can WinUI apps only be developed with .NET languages?</li>
				<li>Challenge: create a style that will apply to <code>Button</code> elements.</li>
			</ol>
		</div>
	</body></html>