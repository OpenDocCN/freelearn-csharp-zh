<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor297"/>10</h1>
<h1 class="chapterTitle" id="_idParaDest-202"><a id="_idTextAnchor298"/>Security and Observability for Serverless and Microservices Applications</h1>
<p class="normal">There are studies that indicate that cybercrime can be considered the third economy in the world. Besides that, the investment made in many companies in cyber security has increased a lot in the last few years. When we talk about serverless and microservices, we cannot ignore this topic. In fact, the area of attack of a distributed system is bigger than a simple monolith application.</p>
<p class="normal">Considering this challenging scenario, security and observability cannot be discussed in a single moment of the development process. The approach of security and privacy by design indicates that you will only achieve success and reduce risk in cyber security if you start thinking about it just after you start thinking about your solution. </p>
<p class="normal">The goal of this chapter is to discuss how to secure applications, enable monitoring for both performance and security, and improve incident response, considering the tools and techniques we currently have.</p>
<h1 class="heading-1" id="_idParaDest-203"><a id="_idTextAnchor299"/>Application Security Best Practices</h1>
<p class="normal">A good approach to <a id="_idIndexMarker822"/>thinking about security in an application is to define it as an onion – with different layers of protection. The most important thing about any application is the data that is stored and processed by it. Considering this, the databases of an application must be designed to have the correct access and protection. However, securing the database is not enough to deliver a good solution, so you must also think about the security of the application itself, defining authentication and authorization for any user who will access it. Besides that, you need to understand that your application will probably use third-party components that must also be protected. Infrastructure also needs to be monitored and secure, and there are sophisticated ways to do so nowadays. Last, but not least, there are alternative solutions that can monitor our applications by intercepting the traffic that arrives at it, guaranteeing<a id="_idIndexMarker823"/> another layer of security. Let’s check each layers of security in detail.</p>
<h2 class="heading-2" id="_idParaDest-204"><a id="_idTextAnchor300"/>Network Security</h2>
<p class="normal">It can be a little<a id="_idIndexMarker824"/> confusing for developers to think about managing a<a id="_idIndexMarker825"/> network in the cloud, since you might imagine that any resource provided must be public. The point is exactly this – we cannot consider any component as public when we are using public cloud providers. To do so, you must design a proper network that will safeguard applications. For this, a <strong class="keyWord">Virtual Private Cloud (VPC)</strong> must be provided.</p>
<p class="normal">A VPC provides a <a id="_idIndexMarker826"/>logically isolated section within a public cloud, where you can launch resources in a virtual network that you define. This isolation ensures that your resources are protected from external threats and unauthorized access. The focus of this is to reduce the attack surface.</p>
<p class="normal">With VPC configurations, you will have fine-grained network control. By defining subnets, route tables, and network gateways, you can control the flow of traffic to and from your serverless functions and microservices. With this, only trusted sources can access your resources, and only exactly what you want will be exposed to the public internet.</p>
<p class="normal">When you think about microservices, there is no direct need to have them exposed to the internet. So, this protection is crucial for sensitive data and critical applications, minimizing the risk of external attacks.</p>
<p class="normal">In Azure, there are two great services that can help you set the private architecture of your subsystems, guaranteeing that only the surfaces that really need to be exposed. The first one is Azure Virtual Network, which is the component that will enable you to design a VPC according to the configuration you decide. The second one is Azure Private Link, which will enable your services to connect over a private endpoint in a virtual network. This will give you the opportunity to reduce the need to expose a service to the public internet, using the Microsoft backbone network to do so.</p>
<p class="normal">Obviously, if you have a better network design, you will be able to monitor and protect your solution with more efficiency. For instance, you can define Azure network security groups to define specific rules according to a group. You have the option of monitoring the traffic of the network by enabling Virtual Network flow logs. You can also define inbound and outbound traffic and prohibitions using Azure Firewall. In summary, Azure Virtual Network and its components are a powerful tool for securing communication between services in the cloud, ensuring <a id="_idIndexMarker827"/>data <a id="_idIndexMarker828"/>confidentiality, integrity, and availability. </p>
<h2 class="heading-2" id="_idParaDest-205"><a id="_idTextAnchor301"/>Data Security</h2>
<p class="normal">The data that <a id="_idIndexMarker829"/>arrives at a database generally comes from a user or a<a id="_idIndexMarker830"/> system. This means that the transmission of this data needs to be guaranteed, and we must consider ways to protect the interception and eventual changing of this data. The best way to do so is to encrypt data from the client to the server. <strong class="keyWord">Hyper Text Transfer Protocol Secure (HTTPS) </strong>is the<a id="_idIndexMarker831"/> alternative that, generally, all web servers use to do so. Together with<a id="_idIndexMarker832"/> the <strong class="keyWord">Transport Layer Security (TLS)</strong> protocol, we enable a secure channel to transfer data.</p>
<p class="normal">In a function app, for instance, HTTPS is the only protocol accepted by default. This means that any HTTP (which is not secure) request will be redirected to HTTPS, providing better security for the transfer of data. You can check it in the configuration of App Service.</p>
<p class="packt_figref"><img alt="" role="presentation" src="img/B31916_10_01.png"/> Figure 10.1: HTTPS Only in App Service</p>
<p class="normal">Besides that, you may also want to increase the security of this transfer layer by defining a specific certificate for your service. In Azure, you can do this by defining a domain for your app.</p>
<p class="normal">By default, Azure delivers to you a certificate created by Microsoft, where the domain used is azurewebsites.net. However, you can buy a custom domain outside Azure, or even inside it, which is much easier to manage.</p>
<div><p class="normal"> Custom domains will represent a cost to your Azure account. You can get more details about custom domains at <a href="https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate">https://learn.microsoft.com/en-us/azure/app-service/tutorial-secure-domain-certificate</a></p>
</div>
<p class="normal">In the same way as you need to secure the transfer layer, you must secure your environment variables and secrets. Azure provides three services to do so. The first one is called <strong class="keyWord">Azure Managed Identities</strong> and it<a id="_idIndexMarker833"/> will let you access data in Azure SQL, Cosmos DB, Azure Storage, and so on without the need for a credential. On the other hand, if you do need to manage variables and secrets, <strong class="keyWord">Azure Key Vault</strong> is the <a id="_idIndexMarker834"/>correct service to store client application secrets, connection strings, passwords, shared access keys, and SSH keys. However, access to Azure Key Vault may cause performance issues for the application’s startup. That is why you should<a id="_idIndexMarker835"/> use <strong class="keyWord">Azure App Configuration</strong> to store non-secrets, such as client IDs, endpoints, and application parameters.</p>
<p class="normal">Another important resource that you must consider while protecting data is the options you have for data encryption in the database service. For instance, in SQL databases, there is the possibility <a id="_idIndexMarker836"/>to <a id="_idIndexMarker837"/>use<a id="_idIndexMarker838"/> the <strong class="keyWord">Transparent data encryption</strong> setting.</p>
<figure class="mediaobject"><img alt="Figure 10.2: Transparent data encryption setting" src="img/B31916_10_02.png"/></figure>
<p class="packt_figref">Figure 10.2: Transparent data encryption setting</p>
<p class="normal">With this setting, you will prevent situations where a stolen database file can be restored on a different server from yours. Besides that, in general, database servers also<a id="_idIndexMarker839"/> have <strong class="keyWord">firewall rules</strong> that will restrict direct <a id="_idIndexMarker840"/>access to them, which is a very important approach to not expose the database server to the public cloud.</p>
<h2 class="heading-2" id="_idParaDest-206"><a id="_idTextAnchor302"/>Authentication and Authorization</h2>
<p class="normal">When you are creating an <a id="_idIndexMarker841"/>application, it is essential that you know the actor that will access it. To do so, you must provide an <strong class="keyWord">authentication</strong> method, that<a id="_idIndexMarker842"/> is, the process of verifying the identity of a user or system, ensuring that the entity requesting access is indeed who or what it claims to be. To do so, you must use credentials such as passwords, tokens, or biometric data. </p>
<p class="normal">Once you have the user or system identified, there is another process that will let this actor access resources or execute activities in the system you are designing. The process that enables it is<a id="_idIndexMarker843"/> called <strong class="keyWord">authorization</strong>.</p>
<p class="normal">There are some alternatives to deliver authentication and authorization. We will discuss three of them in this topic: <strong class="keyWord">JSON Web Tokens (JWTs)</strong>, OAuth 2.0, and OpenID Connect. They are useful techniques to <a id="_idIndexMarker844"/>provide access to websites and APIs, guaranteeing security for the system you are designing.</p>
<h3 class="heading-3" id="_idParaDest-207"><a id="_idTextAnchor303"/>JSON Web Tokens</h3>
<p class="normal">JSON Web Token (JWT) enables security <a id="_idIndexMarker845"/>between the client and the server using <a id="_idIndexMarker846"/>an encoded JSON object, called a token, that is transferred in the HTTP header in a compact and stateless format. The token is created by the server as it verifies the authentication of the requestor. The authorization is given to ensure that the requestor can access the resources. JWTs pertain to industry standard RFC 7519.</p>
<p class="normal">The code provided in the chapter will give you an idea about how to implement JWTs using .NET. It is worth noting that this code is not ready for use, since the authentication method is not resolved. </p>
<pre class="programlisting code"><code class="hljs-code">public class JWT
{
  // Private field to store the JWT token
  private JwtSecurityToken token;
  // Internal constructor to initialize the JWT with a given token
  internal JWT(JwtSecurityToken token)
  {
    this.token = token;
  }
  // Property to get the expiration date and time of the token
  public DateTime ValidTo =&gt; token.ValidTo;
  // Property to get the string representation of the token
  public string Value =&gt; 
    new JwtSecurityTokenHandler().WriteToken(this.token);
}
internal class JWTBuilder 
{
  public JWT  Build() // Method to build the JWT. JWT is an object 
{
    var claims = new List&lt;Claim&gt; // Creating a list of claims
    {
       new Claim(JwtRegisteredClaimNames.Sub,this.subject), 
       new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) 
    }.Union(this.claims.Select(item =&gt; new Claim(item.Key, item.Value))); 
    var token = new JwtSecurityToken( 
      issuer: this.issuer, 
      audience: this.audience, 
      claims: claims, 
      expires: DateTime.UtcNow.AddMinutes(expiryInMinutes), 
      signingCredentials: new SigningCredentials( 
        this.securityKey, 
        SecurityAlgorithms.HmacSha256) 
    );
    return new JWT(token);
  }
}
</code></pre>
<p class="normal">The <code class="inlineCode">Build</code> method in the <code class="inlineCode">JWTBuilder</code> class is responsible for constructing a JWT based on the properties and claims that have been configured in the builder. A <code class="inlineCode">List&lt;Claim&gt;</code> is initialized with two default claims: (1) <code class="inlineCode">sub</code> (subject), which represents the subject of the token; (2) <code class="inlineCode">jti</code> (JWT ID), a unique identifier for the token, generated using <code class="inlineCode">Guid.NewGuid()</code>. Additional claims from the claims dictionary <a id="_idIndexMarker847"/>are appended<a id="_idIndexMarker848"/> using <strong class="keyWord">Union</strong>. Each key-value pair in the dictionary is converted into a Claim <a id="_idIndexMarker849"/>object. A <code class="inlineCode">JwtSecurityToken</code> object is created with the following parameters:</p>
<ul>
<li class="bulletList"><strong class="keyWord">issuer</strong>: The entity that issued the token.</li>
<li class="bulletList"><strong class="keyWord">audience</strong>: The intended recipient of the token.</li>
<li class="bulletList"><strong class="keyWord">claims</strong>: The list of claims created earlier.</li>
<li class="bulletList"><strong class="keyWord">expires</strong>: The expiration time, calculated as the current UTC time plus the configured <code class="inlineCode">expiryInMinutes</code>.</li>
<li class="bulletList"><strong class="keyWord">signingCredentials</strong>: Specifies how the token is signed. It uses the provided <code class="inlineCode">securityKey</code> and the <code class="inlineCode">HmacSha256</code> algorithm.</li>
</ul>
<p class="normal">The method wraps the <code class="inlineCode">JwtSecurityToken</code> in a custom <code class="inlineCode">JWT</code> object and returns it. The <code class="inlineCode">JWT</code> class provides additional properties like <code class="inlineCode">ValidTo</code> (expiration time) and <code class="inlineCode">Value</code> (string representation of the token).</p>
<p class="normal">As soon as the client requestor receives the token, it can be encapsulated in the following requests to the server as authorization header information using the <a id="_idIndexMarker850"/>prefix <strong class="keyWord">Bearer</strong>. The server, when it receives this header information, implements middleware software that analyzes whether the request is appropriate for the requester. The great thing about it is that if the request path is protected by the JWT process, and the request sent does not have the proper token, the request does not arrive at the server for processing, only being processed by the middleware.</p>
<p class="normal">In the example presented in the chapter, you will find two APIs. The first one gives you a token for usage. The second one is the WeatherForecast API generally available when you create an API app using .NET. To<a id="_idIndexMarker851"/> make better use of the example, the Swagger documentation was implemented.</p>
<figure class="mediaobject"><img alt="Figure 10.3: JWT Swagger implementation " src="img/B31916_10_03.png"/></figure>
<p class="packt_figref">Figure 10.3: JWT Swagger implementation </p>
<p class="normal">If you try to run the WeatherForecast API <a id="_idIndexMarker852"/>without delivering a Bearer token, the response will be refused with a 401 error code, which means unauthorized. On the other hand, if you use the Token API to generate the token needed and use this token for authorization with the padlock icon available in the Swagger interface, the result of the API will be properly delivered.</p>
<figure class="mediaobject"><img alt="Figure 10.4: Defining the Bearer token" src="img/B31916_10_04.png"/></figure>
<p class="packt_figref">Figure 10.4: Defining the Bearer token</p>
<p class="normal">Notice that the token provided respects the JWT standard and can be checked on the jwt.io web page, confirming what you defined in your solution.</p>
<figure class="mediaobject"><img alt="Figure 10.5: Decoding JWT on the jwt.io web page" src="img/B31916_10_05.png"/></figure>
<p class="packt_figref">Figure 10.5: Decoding JWT on the jwt.io web page</p>
<p class="normal">Based on the <a id="_idIndexMarker853"/>sample provided, you may consider JWT as a good way to<a id="_idIndexMarker854"/> implement a standard method for <strong class="keyWord">Authorization</strong>.</p>
<h3 class="heading-3" id="_idParaDest-208"><a id="_idTextAnchor304"/>OAuth 2.0 and OpenID Connect (OIDC)</h3>
<p class="normal">OAuth 2.0 is an<a id="_idIndexMarker855"/> open standard that <a id="_idIndexMarker856"/>enables third-party<a id="_idIndexMarker857"/> providers <a id="_idIndexMarker858"/>to give applications <strong class="keyWord">Authorization</strong> to access user resources without exposing their credentials. There are many great providers that enable you to use this technique, such as Google, Microsoft, Facebook, and GitHub.</p>
<p class="normal">The simple use of logins with passwords for authorization is considered too risky for enterprises nowadays. Besides that, transferring this kind of data via APIs is also very dangerous, considering the potential cyberattacks that we need to deal with currently. For this reason, <strong class="keyWord">OpenID Connect (OIDC)</strong> is a good option for <strong class="keyWord">Authentication</strong>, since it enables the confirmation of a user’s existence without exposing passwords.</p>
<p class="normal">To do so, there are three important things to consider. The first one is that this is also an open standard, which means that we have many servers offering this service. The second one is that you will need to consider the usage of a third-party service, so the definition of a good provider must be considered. The third, but not less important, is that OIDC is implemented above OAuth 2.0, which means that, with it, you will have an entire solution for authentication and authorizing your users. </p>
<p class="normal">In .NET, we have the possibility to use OAuth 2.0 and OIDC based on the <strong class="keyWord">Microsoft Authentication Library (MSAL)</strong>. To<a id="_idIndexMarker859"/> do so using Azure, you first need to register an app in Microsoft Entra ID.</p>
<figure class="mediaobject"><img alt="Figure 10.6: Registering an App in Microsoft Entra ID" src="img/B31916_10_06.png"/></figure>
<p class="packt_figref">Figure 10.6: Registering an App in Microsoft Entra ID</p>
<p class="normal">Depending on the type of project you are developing, you will have different ways to get the authentication<a id="_idIndexMarker860"/> of the<a id="_idIndexMarker861"/> users you want. The following code <a id="_idIndexMarker862"/>gets <a id="_idIndexMarker863"/>the user profile in a console app, based on a prompt that will redirect the user to the browser.</p>
<pre class="programlisting code"><code class="hljs-code">private static async Task GetUserProfile()
{
  IPublicClientApplication clientApp = PublicClientApplicationBuilder
    .Create(clientId)
    .WithRedirectUri(redirectUri)
    .WithAuthority(AzureCloudInstance.AzurePublic, "common")
    .Build();
  var resultadoAzureAd = await clientApp.AcquireTokenInteractive(scopes)
    .WithPrompt(Prompt.SelectAccount)
    .ExecuteAsync();
  if (resultadoAzureAd != null)
  {
    // Print the username of the authenticated user
    Console.WriteLine("User: " + resultadoAzureAd.Account.Username);
  }
}
</code></pre>
<p class="normal">The result will be the need to log in using Microsoft. In this case, OIDC is using Microsoft Entra ID as the provider to identify the user.</p>
<figure class="mediaobject"><img alt="Interface gráfica do usuário, Aplicativo  O conteúdo gerado por IA pode estar incorreto." src="img/B31916_10_07.png"/> </figure>
<p class="packt_figref">Figure 10.7: Log in using Microsoft Entra ID</p>
<p class="normal">Once you are<a id="_idIndexMarker864"/> logged<a id="_idIndexMarker865"/> in, Microsoft will ask if you allow <a id="_idIndexMarker866"/>it <a id="_idIndexMarker867"/>to share information about your account with the desired application.</p>
<figure class="mediaobject"><img alt="Figure 10.8: Authorizing app to read your data" src="img/B31916_10_08.png"/></figure>
<p class="packt_figref">Figure 10.8: Authorizing app to read your data</p>
<p class="normal">There are two great things when you use this approach. The first one is that you don’t need to worry about user management. This management will be held by Microsoft Entra ID, which means that it will be centralized and customized using the expertise and experience of the provider, even in aspects of different ways of authenticating, such as Multiple Factors for Authentication. The<a id="_idIndexMarker868"/> second<a id="_idIndexMarker869"/> one, and more important, is the<a id="_idIndexMarker870"/> user <a id="_idIndexMarker871"/>will not need to remember another account, since they will use the one that they already use in their common work, which makes OIDC a popular choice for creating secure and user-friendly authentication mechanisms. </p>
<h2 class="heading-2" id="_idParaDest-209"><a id="_idTextAnchor305"/>Securing Dependencies</h2>
<p class="normal">The <strong class="keyWord">Open Worldwide Application Security Project (OWASP)</strong> is a foundation<a id="_idIndexMarker872"/> that works to improve the <a id="_idIndexMarker873"/>security of software in a nonprofit approach. One of their most well-known initiatives is the Top 10 list, which presents the riskiest situations in relation to your software. This list indicates situations such as injection attacks, broken authentication, sensitive data exposure, and security misconfigurations.</p>
<p class="normal">When developing solutions, the usage of vulnerable and outdated components is considered one of the Top 10 risks. Libraries, frameworks, and APIs play a significant role in modern web application development, but these components can also introduce vulnerabilities into the application if not carefully managed. The decision to use third-party components can provide attackers with a vector to exploit the application, potentially leading to data breaches, unauthorized access, and other security incidents.</p>
<p class="normal">Considering the .NET environment, the usage of components is always connected to NuGet. Since NuGet is the package provider, in Visual Studio, it is quite simple to check if you are using a library that is outdated. </p>
<figure class="mediaobject"><img alt="Figure 10.9: Using NuGet to check outdated libraries" src="img/B31916_10_09.png"/></figure>
<p class="packt_figref">Figure 10.9: Using NuGet to check outdated libraries</p>
<p class="normal">On the other hand, you must be aware that not only .NET packages need to be updated in a solution. When it comes to microservices, depending on the approach decided on to implement them, you will need to handle components that could be in the container or even in the infrastructure that manages the containers of the solution, and these parts of the application must also be continuously checked, evaluating whether there are any vulnerabilities that could cause damage to your solution.</p>
<p class="normal">If you are using GitHub as a repository, you may consider <a id="_idIndexMarker874"/>using <strong class="keyWord">GitHub Dependabot</strong> as a tool for automatically scanning <a id="_idIndexMarker875"/>your GitHub projects for outdated dependencies and known vulnerabilities, and then opening PRs to update<a id="_idIndexMarker876"/> them. <strong class="keyWord">Sonar</strong> and <strong class="keyWord">Sync</strong> are <a id="_idIndexMarker877"/>other tools that you may consider in your pipeline to prevent third-party security issues.</p>
<p class="normal">The purpose of the CVE program (<a href="https://www.cve.org/">https://www.cve.org/</a>) is to help us with that. CVE means Common Vulnerabilities <a id="_idIndexMarker878"/>and Exposures, and it is a list of publicly disclosed computer security issues.</p>
<h1 class="heading-1" id="_idParaDest-210"><a id="_idTextAnchor306"/>Kubernetes and Azure Container Apps Security</h1>
<p class="normal">Orchestrators’ security is twofold: on one side, we have user access security, and on the other side, we have network security. Here, we refer to the users of the orchestrator, not the users of the application hosted by the orchestrator, that is developers, administrators, and other operators that maintain both the orchestrator installation and its applications.  </p>
<p class="normal">The security of application users is taken care of by the application itself with the usual web application tools that are not specific for microservices, that is security tokens such as authentication cookies and bearer tokens, user claims, roles, and authorization policies. </p>
<p class="normal">Orchestrator network security refers to orchestrator tools for isolating both different applications running in the same cluster and different parts of the same application.  </p>
<p class="normal">This section discusses both the orchestrator user’s access security and network security for Kubernetes and Azure Container Apps, each in a dedicated subsection. Let’s start with Kubernetes network security.</p>
<h2 class="heading-2" id="_idParaDest-211"><a id="_idTextAnchor307"/>Kubernetes network security</h2>
<p class="normal">Kubernetes network <a id="_idIndexMarker879"/>security enriches the usual IP-based firewall rules with constraints on higher-level software entities like Kubernetes Pods and namespaces. </p>
<p class="normal">Thus, for instance, we may isolate two applications running in the same Kubernetes cluster by placing them into two different namespaces and then forbidding any communication between those two namespaces.</p>
<p class="normal">We may also run sensitive Microservices in a “militarized zone” implemented as a namespace that exposes just a few <strong class="keyWord">filtering Pods</strong> to external communications. This <a id="_idIndexMarker880"/>way, the <strong class="keyWord">filtering Pods </strong>can look for adequate credentials and potential threats before routing the incoming communication to the microservices that must process them.</p>
<p class="normal">Pod- and namespace-based network rules are more modular and flexible than IP-address-based rules since they directly constrain application-level entities instead of hardware-related entities.</p>
<p class="normal">Network security rules are defined<a id="_idIndexMarker881"/> through <strong class="keyWord">NetworkPolicy</strong> resources defined with the <code class="inlineCode">.yaml</code> below:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: example-network-policy
  namespace: example-namespace
spec:
  podSelector:
    matchLabels:
      myLabel: matValue
      myLabel1: matValue1
  policyTypes: # may be either Ingress, or Egress or both
  - Ingress 
  - Egress
  ingress:
  - from:
      ….
  egress:
  - to:
    ----
</code></pre>
<p class="normal">The policy applies to all Pods selected by <code class="inlineCode">podSelector</code> that are in the same namespace of the <strong class="keyWord">NetworkPolicy</strong> resource. </p>
<p class="normal">If <code class="inlineCode">policyType</code> contains the <code class="inlineCode">Ingress</code> item, then the policy constrains input communications through rules that must be listed in the <code class="inlineCode">ingress</code> section. If <code class="inlineCode">Ingress</code> is not listed in <code class="inlineCode">policyType</code>, the <code class="inlineCode">ingress</code> section must be omitted.</p>
<p class="normal">If <code class="inlineCode">policyType</code> contains the <code class="inlineCode">Egress</code> item, then the policy constrains output communications through rules that must<a id="_idIndexMarker882"/> be listed in the <code class="inlineCode">egress</code> section. If <code class="inlineCode">Egress</code> is not listed in <code class="inlineCode">policyType</code>, the <code class="inlineCode">egress</code> section must be omitted.</p>
<p class="normal">Communication from/to each Pod must satisfy the constraints<a id="_idIndexMarker883"/> of all <strong class="keyWord">NetworkPolicy</strong> resources that select it with their <code class="inlineCode">podSelector</code>.</p>
<p class="normal">Each <code class="inlineCode">from</code> section selects possible sources of communication that sum up to the sources of communication selected by all other <code class="inlineCode">from</code> sections. Analogously, each <code class="inlineCode">to</code> section selects possible destinations of communication that sum up to the destinations of communication selected by all other <code class="inlineCode">to</code> sections.</p>
<p class="normal">Each <code class="inlineCode">from</code> and each <code class="inlineCode">to</code> contains a list of constraints that must be <em class="italic">all</em> satisfied by the allowed sources or destinations. There are three kinds of constraints that can be added:</p>
<ul>
<li class="bulletList">Constraints on IP addresses:
        <pre class="programlisting code-one"><code class="hljs-code">    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
</code></pre>
</li>
<li class="bulletList">A selector expression that selects Pods of the same namespace of the <strong class="keyWord">NetworkPolicy</strong> resource:
        <pre class="programlisting code-one"><code class="hljs-code">  - podSelector:
      matchLabels:
      podlabel1: podvalue1 
      …
</code></pre>
</li>
<li class="bulletList">A selector expression that selects other allowed namespaces:
        <pre class="programlisting code-one"><code class="hljs-code">  - namespaceSelector:
      matchLabels:
        namespacelabel1: namespacevalue1
        …
</code></pre>
</li>
</ul>
<p class="normal">If you would like to receive or send communications just to some Pods of the selected namespaces, you<a id="_idIndexMarker884"/> can also nest a <code class="inlineCode">podSelector</code> inside the <code class="inlineCode">namespaceSelector</code> based item as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">- namespaceSelector:
    matchLabels:
      namespacelabel1: namespacevalue1
  podSelector:
    matchLabels:
      podlabel1: podvalue1
</code></pre>
<p class="normal">Each <code class="inlineCode">from</code> and <code class="inlineCode">to</code> can also limit the allowed communication to a list of ports and port intervals as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">  ports:
  - protocol: TCP
    port: 6379
   …
  - protocol: TCP
    port: 8000
    endPort: 9000
</code></pre>
<p class="normal">If the item contains both <code class="inlineCode">port</code> and <code class="inlineCode">endPort</code>, it specifies a port interval. Otherwise, if it contains just <code class="inlineCode">port</code>, it specifies a singl<a id="_idTextAnchor308"/>e port.</p>
<p class="normal">Here is a policy that selects all Pods of the <code class="inlineCode">mysample</code> namespace and accepts traffic from all Pods of the same namespace and from all Pods of the <code class="inlineCode">mysafe</code> namespace:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: example-network-policy
  namespace: mysample
spec:
  podSelector: {}
  policyTypes: 
  - Ingress 
  ingress:
  - from:
    - podSelector:{}
    - namespaceSelector:
      matchExpressions:
      - key: namespace
        operator: In
        values: ["mysafe"]
</code></pre>
<p class="normal">Here is a policy <a id="_idIndexMarker885"/>that selects all Pods of the <code class="inlineCode">mysample</code> namespace, and accepts traffic from all Pods of the same namespace and from all Pods of the <code class="inlineCode">mysafe</code> namespace, but only on port 80:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: example-network-policy
  namespace: mysample
spec:
  podSelector: {}
  policyTypes: 
  - Ingress 
  ingress:
  - from:
    - podSelector:{}
    - namespaceSelector:
      matchExpressions:
      - key: namespace
        operator: In
        values: ["mysafe"]
    ports:
    - protocol: TCP
      port: 80
</code></pre>
<p class="normal">Here is a policy that enables all input traffic of the <code class="inlineCode">militarized-zone</code> namespace to pass through the Pods labeled with <code class="inlineCode">role: access-control</code>:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: access-control
  namespace: militarized-zone
spec:
  podSelector: 
    matchLabels:
      role: access-control
  policyTypes: 
  - Ingress 
  ingress:
  - from:
    - podSelector:{}
    - namespaceSelector:{}
</code></pre>
<p class="normal">We ca<a id="_idTextAnchor309"/>n force all <a id="_idIndexMarker886"/>traffic to pass just through the Pods with <code class="inlineCode">role: access-control</code> by adding another rule that prevents traffic from external namespaces to all other Pods:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: access-control
  namespace: militarized-zone
spec:
  podSelector: 
    matchExpression:
    - key: role
      operator: NotIn
      values: ["access-control"]
  policyTypes: 
  - Ingress 
  ingress:
  - from:
    - podSelector:{}
    
</code></pre>
<p class="normal"><code class="inlineCode">NetworkPolicy</code> entities constrain direct communication between Pods, that is communication based on Kubernetes services. However, what happens to communication mediated by message brokers? </p>
<p class="normal">We may use a different broker for each<a id="_idTextAnchor310"/> namespace we would like to isolate, so that we can use <code class="inlineCode">NetworkPolicy</code> entities to constrain access to the various message brokers, too. If the message broker servers run outside of the Kubernetes cluster, we may use <code class="inlineCode">NetworkPolicy</code> rules that filter the message broker IP addresses. Otherwise, we can deploy each message broker in the same namespace it serves, so that its Pods are also constrained by the same <code class="inlineCode">NetworkPolicy</code> entities that constrain direct communication between microservices. </p>
<p class="normal">If instead, we use a single message broker cluster, we are forced to use the message broker’s internal <a id="_idIndexMarker887"/>authorization policies to filter the access to the various message queues. </p>
<p class="normal">Azure Container Apps has simpler but less powerful network security.</p>
<h2 class="heading-2" id="_idParaDest-212"><a id="_idTextAnchor311"/>Azure Container Apps Network Security</h2>
<p class="normal">To configure network <a id="_idIndexMarker888"/>security in Azure Container Apps, you must use a custom Azure <strong class="keyWord">Virtual Network (VNET)</strong>. This requirement introduces the need for specific configurations and profiles. The setup typically follows these steps:</p>
<ol>
<li class="numberedList" value="1">Define a custom Azure <strong class="keyWord">VNet</strong>.</li>
<li class="numberedList">Associate a <strong class="keyWord">dedicated subnet</strong> from the VNet to each <strong class="keyWord">Container Apps environment</strong>.</li>
<li class="numberedList">Assign a <strong class="keyWord">subnet from each environment</strong> to its respective <strong class="keyWord">application</strong>.</li>
<li class="numberedList">Express communication constraints between environments and applications as <strong class="keyWord">firewall rules</strong> on the VNet subnets.</li>
</ol>
<div><p class="normal">For detailed guidance on associating custom subnets with environments and applications, refer to the official documentation: <a href="https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli">https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli</a>.</p>
</div>
<p class="normal">However, this approach has some limitations. Because network rules are defined using <strong class="keyWord">IP-address-based constraints</strong>, rather than explicit software-level policies, the result is <strong class="keyWord">reduced modularity</strong> and <strong class="keyWord">limited scalability</strong>. This model may be sufficient for small-scale applications with a few communication restrictions, but as your microservices ecosystem grows, the approach can become too complicated.</p>
<p class="normal">If your system’s communication is handled through <strong class="keyWord">external message brokers</strong>, a simpler and more scalable solution is to manage access via the <strong class="keyWord">broker’s authorization policies</strong>, controlling which services can access specific message queues.</p>
<h2 class="heading-2" id="_idParaDest-213"><a id="_idTextAnchor312"/>Kubernetes User Security </h2>
<p class="normal">Kubernetes user <a id="_idIndexMarker889"/>security is based on four concepts:</p>
<ol>
<li class="numberedList" value="1"><strong class="keyWord">User</strong>: This represents the user who logs in with Kubectl. Each user has a unique username and authenticates with a client certificate. Both certificate and username must be added to the user’s Kubectl configuration file as explained in the <em class="italic">Interacting with Kubernetes: Kubectl, Minikube, and AKS</em> section of <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a><em class="italic">, Practical Microservices Organization with Kubernetes</em>.</li>
<li class="numberedList"><strong class="keyWord">User Group</strong>: Each user group is just a name – a string that may be associated to each user and inserted in its client certificate. User groups simplify the assignation of permissions to users, since each privilege can be assigned to a single user or to a whole user group.</li>
<li class="numberedList"><strong class="keyWord">Role</strong>: Each role represents a set of permissions.</li>
<li class="numberedList"><strong class="keyWord">Role bindings</strong>: Each role binding associates a role, that is a set of permissions, to several users and user groups. Put simply, role bindings encode a one-to-many relationship between roles and both users and user groups.</li>
</ol>
<p class="normal">Permissions can be scoped either to a single namespace or to the whole Kubernetes cluster. Role and role bindings representing namespace-scoped permissions are encoded respectively in <code class="inlineCode">Role</code> and <code class="inlineCode">RoleBinding</code><strong class="keyWord"> </strong>Kubernetes resources, while role and role bindings representing cluster-scoped permissions are encoded respectively in <code class="inlineCode">ClusterRole </code>and <code class="inlineCode">ClusterRoleBinding</code> Kubernetes resources.</p>
<p class="normal">A <code class="inlineCode">RoleBinding</code> can only refer to a <code class="inlineCode">Role</code>, while a <code class="inlineCode">ClusterRoleBinding</code> can only refer to a <code class="inlineCode">ClusterRole</code>. Here are <a id="_idIndexMarker890"/>the definitions of a <code class="inlineCode">Role</code>:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: &lt;namespace name&gt; 
  name: &lt;role name&gt;
rules:
- apiGroups: [""] # "" indicates the core API group
  resources: ["pods"]
  verbs: ["get", "watch", "list"] # also "create", "update", "patch", "delete"
</code></pre>
<p class="normal">Each <strong class="keyWord">Role</strong> is identified by its name and by the namespace it applies to. Permissions are specified as a list of rules, where each rule contains:</p>
<ul>
<li class="bulletList"><code class="inlineCode">apiGroups</code>: The API that contains the operations and the resources involved in the permission. For instance, the API group for Deployments is “apps,” while the API group for Pods is the core API that is represented by the empty string. The API groups string corresponds to the API name contained in each resource <code class="inlineCode">apiVersion</code> property. Each rule can specify several API groups.</li>
<li class="bulletList">r<code class="inlineCode">esources</code>: The name of the resources that can be manipulated with permission (Pods, Deployments, Services, etc.).</li>
<li class="bulletList"><code class="inlineCode">verbs</code>: The operations allowed on the resources:<ul>
<li class="bulletList level-2"><code class="inlineCode">get</code>: Getting information on specific resource instances.</li>
<li class="bulletList level-2"><code class="inlineCode">watch</code>: Observing resource instance properties as they change in time. That is, performing a <code class="inlineCode">Kubectl get</code> or a <code class="inlineCode">Kubectl describe</code> with the <code class="inlineCode">–watch</code> flag on the resource.</li>
<li class="bulletList level-2"><code class="inlineCode">list</code>: Listing the resource in any list of results.</li>
<li class="bulletList level-2"><code class="inlineCode">create</code>: Creating an instance of the resource.</li>
<li class="bulletList level-2"><code class="inlineCode">delete</code>: Deleting an instance of the resource.</li>
<li class="bulletList level-2"><code class="inlineCode">update</code>: Updating a resource instance by providing a new object that represents the instance. This is a case of the resource being updated with <code class="inlineCode">Kubectl apply</code>.</li>
<li class="bulletList level-2"><code class="inlineCode">patch</code>: Updating a resource instance with <code class="inlineCode">Kubectl patch</code>. In this case, we specify an existing resource and then replace just a property with the value contained in the <code class="inlineCode">-p</code> option. The property may also be a complex object, in which case the properties specified in the object tree recursively replace existing values, while properties not specified in the object tree are left unchanged. Here’s an example:
            <pre class="programlisting con"><code class="hljs-con">kubectl patch pod &lt;pod name&gt; -p '{"spec":{"containers":[{"name":"kubernetes-serve-hostname","image":"new image"}]}}'
</code></pre>
</li>
</ul>
</li>
</ul>
<p class="normal">Here’s a role that might <a id="_idIndexMarker891"/>be adequate for developers of an application that runs in the <code class="inlineCode">my-app</code> namespace:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: my-app
  name: developer-user-role
rules:
- apiGroups: ["", "apps"]
  resources: ["pods", "services", "configmaps", "secrets", "deployments", "replicasets"]
  verbs: ["get", "list", "watch", "create", "update", "delete"]
</code></pre>
<p class="normal">All of <code class="inlineCode">apiGroups</code>, r<code class="inlineCode">esources</code>, and <code class="inlineCode">verbs</code> accept the wildcard “*” string that matches everything.</p>
<p class="normal">A <code class="inlineCode">ClusterRole</code> definition is completely analogous, the only difference being that no namespace must be specified and that <code class="inlineCode">type: Role</code> is replaced by <code class="inlineCode">type: ClusterRole</code>.</p>
<p class="normal">Here is the definition of a <code class="inlineCode">RoleBinding</code>:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: &lt;role binding name&gt;
  namespace: &lt;reference namespace&gt;
subjects:
- kind: User # specific user
  name: jane # "name" is case sensitive
  apiGroup: rbac.authorization.k8s.io
- kind: Group #user group
  name: namespace:administrators  # "name" is case sensitive
  apiGroup: rbac.authorization.k8s.io
…
roleRef:
  # "roleRef" specifies the binding to a Role 
  kind: Role #this must be Role 
  name: &lt;role-name&gt; # this must match the name of the Role you wish to bind to
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<p class="normal">A <code class="inlineCode">RoleBinding</code> contains a name and the reference namespace and specifies the <code class="inlineCode">Role</code> it is bound to in its <code class="inlineCode">roleRef</code> property. The <code class="inlineCode">subjects</code> property contains a list of both users and users’ groups, where each item <a id="_idIndexMarker892"/>specifies the user or group name and the kind of subject.</p>
<p class="normal">Here is a <code class="inlineCode">RoleBinding</code> that matches the example <code class="inlineCode">developer-user-role</code> <code class="inlineCode">Role</code> we have seen before, with all users belonging to the <code class="inlineCode">developers</code> group:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: developers-binding
  namespace: my-app
subjects:
- kind: Group
  name: developers
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: developer-user-role
  apiGroup: rbac.authorization.k8s.io
</code></pre>
<p class="normal">A <code class="inlineCode">ClusterBindingRole</code> definition is completely analogous, the only difference being that no namespace must be specified, <code class="inlineCode">roleRef</code> must refer a <code class="inlineCode">ClusterRole</code>, and that <code class="inlineCode">type: BindingRole</code> is replaced by <code class="inlineCode">type: ClusterBindingRole</code>.</p>
<p class="normal">Client certificates do not need to be issued by a public certification authority but need just to be approved by the Kubernetes cluster. Here is the complete procedure for creating an approved certificate:</p>
<ol>
<li class="alphabeticList" value="1">As the first step, you must create the certificate key. This can be done by op<a id="_idTextAnchor313"/>ening a Linux console and using <strong class="keyWord">openssl</strong>:
        <pre class="programlisting con-one"><code class="hljs-con"> openssl genrsa -out mynewuser.key 2048
</code></pre>
</li>
<li class="alphabeticList">You must store the <code class="inlineCode">mynewuser.key</code> file containing the certificate key since it is needed to configure the Kubectl configuration file.</li>
<li class="alphabeticList">Now let’s extract the public part <code class="inlineCode">mynewuser.key</code> in a certificate approval request. Again, we can do it with <strong class="keyWord">openssl</strong>:
        <pre class="programlisting con-one"><code class="hljs-con">openssl req -new -key mynewuser.key -out mynewuser.csr -subj "/CN= mynewuser /O=example:mygroup"
</code></pre>
</li>
<li class="alphabeticList">The above<a id="_idIndexMarker893"/> instruction generates the <code class="inlineCode">mynewuser.csr</code> file, containing a certificate approval request. <code class="inlineCode">mynewuser</code> must be replaced by the actual username, while <code class="inlineCode">example:mygroup</code> must be replaced by the name of the user group you would like to add the user to.</li>
<li class="alphabeticList">Now you must encode the certificate request in base 64:
        <pre class="programlisting con-one"><code class="hljs-con">cat mynewuser.csr | base64 | tr -d "\n"
</code></pre>
</li>
<li class="alphabeticList">The previous command returns the base-64-encoded certificate in the Linux console. Please select and copy it. You must insert it in a <code class="inlineCode">.yaml</code> file that encodes the approval request for the Kubernetes cluster:
        <pre class="programlisting code-one"><code class="hljs-code">apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: mynewuserrequest
spec:
  request: &lt;base64 encoded csr&gt;
  signerName: kubernetes.io/kube-apiserver-client
  expirationSeconds: &lt;duration in seconds&gt;
  usages:
  - client: auth
</code></pre>
</li>
<li class="alphabeticList">The only fields you must change are the <code class="inlineCode">name</code>, that is the approval request name, and <code class="inlineCode">expirationSeconds</code>, which contains the certificate validity in seconds.</li>
<li class="alphabeticList">Now let’s open the Windows console to interact with Minikube. Let’s start Minikube if it’s not started and then pass the previous .yaml file with:
        <pre class="programlisting con-one"><code class="hljs-con">Kubectl apply -f mynewuserrequest.yaml.
</code></pre>
</li>
</ol>
<ol>
<li class="alphabeticList" value="1">Now we can approve the certificate with:
        <pre class="programlisting con-one"><code class="hljs-con">kubectl certificate approve mynewuserrequest
</code></pre>
</li>
<li class="alphabeticList">After the approval, we can get the final certificate in base 64 format:
        <pre class="programlisting con-one"><code class="hljs-con">kubectl get csr mynewuserrequest -o jsonpath='{.status.certificate}'&gt; mytempfile.txt
</code></pre>
</li>
<li class="alphabeticList">Finally, we must base 64 – decode <code class="inlineCode">mytempfile.txt</code> to get the certificate in binary format. We can do it by opening a Linux console in the folder that contains <code class="inlineCode">mytempfile.txt</code>, and then issuing:
        <pre class="programlisting con-one"><code class="hljs-con">cat mytempfile.txt | base64 -d &gt; mynewuser.crt
</code></pre>
</li>
<li class="alphabeticList">Now you can use both <code class="inlineCode">mynewuser.key</code> and <code class="inlineCode">mynewuser.crt</code> to update the Kubectl configuration file of the new user as explained in the <em class="italic">Interacting with Kubernetes: Kubectl, Minikube, and AKS</em> section of <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a><em class="italic">, Practical Microservices Organization with Kubernetes</em>.</li>
</ol>
<p class="normal">As an exercise, you can <a id="_idIndexMarker894"/>use the above procedure to define a new Minikube user belonging to the <code class="inlineCode">developers</code> user group, and then you can assign it developer privileges on the <code class="inlineCode">myapp</code> namespace with the example <code class="inlineCode">developer-user-role Role</code> and <code class="inlineCode">developers-binding RoleBinding</code> we defined before.</p>
<p class="normal">That’s all! Let’s move on to Azure Container Apps user security.</p>
<h2 class="heading-2" id="_idParaDest-214"><a id="_idTextAnchor314"/>Azure Container Apps User Security</h2>
<p class="normal">Azure Container Apps <a id="_idIndexMarker895"/>has no dedicated user security like Kubernetes but uses Azure security. Roles can be assigned to specific users either through the Azure portal or with the Azure CLI with this command:</p>
<pre class="programlisting con"><code class="hljs-con">az role assignment create `
--assignee &lt;USER IDENTITY RESOURCE ID&gt; `
--role &lt;ROLE NAME&gt; `
--scope &lt;ENVIRONMENT OR APPLICATION_RESOURCE_ID&gt;
</code></pre>
<p class="normal">All available roles can be inspected on the Environment and Application page of the Azure portal. Both the application/environment resource ID and the user identity resource ID are available on their respective pages.</p>
<h1 class="heading-1" id="_idParaDest-215"><a id="_idTextAnchor315"/>Threat Detection and Mitigation</h1>
<p class="normal">The number of threats we need to deal with in an application is quite huge and OWASP, as mentioned before, helps us with that. There are many common attacks that an application will need to handle and not only the protection of its network, data, entrance, and dependencies will be enough to deal with these attacks.</p>
<h2 class="heading-2" id="_idParaDest-216"><a id="_idTextAnchor316"/>Threats</h2>
<p class="normal">The most difficult <a id="_idIndexMarker896"/>point of this scenario is detecting a threat on the fly while an application is running. But to detect them, we need to understand basically what they are, so let’s check out, in the following topics, some of the common attacks. </p>
<h3 class="heading-3" id="_idParaDest-217"><a id="_idTextAnchor317"/>Event Injection</h3>
<p class="normal">When an attacker<a id="_idIndexMarker897"/> manipulates input data to execute unauthorized<a id="_idIndexMarker898"/> actions within an application, leading to data breaches, service disruptions, or unauthorized access, we are under an event injection attack. </p>
<p class="normal">There are several strategies of mitigation, which include validating and sanitizing the input, guaranteeing strict input data; using strong-validation libraries, to define well-established libraries and framework connections; and restricting the privilege of users to the minimum necessary.</p>
<h3 class="heading-3" id="_idParaDest-218"><a id="_idTextAnchor318"/>Privilege Escalation</h3>
<p class="normal">In an application where<a id="_idIndexMarker899"/> you have different levels of access, privilege <a id="_idIndexMarker900"/>escalation occurs when an attacker gains access beyond what they need to have, accessing resources or functions that they are not authorized to use. The result can be catastrophic, leading to unauthorized data access, total system control, and further exploitation of the application.</p>
<p class="normal">Fine-grained access control to restrict users must be well implemented. Also, there is the possibility to use<a id="_idIndexMarker901"/> an <strong class="keyWord">Identity and Access Management (IAM)</strong> solution, which will enforce user permissions. Regular audits and <strong class="keyWord">Multi-Factor Authentication (MFA)</strong> will<a id="_idIndexMarker902"/> also help to mitigate possible scenarios where unauthorized users may access relevant data.</p>
<h3 class="heading-3" id="_idParaDest-219"><a id="_idTextAnchor319"/>Denial of Service (DoS) Attacks</h3>
<p class="normal">Let’s suppose you h<a id="_idIndexMarker903"/>ave massive and excessive traffic in your <a id="_idIndexMarker904"/>application caused by an attacker who wants to disrupt the availability of your solution, making the site simply stop responding accordingly. This is what we call a <strong class="keyWord">Denial of Service (DoS)</strong> attack. A DoS attack is caused by a single attacker, from a single point. If you have an event where multiple origins of attacks are observed, you must be experiencing a DDoS attack, which means that the attack is distributed. </p>
<p class="normal">Obviously, the main way to mitigate this kind of attack is by blocking the traffic generated by its origin, so traffic filtering can be the best option. There is also the possibility of limiting the rate of access from a specific client for a period, minimizing the impact of DDoS attacks. </p>
<p class="normal">Besides that, if you have a solution with great availability, focused on delivering high levels of requests, you can suffer less with this kind of attack, especially if we are talking about DoS. So, auto-scaling strategies, which automatically adjust the number of active instances of a service based on the current load, are a good approach<a id="_idIndexMarker905"/> for that. <strong class="keyWord">Content delivery network (CDN)</strong> implementations, which approximate content to the ones who are using it by implementing the content across multiple<a id="_idIndexMarker906"/> geographically dispersed servers, can be also <a id="_idIndexMarker907"/>a good way to protect from this kind of attack.</p>
<h3 class="heading-3" id="_idParaDest-220"><a id="_idTextAnchor320"/>Man-in-the-Middle (MitM) Attacks</h3>
<p class="normal"><strong class="keyWord">Man-in-the-Middle (MitM)</strong> attacks occur <a id="_idIndexMarker908"/>when you have <a id="_idIndexMarker909"/>an interception of communication between two parts of a system, altering data, which can cause inconsistent information in the solution you provide. </p>
<p class="normal">As we have checked before, implementing a secure communication channel, using encryption protocols to secure data in transit, is certainly the best way to reduce the risk of this threat. Authentication mechanisms can also help in this case, especially if there is a way to verify the identities of communicating parties.</p>
<h3 class="heading-3" id="_idParaDest-221"><a id="_idTextAnchor321"/>Code Injection</h3>
<p class="normal">Software code is certainly <a id="_idIndexMarker910"/>one of the ways to cause an attack in an application, especially<a id="_idIndexMarker911"/> if the code enables the injection of malicious code. Malicious code can be added in SQL commands that do not properly restrict what is executed in the database, enabling leaks, changes, or even data exclusion. In cases where your application enables the execution of scripts, the risk is also high, and unauthorized actions can happen due to this. You can also have cases where code is injected by attackers into web pages viewed by other users. This is <a id="_idIndexMarker912"/>called <strong class="keyWord">cross-site scripting (XSS)</strong>.</p>
<p class="normal">Implementing a serious code review process, applying secure coding practices, is mandatory in enterprises where the software is crucial for the business. To help with this, the usage of a static analysis tool must be considered, based on the amount of code that is generated daily by the company.</p>
<h2 class="heading-2" id="_idParaDest-222"><a id="_idTextAnchor322"/>Detection and Mitigation with Web Application Firewalls</h2>
<p class="normal">Since you now <a id="_idIndexMarker913"/>understand<a id="_idIndexMarker914"/> the number of threats available, it is reasonable to say that there is no way to be entirely protected from them without a tool that can monitor the entire traffic, inspect it according to the different known threats, and alert you to take action once you have something suspicious. That is exactly <a id="_idIndexMarker915"/>what a <strong class="keyWord">Web Application Firewall (WAF)</strong> does.</p>
<p class="normal">SQL injection, XSS, and other common web exploits can be handled by WAFs, so you must consider their use crucial for securing serverless and microservices applications. This is only possible because WAFs in general monitor HTTP/HTTPS traffic, giving you the possibility to block malicious requests from a specific client, even before they reach your application.</p>
<p class="normal">They also provide a centralized panel for monitoring traffic and logging, which really simplifies the administration and increases your knowledge about the attacks you are suffering. It is important to mention that if you are running a public cloud solution, you are constantly under attack. </p>
<p class="normal">The service Microsoft offers as a WAF is called Azure Web Application Firewall. It is worth noting that Azure WAF works at Layer 7 (the application layer) of the OSI model and analyzes HTTP(S) traffic. To do so, it will be necessary to check the requests and responses passing through a channel. One of the alternatives for this channel is called Azure Application Gateway. This component<a id="_idIndexMarker916"/> is a <a id="_idIndexMarker917"/>web traffic load balancer that also works on OSI Layer 7. It enables you to manage the traffic of your web applications. All the inspected traffic that suggests a threat is sent to Azure Monitor as an alert so that an administrator of the application can analyze it and take action.</p>
<p class="normal">As you may imagine, a solution that monitors the entire traffic of your application is obviously a concern when it comes to budget. So, this is certainly a point of discussion about investment and the trade-off of it must be analyzed.</p>
<figure class="mediaobject"><img alt="Figure 10.10: Sample solution architecture for enabling WAF" src="img/B31916_10_10.png"/></figure>
<p class="packt_figref">Figure 10.10: Sample solution architecture for enabling WAF</p>
<p class="normal">The preceding diagram represents a solution architecture using the components that were described in this topic. As you can see, common users access the system via HTTPS, Azure Application Gateway handles traffic routing, and Azure WAF protects the solution against web threats. There is also the implementation of a Container Apps environment for scaling workloads using <a id="_idIndexMarker918"/>containers, and <a id="_idIndexMarker919"/>the microservices are running inside a virtual network. Azure Monitor is being used for the logging and observability of the system, so administrator access to Azure Monitor is used for insights. Observability is exactly the next topic that we will discuss. Let’s have a look at it.</p>
<h1 class="heading-1" id="_idParaDest-223"><a id="_idTextAnchor323"/>Observability for Serverless and Microservices</h1>
<p class="normal">As we have seen up<a id="_idIndexMarker920"/> to this point of the book, distributed systems contain a complexity that brings to a solution some concerns that you can’t ignore. The implementation of a single microservice, using techniques such as serverless or containerization, is generally quite simple, but observing the entire solution is a difficult task and is certainly one of these concerns. The adoption of the observability concept is a good answer to this problem.</p>
<p class="normal">Observability is defined by three primary signals: logs, metrics, and traces. A log is an immutable, time-stamped record of an event. A metric is a numerical representation of system performance over time. A trace represents the journey of a request across services in a distributed system. Together, these three signals provide insight into system behavior, enabling proactive maintenance and fast troubleshooting.</p>
<p class="normal">Different from traditional monitoring, which generally focuses on predefined metrics and system health indicators, and is often reactive, observability defends a proactive approach, where the monitoring is continuous to avoid critical problems, and fast root-cause detection is the goal. </p>
<p class="normal">There are several tools available to help implement observability in distributed systems. For logs, tools like Seq and the ELK Stack offer powerful log aggregation and visualization capabilities. For metrics, Prometheus is a widely used open-source monitoring solution, often paired with Grafana for visualization. For distributed tracing, Jaeger and Zipkin are popular open-source options.</p>
<p class="normal">However, Application Performance Monitoring (APM) tools like Azure Monitor, Datadog, and New Relic allow you to centralize logs, metrics, and traces in one place, providing a full picture of system behavior. Choosing<a id="_idIndexMarker921"/> between them depends on your infrastructure, cloud provider, and integration needs.</p>
<p class="normal">Let’s understand each signal of observability in detail to make it easier to understand.</p>
<h2 class="heading-2" id="_idParaDest-224"><a id="_idTextAnchor324"/>Logging</h2>
<p class="normal">Contextual-rich <a id="_idIndexMarker922"/>data is necessary to understand exactly where and when in the distributed system the issue monitored started. For example, understanding the sequence of service calls and the data passed between them can reveal whether an error originated from a specific service or from the interaction between services. This level of detail is crucial for effective debugging and for ensuring the resilience and reliability of distributed systems.</p>
<p class="normal">So, to enhance the usability of logs, it is essential to adopt a structured format that is easy to query and process. One of the most common approaches is to use JSON for log entries, as it offers readability and broad compatibility across systems. However, structured logging goes beyond using a structured format. It requires purposefully defining the meaning (semantics) of each log field. This ensures consistency, improves observability, and enables better filtering, indexing, and correlation across logs.</p>
<p class="normal">Besides that, effective logging needs the use of different logging categories to define the severity and importance of log entries. </p>
<ul>
<li class="bulletList">Debug: Detailed information for technical internal purposes.</li>
<li class="bulletList">Info: General information about the application.</li>
<li class="bulletList">Warning: Alerts that may indicate potential issues, but that did not cause the halting of the application.</li>
<li class="bulletList">Error: Problems that impact the application’s operation and that need to be analyzed.</li>
<li class="bulletList">Fatal: Critical errors that cause the application to terminate.</li>
</ul>
<p class="normal">The correct usage of logging<a id="_idIndexMarker923"/> levels minimizes efforts in analyzing issues, focusing on critical ones in an efficient and effective approach.</p>
<h2 class="heading-2" id="_idParaDest-225"><a id="_idTextAnchor325"/>Metrics</h2>
<p class="normal">When it comes to<a id="_idIndexMarker924"/> metrics that need to be monitored and evaluated for serverless and microservices architectures, there are specific indicators that can be monitored. </p>
<p class="normal">For instance, Azure Functions measures the time it takes for a function to execute from start to finish. This is <a id="_idIndexMarker925"/>called <strong class="keyWord">Function Execution Time</strong>. Shorter execution times generally indicate better performance.</p>
<p class="normal">Azure Functions also measures the latency between a serverless function being triggered and the moment the function essentially starts running. This is <a id="_idIndexMarker926"/>called <strong class="keyWord">Cold Start</strong> and reducing it causes improvement of the user experience. </p>
<p class="normal">The number of <strong class="keyWord">invocations</strong> and the number of <strong class="keyWord">errors</strong> also illustrate how the function is working, helping in the analysis of performance and possible problematic code.</p>
<p class="normal">On the other hand, when you have containerized environments, <strong class="keyWord">CPU</strong> and <strong class="keyWord">Memory Usage</strong> may be good metrics to <a id="_idIndexMarker927"/>monitor. The<a id="_idIndexMarker928"/> first one can affect performance if it is too high, and scaling may be considered. The second one can also impact performance, and the the cause of memory leaks can be addressed.</p>
<p class="normal"><strong class="keyWord">Network Traffic </strong>may<a id="_idIndexMarker929"/> also be a concern in containerized environments and can indicate issues related to communication between microservices. <strong class="keyWord">Pod Health</strong> can<a id="_idIndexMarker930"/> help in identifying failing or unhealthy Pods.</p>
<p class="normal">These and other metrics can not only be monitored but also alerted <a id="_idIndexMarker931"/>using <strong class="keyWord">threshold-based</strong> algorithms and alerts. Today, in Azure, we also have<a id="_idIndexMarker932"/> some <strong class="keyWord">anomaly detection</strong> done by machine models that generally detect deviation of behaviors in some situations, like time-response.</p>
<p class="normal">Once alerts are properly set, it is also important to have a clear protocol for responding to these alerts. This is normally called<a id="_idIndexMarker933"/> the <strong class="keyWord">Incident Response Process</strong>. The process needs to determine how to deal with the incident (alert), how to communicate it, and how to discover the root cause, so the incident does not happen again.</p>
<h2 class="heading-2" id="_idParaDest-226"><a id="_idTextAnchor326"/>Tracing</h2>
<p class="normal">When you have<a id="_idIndexMarker934"/> a distributed application, understanding the complete path from a request to its end is important to effectively diagnose situations across the microservices that are chained. That is why tracing is so important, and .NET applications together with Azure have a very good package of libraries to help you with it.</p>
<p class="normal">The usage of Azure Monitor here is crucial for success. Of course, there are other APM systems that can be used to observe the traceability of an application, but Azure Monitor gives us facilities that you may consider using. Besides that, the <code class="inlineCode">OpenTelemetry</code> library will give you the versatility needed for enterprise solutions. OpenTelemetry (OTel) is a cross-platform, open standard for collecting and emitting telemetry data.</p>
<p class="normal">In .NET the OpenTelemetry implementation uses well-known platform APIs for instrumentation:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Microsoft.Extensions.Logging.ILogger&lt;TCategoryName&gt;</code> for logging</li>
<li class="bulletList"><code class="inlineCode">System.Diagnostics.Metrics.Meter</code> for metrics</li>
<li class="bulletList"><code class="inlineCode">System.Diagnostics.ActivitySource</code> and <code class="inlineCode">System.Diagnostics.Activity</code> for distributed tracing</li>
</ul>
<p class="normal">These APIs are used by OTel for collecting telemetry and exporting this data to an APM service selected by the developer.</p>
<p class="normal">It is also important to notice that the implementation of trace propagation using OTel for .NET and Azure Monitor <a id="_idIndexMarker935"/>is fully automated, which accelerates the process of observing the application’s behavior in Azure Monitor.</p>
<h2 class="heading-2" id="_idParaDest-227"><a id="_idTextAnchor327"/>Centralized Observability with Azure Monitor</h2>
<p class="normal">The following <a id="_idIndexMarker936"/>example <a id="_idIndexMarker937"/>will give you an idea of how powerful Azure Monitor is as an APM system to centralize logging, metrics, and tracing as a professional observability tool, accelerating diagnosing and enabling proactive management with rapid troubleshooting.</p>
<p class="normal">The code provided in startup uses Azure Monitor for registering the telemetry collected by <code class="inlineCode">OpenTelemetry</code> libraries, as we can see here:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
// Retrieve Application Insights connection string from configuration
string appInsightsConnectionString = builder.Configuration[
  "AzureMonitor:ConnectionString"];
builder.Services.AddOpenTelemetry()
  .WithTracing(tracerProviderBuilder =&gt;
  {
    tracerProviderBuilder
      // Set resource builder with application name
      .SetResourceBuilder(
        ResourceBuilder.CreateDefault().AddService(
          builder.Environment.ApplicationName))
      // Add ASP.NET Core instrumentation
      .AddAspNetCoreInstrumentation()
      // Add HTTP client instrumentation
      .AddHttpClientInstrumentation()
      // Add Azure Monitor Trace Exporter with connection string
      .AddAzureMonitorTraceExporter(options =&gt;
      {
        options.ConnectionString = appInsightsConnectionString;
      });
  });
// Add Application Insights only for logging &amp; metrics 
// (without re-adding tracing)
builder.Services.AddApplicationInsightsTelemetry(options =&gt;
{
  options.ConnectionString = appInsightsConnectionString;
  // Disable AI's automatic trace sampling
  options.EnableAdaptiveSampling = false; 
  // Prevents duplicate dependency tracking
  options.EnableDependencyTrackingTelemetryModule = false; 
  // Prevents duplicate HTTP request tracking
  options.EnableRequestTrackingTelemetryModule = false; 
});
var app = builder.Build();
</code></pre>
<p class="normal">The same code <a id="_idIndexMarker938"/>has two<a id="_idIndexMarker939"/> APIs. The APIs will obtain data via another route, but one of them will try to access an unknown URL.</p>
<pre class="programlisting code"><code class="hljs-code">// Map GET request to /error endpoint
app.MapGet("/error", async (HttpContext context) =&gt;
{
  var httpClient = new HttpClient();
  var response = await httpClient.GetAsync(
    "https://anyhost.sample.com/data");
  return "Hello Trace!";
});
</code></pre>
<p class="normal">Notice that the API that is working with a successful endpoint will try to access the Packt website.</p>
<pre class="programlisting code"><code class="hljs-code">// Map GET request to /success endpoint
app.MapGet("/success", async (HttpContext context) =&gt;
{
  var httpClient = new HttpClient();
  var response = await httpClient.GetAsync("https://www.packtpub.com/");
  return "Hello Trace!";
});
</code></pre>
<p class="normal">Both results are impressive. The first one indicates the endpoint with an error can be tracked entirely in the Azure Monitor End-to-end transaction view. </p>
<figure class="mediaobject"><img alt="Figure 10.11: Endpoint with an error in Azure Monitor End-to-end transaction view" src="img/B31916_10_11.png"/></figure>
<p class="packt_figref">Figure 10.11: Endpoint with an error in Azure Monitor End-to-end transaction view</p>
<p class="normal">This monitoring <a id="_idIndexMarker940"/>would be useful to detect this endpoint error, facilitating the correction of this bug. </p>
<p class="normal">The second result is also interesting because it detects a redirection that could improve the performance of the request.</p>
<figure class="mediaobject"><img alt="Figure 10.12: Endpoint with a successful result in Azure Monitor End-to-end transaction view" src="img/B31916_10_12.png"/></figure>
<p class="packt_figref">Figure 10.12: Endpoint with a successful result in Azure Monitor End-to-end transaction view</p>
<p class="normal">The point here is <a id="_idIndexMarker941"/>that every call will take 67.2 milliseconds only to redirect to the page that is desired. Maybe an alternative solution would be to directly access the correct URL. We need to understand this example as a hypothetical case, but in real-world cases, this can increase the performance of the application.</p>
<h1 class="heading-1" id="_idParaDest-228"><a id="_idTextAnchor328"/>Summary </h1>
<p class="normal">In this chapter, we had the opportunity to discuss security and observability strategies for serverless and microservices applications. We need to understand that the increase in threats posed by cybercrime moves us to integrate security from the initial stages of product development. To do so, we must apply, in our security by design approach, security best practices for databases, implementing authentication and authorization mechanisms like <strong class="keyWord">JSON Web Tokens (JWTs)</strong>, OAuth 2.0, and <strong class="keyWord">OpenID Connect (OIDC)</strong>, and using network protection methods like <strong class="keyWord">Virtual Private Clouds (VPCs)</strong> and Azure Private Link. Encryption, HTTPS enforcement, and the use of Azure Key Vault for managing secrets are also important for modern application development.</p>
<p class="normal">Another focus of the chapter was network security, particularly in Kubernetes and Azure Container Apps environments. That is why the chapter explained how Kubernetes network policies enhance security through the isolation of applications and services using namespaces and Pod-based network rules. Azure’s network security strategies involve virtual networks, firewalls, and private links to limit exposure to public threats. The chapter also discussed user security, emphasizing role-based access control (RBAC) in Kubernetes and Azure role assignments. It also addressed securing dependencies by ensuring that third-party components, libraries, and containers are regularly updated to prevent vulnerabilities.</p>
<p class="normal">The chapter also emphasized the importance of threat detection, using web application firewalls (WAFs) and proactive security strategies to mitigate threats such as injection attacks, denial-of-service (DoS) attacks, and privilege escalation.</p>
<p class="normal">To finish, observability was another critical topic presented, which was defined through three primary signals: logs, metrics, and traces. The chapter explained how structured logging, categorized by severity levels, can help diagnose issues efficiently. It also covered key performance metrics for both serverless functions and containerized applications, such as execution times, resource consumption, and error rates. Tracing techniques, including OpenTelemetry and Azure Monitor, were presented as solutions for tracking distributed transactions and enhancing system monitoring. </p>
<h1 class="heading-1" id="_idParaDest-229"><a id="_idTextAnchor329"/>Questions</h1>
<ol>
<li class="numberedList" value="1"><strong class="keyWord">Why is security a critical concern in serverless and microservices architectures compared to monolithic applications?</strong></li>
</ol>
<p class="normal-one">Security is more critical in serverless and microservices architectures because they significantly expand the attack surface. Unlike monolithic applications, distributed systems involve multiple independent services communicating over networks, which increases the potential entry points for cyberattacks. Each microservice, API, or function might expose vulnerabilities, and the complexity of managing security across them demands a more comprehensive and layered approach.</p>
<ol>
<li class="numberedList" value="2"><strong class="keyWord">What are the key layers of security in an application, and why is the “onion model” a useful analogy?</strong></li>
</ol>
<p class="normal-one">The key layers of security include:</p>
<ul>
<li class="bulletList level-2">Data security (e.g., encryption, secure database access)</li>
<li class="bulletList level-2">Application security (e.g., authentication and authorization)</li>
<li class="bulletList level-2">Third-party components (e.g., library updates)</li>
<li class="bulletList level-2">Infrastructure and network security (e.g., VPCs, firewalls)</li>
<li class="bulletList level-2">Traffic interception and monitoring (e.g., WAFs)</li>
</ul>
<p class="normal-one">The “onion model” is useful because it emphasizes that security must be implemented in multiple concentric layers. Each layer reinforces the others, reducing the likelihood of a single point of failure.</p>
<ol>
<li class="numberedList" value="3"><strong class="keyWord">How does a Virtual Private Cloud (VPC) improve security in cloud environments, and what are its key benefits?</strong></li>
</ol>
<p class="normal-one">A VPC creates a logically isolated network within the public cloud, allowing you to define custom subnets, routing rules, and gateways. Key benefits include:</p>
<ul>
<li class="bulletList level-2">Reduced exposure to public threats</li>
<li class="bulletList level-2">Fine-grained traffic control</li>
<li class="bulletList level-2">Integration with services like Azure Private Link</li>
<li class="bulletList level-2">Enhanced monitoring and protection through network security groups and flow logs</li>
</ul>
<ol>
<li class="numberedList" value="4"><strong class="keyWord">What is the difference between authentication and authorization, and what are some commonly used authentication mechanisms?</strong>
<ul>
<li class="bulletList level-2"><strong class="keyWord">Authentication</strong> is the process of verifying the identity of a user or system.</li>
<li class="bulletList level-2"><strong class="keyWord">Authorization</strong> determines what an authenticated user is allowed to do.</li>
<li class="bulletList level-2">Common mechanisms include:<ul>
<li class="bulletList level-3">JSON Web Tokens (JWTs)</li>
<li class="bulletList level-3">OAuth 2.0</li>
<li class="bulletList level-3">OpenID Connect (OIDC)</li>
</ul>
</li>
</ul>
</li>
<li class="numberedList"><strong class="keyWord">How does a JSON Web Token (JWT) ensure secure communication between a client and a server?</strong></li>
</ol>
<p class="normal-one">A JWT encodes user claims in a signed JSON object transferred via HTTP headers. After successful authentication, the server issues a token. This token is then included in subsequent requests by the client. Middleware on the server verifies the token before allowing access. The stateless and signed nature of JWTs helps ensure message integrity and secure access control.</p>
<ol>
<li class="numberedList" value="6"><strong class="keyWord">What are Kubernetes resources for handling network security?</strong></li>
</ol>
<p class="normal-one">Kubernetes handles network security using:</p>
<ul>
<li class="bulletList level-2">Namespaces for isolating applications</li>
<li class="bulletList level-2">Pods with specific labels and rules</li>
<li class="bulletList level-2">NetworkPolicy resources to define ingress/egress rules based on:<ul>
<li class="bulletList level-3">IP blocks</li>
<li class="bulletList level-3">Pod selectors</li>
<li class="bulletList level-3">Namespace selectors</li>
<li class="bulletList level-3">Ports and protocols</li>
</ul>
</li>
</ul>
<p class="normal-one">These policies constrain communication between services in a modular, application-centric way.</p>
<ol>
<li class="numberedList" value="7"><strong class="keyWord">What are Kubernetes resources for handling users’ security?</strong></li>
</ol>
<p class="normal-one">User security in Kubernetes is managed through:</p>
<ul>
<li class="bulletList level-2">Users and Groups</li>
<li class="bulletList level-2">Roles and RoleBindings (namespace-scoped)</li>
<li class="bulletList level-2">ClusterRoles and ClusterRoleBindings (cluster-wide)</li>
</ul>
<p class="normal-one">Permissions are defined through verbs (get, list, create, delete, etc.) and bound to users/groups via role bindings. Authentication typically uses client certificates.</p>
<ol>
<li class="numberedList" value="8"><strong class="keyWord">Does Azure Container Apps have specific facilities for users and network security?</strong></li>
</ol>
<p class="normal-one">Yes:</p>
<ul>
<li class="bulletList level-2">Network security is handled through Azure Virtual Networks and subnets.</li>
<li class="bulletList level-2">User access is managed via Azure Role-Based Access Control (RBAC), where roles are assigned to users through the Azure portal or CLI.</li>
<li class="bulletList level-2">Azure does not have a dedicated user security model like Kubernetes but relies on the broader Azure identity platform.</li>
</ul>
<ol>
<li class="numberedList" value="9"><strong class="keyWord">What are some common cyber threats, such as privilege escalation and denial-of-service attacks, and what strategies can be used to mitigate them?</strong></li>
</ol>
<p class="normal-one">Common threats:</p>
<ul>
<li class="bulletList level-2"><strong class="keyWord">Event injection</strong>: Mitigated by input validation/sanitization.</li>
<li class="bulletList level-2"><strong class="keyWord">Privilege escalation</strong>: Mitigated by fine-grained access controls, IAM solutions, audits, and MFA.</li>
<li class="bulletList level-2"><strong class="keyWord">DoS/DDoS attacks</strong>: Mitigated by rate limiting, traffic filtering, auto-scaling, and CDNs.</li>
<li class="bulletList level-2"><strong class="keyWord">MitM attacks</strong>: Mitigated by HTTPS/TLS encryption and authentication.</li>
<li class="bulletList level-2"><strong class="keyWord">Code injection</strong> (e.g., SQL Injection, XSS): Mitigated by secure coding practices, static analysis, and WAFs.</li>
</ul>
<ol>
<li class="numberedList" value="10"><strong class="keyWord">What role do Web Application Firewalls (WAFs) play in securing microservices applications, and what are their main advantages?</strong></li>
</ol>
<p class="normal-one">WAFs monitor and filter HTTP/HTTPS traffic, blocking malicious requests before they reach the application. Advantages include:</p>
<ul>
<li class="bulletList level-2">Protection against known web exploits (e.g., SQL injection, XSS)</li>
<li class="bulletList level-2">Centralized logging and alerting (e.g., via Azure Monitor)</li>
<li class="bulletList level-2">Ability to block specific clients</li>
<li class="bulletList level-2">Simplified security administration</li>
</ul>
<p class="normal-one">Azure’s WAF integrates with Application Gateway and operates at OSI Layer 7.</p>
<ol>
<li class="numberedList" value="11"><strong class="keyWord">What are the three primary signals of observability, and how do they contribute to maintaining a secure and efficient system?</strong></li>
</ol>
<p class="normal-one">The three primary signals are:</p>
<ul>
<li class="bulletList level-2"><strong class="keyWord">Logs</strong>: Immutable event records that help in debugging and auditing.</li>
<li class="bulletList level-2"><strong class="keyWord">Metrics</strong>: Quantitative performance indicators (e.g., execution time, memory usage).</li>
<li class="bulletList level-2"><strong class="keyWord">Traces</strong>: Visualize request paths across services for root-cause analysis.</li>
</ul>
<p class="normal-one">Together, they allow proactive monitoring, help detect anomalies, and support rapid incident response—crucial for secure and resilient systems.</p>
<h1 class="heading-1" id="_idParaDest-230"><a id="_idTextAnchor330"/>Further reading</h1>
<ul>
<li class="bulletList">Azure Container Apps Networking: <a href="https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli">https://learn.microsoft.com/en-us/azure/container-apps/networking?tabs=workload-profiles-env%2Cazure-cli</a>.</li>
<li class="bulletList">Buy a custom domain: <a href="https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain">https://learn.microsoft.com/en-us/azure/app-service/manage-custom-dns-buy-domain</a></li>
<li class="bulletList">Storing app secrets: <a href="https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/">https://learn.microsoft.com/en-us/samples/azure/azure-sdk-for-net/app-secrets-configuration/</a></li>
<li class="bulletList">Transparent Data Encryption: <a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption">https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/transparent-data-encryption</a></li>
<li class="bulletList">JSON Web Tokens: <a href="https://jwt.io/">https://jwt.io/</a></li>
<li class="bulletList">OAuth 2.0: <a href="https://oauth.net/">https://oauth.net/</a></li>
<li class="bulletList">MSAL: <a href="https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview">https://learn.microsoft.com/en-us/entra/identity-platform/msal-overview</a></li>
<li class="bulletList">What is OIDC?: <a href="https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc">https://www.microsoft.com/en-us/security/business/security-101/what-is-openid-connect-oidc</a></li>
<li class="bulletList">OIDC: <a href="https://openid.net/">https://openid.net/</a></li>
<li class="bulletList">OWASP: <a href="https://owasp.org/">https://owasp.org/</a></li>
<li class="bulletList">Azure Private Link: <a href="https://learn.microsoft.com/en-us/azure/private-link/private-link-overview">https://learn.microsoft.com/en-us/azure/private-link/private-link-overview</a></li>
<li class="bulletList">Network security groups: <a href="https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview">https://learn.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview</a></li>
<li class="bulletList">Virtual Network flow logs: <a href="https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview">https://learn.microsoft.com/en-us/azure/network-watcher/vnet-flow-logs-overview</a></li>
<li class="bulletList">Azure Virtual Network: <a href="https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview">https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview</a></li>
<li class="bulletList">Azure Managed Identities: <a href="https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview">https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview</a></li>
<li class="bulletList">Azure Firewall: <a href="https://learn.microsoft.com/en-us/azure/firewall/overview">https://learn.microsoft.com/en-us/azure/firewall/overview</a></li>
<li class="bulletList">Azure Web Application Firewall: <a href="https://azure.microsoft.com/en-us/products/web-application-firewall">https://azure.microsoft.com/en-us/products/web-application-firewall</a></li>
<li class="bulletList">Azure Application Gateway: <a href="https://learn.microsoft.com/en-us/azure/application-gateway/">https://learn.microsoft.com/en-us/azure/application-gateway/</a></li>
<li class="bulletList">OpenTelemetry: <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel">https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel</a></li>
<li class="bulletList">GitHub Dependabot: <a href="https://github.com/dependabot">https://github.com/dependabot</a></li>
<li class="bulletList">Sonar: <a href="https://www.sonarsource.com/">https://www.sonarsource.com/</a></li>
<li class="bulletList">Synk: <a href="https://snyk.io/">https://snyk.io/</a></li>
<li class="bulletList">Seq: <a href="https://datalust.co/seq">https://datalust.co/seq</a></li>
<li class="bulletList">ELK Stack: <a href="https://www.elastic.co/elastic-stack/">https://www.elastic.co/elastic-stack/</a></li>
<li class="bulletList">Prometheus: <a href="https://prometheus.io/">https://prometheus.io/</a></li>
<li class="bulletList">Grafana: <a href="https://grafana.com/">https://grafana.com/</a></li>
<li class="bulletList">Jaeger: <a href="https://www.jaegertracing.io/">https://www.jaegertracing.io/</a></li>
<li class="bulletList">Zipkin: <a href="https://zipkin.io/">https://zipkin.io/</a></li>
<li class="bulletList">Datadog: <a href="https://www.datadoghq.com/">https://www.datadoghq.com/</a></li>
<li class="bulletList">New Relic: <a href="https://newrelic.com/">https://newrelic.com/</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-231"><a id="_idTextAnchor331"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/PSMCSharp">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>
</body></html>