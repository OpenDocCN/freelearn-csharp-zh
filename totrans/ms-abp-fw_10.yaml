- en: '*Chapter 8*: Using the Features and Services of ABP'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ABP Framework is a full-stack application development framework, so it has many
    building blocks for every aspect of an enterprise solution. In the last three
    chapters, we have explored the fundamental services, data access infrastructure,
    and cross-cutting concern solutions provided by ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this final chapter of *Part 2*, *Fundamentals of ABP Framework*, we will
    continue with some ABP features frequently used in business applications, in the
    following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the current user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the data filtering system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the audit logging system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localizing the **user interface** (**UI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow and try the examples, you need to install an **integrated
    development environment** (**IDE**)/editor (such as Visual Studio) to build ASP.NET
    Core projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the current user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application requires user authentication for some functionalities, you
    generally need to get information about the current user. ABP provides the `ICurrentUser`
    service to obtain detailed information for the currently logged-in user. For web
    applications, the implementation of `ICurrentUser` is completely integrated with
    ASP.NET Core's authentication system, so you can easily get claims of the current
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following code block for simple usage of the `ICurrentUser` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `MyService` constructor injects the `ICurrentUser` service,
    then gets the unique `Id`, `Username`, and `Email` values of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the properties of the `ICurrentUser` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsAuthenticated` (`bool`): Returns `true` if the current user has logged in
    (authenticated).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Id` (`Guid?`): The `null` if the current user has not logged in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserName` (`string`): Username of the current user. Returns `null` if the
    current user has not logged in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TenantId` (`Guid?`): Tenant ID of the current user. It is usable for multi-tenant applications.
    Returns `null` if the current user is not related to a tenant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email` (`string`): Email address of the current user. Returns `null` if the
    current user has not logged in or has not set an email address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailVerified` (`bool`): Returns `true` if the current user''s email address
    has been verified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhoneNumber` (`string`): Phone number of the current user. Returns `null`
    if the current user has not logged in or has not set a phone number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhoneNumberVerified` (`bool`): Returns `true` if the current user''s phone
    number has been verified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Roles` (`string[]`): All roles of the current user as a string array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting the ICurrentUser Service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ICurrentUser` is a widely used service. Thus, some base ABP classes (such
    as `ApplicationService` and `AbpController`) provide it pre-injected. In these
    classes, you can directly use the `CurrentUser` property instead of manually injecting
    this service.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ABP can work with any authentication provider since it works with the current
    claims that are provided by ASP.NET Core. **Claims** are key-value pairs issued
    on user login and stored in the authentication ticket. If you are using cookie-based
    authentication, they are stored in a cookie and sent to the server in every request.
    If you are using token-based authentication, they are sent by the client in every
    request, typically in the **HyperText Transfer Protocol** (**HTTP**) header.
  prefs: []
  type: TYPE_NORMAL
- en: The `ICurrentUser` service gets all the information from the current claims.
    If you want to query the current claims directly, you can use the `FindClaim`,
    `FindClaims`, and `GetAllClaims` methods. These methods are especially useful
    if you create your own custom claims.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom claims
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ABP provides an easy way to add your custom claims to the authentication ticket
    so that you can safely get these custom values on the next requests of the same
    user. You can implement the `IAbpClaimsPrincipalContributor` interface to add
    custom claims to the authentication ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are adding social security number information—a
    custom claim—to the authentication ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are first getting the `ClaimsIdentity` and finding the current
    user's ID. Then, we are getting the social security number from `IUserService`,
    which is a custom service that you should develop yourself. You can get any service
    from the `ServiceProvider` to query the data that you need. Finally, we are adding
    a new `Claim` to the `identity`. `SocialSecurityNumberClaimsPrincipalContributor`
    is then used whenever a user logs in to the application.
  prefs: []
  type: TYPE_NORMAL
- en: You can use custom claims to authorize the current user for specific business
    requirements, filter data, or just show on the UI. Notice that authentication
    ticket claims cannot be changed unless you invalidate the authentication ticket
    and force the user to re-authenticate, so do not store frequently changed data
    in the claims. You can use the caching system (which will be introduced in the
    *Caching data* section) if your purpose is to store user data where it can be
    quickly accessed later.
  prefs: []
  type: TYPE_NORMAL
- en: '`ICurrentUser` is a core service that you frequently use in your application
    code. The next section introduces the data filtering system that seamlessly works
    most of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the data filtering system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtering data in a query is very common in database operations. If you are
    using `WHERE` clause. If you are using `Where` extension method in C#. While most
    of these filtering conditions vary in your queries, some expressions are applied
    to all queries you run if you implement patterns such as soft-delete and multi-tenancy.
  prefs: []
  type: TYPE_NORMAL
- en: ABP automates the data filtering process to help you avoid repeating the same
    filtering logic everywhere in your application code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first see the pre-built data filters of ABP Framework,
    then learn how to disable the filters when we need to. Finally, we will see how
    to implement our custom data filters.
  prefs: []
  type: TYPE_NORMAL
- en: We typically use simple interfaces to enable filtering for entities. ABP defines
    two pre-defined data filters to implement soft-delete and multi-tenancy patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The soft-delete data filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use the soft-delete pattern for an entity, you never delete the entity
    in the database physically. Instead, you mark it as *deleted*.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP defines the `ISoftDelete` interface to standardize the property to mark
    an entity as soft-delete. You can implement that interface for an entity, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Order` entity, in this example, has an `IsDeleted` property that is defined
    by the `ISoftDelete` interface. Once you implement that interface, ABP automates
    the following tasks for you:'
  prefs: []
  type: TYPE_NORMAL
- en: When you delete an order, ABP identifies that the `Order` entity implements
    the soft-delete pattern, prevents the deletion, and sets `IsDeleted` to `true`.
    So, the order is not physically deleted in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you query orders, ABP automatically filters deleted entities (by adding
    an `IsDeleted == false` condition to the query) to avoid accidentally retrieving
    deleted orders from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data filtering is related to queries, so, the first task is not directly related
    to data filtering but is a supporting logic implemented by ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Data Filtering Limitations
  prefs: []
  type: TYPE_NORMAL
- en: The data filtering automation only works when you use repositories or `DbContext`
    (for `DELETE` or `SELECT` command, you should handle this yourself because ABP
    cannot intercept your operation in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: The soft-delete filter is one of the built-in ABP data filters. Another built-in
    filter is for multi-tenancy.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-tenancy data filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multi-tenancy is a widely used pattern to share resources between tenants in
    **software-as-a-service** (**SaaS**) solutions. It is essential to isolate the
    data between different tenants in a multi-tenant application. One tenant cannot
    read or write to another tenant's data, even if they are located in the same physical
    database.
  prefs: []
  type: TYPE_NORMAL
- en: ABP has a complete multi-tenant system, which will be explained in detail in
    [*Chapter 16*](B17287_16_Epub_AM.xhtml#_idTextAnchor457), *Implementing Multi-Tenancy*.
    However, it would be good to mention the multi-tenancy filter here since it is
    related to the data filtering system.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP defines the `IMultiTenant` interface to enable the multi-tenancy data filter
    for an entity. We can implement that interface for an entity, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `IMultiTenant` interface defines the `TenantId` property, as shown in this
    example. ABP uses `Guid` values for tenant IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Once we implement the `IMultiTenant` interface, ABP automatically filters all
    queries for the `Order` entity using the ID of the current tenant. The current
    tenant's ID is obtained from the `ICurrentTenant` service, which will be explained
    in [*Chapter 16*](B17287_16_Epub_AM.xhtml#_idTextAnchor457), *Implementing Multi-Tenancy*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Multiple Data Filters
  prefs: []
  type: TYPE_NORMAL
- en: Multiple data filters can be enabled for the same entity. For example, the `Order`
    entity defined in this section could implement both the `ISoftDelete` and `IMultiTenant`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: As you see, implementing a data filter for an entity is pretty easy—just implement
    the interface related to the data filter. All data filters are enabled by default
    unless you explicitly disable them.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling a data filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Disabling an automatic filter can be necessary in some cases—for example, you
    may want to disable the soft-delete filter to read deleted entities from the database,
    or maybe you want to allow the user to recover deleted entities. You may want
    to disable the multi-tenancy filter to query data from all the tenants in a multi-tenant
    system. For whatever reason, ABP provides an easy and safe way to disable a data
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to get all the orders from the database, including
    deleted ones, by disabling the `ISoftDelete` data filter using the `IDataFilter`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`OrderService`, in this example, injects the `Order` repository and the `IdataFilter`
    service. It then uses the `_dataFilter.Disable<IsoftDelete>()` expression to disable
    the soft-delete filter. In the `using` statement, the filter is disabled, and
    we can query deleted orders too.'
  prefs: []
  type: TYPE_NORMAL
- en: Always Use a using Statement
  prefs: []
  type: TYPE_NORMAL
- en: The `Disable` method returns a disposable object so that we can use it in a
    `using` statement. Once the `using` block ends, the filter automatically turns
    back to the previous state, which means that if it was enabled before that `using`
    block, it returns to the enabled state. If it was already disabled before the
    `using` statement, the `Disable` method does not affect it, and it remains disabled
    after the `using` statement. This system allows us to safely disable a filter
    without affecting any logic that calls the `GetAllOrders` method. It is always
    recommended to disable a filter in a `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '`IdataFilter` service provides two more methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enable<Tfilter>`: Enables a data filter. You can use this to temporarily enable
    a data filter in a scope in which the filter was disabled. It has no effect if
    the filter is already enabled. It is always recommended to enable a filter in
    a `using` statement, just as with the `Disable` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsEnabled<Tfilter>`: Returns `true` if the given filter is currently enabled.
    You generally do not need this method since `Enable` and `Disable` work as expected
    in both cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've learned how to use the `Disable` and `Enable` pre-built data filters.
    The next section shows how to create custom data filters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom data filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as with pre-built data filters, you may want to define your own filters.
    A data filter is represented by an interface, so the first step is to define an
    interface for your filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you want to archive your entities and automatically filter the
    archived data to not retrieve them into the application by default. For this example,
    we can define such a simple interface (you can define this in your domain layer),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsArchived` property will be used to filter the entities. Entities with
    `IsArchived` is `true` will be eliminated by default. Once we define such an interface,
    we can implement it for the entities that can be archived. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Order` entity, in this example, implements the `Iarchivable` interface,
    which makes it possible to apply the data filter on that entity.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Iarchivable` interface doesn't define a setter for `IsArchived`,
    but the `Order` entity defines it. That is my design decision; we don't need to
    set `IsArchived` over the interface, but we need to set it on the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since data filtering is done at the database provider level, custom filter
    implementation also depends on the database provider. This section will show how
    to implement the `Iarchivable` filter for the EF Core provider. If you are looking
    for MongoDB, please refer to ABP''s documentation: [https://docs.abp.io/en/abp/latest/Data-Filtering](https://docs.abp.io/en/abp/latest/Data-Filtering).'
  prefs: []
  type: TYPE_NORMAL
- en: ABP uses EF Core's `DbContext` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to define a property in your `DbContext` class that will
    be used in the filter expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This property directly uses the `IdataFilter` service to get the filter state.
    The `DataFilter` property comes from the base `AbpDbContext` class, and it can
    be `null` if the `DbContext` instance was not resolved from the `null` check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to override the `ShouldFilterEntity` method to decide if a
    given entity type should be filtered or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ABP Framework calls this method for each entity type in this `DbContext` class
    (it is called only once—the first time the `DbContext` class is used after an
    application start). If this method returns `true`, it enables the EF Core global
    filters for that entity. Here, I just checked if the given entity implemented
    the `IArchivable` interface and returned `true` in that case. Otherwise, call
    the `base` method so that it checks for other data filters.
  prefs: []
  type: TYPE_NORMAL
- en: '`ShouldFilterEntity` only decides to enable filtering or not. The actual filtering
    logic should be implemented by overriding the `CreateFilterExpression` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The implementation seems a bit complicated because it creates and combines expressions.
    The important part is how the `archiveFilter` expression was defined. `!IsArchiveFilterEnabled`
    checks if the filter is disabled. If the filter is disabled, then the other condition
    is not evaluated, and all the entities are retrieved without filtering. `!EF.Property<bool>(e,
    "IsArchived")` checks if the `IsArchived` value is `false` for that entity, so
    it eliminates entities with `IsArchived` as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen from the preceding code block, I haven't used the `Order` entity
    in the filter implementation. That means the implementation is generic and can
    work with any entity type—all you need is to implement the `IArchivable` interface
    for the entity that you want to apply the filter for.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, ABP allows us to create and control global query filters easily.
    It also uses that system to implement two popular patterns—soft-delete and multi-tenancy.
    The next section introduces the audit logging system, ABP's other feature that
    is very common in enterprise software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the audit logging system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ABP's audit logging system tracks all requests and entity changes and writes
    them into a database. Then, you can get a report of what was done in your application,
    when it was made, and who did it.
  prefs: []
  type: TYPE_NORMAL
- en: The audit log system is installed and properly configured when you create a
    new solution from the startup templates. Most of the time, you use it without
    any configuration. However, ABP allows you to control, customize, and extend the
    audit logging system. But first, let's understand what an audit log object is.
  prefs: []
  type: TYPE_NORMAL
- en: Audit log object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An audit log object is a group of actions and related entity changes performed
    together in a limited scope, typically in an HTTP request for a web application.
    We will talk more about audit log scopes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 8.1* represents an audit log object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Audit log object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Audit log object
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain that diagram by beginning from the root object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuditLogInfo`: In every scope (typically, a web request), there is one `AuditLogInfo`
    object that contains information about the current user, current tenant, HTTP
    request, client and browser details, and execution time and duration of the operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuditLogActionInfo`: In every audit log, there may be zero or more actions.
    An action is typically a controller action call, a page handler call, or an application
    service method call. It includes the class name, method name, and method arguments
    in that call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntityChangeInfo`: An audit log object may contain zero or more changes on
    the entities in the database. Each entity change contains the change type (created,
    updated, or deleted), entity type (full class name), and ID of the changed entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntityPropertyChangeInfo`: For every entity change, it logs the changes on
    the properties (fields in the database). This object contains the name, type,
    old value, and the new value of the affected property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception`: A list of exceptions occurred during this audit log scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comment`: Additional comments/logs related to this audit log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The audit log object is saved into multiple tables in a relational database:
    `AbpAuditLogs`, `AbpAuditLogActions`, `AbpEntityChanges`, and `AbpEntityPropertyChanges`.
    I''ve written the fundamental properties of the audit log object in the previous
    list. You can check these database tables or investigate the `AuditLogInfo` object
    to see all the details.'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB Limitation
  prefs: []
  type: TYPE_NORMAL
- en: Entity changes are not logged for MongoDB since ABP uses EF Core's change-tracking
    system to get the entity change information, and the MongoDB driver has no such
    change-tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this section, an audit log object is created
    per audit log scope.
  prefs: []
  type: TYPE_NORMAL
- en: Audit log scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The audit log scope uses the **Ambient Context Pattern**. When you create a
    new audit log scope, all actions and changes made in this scope are saved as a
    single audit log object.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to establish an audit log scope.
  prefs: []
  type: TYPE_NORMAL
- en: Audit log middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first and the most common way to create an audit log scope is to use the
    audit log middleware in the ASP.NET Core pipeline configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is typically placed before the `app.UseEndpoints()` or `app.UseConfiguredEndpoints()`
    endpoint configuration. When you use this middleware, every HTTP request writes
    a separate audit log record, which is the wanted behavior most of the time and
    is already configured in the startup templates by default.
  prefs: []
  type: TYPE_NORMAL
- en: Audit log interceptor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't use the audit log middleware or if your application is not a request/reply-style
    ASP.NET Core application (for example, a desktop or Blazor Server application),
    then ABP creates a new audit log scope per application service method.
  prefs: []
  type: TYPE_NORMAL
- en: Manually creating audit scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You typically won''t need to do this, but if you want to create an audit scope
    manually, you can use the `IAuditingManager` service, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once you inject the `IAuditingManager` service, you can use the `BeginScope`
    method to create a new scope. Then, create a `try`-`catch` block to save the audit
    log, including exception cases. In the `try` section, you can just perform your
    logic, call any other service, and so on. All these operations and the changes
    in these operations are saved as a single audit log object in the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: Inside an audit log scope (regardless of whether it is created by ABP or manually
    by you), `_auditingManager.Current.Log` can be used to get the current audit log
    object to investigate or manipulate it (for example, add comment lines or additional
    information). If you are not in an audit log scope, then `_auditingManager.Current`
    returns `null`, so check for `null` if you are unsure as to whether there is a
    surrounding audit log scope.
  prefs: []
  type: TYPE_NORMAL
- en: I've introduced the audit log object and audit log scopes, which work seamlessly
    by default. Now, let's see options to understand the defaults and the global configuration
    possibilities for the audit log system.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AbpAuditingOptions` class is used to configure default options for the
    auditing system. It can be configured using the standard `options` pattern, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can configure `options` inside the `ConfigureServices` method of your module.
    See the following list for the main options for the auditing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsEnabled` (`bool`; default: `true`): The main point to completely disable
    the auditing system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsEnabledForGetRequests` (`bool`; default: `false`): ABP does not save audit
    logs for HTTP `GET` requests by default because `GET` requests are not supposed
    to change the database. However, you can set this to `true`, which enables audit
    logging for `GET` requests too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsEnabledForAnonymousUsers` (`bool`; default: `true`): Set this to `false`
    if you want to write audit logs only for authenticated users. If you save audit
    logs for anonymous users, you will see `null` for `UserId` values for these users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlwaysLogOnException` (`bool`; default: `true`): If an exception occurs in
    your application code, ABP saves the audit log by default, without considering
    the `IsEnabledForGetRequests` and `IsEnabledForAnonymousUsers` options. Set this
    to `false` to disable that behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hideErrors` (`bool`; default: `true`): ABP ignores exceptions while saving
    audit log objects to the database. Set this to `false` to throw exceptions instead
    of hiding them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationName` (`string`; default: `null`): If multiple applications are
    using the same database to save the audit logs, you can set this option in each
    application so that you can filter the logs based on the application name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IgnoredTypes` (`List<Type>`): You can ignore some specific types in the audit
    log system, including entity types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these simple global options, you can enable/disable change tracking
    for entities.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling entity histories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The audit log object contains entity changes with property details. However,
    it is disabled for all entities by default because it may write too many logs
    into the database, which may rapidly increase the database size. It is suggested
    to enable it in a controlled way for the entities you want to track.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to enable entity histories for entities, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `[Auditing]` attribute is used to enable it for a single entity. It will
    be explained in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EntityHistorySelectors` option is used to enable it for multiple entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, I''ve enabled the `EntityHistorySelectors` option
    for all entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddAllEntities` method is a shortcut. `EntityHistorySelectors` is a list
    of named selectors, and you can add a lambda expression to select the entities
    you want. The following code is equivalent to the preceding configuration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of `NamedTypeSelector` is the selector name—`MySelectorName`,
    for this example. Selector names are arbitrary, and they can be used later to
    find or remove a selector from the selector list. You typically don't use it;
    just give it a unique name. The second argument of `NamedTypeSelector` takes an
    expression. It gives you an entity `type` and waits for `true` or `false`. Returns
    `true`, if you want to enable entity histories for a given entity type. So, you
    can pass an expression such as `type => type.Namespace.StartsWith("MyRootNamespace")`
    to select all entities with a namespace. You can add as many selectors as you
    need. All selectors are tested. If one of them returns `true`, the entity is selected
    for logging property changes.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these global options and selectors, there are ways to enable/disable
    audit logging per class, method, and property level.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling and enabling audit logging in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the audit log system, you typically want to log every access.
    However, in some cases, you may want to disable audit logging for some specific
    actions or entities. Here are some potential reasons for that: the action parameters
    may be dangerous to write into the logs (for example, it may contain the user''s
    password), the action call or entity change might be out of the user''s control,
    so it isn''t worth recording for audit purposes, or the operation can be a bulk
    operation that writes too many audit logs and decreases performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP defines the `[DisableAuditing]` and `[Audited]` attributes to control logged
    objects declaratively. There are two targets that you can control for audit logging:
    service calls and entity histories.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling audit logging for service calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application service methods, Razor Page handlers, and `[DisableAuditing]` attribute
    at the class or method level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `[DisableAuditing]` attribute on an application
    service class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With this usage, ABP won''t include the execution of these methods into the
    audit log object. If you just want to disable one of the methods, you can use
    it at the method level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `CreateAsync` method call is not included in the audit log,
    while the `DeleteAsync` method call is written into the audit log object. The
    same behavior could be accomplished using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I disabled audit logging for all methods except the `DeleteAsync` method because
    the `DeleteAsync` method declares the `[Audited]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Audited]` attribute can be used on any class (used with the DI system)
    to enable audit logging on that class, even if the class is not audit-logged by
    default. Moreover, you can use it in any method of any class to just enable it
    for that particular method call. If you use the `[Audited]` attribute on a class,
    you can then disable a specific method using the `[DisableAuditing]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'When ABP includes a method call information in the audit log object, it also
    includes all the parameters of the executed method. That is super-useful to understand
    which changes were made in your system; however, you may want to exclude some
    properties of the input in some cases. Consider a scenario that you get credit
    card information from the user. You probably don''t want to include this in the
    audit logs. You can use the `[DisableAuditing]` attribute on any property of an
    input object in such a case. See the following example, which excludes a property
    of a `Dto` input from the audit log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For this example, ABP won't write the `CreditCardNumber` value into the audit
    log.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling audit logging for method calls won't affect the entity histories.
    If an entity is changed and it was selected for audit logging, changes are still
    logged. The next section explains how to control the audit logging system for
    entity histories.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling audit logging for entity histories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the *Enabling entity histories* section, we saw how to enable entity histories
    for one or more entities by defining selectors. However, if you want to enable
    the entity histories for a single entity, there is an alternative and simpler
    way: just add the `[Audited]` attribute above your entity class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, I added the `[Audited]` attribute to an `Order` entity to configure
    the audit logging system to enable entity histories for this entity.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you've used selectors to enable entity histories for many or all entities
    but want to disable them for a specific entity. In that case, you can use the
    `[DisableAuditing]` attribute for that entity class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[DisableAuditing]` attribute can also be used on a property of an entity
    to exclude this property from the audit logs, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For that example, ABP won't write the `CreditCardNumber` value into the audit
    log.
  prefs: []
  type: TYPE_NORMAL
- en: Storing audit logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The core of the ABP Framework has been designed to not assume any data store
    by introducing abstractions wherever it needs to touch a data source. The audit
    logging system is not an exception. It defines the `IAuditingStore` interface
    to abstract where the audit log objects are saved. That interface only has a single
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can implement this interface to save audit logs where you want. If you use
    ABP's startup templates to create a new solution, it is configured to save audit
    logs to the application's main database, so you normally don't have to implement
    the `IAuditingStore` interface manually.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen different ways to control and customize the audit log system. Audit
    logging is an essential system for enterprise systems to track and log changes
    in your system. The next section introduces the caching system, another essential
    feature of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is one of the most fundamental systems to improve your application's
    performance and scalability. ABP extends ASP.NET Core's **distributed caching**
    system and makes it compatible with other features of ABP Framework, such as multi-tenancy.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed caching is essential if you run multiple instances of your application
    or have a distributed system, such as a microservice solution. It provides consistency
    between different applications and allows the sharing of cached values. A distributed
    cache is typically an external, standalone application, such as Redis and Memcached.
  prefs: []
  type: TYPE_NORMAL
- en: It is suggested to use the distributed caching system even if your application
    has a single running instance. Don't worry about the performance since the default
    implementation of distributed cache works in memory. That means it is not distributed
    unless you explicitly configure a real distributed cache provider, such as Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Caching in ASP.NET Core
  prefs: []
  type: TYPE_NORMAL
- en: 'This section focuses on ABP''s caching features and doesn''t cover all ASP.NET
    Core''s distributed caching system features. You can refer to Microsoft''s documentation
    to learn more about distributed caching in ASP.NET Core: [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will show you how to use the `IDistributedCache<T>` interface,
    configure options, and deal with error handling and batch operations. We will
    also learn about using Redis as the distributed cache provider. Finally, I will
    talk about invalidating cached values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start from the basics—the `IDistributedCache<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Using the IDistributedCache<T> interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core defines an `IDistributedCache` interface, but it is not type-safe.
    It sets and gets `byte` arrays rather than objects. ABP''s `IDistributedCache<T>`
    interface, on the other hand, is designed as generic with type-safe method parameters
    (`T` stands for the type of items stored in the cache). It internally uses the
    standard `IDistributedCache` interface to be 100% compatible with ASP.NET Core''s
    caching system. ABP''s `IDistributedCache<T>` interface has two main advantages,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically serializes/deserializes the objects to `byte` arrays. So, you
    don't deal with serialization and deserialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It automatically adds the cache name prefix to the cache keys to allow the use
    of the same key for different kinds of cache objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first step in using the `IDistributedCache<T>` interface is to define a
    class to represent items in the cache. I''ve defined the following class to store
    a user''s information in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That is a plain C# class. The only restriction is that it should be serializable
    because it is serialized to JSON while saving to the cache and deserialized while
    reading from the cache (for example, do not add references to other objects that
    should not or cannot be stored in the cache; keep it simple).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve defined the cache item class, we can inject the `IDistributedCache<T>`
    interface, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve injected the `IDistributedCache<UserCacheItem>` service to work with
    the distributed cache for `UserCacheItem` objects. The following code block shows
    how we can use it to get cached user information and fall back to the database
    query if the given user was not found in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve passed three parameters to the `GetOrAddAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the cache key, which should be a string value, so I converted
    the `Guid` `userId` value to a string value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is a factory method that is executed if the given key is
    not found in the cache. I passed the `GetUserFromDatabaseAsync` method here. In
    that method, you should build the cache item from its data source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final parameter is a factory method that returns a `DistributedCacheEntryOptions`
    object. This is optional and configures the expiration time for the cached item.
    The factory method is only called if the `GetOrAddAsync` method adds the entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache keys are `string` data types by default. However, ABP defines another
    interface, `IDistributedCache<TCacheItem, TCacheKey>`, allowing you to specify
    the cache key so that you don't need to convert your keys to `string` data types
    manually. We could inject the `IDistributedCache<UserCacheItem, Guid>` service
    and remove the `ToString()` usage in the first parameter for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '`DistributedCacheEntryOptions` has the following options to control the lifetime
    of the cached item:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbsoluteExpiration`: You can set an absolute time, as we''ve done in this
    example. The item is automatically deleted from the cache at that time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbsoluteExpirationRelativeToNow`: An alternative way to set the absolute expiration
    time. We could rewrite the option in this example so that it reads `AbsoluteExpirationRelativeToNow
    = TimeSpan.FromHours(1)`. The result will be the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SlidingExpiration`: Sets how long the cache item can be inactive (not accessed)
    before it is removed. This means that if you continue to access the cached item,
    the expiration time is automatically extended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you don''t pass the expiration time parameter, the default value is used.
    You can configure the default value and some other global options using the `AbpDistributedCacheOptions`
    class explained in the next section. Before that, let''s see the other methods
    of the `IDistributedCache<UserCacheItem>` service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetAsync` is used to read data from the cache with a cache key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetAsync` is used to save an item to the cache. It overwrites the existing
    value if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RefreshAsync` is used to reset the sliding expiration time for the given key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveAsync` is used to delete an item from the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About Synchronous Cache Methods
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the methods also have synchronous versions, such as the `GET` method for
    the `GetAsync` method. However, it is suggested to use the asynchronous version
    wherever possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These methods are the standard methods of ASP.NET Core. ABP adds methods to
    work with multiple items for each method, such as `GetManyAsync` for `GetAsync`.
    Working with `Many` methods has a significant performance gain if you have a lot
    of items to read or write. The `GetOrAddAsync` method (used in the `GetUserInfoAsync`
    example in this section) is also defined by ABP Framework to safely read a cache
    value, fall back to the original data source, and set the cache value in a single
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring cache options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AbpDistributedCacheOptions` is the main options class to configure the caching
    system. You can configure it in the `ConfigureServices` method of your module
    class (you can do this in the domain or application layers), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I've configured the `GlobalCacheEntryOptions` property to configure the default
    cache expiration time to `2` hours in this code block.
  prefs: []
  type: TYPE_NORMAL
- en: '`AbpDistributedCacheOptions` has some other properties too, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KeyPrefix` (`string`; default: `null`): A prefix value that is added to the
    beginning of all cache keys for that application. This option can be used to isolate
    your application''s cache items when using a distributed cache shared by multiple
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hideErrors` (`bool`; default: `true`): A value to control the default value
    of error handling on cache service methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you've seen in the previous examples, these options can be overridden by
    passing parameters to the methods of the `IDistributedCache` service.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use an external process (such as Redis) for distributed caching, it
    is probable to have problems while reading data from and writing data to the cache.
    The cache server may be offline, or we may have temporary network problems. These
    temporary problems can be ignored most of the time, especially while trying to
    read data from the cache. You can safely try to read from the original data source
    if the cache service is not available at the moment. It may be slower but is better
    than throwing an exception and failing the current request.
  prefs: []
  type: TYPE_NORMAL
- en: All the `IDistributedCache<T>` methods get an optional `hideErrors` parameter
    to control the exception-handling behavior. If you pass `false`, then all the
    exceptions are thrown. If you pass `true`, then ABP hides cache-related errors.
    If you don't specify a value, the default value is used, as explained in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cache in a multi-tenancy application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your application is multi-tenant, ABP automatically adds the current tenant's
    ID to the cache key to distinguish between cache values of different tenants.
    In this way, it provides isolation between tenants.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a cache that is shared between tenants, you can use the
    `[IgnoreMultiTenancy]` attribute for the cache item class, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For this example, `MyCacheItem` values can be accessed by different tenants.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis as the distributed cache provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is a popular tool that is used as a distributed cache. ASP.NET Core provides
    a cache integration package for Redis. You can use it by following Microsoft's
    documentation ([https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed)),
    and it works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP also provides a Redis integration package that extends Microsoft''s integration
    to support the batch operations (such as `GetManyAsync`, mentioned in the *Using
    the IDistributedCache<T> interface* section). So, it is suggested to use ABP''s
    integration `Volo.Abp.Caching.StackExchangeRedis` NuGet package to use Redis as
    the cache provider. You can install it using the ABP **command-line interface**
    (**CLI**) with the following command in the directory of the project you want
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, all you need to do is to add a configuration to the
    `appsettings.json` file to connect to the Redis server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You write the server address and port (a connection string) to the `Configuration`
    option. Please see Microsoft''s documentation for details of the configuration:
    [https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed).'
  prefs: []
  type: TYPE_NORMAL
- en: Invalidating cache values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a popular saying that cache invalidation is one of the two hard problems
    in computer science (the other one is naming things). A cached value is typically
    a duplication of data originally located somewhere costly to read frequently or
    a computed value that is costly to recalculate. In such cases, it increases performance
    and scalability, but the problem begins when the original data changes and makes
    the cached value outdated. We should carefully watch these changes and remove
    or refresh the related data in the cache. That is called cache invalidation.
  prefs: []
  type: TYPE_NORMAL
- en: The cache invalidation process depends greatly on the cached data and your application
    logic. However, there are some specific cases where ABP can help you to invalidate
    cached data.
  prefs: []
  type: TYPE_NORMAL
- en: 'One specific case is that we may want to invalidate a cache item when an entity
    has changed (is updated or deleted). For this case, we can register for events
    published by ABP Framework. The following code invalidates a user cache item when
    the related user entity changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`MyUserService` registers for an `EntityChangedEventData<IdentityUser>` local
    event. This event is triggered when a new `IdentityUser` entity is created or
    an existing `IdentityUser` entity is updated or deleted. The `HandleEventAsync`
    method is called in that case with the related entity in the `data.Entity` property.
    This method simply removes the user from the cache with the `Id` value of the
    changed entity.'
  prefs: []
  type: TYPE_NORMAL
- en: Local events work in the current process. That means the handler class (`MyUserService`
    here) should be in the same process as the entity change.
  prefs: []
  type: TYPE_NORMAL
- en: About the Event Bus System
  prefs: []
  type: TYPE_NORMAL
- en: 'Local and distributed events are interesting features of ABP Framework that
    are not included in this book. See the ABP documentation if you want to learn
    more about them: [https://docs.abp.io/en/abp/latest/Event-Bus](https://docs.abp.io/en/abp/latest/Event-Bus).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to work with the distributed caching system,
    configure options, and deal with error handling. We've also introduced the Redis
    cache provider installation. Finally, we've introduced automatic ABP events that
    can help us to invalidate cached values.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will be related to UI localization, the final ABP feature I
    will introduce in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are building a global product, you probably want to show the UI localized
    on the basis of the current user's language. ASP.NET Core provides a system to
    localize your application's UI. ABP adds some useful features and conventions
    to make it even easier and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how to define the languages that you want to support,
    create text for different languages, and get the correct text for the current
    user. You will understand the localization resource concept and embedded localization
    resource files.
  prefs: []
  type: TYPE_NORMAL
- en: We can begin by defining the languages supported by your application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring supported languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first question about localization is this: *Which languages do you want
    to support on your UI?* ABP provides a simple configuration to define languages,
    using `AbpLocalizationOptions`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can write that code into the `ConfigureServices` method of your module class.
    In fact, that configuration is already done (with a lot of languages) when you
    create a new solution using the ABP application startup templates. You just edit
    the list as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LanguageInfo` constructor takes a few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cultureName`: The culture name (code) for the language, which is set to `CultureInfo.CurrentCulture`
    on runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uiCultureName`: The UI culture name (code) for the language, which is set
    to `CultureInfo.` `CurrentUICulture` on runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayName`: Name of the language that is shown to the user while selecting
    this language. It is suggested to write that name in its original language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flagIcon`: A string value that the UI can use to show a country flag near
    the language name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ABP determines one of these languages based on the current HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the current language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP determines the current language by using the `AbpRequestLocalizationMiddleware`
    class. This is an ASP.NET Core middleware that is added to the ASP.NET Core request
    pipeline with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When the request passes through this middleware, one of the configured languages
    is selected and set to `CultureInfo.CurrentCulture` and `CultureInfo.CurrentUICulture`.
    These are the standard systems of .NET to set and get the current culture in localization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current language is selected based on the following HTTP request parameters
    in the given priority order:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `culture` query string parameter is set, it is used to determine the
    current language. An example is `http://localhost:5000/?culture=en-US`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `.AspNetCore.Culture` cookie value is set, then it is used as the current
    language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `Accept-Language` HTTP header is set, it is used as the current language.
    The browser generally sends this last one by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: About ASP.NET Core's Localization System
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The behaviour explained in this section was the default behavior. However,
    ASP.NET Core''s language determination system is more flexible and customizable.
    Please see Microsoft''s documentation for more information: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After defining the languages we want to support, we can define our localization
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a localization resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP is 100% compatible with ASP.NET Core''s localization system. So, you can
    use the `.resx` files as localization resources by following Microsoft''s documentation:
    [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization).
    However, ABP offers a lightweight, flexible, and extensible way to define localized
    texts using simple JSON files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new solution using the ABP startup templates, the `Domain.Shared`
    project contains the localization resource of the application with the localization
    JSON files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Localization resource and localization JSON files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Localization resource and localization JSON files
  prefs: []
  type: TYPE_NORMAL
- en: For this example, the `DemoAppResource` class represents the localization resource.
    An application can have more than one localization resource, and each defines
    its own JSON files. You can think of a localization resource as a group of localization
    texts. It helps to build modular systems where each module has its own localization
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'A localization resource class is an empty class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This class refers to the related resource when you want to use texts in that
    localization resource. The `LocalizationResourceName` attribute sets a string
    name to the resource. Every localization resource has a unique name that is used
    in the client-side code to refer to the resource. We will explore client-side
    localization in *Using localization in the client side* section.
  prefs: []
  type: TYPE_NORMAL
- en: Default Localization Resource of the Application
  prefs: []
  type: TYPE_NORMAL
- en: You typically have a single (default) localization resource in your application
    that comes with the startup template when creating a new ABP solution. The default
    localization resource class's name starts with the project name—for example, `ProductManagementResource`
    if you've specified `ProductManagement` as the project name.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a localization resource, we can create a JSON file for each language
    we support.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the localization JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A localization file is a simple JSON-formatted file, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two main root elements in that file, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`culture`: The culture code for the related language. It matches the culture
    code that was introduced in *Configuring the supported languages* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`texts`: Contains key-value pairs for the localization texts. The key is used
    to access the localized texts and should be the same in all JSON files of different
    languages. The value is the localized text for the current culture (language).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After defining localization texts for each language, we can request localized
    texts at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Getting localized texts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core defines an `IStringLocalizer<T>` interface to get the localized
    texts in the current culture, where `T` stands for the localization resource class.
    You can inject that interface into your class, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, the `LocalizationDemoService` class injects the
    `IStringLocalizer<DemoAppResource>` service, which is used to access localized
    texts for the `DemoAppResource` class. In the `GetWelcomeMessage` method, we simply
    get the localized text for the `WelcomeMessage` key. If the current language is
    English, it returns `Welcome to the application.`, as we defined in the JSON file
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We can pass parameters while localizing text.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized texts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Localization texts can contain parameters, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters can be passed to the localizer, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The given name for this example replaces the `{0}` placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: The fallback logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The localization system uses fallbacks to parent or default cultures when the
    requested text is not found in the current culture's JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume that you''ve requested to get a `WelcomeMessage` text while
    the current culture (`CultureInfo.CurrentUICulture`) is `de-DE` (German–Germany).
    In that case, one of the following scenarios occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t defined a JSON file with `"culture": "de-DE"` or you have defined
    a JSON file but it doesn''t contain the `WelcomeMessage` key, then it falls back
    to the parent culture (`"de"`), tries to find the given key in that culture, and
    returns it if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is not found in the parent culture, it falls back to the default culture
    of the localization resource (see the next section to configure the default culture).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is not found in the default culture, then the given key (`WelcomeMessage`,
    for this example) is returned as the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring localization resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A localization resource should be added to `AbpLocalizationOptions` before
    using it. This configuration is already done in the startup template with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Localization JSON files are generally defined as embedded resources. We are
    configuring ABP's virtual filesystem (using the `AbpVirtualFileSystemOptions`)
    to add all embedded files in that assembly into the virtual filesystem so that
    the localization files are also added.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the second part, we add `DemoAppResource` to the `Resources` dictionary
    so that ABP recognizes it. Here, the `"en"` parameter sets the default culture
    of that localization resource.
  prefs: []
  type: TYPE_NORMAL
- en: ABP's localization system is pretty advanced. It allows you to reuse the texts
    of a localization resource by inheriting the localization resource from another
    localization resource. In this example, we are inheriting `AbpValidationResource`,
    which is defined in ABP Framework and contains standard validation error messages.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddVirtualJson` method is used to set the JSON files related to that resource
    using the virtual filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `DefaultResourceType` sets the default localization resource for that
    application. You can have a default resource used in some places where you don't
    specify the localization resource. The next section explains the main usage point
    of this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing in special services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injecting the `IStringLocalizer<T>` service everywhere can be tedious. ABP pre-injects
    the localizer into some special base classes. When you inherit from these classes,
    you can directly use the `L` shortcut property to localize texts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to localize text in an application service
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `L` property, in this example, is defined by the `ApplicationService` base
    class, so you don't need to inject the `IStringLocalizer<T>` service manually.
    You may wonder, as we haven't specified a localization resource, which one is
    used here. The answer is the `DefaultResourceType` option that was explained in
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to specify another localization resource for a particular application
    service, then set the `LocalizationResource` property in the constructor of your
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `ApplicationService` class, some other common base classes,
    such as `AbpController` and `AbpPageModel`, provide the same `L` property as a
    shortcut of injecting the `IStringLocalizer<T>` service.
  prefs: []
  type: TYPE_NORMAL
- en: Using localization on the client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ABP's benefits for the localization system is that all the localization
    resources are directly usable on the client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code localizes the `WelcomeMessage` key in the JavaScript
    code for an ASP.NET Core MVC/Razor Pages application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`DemoApp` is the localization resource name, and `WelcomeMessage` is the localization
    key here. Client-side localization will be covered in *Part 4*, *User Interface
    and API Development,* of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some essential features that you will need in almost
    any web application.
  prefs: []
  type: TYPE_NORMAL
- en: The `ICurrentUser` service allows you to get information about the current user
    in your application. You can work with the standard claims (such as username and
    ID) and define custom claims based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored the data filtering system that automates filtering data while
    querying from the database. In this way, we can easily implement some patterns
    such as soft-delete and multi-tenancy. We also learned how to define custom data
    filters and disable the filters whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We have understood how the audit log system works to track and save all the
    operations done by users. We can control the audit log system declaratively and
    conventionally with attributes and options.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data is another essential concept to improve the performance and scalability
    of the system. We've learned about ABP's `IDistributedCache<T>` service, which
    provides a type-safe way to interact with the cache provider and automates some
    common tasks such as serialization and exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've explored the localization infrastructure of ASP.NET Core and
    ABP Framework to define and consume localized texts in our applications easily.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have come to the end of this chapter, we've completed *Part 2*, *Fundamentals
    of ABP Framework* of this book, covering ABP Framework and ASP.NET Core infrastructure
    fundamentals. The next part is a practical guide for implementing **domain-driven
    design** (**DDD**) using ABP Framework. DDD is one of the core concepts upon which
    ABP is based. It includes principles, patterns, and practices to build maintainable
    business solutions.
  prefs: []
  type: TYPE_NORMAL
