- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing NoSQL Data Using Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about managing NoSQL data by using Azure Cosmos DB. You will
    learn about some of the key concepts of Cosmos DB like its APIs, ways to model
    your data, and throughput provisioning, which influences costs. You will create
    some Cosmos DB resources using the local emulator and in the Azure cloud. Then
    you will learn how to work with more traditional data using the Core (SQL) API.
  prefs: []
  type: TYPE_NORMAL
- en: In an optional online-only section, you can learn how to work with graph data
    using the Gremlin API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Cosmos DB resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating data with the Core (SQL) API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring server-side programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up Azure resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the most common places to store data are in a **Relational Database Management
    System** (**RDBMS**) such as SQL Server, PostgreSQL, MySQL, and SQLite, or in
    a **NoSQL** database such as Azure Cosmos DB, Redis, MongoDB, and Apache Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases were invented in the 1970s. They are queried with **Structured
    Query Language** (**SQL**). At the time, data storage costs were high, so they
    reduced data duplication as much as possible via a process known as *normalization*.
    Data is stored in tabular structures with rows and columns that are tricky to
    refactor once in production. They can be difficult and expensive to scale.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases do not just mean “no SQL;” they can also mean “not only SQL.”
    They were invented in the 2000s, after the internet and the web had become popular
    and adopted much of the learning from that era of software.
  prefs: []
  type: TYPE_NORMAL
- en: They are designed for massive scalability and high performance, and to make
    programming easier by providing maximum flexibility and allowing schema changes
    at any time because they do not enforce a structure.
  prefs: []
  type: TYPE_NORMAL
- en: Cosmos DB and its APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Cosmos DB is a NoSQL data store that supports multiple APIs. Its native
    API is SQL-based. It also supports alternative APIs like MongoDB, Cassandra, and
    Gremlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB stores data in **atom-record-sequence** (**ARS**) format. You
    interact with this data via an API that you choose when you create the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **API for MongoDB** supports recent MongoDB wire protocol versions, which
    allow existing clients to work with the data as if they are interacting with an
    actual MongoDB database. Tools like `mongodump` and `mongorestore` can be used
    to move any existing data into Azure Cosmos DB. You can check the latest MongoDB
    support at the following link: [https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/mongodb-introduction#how-the-api-works](https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/mongodb-introduction#how-the-api-works).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **API for Cassandra** supports the **Cassandra Query Language** (**CQL**)
    wire protocol version 4, which allows existing clients to work with the data as
    if they are interacting with an actual Cassandra database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a new project, sometimes known as a “green field” project, Microsoft recommends
    the **Core (SQL) API**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For existing projects that use alternative APIs, you could choose to use the
    appropriate API so that your clients and tools do not need to be updated while
    gaining the benefits of data stored in Azure Cosmos DB. This reduces migration
    costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the relationships between data items have metadata that needs analyzing,
    then using the **Gremlin API for Cosmos DB** to treat Cosmos DB as a graph data
    store is a good choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: If you are unsure which API to choose, select Core (SQL)
    as the default.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will first use the native Core (SQL) API for Cosmos DB. This
    allows the developer to query JSON documents using a language like SQL. The Core
    (SQL) API uses JSON’s type system and JavaScript’s function system.
  prefs: []
  type: TYPE_NORMAL
- en: Document modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical JSON document representing a product from the Northwind database,
    the example database that we used in *Chapter 2*, *Managing Relational Data Using
    SQL Server*, when stored in Azure Cosmos DB might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unlike with a relational database model, it is common to **embed** related data,
    which involves duplicating data such as the category and supplier information
    across multiple products. This is good practice if the related data is bounded.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for a product, there will only ever be one supplier and one category,
    so those relationships are bounded to one, which means limited to one each. If
    we were modeling a category and decided to embed its related products, then that
    could be poor practice because having all the product details as an array would
    be unbounded. Instead, we might choose to only store a unique identifier for each
    product and reference the product details stored elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: You should also consider how frequently the related data is updated. The more
    frequently it needs to be updated, the more you should avoid embedding it. If
    related data is unbounded but infrequently updated, then embedding might still
    be a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Deliberately but carefully **denormalizing** parts of your data model implies
    that you will need to execute fewer queries and updates for common operations,
    reducing costs both in money and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use embedding (denormalized data) when:'
  prefs: []
  type: TYPE_NORMAL
- en: The relationships are contained, like property owned by a person, or the children
    of a parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationships are one-to-one or one-to-few, i.e., the related data is bounded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The related data needs infrequent updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The related data often or always needs to be included in query results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Denormalized data models provide better read performance
    but worse write performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you want to model an article and its comments on a popular news
    website. The comments are unbounded and, for an engaging article, would frequently
    be added to, especially during the hours or days after it is published while it
    is topical news. Or imagine an investor with stock they trade. The current price
    of that stock would be frequently updated.
  prefs: []
  type: TYPE_NORMAL
- en: In these scenarios, you would want to **normalize** the related data either
    wholly or partially. For example, you could choose to embed the most liked comments
    that will be shown at the top of the list directly under the article. Other comments
    could be stored separately and referenced using their primary keys. You could
    choose to embed stock information for long-term investments that are held for
    many years, like the price the investment was purchased at and the price on the
    first day of each month since then (but not the live current price), but reference
    stock information for short-term investments for day trading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use referencing (normalized data) when:'
  prefs: []
  type: TYPE_NORMAL
- en: The relationships are one-to-many or many-to-many and unbounded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The related data needs frequent updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Normalized data models require more queries, which worsens
    read performance but provides better write performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about modeling documents in Azure Cosmos DB at the following
    link: [https://learn.microsoft.com/en-us/azure/cosmos-db/sql/modeling-data](https://learn.microsoft.com/en-us/azure/cosmos-db/sql/modeling-data).'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Cosmos DB is distributed globally and scales elastically. It relies on
    replication to provide low latency and high availability all over the world. To
    achieve this, you must accept and choose tradeoffs.
  prefs: []
  type: TYPE_NORMAL
- en: To ease the life of a programmer, you want total consistency of data. If data
    is modified anywhere in the world, then any subsequent read operation should see
    that change. The best consistency is known as **linearizability**. Linearizability
    increases the latency of write operations and reduces the availability of read
    operations because it must wait for replication to occur globally.
  prefs: []
  type: TYPE_NORMAL
- en: A more relaxed consistency level improves latency and availability at the cost
    of potentially increased complexity for the programmer because data might be inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most NoSQL databases only offer two levels of consistency: strong and eventual.
    Azure Cosmos DB offers five to provide exactly the level of consistency that suits
    your project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You choose the level of data consistency, and this will be guaranteed by the
    **Service-Level Agreement** (**SLA**), as shown in the following, ordered from
    the strongest to the weakest:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strong** consistency guarantees linearizability across all regions globally.
    All other consistency levels are collectively known as “relaxed.” You might ask,
    “Why not set Strong consistency in all scenarios?” If you are familiar with relational
    databases, then you should be familiar with transaction isolation levels. These
    are similar conceptually to NoSQL consistency levels. The strongest level of transaction
    isolation level is `SERIALIZABLE`. Weaker levels include `READUNCOMMITTED` and
    `REPEATABLE READ`. You would not want to use `SERIALIZABLE` in all scenarios for
    the same reason you wouldn’t want to use Strong consistency in all scenarios.
    They both slow down operations, and sometimes, to an unacceptable point. Your
    users will complain about a lack of performance, or even an inability to perform
    a task at all. So, you need to look carefully at each task you are attempting
    and determine the minimal required level for that task. Some developers prefer
    to default to the strongest level and weaken it for scenarios that are “too slow.”
    Other developers prefer to default to the weakest level and strengthen it for
    scenarios that introduce too much inconsistency. As you become more familiar with
    NoSQL development, you will be able to judge quicker what level is best for different
    scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounded staleness** consistency guarantees the ability to read your own write
    within the write region, monotonic read within the region (meaning the values
    do not increase or decrease, like a monotone voice, and remain in a consistent
    order), and consistent prefix, and the staleness of read data is restricted to
    a specific number of versions for which the reads lag behind the writes within
    a specified time interval. For example, the time interval might be ten minutes
    and the number of versions might be three. That would mean that a maximum of three
    writes can be made in any ten-minute period before a read operation must reflect
    those changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session** consistency guarantees the ability to read your own write within
    the write region, monotonic read, and consistent prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent prefix** consistency only guarantees the order that writes can
    then be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eventual** consistency does not guarantee that the order of writes will match
    the order of reads. When writes pause, reads will eventually catch up as the replicas
    synchronize. It is possible for a client to read values older than the ones it
    read before. **Probabilistic Bounded Staleness** (**PBS**) is a measurement that
    shows how eventual your consistency is currently. You can monitor it in the Azure
    portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more details about consistency levels at the following link: [https://learn.microsoft.com/en-us/azure/cosmos-db/consistency-levels](https://learn.microsoft.com/en-us/azure/cosmos-db/consistency-levels).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hierarchy of components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hierarchy of components for Azure Cosmos DB is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Account**: You can create up to 50 accounts via the Azure portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: You can have an unlimited number of databases per account. We
    will create a database named `Northwind`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: You can have an unlimited number of containers per database.
    We will create a container named `Products`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition**: These are created and managed automatically within a container,
    and you can have an unlimited number. Partitions are either logical or physical.
    A **logical partition** contains items with the same partition key and defines
    the scope for transactions. Multiple logical partitions are mapped to a **physical
    partition**. Small containers may only need one physical partition. You should
    not concern yourself with physical partitions since you have no control over them.
    Focus on deciding what your partition key should be because that defines the items
    stored in a logical partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Item**: This is a stored entity in a container. We will add items that represent
    each product, like Chai tea.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Item” is a deliberately generic term and is used by the Core (SQL) API to
    refer to a JSON document but can also be used for the other APIs. The other APIs
    also have their own more specific terms:'
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra uses **row**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB uses **document**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph databases like Gremlin use **vertex** and **edge**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughput provisioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughput is measured as **request units per second** (**RU/s**). A single
    **request unit** (**RU**) is about the cost of performing a `GET` request for
    a 1KB document using its unique identifier. Creating, updating, and deleting cost
    more RUs; for example, a query might cost 46.54 RUs, or a delete operation might
    cost 14.23 RUs.
  prefs: []
  type: TYPE_NORMAL
- en: Throughput must be provisioned in advance, although you can scale up and down
    at any time in increments or decrements of 100 RU/s. You will be billed per hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can discover how much a request costs in RUs by getting the `RequestCharge`
    property. You can learn more at the following link: [https://learn.microsoft.com/en-us/azure/cosmos-db/sql/find-request-unit-charge](https://learn.microsoft.com/en-us/azure/cosmos-db/sql/find-request-unit-charge).
    We will output this property in all the example code that we run in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: You must provision throughput to run CRUD operations (creates, reads, updates,
    and deletes). You must estimate throughput by calculating the number of operations
    you’ll need to support throughout the year. For example, a commerce website might
    need to expect much greater throughput at Thanksgiving in the US or Singles Day
    in China.
  prefs: []
  type: TYPE_NORMAL
- en: Most throughput settings are applied at the container level, or you can do so
    at the database level and have the settings shared across all containers. Throughput
    is distributed equally among partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Once provisioned throughput is exhausted, Cosmos DB will start rate-limiting
    access requests, and your code will have to wait and retry later. Luckily, we
    will use the .NET SDK for Cosmos DB, which automatically reads the `retry-after`
    response header and retries after that time limit.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure portal, you can provision between 400 RU/s and 250,000 RU/s.
    At the time of writing, the 400 RU/s minimum would cost about US$35 per month.
    You would then also need to add the cost of storage depending on how many GBs
    you want to store, for example, US$5 for a few GBs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The free tier of Cosmos DB allows up to 1,000 RU/s and 25 GB of storage. You
    can use a calculator at the following link: [https://cosmos.azure.com/capacitycalculator/](https://cosmos.azure.com/capacitycalculator/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Factors that affect RUs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item size**: A 2KB document costs twice as much as a 1KB document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexed properties**: Indexing all item properties costs more than indexing
    a subset of properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Strict consistency costs twice as many RUs as looser consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query complexity**: The number of predicates (filters), the number of results,
    the number of custom functions, projections, the size of the dataset, and so on,
    all increase the cost in RUs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partition strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good partition strategy allows a Cosmos DB database to grow and efficiently
    run queries and transactions. A good partition strategy is about choosing a suitable
    **partition key**. It is set for a container and cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The partition key should be chosen to evenly distribute operations across the
    database to avoid hot partitions, meaning a partition that handles more requests,
    so it is busier than other partitions.
  prefs: []
  type: TYPE_NORMAL
- en: A property that will be unique for an item and will often be used to look up
    an item might be a good choice. For example, for US citizens, a person’s social
    security number. However, partition keys do not have to be unique. The partition
    key value will be combined with an item ID to uniquely identify an item.
  prefs: []
  type: TYPE_NORMAL
- en: Partitions are automatically created by Cosmos DB when needed. There is no negative
    impact on your applications and services from the automatic creation and deletion
    of partitions. Each partition can grow up to a maximum of 20 GB. Cosmos DB will
    automatically split partitions when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A container should have a partition key that possesses these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: High cardinality so that items are distributed evenly across partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evenly distributed requests across partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evenly distributed storage across partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storage design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With relational databases, the schemas are rigid and inflexible. The Northwind
    database’s products are all food-related, so the schema might not change much.
    But if you are building a commerce system for a company that sells everything
    from clothes to electronic equipment to books, then a semi-structured data store
    like the following would be better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clothing: Sizes like S, M L, XL; brand; color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shoes: Sizes like 7, 8, 9; brand; color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Televisions: Sizes like 40”, 52”; screen technology like OLED, LCD; brand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Books: Number of pages; author; publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being schema-less, Azure Cosmos DB can add new types of products with different
    structures and properties simply by adding a new product with that structure to
    a container. You will see examples of this in the code that you write later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating data to Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The open-source **Azure Cosmos DB Data Migration Tool** can import data into
    Azure Cosmos DB from many different sources, including Azure Table Storage, SQL
    databases, MongoDB, text files in JSON and CSV formats, HBase, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not use this migration tool in this book, so if you think it will be
    useful to you, then you can learn how to use it at the following link: [https://github.com/Azure/azure-documentdb-datamigrationtool](https://github.com/Azure/azure-documentdb-datamigrationtool).'
  prefs: []
  type: TYPE_NORMAL
- en: That’s quite enough theory. Now, let’s look at something more practical, how
    to create Cosmos DB resources so we can work with them in code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Cosmos DB resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see Azure Cosmos DB in action, first, we must create Cosmos DB resources.
    We can manually create them in the cloud using the Azure portal or programmatically
    create them using the Azure Cosmos DB .NET SDK. Azure Cosmos DB resources created
    in the cloud have a cost unless you use a trial or free account.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create Azure Cosmos DB resources locally using an emulator, which
    will cost you nothing. At the time of writing, the Azure Cosmos DB Emulator only
    supports Windows. If you want to use Linux or macOS, then you can try to use the
    Linux Emulator, which is currently in preview, or you could host the emulator
    in a Windows virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using an emulator on Windows to create Azure Cosmos DB resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not have a Windows computer, then just read through this section without
    completing the steps yourself, and then in the next section, you will use the
    Azure portal to create Azure Cosmos DB resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the Azure Cosmos DB Emulator on Windows to create Azure Cosmos DB
    resources like a database and container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install the latest version of the Azure Cosmos DB Emulator on
    your local Windows computer from the following link (direct to the MSI installer
    file): [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most recent version of the emulator at the time of writing is 2.14.12, released
    on March 20, 2023\. Earlier versions of the emulator are not supported by the
    developer team. If you have an older version installed, then remove it and install
    the latest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure the Azure Cosmos DB Emulator is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Azure Cosmos DB Emulator** user interface should start automatically,
    but if not, start your favorite browser and navigate to `https://localhost:8081/_explorer/index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the Azure Cosmos DB emulator is running, hosted at `localhost` on
    port `8081`, with a **Primary Key** that you will need to securely connect to
    the service, as shown in *Figure 4.1*:![](img/B19587_04_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.1: The Azure Cosmos DB Emulator user interface on Windows'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The default primary key for the emulator is the same value for everyone. You
    can specify your own key value by starting the emulator at the command line with
    the `/key` switch. You can learn about starting the emulator at the command line
    at the following link: [https://learn.microsoft.com/en-us/azure/cosmos-db/emulator-command-line-parameters](https://learn.microsoft.com/en-us/azure/cosmos-db/emulator-command-line-parameters).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the navigation bar on the left, click **Explorer**, and then click **New
    Container**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Database id**, select **Create new** and enter `Northwind`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **Share throughput across containers** check box.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Database throughput**, select **Autoscale**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Database max RU/s** as `4000`. This will use a minimum of 400 RU/s and
    autoscale up to 4,000 RU/s when needed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Container id**, enter `Products`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Partition key**, enter `/productId`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the tree on the left, expand the **Northwind** database, expand the **Products**
    container, and select **Items**, as shown in *Figure 4.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The empty items in the Products container in the Northwind database'
  prefs: []
  type: TYPE_NORMAL
- en: In the toolbar, click **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the editor window with a JSON document that represents
    a product named `Chai`, as shown in the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the toolbar, click **Save**, and note the extra properties that are automatically
    added to any item, including `id`, `_etag`, and `_ts`, as shown highlighted in
    the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the editor window with a JSON document that represents
    a product named `Chang`, as shown in the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of the editor window with a JSON document that represents
    a product named `Aniseed Syrup`, as shown in the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the first item in the list and note that all the items have been automatically
    assigned GUID values for their `id` properties, as shown in *Figure 4.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: A saved JSON document item in the Azure Cosmos DB emulator'
  prefs: []
  type: TYPE_NORMAL
- en: In the toolbar, click **New SQL Query**, and note the default query text is
    `SELECT * FROM c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the query text to return all products supplied by `Exotic Liquids`;
    in the toolbar, click **Execute Query**, and note that all three products are
    included in the array of results, as shown in *Figure 4.4* and in the following
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/B19587_04_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.4: A query to return all products supplied by Exotic Liquids'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Keywords are case-insensitive, so `WHERE` is treated the same as `Where` or
    `where`. Property names are case-sensitive so `CompanyName` is different from
    `companyName`, and will return zero results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the query text to return all products in category 2, as shown in the
    following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the query and note that one product is included in the array of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Azure portal to create Azure Cosmos DB resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you would prefer to only use the Azure Cosmos DB Emulator to avoid any costs,
    then feel free to skip this section, or just read through it without completing
    the steps yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the Azure portal to create Azure Cosmos DB resources like an
    account, database, and container in the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have an Azure account, then you can sign up for one for free
    at the following link: [https://azure.microsoft.com/free/](https://azure.microsoft.com/free/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the Azure portal and sign in: [https://portal.azure.com/](https://portal.azure.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Azure portal menu, click **+ Create a resource**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Create a resource** page, search for, or click, **Azure Cosmos DB**,
    and then on the **Azure Cosmos DB** page, click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Which API best suits your workload?** page, in the **Azure Cosmos DB
    for NoSQL** box, note the description, **Azure Cosmos DB’s core, or native API
    for working with documents. Supports fast, flexible development with familiar
    SQL query language and client libraries for .NET, JavaScript, Python, and Java.**,
    and then click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Basics** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your **Subscription**. Mine is named `Pay-As-You-Go`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select a **Resource Group** or create a new one. I used the name `apps-services-book`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter an Azure Cosmos DB **Account Name**. I used `apps-services-book`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select a **Location**. I chose **(Europe) UK South** as it is the closest to
    me.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Capacity mode** to **Provisioned throughput**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Apply Free Tier Discount** to **Do not apply**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Only apply the free tier discount now if you want this account
    to be the *only* account within your subscription to be on the free tier. You
    might be better off saving this discount for another account that you might use
    for a real project, rather than a temporary learning account while reading this
    book. With Azure Cosmos DB free tier, you will get the first 1,000 RU/s and 25
    GB of storage for free in an account. You can only enable a free tier on one account
    per subscription. Microsoft estimates this has a value of $64/month.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Limit total account throughput** check box.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click the **Next: Global Distribution** button and review the options but leave
    them at their defaults.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Next: Networking** button and review the options but leave them
    at their defaults.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Next: Backup Policy** button and review the options but leave them
    at their defaults.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Next: Encryption** button and review the options but leave them
    at their defaults.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Review + create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the **Validation Success** message, review the summary, and then click
    the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the deployment to complete. This will take a few minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Go to resource** button. Note that you are probably directed to
    the **Quick Start** page with steps to follow to create a container and so on,
    depending on if this is the first time that you have created an Azure Cosmos DB
    account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the left navigation, click **Overview**, and note the information about
    your Azure Cosmos DB account, as shown in *Figure 4.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Azure Cosmos DB account Overview page'
  prefs: []
  type: TYPE_NORMAL
- en: In the navigation on the left, in the **Settings** section, click **Keys**,
    and note the **URI** and **PRIMARY KEY** needed to programmatically work with
    this Azure Cosmos DB account, as shown in *Figure 4.6*:![](img/B19587_04_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.6: Keys to programmatically work with the Azure Cosmos DB account'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: Unlike the primary key that is shared by all developers
    of the Cosmos DB emulator, your Cosmos DB primary keys in Azure are unique and
    must be kept secret. I deleted the Cosmos DB account that I used to write this
    chapter so the keys in the screenshot above are useless.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the navigation on the left, click **Data Explorer**, and if a video pops
    up, then close it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the toolbar, click **New Container**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the steps listed in the emulator section, *Using an emulator on Windows
    to create Azure Cosmos DB resources*, starting at *step 6* where you fill in the
    information about the new container, and going up to the end of that section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a .NET app to create Azure Cosmos DB resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will create a console app project for creating the same Azure Cosmos
    DB resources in either the local emulator or in the cloud, depending on which
    URI and primary key you choose to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter04`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.CosmosDb.SqlApi`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the project file, treat warnings as errors, add a package reference for
    Azure Cosmos, add a project reference to the Northwind data context project that
    you created in *Chapter 3*, *Building Entity Models for SQL Server Using EF Core*,
    and import the `Console` class statically and globally, as shown highlighted in
    the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the `Northwind.CosmosDb.SqlApi` project at the command prompt or terminal
    using the following command: `dotnet build`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Warning!** If you are using Visual Studio 2022 and you reference a project
    outside of the current solution, then using the **Build** menu gives the following
    error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`NU1105 Unable to find project information for ''C:\apps-services-net8\Chapter03\Northwind.Common.DataContext.SqlServer\Northwind.Common.DataContext.SqlServer.csproj''.
    If you are using Visual Studio, this may be because the project is unloaded or
    not part of the current solution.`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must enter a `dotnet build` command at the command prompt or terminal. In
    **Solution Explorer**, you can right-click the project and select **Open in Terminal**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a class file named `Program.Helpers.cs`, delete any existing statements,
    and then add statements to define a partial `Program` class with a method to output
    a section title to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a class file named `Program.Methods.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, add statements to import the namespace for working
    with Azure Cosmos. Then, define a method for the `Program` class that creates
    a Cosmos client and uses it to create a database named `Northwind` and a container
    named `Products`, in either the local emulator or in the cloud, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following in the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using the emulator, the `endpointUri` and `primaryKey` are the same for
    everyone.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor for a `CosmosClient` requires the `endpointUri` and `primaryKey`.
    Never store your primary key in your source code and then check it in to a public
    Git repository! You should get it from an environment variable or other secure
    place like Azure Key Vault.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating a database, you must specify a name and throughput in RUs per
    second.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating a container, you must specify a name and partition key path, and
    you can optionally set an indexing policy and override the throughput, which defaults
    to the database throughput.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The response to a request to create an Azure Cosmos DB resource includes an
    HTTP status code like `200` `OK` if the resource already exists, or `201` `Created`
    if the resource did not exist but has now been successfully created. The response
    also includes information about the resource like its `Id`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add a statement to
    call the method to create Azure Cosmos resources, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the Azure Cosmos DB Emulator or Azure portal, use **Data Explorer** to delete
    the `Northwind` database. (You must hover your mouse cursor over the database
    and then click the **…** ellipsis button.) You will be prompted to enter its name
    to confirm deletion because this operation cannot be undone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to delete the `Northwind` database at this point. Later in this
    chapter, you will programmatically add the 77 products from the SQL Server `Northwind`
    database to the Cosmos DB `Northwind` database. If you still have the three sample
    products in its `Products` container, then you will have issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console app and note that because we have just deleted the database,
    the code we have executed has (re)created the database, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You do not need to delete the database again because it will be empty of any
    products.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a Cosmos DB database resource to work with, either in the local
    emulator or in the Azure cloud. Now, let’s learn how to perform CRUD operations
    on it using the SQL API.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating data with the Core (SQL) API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common API for working with data in Azure Cosmos DB is Core (SQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'The full documentation for the Core (SQL) API can be found at the following
    link: [https://learn.microsoft.com/en-us/azure/cosmos-db/sql/](https://learn.microsoft.com/en-us/azure/cosmos-db/sql/).'
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations with the Cosmos SQL API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can perform CRUD operations on JSON documents in Cosmos with the SQL API
    by calling the following most common overloads of methods on an instance of the
    `Microsoft.Azure.Cosmos.Container` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadItemAsync<T>(id, partitionKey)`: Where `T` is the item type to get, `id`
    is its unique identifier, and `partitionKey` is its partition key value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadManyItemsAsync<T>(idsAndPartitionKeys)`: Where `T` is the item type to
    get, and `idsAndPartitionKeys` are the unique identifiers and partition key values
    of a read-only list of items to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateItemAsync(object)`: Where `object` is an instance of the item type to
    insert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteItemAsync<T>(id, partitionKey)`: Where `T` is the item type to delete,
    `id` is its unique identifier, and `partitionKey` is its partition key value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PatchItemAsync<T>(id, partitionKey`, `patchOperations)`: Where `T` is the
    item type to update, `id` is its unique identifier, `partitionKey` is its partition
    key value, and `patchOperations` is a read-only list of property changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaceItemAsync<T>(object`, `id)`: Where `T` is the item type to replace,
    `id` is its unique identifier, and `object` is an instance of the item type to
    replace it with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpsertItemAsync<T>(object`, `id)`: Where `T` is the item type to either insert
    or replace, `id` is its unique identifier, and `object` is an instance of the
    item type to insert or replace the existing item with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Cosmos DB uses HTTP as its underlying communication protocol
    and so the “patch” and “replace” operations are implemented using `PATCH` and
    `PUT`. Just like those HTTP methods, `PATCH` is more efficient because only the
    properties that need to change are sent in the request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each method returns a response that has the following common properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Resource`: The item that was created/retrieved/updated/deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequestCharge`: A `double` value indicating the request charge measured in
    RUs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StatusCode`: An HTTP status code value; for example, `404` when a `ReadItemAsync<T>`
    request fails to find the item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Headers`: A dictionary of HTTP response headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Diagnostics`: Useful information for diagnostics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActivityId`: A GUID value that is useful for tracking this activity through
    multi-tiered services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s copy all the products from the Northwind database in SQL Server to Cosmos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the entity classes in the EF Core for SQL Server class libraries are
    designed for the normalized data structure in the Northwind SQL database, we will
    create new classes to represent items in Cosmos that have embedded related data.
    They will use JSON casing conventions since they represent JSON documents:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Northwind.CosmosDb.SqlApi` project, add a new folder named `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Models` folder, add a class file named `CategoryCosmos.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its content to define a `CategoryCosmos` class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must deliberately not follow usual .NET casing conventions because we cannot
    dynamically manipulate the serialization and the resulting JSON must use camel
    case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Models` folder, add a class file named `SupplierCosmos.cs`, and modify
    its content to define a `SupplierCosmos` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Models` folder, add a class file named `ProductCosmos.cs`, and modify
    its content to define a `ProductCosmos` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: All JSON document items in Cosmos must have an `id` property.
    To control the value, it is good practice to explicitly define that property in
    the model. Otherwise, the system will assign a GUID value, as you saw earlier
    in this chapter when using the **Data Explorer** to manually add a new item.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, add statements to import namespaces for the Northwind
    data context and entities types, the Northwind Cosmos types, and EF Core extensions,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Methods.cs`, add statements to define a method to get all the products
    in the Northwind SQL database, including their related category and supplier,
    and then insert them as new items in the `Products` container in Cosmos, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the call to create the Azure Cosmos resources,
    and then add a statement to call the method to insert all the products, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, which should be 77 product items
    inserted, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app again and note the results, which should show that the
    product items already exist, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the Azure Cosmos DB Emulator or Azure portal **Data Explorer**, confirm that
    there are 77 product items in the `Products` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, add statements to define a method to list all the
    items in the `Products` container, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to import the namespaces to work with cultures
    and encodings, simulate French culture, comment out the call to create the product
    items, and then add a statement to call the method to list the product items,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, which should be 77 product items,
    as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Methods.cs`, add statements to define a method to delete all the
    items in the `Products` container, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the call to list the product items, and then add
    a statement to call the method to delete the product items, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, which should be 77 product items
    deleted, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the Azure Cosmos DB Emulator or Azure portal **Data Explorer**, confirm that
    the `Products` container is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding SQL queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following keywords and more are available when writing SQL queries for
    Azure Cosmos DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT` to select from item properties. Supports `*` for all and `TOP` for
    limiting the results to the first specific number of items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AS` to define aliases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FROM` to define the items to select from. Some of the previous queries used
    `FROM c`, where `c` is an implied alias for the items in the container. Since
    a SQL query is executed within the context of a container like `Products`, you
    can use any alias you like, so `FROM Items c` or `FROM p` would work equally well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WHERE` to define a filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIKE` to use pattern matching. `%` means zero, one, or more characters. `_`
    means a single character. `[a-f]` or `[aeiou]` means a single character within
    the defined range or set. `[^aeiou]` means not in the range or set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IN`, `BETWEEN` are range and set filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AND`, `OR`, `NOT` for Boolean logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDER BY` to sort the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISTINCT` to remove duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COUNT`, `AVG`, `SUM`, and other aggregate functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To query the `Products` container using the Core (SQL) API, you might write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try executing a SQL query against our product items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, uncomment the call to (re)create the product items and modify
    the call to `ListProductItems` to pass a SQL query that filters the products to
    only show the products in the Beverages category and only their ID, name, and
    unit price, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, which should be the 12 product items
    in the Beverages category, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the Azure Cosmos DB Emulator or Azure portal **Data Explorer**, create a
    new SQL query, use the same SQL text, and execute it, as shown in *Figure 4.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Executing a SQL query in Data Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Query Stats**, and note the request charge (3.19 RUs), the number of
    records (12), and the output document size (752 bytes), as shown in *Figure 4.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Query statistics in Data Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful query statistics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Index hit document count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index lookup time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document load time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query engine execution time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document write time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other SQL queries with Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try executing the following queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Although queries defined using strings are the most common way of working with
    Cosmos DB, you can also create permanently stored objects using server-side programming.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring server-side programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Cosmos DB server-side programming consists of **stored procedures**, **triggers**,
    and **user-defined functions** (**UDFs**) written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing user-defined functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UDFs can only be called from within a query, and they implement custom business
    logic like calculating tax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a UDF to calculate the sales tax of products:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Azure Cosmos DB Emulator or Azure portal **Data Explorer**, create a
    new UDF, as shown in *Figure 4.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Creating a new UDF'
  prefs: []
  type: TYPE_NORMAL
- en: For the **User Defined Function Id**, enter `salesTax`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the **User Defined Function Body**, enter JavaScript to define the `salesTax`
    function, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the toolbar, click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new SQL query and enter SQL text to return the unit price and sales
    tax for products that cost more than 100, as shown in the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `AS` to alias an expression is optional. I prefer to specify `AS`
    for improved legibility.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Save Query** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using cloud resources instead of the emulator, then for compliance
    reasons, Microsoft saves queries in a container in your Azure Cosmos account in
    a separate database called **___Cosmos**. The estimated additional cost is $0.77
    daily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the query and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing stored procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stored procedures are the only way to ensure **ACID** (**Atomic, Consistent,
    Isolated, Durable**) transactions that combine multiple discrete activities into
    a single action that can be committed or rolled back. You cannot use client-side
    code to implement transactions. Server-side programming also provides improved
    performance since the code executes where the data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just seen that you can define a UDF using the Data Explorer. We could
    define a stored procedure in a similar way, but let’s see how we would do it using
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Methods.cs`, import the namespace for working with server-side
    programming objects, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Methods.cs`, add statements to define a method to create a stored
    procedure that can insert multiple products by chaining callback functions until
    all items in an array are inserted, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out all the existing statements, and add a statement
    to run the new method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, which should be the successful creation
    of the stored procedure, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Methods.cs`, add statements to define a method to execute the stored
    procedure, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the statement to create the stored procedure,
    add a statement to execute the stored procedure, and then list products with a
    `productId` of `78`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, which should be the successful execution
    of the stored procedure, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cleaning up Azure resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are done with an Azure Cosmos DB account, you must clean up the resources
    used, or you will incur costs for as long as those resources exist. You can delete
    resources individually or delete the resource group to delete the entire set of
    resources. If you delete an Azure Cosmos DB account, then all the databases and
    containers within it are also deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Azure portal, navigate to **All Resources**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your `apps-services-book` resource group, click your Azure Cosmos DB account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Overview**, and then in the toolbar, click **Delete Account**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Confirm the Account Name** box, enter your account name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Delete** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the five APIs supported by Azure Cosmos DB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At what level do you select the API: account, database, container, or partition?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does *embed* mean regarding data modeling with Cosmos DB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the unit of measurement for throughput for Cosmos DB and what does 1
    unit represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What package should you reference to programmatically work with Cosmos DB resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What language do you use to write Cosmos DB Core (SQL) API user-defined functions
    and stored procedures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 4.2 – Practice data modeling and partitioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft documentation has an extensive example of modeling and partitioning
    Azure Cosmos DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/azure/cosmos-db/sql/how-to-model-partition-example](https://learn.microsoft.com/en-us/azure/cosmos-db/sql/how-to-model-partition-example)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-4---managing-nosql-data-using-azure-cosmos-db](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-4---managing-nosql-data-using-azure-cosmos-db)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.4 – Download cheat sheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download query cheat sheets for the Azure Cosmos DB APIs and review them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/azure/cosmos-db/sql/query-cheat-sheet](https://learn.microsoft.com/en-us/azure/cosmos-db/sql/query-cheat-sheet)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.5 – Explore the Gremlin API for Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are interested, then I have written an optional online-only section
    where you explore the Azure Cosmos DB graph API that uses the Gremlin API, found
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch04-gremlin.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch04-gremlin.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To gain more experience with the Gremlin graph API, you could read the following
    online book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html](https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.6 – Explore NoSQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter focused on Azure Cosmos DB. If you wish to learn more about NoSQL
    databases, such as MongoDB, and how to use them with EF Core, then I recommend
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use NoSQL databases as a persistence infrastructure**: [https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure](https://learn.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document Database Providers for Entity Framework Core**: [https://github.com/BlueshiftSoftware/EntityFrameworkCore](https://github.com/BlueshiftSoftware/EntityFrameworkCore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to store flexibly structured data in Azure Cosmos DB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create Cosmos DB resources in the emulator and in the Azure cloud.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manipulate data using the Cosmos SQL API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement server-side programming in Cosmos DB using JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will use the `Task` type to improve the performance
    of your applications.
  prefs: []
  type: TYPE_NORMAL
