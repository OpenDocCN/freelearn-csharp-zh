<html><head></head><body>
        

                            
                    <h1 class="header-title">The SOLID Principles of Software Design</h1>
                
            
            
                
<p>This book focuses on techniques related to Dependency Injection and the way those techniques are implemented by default and can be extended by the programmer in .NET Core--the first version of .NET that executes on every platform.</p>
<p>It works on Windows, macOS, and Linux distro on the desktop, and the idea can even be extended to the mobile world covering the Apple, Android, and Tizen (Samsung) operating systems.</p>
<p>This is, with no doubt, the most ambitious project from Microsoft in its search for a universal coverage of programming technologies and tools, and it can be considered a natural step after the initial <strong>UWP</strong> (<strong>Universal Windows Platform</strong>) project that allows building applications for any device supporting Windows, from IoT devices to the desktop, XBOX, or HoloLens.</p>
<p>So, in this chapter we'll start with a quick review of the main architectural components of .NET Core and its derivative frameworks (such as ASP.NET Core), to be followed with the foundations on which Dependency Injection techniques are based, as part of the SOLID principles, stated by Robert C. Martin (<em>Uncle Bob</em>) in 2000. (See Wikipedia: <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)</a>.)</p>
<p>Therefore, we'll revise those five SOLID principles, explaining their purpose and advantages, together with some basic implementations of each one of them in the C# language using Console applications coded in .NET Core. In all we'll see an explanation of each principle and its coverage:</p>
<ul>
<li>Separation of concerns (clearly implemented in the core infrastructure of .NET Core and also from the initial configuration of pipelines and middleware in ASP.NET Core)</li>
<li>Open/Closed (already implemented in classic .NET Framework since version 3.0 and also present here)</li>
<li>Liskov Substitution Principle (available in two ways--in a classic manner through the support of typecasting, and through the use of generics)</li>
<li>Interface segregation: Explanation of Interface segregation and its advantages</li>
<li>Dependency Inversion: Explanation of the principle, its derivatives, and the concept of IoC containers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">In the beginning</h1>
                
            
            
                
<p>The evolution of programming techniques is, somehow, related to language evolution. Once the initial (and, in some ways, chaotic) times had passed, the universality of computing became clear, and the need for good patterns and languages capable of affording large projects turned out to be evident.</p>
<p>The 70s marked the start of the adoption of other paradigms, such as procedural programming, and later on, <strong>object-oriented programming</strong> (<strong>OOP</strong>), proposed by Ole-Johan Dahl and Kristen Nygaard with the Simula language, when they both worked at the Norwegian Computing Center. They were given the Turing Award for these achievements, among other recognitions.</p>
<p>A few years later (around 1979), Bjarne Stroustrup created C with Classes, the prototype of what C++ is today because he found valuable aspects in the Simula language, but he thought that it was too slow for practical purposes, being the first OOP language that was universally adopted.</p>
<p>C++ originally had imperative features and object-oriented and generic ones, while also providing the ability to program for low-level memory manipulation. While it's true that it has become a de facto standard for building critical systems and applications, for many people it was not adequate for <strong>LOB</strong> (<strong>Line of Business</strong>) applications.</p>
<p>Years later, Java and the .NET platforms proposed a much easier and affordable solution for many programmers while still moving within the ordered space that object-oriented programming languages promote.</p>
<p>So, OOP was adopted, and so far no other important programming paradigm has replaced these ideas. Certainly, there are other approaches, such as functional programming, but even the most significant representative of this tendency, JavaScript, is becoming more object-oriented in the latest versions (ECMAScript 2015).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">.NET and .NET Core</h1>
                
            
            
                
<p>.NET has been revamped lately in order to achieve the goal that Microsoft has pursued since Satya Nadella arrived in the company--"<q><em>Any Developer, Any App, Any Platforms.</em></q>".</p>
<p>According to Principal Manager Scott Hunter, the company now presents a set of unified application models that can be summarized in the following screenshot:</p>
<div><img height="231" width="480" class=" image-border" src="img/93628383-00e3-490b-9444-694f2dc6f79d.png"/></div>
<p>Source: <a href="http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx">http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx</a></p>
<p>As you see, the situation now is quite promising for a .NET Developer. The screenshot shows a <strong>Common Infrastructure</strong> (compilers, languages, and runtime components), powered by Roselyn services and other features. All those integrate with the IDEs that support these projects, now including Visual Studio for Mac.</p>
<p>On top of that lies a <strong>.NET Standard Library</strong>, which has points in common that allow us to share code along the three different frameworks--the classic <strong>.NET Framework</strong> (in version 4.6.2, at the time of writing this), <strong>.NET Core</strong> (now in version 2.0), and <strong>Xamarin</strong>, which allows building applications for any type of mobile target--Android, iOS, Windows Phone, and Tizen (Samsung).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">About .NET Core</h1>
                
            
            
                
<p>.NET Core is the new version of .NET presented officially in the summer of 2016, and updated to version 1.1 in the November Connect() event the same year. It's defined as a <em>cross-platform, open source, cloud-ready and modular .NET platform for creating modern web apps, microservices, libraries, and console applications that run everywhere (Windows, Linux, and MacOS).</em></p>
<p>It can be deployed along with the application itself, minimizing installation issues.</p>
<p>Prior to its publication, Microsoft decided to restart the numbering, reinforcing the idea that this is a totally new concept with respect to classical versions, as a better way to avoid ambiguities.</p>
<p>MSDN architect Cesar de la Torre defines in his blog very precisely the goals and structure of .NET Core--unlike the traditional .NET Framework, which is a single package installation, system-wide, and Windows-only runtime environment, .NET Core is about decoupling .NET from Windows, allowing it to run in non-Windows environments without having to install a giant 400 Mb set of binaries (versus just the footprint of the components you need from .NET Core) plus the ability to deploy applications accompanying the framework itself, supporting side-by-side execution of different versions of the framework.</p>
<p>A very interesting part of its architecture and deployment infrastructure, as mentioned in the same source, is that instead of being part of the operating system, .NET Core is composed of NuGet packages and is either compiled directly into an application or put into a folder inside the application. This means applications can carry .NET Core within and thus are completely side by side on the machine.</p>
<p>I, personally, think this is absolutely crucial for the project to be successful. No side-effects, no component installation in the target machine, and no dependencies. (As you'll see throughout this book this avoiding of dependencies is totally foundational when building software that follows good practices.)</p>
<p>NET Core 2.0 - Supported OS Versions Proposal:</p>
<table>
<tbody>
<tr>
<td><strong>OS</strong></td>
<td><strong>Version</strong></td>
<td><strong>Architectures</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td>Windows Client</td>
<td>7 SP1+</td>
<td>x64, x86</td>
<td/>
</tr>
<tr>
<td>Windows Server</td>
<td>2008 R2 SP1+</td>
<td>x64, x86</td>
<td>Configurations: Full, Server Core, Nano</td>
</tr>
<tr>
<td>Windows IoT</td>
<td>10+</td>
<td>[C] arm32</td>
<td>IoT Core - see <a href="https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md">Raspberry Pi instructions</a></td>
</tr>
<tr>
<td>Red Hat Enterprise Linux</td>
<td>7.3+</td>
<td>x64</td>
<td>This includes Centos and Oracle Linux</td>
</tr>
<tr>
<td>Fedora</td>
<td>25+</td>
<td>x64</td>
<td/>
</tr>
<tr>
<td>Debian</td>
<td>8.7+</td>
<td>x64</td>
<td><a href="https://github.com/dotnet/corefx/issues/8951#issuecomment-299927277">Debian 9 (Stretch) workaround</a></td>
</tr>
<tr>
<td>Ubuntu</td>
<td>14.04+</td>
<td>x64, [C] arm32</td>
<td>This includes Linux Mint 17 for x64<br/>
For arm32, see <a href="https://github.com/dotnet/core/blob/master/samples/RaspberryPiInstructions.md">Raspberry Pi instructions</a></td>
</tr>
<tr>
<td>openSUSE</td>
<td>42.2+</td>
<td>x64</td>
<td/>
</tr>
<tr>
<td>Tizen</td>
<td>4+</td>
<td>[S] arm32</td>
<td><a href="https://developer.tizen.org/development/tizen-.net-preview/introduction">Tizen .NET Developer Preview</a></td>
</tr>
<tr>
<td>Mac OS X</td>
<td>10.12+</td>
<td>x64</td>
<td/>
</tr>
<tr>
<td><strong>In Progress OS's</strong></td>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>Arch Linux</td>
<td>[C] TBD</td>
<td>TBD</td>
<td>Blocked on <a href="https://github.com/dotnet/corefx/issues/9855#issuecomment-298982251">missing OpenSSL 1.0 package</a> in distro.<br/>
Arch Linux community efforts tracked <a href="https://bbs.archlinux.org/viewtopic.php?pid=1708479">here</a>.</td>
</tr>
<tr>
<td>FreeBSD &amp; NetBSD</td>
<td>[C] TBD</td>
<td>TBD</td>
<td>Tracking <a href="https://github.com/dotnet/coreclr/issues/6115">main issue</a> and <a href="https://github.com/dotnet/coreclr/labels/os-freebsd">label</a>.<br/>
NetBSD packages for <a href="https://github.com/dotnet/coreclr/issues/6115#issuecomment-233151220">.NET Core 1.0.0</a></td>
</tr>
</tbody>
</table>
<p>As for the types of programmable project available from any of the above-mentioned IDE's, .NET Core can support its own application model, and also the Universal Windows Platform Model, optionally compiled to .NET Native (see the following screenshot):</p>
<div><img height="191" width="209" class=" image-border" src="img/ee337a92-791f-4607-8b0c-290aee531b55.png"/></div>
<p>Source: <a href="http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx">http://www.hanselman.com/blog/AnUpdateOnASPNETCore10RC2.aspx</a></p>
<p>We end this introduction to .NET Core with the summary from the same page mentioned previously in relation to this framework:</p>
<ul>
<li><strong>Cross-platform</strong>: .NET Core currently supports three main operating systems--Linux, Windows and OS X. There are other OS ports in progress such as FreeBSD, NetBSD, and Arch Linux. .NET Core libraries can run unmodified across supported OSes. The apps must be re-compiled per environment, given that apps use a native host. Users select the .NET Core supported environment that works best for their situation.</li>
<li><strong>Open Source</strong>: .NET Core is available on GitHub at <a href="https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md">https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0.0-preview1.md</a>, licensed with the MIT and Apache 2 licenses (licensing is per component). It also makes use of a significant set of open source industry dependencies (see release notes). Being OSS is critical for having a thriving community plus a must for many organizations where OSS is part of their development strategy.</li>
<li><strong>Natural acquisition</strong>: .NET Core is distributed as a set of NuGet packages that developers can pick and choose from. The runtime and base framework can be acquired from NuGet and OS-specific package managers, such as APT, Homebrew, and Yum. Docker images are available on docker hub. The higher-level framework libraries and the larger .NET library ecosystem are available on NuGet.</li>
<li><strong>Modular framework</strong>: .NET Core is built with a modular design, enabling applications to include only the .NET Core libraries and dependencies that are needed. Each application makes its own .NET Core versioning choices, avoiding conflicts with shared components. This approach aligns with the trend of developing software using container technologies such as Docker.</li>
<li><strong>Smaller deployment footprint</strong>: Even when in v1.0/1.1 the size of .NET Core is a lot smaller than .NET Framework; note that the overall size of .NET Core doesn't set out to be smaller than the .NET Framework over time, but since it is pay-for-play, most applications that utilize only parts of CoreFX will have a smaller deployment footprint.</li>
<li><strong>Fast release cycles of .NET Core</strong>: .NET Core's modular architecture plus its OSS nature provide more modern and much faster release cycles (even per NuGet package) compared to slow release cycles from larger monolithic frameworks. This approach allows a much faster innovation pace from Microsoft and the OSS .NET community than what was traditionally possible with the .NET Framework.</li>
</ul>
<p class="QuotePACKT">Thus, there are multiple application model stacks built on top of the .NET Core that allow developers to build applications ranging from console applications, across UWP Windows 10 apps (PC, tablet, and phones) to scalable web applications and microservices with ASP.NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ASP.NET Core</h1>
                
            
            
                
<p>ASP.NET applications that use .NET Core promote a model based on the previous MVC model, although built from scratch, targeted at cross-platform execution, the elimination of some unnecessary features, and the unification of the previous MVC with the web API variant; so, they work with the same controller type.</p>
<p>Besides this, the code doesn't need to be compiled prior to execution while you're developing. The BrowserSync technology allows you change the code on-the-fly and the Roselyn services take care of updating; so, you just have to refresh your page to see the changes.</p>
<p>ASP.NET Core also uses a new hosting model, completely decoupled from the web server environment that hosts the application. It supports IIS versions and also self-hosting contexts via Kestrel (cross-platform, extremely optimized, built on top of LibUv, the same component that Node.js uses) and WebListener HTTP (Windows-only) servers.</p>
<p>As part of its architecture, it proposes a new generation of middleware that is asynchronous, very modular, lightweight, and totally configurable, where we define things such as routing, authentication, static files, diagnostics, error handling, session, CORS, localization; and they can even be user-defined.</p>
<p>Notice also that ASP.NET Core can run as well in the classic .NET Framework with access to the functionality exposed by those libraries. The following screenshot shows the schema:</p>
<div><img height="178" width="398" class=" image-border" src="img/991fdcd2-0907-42ae-a698-432ddeae6b14.png"/></div>
<p>ASP.NET Core joins many things that were separate in previous versions. Thus, there are no distinctions between MVC and Web API and, if you target .NET Core or if you prefer to target any of the other version of .NET, the architectural model can be MVC using this rebuilt architecture.</p>
<p>In addition, a new built-in IoC container for dependency injection is responsible for bootstrapping the system, together with a new configuration protocol, which we'll see in practice in the following chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">About the IDE used in this book</h1>
                
            
            
                
<p>Since this book deals with .NET Core and ASP.NET Core and their built-in capabilities covering SOLID principles in general and DI in particular, we're using the latest available version of Visual Studio (Visual Studio 2017 Enterprise), which includes full support for these platforms, together with a bunch of convenient extensions and templates.</p>
<p>You can also use Visual Studio 2017 Community Edition, which is free, or any higher version with practically no changes, as far as the codes samples are concerned.</p>
<p>If you're a Mac user, you can also use Visual Studio for Mac (<a href="https://www.visualstudio.com/vs/visual-studio-mac/" target="_blank">https://www.visualstudio.com/vs/visual-studio-mac/</a>), available since November 2016, and, if you prefer a light, full-fledged, and free IDE for any platform (Linux, Mac or Windows), you can opt for Visual Studio Code (<a href="https://code.visualstudio.com/download" target="_blank">https://code.visualstudio.com/download</a>), which also has excellent editing and debugging capabilities. All of them have full support for .NET Core/ASP.NET Core as well (see the following screenshot):</p>
<div><img class=" image-border" src="img/4b6e0c2e-656d-4746-97c5-65f130e39d09.png"/></div>
<p>Throughout this and other chapters, I'll use indiscriminately .NET Core or ASP.NET Core for the demos, depending on whether we need a more complex user interface or not. Notice also that .NET Core (for the time being) does not offer any visual UI beyond Console applications.</p>
<p>Actually, the currently available templates shown by default when we select <em>New Project</em> and click on .NET Core are the ones you can see in the following screenshot:</p>
<div><img height="311" width="535" src="img/a6c16fe2-d1f2-4828-946f-372be1fca13d.png"/></div>
<p>As you see, the choices are basically threefold (besides testing): Console apps, Class libraries, and ASP.NET Core Web apps, based on NET Core. In the three cases, the resulting apps run on any platform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other foundational changes in .NET Core</h1>
                
            
            
                
<p>It's important to keep in mind that, with NET Core, you no longer depend on .NET Framework libraries (the BCL libraries), either installed by the OS or manually and located in the GAC (Global Assembly Cache).</p>
<p>All libraries are available via NuGet and downloaded accordingly. But, if you have tried .NET Core prior to Visual Studio 2017, you might miss the file <kbd>project.json</kbd> in which all dependencies were referenced.</p>
<p>The official documentation states that when using Visual Studio 2017:</p>
<ul>
<li>MSBuild supports .NET Core projects, using a simplified <kbd>csproj</kbd> project format that makes it easier to be edited by hand, without the need for unloading the project</li>
<li>There is support for file wildcards in the project file, enabling folder-based projects that don't require individual files to be included</li>
<li>NuGet package references are now part of the <kbd>csproj</kbd> format, consolidating all project references in one file</li>
</ul>
<p>So, if you try a new .NET Core project with this tool, the project's dependencies are now referenced in the <kbd>csproj</kbd> file (in XML format), as you can see when opening it in any text editor:</p>
<div><img height="130" width="358" src="img/2ef002b8-cf59-47ae-8be3-ea6dcce235c9.png"/></div>
<p>In parallel, Visual Studio reads that file, creates a <kbd>Dependencies</kbd> entry in the Solution Explorer, and starts looking for that information (either in the PC's cache or in NuGet).</p>
<p>Note also that they're not real, classic DLLs, but fragments of code that are assembled all together at compile time to minimize size and launch time. If you take a look at that entry you can see the Dependencies' dependencies, and so on:</p>
<div><img height="242" width="386" src="img/551b8bc4-174e-43f4-900c-1288d9d309f5.png"/></div>
<p>Another critical point to highlight relates to the deliverables produced after the compiling process. If you open the demo included as ConsoleApp1 (or create a basic one of your own), and just compile it, you'll see that the bin directory does not contain any executable file. You'll see a DLL with that name instead (ConsoleApp1.dll).</p>
<p>When you launch the application (after adding a <kbd>Console.Read()</kbd> sentence to stop execution), you'll see that the executable is, indeed, <kbd>dotnet.exe</kbd>. And the same is true when you open the Diagnostics Tool and take a snapshot of the executable to see what is in place in that moment. The following screenshot shows the situation:</p>
<div><img height="234" width="488" class=" image-border" src="img/419d5222-7299-47be-9774-fd60507cf1d4.png"/></div>
<p>The reason for this is directly related to the complexity of this model. The application is thought to execute on distinct platforms. The default option allows the deployment architecture to determine the best way to configure the JIT compilers depending on the target. This is why the execution is undertaken by the dotnet runtime (named dotnet.exe).</p>
<p>From the point of view of deployment, in .NET Core, two types of application are defined: portable and self-contained.</p>
<p>In .NET Core, portable applications are the default. Of course, that means that (as developers) we can be sure about their portability in distinct .NET core installations. However, a standalone app does not depend on any previous installation to run. That is to say, it holds within itself all the necessary components and dependencies, including the runtime packaged with the application. Certainly, that builds a larger app, but it also makes the application capable of executing on any .NET Core platform whether you have .NET Core installed in the target or not.</p>
<p>For the main purposes of this book, it doesn't matter which runtime mode we choose. Anyhow, this brief introduction can give you an idea of how the new framework behaves and is managed inside Visual Studio 2017.</p>
<p>And, remember, anything I do using Visual Studio 2017, you can also do with Visual Studio Code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The SOLID principles</h1>
                
            
            
                
<p>Some programming guidelines have a comprehensive, general-purpose intention, while others are mainly designed to fix certain specific problems. Therefore, before we focus on specific problems, it's important to review those features that can be applied in different scenarios and solutions. I mean those principles that you should consider beyond the type of solution or specific platform to program for.</p>
<p>This is where the SOLID principles (and other related problems) come into play. In 2001, Robert Martin published a foundational article on the subject (<a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank">http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>), in which he enumerated a set of principles and guidelines that, in his own words, focus very tightly on dependency management, its potential problems, and how to avoid them.</p>
<p>To explain this further, in his words, <em>poor dependency management leads to code that is hard to change, fragile, and non-reusable</em>. So, this principle is directly related with two of the OOP mantras--reusability, and maintainability (the capacity to change as the project grows, one of the main goals of inheritance).</p>
<p>Overall, Martin stated his 11 commandments to consider, but they can be divided into three areas:</p>
<ul>
<li>The five SOLID principles, which deal with class design</li>
<li>The other six principles, mainly focused on packages--three of them are about package cohesion, and the other three explain the dangers of package coupling and how to evaluate a package structure</li>
</ul>
<p>We're going to start with the SOLID principles, which by extension not only affect the class design, but also other aspects of software architecture.</p>
<p>The application of these ideas has, for example, been decisive in important modifications made to the HTML5 standard. Concretely, the application of the <strong>SRP</strong> (<strong>Single Responsibility principle</strong>) only highlighted the need to totally separate presentation (CSS) from content (HTML) and the subsequent deprecation of some tags (<kbd>&lt;cite&gt;</kbd>, <kbd>&lt;small&gt;</kbd>, <kbd>&lt;font&gt;</kbd>).</p>
<p>This applies to other popular frameworks as well, such as AngularJS (and even more in Angular 2), both designed not only with the Single Responsibility principle in mind but also based on the <strong>Dependency Inversion</strong> principle (the <strong>D</strong> in SOLID).</p>
<p>The following diagram schematizes the five principles' initials and correspondences:</p>
<div><img height="193" width="333" src="img/433e9b9f-6c4e-4c2c-9bd5-f5c088ae6f4d.png"/></div>
<p>The explanation of every letter in the acronym as expressed in Wikipedia is as follows:</p>
<ul>
<li><strong>S - Single Responsibility Principle</strong>: A class should have only a single responsibility (that is, only one potential change in the software's specification should be able to affect the specification of the class). Martin states that this principle is based on the principle of cohesion, previously defined by Tom de Marco in a book named <em>Structured Analysis and Systems Specification</em> and by Meilir Page-Jones in his work <em>The Practical Guide to Structured Systems Design</em>.</li>
<li><strong>O - Open/Closed Principle</strong>: Software entities should be open for extension, but closed for modification. Bertrand Meyer was the first to propose this principle. Martin puts this in another way at <a href="http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>, saying that <em><em>You should be able to extend a class's behavior, without modifying it.</em></em></li>
<li><strong>L - Liskov Substitution principle</strong>: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. Barbara Liskov first stated this, and Martin rephrases the principle in this manner--<em>Derived classes must be substitutable for their base classes</em>.</li>
<li><strong>I - Interface Segregation principle</strong>: <em>Many client-specific interfaces are better than one general-purpose interface</em>. Robert C. Martin was the first to use and formulate this principle, which he rewords in the aforementioned article as--<em>Make fine grained interfaces that are client specific.</em></li>
<li><strong>D - Dependency inversion principle</strong>: <em>We should 'Depend on Abstractions'. Do not depend upon concretions</em>. This too is an idea developed by Robert C. Martin.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Single Responsibility Principle (SRP)</h1>
                
            
            
                
<p>The <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>), focuses on the fact that there should never be more than one reason for a class to change. In this context, responsibility is defined as a reason for a change. If, under any circumstances, more than one reason comes up to change the class, then the class' responsibilities are multiple and should be redefined.</p>
<p>This is, indeed, one of the most difficult principles to apply properly because as Martin says, <em>conjoining responsibilities is something that we do naturally</em>. In his book, <em>Agile Principles, Patterns, and Practices in C#</em>, Martin proposes a canonical example to show the differences, as follows:</p>
<pre>    interface Modem 
    { 
      public void dial(String phoneNumber); 
      public void hangup(); 
      public void send(char c); 
      public char recv(); 
   } </pre>
<p>Given the previous interface, any class implementing it has two responsibilities: connection management and the communication itself. Such responsibilities can be used from the different parts of an application, which, in turn, might change as well.</p>
<p>We're going to use the Visual Studio 2017 Class Designer to express the way Martin proposes we express this class design instead:</p>
<div><img height="280" width="326" class=" image-border" src="img/77024a2f-1d84-4232-ae00-e7317be4c6f5.png"/></div>
<p>As we see, in Martin's solution, the class depends on two interfaces, each one in charge of a responsibility--connection and channel transmission (two abstractions, really: remember that an interface is not compiled and it only serves as a contract for the compiler to check).</p>
<p>However, one wonders, should these two responsibilities be separated? It only depends on application changes. To be precise, the key here is to know whether changes in the application affect the signature of connection functions. If they do, we should separate both; otherwise, there's no need for separation because we would then create needless complexity.</p>
<p>So, overall, a reason to change is the key, but keep in mind that a reason to change is applicable only if changes occur.</p>
<p>In other situations, there might be reasons to keep distinct responsibilities together as long as they are closely related to the business definitions or have to do with the hardware requirements of the operating system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The background of the Separation of Concerns (SoC)</h1>
                
            
            
                
<p>As always happens, there were previous approaches to the problem of software separation. Dijkstra in "<em>On the role of scientific thought</em>" (<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html">http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html</a>) mentioned that <em>It is what I sometimes have called "the separation of concerns", which, even if not perfectly possible, is yet the only available technique for effective ordering of one's thoughts, that I know of.</em></p>
<p>Another advance was Information Hiding, defined by Wikipedia (<a href="https://en.wikipedia.org/wiki/Information_hiding">https://en.wikipedia.org/wiki/Information_hiding</a>) as <em>the principle of segregation of the design decisions in a computer program that</em> <em>are</em> <em>most likely to change, thus protecting other parts of the program from extensive modification if the design decision is changed.</em> This was the seed that later became a basic pillar of OOP--Data Encapsulation.</p>
<p>Even Barbara Liskov, whom we mentioned in connection with the substitution principle, published at the same time <em>Programming With Abstract Data Types</em> (<a href="http://dl.acm.org/citation.cfm?id=807045">http://dl.acm.org/citation.cfm?id=807045</a>), which she describes as an approach to the computer representation of abstraction. The definition of ADTs as a class of objects whose logical behavior is defined by a set of values and a set of operations links data and functionality.</p>
<p>Later approaches have improved these ideas. Proposals for Code Contracts, originally introduced by Bertrand Meyer in his Eiffel language, and implemented in C# via Code Contracts (<a href="https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx)">https://msdn.microsoft.com/es-es/library/dd264808(v=vs.110).aspx)</a> foster the use of pre and post conditions that our software has to accomplish.</p>
<p>Finally, we can think of the separation of what Hayim Makabee (<a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/">https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/</a>) reports as cross-cutting concerns--aspects that might affect distinct pieces of software in even distinct layers of the application and that should be managed in a similar fashion (authorization or instrumentation issues, and so on.). In .Net, we count on Attributes, applicable equally to classes and class members, to modify and tune such behavior.</p>
<p>A bit later in the same article, Makabee clearly establishes the main purposes for these techniques. If we understand coupling as the degree of dependency between two modules, the goal is to obtain low coupling. Another term is cohesion or the measure of how strongly-related the set of functions performed by a module is. Obviously, high cohesion is better.</p>
<p>He ends by summarizing the benefits obtained with these techniques:</p>
<p>Patterns and methodologies are always intended to reduce coupling and at the same time increase congruity. By hiding information, we reduce coupling since we isolate implementation details. Thus, ADT's reduce coupling by using clear and abstract interfaces. We have an ADT specifying the set of function that can be executed on a type, that's more cohesive than a global data structure modified by external functions. The way that OOP reaches that cohesion is the implementation of two of its basic principles--encapsulation and polymorphism, together with dynamic binding. Furthermore, inheritance reinforces cohesion by means of hierarchies that are based on generalization and specialization, which permits a suitable separation from the functionality belonging to a superclass from its subclasses. AOP, in turn, supplies solutions for cross-cutting concerns in a way that both aspects and functionality may become more cohesive.</p>
<p>Maintainability, reusability, and extensibility are only three of the main advantages gained with its implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Well-known examples of Separation of Concerns</h1>
                
            
            
                
<p>All of us have gone through cases and scenarios where the separation of concerns lies at the heart of the system or technology that implements it. One such case is HTML (and, especially HTML5).</p>
<p>Since its inception, the standard HTML5 was thought to clearly separate content from presentation. And the popularity of mobile devices only made that requirement more evident. The huge variety of form factors available today demanded a technology capable of adapting to these sizes, in such a way that content could be held by HTML tags and the final presentation in a given device decided at runtime depending on the device.</p>
<p>Therefore, some tags were declared deprecated, such as <kbd>&lt;font&gt;</kbd>, <kbd>&lt;big&gt;</kbd>, <kbd>&lt;center&gt;</kbd>, and a list of others, and the same happened to some attributes, such as <kbd>background</kbd>, <kbd>align</kbd>, <kbd>bgcolor</kbd>, or <kbd>border</kbd> since they didn't make sense in this new system. Even some of them that still remain unchanged and that have a visual effect on the output (such as <kbd>&lt;b&gt;</kbd>, <kbd>&lt;i&gt;</kbd>, or <kbd>&lt;small&gt;</kbd>) are kept for their semantic meaning and not for their presentational effects, which is a role totally dependent on CSS3.</p>
<p>So, one of the main goals is to avoid functionality overlapping, although this is not the only benefit. If we understand concerns as the different aspects of software functionality, the business logic of software is a concern, and the interface through which a person uses this logic is another.</p>
<p>In practice, this translates into keeping the code for each of these concerns separate. That means, changing the interface should not require changing the business logic code, and vice versa. The underlying principle of encapsulation reinforces these ideas in the OOP paradigm, and the <strong>Model-view-controller</strong> (<strong>MVC</strong>) design pattern is a great example of separating these concerns for better software maintainability.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A basic sample of Separation of Concerns</h1>
                
            
            
                
<p>Let's put this into code with a very basic sample and check for the differences between coupled and decoupled implementations. Imagine that a Console application in .NET Core has to show the user the initial configuration of Console colors, change a value, and present those changes.</p>
<p>If you make a basic project <kbd>ConsoleApp1</kbd>, the following code could be the first approach:</p>
<pre>    using System; 
 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        Console.ResetColor(); 
        Console.WriteLine("This is the default configuration for Console"); 
        Console.ForegroundColor = ConsoleColor.Cyan; 
        Console.WriteLine("Color changed..."); 
        Console.Read(); 
      } 
    } </pre>
<p>This produces the expected results (see the following screenshot showing the output):</p>
<div><img height="98" width="333" class=" image-border" src="img/2b26742b-2bde-43dc-946c-74cbb2e91fd1.png"/></div>
<p>Which problems can we find in this code? First, the main point is in charge of everything: resets the previous initial configuration of the console, changes the foreground, and prints the results.</p>
<p>The first attempt at separation would be to realize that further needs might require other fragments of code to use the same functionality. Even more, that functionality would be better located in another difference-- a piece of software such as a library, for example. So, we should enhance our solution with a new project containing a library project that would be referenced by any other projects along with the solution.</p>
<p>Besides, the manual change to Cyan color implicitly reminds us of the need for a function that allows changing to any valid color.</p>
<p>So, we might end up with another piece of code like this:</p>
<pre>    namespace Utilities 
    { 
      public class ConsoleService 
      { 
        public void ChangeForegroundColor(ConsoleColor newColor) 
        { 
            Console.ForegroundColor = newColor; 
        } 
        public void ResetConsoleValues() 
        { 
            Console.ResetColor(); 
        } 
      } 
    } </pre>
<p>Now, in the main entry point, we could write:</p>
<pre>    /* This is version 2 (with utilities) */ 
    ConsoleService cs = new ConsoleService(); 
    cs.ResetConsoleValues(); 
    Console.WriteLine("This is the default configuration for Console"); 
    cs.ChangeForegroundColor(ConsoleColor.Cyan); 
    Console.WriteLine("Color changed..."); 
    Console.Read(); </pre>
<p>With exactly the same results (I omit the output since there are no changes). So, we made a physical separation together with a logical one, given that now any change to the <kbd>Console</kbd>, should be managed by the <kbd>Utilities</kbd> library, which increases their reusability and therefore maintainability and testing.</p>
<p>Notice also that we could have opted for creating the library as static, to avoid instantiation.</p>
<p>The only change over previous versions of .NET is that, as we showed in a previous screenshot, the reference to the library is now made slightly differently, as it appears in the Dependencies section on the Solution Explorer. Once the project is compiled, we can also see that reference in the <kbd>bin</kbd> directory resulting from compilation:</p>
<div><img height="119" width="293" src="img/c8c31586-699a-49c0-ae4f-e844ade412e2.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Another sample</h1>
                
            
            
                
<p>Let's take a more everyday approach with another sample: something simple, such as reading from a JSON file on a disk and presenting the results in the output. So, I've created a .NET Core Console app that includes a JSON file with five books from PACKT.</p>
<p>A first approach could be the following code:</p>
<pre>    using System; 
    using System.IO; 
    using Newtonsoft.Json; 
 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        Console.WriteLine(" List of Books by PACKT"); 
        Console.WriteLine(" ----------------------"); 
        var cadJSON = ReadFile("Data/BookStore.json"); 
        var bookList = JsonConvert.DeserializeObject&lt;Book[]&gt;(cadJSON); 
        foreach (var item in bookList) 
        { 
            Console.WriteLine($" {item.Title.PadRight(39,' ')} " +  
                $"{item.Author.PadRight(15,' ')} {item.Price}");  
        } 
        Console.Read(); 
      } 
 
      static string ReadFile(string filename) 
      { 
        return File.ReadAllText(filename); 
      } 
    } </pre>
<p>As we can see, the code uses a <kbd>Book</kbd> class that implements the <kbd>IBook</kbd> interface, defined in a very simple manner:</p>
<pre>    interface IBook 
    { 
      string Title { get; set; } 
      string Author { get; set; } 
      double Price { get; set; } 
    } 
    class Book : IBook 
    { 
      public string Author { get; set; } 
      public double Price { get; set; } 
      public string Title { get; set; } 
    } </pre>
<p>This works fine, and generates the following output:</p>
<div><img height="139" width="466" src="img/055ba326-0689-4f4c-bbc1-2228223eb651.png"/></div>
<p>Notice that we're using the popular Newtonsoft JSON library, to easily convert the string into an array of <kbd>Book</kbd> objects.</p>
<p>If we analyze the code, we can identify several places where that SoC principle is present:</p>
<ul>
<li>First, since the entity to manage is a <kbd>Book</kbd> (which has three properties), I created a <kbd>Model</kbd> folder to hold the definition of a <kbd>Book</kbd> interface (<kbd>IBook</kbd>), and also a <kbd>Book</kbd> class that implements that interface</li>
<li>Secondly, the use of the <kbd>Newtonsoft</kbd> library is another separation since it's the library that takes care of the conversion of the string into an array of <kbd>Books</kbd></li>
<li>Finally, file reading takes place in the method <kbd>ReadFile()</kbd>, which receives the name of the file</li>
</ul>
<p>Is there any other separation required? As we mentioned, the reason to change would be key at the time to decide. For example, does the app read another type of information (apart from <kbd>Books</kbd>)? Or, does our UI really need to include the <kbd>ReadFile()</kbd>method? And what about having to reference directly the <kbd>Newtonsof</kbd>t library directly in the user interface?</p>
<p>If this isn't the case, perhaps a better approach would be to separate that method in a <kbd>Utilities</kbd> class, just like in the first sample, thus ensuring architecture has three separate folders to hold different aspects of the application: the data model, the utilities area, and the main user interface.</p>
<p>In this manner, we would end up with a <kbd>Utilities</kbd> class like this:</p>
<pre>    using Newtonsoft.Json; 
    using System.IO; 
 
    internal class Utilities 
    { 
      internal static Book[] ReadData() 
      { 
        var cadJSON = ReadFile("Data/BookStore.json"); 
        return JsonConvert.DeserializeObject&lt;Book[]&gt;(cadJSON); 
      } 
 
      static string ReadFile(string filename) 
      { 
        return File.ReadAllText(filename); 
      } 
    } </pre>
<p>And the resulting <kbd>Program</kbd> class gets reduced to the following:</p>
<pre>    using System; 
 
    class Program 
    { 
      static void Main(string[] args) 
      { 
        var bookList = Utilities.ReadData(); 
        PrintBooks(bookList); 
      } 
 
      static void PrintBooks(Book[] books) 
      { 
        Console.WriteLine(" List of Books by PACKT"); 
        Console.WriteLine(" ----------------------"); 
        foreach (var item in books) 
        { 
          Console.WriteLine($" {item.Title.PadRight(39, ' ')} "  + <br/>             $"{item.Author.PadRight(15, ' ')} {item.Price}"); 
        } 
        Console.Read(); 
      } 
    }  </pre>
<p>Of course, we get the same output, but now we have an initial separation of concerns. There's no need to reference external libraries in the UI, which facilitates maintainability and extensibility.</p>
<p>Let's now explore the second principle: Open/Closed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Open/Closed principle</h1>
                
            
            
                
<p>We can detect the need to use this principle when a change in the module results in a cascade of changes that affect dependent modules. The design is said to be too inflexible.</p>
<p>The <strong>Open/Closed principle</strong> (<strong>OCP</strong>) principle advises us that we should refactor the application in such a manner that future changes don't provoke further modifications.</p>
<p>The form to apply this principle correctly would be by extending the functionality with new code (for instance, using polymorphism) and never changing the old code, which is working already. We can find several strategies to achieve this goal.</p>
<p>Observe that closed for modification is especially meaningful when you have distinct, separate modules (DLLs, EXEs, and so on) that depend on the module that has to be changed.</p>
<p>On the other hand, using extension methods or polymorphic techniques allows us to perform changes in code without affecting the rest. Think, for example, about the extension methods available in the C# language since version 3.0.</p>
<p>You can consider extension methods as a special type of static methods with the difference being that they are called as if they were instance methods of the extended type. You find a typical example in the LINQ standard query operators because they add a query functionality to the existing types, such as <kbd>System.Collections.IEnumerable</kbd> or <kbd>System.Collections.Generic.IEnumerable&lt;T&gt;</kbd>.</p>
<p>The classical and simplest example of this pattern is the client/server cohesion that has been largely seen in development for many years. It is preferable that clients depend on server abstractions, not on their concretions.</p>
<p>This can be achieved with interfaces. Servers can implement a client interface that clients will use to connect to them. In this manner, servers can change without affecting the way clients use them (refer to the following diagram):</p>
<div><img height="159" width="254" class=" image-border" src="img/8ce953ba-b990-4382-9cca-78e872b36543.png"/></div>
<p>Any subtype of the client interface will be free to implement the interface in the way it deems more appropriate, and as long as it doesn't break other clients' access.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Back to our sample</h1>
                
            
            
                
<p>Let's imagine a simple case in which the app has to cover a new aspect. For example, the app now has to allow the user to list an extra file of books to be added to the previous list.</p>
<p>For this new requirement, we can create a new and overloaded <kbd>ReadData()</kbd> method that receives an extra argument. Notice here that the argument doesn't even have to be used. It's enough if it declares another signature to be invoked for this extra situation.</p>
<p>If we have the extra data in another file (<kbd>BookStore2</kbd>.<kbd>json</kbd>, in our demo), we could create this extra version of the method:</p>
<pre>     internal static List&lt;Book&gt; ReadData(string extra) 
     { 
       List&lt;Book&gt; books = ReadData(); 
       var cadJSON = ReadFile("Data/BookStore2.json"); 
       books.AddRange(JsonConvert.DeserializeObject&lt;List&lt;Book&gt;&gt;(cadJSON)); 
       return books; 
     } </pre>
<p>Notice that we don't even use the method's argument in this implementation (of course, there are other ways to do this, but let's put it this way for the purpose of the demo).</p>
<p>We have now two versions of <kbd>ReadData()</kbd> that should be called in the user interface depending on the user's choice (I also changed the <kbd>Book[]</kbd> definition into a <kbd>List&lt;Book&gt;</kbd> for simplicity, but you can see the older version as well in the source code):</p>
<pre>    static List&lt;Book&gt; bookList; 
    static void Main(string[] args) 
    { 
      Console.WriteLine("Please, press 'yes' to read an extra file, "); 
      Console.WriteLine("or any other key for a single file"); 
      var ans = Console.ReadLine(); 
      bookList = (ans != "yes") ? Utilities.ReadData() : Utilities.ReadData(ans); 
      PrintBooks(bookList); 
    } </pre>
<p>Now if the user's answer is <em>yes</em> you have an extra set of books added to the list, as you can see in the output:</p>
<div><img class=" image-border" src="img/e265aab9-543e-48d8-aa15-7a4f66f11b2f.png"/></div>
<p>Besides all these reasons, you can think of situations such as having the <kbd>Utilities</kbd> code separated in a distinct library that could also be used by other parts of the application. The implementation of the Open/Closed principle here allows a more stable and extensible approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Liskov Substitution principle</h1>
                
            
            
                
<p>Let's remember this definition--subtypes must be substitutable for their base types. This means that this should happen without breaking the execution or losing any other kind of functionality.</p>
<p>You'll notice that this idea lies behind the basic principles of inheritance in the OOP programming paradigm.</p>
<p>If you have a method that requires an argument of the <kbd>Person</kbd> type (let's put it that way), you can pass an instance of another class (<kbd>Employee</kbd>, <kbd>Provider</kbd>, and so on) as long as these instances inherit from <kbd>Person</kbd>.</p>
<p>This is one of the main advantages of well-designed OOP languages, and most popular and accepted languages support this characteristic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Back to the code again</h1>
                
            
            
                
<p>Let's take a look at the support inside our sample, where a new requirement arises. Actually, our demo simply calls the <kbd>PrintBooks</kbd> method and expects to receive a <kbd>List&lt;Book&gt;</kbd> object as the argument.</p>
<p>However, another reason for change might come up when new lists of books appear, and those lists include some new field, like the topic each book belongs to (.NET, Node, Angular, and so on).</p>
<p>For example, a new list appears containing a fourth field, <kbd>Topic</kbd>, in this way:</p>
<pre>    { 
      "Title": "AngularJS Services", 
      "Author": "Jim Lavin", 
      "Price": 30.99, 
      "Topic": "Angular" 
    } </pre>
<p>The class <kbd>Book</kbd> should not be changed since it's being used already. Thus, we can inherit from <kbd>Book</kbd> and create a <kbd>TopicBook</kbd> class just adding the new field (I'm trying to keep things as simple as possible to focus on the architecture we're dealing with):</p>
<pre>    public class TopicBook : Book 
    { 
      public string Topic { get; set; } 
    }</pre>
<p>To cover this new aspect, we can change the user interface to allow the user to select a new option (<kbd>topic</kbd>) that includes the new type of book:</p>
<pre>    static void Main(string[] args) 
    { 
      Console.WriteLine("Please, press 'yes' to read an extra file, "); 
      Console.WriteLine("'topic' to include topic books or any<br/>          other key for a single file"); 
      var ans = Console.ReadLine(); 
      bookList = ((ans != "yes") &amp;&amp; (ans != "topic")) ?  
        Utilities.ReadData() : Utilities.ReadData(ans); 
      PrintBooks(bookList); 
    }   </pre>
<p>Notice that we're just including a new condition and calling the overloaded method in case the new condition is selected.</p>
<p>As for the <kbd>ReadData()</kbd> overloaded method, we can make some minimal changes (basically, adding an <kbd>if</kbd> condition to include the extra data), like you can see in the following code:</p>
<pre>    internal static List&lt;Book&gt; ReadData(string extra) 
    { 
      List&lt;Book&gt; books = ReadData(); 
      var filename = "Data/BookStore2.json"; 
      var cadJSON = ReadFile(filename); 
         books.AddRange(JsonConvert.DeserializeObject&lt;List&lt;Book&gt;&gt;(cadJSON)); 
      if (extra == "topic") 
      { 
         filename = "Data/BookStore3.json"; 
         cadJSON = ReadFile(filename); 
         books.AddRange(JsonConvert.DeserializeObject&lt;List&lt;TopicBook&gt;&gt;(cadJSON)); 
      } 
      return books; 
    } 
 </pre>
<p>Observe that the method's changes are minimal, and especially that we're adding to the list of books the result of deserializing a different class (<kbd>TopicBook</kbd>), without any compilation or execution problems.</p>
<p>Therefore, the implementation of Generics in .NET (and .NET Core, in this case) correctly implements the Liskov Substitution Principle, and we don't have to make modifications in our logic.</p>
<p>We can check the results in the Automatic Window using a breakpoint before the <kbd>return</kbd> sentence of <kbd>ReadData</kbd> and seeing how the <kbd>List&lt;Book&gt;</kbd> now includes five elements of type <kbd>TopicBook</kbd>, with no complaints:</p>
<div><img height="321" width="523" class=" image-border" src="img/93b4c95e-e217-47b0-917a-6c54857c62ca.png"/></div>
<p>What about the other side (the user interface logic) and, especially, our <kbd>PrintBooks</kbd> method, which expects a <kbd>List&lt;Book&gt;</kbd>? Well, there's no difference insofar as we don't try to print out a field that doesn't exist.</p>
<p>You can check the output in the following screenshot:</p>
<div><img height="272" width="485" class=" image-border" src="img/d7689355-b322-49c0-a426-ec60a6c98b46.png"/></div>
<p>Thanks to the Liskov Substitution principle support, we were able to add behavior and information with minimum effort, and consequently, enforce the OOP principle of code reutilization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other implementations of LSP in .NET</h1>
                
            
            
                
<p>What we've seen up to this point is not the only implementation of the LSP principle that we find inside .NET, since different areas of the framework, have grown using this conception.</p>
<p>Events are flexible enough to be defined in a way that allows us to pass our own information via classic definitions, alternatively with the participation of generics, we can simply define a generic event handler that holds information of any kind. All these techniques foster the implementation of good practices, not just the SOLID principles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Interface Segregation principle</h1>
                
            
            
                
<p>As Martin states, this principle deals with the inconveniences of <em>fat</em> interfaces. And the problem arises when the interfaces of the class can be logically fragmented into distinct groups or methods.</p>
<p>In this case, if there is more than one client of our application, chances are that some clients are connected to a functionality they never use. As Martin states in his <em>Agile Principles Patterns and Practices in C#</em> book,</p>
<p>When the clients are separate, the interfaces should remain separate, too. Why? Because clients exert forces on their server interfaces. When we think of forces that cause changes in software, we normally think about how changes to interfaces will affect their users.</p>
<p>And, as a conclusion, he remarks that</p>
<p>When clients are forced to depend on methods they don't use, those clients are subject to changes to those methods. This results in an inadvertent coupling between all the clients. Said another way, when a client depends on a class that contains methods that the client does not use but that other clients do use, that client will be affected by the changes that those other clients force on the class. We would like to avoid such couplings where possible, and so we want to separate the interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Another sample</h1>
                
            
            
                
<p>Let's see this situation with another example that starts from a new scenario. Let's imagine another app in which we have to cover not only the two types of books available at the moment but also a new publication in video format, that holds another field named <kbd>Duration</kbd>.</p>
<p>A single record of this file would look like this:</p>
<pre>     { 
       "Title": "HTML 5 Game Development", 
       "Author": "Daniel Albu", 
       "Price": 5.68, 
       "Topic": "HTML5 Games", 
       "Duration": "2h20m" 
     }  </pre>
<p>But the application maintains the other two previous formats, so we have the possibility to list files with three, four, or five fields, depending on the initial selection the user chooses.</p>
<p>A first approach could lead us to an interface like this:</p>
<pre>    interface IProduct 
    { 
      string Title {get; set;} 
      string Author {get; set;} 
      double Price {get; set;} 
      string Topic { get; set; } 
      string Duration { get; set; } 
    } </pre>
<p>Based on this interface we could create the <kbd>Product</kbd> class (the new name is supposed to locate a step above the books or videos since both have four fields in common):</p>
<pre>    public class Product : IProduct 
    { 
      public string Title { get; set; } 
      public string Author { get; set; } 
      public double Price { get; set; } 
      public string Topic { get; set; } 
      public string Duration { get; set; } 
    } </pre>
<p>Now, the equivalent <kbd>Utilities</kbd> class could select a file depending on the user's entry, read it, deserialize it, and send the information back to a <kbd>PrintProducts</kbd> method in charge of the console output.</p>
<p>Our new user interface would look like this:</p>
<pre>    using System;
    using System.Collections.Generic;

    class Program
    {
      static List&lt;Product&gt; productList;
      static void Main(string[] args)
      {
        string id = string.Empty;
        do
        {
            Console.WriteLine("File no. to read: 1/2/3-Enter(exit): ");
            id = Console.ReadLine();
            if ("123".Contains(id) &amp;&amp; !String.IsNullOrEmpty(id))
            {
                productList = Utilities.ReadData(id);
                PrintBooks(productList);
            }
        } while (!String.IsNullOrWhiteSpace(id));
      }

      static void PrintBooks(List&lt;Product&gt; products)
      {
        Console.WriteLine(" List of Products by PACKT");
        Console.WriteLine(" ----------------------");
        foreach (var item in products)
        {
            Console.WriteLine($" {item.Title.PadRight(36, ' ')} " +
            $"{item.Author.PadRight(20, ' ')} {item.Price}" + " " +
            $"{item.Topic?.PadRight(12, ' ') } " +]
            $"{item.Duration ?? ""}");
        }
        Console.WriteLine();
      }
    }</pre>
<p>Observe that we had to deal with the two cases in which some field could be null, so we use string interpolation, together with the null coalescence operator (<kbd>??</kbd>) and the Null-conditional operator (<kbd>?</kbd>), to prevent failure in these cases.</p>
<p>The <kbd>Utilities</kbd> class gets reduced to a much simpler code:</p>
<pre>    using System.Collections.Generic;
    using System.IO;

    internal class Utilities
    {
      internal static List&lt;Product&gt; ReadData(string fileId)
      {
        var filename = "Data/ProductStore" + fileId + ".json";
        var cadJSON = ReadFile(filename);
        return JsonConvert.DeserializeObject&lt;List&lt;Product&gt;&gt;(cadJSON);
      }
      static string ReadFile(string filename)
      {
        return File.ReadAllText(filename);
      }
    }</pre>
<p>The output lets the user select a number and print the file's content in a similar way to what we did in previous demos, only this time selecting each file individually:</p>
<div><img height="386" width="501" class=" image-border" src="img/4d0040db-0d58-4b08-b5e9-891917d4b7a0.png"/></div>
<p>If our application now requires more changes, like the addition of statistics, for example, the use of a single class to hold them all (the <kbd>Product</kbd> class, here) denotes a violation of the Interface Segregation principle.</p>
<p>This is because we should separate the interfaces and use a compound approach to prevent a class from dealing with unwanted or unneeded functionality.</p>
<p>The alternative and proper separation could be to create the following (distinct) interfaces:</p>
<pre>    interface IProduct
    {
      string Title { get; set; }
      string Author { get; set; }
      double Price { get; set; }
    }

    interface ITopic
    {
      string Topic { get; set; }
    }

    interface IDuration
    {
      string Duration { get; set; }
    }</pre>
<p>Now we should have three classes, since three entities can be distinguished, but could maintain three fields in common. The definitions of the three classes could be expressed in this way:</p>
<pre>    class Book : IProduct
    {
      public string Author { get; set; }
      public double Price { get; set; }
      public string Title { get; set; }
    }
    class TopicBook: IProduct, ITopic
    {
      public string Author { get; set; }
      public double Price { get; set; }
      public string Title { get; set; }
      public string Topic { get; set; }
    }
    class Video: IProduct, ITopic, IDuration
    {
      public string Author { get; set; }
      public double Price { get; set; }
      public string Title { get; set; }
      public string Topic { get; set; }
      public string Duration { get; set; }
    }</pre>
<p>Thanks to this division every entity keeps its own personality, and we can later create methods that use generics, or apply the Liskov Substitution principle to deal with the distinct requirements that might arise during the lifecycle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Dependency Inversion principle</h1>
                
            
            
                
<p>The last of the SOLID principles is based on two statements, which Wikipedia (<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a>) defines in this form:</p>
<ul>
<li><em>High-level modules should not depend on low-level modules. Both should depend on abstractions</em></li>
<li><em>Abstractions should not depend upon details. Details should depend upon abstractions</em></li>
</ul>
<p>As for the first statement, we should clarify what we understand by high-level and low-level modules. The terminology is related to the importance of the actions performed by the module with respect to the application as a whole.</p>
<p>Let's put it simply: if a module holds the business logic of a <kbd>Customers</kbd> class, and another module <kbd>PrinterService</kbd> includes the format that a list of the <kbd>Customers</kbd> class uses in a report, the first one would be high-class and the second would be low-class (the reason for the existence of the second is to provide some functionality to the first).</p>
<p>The second statement speaks for itself. If an abstraction depends on details, the usage as a definition contract is compromised (a change in the details could force a redefinition).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The (more or less) canonical example</h1>
                
            
            
                
<p>Dependency Injection techniques are just a way of implementing this principle, and we will see them exemplified in many forms and scenarios along this book.</p>
<p>So, I'll use here the (almost) canonical code that you could find on the internet about this subject. I'm showing you here an adaptation made by Munir Hassan (<a href="https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency">https://www.codeproject.com/Articles/495019/Dependency-Inversion-Principle-and-the-Dependency</a>) in CodeProject which uses a notification scenario to illustrate this situation, and I think it's particularly interesting. He starts with an initial code such as this:</p>
<pre>    public class Email
    {
      public void SendEmail()
      {
        // code
      }
    }
    public class Notification
    {
      private Email _email;
      public Notification()
      {
        _email = new Email();
      }
      public void PromotionalNotification()
      {
        _email.SendEmail();
      }
    }</pre>
<p>Notification depends on <kbd>Email</kbd>, creating an instance in its constructor. This kind of interaction is said to be tightly coupled. If we want to send other types of notification as well, we have to modify the way the <kbd>Notification</kbd> class is implemented.</p>
<p>A way to achieve this could be the introduction of an interface (a new level of abstraction) to define the concept of sending messages and force the <kbd>Email</kbd> class to implement that interface:</p>
<pre>    public interface IMessageService
    {
      void SendMessage();
    }
    public class Email : IMessageService
    {
      public void SendMessage()
      {
        // code
      }
    }
    public class Notification
    {
      private IMessageService _iMessageService;
      public Notification()
      {
        _iMessageService = new Email();
      }
      public void PromotionalNotification()
      {
        _iMessageService.SendMessage();
      }
    }</pre>
<p>Now, the class calls something named <kbd>_iMessageService</kbd>, whose implementation could vary. As Hamir mentions, there are three ways to implement this pattern:</p>
<p>DI is the act of supplying all classes that a service needs rather than leaving the responsibility to the service to obtain dependent classes. DI typically comes in three flavors: Constructor Injection, Property Injection, Method Injection</p>
<p>In the first form, (constructor injection) Hamir proposes the following:</p>
<pre>    public class Notification
    {
      private IMessageService _iMessageService;
      public Notification(IMessageService _messageService)
      {
        this._iMessageService = _messageService;
      }
      public void PromotionalNotification()
      {
        _iMessageService.SendMessage();
      }
    }</pre>
<p>This reminds us of what we will see in the implementation of Dependency Injection in ASP.NET Core in the following chapters. No mention of <kbd>Emails</kbd> here: only an <kbd>IMessageService</kbd> is implied.</p>
<p>You can visit the aforementioned page for more details about the other ways to implement injection, but, as I mentioned, we'll cover all those in detail in the coming chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other ways to implement Dependency Inversion</h1>
                
            
            
                
<p>Generally speaking, there are many ways in which the DIP principle can lead to a solution. Another way to implement this principle is by using the Dependency Injection techniques, derived from another way to see Dependency Inversion: the so-called <strong>Inversion of Control</strong> (<strong>IoC</strong>).</p>
<p>According to the paper written by Martin Fowler (<a href="https://martinfowler.com/articles/injection.html">https://martinfowler.com/articles/injection.html</a>), Inversion of Control is the principle whereby the control flow of a program is inverted; instead of the programmer controlling the flow of a program, the external sources (framework, services, and other components) take control of it.</p>
<p>One of them is a dependency container, which is a component and serves or provides you with some code, injecting it when required.</p>
<p>Some popular Dependency Containers for C# are Unity and Ninject, to name just a couple. In NET Core, there's an embedded container so there's no need to use an external one, except in cases where we might require some special functionality provided by them.</p>
<p>In the code, you instruct this component to register certain classes of your application; so, later on, when you need an instance of one of them, you just have to declare it (typically in the constructor), and it is served to your code automatically.</p>
<p>Other frameworks implement this principle as well, even if they're not purely object-oriented. This is the case with AngularJS or Angular 2, in which, when you create a controller that requires access to a service, you ask for the service in the controller's function declaration, and the internal Angular's DI system serves a singleton instance of the service without the intervention of the client's code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we've reviewed the five SOLID Principles in the way they were formulated by Robert C. Martin in 2000.</p>
<p>We've explored each of these principles, discussing their advantages and checking their implementation with some simple code using .NET Core Console applications, to see how they can be coded.</p>
<p>In the next chapter, we will talk about Dependency Injection and the most popular IoC containers, reviewing how they can be used and analyzing their pros and cons in everyday applications.</p>


            

            
        
    </body></html>