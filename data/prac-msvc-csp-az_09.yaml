- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Authentication and Authorization with Services and Clients
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务和客户端进行身份验证和授权
- en: Not every user and application should be allowed to access all API services.
    Some APIs should only be accessible from specific applications, and others should
    be restricted to a group of users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个用户和应用都应该被允许访问所有 API 服务。某些 API 应仅从特定应用程序访问，而其他 API 应仅限于特定用户组。
- en: In this chapter, you’ll learn how to use **business-to-consumer** (**B2C**)
    to allow users to register with our application and protect APIs. We’ll use Azure
    **Active Directory** (**AD**) B2C for this. For an on-premises solution (which
    can also be used in the cloud), we’ll be using ASP.NET Core Identity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 **企业到消费者** (**B2C**) 允许用户在我们的应用程序中注册并保护 API。我们将使用 Azure **活动目录**
    (**AD**) B2C 来实现这一点。对于本地解决方案（也可以在云中使用），我们将使用 ASP.NET Core Identity。
- en: Instead of securing every API project, you’ll learn about Microsoft **Yet Another
    Reverse Proxy** (**YARP**), a proxy that is put in front of the APIs that are
    available to restrict access to the services in the backend.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每个 API 项目进行安全保护，你将了解 Microsoft **Yet Another Reverse Proxy** (**YARP**)，这是一个放在可用的
    API 前面的代理，用于限制对后端服务的访问。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Create an Azure AD B2C tenant
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Azure AD B2C 租户
- en: Secure REST APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 REST API
- en: Use Microsoft YARP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Microsoft YARP
- en: Use ASP.NET Core Identity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core Identity
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription,
    Docker Desktop, and .NET Aspire.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，就像前面的章节一样，你需要一个 Azure 订阅、Docker Desktop 和 .NET Aspire。
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure)。
- en: 'The `ch09` folder contains the following projects, along with their outputs:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch09` 文件夹包含以下项目及其输出：'
- en: '`Codebreaker.ApiGateway`: This is a new project that will act as an application
    gateway in front of the `game-apis` service and `bot-service` and secure the APIs
    with the help of YARP'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ApiGateway`：这是一个新项目，将在 `game-apis` 服务和 `bot-service` 前充当应用程序网关，并借助
    YARP 保护 API'
- en: '`WebAppAuth`: This is a new project for the client part that focuses on creating
    new users with Azure AD B2C, providing authentication from the client side, and
    invoking `bot-service` via the gateway'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAppAuth`：这是一个新的客户端项目，专注于使用 Azure AD B2C 创建新用户，从客户端提供身份验证，并通过网关调用 `bot-service`'
- en: '`Codebreaker.ApiGateway.Identities`: This is a new project that can be used
    instead of `Codebreaker.ApiGateway` where instead of using Azure AD B2C, local
    users are created and managed'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ApiGateway.Identities`：这是一个新项目，可以用作 `Codebreaker.ApiGateway` 的替代品，其中不是使用
    Azure AD B2C，而是创建和管理本地用户'
- en: To help you go through the code with this chapter, start by using the code from
    the previous chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你使用本章的代码，请首先使用上一章的代码。
- en: Choosing an identity solution
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择身份解决方案
- en: Different options are available to authenticate users with .NET solutions. If
    you require a local database that can manage users, you can use **ASP.NET Core
    Identity**, which makes use of EF Core (see [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)).
    It allows you to store local users and integrate user accounts, such as those
    from Microsoft, Facebook, and Google, with **OpenID Connect** (**OIDC**). For
    the database, SQL Server and MySQL can be used, while the data schema is completely
    customizable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 .NET 解决方案，有多种选项可用于对用户进行身份验证。如果你需要一个可以管理用户的本地数据库，你可以使用 **ASP.NET Core Identity**，它使用
    EF Core（见 [*第 5 章*](B21217_05.xhtml#_idTextAnchor110)）。它允许你存储本地用户并将用户账户（如来自 Microsoft、Facebook
    和 Google 的账户）与 **OpenID Connect** (**OIDC**) 集成。对于数据库，可以使用 SQL Server 和 MySQL，而数据模式是完全可定制的。
- en: To reduce the work required, and to enhance security, it’s not necessary to
    implement this functionality with every service – here, Microsoft YARP can be
    used to forward the requests and send the required claims.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少工作量和提高安全性，不需要在每个服务中实现此功能——在这里，可以使用 Microsoft YARP 来转发请求并发送所需的声明。
- en: If external applications are accessing the identity management solution, an
    **OIDC** server should be used to manage identities. If storing user data in a
    cloud service is not an option, a third-party service such as Identity Server
    from Duende ([https://duendesoftware.com/products/communityedition](https://duendesoftware.com/products/communityedition))
    can be used. This is free for small companies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部应用程序正在访问身份管理解决方案，应使用**OIDC**服务器来管理身份。如果无法在云服务中存储用户数据，可以使用第三方服务，如Duende的Identity
    Server（[https://duendesoftware.com/products/communityedition](https://duendesoftware.com/products/communityedition)）。这对于小型公司是免费的。
- en: To store user data in a cloud service, many companies use **Microsoft Entra**.
    This can easily be integrated with .NET applications. This service offers **business-to-business**
    (**B2B**) functionality that allows you to add external users (**Entra External
    Identities**). Microsoft, Facebook, and Google accounts are on the list of supported
    external users. However, at the time of writing, **Microsoft Entra** does not
    allow users to register themselves. For this, **Azure AD B2C** is a great option.
    This service can also be used with services running on-premises and accessing
    authentication from the cloud.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在云服务中存储用户数据时，许多公司使用**Microsoft Entra**。这可以轻松地与.NET应用程序集成。这项服务提供了**企业对企业**（**B2B**）功能，允许您添加外部用户（**Entra
    External Identities**）。微软、Facebook和谷歌账户都列在支持的外部用户名单中。然而，在撰写本文时，**Microsoft Entra**不允许用户自行注册。为此，**Azure
    AD B2C**是一个很好的选择。此服务还可以与本地运行的并从云中访问身份验证的服务一起使用。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With its user data residency requirement, Azure AD B2C allows you to select
    a country when you’re creating a directory and shows the location for the data.
    However, if, for example, the requirement is to keep the user data in Switzerland,
    it’s stored in Europe, which might not be enough for the legal requirements of
    some businesses.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Azure AD B2C的用户数据居住要求允许您在创建目录时选择一个国家，并显示数据的位置。然而，如果要求将用户数据保留在瑞士，数据将存储在欧洲，这可能不足以满足某些企业的法律要求。
- en: For the Codebreaker solution, we’ll use Azure AD B2C and ASP.NET Core Identity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Codebreaker解决方案，我们将使用Azure AD B2C和ASP.NET Core Identity。
- en: Creating an Azure AD B2C tenant
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Azure AD B2C租户
- en: The Codebreaker solution should allow users to register with the application
    and play different game types. Some limited game types are available to anonymous
    users. All the game types and more functionalities are available to registered
    users. Some parts of the solution should only be accessible to specific user groups
    – for example, `bot-service` should not be accessible from normal registered playing
    users. Specific user permissions (or claims) are required for differentiation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker解决方案应允许用户使用应用程序进行注册并玩不同类型的游戏。一些有限的游戏类型可供匿名用户使用。所有游戏类型和更多功能都可供注册用户使用。解决方案的一些部分应仅对特定用户组可访问——例如，`bot-service`不应从普通注册玩家用户访问。需要特定的用户权限（或声明）来进行区分。
- en: 'To create a new AAD B2C tenant, open the Azure portal and click **Create a
    resource**. Select **Identity** from the left bar and choose **Azure Active Directory
    B2C**. Then, select **Create a new Azure AD B2C Tenant**. This will open the screen
    shown in *Figure 9**.1*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的AAD B2C租户，请打开Azure门户并点击**创建资源**。从左侧栏中选择**身份**，然后选择**Azure Active Directory
    B2C**。然后，选择**创建新的Azure AD B2C租户**。这将打开如图9.1所示的屏幕：
- en: '![Figure 9.1 – Creating an AAD B2C tenant](img/B21217_09_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 9.1 – 创建AAD B2C租户](img/B21217_09_01.jpg)'
- en: Figure 9.1 – Creating an AAD B2C tenant
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 创建AAD B2C租户
- en: To create a new AAD B2C tenant, you need to enter the name of the organization,
    the name of the domain name (a domain name that does not exist yet), the location
    that will be used to define the region where the user data is stored, a subscription,
    and a resource group. Once you’ve done this, click **Review + Create**, then **Create**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的AAD B2C租户，您需要输入组织的名称、域名（一个尚未存在的域名）、用于定义用户数据存储区域的地理位置、订阅和资源组。完成这些操作后，点击**审查
    + 创建**，然后点击**创建**。
- en: You’ll need to wait a short time for the directory to be created. To list the
    directories available to you, and to switch directories, within the Azure portal,
    click the **Settings** button. Select the new directory and click **Switch** to
    change to it. Similarly, you can switch back to the directory where you run Azure
    resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要等待一段时间以创建目录。要在Azure门户中列出您可用的目录，并切换目录，请点击**设置**按钮。选择新目录并点击**切换**以更改到它。同样，您也可以切换回运行Azure资源的目录。
- en: 'In the next few sections, we’ll do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将执行以下操作：
- en: Specify identity providers so that the user doesn’t need to enter another password
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定身份提供者，以便用户不需要输入另一个密码
- en: Configure user attributes to define what information the application needs from
    the user
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户属性以定义应用程序需要从用户处获取的信息
- en: Define user flows to specify how the user information flows
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义用户流程以指定用户信息如何流动
- en: Create app registrations to define service applications that offer APIs and
    client applications for accessing APIs
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序注册以定义提供API和客户端应用程序以访问API的服务应用程序
- en: Specifying identity providers
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定身份提供者
- en: 'When you are in an Azure AD B2C, you can open the Azure AD B2C configuration.
    The B2C directory supports a large list of different identity providers. Users
    don’t need to remember another password when they use identity providers. Within
    the Azure AD B2C configuration, in the **Manage** category in the left pane, select
    **Identity provider** (see *Figure 9**.2*):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处于Azure AD B2C中时，可以打开Azure AD B2C配置。B2C目录支持大量不同的身份提供者。当用户使用身份提供者时，不需要记住另一个密码。在Azure
    AD B2C配置中，在左侧面板的**管理**类别中，选择**身份提供者**（见图*图9.2*）：
- en: '![Figure 9.2 – Identity providers](img/B21217_09_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 身份提供者](img/B21217_09_02.jpg)'
- en: Figure 9.2 – Identity providers
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 身份提供者
- en: By default, **Local account** is configured so that a password is stored locally
    with AAD B2C. You can configure Microsoft, Google, Facebook, and other accounts
    that support OIDC. The Codebreaker directory has GitHub configured as a provider
    because most developers already have a GitHub account.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**本地账户**已配置，以便密码以本地方式与AAD B2C一起存储。您可以配置支持OIDC的Microsoft、Google、Facebook和其他账户。Codebreaker目录已将GitHub配置为提供者，因为大多数开发者已经有了GitHub账户。
- en: For each provider, you’re what needs to be done to configure it. You just need
    to click on the provider to get that information. With GitHub, for example, you
    need to create a GitHub OAuth application to get all the values you need to configure
    this provider. For authenticating services with AAD B2C, you can keep the default
    settings.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个提供者，您需要执行的操作来配置它。您只需单击提供者即可获取该信息。例如，对于GitHub，您需要创建GitHub OAuth应用程序以获取配置此提供者所需的所有值。对于使用AAD
    B2C进行身份验证的服务，您可以保留默认设置。
- en: Configuring user attributes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置用户属性
- en: 'No matter which provider you choose, you must have a way to identify users.
    To gather such information, you must ask your users for details. You can also
    create custom attributes that should be stored in the directory. Within the **Manage**
    category, select **User Attributes**, as shown in *Figure 9**.3*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个提供者，您都必须有一种方法来识别用户。为了收集此类信息，您必须向您的用户索要详细信息。您还可以创建应在目录中存储的自定义属性。在**管理**类别中，选择**用户属性**，如图*图9.3*所示：
- en: '![Figure 9.3 – User Attributes](img/B21217_09_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 用户属性](img/B21217_09_03.jpg)'
- en: Figure 9.3 – User Attributes
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 用户属性
- en: Here, several built-in attributes, such as `Gamer Name` of the `String` type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，有几个内置属性，例如`String`类型的`Gamer Name`。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the **General Data Protection Regulation** (**GDPR**), you need to ensure
    you only collect necessary data and keep it secured, allow the user to ask for
    the data that you’ve stored, and allow the user to delete that data if it doesn’t
    need to be stored for legal reasons.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**通用数据保护条例**（**GDPR**），您需要确保您只收集必要的数据并保持其安全，允许用户请求您存储的数据，并允许用户在不需要因法律原因存储时删除该数据。
- en: Defining user flows
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户流程
- en: With user flows, you define what information should be collected from the user
    when registering or editing the user profile, and what information should be sent
    to the application within **claims**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户流程，您定义在注册或编辑用户配置文件时应从用户处收集哪些信息，以及应在**声明**中发送给应用程序哪些信息。
- en: 'Within the AAD B2C configuration, from the left pane, within the `B2C_1_`.
    Add a name (for example, `SUSI`) and select the **Email** signup identity provider.
    You can also select social providers such as GitHub. Regarding the **User attributes
    and token claims** category, select the user attributes the user should enter
    when this dialogue is shown, as well as the claims that are passed to the application
    within a token, as shown in *Figure 9**.4*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在AAD B2C配置中，从左侧面板中，在`B2C_1_`内添加一个名称（例如，`SUSI`），并选择**电子邮件**注册身份提供者。您还可以选择如GitHub等社交提供者。关于**用户属性和令牌声明**类别，选择当此对话框显示时用户应输入的用户属性，以及作为令牌传递给应用程序的声明，如图*图9.4*所示：
- en: '![Figure 9.4 – Creating a user flow](img/B21217_09_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 创建用户流程](img/B21217_09_04.jpg)'
- en: Figure 9.4 – Creating a user flow
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 创建用户流程
- en: When defining what information to ask from the user, keep GDPR in mind.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义从用户那里请求的信息时，请记住 GDPR。
- en: Azure AD B2C allows you to customize user flow dialogues by specifying company
    branding, changing the page layout, returning custom pages, and adding API connectors
    for custom validators when a user registers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Azure AD B2C 允许您通过指定公司品牌、更改页面布局、返回自定义页面以及在用户注册时添加用于自定义验证器的 API 连接器来自定义用户流程对话框。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User attributes can be filled by creating user flows or **custom policies**.
    See the links in the *Further reading* section for more information. Also, check
    out the source code in the Codebreaker Backend repository ([https://github.com/codebreakerapp/Codebreaker.Backend](https://github.com/codebreakerapp/Codebreaker.Backend)),
    which contains a custom policy for adding groups for privileged users.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户属性可以通过创建用户流程或 **自定义策略** 来填充。有关更多信息，请参阅 *进一步阅读* 部分的链接。还可以查看 Codebreaker 后端存储库中的源代码
    ([https://github.com/codebreakerapp/Codebreaker.Backend](https://github.com/codebreakerapp/Codebreaker.Backend))，其中包含用于为特权用户添加组的自定义策略。
- en: 'As soon as an application has been registered (the next step), you can test
    the user flow, as shown in *Figure 9**.5*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了应用程序（下一步），您就可以测试用户流程，如图 *图 9*.5* 所示：
- en: '![Figure 9.5 – Testing the user flow](img/B21217_09_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 测试用户流程](img/B21217_09_05.jpg)'
- en: Figure 9.5 – Testing the user flow
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 测试用户流程
- en: Selecting the user attributes that should be collected defines the input elements
    of the dialogue. The icon, colors, and layout can be customized. It’s even possible
    to create complete custom dialogues.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 选择应收集的用户属性定义了对话的输入元素。图标、颜色和布局可以自定义。甚至可以创建完整的自定义对话框。
- en: Creating app registrations
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用注册
- en: Next, we’ll learn how to register apps. Here, we will register the application
    gateway that offers APIs and a client application. Other applications can be registered
    similarly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何注册应用。在这里，我们将注册提供 API 和客户端应用程序的应用程序网关。其他应用可以类似地注册。
- en: 'In the **Manage** category in the left pane, click **App registrations**. This
    opens the **App registrations** page, as shown in *Figure 9**.6*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板的 **管理** 类别中，点击 **应用注册**。这将打开 **应用注册** 页面，如图 *图 9*.6* 所示：
- en: '![Figure 9.6 – Registering an app](img/B21217_09_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 注册应用](img/B21217_09_06.jpg)'
- en: Figure 9.6 – Registering an app
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 注册应用
- en: 'Add multiple app registrations: the `Codebreaker.GameAPIs` application offers
    the game APIs, `Codebreaker.Bot` and `Codebreaker.Blazor` are web applications
    that need API permissions, and `Codebreaker.Client` is a client application that
    needs API permissions.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 添加多个应用注册：`Codebreaker.GameAPIs` 应用提供游戏 API，`Codebreaker.Bot` 和 `Codebreaker.Blazor`
    是需要 API 权限的 Web 应用程序，而 `Codebreaker.Client` 是需要 API 权限的客户端应用程序。
- en: When you configure the app registration process, you specify what accounts are
    allowed to use this application. Here, we’ll allow all accounts, externally registered
    users, and the redirect URI. To test the `game-apis` service from the local developer
    system, specify the port number that’s used when running it locally, such as `http://localhost:5453`,
    and click the **Register** button. The link to the Azure container app needs to
    be added later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您配置应用注册过程时，您指定哪些帐户可以使用此应用程序。在这里，我们将允许所有帐户、外部注册的用户和重定向 URI。要测试从本地开发系统测试 `game-apis`
    服务，请指定本地运行时使用的端口号，例如 `http://localhost:5453`，然后点击 **注册** 按钮。稍后需要添加 Azure 容器应用的链接。
- en: Defining scopes
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义作用域
- en: 'You can specify applications that offer APIs via the app registration process.
    In the `games`. Within this scope, add the `Games.Play` and `Games.Query` scopes,
    as shown in *Figure 9**.7*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过应用注册过程指定提供 API 的应用程序。在 `games`。在此范围内，添加 `Games.Play` 和 `Games.Query` 作用域，如图
    *图 9*.7* 所示：
- en: '![Figure 9.7 – Defining scopes](img/B21217_09_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 定义作用域](img/B21217_09_07.jpg)'
- en: Figure 9.7 – Defining scopes
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 定义作用域
- en: Creating a secret
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建密钥
- en: To only allow applications that have been identified applications, you can add
    a certificate or a secret. Instead of using secrets, a better approach could be
    to run the application with a user that is allowed to access the service. Here,
    managed identities can be used. This is not possible in all scenarios.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅允许已识别的应用程序，您可以添加证书或密钥。与使用密钥相比，更好的方法可能是使用允许访问服务的用户运行应用程序。在这里，可以使用托管标识。并非所有场景都支持此操作。
- en: Using the **Certificates and secrets** option from the left pane, create a client
    secret. Secrets cannot be read from the portal again, only after creation. Copy
    the secret before leaving the page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用左侧面板中的**证书和密钥**选项创建一个客户端密钥。密钥创建后无法再次从门户中读取，只能复制。在离开页面之前复制密钥。
- en: Adding API permissions
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加API权限
- en: 'For application registrations that invoke APIs, you need to configure **API
    permissions**, as shown in *Figure 9**.8*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用API的应用程序注册，你需要配置**API权限**，如图9.8所示：
- en: '![Figure 9.8 – Adding API permissions](img/B21217_09_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 添加API权限](img/B21217_09_08.jpg)'
- en: Figure 9.8 – Adding API permissions
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 添加API权限
- en: The `Codebreaker.Blazor` and `Codebreaker.Client` application registrations
    need the `Games.Play` and `Games.Query` application permissions. After adding
    these permissions, click **Grant** **admin consent**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.Blazor`和`Codebreaker.Client`应用程序注册需要`Games.Play`和`Games.Query`应用程序权限。添加这些权限后，点击**授予**
    **管理员同意**。'
- en: Evaluating the app registration process
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估应用程序注册过程
- en: 'With this configuration complete, open `bot-service` and the client applications).
    Then, click **Evaluate my app registration**, as shown in *Figure 9**.9*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此配置后，打开`bot-service`和客户端应用程序。然后，点击**评估我的应用程序注册**，如图9.9所示。
- en: '![Figure 9.9 – Integration assistant results](img/B21217_09_09.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 集成助手结果](img/B21217_09_09.jpg)'
- en: Figure 9.9 – Integration assistant results
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 集成助手结果
- en: The integration assistant offers great information for development, testing,
    releasing, and monitoring when you click the tabs above the recommended configurations.
    If you see some warnings or errors, click the ellipsis (**…**). From here, you
    can check the documentation and open a page where you can change your configuration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 集成助手在点击推荐配置上方的标签时，为开发、测试、发布和监控提供了大量信息。如果你看到一些警告或错误，点击省略号（**…**）。从这里，你可以查看文档并打开一个可以更改你配置的页面。
- en: With Azure AD B2C configured, let’s implement some code so that we can make
    use of AAD B2C.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了Azure AD B2C之后，让我们实现一些代码，以便我们可以利用AAD B2C。
- en: Securing an API
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API
- en: We can now secure every API project. However, there are different ways we can
    do this so that we can reduce the work we need to do. One option is to use Azure
    Container Apps to configure authentication. Instead of configuring this for every
    container app, let’s create a new project that will be secured and routed to multiple
    services. For this, we’ll use **YARP**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保护每个API项目。然而，我们可以以不同的方式来做这件事，以减少我们需要做的工作。一个选项是使用Azure Container Apps来配置身份验证。而不是为每个容器应用配置此设置，让我们创建一个新的项目，该项目将被保护并路由到多个服务。为此，我们将使用**YARP**。
- en: Creating a new project with authentication
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有身份验证的新项目
- en: 'Create a new Web API project by using the .NET template with the `-au` authentication
    option:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`-au`身份验证选项的.NET模板创建一个新的Web API项目：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the .NET CLI, you can also pass all the values needed to configure the
    B2C service, such as `--domain` for the domain, `--aad-b2c-instance` to pass the
    domain link for logging in, `--client-id` for the application ID, `--susi-policy-id`
    for the signup user flow (before it was called *user flow*, it was called *policy*),
    and `--default-scope` to configure a scope. If you don’t assign parameter values
    for these configurations, you just need to change them after they’ve been created
    in the `appsettings.json` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET CLI，你也可以传递配置B2C服务所需的所有值，例如`--domain`用于域名，`--aad-b2c-instance`用于传递登录域名链接，`--client-id`用于应用程序ID，`--susi-policy-id`用于注册用户流程（在它被称为*用户流程*之前，它被称为*策略*），以及`--default-scope`用于配置作用域。如果你没有为这些配置分配参数值，你只需在`appsettings.json`文件中创建后更改它们即可。
- en: 'The NuGet packages related to authentication and authorization that have been
    added to this project are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加到该项目中的与身份验证和授权相关的NuGet包如下：
- en: '`Microsoft.AspNetCore.Authentication.JwtBearer`: This package supports authentication
    using **JSON Web** **Tokens** (**JWT**)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Authentication.JwtBearer`：此包支持使用**JSON Web** **令牌**（**JWT**）进行身份验证'
- en: '`Microsoft.AspNetCore.Authentication.OpenIdConnect`: This package allows authentication
    with an OIDC against identity providers, such as Azure AD B2C'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Authentication.OpenIdConnect`：此包允许使用OIDC与身份提供者进行身份验证，例如Azure
    AD B2C'
- en: '`Microsoft.Identity.Web`: This package provides utilities and middleware for
    authentication flows and user authorization'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Identity.Web`：此包提供用于身份验证流程和用户授权的实用工具和中间件'
- en: '`Microsoft.Identity.Web.DownstreamApi`: This package helps call downstream
    APIs using the same authentication context'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.Identity.Web.DownstreamApi`: 此包有助于使用相同的身份验证上下文调用下游API'
- en: Next, we’ll add YARP to this project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将YARP添加到这个项目中。
- en: Creating an application gateway with YARP
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用YARP创建应用程序网关
- en: When creating a microservices solution, it’s not necessary to implement authentication
    with every service. Instead, you can create a service that acts as a reverse proxy.
    Clients only call into the reverse proxy. This proxy forwards authenticated requests
    to other services. Here, we’ll use Microsoft YARP. A reverse proxy sits in front
    of backend services and intercepts invocations from a client before it is sent
    to the service. The YARP proxy offers different features, such as load balancing,
    rate limiting, switching of protocols, selecting services based on different versions,
    and more. Based on Layer 7, the proxy can read HTTP requests to route based on
    links and HTTP headers, as well as change the protocol that’s used. Here, we’ll
    use a reverse proxy to deal with authentication and authorization before forwarding
    the requests to the backend service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建微服务解决方案时，没有必要为每个服务实现身份验证。相反，你可以创建一个充当反向代理的服务。客户端只调用反向代理。此代理将经过身份验证的请求转发到其他服务。在这里，我们将使用Microsoft
    YARP。反向代理位于后端服务之前，并在请求发送到服务之前拦截来自客户端的调用。YARP代理提供不同的功能，如负载均衡、速率限制、协议切换、根据不同版本选择服务等。基于第7层，代理可以读取HTTP请求，根据链接和HTTP头进行路由，以及更改使用的协议。在这里，我们将使用反向代理来处理身份验证和授权，然后再将请求转发到后端服务。
- en: '*Figure 9**.10* shows the new way to communicate with the services:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.10* 展示了与服务通信的新方法：'
- en: '![Figure 9.10 – Communication via YARP](img/B21217_09_10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 通过YARP进行通信](img/B21217_09_10.jpg)'
- en: Figure 9.10 – Communication via YARP
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 通过YARP进行通信
- en: The reverse proxy routes incoming requests to backend services. The backend
    services that have been routed are `game-apis` and `bot-service`. The client applications
    don’t interact with these services; they just use the YARP gateway.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理将传入的请求路由到后端服务。已路由的后端服务是`game-apis`和`bot-service`。客户端应用程序不与这些服务交互；它们只是使用YARP网关。
- en: In addition to the NuGet packages we added earlier, we need to add the `Yarp.ReverseProxy`
    and `Microsoft.Extensions.ServiceDiscovery.Yarp` NuGet packages. The first one
    is the package for YARP, while the second one allows us to use.NET service discovery
    with YARP.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前添加的NuGet包之外，我们还需要添加`Yarp.ReverseProxy`和`Microsoft.Extensions.ServiceDiscovery.Yarp`
    NuGet包。第一个是YARP的包，而第二个允许我们使用YARP进行.NET服务发现。
- en: Mapping routes with YARP
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用YARP映射路由
- en: 'How the proxy service communicates with the backend APIs can be configured
    both programmatically and using a configuration file. We’ll use the second option
    with the `appsettings.json` file. First, let’s configure the addresses of the
    `game-apis` service and `bot-service`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务如何与后端API通信可以通过编程方式或使用配置文件进行配置。我们将使用`appsettings.json`文件进行第二种选项。首先，让我们配置`game-apis`服务和`bot-service`的地址：
- en: Codebreaker.ApiGatewayIntro/appsettings.json
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGatewayIntro/appsettings.json
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The complete reverse proxy configuration is added to the `ReverseProxy` section,
    The configuration section, called `Clusters`, defines the list of systems that
    are available for the `game-apis` service and `bot-service`. With every service,
    multiple addresses can be added. Using the service discovery YARP package, we
    can use the .NET Aspire named endpoints.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的反向代理配置已添加到`ReverseProxy`部分，配置部分，称为`Clusters`，定义了可用于`game-apis`服务和`bot-service`的系统列表。对于每个服务，可以添加多个地址。使用服务发现YARP包，我们可以使用.NET
    Aspire命名端点。
- en: 'The following code configures the routes that use the cluster configuration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码配置了使用集群配置的路由：
- en: Codebreaker.ApiGatewayIntro/appsettings.json
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGatewayIntro/appsettings.json
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Routes` configuration contains a list of routes. `gamesRoute` references
    the previously specified `gamesapicluster`, while `botRoute` references the hosts
    defined by `botcluster`. The `Match` configuration specifies the `Path` that’s
    used to map the request to the corresponding cluster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes`配置包含一个路由列表。`gamesRoute`引用之前指定的`gamesapicluster`，而`botRoute`引用由`botcluster`定义的主机。`Match`配置指定用于将请求映射到相应集群的`Path`。'
- en: 'We just need to make a small update to the startup code to activate this reverse
    proxy library:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要对启动代码进行少量更新以激活此反向代理库：
- en: Codebreaker.ApiGateway/Program.cs
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway/Program.cs
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `AddReverseProxy` method registers the services that are needed by the reverse
    proxy to the DI container. The `LoadFromConfig` method retrieves the configuration
    values from the previously specified configuration. The `MapReverseProxy` method
    configures the middleware to forward the requests, as defined by the configuration.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddReverseProxy` 方法将反向代理所需的服务注册到 DI 容器中。`LoadFromConfig` 方法从之前指定的配置中检索配置值。`MapReverseProxy`
    方法配置中间件以根据配置转发请求。'
- en: 'With the `AppHost` project, after adding a reference to the gateway project,
    the gateway can be added to the app model:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AppHost` 项目中，在添加对网关项目的引用之后，可以将网关添加到应用程序模型中：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The API gateway needs to reference the `game-apis` service and `bot-service`.
    Here, external HTTP endpoints are no longer needed. Only the gateway needs references
    from outside when it’s deployed to the Azure Container Apps environment, thus
    only the gateway configuration uses the `WithExternalHttpEndpoints` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关需要引用 `game-apis` 服务和 `bot-service`。在这里，外部 HTTP 端点不再需要。当网关部署到 Azure Container
    Apps 环境时，只有网关需要从外部引用，因此只有网关配置使用 `WithExternalHttpEndpoints` 方法。
- en: With this in place, you can start the application and invoke the two services
    via the gateway. The requests are forwarded to the specific service.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，您可以启动应用程序并通过网关调用两个服务。请求被转发到特定的服务。
- en: Next, we’ll add authentication to the gateway.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向网关添加身份验证。
- en: Adding authentication to the gateway
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加网关的身份验证
- en: Using the .NET template for the Web API with Identity already added some code
    for authentication and authorization. We will enhance this code now.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已添加身份验证和授权的 .NET 模板 Web API 已经添加了一些代码。我们现在将增强此代码。
- en: 'We can configure the DI container to authenticate users by invoking the `AddAuthentication`
    method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `AddAuthentication` 方法来配置 DI 容器以通过身份验证用户：
- en: Codebreaker.ApiGateway/Program.cs
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway/Program.cs
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `AddAuthentication` method registers services that are needed for authentication.
    The `JwtBearerDefaults.AuthenticationScheme` argument returns **Bearer** as the
    authentication scheme. Bearer tokens are used with most REST APIs because they
    can be used easily and don’t require encryption but need to perform HTTPS encryption
    to secure it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAuthentication` 方法注册了身份验证所需的服务的服务。`JwtBearerDefaults.AuthenticationScheme`
    参数返回 **Bearer** 作为身份验证方案。Bearer 令牌在大多数 REST API 中使用，因为它们易于使用且不需要加密，但需要执行 HTTPS
    加密以安全地传输。'
- en: '`AddMicrosoftIdentityWebApi` is an extension method that extends `AuthenticationBuilder`
    and protects the API using the Microsoft Identity platform. `AzureAdB2C` is a
    configuration section that specifies the values from AADB2C from `appsettings.json`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMicrosoftIdentityWebApi` 是一个扩展方法，它扩展了 `AuthenticationBuilder` 并使用 Microsoft
    Identity 平台保护 API。`AzureAdB2C` 是一个配置部分，它指定了从 `appsettings.json` 中的 AADB2C 的值：'
- en: Codebreaker.ApiGateway/appsettings.json
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway/appsettings.json
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the `appsettings.json` configuration file, you need to configure your Azure
    AD B2C domain name, the application ID, and the previously configured user flow.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `appsettings.json` 配置文件，您需要配置您的 Azure AD B2C 域名、应用程序 ID 以及之前配置的用户流程。
- en: 'The `AddAuthentication` method specifies the authentication configuration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAuthentication` 方法指定了身份验证配置：'
- en: Codebreaker.ApiGateway/Program.cs
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway/Program.cs
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AddAuthorization` method allows configuration with an `AuthorizationOptions`
    delegate. The options allow you to specify a default policy and named policies.
    The preceding code snippet defines the `playPolicy` and `queryPolicy` policies.
    `playPolicy` requires the `Games.Play` scope to be set, whereas `queryPolicy`
    requires the `Games.Query` scope to be set. `queryPolicy` also requires the user
    to be authenticated. You can define a claim to be passed with the token by using
    the `RequireClaim` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAuthorization` 方法允许使用 `AuthorizationOptions` 代理进行配置。这些选项允许您指定默认策略和命名策略。前面的代码片段定义了
    `playPolicy` 和 `queryPolicy` 策略。`playPolicy` 需要设置 `Games.Play` 范围，而 `queryPolicy`
    需要设置 `Games.Query` 范围。`queryPolicy` 还要求用户必须经过身份验证。您可以通过使用 `RequireClaim` 方法定义一个与令牌一起传递的声明。'
- en: 'With the policies in place, routes can be restricted to the required policies:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了策略之后，可以将路由限制为所需的策略：
- en: Codebreaker.ApiGateway/appsettings.json
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway/appsettings.json
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `AuthorizationPolicy` configuration, alongside `botRoute`, `botPolicy`
    is referenced to require authenticated users and the application to send the correct
    scope.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AuthorizationPolicy` 配置，与 `botRoute` 一起，引用 `botPolicy` 以要求认证用户和应用程序发送正确的范围。
- en: 'Now that we’ve configured the DI container, the middleware needs to be configured:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 DI 容器，需要配置中间件：
- en: Codebreaker.GameAPis/Program.cs
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPis/Program.cs
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `UseAuthentication` method adds authentication middleware, while the `UseAuthorization`
    method adds authorization middleware.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthentication` 方法添加了身份验证中间件，而 `UseAuthorization` 方法添加了授权中间件。'
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the minimal API needs to be restricted directly, the `RequireAuthorization`
    extension method can be used. A policy can be passed as an argument to check for
    the policy’s requirements. Upon injecting `ClaimsPrincipal` as an argument to
    a minimal API method, information about the user and claim information can be
    retrieved programmatically. This allows us to check for restrictions based on
    values that are retrieved with the API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最小 API 需要直接限制，可以使用 `RequireAuthorization` 扩展方法。可以将策略作为参数传递以检查策略的要求。将 `ClaimsPrincipal`
    注入为最小 API 方法的参数时，可以以编程方式检索有关用户和声明信息的详细信息。这允许我们根据通过 API 获取的值进行检查限制。
- en: To test this out, we’ll update our client application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们将更新我们的客户端应用程序。
- en: Authentication using Microsoft Identity with ASP.NET Core web applications
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Microsoft Identity 和 ASP.NET Core 网络应用程序进行身份验证
- en: To authenticate using Azure AD B2C, we’ll use the Microsoft Identity platform.
    In this section, we’ll focus on creating accounts with Azure AD B2C, logging in,
    and invoking secured REST APIs with ASP.NET Core web applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Azure AD B2C 进行身份验证，我们将使用 Microsoft Identity 平台。在本节中，我们将重点介绍使用 Azure AD
    B2C 创建账户、登录以及使用 ASP.NET Core 网络应用程序调用受保护的 REST API。
- en: 'Like with the minimal API we created earlier, a .NET template can be used.
    Invoke this command to create a new project:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的最小 API 一样，可以使用 .NET 模板。运行以下命令以创建新项目：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In creating this project, several NuGet packages are added for identities and
    authentication. These were discussed when we secured the API. An additional package
    that hasn’t been used before is `Microsoft.Identity.Web.UI`. This package integrates
    with `Microsoft.Identity.Web` and offers pre-built UI elements for login, logout,
    and profile management.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此项目时，添加了几个用于身份验证和身份的 NuGet 包。这些在我们保护 API 时已经讨论过。一个之前未使用过的附加包是 `Microsoft.Identity.Web.UI`。此包与
    `Microsoft.Identity.Web` 集成，并提供用于登录、注销和配置文件管理的预构建 UI 元素。
- en: 'With the DI container configuration, authentication is added. So, we need to
    customize it for calling APIs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 DI 容器配置，添加了身份验证。因此，我们需要对其进行自定义以调用 API：
- en: WebAppAuth/Program.cs
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: WebAppAuth/Program.cs
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To use Azure AAD B2C, `AddAuthentication` is invoked using the configuration
    from the `AzureAdB2C` section within `appsettings.json`. `AddMicrosoftIdentityWeb`
    is an extension method from the `Microsoft.Identity.Web` NuGet package. This configures
    supporting cookies and `OpenIdConnect`. The `EnableTokenAcquisitionToCallDownstreamApi`
    method allows us to pass tokens that have been received from the application so
    that we can forward them to the APIs that have been invoked by the application
    via `HttpClient`. When using this method, the `ITokenAcquisition` interface is
    registered in the DI container. This can be used to retrieve the tokens and pass
    them to the HTTP headers of `HttpClient`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Azure AAD B2C，需要使用 `appsettings.json` 文件中 `AzureAdB2C` 部分的配置来调用 `AddAuthentication`。`AddMicrosoftIdentityWeb`
    是来自 `Microsoft.Identity.Web` NuGet 包的扩展方法。这配置了支持 cookie 和 `OpenIdConnect`。`EnableTokenAcquisitionToCallDownstreamApi`
    方法允许我们传递从应用程序接收到的令牌，以便我们可以通过 `HttpClient` 将其转发到应用程序调用的 API。当使用此方法时，`ITokenAcquisition`
    接口在 DI 容器中注册。这可以用来检索令牌并将它们传递给 `HttpClient` 的 HTTP 头。
- en: 'For the Microsoft Identity user interface, the `AddMicrosoftIdentityUI` method
    needs to be configured with the DI container:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Microsoft Identity 用户界面，需要使用 DI 容器配置 `AddMicrosoftIdentityUI` 方法：
- en: WebAppAuth/Program.cs
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WebAppAuth/Program.cs
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method configures `AccountController` (based on ASP.NET Core MVC) with
    `SignIn` and `SignOut` methods in the `MicrosoftIdentity` area.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `MicrosoftIdentity` 区域配置 `AccountController`（基于 ASP.NET Core MVC），并提供了
    `SignIn` 和 `SignOut` 方法。
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When creating Blazor client applications, AD B2C support is built-in with .NET
    7 templates, but not with .NET 8\. Support has been planned for .NET 9\. You can
    add AD B2C integration manually.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Blazor 客户端应用程序时，.NET 7 模板内置了对 AD B2C 的支持，但 .NET 8 中则没有。对于 .NET 9 的支持已被计划。您可以手动添加
    AD B2C 集成。
- en: Some differences in authentication can be implemented with different client
    technologies. Check out the links in the *Further reading* section for more information.
    Also, check out the Codebreaker GitHub ([https://github.com/codebreakerapp](https://github.com/codebreakerapp))
    for implementations for Blazor, WinUI, .NET MAUI, WPF, and Uno Platform.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过不同的客户端技术实现身份验证的不同差异。查看“进一步阅读”部分中的链接以获取更多信息。还可以查看 Codebreaker GitHub ([https://github.com/codebreakerapp](https://github.com/codebreakerapp))
    以获取 Blazor、WinUI、.NET MAUI、WPF 和 Uno Platform 的实现。
- en: Specifying authentication with Azure Container Apps
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 容器应用指定身份验证
- en: Instead of needing to manage authentication with the service itself, we can
    do this directly with Azure Container Apps. After selecting the deployed games
    API, within the Azure portal, choose **Authentication** from the **Settings**
    category in the left pane. Here, you can add an **identity provider**. By selecting
    **Microsoft**, you can configure **Workforce** or **Customer** tenant types. **Workforce**
    is for B2B scenarios. Here, you can directly create an app registration within
    Microsoft Entra. For B2C, select **Customer**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用 Azure 容器应用来管理身份验证，而不是需要管理服务本身的身份验证。在 Azure 门户中选择已部署的游戏 API 后，在左侧面板的
    **设置**类别中选择 **身份验证**。在这里，您可以添加一个 **身份提供者**。通过选择 **Microsoft**，您可以配置 **Workforce**
    或 **Customer** 租户类型。**Workforce** 用于 B2B 场景。在这里，您可以直接在 Microsoft Entra 中创建应用程序注册。对于
    B2C，选择 **Customer**。
- en: Using ASP.NET Core Identity to store user information in a local database
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core Identity 在本地数据库中存储用户信息
- en: If Azure AD B2C is not an option for you, you can use **ASP.NET Core Identity**,
    which .NET offers for storing users in a local database. We’ll use this as an
    alternative way to run the solution without the need to configure Azure AD B2C.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Azure AD B2C 对您来说不是一种选择，您可以使用 .NET 提供的 **ASP.NET Core Identity** 来在本地数据库中存储用户。我们将使用这种方式作为运行解决方案的替代方法，无需配置
    Azure AD B2C。
- en: 'With `-au` `Individual` option:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-au` `Individual` 选项：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This creates two projects: `Codebreaker.ApiGateway.Identities` and `Codebreaker.ApiGateway.Identities.Client`.
    The second project is a library that contains **Razor components** that can be
    run on the client with **interactive WebAssembly rendering**, as well as **interactive
    server rendering**. This library was referenced in the first project, which hosts
    the Blazor application and contains Razor components that support interactive
    server rendering. This project contains a huge list of Razor components for registering
    users to help users with forgotten passwords, as well as components for managing
    user information.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个项目：`Codebreaker.ApiGateway.Identities` 和 `Codebreaker.ApiGateway.Identities.Client`。第二个项目是一个库，其中包含可以在客户端运行并具有
    **交互式 WebAssembly 渲染**以及 **交互式服务器渲染**的 **Razor 组件**。这个库在第一个项目中引用，该项目托管 Blazor
    应用程序并包含支持交互式服务器渲染的 Razor 组件。该项目包含一个用于注册用户以及帮助用户找回密码的组件列表，以及用于管理用户信息的组件。
- en: Let’s cover some important parts of this application, beginning with the database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨这个应用程序的一些重要部分，从数据库开始。
- en: Customizing the EF Core configuration
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 EF Core 配置
- en: With this project, user information is stored in a relational database via EF
    Core. By default, MySQL is used. This can easily be changed to SQL Server, but
    using MySQL for this scenario is great as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，用户信息通过 EF Core 存储在关系型数据库中。默认情况下，使用 MySQL。这可以轻松地更改为 SQL Server，但在这个场景中使用
    MySQL 也是很好的。
- en: 'What information about users is stored is defined with the `ApplicationDbContext`
    class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的用户信息由 `ApplicationDbContext` 类定义：
- en: Codebreaker.ApiGateway.Identities/Data/ApplicationDbContext.cs
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway.Identities/Data/ApplicationDbContext.cs
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ApplicationDbContext` is an EF Core context with a hierarchy of base classes.
    The body of this class is empty as it was created from the template. Adding custom
    `DbSet` properties allows you to add additional tables to the database. The base
    class, `IdentityDbContext`, uses the `ApplicationUser` class as a generic parameter
    to define what information to store about the user:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationDbContext` 是一个具有基类层次结构的 EF Core 上下文。由于是从模板创建的，因此这个类的主体为空。添加自定义
    `DbSet` 属性允许您向数据库添加额外的表。基类 `IdentityDbContext` 使用 `ApplicationUser` 类作为泛型参数来定义要存储的用户信息：'
- en: Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Adding properties to this class allows you to customize the `users` table with
    additional columns. To see the defined properties, you need to follow the base
    classes, starting with `IdentityUser`. `IdentityUser` derives from `IdentityUser<string>`.
    The generic string parameter specifies the use of GUID values for the key. The
    generic `IdentiyUser` type defines the `UserName`, `Email`, `PasswordHash`, and
    `PhoneNumber` properties, among others, to map to columns.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 向此类添加属性允许您使用额外的列自定义`users`表。要查看定义的属性，需要从`IdentityUser`基类开始跟踪，`IdentityUser`继承自`IdentityUser<string>`。泛型字符串参数指定了使用GUID值作为键。泛型`IdentiyUser`类型定义了`UserName`、`Email`、`PasswordHash`和`PhoneNumber`等属性，以映射到列。
- en: '`IdentityDbContext<TUser>` has some more base classes, such as `IdentityUserContext<TUser`,
    `TRole`, `TKey`, `TUserClaim`, `TuserLogin`, and `TUserToken>`, to define several
    tables that are used.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityDbContext<TUser>`有一些其他基类，例如`IdentityUserContext<TUser`, `TRole`, `TKey`,
    `TUserClaim`, `TuserLogin`, 和 `TUserToken>`，用于定义使用的一些表。'
- en: 'The EF Core context needs to be configured with the DI container:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core上下文需要与DI容器进行配置：
- en: Codebreaker.ApiGateway.Identities/Program.cs
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway.Identities/Program.cs
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the EF Core configuration has been changed to use the `Aspire.Pomelo.EntityFrameworkCore.MySql`
    NuGet package with the MySQL Entity Framework .NET Aspire component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，EF Core配置已更改，以使用`Aspire.Pomelo.EntityFrameworkCore.MySql` NuGet包和MySQL Entity
    Framework .NET Aspire组件。
- en: With that, the EF Core context has been configured with ASP.NET Core Identity.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，EF Core上下文已经与ASP.NET Core身份验证进行了配置。
- en: Configuring ASP.NET Core Identity
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置ASP.NET Core身份验证
- en: 'When configuring ASP.NET Core Identity, EF Core must be mapped:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置ASP.NET Core身份验证时，EF Core必须进行映射：
- en: Codebreaker.ApiGateway.Identities/Program.cs
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway.Identities/Program.cs
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `AddIdentityCore` method configures the `ApplicationUser` class (the same
    class that was used with the EF Core model) for ASP.NET Core Identity. When the
    user registers, before using the account, it needs to be confirmed by setting
    the `RequireConfirmedAccount` property (discussed next). With the invocation of
    `AddEntityFrameworkStores`, the EF Core context, `ApplicationDbContext`, is mapped
    to ASP.NET Core Identity. The `AddSignInManager` method registers the `SignInManager`
    class with the DI container. `SignInManager` can be used to log the user in and
    out, retrieve claims, and work with two-factor authentication options. The `AddDefaultTokenProviders`
    method registers token providers by implementing the `IUserTwoFactorTokenProvider`
    interface to return and validate tokens for two-factor authentication, such as
    email, phone, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddIdentityCore`方法配置了`ApplicationUser`类（与EF Core模型一起使用的相同类）以用于ASP.NET Core身份验证。当用户注册时，在使用账户之前，需要通过设置`RequireConfirmedAccount`属性（将在下文中讨论）进行确认。通过调用`AddEntityFrameworkStores`，EF
    Core上下文`ApplicationDbContext`被映射到ASP.NET Core身份验证。`AddSignInManager`方法将`SignInManager`类注册到DI容器中。`SignInManager`可用于登录和注销用户，检索声明，并处理双因素认证选项。`AddDefaultTokenProviders`方法通过实现`IUserTwoFactorTokenProvider`接口来注册令牌提供者，以返回和验证用于双因素认证的令牌，例如电子邮件、电话等。'
- en: 'To confirm an account, the `IEmailSender` interface needs to be registered
    with the DI container:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认账户，需要将`IEmailSender`接口注册到DI容器中：
- en: Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the default configuration, a no-op `IdentityNoOpEmailSender` class is implemented.
    This is practical for testing purposes but needs to be changed to verify a user’s
    email address.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置下，实现了无操作的`IdentityNoOpEmailSender`类。这对于测试目的来说是实用的，但需要更改以验证用户的电子邮件地址。
- en: 'Now, let’s configure the project with the .NET Aspire AppHost project:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用.NET Aspire AppHost项目来配置项目：
- en: CodebreakerAppHost/Program.cs
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: CodebreakerAppHost/Program.cs
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the AppHost project uses multiple launch profiles to either start the
    solution with Azure AD B2C (the `Azure` launch profile), or with the local database
    (the `OnPremises` launch profile). When it comes to the different launch profile
    settings, the `STARTUP_MODE` environment variable is configured, which is then
    used to differentiate the projects to be started and how they are configured.
    When launching `OnPremises` mode, the newly created project is configured to reference
    the MySQL database running in a container via the `Aspire.Hosting.MySql` NuGet
    package. The `WithDataVolume` method creates a named Docker volume (see [*Chapter
    5*](B21217_05.xhtml#_idTextAnchor110)) to have persistence, while the `WithPhpMyAdmin`
    method adds an admin UI.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，AppHost 项目使用多个启动配置文件，要么以 Azure AD B2C（`Azure` 启动配置文件）启动解决方案，要么以本地数据库（`OnPremises`
    启动配置文件）启动。当涉及到不同的启动配置文件设置时，会配置 `STARTUP_MODE` 环境变量，然后用于区分要启动的项目以及它们的配置。在启动 `OnPremises`
    模式时，新创建的项目配置为通过 `Aspire.Hosting.MySql` NuGet 包引用在容器中运行的 MySQL 数据库。`WithDataVolume`
    方法创建一个命名的 Docker 卷（见 [*第 5 章*](B21217_05.xhtml#_idTextAnchor110)）以实现持久性，而 `WithPhpMyAdmin`
    方法添加了管理界面。
- en: 'If we run the solution now, we can register a new user, as shown in *Figure
    9**.11*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行解决方案，我们可以注册一个新用户，如图 *图 9**.11* 所示：
- en: '![Figure 9.11 – Registering a local user](img/B21217_09_11.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 注册本地用户](img/B21217_09_11.jpg)'
- en: Figure 9.11 – Registering a local user
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 注册本地用户
- en: When registering the user, you might need to apply EF Core migrations to create
    the database. On receiving the registration confirmation, choose **Click here
    to confirm your account** to approve the email. Then, click the **Login** button
    on the left pane. After logging in, the email will be shown on the **Auth** **Required**
    page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册用户时，你可能需要应用 EF Core 迁移来创建数据库。在收到注册确认后，选择**点击此处确认您的账户**以批准电子邮件。然后，点击左侧面板上的**登录**按钮。登录后，电子邮件将显示在**认证**
    **必需**页面上。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of having the user remember another password, with ASP.NET Core Identity,
    it’s also possible to add external providers, such as Microsoft, Facebook, and
    Google accounts, as shown at [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core Identity，除了让用户记住另一个密码外，还可以添加外部提供者，例如 Microsoft、Facebook 和 Google
    账户，如[https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social)所示。
- en: 'With phpMyAdmin enabled, you can open the management UI and see the tables
    that have been created, as shown in *Figure 9**.12*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 phpMyAdmin 后，您可以打开管理界面并查看已创建的表，如图 *图 9**.12* 所示：
- en: '![Figure 9.12 – MySQL admin UI](img/B21217_09_12.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – MySQL 管理界面](img/B21217_09_12.jpg)'
- en: Figure 9.12 – MySQL admin UI
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – MySQL 管理界面
- en: Using this admin UI, you can perform SQL queries and easily change and delete
    records.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此管理界面，您可以执行 SQL 查询，并轻松更改和删除记录。
- en: With ASP.NET Core Identity in place, users can now register with this application
    and manage their accounts. This option is great if user data isn’t stored within
    a managed cloud service and can be implemented easily. What about using desktop
    client applications? They can use an API to access this data. We’ll learn how
    to add this API in the next section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core Identity 就绪的情况下，用户现在可以使用此应用程序注册并管理他们的账户。如果用户数据不存储在托管云服务中并且可以轻松实现，这是一个很好的选择。那么使用桌面客户端应用程序呢？它们可以使用
    API 来访问这些数据。我们将在下一节中学习如何添加此 API。
- en: Creating identity API endpoints
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建身份 API 端点
- en: .NET 8 offers identity API endpoints that use the ASP.NET Core Identity infrastructure.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 提供了使用 ASP.NET Core Identity 基础设施的标识 API 端点。
- en: 'With the EF Core configuration for ASP.NET Core Identity in place, all we need
    to do is configure the identity endpoints with the DI container and the middleware.
    The DI container must be configured first:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core Identity 的 EF Core 配置就绪后，我们所需做的就是使用 DI 容器和中间件配置身份端点。首先必须配置 DI
    容器：
- en: Codebreaker.Gateway.Identity/Program.cs
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Gateway.Identity/Program.cs
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `AddIdentityApiEndpoints` method adds authentication with a Bearer token
    and identity cookies, as well as options and validators to validate allowed passwords
    and usernames, register `UserManager`, and provide a factory for user claims.
    `IEmailSender`, which is used to validate correct emails, is configured to use
    `NoOpEmailSender`. When you have a real implementation of `IEmailSender` in place
    (using your email provider), you need to make sure you register this class after
    the invocation of `AddIdentityApiEndpoints` to overwrite `NoOpEmailSender` with
    your configuration. The `AddEntityFrameworkStores` method is an extension method
    for the returned `IdentityBuilder` object and adds the EF Core store for user
    and role data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddIdentityApiEndpoints`方法添加了使用Bearer令牌和身份cookie的认证，以及验证允许的密码和用户名的选项和验证器，注册`UserManager`，并提供用户声明的工厂。用于验证正确电子邮件的`IEmailSender`被配置为使用`NoOpEmailSender`。当您有`IEmailSender`的真实实现（使用您的电子邮件提供程序）时，您需要确保在调用`AddIdentityApiEndpoints`之后注册此类，以用您的配置覆盖`NoOpEmailSender`。`AddEntityFrameworkStores`方法是对返回的`IdentityBuilder`对象的扩展方法，并为用户和角色数据添加了EF
    Core存储。'
- en: 'The middleware can be configured using the `MapIdentityApi` method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`MapIdentityApi`方法配置中间件：
- en: Codebreaker.Gateway.Identity/Program.cs
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Gateway.Identity/Program.cs
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `MapGroup` method is used to add a common prefix for the identity API. `MapIdentityApi`
    itself defines several URIs, such as `/register` to register a new user by using
    `RegisterRequest` with the body of a POST request, and `/login` to log a user
    in while passing `LoginRequest`, which can include username, password, and two-factor
    codes, links to reset a forgotten password, confirmation of the email, and more.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapGroup`方法用于为身份API添加一个公共前缀。`MapIdentityApi`本身定义了几个URI，例如`/register`，通过POST请求正文使用`RegisterRequest`注册新用户，以及`/login`，在传递`LoginRequest`时登录用户，`LoginRequest`可以包括用户名、密码、双因素代码、重置忘记密码的链接、电子邮件确认等。'
- en: Some of these APIs allow anonymous access (for example, when registering or
    logging in), while with others, authentication is required. The API group with
    the `/manage` link is configured to require authentication.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些API允许匿名访问（例如，在注册或登录时），而其他API则需要认证。带有`/manage`链接的API组被配置为需要认证。
- en: 'When Swagger is enabled, you’ll see all these APIs, as shown in *Figure 9**.13*.
    This means you can test them before using them from a client application:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用Swagger时，您将看到所有这些API，如图*图9.13*所示。这意味着您可以在从客户端应用程序使用之前测试它们：
- en: '![Figure 9.13 – Identity API endpoints](img/B21217_09_13.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 身份API端点](img/B21217_09_13.jpg)'
- en: Figure 9.13 – Identity API endpoints
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 身份API端点
- en: Try invoking the `/register` API and create a new user passing two values. With
    a success, HTTP status code `200` is returned with an empty HTTP body if you didn’t
    create a custom implementation of the `IEmailSender` interface. If this is the
    case, you can use the MySQL admin UI to approve the user (or change the ASP.NET
    Core Identity configuration so that it doesn’t require confirmed accounts) before
    logging in; otherwise, login will be denied.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调用`/register` API并传递两个值来创建新用户。如果没有创建自定义的`IEmailSender`接口实现，成功时将返回HTTP状态码`200`，并且HTTP正文为空。如果情况如此，您可以在登录之前使用MySQL管理UI批准用户（或更改ASP.NET
    Core Identity配置，使其不需要已确认的账户）；否则，登录将被拒绝。
- en: With a successful login, Bearer tokens are returned. You receive access and
    refresh tokens and expiration information that is set to 3,600 seconds by default.
    The refresh token can be used with the `/refresh` API to get new access and refresh
    tokens.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，会返回Bearer令牌。您将收到访问令牌和刷新令牌以及默认设置为3,600秒的过期信息。刷新令牌可以与`/refresh` API一起使用，以获取新的访问令牌和刷新令牌。
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn how to use SendGrid to implement `IemailSender`, take a look at the
    following article: [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用SendGrid实现`IEmailSender`，请参阅以下文章：[https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm)。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to authenticate users with Azure AD B2C using
    Microsoft Identities and ASP.NET Core Identity. With Azure AD B2C, you added custom
    user attributes, specified user flows, and registered applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用Microsoft Identities和ASP.NET Core Identity通过Azure AD B2C进行用户认证。使用Azure
    AD B2C，您添加了自定义用户属性，指定了用户流程，并注册了应用程序。
- en: Instead of implementing protection with every API, you created a reverse proxy
    using Microsoft YARP and protected the APIs with a gateway service. Using YARP,
    we defined routes to map different backend services and configured policies with
    routes to require authenticated clients.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每个 API 实现保护，您使用 Microsoft YARP 创建了一个反向代理，并通过网关服务保护了 API。使用 YARP，我们定义了路由以映射不同的后端服务，并使用路由配置了策略，要求认证客户端。
- en: You also learned to use ASP.NET Core Identity as an alternative option for authentication
    and authorization with built-in ASP.NET Core functionality but a simpler feature
    set.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了如何使用 ASP.NET Core Identity 作为内置 ASP.NET Core 功能的替代选项进行身份验证和授权，但功能更简单。
- en: The next chapter covers how to test microservices solutions, from unit tests
    to integration tests, including testing services with Microsoft Playwright.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何测试微服务解决方案，从单元测试到集成测试，包括使用 Microsoft Playwright 测试服务。
- en: Further reading
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，请参阅以下链接：
- en: '*Azure AD B2C Claims* *Schema*: [https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema](https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure AD B2C 声明* *模式*: [https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema](https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema)'
- en: '*Enrich tokens with claims from external sources using API* *connectors*: [https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment](https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 API 连接器从外部来源丰富令牌中的声明* [https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment](https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment)'
- en: '*ASP.NET Core* *Middleware*: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ASP.NET Core* *中间件*: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware)'
- en: '*How to use Identity to secure a Web API backend for* *SPAs*: [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何使用身份验证来保护 SPAs 的 Web API 后端* [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization)'
- en: '*GitHub repository for* *YARP*: [https://github.com/microsoft/reverse-proxy](https://github.com/microsoft/reverse-proxy)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*YARP 的 GitHub 仓库* [https://github.com/microsoft/reverse-proxy](https://github.com/microsoft/reverse-proxy)'
- en: '*Securing a Blazor WASM app with Azure AD* *B2C*: [https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Azure AD B2C 保护 Blazor WASM 应用* [https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c)'
- en: '*Securing a WPF desktop app with Aure AD* *B2C*: [https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app](https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Azure AD B2C 保护 WPF 桌面应用* [https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app](https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app)'
- en: '*Choosing an identity management* *solution*: [https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution](https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择一个身份管理* *解决方案*: [https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution](https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution)'
- en: '*Azure API* *Management*: [https://learn.microsoft.com/en-us/azure/api-management/](https://learn.microsoft.com/en-us/azure/api-management/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure API* *管理*: [https://learn.microsoft.com/en-us/azure/api-management/](https://learn.microsoft.com/en-us/azure/api-management/)'
- en: 'Part 3: Troubleshooting and Scaling'
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：故障排除和扩展
- en: In this part, the focus shifts towards ensuring the smooth operation of the
    application and promptly addressing any emerging issues. Emphasis is placed on
    early issue detection through unit testing. You will delve into creating integration
    tests using .NET Aspire libraries and implementing end-to-end testing with Microsoft
    Playwright. The importance of logs, metrics, and distributed tracing, facilitated
    by Open Telemetry and supported by .NET Aspire, will be explored. Monitoring service
    interactions, performance metrics, memory consumption, and more during development
    will be facilitated by the .NET Aspire dashboard. Within the Azure environment,
    Azure Log Analytics and Application Insights will be utilized, alongside alternative
    options like **Prometheus** and **Grafana** that can be deployed in both on-premises
    and cloud environments. When scaling services, insights gained from previous chapters
    will be leveraged, with caution advised when using Azure Load Testing to prevent
    exceeding budget limits. Before scaling up and out, potential performance enhancements
    will be identified and implemented.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，重点转向确保应用程序的平稳运行和及时解决任何新出现的问题。强调通过单元测试进行早期问题检测。您将深入了解使用 .NET Aspire 库创建集成测试，以及使用
    Microsoft Playwright 实现端到端测试。Open Telemetry 促进的日志、指标和分布式跟踪的重要性将被探讨。.NET Aspire
    仪表板将有助于在开发过程中监控服务交互、性能指标、内存消耗等。在 Azure 环境中，将利用 Azure Log Analytics 和 Application
    Insights，同时还可以使用 **Prometheus** 和 **Grafana** 等替代选项，这些选项可以在本地和云环境中部署。在扩展服务时，将利用前几章中获得的经验，并建议在使用
    Azure Load Testing 时谨慎行事，以防止超出预算限制。在扩展之前，将识别并实施潜在的性能提升。
- en: 'This part has the following chapters:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B21217_10.xhtml#_idTextAnchor239), *All about Testing the Solution*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21217_10.xhtml#_idTextAnchor239)，*关于解决方案测试的所有内容*'
- en: '[*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), *Logging and Monitoring*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21217_11.xhtml#_idTextAnchor263)，*日志和监控*'
- en: '[*Chapter 12*](B21217_12.xhtml#_idTextAnchor294)*, Scaling Services*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21217_12.xhtml#_idTextAnchor294)，*扩展服务*'
