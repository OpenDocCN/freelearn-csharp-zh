<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Using the Task Parallel Library"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using the Task Parallel Library</h1></div></div></div><p>In this chapter, we will dive into a new asynchronous programming paradigm, the Task Parallel Library. You will learn the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a task</li><li class="listitem" style="list-style-type: disc">Performing basic operations with a task</li><li class="listitem" style="list-style-type: disc">Combining tasks together</li><li class="listitem" style="list-style-type: disc">Converting the APM pattern to tasks</li><li class="listitem" style="list-style-type: disc">Converting the EAP pattern to tasks</li><li class="listitem" style="list-style-type: disc">Implementing a cancelation option</li><li class="listitem" style="list-style-type: disc">Handling exceptions in tasks</li><li class="listitem" style="list-style-type: disc">Running tasks in parallel</li><li class="listitem" style="list-style-type: disc">Tweaking the execution of tasks with <code class="literal">TaskScheduler</code></li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Introduction</h1></div></div></div><p>In the previous chapters, you learned what a thread is, how to use threads, and why we need a thread pool. Using a thread pool allows us to save operating system resources at the cost of reducing a parallelism degree. We <a id="id157" class="indexterm"/>can think of a thread pool as an <span class="strong"><strong>abstraction layer</strong></span> that hides details of thread usage from a programmer, allowing us to concentrate on a program's logic rather than on threading issues.</p><p>However, using a thread pool is complicated as well. There is no easy way to get a result from a thread pool worker thread. We need to implement our own way to get a result back, and in case of an exception, we have to propagate it to the original thread properly. Besides this, there is no easy way to create a set of dependent asynchronous actions, where one action runs after another finishes its work.</p><p>There were several attempts to work around these issues, which resulted in the creation of the Asynchronous Programming Model and the Event-based Asynchronous Pattern, mentioned in <a class="link" href="ch03.html" title="Chapter 3. Using a Thread Pool">Chapter 3</a>, <span class="emphasis"><em>Using a Thread Pool</em></span>. These patterns made getting results easier and did a good job of propagating exceptions, but combining asynchronous actions together still required a lot of work and resulted in a large amount of code.</p><p>To resolve all these problems, a new API for asynchronous operations was introduced in .Net Framework 4.0. It was called the Task Parallel Library (TPL). It was changed slightly in .Net Framework 4.5 and to make it clear, we will work with the latest version of TPL using the 4.6 version of .Net Framework in our projects. TPL can be considered as one more abstraction layer over a thread pool, hiding the lower-level code that will work with the thread pool from a programmer and supplying a more convenient and fine-grained API.</p><p>The core concept of TPL is a task. A<a id="id158" class="indexterm"/> task represents an asynchronous operation that can be run in a variety of ways, using a separate thread or not. We will look through all the possibilities in detail in this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>By default, a programmer is not aware of how exactly a task is being executed. TPL raises the level of abstraction by hiding the task implementation details from the user. Unfortunately, in some cases, this could lead to mysterious errors, such as the application hanging while trying to get a result from the task. This chapter will help you understand the mechanics under the hood of TPL and how to avoid using it in improper ways.</p></div></div><p>A task can be combined with other tasks in different variations. For example, we are able to start several tasks simultaneously, wait for all of them to complete, and then run a task that will perform some calculations over all the previous tasks' results. Convenient APIs for task combination are one of the key advantages of TPL compared to the previous patterns.</p><p>There are also several ways to deal with exceptions resulting from tasks. Since a task may consist of several other tasks, and they in turn have their child tasks as well, there is the concept of <code class="literal">AggregateException</code>. This type of exception holds all exceptions from underlying tasks inside it, allowing us to handle them separately.</p><p>And, last but not least, C# has built-in support for TPL since version 5.0, allowing us to work with tasks in a very smooth and comfortable way using the new <code class="literal">await</code> and <code class="literal">async</code> keywords. We will discuss this topic in <a class="link" href="ch05.html" title="Chapter 5. Using C# 6.0">Chapter 5</a>, <span class="emphasis"><em>Using C# 6.0</em></span>.</p><p>In this chapter, you will learn to use TPL to execute asynchronous operations. We will learn what a task is, cover different ways to create tasks, and will learn how to combine tasks. We will also discuss how to convert legacy APM and EAP patterns to use tasks, how to handle exceptions properly, how to cancel tasks, and how to work with several tasks that are being executed simultaneously. In addition, we will find out how to deal with tasks in Windows GUI applications properly.</p></div></div>
<div class="section" title="Creating a task"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Creating a task</h1></div></div></div><p>This<a id="id159" class="indexterm"/> recipe shows the basic concept of what a task is. You will learn how to create and execute tasks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec91"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe1</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec92"/>How to do it...</h2></div></div></div><p>To create and execute a task, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>This time, make sure that you are using .Net Framework 4.5 or higher for every project.</p></div></div></li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static void TaskMethod(string name)
{
  WriteLine($"Task {name} is running on a thread id " +
      $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
      $"{CurrentThread.IsThreadPoolThread}");
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var t1 = new Task(() =&gt; TaskMethod("Task 1"));
var t2 = new Task(() =&gt; TaskMethod("Task 2"));
t2.Start();
t1.Start();
Task.Run(() =&gt; TaskMethod("Task 3"));
Task.Factory.StartNew(() =&gt; TaskMethod("Task 4"));
Task.Factory.StartNew(() =&gt; TaskMethod("Task 5"), TaskCreationOptions.LongRunning);
Sleep(TimeSpan.FromSeconds(1));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec93"/>How it works...</h2></div></div></div><p>When the<a id="id160" class="indexterm"/> program runs, it creates two tasks with its constructor. We pass the lambda expression as the <code class="literal">Action</code> delegate; this allows us to provide a string parameter to <code class="literal">TaskMethod</code>. Then, we run these tasks using the <code class="literal">Start</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Note that until we call the <code class="literal">Start</code> method on these tasks, they will not start execution. It is very easy to forget to actually start the task.</p></div></div><p>Then, we run two more tasks using the <code class="literal">Task.Run</code> and <code class="literal">Task.Factory.StartNew</code> methods. The difference is that both the created tasks immediately start working, so we do not need to call the <code class="literal">Start</code> method on the tasks explicitly. All of the tasks, numbered <code class="literal">Task 1</code> to <code class="literal">Task 4</code>, are placed on thread pool worker threads and run in an unspecified order. If you run the program several times, you will find that the task execution order is not defined.</p><p>The <code class="literal">Task.Run</code> method is just a shortcut to <code class="literal">Task.Factory.StartNew</code>, but the latter method has additional options. In general, use the former method unless you need to do something special, as in the case of <code class="literal">Task 5</code>. We mark this task as long-running, and as a result, this task will be run on a separate thread that does not use a thread pool. However, this behavior could change, depending on the current <a id="id161" class="indexterm"/>
<span class="strong"><strong>task scheduler</strong></span> that runs the task. You will learn what a task scheduler is in the last recipe of this chapter.</p></div></div>
<div class="section" title="Performing basic operations with a task"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Performing basic operations with a task</h1></div></div></div><p>This recipe<a id="id162" class="indexterm"/> will describe how to get the result value from<a id="id163" class="indexterm"/> a task. We will go through several scenarios to understand the difference between running a task on a thread pool or on a main thread.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec94"/>Getting ready</h2></div></div></div><p>To start this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe2</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec95"/>How to do it...</h2></div></div></div><p>To perform <a id="id164" class="indexterm"/>basic operations with a task, perform the<a id="id165" class="indexterm"/> following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static Task&lt;int&gt; CreateTask(string name)
{
  return new Task&lt;int&gt;(() =&gt; TaskMethod(name));
}

static int TaskMethod(string name)
{
  WriteLine($"Task {name} is running on a thread id " +
     $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
     $"{CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  return 42;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">TaskMethod("Main Thread Task");
Task&lt;int&gt; task = CreateTask("Task 1");
task.Start();
int result = task.Result;
WriteLine($"Result is: {result}");

task = CreateTask("Task 2");
task.RunSynchronously();
result = task.Result;
WriteLine($"Result is: {result}");

task = CreateTask("Task 3");
WriteLine(task.Status);
task.Start();

while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5)); } 
      
WriteLine(task.Status);
result = task.Result;
WriteLine($"Result is: {result}");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec96"/>How it works...</h2></div></div></div><p>At first, we <a id="id166" class="indexterm"/>run <code class="literal">TaskMethod</code> without wrapping it into a task. As a result, it is executed synchronously, providing us with information about the main thread. Obviously, it is not a thread pool thread.</p><p>Then, we<a id="id167" class="indexterm"/> run <code class="literal">Task 1</code>, starting it with the <code class="literal">Start</code> method and waiting for the result. This task will be placed on a thread pool, and the main thread waits and is blocked until the task returns.</p><p>We do the same with <code class="literal">Task 2</code>, except that we run it using the <code class="literal">RunSynchronously()</code> method. This task will run on the main thread, and we get exactly the same output as in the very first case when we called <code class="literal">TaskMethod</code> synchronously. This is a very useful optimization that allows us to avoid thread pool usage for very short-lived operations.</p><p>We run <code class="literal">Task 3</code> in the same way we did <code class="literal">Task 1</code>, but instead of blocking the main thread, we just spin, printing out the task status until the task is completed. This shows several task statuses, which are <code class="literal">Created</code>, <code class="literal">Running</code>, and <code class="literal">RanToCompletion</code>, respectively.</p></div></div>
<div class="section" title="Combining tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Combining tasks</h1></div></div></div><p>This recipe <a id="id168" class="indexterm"/>will show you how to set up tasks that are dependent on each other. We will learn how to create a task that will run after the parent task is complete. In addition, we will discover a way to save thread usage for very short-lived tasks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec97"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe3</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec98"/>How to do it...</h2></div></div></div><p>To combine tasks, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the <a id="id169" class="indexterm"/>following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(seconds));
  return 42 * seconds;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var firstTask = new Task&lt;int&gt;(() =&gt; TaskMethod("First Task", 3));
var secondTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Second Task", 2));

firstTask.ContinueWith(
  t =&gt; WriteLine(
    $"The first answer is {t.Result}. Thread id " +
    $"{CurrentThread.ManagedThreadId}, is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}"),
  TaskContinuationOptions.OnlyOnRanToCompletion);

firstTask.Start();
secondTask.Start();

Sleep(TimeSpan.FromSeconds(4));

Task continuation = secondTask.ContinueWith(
  t =&gt; WriteLine(
    $"The second answer is {t.Result}. Thread id " +
    $"{CurrentThread.ManagedThreadId}, is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}"),
  TaskContinuationOptions.OnlyOnRanToCompletion 
    | TaskContinuationOptions.ExecuteSynchronously);

continuation.GetAwaiter().OnCompleted(
  () =&gt; WriteLine(
    $"Continuation Task Completed! Thread id " +
    $"{CurrentThread.ManagedThreadId}, is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}"));

Sleep(TimeSpan.FromSeconds(2));
WriteLine();

firstTask = new Task&lt;int&gt;(() =&gt;
{
  var innerTask = Task.Factory.StartNew(() =&gt; TaskMethod("Second Task", 5),TaskCreationOptions.AttachedToParent);

  innerTask.ContinueWith(t =&gt; TaskMethod("Third Task", 2),
        TaskContinuationOptions.AttachedToParent);

  return TaskMethod("First Task", 2);
});

firstTask.Start();

while (!firstTask.IsCompleted)
{
  WriteLine(firstTask.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(firstTask.Status);

Sleep(TimeSpan.FromSeconds(10));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec99"/>How it works...</h2></div></div></div><p>When the <a id="id170" class="indexterm"/>main program starts, we create two tasks, and for the first task, we set up a <a id="id171" class="indexterm"/>
<span class="strong"><strong>continuation</strong></span> (a block of code that runs after the antecedent task is complete). Then, we start both tasks and wait for 4 seconds, which is enough for both tasks to be complete. Then, we run another continuation to the second task and try to execute it synchronously by specifying a <code class="literal">TaskContinuationOptions.ExecuteSynchronously</code> option. This is a useful technique when the continuation is very short lived, and it will be faster to run it on the main thread than to put it on a thread pool. We are able to achieve this because the second task is completed by that moment. If we comment out the 4-second <code class="literal">Thread.Sleep</code> method, we will see that this code will be put on a thread pool because we do not have the result from the antecedent task yet.</p><p>Finally, we<a id="id172" class="indexterm"/> define a continuation for the previous continuation, but in a slightly different manner, using the new <code class="literal">GetAwaiter</code> and <code class="literal">OnCompleted</code> methods. These methods are intended to be used along with C# language asynchronous mechanics. We will cover this topic later in <a class="link" href="ch05.html" title="Chapter 5. Using C# 6.0">Chapter 5</a>, <span class="emphasis"><em>Using C# 6.0</em></span>.</p><p>The last part of the demo is about the parent-child task relationships. We create a new task, and while running this task, we run a so-called child task by providing a <code class="literal">TaskCreationOptions.AttachedToParent</code> option.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>The child task must be created while running a parent task so that it is attached to the parent properly!</p></div></div><p>This means that the parent task will not be complete until all child tasks finish their work. We are also able to run continuations on those child tasks that provide a <code class="literal">TaskContinuationOptions.AttachedToParent</code> option. These continuation tasks will affect the parent task as well, and it will not be complete until the very last child task ends.</p></div></div>
<div class="section" title="Converting the APM pattern to tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Converting the APM pattern to tasks</h1></div></div></div><p>In this recipe, we <a id="id173" class="indexterm"/>will see how to convert an old-fashioned APM API to a task. There are examples of different situations that could take place <a id="id174" class="indexterm"/>in the process of conversion.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec100"/>Getting ready</h2></div></div></div><p>To start this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe4</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec101"/>How to do it...</h2></div></div></div><p>To convert the APM pattern to tasks, carry out the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the <a id="id175" class="indexterm"/>following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">delegate string AsynchronousTask(string threadName);
delegate string IncompatibleAsynchronousTask(out int threadId);

static void Callback(IAsyncResult ar)
{
  WriteLine("Starting a callback...");
  WriteLine($"State passed to a callbak: {ar.AsyncState}");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  WriteLine($"Thread pool worker thread id: {CurrentThread.ManagedThreadId}");
}

static string Test(string threadName)
{
  WriteLine("Starting...");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  CurrentThread.Name = threadName;
  return $"Thread name: {CurrentThread.Name}";
}

static string Test(out int threadId)
{
  WriteLine("Starting...");
  WriteLine($"Is thread pool thread: {CurrentThread.IsThreadPoolThread}");
  Sleep(TimeSpan.FromSeconds(2));
  threadId = CurrentThread.ManagedThreadId;
  return $"Thread pool worker thread id was: {threadId}";
}</pre></div></li><li class="listitem">Add the <a id="id176" class="indexterm"/>following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">int threadId;
AsynchronousTask d = Test;
IncompatibleAsynchronousTask e = Test;

WriteLine("Option 1");
Task&lt;string&gt; task = Task&lt;string&gt;.Factory.FromAsync(
  d.BeginInvoke("AsyncTaskThread", Callback, 
    "a delegate asynchronous call"), d.EndInvoke);

task.ContinueWith(t =&gt; WriteLine(
    $"Callback is finished, now running a continuation! Result: {t.Result}"));

while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(task.Status);
Sleep(TimeSpan.FromSeconds(1));

WriteLine("----------------------------------------------");
WriteLine();
WriteLine("Option 2");

task = Task&lt;string&gt;.Factory.FromAsync(
  d.BeginInvoke, d.EndInvoke, "AsyncTaskThread", "a delegate asynchronous call");

task.ContinueWith(t =&gt; WriteLine(
    $"Task is completed, now running a continuation! Result: {t.Result}"));
while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(task.Status);
Sleep(TimeSpan.FromSeconds(1));

WriteLine("----------------------------------------------");
WriteLine();
WriteLine("Option 3");

IAsyncResult ar = e.BeginInvoke(out threadId, Callback, "a delegate asynchronous call");
task = Task&lt;string&gt;.Factory.FromAsync(ar, _ =&gt; e.EndInvoke(out threadId, ar));

task.ContinueWith(t =&gt; 
  WriteLine(
        $"Task is completed, now running a continuation! " +
        $"Result: {t.Result}, ThreadId: {threadId}"));

while (!task.IsCompleted)
{
  WriteLine(task.Status);
  Sleep(TimeSpan.FromSeconds(0.5));
}
WriteLine(task.Status);

Sleep(TimeSpan.FromSeconds(1));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec102"/>How it works...</h2></div></div></div><p>Here, we <a id="id177" class="indexterm"/>define two kinds of delegates; one of them uses the <code class="literal">out</code> parameter and therefore is incompatible with the standard TPL API for converting the APM pattern to tasks. Then, we have three examples of such a conversion.</p><p>The key point<a id="id178" class="indexterm"/> for converting APM to TPL is the <code class="literal">Task&lt;T&gt;.Factory.FromAsync</code> method, where <code class="literal">T</code> is the asynchronous operation result type. There are several overloads of this method; in the first case, we pass <code class="literal">IAsyncResult</code> and <code class="literal">Func&lt;IAsyncResult, string&gt;</code>, which is a method that accepts the <code class="literal">IAsyncResult</code> implementation and returns a string. Since the first delegate type provides <code class="literal">EndMethod</code>, which is compatible with this signature, we have no problem converting this delegate asynchronous call to a task.</p><p>In the second example, we do almost the same, but use a different <code class="literal">FromAsync</code> method overload, which does not allow specifying a callback that will be executed after the asynchronous delegate call is completed. We are able to replace this with a continuation, but if the callback is important, we can use the first example.</p><p>The last example shows a little trick. This time, <code class="literal">EndMethod</code> of the <code class="literal">IncompatibleAsynchronousTask</code> delegate uses the <code class="literal">out</code> parameter and is not compatible with any <code class="literal">FromAsync</code> method overload. However, it is very easy to wrap the <code class="literal">EndMethod</code> call into a lambda expression that will be suitable for the task factory.</p><p>To see what is going on with the underlying task, we are printing its status while waiting for the asynchronous operation's result. We see that the first task's status is <code class="literal">WaitingForActivation</code>, which means that the task has not actually been started yet by the TPL infrastructure.</p></div></div>
<div class="section" title="Converting the EAP pattern to tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Converting the EAP pattern to tasks</h1></div></div></div><p>This<a id="id179" class="indexterm"/> recipe will describe how to translate event-based <a id="id180" class="indexterm"/>asynchronous operations to tasks. In this recipe, you will find a solid pattern that is suitable for every event-based asynchronous API in the .NET Framework class library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec103"/>Getting ready</h2></div></div></div><p>To begin this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe5</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec104"/>How to do it...</h2></div></div></div><p>To convert the EAP pattern to tasks, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.ComponentModel;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  Sleep(TimeSpan.FromSeconds(seconds));
  return 42 * seconds;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var tcs = new TaskCompletionSource&lt;int&gt;();

var worker = new BackgroundWorker();
worker.DoWork += (sender, eventArgs) =&gt;
{
  eventArgs.Result = TaskMethod("Background worker", 5);
};

worker.RunWorkerCompleted += (sender, eventArgs) =&gt;
{
  if (eventArgs.Error != null)
  {
    tcs.SetException(eventArgs.Error);
  }
  else if (eventArgs.Cancelled)
  {
    tcs.SetCanceled();
  }
  else
  {
    tcs.SetResult((int)eventArgs.Result);
  }
};

worker.RunWorkerAsync();

int result = tcs.Task.Result;

WriteLine($"Result is: {result}");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec105"/>How it works...</h2></div></div></div><p>This is a<a id="id181" class="indexterm"/> very simple and elegant example of converting EAP patterns to tasks. The key point is to use the <code class="literal">TaskCompletionSource&lt;T&gt;</code> type, where <code class="literal">T</code> is an asynchronous operation result type.</p><p>It is also important not <a id="id182" class="indexterm"/>to forget to wrap the <code class="literal">tcs.SetResult</code> method call into the <code class="literal">try/catch</code> block in order to guarantee that the error information is always set to the task completion source object. It is also possible to use the <code class="literal">TrySetResult</code> method instead of <code class="literal">SetResult</code> to make sure that the result has been set successfully.</p></div></div>
<div class="section" title="Implementing a cancelation option"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Implementing a cancelation option</h1></div></div></div><p>This recipe is about<a id="id183" class="indexterm"/> implementing the cancelation process for task-based asynchronous operations. You will learn how to use the cancelation token properly for tasks and how to find out whether a task is canceled before it was actually run.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec106"/>Getting ready</h2></div></div></div><p>To start with this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe6</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec107"/>How to do it...</h2></div></div></div><p>To implement<a id="id184" class="indexterm"/> a cancelation option for task-based asynchronous operations, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds, CancellationToken token)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  for (int i = 0; i &lt; seconds; i ++)
  {
    Sleep(TimeSpan.FromSeconds(1));
    if (token.IsCancellationRequested) return -1;
  }
  return 42*seconds;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var cts = new CancellationTokenSource();
var longTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 1", 10, cts.Token), cts.Token);
WriteLine(longTask.Status);
cts.Cancel();
WriteLine(longTask.Status);
WriteLine("First task has been cancelled before execution");

cts = new CancellationTokenSource();
longTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 2", 10, cts.Token), cts.Token);
longTask.Start();
for (int i = 0; i &lt; 5; i++ )
{
  Sleep(TimeSpan.FromSeconds(0.5));
  WriteLine(longTask.Status);
}
cts.Cancel();
for (int i = 0; i &lt; 5; i++)
{
  Sleep(TimeSpan.FromSeconds(0.5));
  WriteLine(longTask.Status);
}

WriteLine($"A task has been completed with result {longTask.Result}.");</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec108"/>How it works...</h2></div></div></div><p>This is <a id="id185" class="indexterm"/>another very simple example of how to implement the cancelation option for a TPL task. You are already familiar with the cancelation token concept we discussed in <a class="link" href="ch03.html" title="Chapter 3. Using a Thread Pool">Chapter 3</a>, <span class="emphasis"><em>Using a Thread Pool</em></span>.</p><p>First, let's look closely at the <code class="literal">longTask</code> creation code. We're providing a cancelation token to the underlying task once and then to the task constructor for the second time. <span class="emphasis"><em>Why do we need to supply this token twice?</em></span></p><p>The answer is that if we cancel the task before it was actually started, its TPL infrastructure is responsible for dealing with the cancelation because our code will not be executed at all. We know that the first task was canceled by getting its status. If we try to call the <code class="literal">Start</code> method on this task, we will get <code class="literal">InvalidOperationException</code>.</p><p>Then, we deal with the cancelation process from our own code. This means that we are now fully responsible for the cancelation process, and after we canceled the task, its status was still <code class="literal">RanToCompletion</code> because from TPL's perspective, the task finished its job normally. It is very important to distinguish these two situations and understand the responsibility difference in each case.</p></div></div>
<div class="section" title="Handling exceptions in tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Handling exceptions in tasks</h1></div></div></div><p>This recipe <a id="id186" class="indexterm"/>describes the very important topic of handling exceptions in asynchronous tasks. We will go through different aspects of what happens to exceptions thrown from tasks and how to get to their information.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec109"/>Getting ready</h2></div></div></div><p>To step<a id="id187" class="indexterm"/> through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe7</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec110"/>How to do it...</h2></div></div></div><p>To handle exceptions in tasks, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  Sleep(TimeSpan.FromSeconds(seconds));
  throw new Exception("Boom!");
  return 42 * seconds;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">Task&lt;int&gt; task;
try
{
  task = Task.Run(() =&gt; TaskMethod("Task 1", 2));
  int result = task.Result;
  WriteLine($"Result: {result}");
}
catch (Exception ex)
{
  WriteLine($"Exception caught: {ex}");
}
WriteLine("----------------------------------------------");
WriteLine();

try
{
  task = Task.Run(() =&gt; TaskMethod("Task 2", 2));
  int result = task.GetAwaiter().GetResult();
      WriteLine($"Result: {result}");
}
catch (Exception ex)
{
  WriteLine($"Exception caught: {ex}");
}
WriteLine("----------------------------------------------");
WriteLine();

var t1 = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 3", 3));
var t2 = new Task&lt;int&gt;(() =&gt; TaskMethod("Task 4", 2));
var complexTask = Task.WhenAll(t1, t2);
var exceptionHandler = complexTask.ContinueWith(t =&gt; 
    WriteLine($"Exception caught: {t.Exception}"), 
    TaskContinuationOptions.OnlyOnFaulted
  );
t1.Start();
t2.Start();

Sleep(TimeSpan.FromSeconds(5));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec111"/>How it works...</h2></div></div></div><p>When the <a id="id188" class="indexterm"/>program starts, we create a task and try to get the task results<a id="id189" class="indexterm"/> synchronously. The <code class="literal">Get</code> part of the <code class="literal">Result</code> property makes the current thread wait until the completion of the task and propagates the exception to the current thread. In this case, we easily catch the exception in a catch block, but this exception is a wrapper exception called <code class="literal">AggregateException</code>. In this case, it holds only one exception inside because only one task has thrown this exception, and it is possible to get the underlying exception by accessing the <code class="literal">InnerException</code> property.</p><p>The second example<a id="id190" class="indexterm"/> is mostly the same, but to access the task result, we use the <code class="literal">GetAwaiter</code> and <code class="literal">GetResult</code> methods. In this case, we do not have a wrapper exception because it is unwrapped by the TPL infrastructure. We have an original exception at once, which is quite comfortable if we have only one underlying task.</p><p>The last <a id="id191" class="indexterm"/>example shows the situation where we have two task-throwing exceptions. To handle exceptions, we now use a continuation, which is executed only in case the antecedent task finishes with an exception. This behavior is achieved by providing a <code class="literal">TaskContinuationOptions.OnlyOnFaulted</code> option to a continuation. As a result, we have <code class="literal">AggregateException</code> being printed out, and we have two inner exceptions from both the tasks inside it.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec112"/>There's more…</h2></div></div></div><p>As tasks may be connected in a very different manner, the resulting <code class="literal">AggregateException</code> exception might contain other aggregate exceptions inside along with the usual exceptions. Those inner aggregate exceptions might themselves contain other aggregate exceptions within them.</p><p>To get rid of those wrappers, we should use the root aggregate exception's <code class="literal">Flatten</code> method. It will return a collection of all the inner exceptions of every child aggregate exception in the hierarchy.</p></div></div>
<div class="section" title="Running tasks in parallel"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Running tasks in parallel</h1></div></div></div><p>This recipe <a id="id192" class="indexterm"/>shows how to handle many asynchronous tasks that are running simultaneously. You will learn how to be notified effectively when all tasks are complete or any of the running tasks have to finish their work.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec113"/>Getting ready</h2></div></div></div><p>To start this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe8</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec114"/>How to do it...</h2></div></div></div><p>To run tasks in parallel, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the<a id="id193" class="indexterm"/> following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static int TaskMethod(string name, int seconds)
{
  WriteLine(
    $"Task {name} is running on a thread id " +
    $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
    $"{CurrentThread.IsThreadPoolThread}");

  Sleep(TimeSpan.FromSeconds(seconds));
  return 42 * seconds;
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var firstTask = new Task&lt;int&gt;(() =&gt; TaskMethod("First Task", 3));
var secondTask = new Task&lt;int&gt;(() =&gt; TaskMethod("Second Task", 2));
var whenAllTask = Task.WhenAll(firstTask, secondTask);

whenAllTask.ContinueWith(t =&gt;
  WriteLine($"The first answer is {t.Result[0]}, the second is {t.Result[1]}"),
  TaskContinuationOptions.OnlyOnRanToCompletion);

firstTask.Start();
secondTask.Start();

Sleep(TimeSpan.FromSeconds(4));

var tasks = new List&lt;Task&lt;int&gt;&gt;();
for (int i = 1; i &lt; 4; i++)
{
  int counter = i;
  var task = new Task&lt;int&gt;(() =&gt; TaskMethod($"Task {counter}", counter));
  tasks.Add(task);
  task.Start();
}

while (tasks.Count &gt; 0)
{
  var completedTask = Task.WhenAny(tasks).Result;
  tasks.Remove(completedTask);
  WriteLine($"A task has been completed with result {completedTask.Result}.");
}

Sleep(TimeSpan.FromSeconds(1));</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec115"/>How it works...</h2></div></div></div><p>When the<a id="id194" class="indexterm"/> program starts, we create two tasks, and then, with the help of the <code class="literal">Task.WhenAll</code> method, we create a third task, which will be complete after all initial tasks are complete. The resulting task provides us with an answer array, where the first element holds the first task's result, the second element holds the second result, and so on.</p><p>Then, we create another list of tasks and wait for any of those tasks to be completed with the <code class="literal">Task.WhenAny</code> method. After we have one finished task, we remove it from the list and continue to wait for the other tasks to be complete until the list is empty. This method is useful to get the task completion progress or to use a timeout while running the tasks. For example, we wait for a number of tasks, and one of those tasks is counting a timeout. If this task is completed first, we just cancel all other tasks that are not completed yet.</p></div></div>
<div class="section" title="Tweaking the execution of tasks with TaskScheduler"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Tweaking the execution of tasks with TaskScheduler</h1></div></div></div><p>This <a id="id195" class="indexterm"/>recipe describes another very important aspect of dealing with tasks, which is a proper way to work with a UI from the asynchronous code. You will learn what a task scheduler is, why it is so important, how it can harm our application, and how to use it to avoid errors.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec116"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter4\Recipe9</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec117"/>How to do it...</h2></div></div></div><p>To tweak task execution with <code class="literal">TaskScheduler</code>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# <span class="strong"><strong>WPF Application</strong></span> project. This time, we will need a UI thread with a message loop, which is not available in console applications.</li><li class="listitem">In the <code class="literal">MainWindow.xaml</code> file, add the following markup inside a grid element (that is, between the <code class="literal">&lt;Grid&gt;</code> and <code class="literal">&lt;/Grid&gt;</code> tags):<div class="informalexample"><pre class="programlisting">&lt;TextBlock Name="ContentTextBlock"
HorizontalAlignment="Left"
Margin="44,134,0,0"
VerticalAlignment="Top"
Width="425"
Height="40"/&gt;
&lt;Button Content="Sync"
HorizontalAlignment="Left"
Margin="45,190,0,0"
VerticalAlignment="Top"
Width="75"
Click="ButtonSync_Click"/&gt;
&lt;Button Content="Async"
HorizontalAlignment="Left"
Margin="165,190,0,0"
VerticalAlignment="Top"
Width="75"
Click="ButtonAsync_Click"/&gt;
&lt;Button Content="Async OK"
HorizontalAlignment="Left"
Margin="285,190,0,0"
VerticalAlignment="Top"
Width="75"
Click="ButtonAsyncOK_Click"/&gt;</pre></div></li><li class="listitem">In <a id="id196" class="indexterm"/>the <code class="literal">MainWindow.xaml.cs</code> file, use the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">MainWindow</code> constructor:<div class="informalexample"><pre class="programlisting">void ButtonSync_Click(object sender, RoutedEventArgs e)
{
  ContentTextBlock.Text = string.Empty;
  try
  {
    //string result = TaskMethod(
    //  TaskScheduler.FromCurrentSynchronizationContext()).Result;
    string result = TaskMethod().Result;
    ContentTextBlock.Text = result;
  }
  catch (Exception ex)
  {
    ContentTextBlock.Text = ex.InnerException.Message;
  }
}

void ButtonAsync_Click(object sender, RoutedEventArgs e)
{
  ContentTextBlock.Text = string.Empty;
  Mouse.OverrideCursor = Cursors.Wait;
  Task&lt;string&gt; task = TaskMethod();
  task.ContinueWith(t =&gt; 
    {
      ContentTextBlock.Text = t.Exception.InnerException.Message;
      Mouse.OverrideCursor = null;
    }, 
    CancellationToken.None,
    TaskContinuationOptions.OnlyOnFaulted,
    TaskScheduler.FromCurrentSynchronizationContext());
}

void ButtonAsyncOK_Click(object sender, RoutedEventArgs e)
{
  ContentTextBlock.Text = string.Empty;
  Mouse.OverrideCursor = Cursors.Wait;
  Task&lt;string&gt; task = TaskMethod(
    TaskScheduler.FromCurrentSynchronizationContext());

  task.ContinueWith(t =&gt; Mouse.OverrideCursor = null,
    CancellationToken.None,
    TaskContinuationOptions.None,
    TaskScheduler.FromCurrentSynchronizationContext());
}

Task&lt;string&gt; TaskMethod()
{
  return TaskMethod(TaskScheduler.Default);
}

Task&lt;string&gt; TaskMethod(TaskScheduler scheduler)
{
  Task delay = Task.Delay(TimeSpan.FromSeconds(5));

  return delay.ContinueWith(t =&gt;
  {
    string str =
      "Task is running on a thread id " +
      $"{CurrentThread.ManagedThreadId}. Is thread pool thread: " +
      $"{CurrentThread.IsThreadPoolThread}";

    ContentTextBlock.Text = str;
    return str;
  }, scheduler);
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How it works...</h2></div></div></div><p>Here, we meet <a id="id197" class="indexterm"/>many new things. First, we created a WPF application instead of a console application. It is necessary because we need a user interface thread with a message loop to demonstrate the different options of running a task asynchronously.</p><p>There is a very important abstraction called <code class="literal">TaskScheduler</code>. This component is actually responsible for how the task will be executed. The default task scheduler puts tasks on a thread pool worker thread. This is the most common scenario; unsurprisingly, it is the default option in TPL. We also know how to run a task synchronously and how to attach them to the parent tasks to run those tasks together. Now, let's see what else we can do with tasks.</p><p>When the program starts, we create a window with three buttons. The first button invokes a synchronous task execution. The code is placed inside the <code class="literal">ButtonSync_Click</code> method. While the task runs, we are not even able to move the application window. The user interface gets totally frozen while the user interface thread is busy running the task and cannot respond to any message loop until the task is complete. This is quite a common bad practice for GUI Windows applications, and we need to find a way to work around this issue.</p><p>The second problem is that we try to access the UI controls from another thread. Graphical User Interface controls have never been designed to be used from multiple threads, and to avoid possible errors, you are not allowed to access these components from a thread other than the one on which it was created. When we try to do that, we get an exception, and the exception message is printed on the main window in 5 seconds.</p><p>To resolve the first problem, we try to run the task asynchronously. This is what the second button does; the code for this is placed inside the <code class="literal">ButtonAsync_Click</code> method. If you run the task in a debugger, you will see that it is placed on a thread pool, and in the end, we will get the same exception. However, the user interface remains responsive all the time the task runs. This is a good thing, but we need to get rid of the exception.</p><p>And we already <a id="id198" class="indexterm"/>did that! To output the error message, a continuation was provided with the <code class="literal">TaskScheduler.FromCurrentSynchronizationContext</code> option. If this wasn't done, we would not see the error message because we would get the same exception that took place inside the task. This option instructs the TPL infrastructure to put a code inside the continuation on the UI thread and run it asynchronously with the help of the UI thread message loop. This resolves the problem with accessing UI controls from another thread, but still keeps our UI responsive.</p><p>To check whether this is true, we press the last button that runs the code inside the <code class="literal">ButtonAsyncOK_Click</code> method. All that is different is that we provide the UI thread task scheduler to our task. After the task is complete, you will see that it runs on the UI thread in an asynchronous manner. The UI remains responsive, and it is even possible to press another button despite the wait cursor being active.</p><p>However, there are some tricks to use the UI thread in order to run tasks. If we go back to the synchronous task code and uncomment the line with getting the result with the UI thread task scheduler provided, we will never get any result. This is a classical deadlock situation: we are dispatching an operation in the queue of the UI thread, and the UI thread waits for this operation to complete, but as it waits, it cannot run the operation, which will never end (or even start). This will also happen if we call the <code class="literal">Wait</code> method on a task. To avoid deadlock, never use synchronous operations on a task scheduled to the UI thread; just use <code class="literal">ContinueWith</code> or <code class="literal">async</code>/<code class="literal">await</code> from C#.</p></div></div></body></html>