- en: '*Chapter 8*: Planets: Tracking Images'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using augmented reality for data visualization and
    education. We're going to build a project where users can learn about the planets
    in our Solar System. Suppose you have a children's science book on the Solar System
    with a companion mobile app. On the page about planet Earth, for example, the
    reader can point their mobile device at the picture on the page and a 3D rendering
    of the Earth will pop out of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The AR mechanism we'll be using is known as *image tracking*. With image tracking,
    you prepare a reference library of images that may be recognized and tracked in
    the real world at runtime. When the user's device's camera detects one of these
    images, a virtual object can be instantiated at the image location.
  prefs: []
  type: TYPE_NORMAL
- en: I have provided you with "planet cards," which have pictures and unique markers
    on them for each planet that I created from free resources available on the web,
    for you to print yourself and use with the app. For rendering the planets' spherical
    surface skins, we will be using free texture images of the actual planets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AR image tracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the Planets project and getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and tracking reference images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and instantiating a virtual Earth prefab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating a planet on its axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding the project with multiple planets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a responsive UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a working app that detects images on
    the provided planet cards, renders a 3D model of the given planet, and offers
    additional information details about a planet.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the project in this chapter, you need Unity installed on your development
    computer, connected to a mobile device that supports augmented reality applications
    (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013), *Setting Up
    for AR Development*, for instructions). We also assume that you have the `ARFramework`
    template and all its prerequisites installed. See [*Chapter 5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*,
    Using the AR User Framework*, for more details. The completed project can be found
    in this book's GitHub repository at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AR image tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building our project, let's take a moment to learn how AR image
    tracking works. In this section, I'll introduce some of the basic principles behind
    image recognition and tracking, and what makes some images better than others
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the principles behind augmented reality involve using compute mechanisms
    to recognize features in the real world, determine their position and orientation
    in a 3D space, instantiate virtual objects relative to and anchored within this
    3D space, and track the user as they move within this space. Modern devices can
    accomplish this using their video cameras and other sensors built into the device
    to performing real-time spatial mapping of the environment. A different approach
    is for the device to track predetermined images. That is what we will use for
    the project in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Augmented reality technology was born in the 1990s, where QR code-like marker
    images were used for tracking. An example is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A basic AR marker'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – A basic AR marker
  prefs: []
  type: TYPE_NORMAL
- en: Marker images can be used for triggering and positioning virtual objects in
    the real world. These simplistic yet visually distinct markers are easily detected,
    even by low-end devices. Such markers are readily detectable because of their
    *distinctive details*, *high contrast edges*, and an *asymmetric shape* – that
    is, it's an easily recognizable image with unambiguous top, bottom, left, and
    right sides. In this way, the detection software can determine which marker image
    is in view and the orientation of the camera relative to the marker in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taken to the next level, products such as Merge Cube ([https://mergeedu.com/cube](https://mergeedu.com/cube))
    have markers on each of its six faces, just like a physical cube that you can
    hold in your hand. Users can find companion apps with a wide gamut of games, learning,
    and exploration experiences. Merge offers a Unity package for developers so that
    you can build your own projects for it too. Merge Cube is depicted in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Merge Cube provides a 3D tracking cube with markers on each
    face'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.02_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Merge Cube provides a 3D tracking cube with markers on each face
  prefs: []
  type: TYPE_NORMAL
- en: Markers can be combined with natural images to provide pleasing and informative
    yet visually distinct images that also act as AR markers. You'll often see this
    in AR augmented storybooks or even cereal boxes. This is the approach I have taken
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While markers provide the highest reliability, they are not necessarily required
    for image tracking. Ordinary photographic images can also be used. In AR lingo,
    these are referred to as *natural feature images*. Images for tracking must have
    the same characteristics that make markers reliable – distinctive details, high
    contrast edges, and an asymmetric shape. Much has been written about the best
    practices for selecting images. For instance, the AR Core developer guide ([https://developers.google.com/ar/develop/java/augmented-images/](https://developers.google.com/ar/develop/java/augmented-images/))
    contains additional tips about using reference images, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use an image resolution of at least 300 x 300 pixels. However, a very high resolution
    does not help with recognition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color information is not used, so either color or grayscale images are just
    as good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid images with a lot of geometric features, or too few.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid repeating patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AR Core SDK comes with an **arcoreimg** tool that can evaluate images and
    returns a quality score between 0 and 100 for each image, where a score of at
    least 75 is recommended. Likewise, Unity uses a similar tool when compiling the
    Image Reference Library in your builds (we'll learn more about this later in this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Given this general understanding of using image tracking in augmented reality
    applications, let's begin by defining a fun and interesting project – visualizing
    our Solar System's planets.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Planets project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a planet information app that allows users to scan *planet
    cards* to visualize a 3D model of each planet in the Solar System. Imagine this
    being part of a trading card collection or a companion app to a children's science
    book. When the user points the device's camera at one of the planet cards, they
    can see a 3D rendering of the planet. Upon pressing an **Info** button, the user
    can get additional information about that planet. In this section, I will define
    the general user experience flow, give you instructions for preparing the planet
    cards for your own use, and help you collect assets that you'll use in this project.
  prefs: []
  type: TYPE_NORMAL
- en: User experience flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general onboarding user workflow will play out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup-mode**: The app will start, check the device for AR support, and
    ask for camera permissions (OS-dependent). Once read, the app will go into Scan-mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scan-mode**: The user is prompted to aim the camera at an image for detection
    and tracking. When at least one image is being tracked, the app goes into Main-mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Main-mode**: This is where the app responds to new or updated tracked images
    and allows the user to interact with the planet. When an image is tracked, it
    determines which planet corresponds to the image and instantiates the planet''s
    game object. If tracking is lost, the app may go back to Scan-mode to prompt the
    user. If a different image is tracked, the current planet is replaced with the
    new image''s planet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This workflow is a bit simpler than the ones we implemented in the previous
    chapters. In that case, we needed the user to scan the environment for trackable
    planes before starting Main-mode. The user was then asked to deliberately tap
    the screen to place a virtual object in the scene. Furthermore, in the AR Gallery
    project, we added Edit-mode to modify pictures that had been added by the user.
    Much of that is unnecessary in this project; the process is more automated as
    we let the device detect an image and we instantiate a virtual object in response.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the planet cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this project, we are using printed *planet cards* as marker images so that
    we can choose a planet to visualize. You can find a PDF file that contains the
    cards in the project files for this chapter (in the folder named `Printables/`).
    To prepare the cards for this project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Print out the `PlanetCards.pdf` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, cut the sheets into separate cards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I suggest that you print on thick paper stock or mount the printouts on paperboard
    to avoid warping, which may affect the software's ability to recognize the images
    at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following photo shows getting these cards ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Cutting the printed planet cards for this project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.03_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Cutting the printed planet cards for this project
  prefs: []
  type: TYPE_NORMAL
- en: These cards were created from a combination of resources that can be found for
    free on the web. I found the original flashcards on the *Kids Flashcards* website.
    Upon going to [https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english](https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english),
    I downloaded the *Solar System flashcards free* PDF file.
  prefs: []
  type: TYPE_NORMAL
- en: First, I attempted to use the flashcards as-is, but the pictures were not distinctive
    enough to be detected individually. So, I decided to add *ArUco* markers to each
    one. ArUco is a square marker with a wide black border and inner binary matrix
    that determines its ID based on OpenCV (the Open Source Computer Vision library,
    which was developed at the *University of Cordoba, Spain*; see [https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html](https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html)).
    I used the online ArUco marker generator at [https://chev.me/arucogen/](https://chev.me/arucogen/)
    to make separate markers for each planet.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I used *Photoshop* to combine the markers with the planet flashcards to
    make our final planet cards for this project. (The Photoshop PSD file is also
    included with this chapter's files on GitHub.)
  prefs: []
  type: TYPE_NORMAL
- en: Each planet card is also a separate PNG image. These have been provided for
    you in the `Image Library/` folder. Later in this chapter, we will create an image
    reference library and add these images. The images are named with the pattern
    *[planetname]*`-MarkerCard.png`; for example, `Earth-MarkerCard.png`. We'll take
    advantage of this naming convention in our code.
  prefs: []
  type: TYPE_NORMAL
- en: When the app detects a planet card, the application will instantiate a model
    of the planet. For this, we need texture images for the planet materials.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting planet textures and data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need texture images to use as the planet skins of the spherical mesh for
    each planet. The ones we're using I found at the interesting *Solar System Scope*
    project site ([https://www.solarsystemscope.com/](https://www.solarsystemscope.com/)).
    These are included with the files for this chapter in this book's GitHub repository
    and can be downloaded from [https://www.solarsystemscope.com/textures/](https://www.solarsystemscope.com/textures/).
    That said, you can find alternative assets in the Unity Asset Store ([https://assetstore.unity.com/?q=solar%20system&orderBy=1](https://assetstore.unity.com/?q=solar%20system&orderBy=1)),
    including the classic *Planet Earth Free* package ([https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399](https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399))
    for Earth itself, which includes cloud cover.
  prefs: []
  type: TYPE_NORMAL
- en: For additional metadata about the planets, I found the *Planetary Fact Sheet*
    on the NASA.gov website ([https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html))
    and more details at [https://nssdc.gsfc.nasa.gov/planetary/planetfact.html](https://nssdc.gsfc.nasa.gov/planetary/planetfact.html).
    We could use some of these details directly while rendering and animating our
    models, such as the planet diameter (km), rotation period (hours), and tilt (obliquity
    to orbit in degrees).
  prefs: []
  type: TYPE_NORMAL
- en: With our planet cards, planet skin textures, and other planetary details in
    hand, we're ready to start building the project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we''ll create a new scene named `PlanetsScene` using the `ARFramework`
    scene template. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File | New Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New Scene** dialog box, select the **ARFramework** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Scenes/` folder in your `Assets` project, name it `PlanetsScene`, and
    click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new AR scene already has the following set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AR Session** game object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AR Session Origin** rig with the raycast manager and plane manager components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI Canvas** is a screen space canvas with child panels; that is, Startup
    UI, Scan UI, Main UI, and NonAR UI. It also contains the UI Controller component
    script that we wrote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction Controller** is a game object that contains the Interaction Controller
    component script we wrote, which helps the app switch between interaction modes,
    including the Startup, Scan, Main, and NonAR modes. It also has a **Player Input**
    component that''s been configured with the **AR Input Actions** asset we created
    previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **OnboardingUX** prefab from the AR Foundation Demos project, which provides
    AR session status and feature detection status messages, as well as animated onboarding
    graphics prompts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can set the app title now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, unfold the **UI Canvas** object and unfold its
    child **App Title Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Title Text** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its `Planet Explorer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using this scene as a basis, we will replace the AR trackable components with
    an AR Tracked Image Manager one.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking reference images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our starter scene includes an AR Session Origin with components for Player Input
    and AR Raycast Manager. It also has a component we do not need in this project,
    for detecting and tracking planes, which we'll replace with AR Tracked Image Manager
    instead. Documentation on **AR Tracked Image Manager** can be found at [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html).
    Then, we'll create an image reference library for our planet card images.
  prefs: []
  type: TYPE_NORMAL
- en: Adding AR Tracked Image Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure the AR Session to track images, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, use the **3-dot** context menu (or *right-click*)
    on **AR Plane Manager** and select **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `AR` and add an **AR Tracked Image Manager** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll notice that there is a **Serialized Library** slot on the component for
    the reference image library. We'll create that next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reference image library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reference image library contains records for each of the images that the
    application will be able to detect and track in the real world. In our case, we're
    going to add the planet card images. In the assets provided in the GitHub repository
    for this book, there is a folder named `Image Library/` that already contains
    the planet card images we'll be adding to the library. We will start with just
    the Earth card here; we will add the other planets later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the library by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Image Library/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on the `Image Library/` folder and select **Create | XR | Reference
    Image Library**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **ReferenceImageLibrary** assets selected, in the **Inspector** window,
    click **Add Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Earth-MarkerCard` image from the **Project** window onto the square
    image texture slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Specify Size** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you printed the planet cards from the PDF provided, at scale, the width will
    be about 8 cm, or 0.08 meters. Otherwise, use a ruler to measure the Earth planet
    card you printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, enter the width (`0.08`) in the **X** field. The **Y** value will be automatically
    updated based on the PNG image's pixel dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Keep Texture At Runtime** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting **Reference Image Library** settings are shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Reference Image Library with the Earth added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.04_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Reference Image Library with the Earth added
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can update the **AR Tracked Image Manager** component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **ReferenceImageLibrary** asset from the **Project** window onto the
    **Serialized Library** slot of **AR Tracked Image Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Temporarily, while we get this project set up, we'll instantiate an existing
    prefab object when the image is detected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, drag the `ARF-samples/Prefabs/` folder onto the **Tracked Image
    Prefab** slot (or another similar object).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **AR Tracked Image Manager** component should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The AR Tracked Image Manager with the reference image library
    assigned'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.05_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The AR Tracked Image Manager with the reference image library assigned
  prefs: []
  type: TYPE_NORMAL
- en: You now have an AR scene that recognizes and tracks images that have been defined
    in a reference library. Currently, the library only contains the Earth-MarkerCard
    image. When the image is recognized while running the app, a simple cube will
    be placed on the Earth planet card.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost ready to try this out. But first, let's configure the user framework's
    UI and modes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the user interaction modes and UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scene template, `ARFramework`, where we started provides a simple framework
    for enabling user interaction modes and displaying the corresponding UI panels
    for a mode. This project will start in Startup-mode while the AR Session is initializing
    so that we can verify that the device supports AR. Then, it will transition to
    Scan-mode, where it will try to find one of the reference images. Once found,
    it will transition to Main-mode, where we can support additional user interactions
    with the app's content.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for reference images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Scan-mode, we''ll display an instructional graphic prompting the user to
    point the camera at a planet card with a planet and marker image. Perform the
    following steps to configure this:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, unfold the **UI Canvas** game object and unfold
    its child **Scan UI**. Select the child **Animated Prompt** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window set **Animated Prompt | Instruction to Find An Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will now play the Find Image Clip we defined on the **OnboardingUX** object,
    which is provided by the Unity Onboarding UX assets and is already present in
    our scene hierarchy. What you can expect is shown in the following screen capture.
    On the left is Startup-mode, where the AR Session is being initialized. On the
    right is Scan-mode, where the user is prompted to find an image (you can't see
    the video feed because I'm covering the camera to make the prompt more visible
    in the screen capture).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.06_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to set up the Scan-mode''s script to know when an image has been
    found and transition to Main-mode. We''ll replace the default `ScanMode` script
    with a similar one that references `ARTrackedImageManager` instead of `ARTrackedPlaneManager`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Scripts/` folder by *right-clicking* and selecting`ImageScanMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `ImageScanMode` and replace its content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script. Then, back in Unity, in the **Hierarchy** window, select the
    **Scan Mode** game object (under **Interaction Controller**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, remove the original **Scan Mode** component using
    the *3-dot* context menu and selecting **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **ImageScanMode** script onto the **Scan Mode** object, adding it as
    a new component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** window, drag the **AR Session Origin** object into the
    **Inspector** window and drop it onto the **Image Scan Mode | Image Manager**
    slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The component will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The Image Scan Mode component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.07_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – The Image Scan Mode component
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have created a new scene using the `ARFramework` template and
    modified it to use **AR Tracked Image Manager** and prompt the user to scan for
    an image accordingly. When an image is detected (for example, the Earth-MarkerCard),
    a generic game object will be instantiated (for example, the AR Placed Cube prefab).
    Let's test what we have accomplished so far on the target device.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build and run the scene on your target device, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you've saved the work you've done on the current scene by going to **File
    | Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File | Build Settings** to open the **Build Settings** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add Open Scenes** to add the current scene to the **Scenes In Build**
    list (if it's not already present).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck all but the current scene, `PlanetsScene`, from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click **Build And Run** to build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the app launches, point your device''s camera at the printed Earth planet
    card. Your virtual cube should get instantiated at that location, as shown in
    the following screen capture from my phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – The Earth card has been detected, and the cube has been instantiated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.08_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – The Earth card has been detected, and the cube has been instantiated
  prefs: []
  type: TYPE_NORMAL
- en: We now have a basic AR scene with image detection set up to recognize the Earth
    planet card and instantiate a sample prefab at that location. Now, let's make
    a planet Earth model that we can use instead of this silly cube.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and instantiating a virtual Earth prefab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create prefab game objects for each of the planets.
    Since each of the planets has similar behaviors (for example, they rotate), we'll
    first create a generic Planet Prefab, and then make each specific planet a variant
    of that one. In Unity, `Planet` script that animates the planet's rotation and
    handles other behavior. Each planet will have its own "skin" defined by a material,
    along with a base texture map, which we downloaded earlier from the web.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll create a generic Planet Prefab object, create an Earth
    Prefab as a variant, add planet metadata by writing a `Planet` component script,
    and implement a planet rotation animation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the generic Planet Prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Planet Prefab contains a 3D sphere that gets rendered with each planet''s
    texture image. Planets spin along their axes, so we''ll set up a hierarchy with
    an Incline transform that defines this incline axis. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Planet Prefab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* (or select **Open Prefab** in the **Inspector** window) to open
    the prefab for editing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the main menu, select `Incline`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Planet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will be useful to have any planets we instantiate in the scene on a specific
    layer. I will name this layer `PlacedObjects`. (I introduced and discussed layers
    in a previous chapter). With its root `PlacedObjects`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `PlacedObjects` layer doesn't exist, select `PlacedObjects` to one of
    the empty slots. In the `PlacedObjects.`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will then be prompted with the question, **Do you want to set layer to PlacedObjects
    for all child objects as well?** Click **Yes, Change Children**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Save** the prefab.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is very simplistic right now (only a sphere child object is being parented
    by an Incline transform), but it will serve as a template for each planet prefab
    that we add. The Planet Prefab hierarchy is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The Planet Prefab hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.09_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – The Planet Prefab hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Each planet will be rendered with a skin representing an actual view of that
    planet. Before creating the Earth prefab, let's take a moment to understand render
    materials and the texture images we are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding equirectangular images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Unity renders a 3D model, it starts with a 3D mesh that describes the
    geometry. Much like a fishing net, a mesh is a collection of vertices and vectors,
    with the vectors connecting these vertices, organized as triangles (or sometimes
    four-sided quads) that define the surface of the mesh. The following illustration
    shows a wireframe view of a sphere mesh on the left. On the right is a rendered
    view of the sphere, with a globe texture mapped onto its 3D surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Sphere mesh (left) and rendered sphere with texture (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Sphere mesh (left) and rendered sphere with texture (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'A texture image is just a 2D image file (for example, a PNG file) that is computationally
    mapped onto the 3D mesh''s surface when it is rendered. Think of unraveling a
    globe as a 2D map, like cartographers have been doing for centuries. A common
    2D projection is known as **equirectangular**, where the center (equator) is at
    the correct scale and the image gets increasingly stretched as it approaches the
    top and bottom poles. The following image shows the equirectangular texture of
    the preceding globe (illustration by *Stefan Kuhn*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Equirectangular texture that defines the skin of a sphere'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Equirectangular texture that defines the skin of a sphere
  prefs: []
  type: TYPE_NORMAL
- en: Information – Equirectangular Images Are Also Used in 360-Degree Media and VR
  prefs: []
  type: TYPE_NORMAL
- en: Equirectangular images are also known as 360-degree images and used in virtual
    reality applications. In VR, the image is effectively mapped to the *inside* of
    a sphere, where you're viewing from the inside rather than the outside of a globe!
  prefs: []
  type: TYPE_NORMAL
- en: 'For our project, we have texture images for each of the planets. The Mars one,
    for example, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Texture map image for Mars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Texture map image for Mars
  prefs: []
  type: TYPE_NORMAL
- en: To create a prefab for a specific planet, such as Earth, we'll need to create
    a material that uses the Earth texture image. We'll build that now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Earth prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Earth prefab will be a variant of the Planet Prefab, with its own Earth
    Material. Create it by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Earth Prefab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* **Earth Prefab** (or select **Open Prefab** in the **Inspector**
    window).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Materials/` folder (create one if necessary) and select `Earth Material`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Earth Material** from the **Project** window and drop it onto the **Planet**
    game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `Planet Textures/earth`) in the **Project** Assets and drag it onto
    the **Surface Inputs | Base Map** texture chip. The following screenshot shows
    **Earth Material** in the **Inspector** window:![Figure 8.13 – Earth Material
    with the Base Map texture defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B15145.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.13 – Earth Material with the Base Map texture defined
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's pick a default size for our planet when added to the scene. Unless you
    want to place a 1-meter diameter planet into your scene (!), we need to set its
    **Scale**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Planet** child object in the **Hierarchy** window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In its `0.1, 0.1, 0.1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, to rest the planet on the image's surface, we could set its Y position
    to `0.05`. But to let it hover a little above, we will set `0.075`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Save** the prefab and exit back to the **Scene** hierarchy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use this prefab instead of the AR Placed Cube prefab in the AR Tracked Image
    Manager component on the AR Session Origin object. Later, we''ll manage this more
    correctly using a script but for now, let''s just try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Earth Prefab** from the **Project** window into the **Inspector** window
    and drop it into the **AR Tracked Image Manager | Tracked Image Prefab** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build and Run** the scene.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time, when you point the camera at the Earth planet card, the Earth prefab
    will appear, as shown in the following screen capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – While tracking the Earth planet card, the app instantiates
    an Earth prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – While tracking the Earth planet card, the app instantiates an
    Earth prefab
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty nice. The prefab could also include other information about
    the planet. We'll look at how to do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding planet metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each planet prefab can include additional information about that planet. We
    can capture this in the `Planet` script of the prefab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Project** window, open **Planet Prefab** for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Scripts/` folder, create a new C# script named `Planet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Planet` script onto the root **Planet Prefab** game object, adding
    it as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Planet` script in your code editor and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script. Then, in Unity, **Save** the prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although we have made all these changes to the Planet Prefab, the Earth Prefab
    inherits everything because it is a prefab variant.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, open **Earth Prefab** for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Earth`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Earth is the third planet from the Sun and the only astronomical object
    known to harbor and support life`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Save** the prefab.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also can ascribe behaviors to the planet prefab, such as rotation about its
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the planet's rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Planets spin. Some faster than others. Mercury just barely – it rotates once
    every 59 Earth days, while it orbits the Sun in 88 Earth days! And a planet''s
    axis of rotation is not perfectly vertical (relative to its orbit around the Sun).
    Earth, for example, is tilted by 23.4 degrees, while Venus rotates on its side
    at 177.4 degrees! OK, enough science trivia – let''s animate our Earth model.
    We''re going to add a `Planet` behavior script to the Planet Prefab that rotates
    the planet along its rotation axis. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Planet` script in your code editor and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the class, we will declare variables for `inclineDegrees` (Earth
    is 23.4) and `rotationPeriodHours` (Earth is 24). We will also define references
    to the prefab's `incline` and `planet` child objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a public `animationHoursPerSecond`, which sets the animation speed.
    I've initialized it to `1.0`, which means the Earth will complete one rotation
    in 24 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` function sets up the **Incline** angle by rotating along the Z-axis.
    This only needs to be done once.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` function rotates the planet about its local Y-axis. Since the
    planet is parented by the `Time.deltaTime` each `Update` is a common Unity idiom
    for calculating how an object's Transform changes from one frame to the next,
    where `deltaTime` is the fraction of a second since the previous `Update`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving the script, back in Unity, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Project** window, open **Planet Prefab** for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the root **Plane Prefab** game object is selected in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Incline** game object from the **Hierarchy** window into the **Inspector**
    window before dropping it onto the **Planet | Incline** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Planet** object onto the **Planet | Planet** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Planet** component will now look like this in the **Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The Planet component on the Planet Prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – The Planet component on the Planet Prefab
  prefs: []
  type: TYPE_NORMAL
- en: Please now **Build and Run** the project. When the Earth is instantiated, it
    will be tilted and rotating at the rate of one full rotation every 24 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a basic AR scene with image tracking. It lets the AR
    Tracked Image Manager instantiate our Earth Prefab directly when an image is detected.
    Currently, it doesn't distinguish what image is detected (supposing you had multiple
    images in the reference library) and always instantiates an Earth Prefab. We need
    to make the app more robust, and we can do this from the Main-mode.
  prefs: []
  type: TYPE_NORMAL
- en: Building the app's Main-mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you now know, `ARTrackedImageManager` has a "Tracked Image Prefab" field;
    however, this is not intended for content" ([https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html)).
    Currently, when *any* reference image is recognized, the Earth Prefab will *always*
    be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather, when the app is in Main-mode, we should determine which planet card
    image is being tracked and instantiate the corresponding planet prefab for that
    card. So far, we only have one planet, Earth, in the image reference library.
    However, later in this chapter, we''ll expand the project for all the planets.
    We can start by removing the prefab from the **AR Tracked Image Manager** component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector** window, delete the contents of the **AR Tracked Image
    Manager | Tracked Image Prefab** slot, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.16 – AR Tracked Image Manager with the default prefab field cleared'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – AR Tracked Image Manager with the default prefab field cleared
  prefs: []
  type: TYPE_NORMAL
- en: When no prefab is specified in `ARTrackedImage` component on it. Now, we can
    instantiate the prefab as a child of that.
  prefs: []
  type: TYPE_NORMAL
- en: In our scene framework, the app starts in Startup-mode, then goes into Scan-mode
    once the AR Session is ready. When Scan-mode detects a reference image, it goes
    into Main-mode by enabling the **Main Mode** game object under **Interaction Controller**.
    This displays the **Main UI** panel. Let's build this panel now.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the PlanetsMainMode script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will write a new `PlanetsMainMode` script to replace the
    default `MainMode` one provided in the default scene template. Like other modes
    in our framework, it will display the appropriate UI panel when enabled. Then,
    when an image is tracked, it will find the corresponding planet prefab and instantiate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The script needs to figure out which image the AR software found and decide
    which prefab to instantiate as a child of the tracked image. In our case, we'll
    use the name of the detected image file to determine which planet card is recognized
    (by design, each card image is prefixed with the planet's name; for example, `Earth-MarkerCard`).
    The script will implement a serializable dictionary we can use to look up the
    planet prefab for each planet name, using the *Serialized Dictionary Lite* Asset
    package (you already have this package installed because `ARFramework` also requires
    it. See [https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992](https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992)
    for more information).
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Scripts/` folder, create a new C# script named `PlanetsMainMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **Main Mode** game object (under **Interaction
    Controller**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Inspector** window, remove the default **Main Mode** component using
    the *3-dot* context menu and selecting **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `PlanetMainMode` script from the **Project** window onto the **Main
    Mode** object, adding it as a new component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the `PlanetMainMode` script to open it for editing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by adding the following `using` assembly declarations at the top of the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When an image is tracked, we need to find which planet prefab to instantiate.
    At the top of the file, define a `PlanetPrefabDictionary` as follows, and declare
    a `planetPrefab` variable for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When this mode is enabled, similar to the original `MainMode` script, we''ll
    show the Main UI panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, we''ll enter Main-mode after Scan-mode has determined it has started
    tracking an image. So, `OnEnable` should also instantiate planets for the tracked
    images. Add a reference to `imageManager` at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update `OnEnable`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `InstantiatePlanet`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `InstantiatePlanet` function determines the planet's name from the tracked
    image filename (for example, `Earth-MarkerImage`) by assuming the images follow
    our naming convention. It makes sure we don't already have the planet object in
    the scene. If not, the planet prefab is instantiated and parented to the tracked
    image object. (We pass `false` as a second parameter so that the planet is positioned
    relative to the tracked image transform. See [https://docs.unity3d.com/ScriptReference/Transform.SetParent.html](https://docs.unity3d.com/ScriptReference/Transform.SetParent.html).)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in Unity, make sure you have the **Main Mode** game object selected in
    the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **AR Session Origin** object from the **Hierarchy** window into the
    **Inspector** window, dropping it onto the **Image Manager** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, click the **+** button at the bottom right of the
    **Planets Main Mode | Planet Prefabs** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the word `Earth` into the `Id` slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the item and, from the **Hierarchy** window, drag the **Earth Prefab**
    object on the **Value** slot in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **File | Save** to save your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you `PlanetsMainMode` when it is enabled. Now, the code is ready to detect
    different planet card images and instantiate different corresponding planet prefabs.
    We will start by adding Mars.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the project with multiple planets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add another planet to the project, we need to add its planet card image to
    the Reference Image Library, create its planet prefab, including a material for
    rendering the planet skin, and add the reference to the `planetPrefabs` list in
    `PlanetsMainMode`. Then, we'll update the script to handle tracking multiple planets.
    Let's walk through the steps for adding Mars.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the planet card image to the Reference Image Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to add Mars to our **Reference Image Library**:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate and select your `Image Library/` folder.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Inspector** window, click **Add Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and drag the `Mars-MarkerCard` image from the **Project** window and
    drop it onto the empty image **Texture** slot in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the `0.08` meters (8 cm).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, check the **Keep Texture At Runtime** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Reference Image Library should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.17_B15145.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Reference Image Library with the Mars-MarkerCard image added
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create the Mars Prefab and material.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the planet prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the planet prefab, we''ll copy and modify the Earth Prefab assets.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Prefabs/` folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Mars Prefab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Mars Prefab** for editing. Select the child **Planet** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Materials/` folder and select `Mars Material`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Mars Material** onto the **Planet** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Planet Textures/` folder) and drag it onto the **Mars Material | Base
    Map** texture slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Mars Prefab Planet should now look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Mars Prefab with its Planet set to the Mars Material'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B15145.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.18 – Mars Prefab with its Planet set to the Mars Material
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll set the Mars Planet metadata. In the **Hierarchy** window, select
    the root **Mars Prefab** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Mars`; `25.2`; `24.7`. For its `Mars is the fourth planet from the Sun
    and the second-smallest planet in the Solar System`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Save** the prefab and return to the scene Hierarchy (using the **<** button
    at the top left of the **Hierarchy** window).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can add the prefab to the Main-mode **Planet Prefabs** dictionary,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the scene **Hierarchy**, select the **Main Mode** game object (under **Interaction
    Controller**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, click the **+** button at the bottom right of the
    **Planets Main Mode | Planet Prefabs** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the word `Mars` into the `Id` slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold the item and, from the **Hierarchy** window, drag the **Mars Prefab**
    object onto the **Value** slot in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Planets Main Mode** component should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – The Planets Main Mode component''s Planet Prefabs dictionary
    with Mars added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – The Planets Main Mode component's Planet Prefabs dictionary with
    Mars added
  prefs: []
  type: TYPE_NORMAL
- en: If you **Build and Run** now, when in Scan-mode, point the camera at your Mars
    planet card. The Mars 3D object will be added to the scene, rotating in all its
    glory!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, after doing this, if you move the camera to scan the Earth planet
    card, nothing will happen. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to detected images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your scripts can subscribe to events so that they''re notified when an image
    is being tracked, updated, or removed. Specifically, we can implement an `OnTrackedImageChanged`
    function to handle these events. We can use this in the `PlanetsMainMode` script,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PlanetsMainMode` script for editing again and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line to your `OnEnable` function, adding a listener to `imageManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, remove the listener in `OnDisable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When `ARTrackedImageManager` detects a new image, the Main-mode script will
    kick in. It contains a listener for the events and will call `InstantiatePlanet`
    for any newly tracked images.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the app completely loses image tracking, we should go back to Scan-mode
    and display its instructional graphic, prompting the user to find a reference
    image. Add this check to `Update`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip – Tracking the State of Individual Trackables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AR Foundation also provides you with the current tracking state of each trackable
    image individually. Given a trackable image (`ARTRackedImage`), you can check
    its `trackingState` for `Tracking` – image is actively tracking, `Limited` – image
    is being tracked but not reliably, or `None` – the image is not being tracked.
    See [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html)`#tracking-state`.
    In this project, we will only go back to Scan mode when no images are being tracked,
    so we don't necessarily need this extra level of status monitoring.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'OK – this is getting pretty robust. **Build and Run** the project again, this
    time scanning either (or both) the Earth and Mars planet cards. We''ve got planets!
    The following screen capture shows the app running, with the addition of the information
    UI at the bottom of the screen, which we will add in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Earth and Mars rendered at runtime'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Earth and Mars rendered at runtime
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add the rest of the planets to your project by following these
    same steps. As we mentioned earlier in this chapter, referencing the NASA data
    provided at [https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html),
    use their *Length of Day* row for our `Planet` script already includes an animation
    speed scalar, `animationHoursPerSecond`, that you can use to modify the rotation
    rates that are visualized in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our application supports multiple planets, you might want to tell the
    user more about the specific planet that they are looking at. Let's add this capability
    to Main-mode so that it responsively updates the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Making a responsive UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll add an info panel to the bottom of the screen (as shown
    in the preceding screen capture). When you point the camera at one planet or another,
    we'll show the planet's name, as well as an **Info** button, which will cause
    a text box to appear that contains more information about that planet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Main-mode UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the app is in Main-mode, the Main UI panel is displayed. On this panel,
    we''ll show the name of the current planet and an **Info** button for the user
    to press when they want more details about that planet. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, unfold the **UI Canvas** object and unfold its
    child **Main UI** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default child text in the panel is a temporary placeholder, so we can remove
    it. *Right-click* the child **Text** object and select *Delete*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subpanel by *right-clicking* on `Info Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `175`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I set my background `255`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a text element for the planet name. *Right-click* `Planet Name Text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Planet Name Text `[Planet name]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text properties; for example, `50`; `72`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `Info Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the button properties; for example, `150, 150`; `-20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold `-50` and its text content to `Info`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* `?`, `72`, `-15`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to use this button to toggle a details panel on and off. So, let's
    replace its **Button** component with a **Toggle** instead. With the **Info Button**
    object selected in the **Hierarchy** window, in the **Inspector** window, remove
    the **Button** component using the *3-dot* context menu and selecting **Remove
    Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `toggle`, and add a **Toggle** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My main **Info Panel** now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Main UI''s Info Panel with Planet Name Text and an Info Button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Main UI's Info Panel with Planet Name Text and an Info Button
  prefs: []
  type: TYPE_NORMAL
- en: The Planet Name Text's content will be filled in at runtime. Let's add that
    code now.
  prefs: []
  type: TYPE_NORMAL
- en: Pointing the camera to show information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The plan is that with one or more virtual planets instantiated in the scene,
    the user can point the camera at a planet so that it displays the planet's name
    in the Info Panel. This can be implemented using a `Physics Raycast`. (Raycasts
    were introduced and explained in the previous chapters. See [https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)).
    Recall that at the beginning of this chapter, we put the Planet Prefab on a layer
    named `PlacedObjects`. We'll make use of that here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes to the `PlanetsMainMode` script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure the script file contains the following assembly references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of the class, declare and initialize references to the AR `camera`
    and `layerMask` variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add references to the `planetName` and `infoButton` UI elements in the
    Info Panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can initialize the UI settings when the mode is enabled. Please add the
    following lines to the `OnEnable` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following highlighted code to the `Update` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script. Back in Unity, select the **Main Mode** object in the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Planet Name Text** game object from the **Hierarchy** window (under
    **UI Canvas / Main UI / Info Panel**) into the **Planets Main Mode | Planet Name**
    slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Info Button** object onto the **Info Button** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and **Build and Run** the project one more time. While viewing one
    or more planets, as you point the device's camera at one of them, the planet's
    name will be shown in the Info Panel at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let's set up the Info Button and description display.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying information details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user is pointing their camera at a virtual 3D planet in the scene,
    we show the name of the planet in the Info Panel. When the user clicks the **Info**
    button, we want to show more information about the planet, such as its description
    text. Let''s add a text panel for that now by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Details Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has already been set to `30`, `30`, `150`, and `200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* `Details Text`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Format the text area; for example, set its `48`, its `30, 30, 30, 30`, and
    its **Alignment**: to **Center, Middle**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add control of this panel to the `PlanetsMainMode` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add references to `detailsPanel` and `detailsText` at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure the panel is hidden when the mode is enabled. Add the following line
    to the `OnEnable` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the panel''s content when a planet is being selected. That is, in
    `Update`, we must set `detailsText` at the same time we set `planetName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script. Back in Unity, we'll wire up the **Info Button** toggle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With **Info Button** selected in the **Hierarchy** window, in the **Inspector**
    window, click the **+** button at the bottom right of the **Toggle | On Value
    Changed** action list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** window, drag the **Details Panel** game object onto the
    **On Value Changed | Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** selection list, choose **GameObject | Dynamic Bool | SetActive**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when you **Build and Run** the project and view a planet, then press the
    **Info** button, the Details Panel will be displayed alongside the planet''s description
    text, as shown in the following screen capture from my phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Displaying description text about Mars in the toggled Details
    Panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B15145.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Displaying description text about Mars in the toggled Details
    Panel
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we added a responsive UI to the scene. When the user points
    their device camera at a virtual planet that's been instantiated in the scene,
    the name of the planet is displayed in the Info Panel at the bottom of the screen.
    If the user taps the **Info** button, a text panel is toggled, showing additional
    details about that specific planet.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of additional ways to improve this project?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built an AR project that lets you visualize and learn about
    planets in our Solar System. The scene uses AR image detection and tracks the
    planet cards that you printed out from the PDF file provided with the files for
    this book. Each planet card image includes a distinct marker with unique details,
    high contrast edges, and asymmetric shapes, making them readily detectable and
    trackable by the AR system. You set up the AR Session to track images using the
    AR Trackable Image Manager component and built a Reference Image Library asset
    with the planet card images.
  prefs: []
  type: TYPE_NORMAL
- en: You then created a generic Planet Prefab with a Planet script that controls
    the rotation behavior and metadata for a planet. Then, you created separate prefab
    variants for each planet. You wrote a `PlanetsMainMode` script that instantiates
    the correct planet prefab when a specific planet card image is detected. This
    allows multiple tracked images and planets to be present in the scene. Then, you
    added a responsive UI where the user can point their device camera to an instantiated
    planet and get additional information about that virtual object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll explore another kind of AR application: flipping
    the device camera so that it''s facing the user to make selfie face filters.'
  prefs: []
  type: TYPE_NORMAL
