<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-219"><a id="_idTextAnchor229"/>10</h1>
<h1 id="_idParaDest-220"><a id="_idTextAnchor230"/>Push Your Application with Performance</h1>
<p>With each new release<a id="_idIndexMarker555"/> of <strong class="bold">ASP.NET</strong>, the ASP.NET team continues to make performance a priority. When ASP.NET Core introduced a different way of building web applications with streamlined enhancements (including <strong class="bold">middleware</strong> and <strong class="bold">Razor Pages</strong>) the focus was continually on improving the C# language as well. These technologies are what give ASP.NET its spark and speed.</p>
<p>ASP.NET is cross-platform, has built-in support for dependency injection, is open source, and is one of the fastest-performing frameworks in the industry.</p>
<p>While this is an ASP.NET book with a chapter on performance, there will be additional aspects of web development that are equally as important. We’ll stay focused on ASP.NET and C# performance as much as possible.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Why Performance Matters</li>
<li>Establishing Baselines</li>
<li>Applying Performance Best Practices</li>
</ul>
<p>By the end of this chapter, you’ll understand the importance of performance in your application, how to establish client-side and server-side baselines and techniques on how to optimize the client-side resources for faster delivery, and finally, how to deliver content faster with server-side performance techniques such as optimizing HTML, implementing various caching techniques, and identifying slow queries.</p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor231"/>Technical requirements</h1>
<p>When creating baselines and testing performance for your web application, there is a need for an IDE or editor you feel comfortable with for writing code. We recommend using your favorite editor to view the GitHub repository. Our recommendations include the following:</p>
<ul>
<li><strong class="bold">Visual Studio</strong> (preferably the latest version)</li>
<li><strong class="bold">Visual </strong><strong class="bold">Studio Code</strong></li>
<li><strong class="bold">JetBrains Rider</strong></li>
</ul>
<p>The code for this chapter is located in Packt Publishing’s GitHub repository, located at <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor232"/>Why Performance Matters</h1>
<p>Performance <a id="_idIndexMarker556"/>takes many shapes and forms in web development since there are so many moving pieces to make a website always ready and available to our users. As a developer, if someone asked for help regarding a website being slow, what advice would you recommend? It’s a tough question to answer verbally without examining the website. With websites, there may be times when performance isn’t just one technology; the problem may be more than one bottleneck.</p>
<p>For instance, when loading a web page in the browser, do you see content appear, but images take a long time and paint row by row? How about accessing the database? Do you have slow queries where the server takes a minute to retrieve records? Are web APIs performing at more than two seconds for each request?</p>
<p>As you can see, performance is an analysis of an entire website including browser, server, C#, API, and database.</p>
<p>Amazon published a study calculating that if a page load slowed down by even 1 second on their website, it could cost them $1.6B in sales.</p>
<p class="callout-heading">How one second could cost Amazon $1.6 billion in sales</p>
<p class="callout">The research was<a id="_idIndexMarker557"/> reported by Fast Company and is located at <a href="https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales">https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales</a>.</p>
<p>While this is a head-turner, there is a more recent article on how Netflix replaced React with plain JavaScript (more commonly called Vanilla JavaScript). This provided huge gains in performance. In the case study, it reported one page had 300 KB of JavaScript, which is a lot. However, compared to other websites such as <a href="http://CNN.com">CNN.com</a> (4.4 MB of JavaScript) and <a href="http://USAToday.com">USAToday.com</a> (1.5 MB of JavaScript), 300 KB of JavaScript is considered minimal.</p>
<p class="callout-heading">A Netflix web performance case study</p>
<p class="callout">Google Chrome <a id="_idIndexMarker558"/>Engineering Lead <em class="italic">Addy Osmani</em> wrote an article about the performance gains Netflix experienced through optimizations. The case study can be found at <a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9</a>.</p>
<p>With these specific scenarios and case studies, many companies took notice and focused primarily on performance. Even Microsoft focused its efforts on performance by submitting its results to TechEmpower’s industry framework benchmark results. As a result of the constant<a id="_idIndexMarker559"/> improvement, ASP.NET is now ranked as one of the fastest platforms for the web.</p>
<p class="callout-heading">TechEmpower framework benchmark results</p>
<p class="callout">Every year, TechEmpower<a id="_idIndexMarker560"/> updates its results in a chart that can be found at <a href="https://techempower.com/benchmarks/">https://techempower.com/benchmarks/</a>. As of July 19, 2022, ASP.NET is ranked #9 in performance.</p>
<p>Finally, with Google as the most dominant player in the search engine industry, it attached how fast a page loads <a id="_idIndexMarker561"/>to your <strong class="bold">search engine result pages</strong> (<strong class="bold">SERPs</strong>). Translation: the speed of your site is one of the ranking factors for how high you are in the search results (which we’ll discuss in the next section).</p>
<p class="callout-heading">Google using site speed in web search ranking</p>
<p class="callout">On Google’s blog, they mentioned that page speed is another factor taken into account when ranking your website. The post is found at <a href="https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking">https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking</a>.</p>
<p>Performance is one of my favorite topics. The idea of making small changes that lead to large performance gains is definitely exciting. It also can be visually apparent as well. This chapter is meant to assist in using techniques and tools to identify those performance issues on any website.</p>
<p>The good news is, in past chapters, we’ve already mentioned specific ways to improve performance that we’ll refer back to when relevant. As I’ve said in <a href="B19493_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>, performance should be the top priority when building ASP.NET web applications, with security running a close second.</p>
<p>Performance has always been a mix between an art and a science as you’ll see in some of the sections in this chapter. There is <em class="italic">perceived</em> performance and then there’s <em class="italic">actual</em> performance.</p>
<p>Actual performance is a measurement when an activity or task immediately responds and notifies the user that it’s finished. An immediate response is a goal. Perceived performance is a subjective measurement where users experience an activity or task as quick, even when it isn’t. One example of perceived performance is when the user requests a web page and the browser renders the page immediately. The content continues to load in the background while keeping the user’s focus by allowing them to scroll through the page waiting for the additional content. As a result, users think the site is “fast” because it responded immediately. Spinners and progress bars are other ways to achieve perceived performance while something is processing.</p>
<p>While perceived performance is a way to divert a user’s attention while waiting for a process to complete, this<a id="_idIndexMarker562"/> chapter will focus more on actual performance.</p>
<p>In the next section, we’ll learn how to create baselines for client-side and server-side code using <a id="_idIndexMarker563"/>public <a id="_idIndexMarker564"/>web tools and<a id="_idIndexMarker565"/> specific server tools such as <strong class="bold">Visual Studio Performance Profiler</strong>, <strong class="bold">Benchmark.net</strong>, and <strong class="bold">Application Insights</strong>.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor233"/>Establishing Baselines</h1>
<p>So, how do you know <a id="_idIndexMarker566"/>you’re experiencing<a id="_idIndexMarker567"/> a slowdown on a website? Is it because of a recent release of a software product, or a new NuGet package installed causing the slowdown?</p>
<p>While identifying an issue, you may be asking yourself, “what changed?” But the question everyone <em class="italic">should</em> be asking is “how do you measure performance?” In order to measure it, there needs to be a baseline of what’s expected when it comes to performance.</p>
<p>Each part of your application should include performance tests. Whether it’s the frontend, a C# subsystem, a web API, or the database, the proper systems should be in place to notify the team when a system isn’t performing as expected.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor234"/>Using Client-Side Tools</h2>
<p>Issues on the client side are <a id="_idIndexMarker568"/>mostly due to load times, delivery of <a id="_idIndexMarker569"/>resources not found (such as HTML pages, images, CSS, and JavaScript), or JavaScript errors in general. However, this doesn’t mean the entire problem is on the client.</p>
<p>Creating a baseline for your client-side code should be conducted through a testing tool such as <strong class="bold">Cypress</strong> or <strong class="bold">Selenium</strong> during development and recording the duration of tests. Compare <a id="_idIndexMarker570"/>the latest<a id="_idIndexMarker571"/> scenarios with previous test results to see where there is a time difference.</p>
<p>Another approach for determining a baseline is to use various tools on the web such as the tools listed in this section. Think of these tools as like taking your car to the mechanic for maintenance. These tools scan your public website, analyze all aspects of the site, and provide a report on how to fix each issue found.</p>
<p>Some of the tools to give you insights into the performance of a website include the following:</p>
<ul>
<li><strong class="bold">Google P<a id="_idTextAnchor235"/>ageSpeed Insights</strong> (<a href="https://pagespeed.web.dev">https://pagespeed.web.dev</a>): Google uses its search <a id="_idIndexMarker572"/>engine to rank your site and provides an exceptional tool to help with website problems.</li>
<li><strong class="bold">Lighthouse</strong> (<a href="https://developer.chrome.com/docs/lighthouse/">https://developer.chrome.com/docs/lighthouse/</a>): If your site isn’t <a id="_idIndexMarker573"/>publicly accessible to analyze from one of these tools, you can use the Lighthouse extension to run tests on the site in-house. Lighthouse produces a full report of recommendations on how to make your site perform <a id="_idIndexMarker574"/>better.</li>
<li><strong class="bold">GTMetrix</strong> (<a href="https://gtmetrix.com">https://gtmetrix.com</a>): GTMetrix is<a id="_idIndexMarker575"/> a tool I’ve been using over the years and it continues to impress and improve each year. It provides a performance summary, speed visualization, and recommendations.</li>
<li><strong class="bold">Google Search Console</strong> (<a href="https://search.google.com/search-console">https://search.google.com/search-console</a>): Google<a id="_idIndexMarker576"/> created this for administrators of websites to identify performance issues along with other general maintenance tools, such as what people are typing into Google to find your website.</li>
<li><strong class="bold">DevTools</strong>: DevTools is a<a id="_idIndexMarker577"/> panel of web developer tools located inside of Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Edge to help web developers analyze web pages, and it’s becoming the IDE of the internet. Pressing F12 in the browser will open the panel.</li>
</ul>
<p>These tools are great for gauging how well your site performs on the internet and how it performs based on the last revision. If your last release takes 0.5 seconds to load and the latest <a id="_idIndexMarker578"/>release <a id="_idIndexMarker579"/>now takes three seconds, it’s time to examine what changed. What better way to check this than to automate the process (refer to <a href="B19493_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>) by reporting on the performance issue before deploying the site?</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor236"/>Using Server-Side Tools</h2>
<p>With ASP.NET, creating<a id="_idIndexMarker580"/> baselines for your code is just as easy<a id="_idIndexMarker581"/> with a number of tools at your disposal.</p>
<p>In this section, we’ll review some of the tools available for creating a baseline for your code such as Visual Studio, Benchmark.net, Application Insights, and other tools such as NDepend.</p>
<h3>Visual Studio Performance Tools</h3>
<p>With Visual<a id="_idIndexMarker582"/> Studio being a solid IDE in<a id="_idIndexMarker583"/> the industry, the ability to gauge C# performance was becoming more prevalent because if code was slow, developers wanted a way to locate the bottleneck.</p>
<div><div><img alt="Figure 10.1 – Performance Profiler in Visual Studio 2022" src="img/B19493_10_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Performance Profiler in Visual Studio 2022</p>
<p>When starting <strong class="bold">Performance Profiler</strong>, you’re presented with a list of options:</p>
<div><div><img alt="Figure 10.2 – List of available options before running Performance Profiler" src="img/B19493_10_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – List of available options before running Performance Profiler</p>
<p>As you can see, there are a vast number of options crossing multiple touchpoints. For example, there is a <strong class="bold">Database</strong> option to look at how your queries are performing in the application.</p>
<p>The metrics for databases are<a id="_idIndexMarker584"/> similar to the <strong class="bold">Entity Framework</strong> details explaining the duration it took to execute the query. Another option is identifying where async/await problems can <a id="_idIndexMarker585"/>occur as well as memory usage <a id="_idIndexMarker586"/>and object allocation.</p>
<h3>Benchmark.net</h3>
<p>If there are<a id="_idIndexMarker587"/> smaller, self-contained methods required to test, one<a id="_idIndexMarker588"/> of the best tools around for micro-benchmarking is Benchmark.net (<a href="https://benchmarkdotnet.org/">https://benchmarkdotnet.org/</a>).</p>
<p>Benchmark.net takes specific methods and tests them with different scenarios. The one caveat to this is that the Benchmark project <em class="italic">must</em> be a console application.</p>
<p>As an example, if we wanted to test the age-old debate as to which is faster between string concatenation or a <code>StringBuilder</code> class, we would write two benchmark tests to determine which was faster, as shown in the following:</p>
<pre class="source-code">
public class Benchmarks
{
    [Benchmark(Baseline = true)]
    public void StringConcatenationScenario()
    {
        var input = string.Empty;
        for (int i = 0; i &lt; 10000; i++)
        {
            input += «a»;
        }
    }
    [Benchmark]
    public void StringBuilderScenario()
    {
        var input = new StringBuilder();
        for (int i = 0; i &lt; 10000; i++)
        {
            input.Append(«a»);
        }
    }
}</pre> <p>In the preceding code, we created a string in one scenario and an instance of a <code>StringBuilder()</code> class in another. To accomplish the same goal, we add 10,000 ‘a’s and start the benchmark.</p>
<p>Based on the results in <em class="italic">Figure 10</em><em class="italic">.3</em>, the obvious choice is to use <code>StringBuilder()</code> for performing large string concatenations:</p>
<div><div><img alt="Figure 10.3 – Comparing the performance of a string concatenation versus a StringBuilder() class" src="img/B19493_10_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Comparing the performance of a string concatenation versus a StringBuilder() class</p>
<p>In regards to creating a baseline, we added an additional parameter to our <code>[Benchmark]</code> attribute in our first scenario, called <code>Baseline</code>, and set it to <code>true</code>. This tells Benchmark.net to use this as our baseline when measuring the performance of our other methods. You can have any number of methods to achieve the same result, but <a id="_idIndexMarker589"/>everything <a id="_idIndexMarker590"/>will be compared to the one method with <code>Baseline=true</code> in the Benchmark attribute.</p>
<p>For small, compact methods, Benchmark.net is definitely a great tool for providing insight into ways to create faster code using micro-optimizations.</p>
<h3>Application Insights</h3>
<p>Microsoft’s Application<a id="_idIndexMarker591"/> Insights is meant to be a general-purpose<a id="_idIndexMarker592"/> analysis tool for collecting telemetry about everything your application does. Once set up, Application Insights can collect data about the following:</p>
<ul>
<li>Requests – web pages and API calls</li>
<li>Dependencies – what is your application loading behind the scenes?</li>
<li>Exceptions – every exception your application throws</li>
<li>Performance counters – automatically identifying slowdowns</li>
<li>Heartbeats – is the application still up and running?</li>
<li>Logs – a centralized location for collecting all types of logs for your application</li>
</ul>
<p>When adding<a id="_idIndexMarker593"/> Application Insights, Application<a id="_idIndexMarker594"/> Insights <em class="italic">does</em> require an Azure subscription.</p>
<p class="callout-heading">Application Insights additional material</p>
<p class="callout">There are various ways to set up Application Insights and way too many to cover in this chapter. For more information on Application Insights and how to set it up for your application, navigate to <a href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core">https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core</a>.</p>
<p>Some other recommendations for creating baselines and identifying bottlenecks include the following:</p>
<ul>
<li><strong class="bold">JetBrains dotTrace/dotMemory</strong> – dotTrace is a performance profiler tool, and dotMemory is a memory profiler tool. Both are exceptional tools and perform deep dives into how well your application performs. dotTrace and dotMemory give you the ability to compare a baseline of results against another set of results (“comparing snapshots”).</li>
<li><strong class="bold">RedGate ANTS Performance Profiler/Memory Profiler</strong> – With the ability to profile .NET code and memory allocations, the ANTS Performance and Memory Profiler demonstrates a similar approach to performance and memory profiling while conducting a deep-dive analysis while your code is running.</li>
<li><code>if..else</code> or switches). These can be user-defined as well to meet your code quality requirements <a id="_idIndexMarker595"/>using <strong class="bold">Code Query for LINQ</strong> (<strong class="bold">CQLinq</strong>). NDepend also has capabilities to integrate into your CI/CD pipeline to automate the process.</li>
<li><strong class="bold">Build-it-yourself metrics</strong> – Back in <a href="B19493_07.xhtml#_idTextAnchor163"><em class="italic">Chapter 7</em></a>, we explained how to “identify slow integration tests.” Using the diagnostic Stopwatch on your unit, integration, and APIs, you can perform and report on these metrics even before sending out a release.</li>
</ul>
<p>When these tools examine your application, they perform analysis on how to optimize your code by<a id="_idIndexMarker596"/> finding hotspots. If the hotspot is called<a id="_idIndexMarker597"/> enough times, your application’s performance will suffer. The path to get to this hotspot is<a id="_idIndexMarker598"/> called the <strong class="bold">hot path</strong>.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor237"/>Databases</h2>
<p>While you can <a id="_idIndexMarker599"/>create a baseline with databases, most optimizations are done at the database level by analyzing stored procedures, index management, and schema definitions. Each database type has its own performance tools for finding bottlenecks. For now, we’ll focus<a id="_idIndexMarker600"/> specifically on <strong class="bold">SQL </strong><strong class="bold">Server</strong> tools.</p>
<h3>SQL Server Management Studio (SSMS) Profiler</h3>
<p>With <strong class="bold">SSMS</strong> using a <a id="_idIndexMarker601"/>profiler <a id="_idIndexMarker602"/>interface, developers have the ability to identify whether a particular ad-hoc query, stored procedure, or table isn’t performing as expected.</p>
<p>SQL Server Profiler is located under the <strong class="bold">Tools</strong> option as the first menu item, as shown in <em class="italic">Figure 10</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 10.4 – SQL Server Profiler in SSMS" src="img/B19493_10_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – SQL Server Profiler in SSMS</p>
<p>On running SQL Server profiler, every request sent to the database is logged along with how long it<a id="_idIndexMarker603"/> took, how many<a id="_idIndexMarker604"/> reads and writes are necessary, and the results returned.</p>
<h3>Query Store</h3>
<p>One of the latest<a id="_idIndexMarker605"/> features of SQL Server 2016 is the <strong class="bold">Query Store</strong>. The Query <a id="_idIndexMarker606"/>Store provides you with insight into how to improve performance on SQL Server.</p>
<p>Once enabled (right-click on database | <strong class="bold">Properties</strong> | <strong class="bold">Query Store</strong> | <strong class="bold">Operation Mode: On</strong>), it’ll begin analyzing your SQL Server workload when actively being used and make recommendations on how to improve performance.</p>
<p>Once the data is collected, the metrics are available using stored procedures to identify slow-performing queries.</p>
<p class="callout-heading">Query Store additional material</p>
<p class="callout">For additional material on Microsoft’s Query Store, navigate to <a href="https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store">https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store</a>. For performance tuning using Query Store, navigate to <a href="https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store">https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store</a>.</p>
<p>In this section, we covered why establishing baselines is important while listing various client-side tools such as Google Page Speed Insights, Lighthouse, GTMetrix, Google Search Console, and Chrome DevTools for gauging performance. We also looked at server-side tools such as Visual Studio Performance Profiler, Benchmark.net, Application Insights, JetBrains dotMemory and dotTrace, RedGate ANTS Performance Profiler/Memory Profiler, and NDepend for identifying issues with codebases. With databases, we mentioned two tools to identify performance bottlenecks: SQL Server Management Studio Profiler and Query Store. We also mentioned hotspots, or hot paths, where<a id="_idIndexMarker607"/> frequently called, unoptimized code could cause <a id="_idIndexMarker608"/>performance issues in your application.</p>
<p>The next section will cover the best practices for some client-side and server-side techniques, but will mostly focus on server-side optimizations using C#.</p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor238"/>Applying Performance Best Practices</h1>
<p>As mentioned at the beginning of this chapter, the content in this chapter applies to client <em class="italic">and</em> server<a id="_idIndexMarker609"/> techniques to get the most out of your ASP.NET websites.</p>
<p>In this section, we’ll first focus on optimizing the client by applying image optimization, minimizing your requests, using CDNs, and other tips to improve client-side performance. Then we’ll focus on server-side techniques such as optimizing your HTML, caching, and <strong class="bold">Entity Framework Core</strong> performance <a id="_idIndexMarker610"/>techniques along with identifying slow queries.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor239"/>Optimizing client-side performance</h2>
<p>In this section, we’ll learn <a id="_idIndexMarker611"/>about image optimizations, identifying<a id="_idIndexMarker612"/> Google’s <strong class="bold">Core Web Vitals</strong> metrics, using a CDN when applicable, how to minimize requests, and where to place scripts and styles.</p>
<h3>Fixing Image Optimization</h3>
<p>According <a id="_idIndexMarker613"/>to the Web Almanac (<a href="https://almanac.httparchive.org/en/2022/media#bytesizes">https://almanac.httparchive.org/en/2022/media#bytesizes</a>), image optimization is <a id="_idIndexMarker614"/>one of <a id="_idIndexMarker615"/>the worst problems on the web. The number of devices required to support it doesn’t make this any easier. Let’s see how we can optimize this experience.</p>
<p>Here’s the basic usage of an <code>&lt;</code><code>img&gt;</code> tag:</p>
<pre class="source-code">
&lt;img width="100" height="100"
     src="img/logo.jpg"
     alt="Buck's Coffee Shop Logo"</pre> <p>However, for responsive layouts, the <code>&lt;img&gt;</code> tag has an <code>srcset</code> attribute:</p>
<pre class="source-code">
&lt;img src="img/logo-400.jpg" 
alt="Buck›s Coffee Shop Logo" 
width="100"
height="100" 
loading="lazy"
srcset="logo-400.jpg 400w, 
logo-800.jpg 800w, 
logo-1024.jpg 1024w"
sizes="(max-width: 640px) 400px, 800px, 1024px"&gt;</pre> <p>The preceding code identifies the size of the viewport (the web page) and loads the appropriate image. The <code>max-width</code> media condition says that if the viewport is 640px, use the 400px image. If the max-width is over 640px and less than 800px, use the 800px image.</p>
<p>This allows you to support a number of different responsive layouts. Once you define the layout for your site, images should complement the layout size as well. What does this mean? For every image, you should have an image created for each responsive layout. For example, the preceding default image logo should have three images: <code>logo-400.jpg</code>, <code>logo-800.jpg</code>, and <code>logo-1024.jpg</code>.</p>
<p>Also, the <code>loading="lazy"</code> tells the browser to defer loading the images until the browser can determine the size of the viewport to display the proper image.</p>
<p>Finally, images can become extremely large and can contain encoded data such as GPS data when a picture is taken. Compressing an image is the process of removing the extra data, making the image smaller and quicker to load in a browser. This is a server-side task and can be included as a task in your client-side task runner (previously discussed in <a href="B19493_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>).</p>
<p>The minimum steps for image optimization should look like the following:</p>
<ol>
<li><strong class="bold">Determine the site’s responsive layouts</strong> – Identify the sizes you need for your images (400px, 800px, etc.)</li>
<li><strong class="bold">Create the images based on the layouts</strong> – There should be a resized image for each layout size.</li>
<li><strong class="bold">Optimize the images</strong> – For each image on your site, compress the images so they are smaller and load faster by removing the extra data attached to each image. Use image services such as Optimazilla (<a href="https://imagecompressor.com/">https://imagecompressor.com/</a>) or TinyPNG (<a href="https://tinypng.com/">https://tinypng.com/</a>).</li>
<li> <code>srcset</code> and <code>sizes</code> attributes so the browser can determine the best image to display based on the viewport size.</li>
</ol>
<p>Image<a id="_idIndexMarker616"/> optimization <a id="_idIndexMarker617"/>is too big a topic for a small chapter, but this quick overview should be enough to provide a better experience for website users.</p>
<h3>Minimizing requests</h3>
<p>Most of the aforementioned <a id="_idIndexMarker618"/>client-side tools for creating baselines can be used to identify where multiple requests are made for resources. On average, websites have 58 requests for JavaScript and CSS (that’s <em class="italic">not</em> counting images). Each request causes latency and depending on the resource, it’ll take longer than a user is willing to wait.</p>
<p>We’ve already learned how to use a better approach when structuring your JavaScript and CSS back in <a href="B19493_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>, eliminating a large number of requests for your JavaScript and CSS files.</p>
<p>Finally, if there’s a large number of consistent-sized images and you’re calling each one separately, a better approach would be to create one large image (sprite sheet) containing all of the images and use CSS to display them. Instead of your browser requesting 15 social network logos, make one call to an image and split them out using CSS, as shown in <em class="italic">Figure 10</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 10.5 – Sprite sheet of 32x32 social network icons" src="img/B19493_10_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Sprite sheet of 32x32 social network icons</p>
<p>To use this sprite sheet, the CSS would look like the following:</p>
<pre class="source-code">
.bg-YouTube_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -1px -1px;
}
.bg-facebook_32x32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -35px -1px;
}
.bg-github_32x32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -1px -35px;
}
.bg-Instagram_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -35px -35px;
}
.bg-LinkedIn_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -69px -1px;
}
.bg-quora_32x32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -69px -35px;
}
.bg-RSS_32x32 {
    width: 32px; height: 3<a id="_idTextAnchor240"/>2px;
    background: url('css_sprites.png') -1px -69px;
}
.bg-Twitter_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -35px -69px;
}</pre> <p>The background identifies <a id="_idIndexMarker619"/>which image to use as a background by using the offset top and left positions. To display the RSS icon in HTML, it would be presented as the following:</p>
<pre class="source-code">
&lt;div class="bg-RSS_32x32"&gt;&lt;/div&gt;</pre> <p>Such services to create sprites include CodeShack’s Images to Sprite Sheet Generator (<a href="https://codeshack.io/images-sprite-sheet-generator/">https://codeshack.io/images-sprite-sheet-generator/</a>) and <a id="_idIndexMarker620"/>Toptal’s CSS Sprites Generator (<a href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a>).</p>
<h3>Using CDNs</h3>
<p>If a site uses a<a id="_idIndexMarker621"/> large number of static files, using a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>) provides a<a id="_idIndexMarker622"/> much-needed service of delivering content based on location. These geographically based servers cache files so they’re delivered quicker based on where a user is located.</p>
<p>For example, if someone in California requests a file from Nevada, it’s quicker than someone requesting the file from England. The closer the content, the quicker the user receives it.</p>
<h3>Final thoughts on client-side performance</h3>
<p>While there are a ton<a id="_idIndexMarker623"/> of client-side tips we could cover, let’s close this section out with some final thoughts on making the client quicker:</p>
<ul>
<li><strong class="bold">Scripts at the bottom, styles at the top</strong> – Avoid placing scripts in the header, but absolutely place the styles in the header. Placing scripts at the bottom confirms <a id="_idIndexMarker624"/>the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) is completely loaded and, if immediately executed, JavaScript is able to find the DOM elements because they’ve already been rendered.</li>
<li><strong class="bold">Apply Google’s Core Web Vitals to your site</strong> – If you’re using either Lighthouse or Google’s Page Speed Insights, you’ll notice the following acronyms for identifying your site’s performance: FCP (First Contentful Paint), LCP (Largest Contentful Paint), CLS (Cumulative Layout Shift), and FID (First Input Delay). Review these terms at <a href="https://web.dev/vitals">https://web.dev/vitals</a> to provide a better web experience for your users.</li>
<li><code>&lt;details&gt;</code>/<code>&lt;summary&gt;</code> HTML tags may be enough. Also, browsers are becoming even more modern and evolved with new tags such as the <code>&lt;dialog&gt;</code> tag where JavaScript isn’t necessary. Refer to <a href="https://caniuse.com/">https://caniuse.com/</a> for browser support.</li>
</ul>
<p>In this section, you learned how to optimize the client side by optimizing your images, along with how CDNs improve the loading of your static content and how to minimize your requests to lower latency issues. For our final notes, we examined some tips such as placing scripts at the bottom and styles at the top, applying Google’s Core Web Vitals to websites, providing sites that are responsive regardless of device, and using HTML instead of <a id="_idIndexMarker625"/>JavaScript where it makes sense.</p>
<p>In the next section, we’ll shift our focus from the client to the server side and look at some of the common practices when optimizing C# and Entity Framework Core.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor241"/>Common Server-side Practices</h2>
<p>With C# being such a <a id="_idIndexMarker626"/>robust language, there are so many ways to create a web application. As you saw in <a href="B19493_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a> with Entity Framework Core, each design pattern fit a certain need but worked the same regardless of the pattern. The good news with these performance techniques is they apply to web standards and design patterns already used in the industry. One such example is ETags. At one point, they were considered a separate web concept requiring specific code. Now, when using static files, these ETags are integrated into websites without any additional coding. They’re considered a web standard with browsers.</p>
<p>What we’re going to address in this section is how to improve performance by adding these web standards and design patterns to our own web application to make it even faster.</p>
<p>In this section, we’ll learn about the various performance enhancements we can apply to your code using C#, including quick performance gains you can apply immediately to your own website, and we’ll learn how to add a middleware component to optimize your HTML, improve Entity Framework Core performance with only four letters, and identify slow Entity Framework Core queries.</p>
<h3>Applying quick performance wins</h3>
<p>While some of these<a id="_idIndexMarker627"/> quick hits are <a id="_idIndexMarker628"/>well-known (and some have been covered in previous chapters), it doesn’t hurt to review them to get the most performance out of your website:</p>
<ul>
<li><strong class="bold">Turn Debug Off</strong> – When you run your application with debug mode, additional information is compiled into each assembly for debugging purposes. When changed to release mode, you are getting an optimized version of your assemblies for deployment.</li>
<li><strong class="bold">Use async/await</strong> – As mentioned in previous chapters, using async/await provides performance benefits and should be used for tasks involving file I/O, database, and API calls.</li>
<li><strong class="bold">Use the database</strong> – When using Entity Framework Core, try to assess the goal and evaluate the best approach: whether it’s an Entity Framework Core simple data access method or whether a stored procedure would provide faster performance.</li>
<li><code>ChangeState</code> management such as updating an entity, use <code>.AsNoTracking()</code> to reduce the Entity Framework overhead.</li>
</ul>
<p>While these are some tips to give a web application a quick lift in performance, we’re now ready to dive into more involved code-based techniques.</p>
<h3>Optimizing the HTML</h3>
<p>Since we learned about <a id="_idIndexMarker629"/>optimizing images (in the last section) and<a id="_idIndexMarker630"/> optimizing JavaScript and CSS (in <a href="B19493_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>), we now need to focus on the <em class="italic">other</em> client-side resource: HTML.</p>
<p>When you “view source” in the browser, you’d like to see this beautifully formatted document that everyone can understand. But when the browser receives this document, it doesn’t care how big it is or even how “pretty” it is. The browser simply parses and renders the HTML as it comes in.</p>
<p>Have you noticed how much space is wasted in this document for the sake of formatting? For example, let’s load the “Buck’s Coffee Shop” web page.</p>
<p>In the <strong class="bold">Network</strong> tab in Chrome DevTools, we see it’s 4.1 KB:</p>
<div><div><img alt="Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)" src="img/B19493_10_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)</p>
<p>Since the browser doesn’t care, wouldn’t it be better if we could reduce the size of the HTML?</p>
<p>Middleware can assist with this. If we use our standard middleware template from <a href="B19493_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, we<a id="_idIndexMarker631"/> can <a id="_idIndexMarker632"/>create an <code>HtmlShrink</code> component:</p>
<pre class="source-code">
public class HtmlShrinkMiddleware
{
    private readonly RequestDelegate _next;
    public HtmlShrinkMiddleware(RequestDelegate next) =&gt; _next = next;
    public async Task InvokeAsync(HttpContext context)
    {
        using var buffer = new MemoryStream();
        <strong class="bold">// Replace the context response with our buffer</strong>
        var stream = context.Response.Body;
        context.Response.Body = buffer;
        <strong class="bold">// Invoke the rest of the pipeline</strong>
        <strong class="bold">// if there are any other middleware components</strong>
        await _next(context);
        <strong class="bold">// Reset and read out the contents</strong>
        buffer.Seek(0, SeekOrigin.Begin);
        <strong class="bold">// Adjust the response stream to remove whitespace.</strong>
        var compressedHtmlStream = new HtmlShrinkStream(stream);
        <strong class="bold">// Reset the stream again</strong>
        buffer.Seek(0, SeekOrigin.Begin);
        <strong class="bold">// Copy our content to the original stream and put it back</strong>
        await buffer.CopyToAsync(compressedHtmlStream);
        context.Response.Body = compressedHtmlStream;
    }
}
public static class HtmlShrinkMiddlewareExtensions
{
    public static IApplicationBuilder UseHtmlShrink(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;HtmlShrinkMiddleware&gt;();
    }
}</pre> <p>The preceding code contains our familiar middleware scaffolding. Our <code>HtmlShrinkMiddleware</code> component now instantiates an <code>HtmlShrinkStream</code> class to perform our compression, removing any whitespace in the HTML. Also, we created the standard extension at the bottom of the code.</p>
<p>Our <code>HtmlShrinkStream</code> class is <a id="_idIndexMarker633"/>shown<a id="_idIndexMarker634"/> in the following:</p>
<pre class="source-code">
public class HtmlShrinkStream: Stream
{
    private readonly Stream _responseStream;
    public HtmlShrinkStream(Stream responseStream)
    {
        ArgumentNullException.ThrowIfNull(responseStream);
        _responseStream = responseStream;
    }
    public override bool CanRead =&gt; _responseStream.CanRead;
    public override bool CanSeek =&gt; _responseStream.CanSeek;
    public override bool CanWrite =&gt; _responseStream.CanWrite;
    public override long Length =&gt; _responseStream.Length;
    public override long Position
    {
        get =&gt; _responseStream.Position;
        set =&gt; _responseStream.Position = value;
    }
    public override void Flush() =&gt; _responseStream.Flush();
    public override int Read(byte[] buffer, int offset, int count) =&gt;
        _responseStream.Read(buffer, offset, count);
    public override long Seek(long offset, SeekOrigin origin) =&gt;
        _responseStream.Seek(offset, origin);
    public override void SetLength(long value) =&gt;
        _responseStream.SetLength(value);
    public override void Write(byte[] buffer, int offset, int count)
    {
        var html = Encoding.UTF8.GetString(buffer, offset, count);
         var removeSpaces = new Regex(@"(?&lt;=\s)\s+(?![^&lt;&gt;]*&lt;/pre&gt;)", RegexOptions.Multiline);
        html = removeSpaces.Replace(html, string.Empty);
var removeCrLf = new Regex(@"(\r\n|\r|\n)", RegexOptions.Multiline);
html = removeCrLf.Replace(html, string.Empty);
        buffer = Encoding.UTF8.GetBytes(html);
        _responseStream.WriteAsync(buffer, 0, buffer.Length);
    }
}</pre> <p>In<a id="_idIndexMarker635"/> our <code>HtmlShrinkStream</code> class, our efforts <a id="_idIndexMarker636"/>are concentrated on the <code>Write()</code> method. We look at the buffer received, turn it into an HTML string, replace all whitespace by using a RegEx, and finally, write the <code>buffer</code> to the <code>responseStream</code>.</p>
<p>We can now add our <code>HtmlShrink</code> middleware extension to our pipeline by adding the following line to our <code>Program.cs</code> file:</p>
<pre class="source-code">
app.UseHtmlShrink();</pre> <p>Once added, any HTML received in the browser will be stripped of any whitespace. If we look at Buck’s Coffee Shop home page, we can see everything works, but if we view the source, we can see everything is a little more compact:</p>
<div><div><img alt="Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page" src="img/B19493_10_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page</p>
<p>It may not look<a id="_idIndexMarker637"/> pretty, but if we look at the <strong class="bold">Network</strong> tab in<a id="_idIndexMarker638"/> Chrome DevTools, we can see a difference in what was sent to the browser:</p>
<div><div><img alt="Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)" src="img/B19493_10_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)</p>
<p>That’s almost 20% smaller than the original size.</p>
<h3>Enabling DbContext pooling</h3>
<p>Connection<a id="_idIndexMarker639"/> pooling <a id="_idIndexMarker640"/>is the ability to reuse a connection for multiple users. By default, database connections already use connection pooling through a <code>SqlConnection</code>. This concept was applied to Entity Framework Core’s <code>DbContext</code>.</p>
<p>If a web application uses Entity Framework Core heavily, you want the best performance available. All it takes is to update your middleware <code>DbContext</code> connection.</p>
<p>For example, I might have the following line in my middleware:</p>
<pre class="source-code">
services.AddDbContext&lt;MyDbContext&gt;(options =&gt;
    options.UseSqlServer(connectionString));</pre> <p>We can immediately improve our performance by adding four letters to this line:</p>
<pre class="source-code">
services.AddDbContextPool&lt;MyDbContext&gt;(options =&gt;
    options.UseSqlServer(connectionString));</pre> <p>Using the <code>AddDbContextPool&lt;&gt;()</code> method contains the same syntax, but after a <code>DbContext</code> is done, it will reset its state and store it for later when a new instance of the <code>DbContext</code> is required. We are recycling our <code>DbContext</code>s!</p>
<p>Depending on how large your <code>DbContext</code> is, every time a new instance is created, the creation of the DbContext takes time. Using the <code>.AddDbContextPool&lt;&gt;()</code> method gives us the <a id="_idIndexMarker641"/>performance<a id="_idIndexMarker642"/> boost we need.</p>
<p class="callout-heading">Entity Framework Core DbContext pooling benchmarks</p>
<p class="callout">Microsoft performed benchmarks with and without DbContext pooling. With DbContext pooling implemented, the performance increased by over 50%. Microsoft even included the source code to the benchmark code. The results can be found at <a href="https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks">https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks</a>.</p>
<h3>Identifying slow queries</h3>
<p>The ability to identify <a id="_idIndexMarker643"/>slow queries is sometimes difficult, since we are in Visual Studio and may not see what’s happening behind the scenes when sending a query to the database. So, how do we find these slow queries in our web application?</p>
<p>In the DbContext’s <code>OnConfiguring()</code> method, add a <code>.LogTo()</code> method to your <code>DbContextOptionsBuilder</code> and you’ll see every database call and the time it took to execute it:</p>
<pre class="source-code">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    if (!optionsBuilder.IsConfigured)
    {
        var connString = _configuration.GetConnectionString(«DefaultConnection»);
        if (!string.IsNullOrEmpty(connString))
        {
            optionsBuilder.UseSqlServer(connString)
                .LogTo(Console.WriteLine, LogLevel.Information);
        }
    }
}</pre> <p>The <code>.LogTo()</code> method <a id="_idIndexMarker644"/>will produce the following log entry:</p>
<pre class="source-code">
Microsoft.EntityFrameworkCore.Database.Command: Information: Executed DbCommand (46ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
SELECT [a].[ID], [a].[LocationID], [a].[Name], [l].[ID], [l].[Name]
FROM [Attractions] AS [a]
INNER JOIN [Locations] AS [l] ON [a].[LocationID] = [l].[ID]</pre> <p>For this particular query, it took <em class="italic">46ms</em> to execute. The <code>.LogTo()</code> method provides an easy way to identify whether a query is performing to the best of its ability or is a likely candidate for optimization.</p>
<p>In this section, we learned some bite-sized optimizations along with a new middleware to shrink your HTML, how to speed up Entity Framework Core using DbContext pooling, and how to locate slow queries throughout your application.</p>
<p>In the next<a id="_idIndexMarker645"/> section, we’ll focus on the various types of caching and how each one is different and can work collectively to improve the overall performance of your application.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor242"/>Understanding caching</h2>
<p>Since caching is extremely <a id="_idIndexMarker646"/>important to a web application, it’s only fitting it gets its own <a id="_idIndexMarker647"/>section to cover all of the possible types of caching available. In the industry, there’s a saying: “the best database call is no call at all.” They’re likely referring to caching.</p>
<p>In this section, we’ll learn the different types of caching that include response and output caching, data caching, and caching static files.</p>
<h3>Using response caching and output caching</h3>
<p>Whether <a id="_idIndexMarker648"/>making a <a id="_idIndexMarker649"/>call to a web page or an API, the ability to cache data is extremely important. Implementing a simple caching strategy to immediately return data is efficient.</p>
<p><code>ResponseCaching</code> is a middleware extension that is best suited for GET or HEAD API requests from a client. When utilizing response caching, .NET uses the standard HTTP caching semantics.</p>
<p class="callout-heading">RFC 9111: HTTP caching</p>
<p class="callout">For additional <a id="_idIndexMarker650"/>material on HTTP caching, navigate to <a href="https://www.rfc-editor.org/rfc/rfc9111">https://www.rfc-editor.org/rfc/rfc9111</a>.</p>
<p>To add response caching, the builder must add it to the services and the application (app) must “use” it, as shown in the following:</p>
<pre class="source-code">
Var builder = WebApplication.CreateBuilder(args);
builder.Services.AddResponseCaching();
var app = builder.Build();
app.UseHttpsRedirection();
<strong class="bold">// If using Cors, UseCors must be placed before the UseResponseCaching</strong>
<strong class="bold">// app.UseCors();</strong>
app.UseResponseCaching();</pre> <p>Once in place, any<a id="_idIndexMarker651"/> API<a id="_idIndexMarker652"/> call would provide the cached data from the browser by default.</p>
<p class="callout-heading">ResponseCaching middleware</p>
<p class="callout">For more <a id="_idIndexMarker653"/>details on <code>ResponseCaching</code>, navigate to <a href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware">https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware</a>.</p>
<p>However, for most web UIs such as Razor Pages, <code>OutputCaching</code> is the better option because browsers set request headers to prevent caching. <code>OutputCaching</code>’s configuration is similar to <code>ResponseCaching</code>, as shown in the following:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddOutputCache();
<strong class="bold">// Add services to the container.</strong>
builder.Services.AddRazorPages();
var app = builder.Build();
<strong class="bold">// Configure the HTTP request pipeline.</strong>
If (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    App.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
<strong class="bold">// if using Cors, UseOutputCache must be placed AFTER useCors().</strong>
<strong class="bold">//app.UseCors();</strong>
app.UseOutputCache();</pre> <p>In the<a id="_idIndexMarker654"/> middleware <a id="_idIndexMarker655"/>configuration, we add the <code>AddOutputCache()</code> method to the services collection and place the <code>UseOutputCache()</code> method after the <code>UseRouting()</code> method and, if it’s used, after the <code>UseCors()</code> method.</p>
<p>When the <code>OutputCache</code> is added to the middleware, this doesn’t mean we are automatically caching our UI pages. We also need to identify which pages are cached by adding an <code>[OutputCache]</code> attribute to the Razor Page class:</p>
<pre class="source-code">
[OutputCache]
public class IndexModel : PageModel
{
    private readonly ILogger&lt;IndexModel&gt; _logger;
    public IndexModel(ILogger&lt;IndexModel&gt; logger)
    {
        _logger = logger;
    }
    public void OnGet() { }
}</pre> <p>If no parameters are defined in the attribute, the default policy for caching pages is as follows:</p>
<ul>
<li>HTTP 200 status codes are cached</li>
<li>HTTP GET or HEAD requests are cached</li>
<li>Responses where cookies are set are <em class="italic">not</em> cached</li>
<li>Responses to authenticated requests are <em class="italic">not</em> cached</li>
</ul>
<p>Response caching is meant for caching on the client side or through the browser and output caching is cached on the server. If two users access the same page from two different browsers, response caching won’t help since each browser will cache the page in each browser. However, if <a id="_idIndexMarker656"/>output caching was <a id="_idIndexMarker657"/>implemented, this would cache the page on the server and quickly deliver the page to both users.</p>
<p>Caching your pages gives users a better experience when coupled with data caching, which we’ll discuss next.</p>
<h3>Implementing data caching</h3>
<p>When a user visits a <a id="_idIndexMarker658"/>website, they are shown a certain amount of data based on who they are. For example, when the first user visits a blog, they could be presented with the same data as the next visitor to the site. If the data doesn’t change that often, it doesn’t make sense to travel all the way back to the database to retrieve the same data again. Data caching helps us solve this problem. Data caching is taking commonly used data and storing it for a period of time.</p>
<p>Let’s look at an example to show the approach. Since we’re using Entity Framework Core, we’ll have an existing service (<code>CoffeeService</code>) containing a simple <code>.GetAll()</code> method returning all of the coffees. We can wrap a new caching class around the service called <code>CacheCoffeeService</code>, as shown in the following:</p>
<pre class="source-code">
public class CacheCoffeeService : CoffeeService, ICachedCoffeeService
{
    private const string keyCoffeeList = «EntireCoffeeList»;
    private readonly IMemoryCache _cache;
    public CacheCoffeeService(IBucksDbContext dbContext,
        IMemoryCache cache)
        : base(dbContext)
    {
        _cache = cache;
    }
    public List&lt;Coffee&gt; GetAll(bool reload = false)
    {
        <strong class="bold">// If we can't find it in the cache or want to reload...</strong>
        if (!_cache.TryGetValue(keyCoffeeList, out List&lt;Coffee&gt;         coffees) || reload)
        {
            coffees = base.GetAll();
            _cache.Set(keyCoffeeList, coffees,
                new MemoryCacheEntryOptions()
                    .SetSlidingExpiration(TimeSpan.FromSeconds(60))                     // 1min
                    .SetAbsoluteExpiration(TimeSpan.FromSeconds(3600))                     // 6min
                    .SetPriority(CacheItemPriority.Normal)
            );
        }
        return coffees;
    }
}
public interface ICachedCoffeeService
{
    List&lt;Coffee&gt; GetAll(bool reload = false);
}</pre> <p><code>CacheCoffeeService</code> inherits <a id="_idIndexMarker659"/>from <code>CoffeeService</code> and uses the <code>ICachedCoffeeService</code> interface. The <code>ICachedCoffeeService</code> interface should be <em class="italic">exactly</em> the same as <code>CoffeeService</code> except for one minor detail: a reload parameter added to each call with a default of false.</p>
<p>If we can’t find the entire list of coffees in the cache or we decide we want to reload the entire coffee list, we make a call to the base class (<code>CoffeeService.GetAll())</code>), save the new list to the cache, and return the entire list.</p>
<p>By default, when you call <code>CachedCoffeeService.GetAll()</code> with no parameters, you’ll get the cached version of the list. Pass a <code>true</code> to the <code>.GetAll()</code> and you’ll refresh your cache and receive the latest list of coffees.</p>
<p>This approach provides the benefit of combining a caching layer with standard data access, giving us the best of both worlds. When creating these data caches, the benefit is immediately obvious: gaining performance by using memory as your database, which is thread-safe. However, be wary of how many tables or how much data you are storing in the cache.</p>
<p>While it may seem like a trade-off using memory as a database, another caching option is using a distributed cache. A distributed cache is a cache shared across multiple app servers and provides the following benefits:</p>
<ul>
<li>It is coherent/aware of requests across servers</li>
<li>If the power goes out for a server, the cached data is persisted</li>
<li>As mentioned, a distributed cache doesn’t use local memory</li>
</ul>
<p>Some of the best<a id="_idIndexMarker660"/> candidates for data caching are small lookup tables (&lt; 100 records) and rarely-accessed table data.</p>
<h3>Caching static files</h3>
<p>With all of these<a id="_idIndexMarker661"/> static files such as images, CSS, and JavaScript available to our web application, you’d think there would be a way to cache these files as well.</p>
<p>In the <code>.UseStaticFiles()</code> method, there is a context parameter containing an <code>HttpContext</code>, so we can use the response object to change the cache-control headers for our static files:</p>
<pre class="source-code">
app.UseStaticFiles(new StaticFileOptions
{
    OnPrepareResponse = ctx =&gt;
    {
        <strong class="bold">// Cached for 24 hours.</strong>
        var response = ctx.Context.Response;
        var duration = 60 * 60 * 24; // 24h duration.
        response.Headers[HeaderNames.CacheControl] =
        "public,max-age="+duration;
    }
});</pre> <p>The preceding code takes our static files middleware component and allows a <code>StaticFileOptions</code> instance, which also has an <code>OnPrepareResponse</code> event available to us. For our cache duration, we set every static file header’s cache duration to 24 hours.</p>
<p>If we wanted to <a id="_idIndexMarker662"/>disable caching, we would modify the response to change the following headers:</p>
<pre class="source-code">
app.UseStaticFiles(new StaticFileOptions
{
    OnPrepareResponse = ctx =&gt;
    {
        var response = ctx.Context.Response;
        <strong class="bold">// disable all caching</strong>
        response.Headers[HeaderNames.CacheControl] = "no-cache,             no-store";
        response.Headers[HeaderNames.Pragma] = "no-cache";
        response.Headers[HeaderNames.Expires] = "-1";
    }
});</pre> <p>The preceding code sample disables caching for every static file.</p>
<p>Again, while these files are cached on the server’s local memory, keep in mind that when the power goes down, so does the cache.</p>
<p>If you wanted to cache a certain folder or file type, the <code>ctx</code> parameter contains not only a <code>Context</code> property of the <code>HttpContext</code> type, but a <code>File</code> property containing an <code>IFileInfo</code> type<a id="_idIndexMarker663"/> that includes <code>FileInfo</code> data.</p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor243"/>Summary</h1>
<p>While we covered a lot in this chapter, there are additional ways to achieve performance in web applications using more advanced techniques. The methods covered in this chapter are the best approaches for achieving performance in ASP.NET web applications. More than ever, performance is now considered one of the more important features in web applications, since it’s now usually tied to a company’s finances.</p>
<p>In this chapter, we first learned why performance matters by showing the effects of a slow website, how minor adjustments can produce large dividends, and how search engines reward websites for performance improvements.</p>
<p>We learned how to create baselines to identify possible bottlenecks using performance tools to analyze the client and server-side code with various tools.</p>
<p>Then, we learned about client-side techniques to optimize images, using CDNs to improve the loading of static content, and how to minimize your requests to lower latency issues. We also examined some quick tips such as placing scripts at the bottom and styles at the top, reviewing Google’s Core Web Vitals to understand how they gauge website performance, and using HTML instead of JavaScript where it’s relevant.</p>
<p>Finally, we focused on the server side by reviewing some small, immediate optimizations along with improving performance by optimizing HTML before it’s sent back to the client. From there, we learned how to speed up Entity Framework Core by adding DbContext pooling and identifying slow queries. The final piece to our performance chapter was implementing caching, which included learning about response caching, output caching, data caching, and how to cache static files.</p>
<p>In the appendix, we’ll examine some programming guidelines, along with what ASP.NET 8 projects look like nowadays.</p>
</div>
</body></html>