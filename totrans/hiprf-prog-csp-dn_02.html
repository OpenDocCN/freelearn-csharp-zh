<html><head></head><body>
		<div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Introducing C# 10.0 and .NET 6</h1>
			<p>Microsoft .NET 6 and C# 10.0 are the latest incarnations of the .NET platform and C# programming language. They bring many performance enhancements to the C# and .NET programmer community. We will start this book with an overview of the new versions of C# and .NET.</p>
			<p>In this chapter, you will start by downloading, restoring, building, and testing the latest version of the .NET compiler <a id="_idIndexMarker000"/>called <strong class="bold">Roslyn</strong>. Then, you will review what's new in .NET 6, including the areas where performance has been greatly enhanced. Then, you will review what's new in C# 10.0 by looking at some code examples that demonstrate these features. </p>
			<p>In the <em class="italic">Native compilation</em> section, you will build a project and run it as an MSIL project with multiple binaries, then compile and run it as a single native binary. Finally, you will learn how to improve the performance of Windows Store applications and ASP.NET websites.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><strong class="bold">Overview of .NET 6</strong>: In this section, we will cover, at a high level, what's new in .NET 6. You will learn about the various performance improvements that will be part of .NET 6.</li>
				<li><strong class="bold">Overview of C# 10.0</strong>: Having learned how to obtain the latest Roslyn code in the <em class="italic">Technical requirements</em> section, in this section, you will learn about the various features that will be part of C# 10.0. This will include code examples.</li>
				<li><strong class="bold">Native compilation</strong>: In this section, you will learn how to compile a .NET Core application into a single native executable. You will write a simple console application that recursively converts audio files from one format into another.</li>
				<li><strong class="bold">Improving Windows Store performance</strong>: This is a brief section that provides standard guidelines for improving the performance of applications that target the Windows Store.</li>
				<li><strong class="bold">Improving ASP.NET performance</strong>: This is a brief section that provides some standard guidelines for improving ASP.NET applications.</li>
			</ul>
			<p>By the end of this chapter, you will have the following skills:</p>
			<ul>
				<li>You will understand what's new in Microsoft .NET 6.</li>
				<li>You will be able to apply the new C# 10.0 code features within your source code.</li>
				<li>You will be able to compile your source code to native assemblies (also known as binaries).</li>
				<li>You will know what, how, and where to look for information on improving the performance of applications that target the Windows Store.</li>
				<li>You will know what, how, and where to look for information on improving the performance of ASP.NET applications.</li>
			</ul>
			<p>Let's begin this chapter by looking at Microsoft .NET 6.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>You will need the following prerequisites to complete this chapter:</p>
			<ul>
				<li>The latest preview version of Visual Studio Community Edition or higher.</li>
				<li>Microsoft .NET 6 SDK.</li>
				<li>This book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH01">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH01</a>.</li>
				<li>Optional: The latest Roslyn compiler built from source. The source code is available on GitHub at <a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a>. This should be automatically installed when you install the latest preview versions of Visual Studio.<p class="callout-heading">Note </p><p class="callout">You can find the latest complete and up-to-date C# 10.0 feature set at <a href="https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md">https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md</a>. At the time of writing, C# 10.0 is still undergoing much development and change. So, the contents of this book may not work as expected. If this turns out to be the case, then please refer to the preceding URL for the most relevant information to help you start working.</p></li>
			</ul>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Obtaining and building the latest Roslyn compiler from the source code</h2>
			<p class="callout-heading">Note</p>
			<p class="callout">The build <a id="_idIndexMarker001"/>system of all .NET-related repositories <a id="_idIndexMarker002"/>has been in flux for several years now. We will provide the instructions for compiling Roslyn here; these were correct at the time of writing. For the latest instructions, please read the <code>README.md</code> file located at <a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a>.</p>
			<p>The following instructions are for downloading and building the latest version of the Roslyn compiler source on Windows 10:</p>
			<ol>
				<li>In the root of the <code>C:\</code> drive, clone the Roslyn source code by using the following command in the Windows Command Prompt:<pre><strong class="bold">git clone https://github.com/dotnet/roslyn.git</strong></pre></li>
				<li>Then, run the following command:<pre><strong class="bold">cd Roslyn</strong></pre></li>
				<li>Restore the Roslyn dependencies by running the following command:<pre><strong class="bold">restore.cmd</strong></pre></li>
				<li>Build the Roslyn source code by running the following command: <pre><strong class="bold">build.cmd</strong></pre></li>
				<li>Test the Roslyn build by running the following command: <pre><strong class="bold">test.cmd</strong></pre></li>
				<li>Once all the tests have finished running, check the versions of C# that are accessible <a id="_idIndexMarker003"/>to the new computer. Do <a id="_idIndexMarker004"/>this by opening a Command Prompt window and navigating to <code>C:\roslyn\artifacts\bin\csc\Debug\net472</code>. </li>
				<li>Then, run the following command:<pre><strong class="bold">csc /langversion:?</strong></pre><p class="callout-heading">Note</p><p class="callout">I always run my Command Prompt as an administrator. Hence, the screenshots will show Command Prompt in administrative mode. But running Command Prompt as an administrator is not necessary for this exercise. Where Command Prompt must be executed as an administrator, this will be made clear as needed.</p></li>
			</ol>
			<p>You should see something equivalent to the following:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16617_Figure_1.1.jpg" alt="Figure 1.1 – The versions of the C# programming language supported by the compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The versions of the C# programming language supported by the compiler</p>
			<p>As you <a id="_idIndexMarker005"/>can see, at the time of writing, version 10.0 of the C# language is available via the C# compiler. C# 10.0 is set as the default. The <a id="_idIndexMarker006"/>preview is still under development. The default version may be different on your computer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The latest version of Visual Studio 2022 should allow you to use the latest available C# 10.0 code features. If it doesn't, then compile the latest source and overwrite the files located at <code>C:\Program Files (x86)\Microsoft Visual Studio\2022\Preview\MSBuild\Current\Bin\Roslyn</code>.</p>
			<p>The following three sets of instructions provide compiler help for compiling a program that targets a specific C# version and then runs the program. These commands are for demonstrative purposes only, and you do not have to run them now:</p>
			<pre>csc /help
csc -langversion:10.0 /out:HelloWorld.exe Program.cs
csc HelloWorld</pre>
			<p>Now that <a id="_idIndexMarker007"/>you can build C# 10.0 from the command <a id="_idIndexMarker008"/>line and from within Visual Studio 2022, let's learn what kind of new development is taking place with Microsoft .NET 6.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Overview of Microsoft .NET 6</h1>
			<p>Microsoft .NET 6 is <a id="_idIndexMarker009"/>the latest incarnation of .NET. You can access <a id="_idIndexMarker010"/>the downloads at <a href="https://dotnet.microsoft.com/download/dotnet/6.0">https://dotnet.microsoft.com/download/dotnet/6.0</a>. The downloads are available for Windows, macOS, and Linux users.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To get the most out of .NET 6 and C# 10.0, it is best that you have Visual Studio 2022 or later installed.</p>
			<p>The .NET 6 API <a id="_idIndexMarker011"/>documentation is available at <a href="https://docs.microsoft.com/dotnet/api/?view=net-6.0">https://docs.microsoft.com/dotnet/api/?view=net-6.0</a>.</p>
			<p>Microsoft .NET 5 and later will no longer carry the <em class="italic">Core or Framework suffix</em>, as per the following article: <a href="https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx">https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx</a>. Microsoft's goal with version 5 and later of the .NET platform is to create a single platform for the .NET development of WinForms, WPF, Xamarin.Forms, ASP.NET Core, and all other forms of .NET development. Xamarin.Forms becomes Microsoft MAUI, with the main difference between versions being that the new Microsoft MAUI will only use a single project to target all operating systems and devices.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Moving to one unified platform</h2>
			<p>The infrastructure <a id="_idIndexMarker012"/>for .NET 6 consists of runtime components, compilers, and languages. Microsoft .NET SDK will sit on top of this infrastructure. The tools that will be available include the command-line interface, Visual Studio Code, Visual Studio for Mac, and, of course, Visual Studio. </p>
			<p>With the unified platform, you can write desktop applications using WinForms, WPF, and UWP. Web applications can be written using ASP.NET. Cloud applications will target Microsoft Azure. Mobile <a id="_idIndexMarker013"/>applications will be written using Microsoft MAUI. Games, <strong class="bold">virtual reality</strong> (<strong class="bold">VR</strong>), and <strong class="bold">augmented reality</strong> (<strong class="bold">AR</strong>) applications <a id="_idIndexMarker014"/>will be developed in Unity, using Visual Studio 2022 or higher as the C# code editor. IoT will target ARM32 and ARM64 architectures. Finally, you <a id="_idIndexMarker015"/>will be able to develop <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) applications using ML.NET and .NET for Apache Spark.</p>
			<p>Microsoft is planning <a id="_idIndexMarker016"/>on producing a single .NET runtime and framework that is uniform in its developer experience and runtime behavior across applications and devices. This will be accomplished by building a single code base that combines the best elements of.NET Framework, .NET Core, Mono, and Xamarin.Forms.</p>
			<p>The main <a id="_idIndexMarker017"/>features of.NET 6 are as follows:</p>
			<ul>
				<li>Unified developer experiences, regardless of the applications being developed and the devices being targeted.</li>
				<li>Unified runtime experiences across all devices and platforms.</li>
				<li>Java interoperability will be available on all platforms. This is stated in the Redmond Magazine article called <em class="italic">Coming in 2020: .NET 5, The Next Phase of Microsoft's .NET Framework</em>: <a href="https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx">https://redmondmag.com/articles/2019/12/31/coming-in-2020-net-5.aspx</a>.</li>
				<li>Multiple operating systems will be supported for Objective-C and Swift.</li>
				<li>AOT will be supported by CoreFX to provide static .NET compilation, support multiple operating systems, and produce assemblies that are smaller in size.</li>
			</ul>
			<p>Now, let's look at some of the new features of .NET 6 from a high-level viewpoint.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Garbage collection</h2>
			<p>The garbage collector's performance regarding marking and stealing has been improved. When a <a id="_idIndexMarker018"/>thread has finished its marking allotment, it can steal outstanding marking work from other threads. This speeds up the process of <a id="_idIndexMarker019"/>collecting items to be garbage collected. Reduced lock contentions on computers with higher core counts, improved de-committing, avoidance of costly memory resets, and vectorized sorting are just some of the new garbage collection performance improvements in .NET 6.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Just-In-Time compiler</h2>
			<p>In .NET 6, the <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) compiler <a id="_idIndexMarker020"/>has also been improved. You can apply various optimizations to the JIT, and it has an unlimited amount of time <a id="_idIndexMarker021"/>to implement those optimizations. <strong class="bold">Ahead-Of-Time</strong> (<strong class="bold">AOT</strong>) is just one of the various techniques provided to the JIT so that it can compile as much code as it can before executing the application. The JIT now sees the length <a id="_idIndexMarker022"/>of an array as unsigned, which improves the performance of mathematical operations carried out on an array's length. There are still many changes being made.</p>
			<p>Suffice to say that between the JIT and the GC, the performance improvements that have been made to JIT and GC concerning memory and compilation optimizations are just two reasons alone to migrate to .NET 6. </p>
			<p>The JIT also recognizes more than a thousand new hardware intrinsic methods. These methods allow you to target various hardware instruction sets from C#. You are no longer tied to just x86_x64 hardware instruction sets.</p>
			<p>Several runtime helper functions are available in the JIT. These helper functions enable the JIT compiler to manipulate the source code so that the code runs must faster. Generic lookups are much faster now, as they no longer need to employ slower lookup tables.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Text-based processing</h2>
			<p>Performance <a id="_idIndexMarker023"/>enhancements have also been made within the text-based <a id="_idIndexMarker024"/>processing elements of .NET 6. These include (but are not limited to) processing whitespace in the <code>System.Char</code> class, which requires less branching and fewer arguments. Because this class is used in various text-processing objects and methods within .NET 6, the speed of processing text in .NET 6 will be generally improved. <code>DateTime</code> processing is also at least 30% faster due to optimizations in extracting the date and time components from the raw tick count. Performance improvements have also been made to string operations <a id="_idIndexMarker025"/>due to culture-aware modifications of <code>StartsWith</code> and <code>EndsWith</code>. By utilizing stack allocation and JIT devirtualization, the performance <a id="_idIndexMarker026"/>of data encoding, such as <em class="italic">UTF8</em> and <em class="italic">Latin1</em> encoding, has also been enhanced.</p>
			<p><code>CharInClass</code> method is more intelligent in determining if characters appear within the specified character class. Character and digit comparisons use lookup tables and various method calls are inlined, providing improved RegEx processing. Generated code for various expressions has been improved. Searching for RegExes is carried out using span-based searching with vectorized methods. The need for backtracking has been eliminated as it analyzes RegExes during the node tree optimization phase and adds atomic groups that do not change the semantics but do prevent backtracking. These are only some of the improvements to RegEx performance. But there are many more.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more in-depth <a id="_idIndexMarker028"/>knowledge on .NET 5 performance improvements to RegExes, please read the following very detailed post by Stephen Toub: <a href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/">https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/</a>.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Threading and asynchronous operations</h2>
			<p>Threading <a id="_idIndexMarker029"/>and asynchronous operations <a id="_idIndexMarker030"/>have also received a performance <a id="_idIndexMarker031"/>boost in .NET 5 with the experimental addition <a id="_idIndexMarker032"/>of async <code>ValueTask</code> pooling. You can turn on pooling by setting <code>DOTNET_SYSTEM_THREADING_POOLASYNCVALUETASK</code> to <code>true</code> or <code>1</code>. Pooling creates state machine box objects that implement the interfaces, <code>IvalueTaskSource</code>, and <code>IValueTaskSource&lt;TResult&gt;</code>. The runtime adds these <a id="_idIndexMarker033"/>objects to the pool. Volatility has <a id="_idIndexMarker034"/>also received performance improvements in <code>ConcurrentDictionary</code>, with <a id="_idIndexMarker035"/>performance improving <a id="_idIndexMarker036"/>as much as 30% on some ARM architectures.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Collections and LINQ</h2>
			<p>The collections <a id="_idIndexMarker037"/>have also seen several performance enhancements, mainly to <code>Dictionary&lt;TKey, TValue&gt;</code>, <code>HashSet&lt;T&gt;</code>, <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>, and <code>System.Collections.Immutable</code>. The <code>HashSet&lt;T&gt;</code> collection's implementation <a id="_idIndexMarker038"/>has been rewritten and re-synchronized with <code>Dictionary&lt;TKey</code>,<code> </code>the<code> TValue&gt;</code> implementation, and moved further down the stack. The performance of <code>foreach</code> when iterating through an <code>ImmutableArray&lt;T&gt;</code> has been improved, and the generated code has been reduced in size by the addition of the <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> annotation to the <code>GetEnumerator</code> method of <code>ImmutableArray&lt;T&gt;</code>. Other elements of the .NET collections, such as <code>BitArray</code>, have also seen performance improvements.</p>
			<p>In .NET 5, LINQ has <a id="_idIndexMarker039"/>also seen further performance improvements, including <code>OrderBy</code>, <code>Comparison&lt;T&gt;</code>, <code>Enumerable.SkipLast</code>, and by making implementing <code>Enumerable.Any</code> more <a id="_idIndexMarker040"/>consistent with <code>Enumerable.Count</code>. These are only a few performance improvements that have been to the collections.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Networking and Blazor</h2>
			<p>Networking has <a id="_idIndexMarker041"/>received a lot of work on performance improvement, especially <a id="_idIndexMarker042"/>the <code>System.Uri</code> class (especially in its construction). The <code>System.Net.Sockets</code> and <code>System.Net.Http</code> namespaces have also seen performance improvements. Many improvements have been made to how JSON is processed with <code>JsonSerializer</code> in the <code>System.Text.Json</code> library for .NET.</p>
			<p>As Blazor uses the .NET mono runtime and .NET 5 libraries, a linker has been added that trims code <a id="_idIndexMarker043"/>from the assembly that is not used down to the member level. The code to be trimmed is identified by <em class="italic">static code analysis</em>. User interface response times are also <a id="_idIndexMarker044"/>improved in Blazor Web Assembly applications, as the client-side code is downloaded before being executed, and behaves just like a desktop application – but from within the browser.</p>
			<p>Furthermore, general improvements that have gone into .NET 5 include faster assembly loading, faster mathematical operations, faster encryption and decryption, faster interoperability, faster reflection emitting, faster I/O, and various allocations in various libraries.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>New performance-based APIs and analyzers</h2>
			<p>A few new performance-focused APIs have been added to .NET 5. Internally, some of these APIs <a id="_idIndexMarker045"/>are already being used to reduce <a id="_idIndexMarker046"/>code size and improve the performance of .NET 5 itself. They focus on helping the programmer to concentrate on writing performant code and removing the complexity of tasks that have been previously hard to accomplish. These new APIs and improvements to existing APIs include <code>Decimal</code>, <code>GC</code>, <code>MemoryExtensions</code>, <code>StringSplitOptions</code>, <code>BinaryPrimitives</code>, <code>MailAddress</code>, <code>MemoryMarshall</code>, <code>SslStream</code>, <code>HttpClient</code>, and more.</p>
			<p>The .NET 5 SDK has <a id="_idIndexMarker047"/>also seen the addition of <a id="_idIndexMarker048"/>some new performance-based analyzers. These analyzers can detect accidental allocations as a part of range indexing and offer ways to eliminate the allocation. Analyzers will detect the old overloads for the <code>Stream.Read</code>/<code>WriteAsync</code> methods and will offer fixes to enable automatic switching to the newer overload methods that prefer <code>Memory</code> overloads. In <code>StringBuilder</code>, it is more performant to use <em class="italic">typed overloads</em> to append non-string values such as <code>int</code> and <code>long</code> values. When situations are encountered by the analyzer where the programmer has called <code>ToString()</code> on a type that's being appended for which a typed overload exists, the fixer will detect these situations and automatically switch to using the correct typed overload. With LINQ, it is now more efficient to check if <code>(collection.Count != 0)</code> using the <code>(!collection.IsEmpty)</code> syntax. The old way will be detected by the analyzer and fixed to use the more performant new way. Finally, when you have worked to make your code faster, your code is made correct, as the analyzer flags cases that use loops to allocate memory from the stack using <code>stackalloc</code>. This helps prevent stack overflow exceptions from being raised.</p>
			<p>To see the <a id="_idIndexMarker049"/>road ahead in terms of .NET's new development, you can view the .NET Core roadmap located at <a href="https://github.com/dotnet/core/blob/master/roadmap.md">https://github.com/dotnet/core/blob/master/roadmap.md</a>.</p>
			<p>Now, let's look at C# 10.0.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Overview of C# 10.0</h1>
			<p>You can find <a id="_idIndexMarker050"/>the features that will become part of C# 10.0 on the Roslyn GitHub page at <a href="https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md">https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md</a>.</p>
			<p>Not all these features are available at the time of writing. However, we will look at some of the available features. With that, let's start with top-level programs.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Writing top-level programs</h2>
			<p>Before C# 9.0, the <code>Program.cs</code>. In this file, you would have something akin to the following:</p>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">namespace HelloWorld</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">class Program</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">            static void Main(string[] args)</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                  Console.WriteLine("Hello, World!");</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, first, we import our <code>System</code> library. Then, we have a namespace definition followed by our class definition. Then, in the class definition, we have our <code>Main</code> method, in which we output the phrase <code>"Hello, World!"</code> to the console window.</p>
			<p>In version 10.0 of the C# programming language, this can be simplified down to a single line:</p>
			<pre class="source-code">System.Console.WriteLine("Hello, World");</pre>
			<p>Here, we have <a id="_idIndexMarker052"/>eradicated 10 lines of code. Running the program will output the following:</p>
			<div><div><img src="img/B16617_Figure_1.2.jpg" alt="Figure 1.2 – The console window showing the output &quot;Hello World!&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – The console window showing the output "Hello World!"</p>
			<p>If we open the generated DLL in IL DASM, we will see the following:</p>
			<div><div><img src="img/B16617_Figure_1.3.jpg" alt="Figure 1.3 – ILDASM showing the internals of the hello world program&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – ILDASM showing the internals of the hello world program</p>
			<p>You will see from the decompilation that the compiler adds the <code>Main</code> method at compile time. The next addition to C# 10.0 that we will look at is init-only properties.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Using init-only properties</h2>
			<p>Init-only <a id="_idIndexMarker053"/>properties allow you to use object initializers with immutable fields. For our little demonstration, we will use a <code>Book</code> class that holds the name of a book and its author:</p>
			<pre class="source-code">namespace CH01_Books</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    internal class Book</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        public string Title { get; init; }</pre>
			<pre class="source-code">        public string Author { get; init; }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The properties can be initialized when the book is created. But once created, they can only be read, not updated, making the <code>Book</code> type immutable. Now, let's look at init-only properties. In the <code>Program</code> class, replace its contents with the following:</p>
			<pre class="source-code">using System;</pre>
			<pre class="source-code">using CH01_Books;</pre>
			<pre class="source-code">var bookName = new Book { Title = "Made up book name", </pre>
			<pre class="source-code">    Author = "Made Up Author" };</pre>
			<pre class="source-code">Console.WriteLine($"{bookName.Title} is written by </pre>
			<pre class="source-code">    {bookName.Author}. Well worth reading!");</pre>
			<p>Here, we imported the <code>System</code> and <code>CH01_Books</code> namespaces. Then, we declared a new immutable variable of the <code>Book</code> type. After that, we output the contents of that <code>Book</code> type using an interpolated string. Run the program; you should see the following output:</p>
			<div><div><img src="img/B16617_Figure_1.4.jpg" alt="Figure 1.4 – The output of our init-only properties example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – The output of our init-only properties example</p>
			<p>Now that we <a id="_idIndexMarker054"/>have been introduced to init-only properties, let's look at records.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Using records</h2>
			<p>When updating data, you do not want that data to be changed by another thread. So, in multi-threaded <a id="_idIndexMarker055"/>applications, you will want to use thread-safe objects when making updates. Records allow complete objects to be immutable and behave as values. The advantage of using records over structs is that they require less memory to be allocated to them. This reduction in memory allocation is accomplished by compiling records to reference types. They are then accessed via references and not as copies. Due to this, other than the original record allocation, no further memory allocation is required.</p>
			<p>Let's learn how to use records. Start a new console application.</p>
			<p>To demonstrate the use of records, we will use the following <code>Book</code> example:</p>
			<pre class="source-code">internal record Book</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public string Title { get; init; }</pre>
			<pre class="source-code">     public string Author { get; init; }</pre>
			<pre class="source-code">}</pre>
			<p>The only change to the <code>Book</code> class is that class has been replaced with <code>record</code>. Everything else remains the same. Now, let's put the record to work:</p>
			<ol>
				<li value="1">Replace the contents of the <code>Program</code> class with the following code:<pre>using System;
using CH01_Records;
var bookOne = new Book { 
    Title = "Made Up Book", 
    Author = "Made Up Author
};
var bookTwo = bookOne with { 
    Title = "And Another Made Up Book"
};
var bookThree = bookTwo with { 
    Title = "Yet Another Made Up Book"
};
var bookFour = bookThree with { 
    Title = "And Yet Another Made Up Book: Part 1",
};
var bookFive = bookFour with { 
    Title = "And Yet Another Made Up Book: Part 2"
};
var bookSix = bookFive with { 
    Title = "And Yet Another Made Up Book: Part 3"
};
Console.WriteLine($"Some of {bookThree.Author}'s 
    books include:\n");
Console.WriteLine($"- {bookOne.Title}");
Console.WriteLine($"- {bookTwo.Title}");
Console.WriteLine($"- {bookThree.Title}");
Console.WriteLine($"- {bookFour.Title}");
Console.WriteLine($"- {bookFive.Title}");
Console.WriteLine($"- {bookSix.Title}");
Console.WriteLine($"\nMy favourite book by {bookOne.
    Author} is {bookOne.Title}.");</pre></li>
				<li>As you <a id="_idIndexMarker056"/>can see, we are creating immutable record types. We can create new immutable types from them and change any fields we like using the <code>with</code> expression. The original record is not mutated in any way. Run the code; you will see the following output:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16617_Figure_1.5.jpg" alt="Figure 1.5 – Init-only properties showing their immutability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Init-only properties showing their immutability</p>
			<p>Despite <a id="_idIndexMarker057"/>changing the title during the assignment, the original record has not been mutated at all.</p>
			<ol>
				<li value="3">Records can also use <em class="italic">inheritance</em>. Let's add a new record that contains the publisher's name:<pre>    internal record Publisher
    {
        public string PublisherName { get; init; }
    }</pre></li>
				<li>Now, let's have our <code>Book</code> inherit this <code>Publisher</code> record:<pre>    internal record Book : Publisher
    {
        public string Title { get; init; }
        public string Author { get; init; }
    }</pre></li>
				<li><code>Book</code> will now include <code>PublisherName</code>. When we initialize a new book, we can now set its <code>PublisherName</code>:<pre>var bookOne = new Book { 
    Title = "Made Up Book", 
    Author = "Made Up Author",
    PublisherName = "Made Up Publisher Ltd."
};</pre></li>
				<li>Here, we have <a id="_idIndexMarker058"/>created a new <code>Book</code> that contains <code>Publisher.PublisherName</code>. Let's print the publisher's name. Add the following line to the end of the <code>Program</code> class:<pre>Console.WriteLine($"These books were originally published 
    by {bookSix.PublisherName}.");</pre></li>
				<li>Run the code; you should see the following output:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16617_Figure_1.6.jpg" alt="Figure 1.6 – Init-only properties using inheritance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Init-only properties using inheritance</p>
			<ol>
				<li value="8">As you <a id="_idIndexMarker059"/>can see, we never set the publisher's name for <code>bookTwo</code> to <code>bookSix</code>. However, the inheritance has followed through from when we set it for <code>bookOne</code>.</li>
				<li>Now, let's perform object equality checking. Add the following code to the end of the <code>Program</code> class:<pre>var book = bookThree with { Title = "Made Up Book" };
var booksEqual = Object.Equals(book, bookOne) ? 
    "Yes" : "No";
Console.WriteLine($"Are {book.Title} and 
    {bookOne.Title} equal? {booksEqual}"); </pre></li>
				<li>Here, we created a new <code>Book</code> from <code>bookThree</code> and set the title to <code>Made Up Book</code>. Then, we performed <a id="_idIndexMarker060"/>an equality check and output the result to the console window. Run the code; you will see the following output:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16617_Figure_1.7.jpg" alt="Figure 1.7 – Init-only properties showing the result of an equality check&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Init-only properties showing the result of an equality check</p>
			<p>It is clear to see that the equality check works with both book instances being equal. </p>
			<ol>
				<li value="11">Our final look at records considers positional records. Positional records set data via the constructor and extract data via the deconstructor. The best way to understand this <a id="_idIndexMarker061"/>is with code. Add a class called <code>Product</code> and replace the class with the following:<pre>    public record Product
    {
        readonly string Name;
        readonly string Description;
        public Product(string name, string 
            description) 
            =&gt; (Name, Description) = (name, 
            description);
        public void Deconstruct(out string name, out 
            string description) 
            =&gt; (name, description) = (Name, 
                Description);
    }</pre></li>
				<li>Here, we have an immutable record. The record has two private and <code>readonly</code> fields. They are set in the constructor. The <code>Deconstruct</code> method is used to return the data. Add the following code to the <code>Program</code> class:<pre>var ide = new Product("Awesome-X", "Advanced Multi-
    Language IDE");
var (product, description) = ide;
Console.WriteLine($"The product called {product} is an 
    {description}.");</pre></li>
			</ol>
			<p>In this code, we created a new product with parameters for the name and description. Then, we declared two fields called <code>product</code> and <code>description</code>. The fields are <a id="_idIndexMarker062"/>set by assigning the product. Then, we output the product and description to the console window, as shown here:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B16617_Figure_1.8.jpg" alt="Figure 1.8 – Init-only positional records&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Init-only positional records</p>
			<p>Now that we have finished looking at records, let's look at the improved pattern matching capabilities of C# 10.0.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Using the new pattern matching features</h2>
			<p>Now, let's look at what's new for pattern matching in C# 10.0, starting with simple patterns. With <a id="_idIndexMarker063"/>simple pattern matching, you no longer need the discard (<code>_</code>) operator to just declare the type. In our example, we will apply discounts to orders:</p>
			<ol>
				<li value="1">Add a new record called <code>Product</code> to a new file called <code>Product.cs</code> in a new console application and add the following code:<pre>    internal record Product
    {
        public string Name { get; init; }
        public string Description { get; init; }
        public decimal UnitPrice { get; init; }
    }</pre></li>
				<li>Our <code>Product</code> record has three init-only properties for <code>Name</code>, <code>Description</code>, and <code>UnitPrice</code>. Now, add the <code>OrderItem</code> record that inherits from <code>Product</code>:<pre>    internal record OrderItem : Product
    {
        public int QuantityOrdered { get; init; }
    }</pre></li>
				<li>Our <code>OrderItem</code> record inherits the <code>Product</code> record and adds the <code>QuantityOrdered</code> init-only property. In the <code>Program</code> class, we will add three variables of the <code>OrderItem</code> type and initialize them. Here is the first <code>OrderItem</code>:<pre>var orderOne = new OrderItem {
        Name = "50-80mm Scottish Cobbles", 
        Description = "These rounded stones are 
          frequently used for edging paths and to add 
            interest to gardens", 
        QuantityOrdered = 4, 
        UnitPrice = 199 
};</pre></li>
			</ol>
			<p>As you <a id="_idIndexMarker064"/>can see, the quantity that's being ordered is <code>4</code>.</p>
			<ol>
				<li value="4">Add <code>orderTwo</code> with the same values but with an <code>OrderQuantity</code> of <code>7</code>.</li>
				<li>Then, add <code>orderThree</code> with the same values, but with an <code>OrderQuantity</code> of <code>31</code>. We will demonstrate simple pattern matching in the <code>GetDiscount</code> method:<pre>static int GetDiscount(object order) =&gt;
    order switch
    {
        OrderItem o when o.QuantityOrdered == 0 =&gt; 
            throw 
          new ArgumentException("Quantity must be 
              greater than zero."),
        OrderItem o when o.QuantityOrdered &gt; 20 =&gt; 30,
        OrderItem o when o.QuantityOrdered &lt; 5 =&gt; 10,
        OrderItem =&gt; 20,
        _ =&gt; throw new ArgumentException("Not a known 
            OrderItem!", nameof(order))
    };</pre></li>
				<li>Our <code>GetDiscount</code> method receives an order. <code>QuantityOrdered</code> is then evaluated. Argument exceptions are thrown if the order quantity is <code>0</code> and if the object type that's been passed in is not of the <code>OrderItem</code> type. Otherwise, a discount of the <code>int</code> type is returned for the quantity ordered. Notice that we use the type without using the discard operator on the line for the 20% discount.</li>
				<li>Finally, we <a id="_idIndexMarker065"/>must add the following lines to the end of the <code>Program</code> class:<pre>Console.WriteLine($"The discount for Order One is 
    {GetDiscount(orderOne)}%.");
Console.WriteLine($"The discount for Order Two is 
    {GetDiscount(orderTwo)}%.");
Console.WriteLine($"The discount for Order Three is 
    {GetDiscount(orderThree)}%.");</pre></li>
				<li>These lines print the discount received for each of the orders to the console window. Now, let's modify our code so that it uses relational pattern matching. Add the following method to the <code>Program</code> class:<pre>static int GetDiscountRelational(OrderItem orderItem) 
    =&gt; orderItem.QuantityOrdered switch
    {
        &lt; 1 =&gt; throw new ArgumentException("Quantity 
            must be greater than zero."),
        &gt; 20 =&gt; 30,
        &lt; 5 =&gt; 10,
        _ =&gt; 20
    };</pre></li>
				<li>Using relational pattern matching, we have received the same outcome as with simple pattern matching, but with less code. It is also very readable, which makes it easy to maintain. Add the following three lines of code to the end of the <code>Program</code> class:<pre>Console.WriteLine($"The discount for Order One is 
    {GetDiscountRelational(orderOne)}%.");
Console.WriteLine($"The discount for Order Two is 
    {GetDiscountRelational(orderTwo)}%.");
Console.WriteLine($"The discount for Order Three is 
    {GetDiscountRelational(orderThree)}%.");</pre></li>
				<li>In these <a id="_idIndexMarker066"/>three lines, we simply output the discount for each order to the console window. Run the program; you will see the following output:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_1.9.jpg" alt="Figure 1.9 – Simple and relational pattern matching output showing the same results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Simple and relational pattern matching output showing the same results</p>
			<p>From the preceding screenshot, you can see that the same outcome has been received for both discount methods.</p>
			<ol>
				<li value="11">The logical <code>AND</code>, <code>OR</code>, and <code>NOT</code> methods can be used in logical pattern matching. Let's add the following method:<pre>static int GetDiscountLogical(OrderItem orderItem) =&gt;
    orderItem.QuantityOrdered switch
    {
        &lt; 1 =&gt; throw new ArgumentException("Quantity 
            must be greater than zero."),
        &gt; 0 and &lt; 5 =&gt; 10,
        &gt; 4 and &lt; 21 =&gt; 20,
        &gt; 20 =&gt; 30
    };</pre></li>
				<li>In the <code>GetDiscountLogical</code> method, we employ the logical AND operator to check <a id="_idIndexMarker067"/>whether a value falls in that range. Add the following three lines to the end of the <code>Program</code> class:<pre>Console.WriteLine($"The discount for Order One is 
    {GetDiscountLogical(orderOne)}%.");
Console.WriteLine($"The discount for Order Two is 
    {GetDiscountLogical(orderTwo)}%.");
Console.WriteLine($"The discount for Order Three is 
    {GetDiscountLogical(orderThree)}%.");</pre></li>
				<li>In those three lines of code, we output the discount value for the order to the console window. Run the code; you will see the following output:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_1.10.jpg" alt="Figure 1.10 – Simple, relational, and logical pattern matching showing the same results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Simple, relational, and logical pattern matching showing the same results</p>
			<p>The output for the logical pattern matching is the same as for simple and relational pattern matching. Now, let's learn how to use new expressions with targeted types.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Using new expressions with targeted types</h2>
			<p>You can <a id="_idIndexMarker068"/>omit the type of object being instantiated. But to do so, the declared type must be explicit and not use the <code>var</code> keyword. If you attempt to do this with the ternary operator, you will be greeted with an exception: </p>
			<ol>
				<li value="1">Create a new console application and add the <code>Student</code> record:<pre>    public record Student
    {
        private readonly string _firstName;
        private readonly string _lastName;
        public Student(string firstName, string 
            lastName)
        {
            _firstName = firstName;
            _lastName = lastName;
        }
        public void Deconstruct(out string firstName, 
            out string lastName)
            =&gt; (firstName, lastName) = (_firstName, 
                _lastName);
    }</pre></li>
				<li>Our <code>Student</code> record stores the first and last name values, which have been set via the constructor. These values are obtained via the <code>out</code> parameters of the <code>Deconstruct</code> method. Add the following code to the <code>Program</code> class:<pre>Student jenniferAlbright = new ("Jennifer", 
    "Albright");
var studentList = new List&lt;Student&gt;
{
    new ("Jennifer", "Albright"),
    new ("Kelly", "Charmichael"),
    new ("Lydia", "Braithwait")
};
var (firstName, lastName) = jenniferAlbright;
Console.WriteLine($"Student: {lastName}, {firstName}");
(firstName, lastName) = studentList.Last();
Console.WriteLine($"Student: {lastName}, {firstName}");</pre></li>
				<li>First, we <a id="_idIndexMarker069"/>instantiate a new <code>Student</code> without declaring the type in the <code>new</code> statement. Then, we instantiate a new <code>List</code> and add new students to the list while omitting the <code>Student</code> type. The fields are then defined for <code>firstName</code> and <code>lastName</code> and assigned their values through the assignment of the named student. The student's name is then printed out on the console window. Next, we take those fields and reassign them with the name of the last student on the list. Then, we output the student's name to the console window. Run the program; you will see the following output:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_1.11.jpg" alt="Figure 1.11 – Using targeted types with new expressions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Using targeted types with new expressions</p>
			<p>From the preceding screenshot, you can see that we have the correct student names printed. Now, let's look at covariant returns.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Using covariant returns</h2>
			<p>With covariant returns, base class methods with less specific return types can be overridden <a id="_idIndexMarker070"/>with methods that return more specific types. Have a look at the following array declaration:</p>
			<pre class="source-code">object[] covariantArray = new string[] { "alpha", "beta", </pre>
			<pre class="source-code">    "gamma", "delta" };</pre>
			<p>Here, we declared an <code>object</code> array. Then, we assigned a <code>string</code> array to it. This is an example of covariance. The <code>object</code> array is the least specific array type, while the <code>string</code> array is the more specific array type.</p>
			<p>In this example, we will instantiate covariant types and pass them into a method that accepts less and more specific types. Add the following class and interface declarations to the <code>Program</code> class:</p>
			<pre class="source-code">public interface ICovariant&lt;out T&gt; { }</pre>
			<pre class="source-code">public class Covariant&lt;T&gt; : ICovariant&lt;T&gt; { }</pre>
			<pre class="source-code">public class Person { }</pre>
			<pre class="source-code">public class Teacher : Person { }</pre>
			<pre class="source-code">public class Student : Person { }</pre>
			<p>Here, we have a covariant class that implements a covariant interface. We declared a general type of <code>Person</code> that is inherited by the specific <code>Teacher</code> and <code>Student</code> types. Add <code>CovarianceClass</code>, as shown here:</p>
			<pre class="source-code">public class CovarianceExample</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public void CovariantMethod(ICovariant&lt;Person&gt; person)</pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">      Console.WriteLine($"The type of person passed in is </pre>
			<pre class="source-code">          of type {person.GetType()}.");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the <code>CovarianceExample</code> class, we have a <code>CovariantMethod</code> with a parameter that can accept objects of the <code>ICovariant&lt;Person&gt;</code> type. Now, let's put covariance <a id="_idIndexMarker071"/>to work by adding the <code>CovarianceAtWork</code> method to the <code>CovarianceExample</code> class:</p>
			<pre class="source-code">public void CovarianceAtWork()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">ICovariant&lt;Person&gt; person = new Covariant&lt;Person&gt;();</pre>
			<pre class="source-code">ICovariant&lt;Teacher&gt; teacher = new Covariant&lt;Teacher&gt;();</pre>
			<pre class="source-code">ICovariant&lt;Student&gt; student = new Covariant&lt;Student&gt;();</pre>
			<pre class="source-code">CovariantMethod(person);</pre>
			<pre class="source-code">CovariantMethod(teacher);</pre>
			<pre class="source-code">CovariantMethod(student);</pre>
			<pre class="source-code">}</pre>
			<p>In this method, we have the general <code>Person</code> type and the more specific <code>Teacher</code> and <code>Student</code> types. We must pass each into <code>CovariantMethod</code>. This method can take the less specific <code>Person</code> type and the more specific <code>Teacher</code> and <code>Student</code> types.</p>
			<p>To run the <code>CovarianceAtWork</code> method, place the following code after the <code>using</code> statement and before the <code>covariantArray</code> example:</p>
			<pre class="source-code">CovarianceExample.CovarianceAtWork();</pre>
			<p>Now, let's look at native compilation.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Native compilation</h1>
			<p>When .NET <a id="_idIndexMarker072"/>code is compiled, it is compiled into <strong class="bold">Microsoft Intermediate Language</strong> (<strong class="bold">MSIL</strong>). MSIL <a id="_idIndexMarker073"/>gets interpreted by a JIT compiler when it is needed. The JIT compiler then compiles the necessary MSIL code into native binary code. Subsequent calls to the same code call the binary version of the code, not the MSIL version of the code. This means that MSIL code is always slower than native code, as it is compiled to native on the first run.</p>
			<p>JIT code has the advantage of being cross-platform code at the expense of longer startup times. The code of an MSIL assembly that runs is compiled to native code by the JIT compiler. The <a id="_idIndexMarker074"/>native code is optimized by the JIT compiler for the target hardware it is running on.</p>
			<p>By default, UWP applications are compiled to native code using .NET Native, while iOS applications are compiled to native code via Xamarin/Xamarin.Forms. Microsoft .NET Core can also be compiled into native code.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Performing native compilation of .NET Core applications</h2>
			<p>When <a id="_idIndexMarker075"/>using <code>dotnet</code> to compile an assembly to native code, you will need to specify a t<a href="https://docs.microsoft.com/en-us/dotnet/standard/frameworks">arget framework. For a list of supported target frameworks</a>, please refer to <a href="https://docs.microsoft.com/en-us/dotnet/standard/frameworks">https://docs.microsoft.com/en-us/dotnet/standard/frameworks</a>. You will also need to <a id="_idIndexMarker077"/>spec<a href="https://docs.microsoft.com/en-us/dotnet/core/rid-catalog">ify a <strong class="bold">Runtime Identifier</strong> (<strong class="bold">RID</strong>). For a list of supported </a>RIDs, please refer to <a href="https://docs.microsoft.com/en-us/dotnet/core/rid-catalog">https://docs.microsoft.com/en-us/dotnet/core/rid-catalog</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, native compilation against .NET 5.0 does have its issues. So, to keep things simple, we will demonstrate native compilation into a single executable against netcoreapp3.1 and win10-x64.</p>
			<p>To demonstrate the compilation of Microsoft .NET Core applications into natively compiled single executables, we will write a simple demonstration application that traverses a directory structure and converts audio files from one format into another:</p>
			<ol>
				<li value="1">Start a new console application and target .NET 6.</li>
				<li>Visit <a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a> and download <code>ffmpeg</code> for your operating system. Mine is Windows 10.</li>
				<li>On Windows 10, extract the <code>ffmpeg</code> files into the <code>C:\Tools\ffmpeg</code> folder. Add the following <code>using</code> statements to the top of the <code>Program.cs</code> file:<pre>using System;
using System.Diagnostics;
using System.IO;</pre></li>
				<li>We will be batch processing audio files in a folder hierarchy on our local systems. Here, the <code>using</code> statements listed will help us debug our code and perform I/O <a id="_idIndexMarker078"/>on the filesystem. Now, at the top of the <code>Program</code> class, add the following three fields:<pre>private static string _baseDirectory = string.Empty;
private static string _sourceExtension = string.Empty;
private static string _destinationExtension = string
    .Empty;</pre></li>
				<li>The <code>BaseDirectory</code> member holds the starting directory that will be processed. <code>sourceExtension</code> holds the extension of the file type, such as <code>.wav</code>, we are after converting to, while <code>destinationExtension</code> holds the extension, such as <code>.ogg</code>, of the file type we are after converting to. Update your <code>Main</code> method so that it looks as follows:<pre>static void Main(string[] args)
{
Console.Write("Enter Source Directory: ");
_baseDirectory = Console.ReadLine();
Console.Write("Enter Source Extension: ");
_sourceExtension = Console.ReadLine();
Console.Write("Enter Destination Extension: ");
_destinationExtension = Console.ReadLine();
new Program().BatchConvert();
}</pre></li>
				<li>In our <code>Main</code> method, we have requested that the user enters the source directory, source extension, and destination extension. Then, we set out member <a id="_idIndexMarker079"/>variables and called the <code>BatchConvert</code> method. Let's add our <code>BatchConvert</code> method:<pre>private void BatchConvert()
{
var directory = new DirectoryInfo(_baseDirectory);
ProcessFolder(directory);
}</pre></li>
				<li>The <code>BatchConvert</code> method creates a new <code>DirectoryInfo</code> object called <code>directory</code> and then <a id="_idIndexMarker080"/>passes the <code>directory</code> object into the <code>ProcessFolder</code> method. Let's add this method now:<pre>private void ProcessFolder(DirectoryInfo 
    directoryInfo)
{
Console.WriteLine($"Processing Directory: 
    {directoryInfo.FullName}");
var fileInfos = directoryInfo.EnumerateFiles();
var directorieInfos = directoryInfo.
    EnumerateDirectories();
       foreach (var fileInfo in fileInfos)
             if (fileInfo.Extension.Replace(".", "") 
                 == sourceExtension)
                    ConvertFile(fileInfo);
foreach (var dirInfo in directorieInfos)
             ProcessFolder(dirInfo);
}</pre></li>
				<li>The <code>ProcessFolder</code> method outputs a message to the screen so that the user <a id="_idIndexMarker081"/>knows what folder is being processed. Then, it obtains an enumeration of the <code>FileInfo</code> and <code>DirectoryInfo</code> objects from the <code>directoryInfo</code> parameter. After this, it converts all the files in that folder that have the required source file extension. Once all the files have been processed, each of the <code>DirectoryInfo</code> objects is processed by calling the <code>ProcessFolder</code> method recursively. Finally, let's add our <code>ConvertFile</code> method:<pre>private void ConvertFile(FileInfo fileInfo)
{    
}</pre></li>
				<li>Our <code>ConvertFile</code> method takes a <code>FileInfo</code> parameter. This parameter contains the file that is to undergo conversion. The remaining code will be added to this <code>ConvertFile</code> method. Add the following three variables:<pre>var timeout = 10000;
var source = $"\"{fileInfo.FullName}\"";
var destination = $"\"{fileInfo.FullName.Replace
     (_sourceExtension, _destinationExtension)}\"";</pre></li>
				<li>The <code>timeout</code> variable is set to 10 seconds. This gives the process 10 seconds to process each file. The <code>source</code> variable contains the full name of the file to be converted, while the <code>destination</code> variable contains the full path of the newly converted file. Now, add the check to see if the converted file exists:<pre>if (File.Exists(fileInfo.FullName.Replace
     (_sourceExtension, _destinationExtension)))
{
Console.WriteLine($"Unprocessed: {fileInfo.FullName}");
       return;
}</pre></li>
				<li>If the <code>destination</code> file exists, then the conversion has already taken place, so we do <a id="_idIndexMarker082"/>not need to process the file. So, let's output a message to the user to inform them that the file is unprocessed, and then return from the method. Let's add the code to perform the conversion:<pre>Console.WriteLine($"Converting file: {fileInfo.FullName}
    from {_sourceExtension} to {_destination
        Extension}.");
using var ffmpeg = new Process
{
StartInfo = {
             FileName = @"C:\Tools\ffmpeg\bin
                \ffmpeg.exe",
              Arguments = $"-i {source} 
                {destination}",
              UseShellExecute = false,
              RedirectStandardOutput = true,
              RedirectStandardError = true,
              CreateNoWindow = true
}
};
ffmpeg.EnableRaisingEvents = false;
ffmpeg.OutputDataReceived += (s, e) =&gt; Debug.WriteLine
     ($"Debug: e.Data");
ffmpeg.ErrorDataReceived += (s, e) =&gt; Debug.WriteLine
     ($@"Error: {e.Data}");
ffmpeg.Start();
ffmpeg.BeginOutputReadLine();
ffmpeg.BeginErrorReadLine();
ffmpeg.WaitForExit(timeout);</pre></li>
				<li>Here, we <a id="_idIndexMarker083"/>output a message to the window informing the user of the file being processed. Then, we instantiate a new process that executes <code>ffmpeg.exe</code> and converts an audio file from one format into another, as specified by the user. The converted file is then saved in the same directory as the original file.</li>
				<li>With that, we have completed our sample project. So, let's see it running. On an external hard disk, I have some Ghosthack audio samples that I own. The files are in <code>.wav</code> file format. However, they need to be transformed into <code>.ogg</code> files to be used in an Android program that I use. You can use your own audio file or music folders.<p class="callout-heading">Note</p><p class="callout">If you don't have any audio files to hand to test this small program, you can download some royalty-free sounds from <a href="https://www.bensound.com">https://www.bensound.com</a>. You can check the following page for links to various public music domains: <a href="https://www.lifewire.com/public-domain-music-3482603">https://www.lifewire.com/public-domain-music-3482603</a>.</p></li>
				<li> Fill out the questions and press <em class="italic">Enter</em>:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_1.12.jpg" alt="Figure 1.12 – Our file converter showing the directory and file conversion formats&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Our file converter showing the directory and file conversion formats</p>
			<p>The <a id="_idIndexMarker084"/>program will now process all files and folders under the specified parent folder and process them.</p>
			<p>The program is working as expected in its MSIL form. However, we can see the delay in performing the file conversions. Let's compile our file converter into a single native executable, and then see if it is visibly any faster:</p>
			<ol>
				<li value="1">Open the Visual Studio Developer Command Prompt as an administrator and navigate to the folder that contains your solution and project file. When publishing the file, it is worth noting that the <code>TargetFramework</code> property of the project should also be updated to netcoreapp3.1; otherwise, this may not work – that is, if it is set to <code>net5.0</code>. Type the following command and then press <em class="italic">Enter</em>:<pre>dotnet publish --framework netcoreapp3.1 -
    p:PublishSingleFile=true --runtime win10-x64</pre></li>
				<li>When the command has finished running, your command window should look as follows:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_1.13.jpg" alt="Figure 1.13 – The Developer Command Prompt in administrative mode showing the native compilation output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – The Developer Command Prompt in administrative mode showing the native compilation output</p>
			<ol>
				<li value="3">If you <a id="_idIndexMarker085"/>navigate to the publish directory, you will see the following output:</li>
			</ol>
			<div><div><img src="img/B16617_Figure_1.14.jpg" alt="Figure 1.14 – Windows Explorer displaying the output files resulting from native compilation &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – Windows Explorer displaying the output files resulting from native compilation </p>
			<ol>
				<li value="4">Run the <code>CH01_NativeCompilation.exe</code> file. You will see that <code>.wav</code> files are processed into <code>.ogg</code> files much quicker.</li>
			</ol>
			<p>In this section, we learned how to write a console app. We compile the console app to MSIL and then compile the console app into a single native executable file. Visually, from the user's perspective, the file processes batch audio files much quicker in native form than in MSIL form.</p>
			<p>Now, let's learn how to improve Windows Store applications.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Improving Windows Store performance</h1>
			<p>Here are <a id="_idIndexMarker086"/>some basic tips for improving the performance of Windows Store applications:</p>
			<ul>
				<li><strong class="bold">Perform the Microsoft Store app performance assessment</strong>: For information on how to do this, visit <a href="https://docs.microsoft.com/en-us/windows-hardware/test/assessments/microsoft-store-app-performance">https://docs.microsoft.com/en-us/windows-hardware/test/assessments/microsoft-store-app-performance</a>.</li>
				<li><strong class="bold">Understand the Microsoft Store app performance assessment's Results</strong>: To help you understand the results of the Windows Store App Performance Assessment, visit <a href="https://docs.microsoft.com/en-us/windows-hardware/test/assessments/results-for-the-microsoft-store-app-performance-assessment">https://docs.microsoft.com/en-us/windows-hardware/test/assessments/results-for-the-microsoft-store-app-performance-assessment</a></li>
				<li><strong class="bold">Address the issues highlighted in the Microsoft Store app performance assessment results</strong>: The main areas to focus on are any that have issues highlighted in dark purple, followed by issues marked in medium purple. The primary metrics will be on Launch:Warm, Launch:Cold, Post Launch, Idle, and Suspend. You also need to pay attention to processor and storage usage, as well as processor and storage I/O delays, registry flushes, time accounting, missing <a id="_idIndexMarker087"/>symbols, long-running <strong class="bold">Deferred Procedure Calls</strong> (<strong class="bold">DPCs</strong>), and <strong class="bold">Interrupt Service Routines</strong> (<strong class="bold">ISRs</strong>) that can <a id="_idIndexMarker088"/>be perceived by the end user as performance issues.</li>
			</ul>
			<p>In the next section, we'll learn how to improve performance with ASP.NET.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Improving ASP.NET performance</h1>
			<p>Here are some <a id="_idIndexMarker089"/>basic tips for improving the performance of web applications and APIs:</p>
			<ul>
				<li><strong class="bold">Perform baseline measurements</strong>: Before making changes to the performance of your web application or API, take a baseline reading of your program's performance. This way, you can measure any adjustments to see if they improve performance or slow things down.</li>
				<li><strong class="bold">Begin by optimizing the code with the largest impact</strong>: When you have completed your baseline measurements, start performance tuning on the piece of code that is the least performant and that has the biggest impact on your program's performance. This will provide you with your biggest win.</li>
				<li><strong class="bold">Enable HTTP compression</strong>: To reduce the size of transmitted files over HTTP/HTTPS and improve network performance, enable compression. There are two types of compression. GZIP compression has been around for many years and is the <a id="_idIndexMarker090"/>de facto compression mechanism; it can reduce a file's size by one-third. An alternative compression mechanism is Brotli. Most major browsers have had support for this compression mechanism since 2016/2017.</li>
				<li><strong class="bold">Reduce TCP/IP connection overheads</strong>: Reducing HTTP requests seriously improves HTTP communication performance. Each request uses network and hardware resources. When a hardware and software-specific number of connections is established, performance will start to show signs of degrading. This can be mitigated by reducing the number of HTTP requests.</li>
				<li><strong class="bold">Use HTTP/2 over SSL</strong>: HTTP/2 over SSL provides various performance improvements of using HTTP. Multiplexed streams provide bi-directional sequences of text format frames. Server push enables a server to push cacheable data to the client in anticipation that the client may use it. Binary protocols have a lower overhead when it comes to parsing data and they are less prone to errors. Binary protocols offer more security and have better network utilization There are many more optimizations that you gain when you switch to HTTP/2 over SSL. </li>
				<li><strong class="bold">Employ minification</strong>: Minification is the process of eliminating whitespace and comments in an HTML, CSS, or JavaScript web file. By making the size of the file smaller and by enabling compression, you can seriously speed up the network transmission of files, especially over poor Wi-Fi.</li>
				<li><strong class="bold">Place CSS in the head so that it loads first</strong>: To efficiently render a web page, it is best to load the complete CSS before rendering to prevent reflows.</li>
				<li><code>body</code> tag. For heavy framework-based applications, bootstrapping will be beneficial as only the JavaScript that is needed is loaded. An alternative is isomorphic JavaScript for rendering pages on both the client <a id="_idIndexMarker091"/>and the server. Isomorphic applications improve SEO, performance, and maintainability.</li>
				<li><strong class="bold">Reduce image size</strong>: Images can vary greatly in size. Reduce the size of the images that are used on a page. When used with minification and compression, this technique can help fancy-looking web pages load fast.</li>
			</ul>
			<p>You can find out more about other techniques for improving ASP.NET performance in the <em class="italic">Further reading</em> section. Now, let's summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Summary</h1>
			<p>At the start of this chapter, you downloaded the latest source for the C# programming language. Then, you restored it, built it, and ran various tests. After that, you built a Hello, World! program that demonstrated C# 9.0 features.</p>
			<p>Then, you learned what's new in .NET 5. This section covered topics on garbage collection, JIT compilation, text-based processing, threading and asynchronous operations, collections, LINQ, networking, and Blazor. We also covered the new performance-based APIs and analyzers. From what was covered, you now have a high-level appreciation of the many performance improvements made by Microsoft and third parties to the new version of the .NET programming language. These performance improvements are a solid reason to move to .NET 5. But another compelling reason is also the move to .NET for true cross-platform development from a single code base.</p>
			<p>After reviewing the performance improvements and additions to .NET 5, we looked at the new C#10.0 features. You learned how to write a program with just one line of code using top-level statements. Then, you learned how to implement init-only properties, records, new pattern-matching features, new expressions with targeted types, and covariant returns. From reviewing the new additions to the C# 9.0 language, you learned how to compile and run code in MSIL, and then compile and run native code in a single executable file. Visually, the end user experience was shown to be better when using the native binary over the MSIL assembly. For the example, we used a simple audio file format converter.</p>
			<p>You were then provided with some guidance on how to improve Windows Store app performance. Links to the official Microsoft documentation were presented to you to help you generate performance reports, along with how to understand the results of the performance assessment. This guidance also highlighted the main metrics to pay attention to. Finally, we considered some ways in which you can improve the performance of your ASP.NET websites and APIs. In the <em class="italic">Further reading</em> section, you will find a link to the official Microsoft ASP.NET documentation. This documentation will help you architect and build quality websites. </p>
			<p>Furthermore, in the <em class="italic">Further reading</em> section, you will find some links to documentation and the GitHub repository for .NET MAUI, which is due to be released in 2021 in concert with .NET 6. This user interface technology is an evolution of Xamarin.Forms with evolutionary changes based on customer research. It does look rather promising. </p>
			<p>In the next chapter, we will be looking at .NET interoperability. But before that, work through this chapter's questions to see how well everything has sunk in.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Questions and exercises</h1>
			<p>Answer the following questions regarding this chapter:</p>
			<ol>
				<li value="1">What areas of .NET are being improved by .NET 6?</li>
				<li>What is new to C# 10.0?</li>
				<li>What tools are available for native compilation in .NET?</li>
				<li>How can you improve the Windows Store app's performance?</li>
				<li>How can you speed up ASP.NET?</li>
				<li>Investigate the state of .NET MAUI, the future of frontend desktop and mobile development that is still undergoing development.</li>
				<li>Write some console applications and practice using the new features of .NET 6 and C# 10.0.</li>
				<li>Use Benchmark.NET to benchmark one of your small applications, and then upgrade it to use .NET 6 and C# 10.0. Measure its performance without making any changes if possible, and then measure its performance again. See if you notice any performance improvements by simply upgrading to C# 10.0 and .NET 6.<p class="callout-heading">Note</p><p class="callout">The answers to questions 4 and 5 can be found in the external reference sources provided in their respective sections.</p></li>
			</ol>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>Download .NET 6: <a href="https://dotnet.microsoft.com/download/dotnet/6.0">https://dotnet.microsoft.com/download/dotnet/6.0</a>.</li>
				<li>Download Visual Studio Preview: <a href="https://visualstudio.microsoft.com/vs/preview/">https://visualstudio.microsoft.com/vs/preview/</a>.</li>
				<li><em class="italic">Introducing the .NET multi-platform app UI</em>: <a href="https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/">https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/</a>.</li>
				<li>.NET MAUI GitHub page: <a href="https://github.com/dotnet/maui">https://github.com/dotnet/maui</a>.</li>
				<li>Learn from Microsoft how to build quality Windows 10 apps that reflect your brand: <a href="https://docs.microsoft.com/en-us/windows-hardware/get-started/">https://docs.microsoft.com/en-us/windows-hardware/get-started/</a>.</li>
				<li>Learn from Microsoft how to architect and build quality websites using Microsoft technology: https://dotnet.microsoft.com/apps/aspnet.</li>
				<li>C#9.0 early review: <a href="https://medium.com/dev-genius/c-9-early-review-5bcd88296c54#:~:text=Relax%20ordering%20of%20ref%20and%20partial%20modifiers%20Currently%2C,is%20a%20ref%20struct%2C%20ref%20must%20appear%20">https://medium.com/dev-genius/c-9-early-review-5bcd88296c54#:~:text=Relax%20ordering%20of%20ref%20and%20partial%20modifiers%20Currently%2C,is%20a%20ref%20struct%2C%20ref%20must%20appear%20</a>.</li>
				<li><em class="italic">File I/O Improvements in .NET 6</em>: <a href="https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/">https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/</a>.</li>
			</ul>
		</div>
	</body></html>