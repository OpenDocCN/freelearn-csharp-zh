<html><head></head><body>
        

                            
                    <h1 class="header-title">Patterns - Dependency Injection</h1>
                
            
            
                
<p>In <a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank">Chapter 7</a>, <em>Interception</em>, we completed our journey in exploring the pillars of <strong>Dependency Injection</strong> (<strong>DI</strong>). Now, it's time to learn the principles behind Dependency Injection and explore how to apply different techniques to implement those principles to acquire a loosely coupled architecture. There are different techniques to implement DI, but if you are not choosing an appropriate one while you code, you will become a troublemaker for the project.</p>
<p>In this chapter, we will discuss different techniques, also known as <strong>Patterns of Dependency Injection</strong> with proper illustrations. I will shed light on use cases, and pros and the cons so that it will be easy for you to visualize the problems which you currently see in your application. That will eventually persuade you to adapt to these patterns in your app resulting in a better architecture.</p>
<p>Constructor Injection is the most important one among all these patterns. However, as developers, we should understand every available pattern. It's always recommended to use the best fit pattern for a particular scenario by analyzing the frequency and cases of using the dependency.</p>
<p>While most of these patterns address some specific context, always remember Constructor Injection is the simplest and can be opted without any confusion.</p>
<p>The following topics would be covered in this chapter:</p>
<ul>
<li>Dependency Inversion Principle</li>
<li>Inversion of Control</li>
<li>DI patterns</li>
<li>The proper way to implement patterns</li>
<li>The pros and cons of each pattern</li>
<li>Adoption and examples in .NET Core 2.0</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency Inversion Principle</h1>
                
            
            
                
<p>The SOLID principles have a D in it, which is called the <strong>Dependency Inversion Principle</strong> (<strong>DIP</strong>). The following statement is by Robert C. Martin on DIP:</p>
<p>"High-level modules should not depend on low-level modules. Both should depend on abstractions."</p>
<p>You can consider a High-level Module as a Business Module of one application comprising the complex logic of the application, and a Low-level Module as the classes that actually perform the basic or primary functions such as writing to disks, interaction with the database, and so on, with the commands received from the Business Module.</p>
<p>When objects of a High-level Module interact with objects of a Low-level Module, they generate a coupling. This happens because you have to refer to the classes of Low-level Modules in order to access them for instantiation. However, the DIP does not recommend this. The principle encourages us to reduce the coupling so that the modules live isolated. It also explains how this can be done through abstractions. Both should commit themselves to abstractions instead of directly depending on each other. Let's understand this point with an example.</p>
<p>Consider one class called <kbd>FeedbackService</kbd> that is saving one <kbd>Feedback</kbd> details in the database:</p>
<pre>    public class FeedbackService : IFeedbackService<br/>    {<br/>      private INotifier notifier;<br/><strong>      public void SaveFeedback(Feedback feedback, NotifyType notify)</strong><br/><strong>      {</strong><br/><strong>        SaveFeedbackToDb(feedback);</strong><br/><strong>        SendNotification(feedback, notify);</strong><br/><strong>      }</strong><br/>      private void SendNotification(Feedback feedback, NotifyType notify)<br/>      {<br/>        if (notify == NotifyType.Email)<br/>        {<br/>            notifier = <strong>new EmailNotifier();</strong><br/>        }<br/>        else if (notify == NotifyType.Sms)<br/>        {<br/>            notifier = <strong>new SmsNotifier();</strong><br/>        }<br/>        else if (notify == NotifyType.Voice)<br/>        {<br/>            notifier = <strong>new VoiceNotifier();</strong><br/>        }<br/>        else<br/>        {<br/>            throw new ArgumentException("No matched notify type <br/>              found.", notify.ToString());<br/>        }<br/>        notifier.SendNotification(feedback);<br/>      }<br/>      private int SaveFeedbackToDb(Feedback feedback)<br/>      {<br/>        // Save details in db.<br/>        Console.WriteLine("Db Saving Started.");<br/>        return 1;<br/>      }<br/>    }</pre>
<p>The principal method here is <kbd>SaveFeedback</kbd>, which not only saves the feedback but also sends a notification. It takes the <kbd>Feedback</kbd> object and notifies type as parameters. When feedback is saved, usually one notification is sent to the customer and admin.</p>
<p><kbd>FeedbackService</kbd> implements an interface which can be coded like the following:</p>
<pre>    public interface IFeedbackService<br/>    {<br/>      void SaveFeedback(Feedback feedback, NotifyType notify);<br/>    }</pre>
<p><kbd>INotifier</kbd> is an interface which is implemented by all the notifier types. Have a look at the following code:</p>
<pre>    public interface INotifier<br/>    {<br/>      void SendNotification(Feedback feedback);<br/>    }<br/>    public class EmailNotifier : INotifier<br/>    {<br/>      public void SendNotification(Feedback feedback)<br/>      {<br/>        Console.WriteLine("Email Notification starts!");<br/>      }<br/>    }<br/>    public class SmsNotifier : INotifier<br/>    {<br/>      public void SendNotification(Feedback feedback)<br/>      {<br/>        Console.WriteLine("Sms Notification starts!");<br/>      }<br/>    }<br/>    public class VoiceNotifier : INotifier<br/>    {<br/>      public void SendNotification(Feedback feedback)<br/>      {<br/>        Console.WriteLine("Voice Notification starts!");<br/>      }<br/>    }</pre>
<p>Note that I have not defined the body of the methods since they are here in the book for illustration. You can write logic and implement yours.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Problems</h1>
                
            
            
                
<p>The approach seems correct, but it is not recommended and does not respect software design principles which are described as follows:</p>
<p>Clearly, we are violating the Single Responsibility Principle with this approach. <kbd>FeedbackService</kbd> is taking the responsibility to save a feedback as well as sending notifications after success.</p>
<p>Tight coupling exists with the concrete classes <kbd>Feedback</kbd> and other <kbd>Notifier</kbd> classes such as <kbd>EmailNotifier</kbd>, <kbd>SmsNotifier</kbd>, and <kbd>VoiceNotifier</kbd>.</p>
<p>Our most popular, the <kbd>new</kbd> keyword is used inside the <kbd>SendNotification</kbd> of the <kbd>FeedbackService</kbd> class to decide which <kbd>Notifier</kbd> instance to create according to the input <kbd>notify</kbd> of type <kbd>enum</kbd>, which can be defined as follows:</p>
<pre>    public enum NotifyType<br/>    {<br/>      Email = 1,<br/>      Sms = 2,<br/>      Voice = 3<br/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Solution</h1>
                
            
            
                
<p>The solution should address all the issues with the preceding approach, so that the resulting architecture becomes loosely coupled. Let's get started.</p>
<p class="mce-root">The first thing is to separate the responsibilities from the <kbd>FeedbackService</kbd> class. This can be easily be done by transferring the <kbd>SendNotification</kbd> responsibility to the notifier instead of having it inside the class.</p>
<p class="mce-root">So, we can inject the <kbd>INotifier</kbd> type dependency inside the constructor. Thus, we can do <kbd>_notifier.SendNotification()</kbd> to send an injected type notification. Also, we changed the signature of <kbd>SaveFeedback</kbd>, which now accepts the <kbd>IFeedback</kbd> type parameter.</p>
<p class="mce-root"><kbd>FeedbackService</kbd> can be rewritten as follows:</p>
<pre>    public class FeedbackService : IFeedbackService<br/>    {<br/>      private readonly INotifier _notifier;<br/>      public FeedbackService(<strong>INotifier notifier</strong>)<br/>      {<br/>        _notifier = notifier;<br/>      }<br/><br/>      public void SaveFeedback(<strong>IFeedback feedback</strong>)<br/>      {<br/>        SaveFeedbackToDb(feedback);<br/><br/>        _notifier.SendNotification(feedback);<br/>      }<br/>      private int SaveFeedbackToDb(IFeedback feedback)<br/>      {<br/>        throw new NotImplementedException();<br/>      }<br/>    }</pre>
<p>Now the <kbd>Service</kbd> does not depend upon the concrete implementations, and we eliminated the <kbd>if...else...if</kbd> clumsy codes from the class to decide which notification to send. The decision of notification type is now with the composer of the <kbd>Service</kbd> class instance. That can be done inside the Composition Root, something like the following:</p>
<pre>    var feedbackService = new FeedbackService(new SmsNotifier());<br/>    feedbackService.SaveFeedback(new Feedback());</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Inversion of Control (IoC)</h1>
                
            
            
                
<p><strong>Inversion of Control</strong> (<strong>IoC</strong>) is a Software Design Pattern which supports the <strong>Dependency Inversion Principle</strong> (<strong>DIP</strong>). There is a lot of confusion between these two terms, but if you closely observe, the names will clarify the doubts themselves.</p>
<p>The DIP is a principle or set of rules kind of theory. On the other hand, Inversion of Control is a pattern of well-defined steps we can follow to make our code DIP friendly. You have already experienced the steps of IoC, haven't you? </p>
<p>Notice the steps we followed to take away the control of object creations from the <kbd>FeedbackService</kbd> class to an external location, which can be considered as a Composition Root. We did the following to be precise:</p>
<ol>
<li>Introduce interfaces for the concrete dependency: <kbd>INotifier</kbd> and <kbd>IFeedback</kbd>.</li>
<li>Update concrete dependencies to implement from interface: <kbd>EmailNotifier</kbd>, <kbd>SmsNotifier</kbd>, and <kbd>VoiceNotifier</kbd>.</li>
<li>Provide dependency to the constructor and store in a <kbd>private readonly </kbd>member:</li>
</ol>
<pre>        public FeedbackService(INotifier notifier)<br/>        {<br/>          _notifier = notifier;<br/>        }</pre>
<ol start="4">
<li>With the private member, we can call the method of the dependency class directly:  <kbd>_notifier.SendNotification(feedback);</kbd> </li>
<li>Instantiate <kbd>Service</kbd> with dependency in the Composition Root:<br/>
<kbd>var feedbackService = new FeedbackService(new SmsNotifier());</kbd>.</li>
</ol>
<p>So, someone else is now trying to manage the object creation and lifetime. Before we executed those steps, the class itself was instantiating all its dependencies inside it using the <kbd>new</kbd> keyword. Therefore, we inverted the controls, and flow of management of objects is done in reverse through someone else, isn't it! That's it, this is what IoC is trying to express.</p>
<p>The last step involves injecting the dependency object into the constructor of <kbd>Service</kbd>, and the pattern is known as the <strong>Constructor Injection Pattern</strong>. Let's explore this pattern with other important ones in the next section.</p>
<p>The following is the diagram representing the DIP and non-DIP implementations. Notice the arrows. In non-DIP, dependencies are managed by the class itself so, arrows pointing to concrete class objects, whereas, in DIP, an arrow is coming into the class, as the dependency objects are sent by someone else:</p>
<div><img height="240" width="428" src="img/c6784d17-712d-41e5-a556-ff8a8142d1a6.png"/></div>
<p>When a class manages all its dependencies itself, it is regarded as a <strong>Control Freak</strong>, which is an anti-pattern. We will discuss more about this anti-pattern in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Patterns</h1>
                
            
            
                
<p class="mce-root">The following are the four important patterns by which we can implement Dependency Injection:</p>
<ul>
<li>Constructor Injection Pattern</li>
<li>Property Injection Pattern</li>
<li>Method Injection Pattern</li>
<li>Ambient Context</li>
</ul>
<p>Let's explore one by one with illustrations, the advantages, and disadvantages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constructor Injection pattern</h1>
                
            
            
                
<p>As the name suggests, Injection will take the help of the constructor. In other words, the constructor is the target of injection. Injection is performed by supplying the dependency to the constructor as an argument. This is the most common technique to inject dependencies into classes.</p>
<p>The client calls the constructor to create the object and during the instantiation, the dependency gets injected, which is depicted as follows:</p>
<div><img height="176" width="276" src="img/923d38e0-dcca-4797-a364-e90566508b8b.png"/></div>
<p>For example, a company, initially, was set up with only one department called Engineering. Let's design the <kbd>Employee</kbd> class for this company as follows:</p>
<pre>    public class Employee
    {
        public int EmployeeId;
        public string EmployeeName;
        public Department EmployeeDept;

        public Employee(int id, string name)
        {
           EmployeeId = id;
           EmployeeName = name;
           EmployeeDept = new Engineering();
        }
    }</pre>
<p>We have a constructor which takes <kbd>id</kbd> and <kbd>name</kbd> as parameters and initialises an <kbd>Employee</kbd> object. As I told you, the company started only with Engineering as a department, so it's obvious that we assign <kbd>EmployeeDept</kbd> with a new object of the <kbd>Engineering</kbd> class. <kbd>Engineering</kbd> and <kbd>Department</kbd> classes would look something as follows:</p>
<pre>    public class Department
    {
      public int DeptId { get; set; }
      public string DeptName { get; set; }
    }
    public class Engineering : Department {  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The problem</h1>
                
            
            
                
<p>Can you foresee a complex issue in this design? What if the company grows and builds another department like marketing? How would we incorporate this new department into the <kbd>Employee</kbd> class? How to say a particular employee belongs to the marketing department?</p>
<p>Unfortunately, there is no way to do this here, as the <kbd>Employee</kbd> class is tightly coupled with the <kbd>Engineering</kbd> class. This not only leads to a bad design, but developers also face hurdles for unit testing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The solution</h1>
                
            
            
                
<p>So, what is the solution? We just need a <kbd>Department</kbd> object when we instantiate with <kbd>Employee</kbd>. How about providing the required type of <kbd>Department</kbd> (engineering/marketing) reference directly to the <kbd>Employee</kbd> class?</p>
<p>That's super easy. Let's have a look at the modification.</p>
<ol>
<li>First, design an interface <kbd>IDepartment</kbd> which can be implemented by the <kbd>Department</kbd> class:</li>
</ol>
<pre>        public interface IDepartment
        {
          int DeptId { get; set; }
          string DeptName { get; set; }
        }
        public class Department : IDepartment
        {
          public int DeptId { get; set; }
          public string DeptName { get; set; }
        }</pre>
<ol start="2">
<li>Instead of having a property of <kbd>Department</kbd> type, now we will have that of type <kbd>IDepartment</kbd>. Basically, we can now allow different types of departments with this technique. We will see this in action in a while. Also, see how this property is initialized inside the constructor using the param <kbd>dept</kbd> of type <kbd>IDepartment</kbd>.</li>
</ol>
<pre>        public class Employee
        {
          public int EmployeeId;
          public string EmployeeName;
          public IDepartment EmployeeDept;

          public Employee(int id, string name, IDepartment dept)
          {
            EmployeeId = id;
            EmployeeName = name;
            EmployeeDept = dept;
          }
        }</pre>
<ol start="3">
<li>Now have a look at the classes for different departments. They inherit from <kbd>Department</kbd>, thereby implementing <kbd>IDepartment</kbd>:</li>
</ol>
<pre>       public class Engineering : Department
       {
         public Engineering()
         {
           DeptName = "Engineering";
         }
       }
       public class Marketing: Department
       {
         public Marketing()
         {
            DeptName = "Marketing";
         }
       }</pre>
<ol start="4">
<li>Creating employees with a different department is easy now. If we create such objects inside the <kbd>main</kbd> method, we can do the following:</li>
</ol>
<pre>        static void Main(string[] args)
        {
          var engineering = new Engineering();
          Employee emp = new Employee(1, "Sasmita Tripathy",<br/>            <strong>new Engineering()</strong>);
          var marketing = new Marketing();
          Employee emp1 = new Employee(2, "Ganeswar Tripathy",<br/>            <strong>new Marketing()</strong>);
          Console.WriteLine("Emp Name: " + emp.EmployeeName + ",<br/>            Department: " + emp.EmployeeDept.DeptName);
          Console.WriteLine();
          Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",<br/>            Department: " + emp1.EmployeeDept.DeptName);
          Console.ReadLine();
        }</pre>
<p>You can see how a particular <kbd>Department</kbd> object is passed to the <kbd>Employee</kbd> constructor to create different employees who belong to different departments. That is the injection we did. We injected objects of type <kbd>IDepartment</kbd> (<kbd>Engineering</kbd> and <kbd>Marketing</kbd>) into the <kbd>Employee</kbd> constructor.</p>
<p>The following is the output:</p>
<div><img height="138" width="529" src="img/192956cf-7f83-4a52-95ee-0a24461d5e0d.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Curveball</h1>
                
            
            
                
<p>You must be thinking everything in the preceding was perfect. But it is not. Let's analyze it:</p>
<pre>     var engineering = new Engineering();
     Employee emp = new Employee(1, "Sasmita Tripathy", <br/>       new Engineering());
     emp.EmployeeDept = new Marketing();</pre>
<p>You can see I created an object with employee department as <kbd>Engineering</kbd>. Then in the next line, we can easily change the department by assigning a <kbd>Marketing</kbd> object to it. This should be completely avoided.</p>
<p>To do that, the field must be marked as <kbd>private</kbd> and <kbd>readonly</kbd>.</p>
<pre>    private readonly IDepartment EmployeeDept;</pre>
<p>It's not strictly recommended, but we should definitely follow this so that developers can't unnecessary hijack the actual values.</p>
<p>Secondly, the constructor does not handle the case where the dependent instance is received as <kbd>null</kbd>. The constructor can be altered as follows:</p>
<pre>    public Employee(int id, string name, IDepartment dept)
    {   
        EmployeeDept = dept ?? throw new ArgumentNullException();
        EmployeeId = id;
        EmployeeName = name;
   }</pre>
<p>Now here is the important thing, the constructor not only does the job of pushing the dependent instance to a <kbd>private</kbd> property, but also inserts values to other member variables such as <kbd>EmployeeId</kbd> and <kbd>EmployeeName</kbd>. This is against the Single Responsibility Principle. Therefore, we should have the constructor only handling the dependency thing and nothing else:</p>
<pre>    public Employee(IDepartment dept)
    {   
        EmployeeDept = dept ?? throw new ArgumentNullException();
    }</pre>
<p>Also, writing like this would guarantee that when an object is created, it will contain the dependency within it. At the same time, this will be valued only if the class is fully dependent on the dependency henceforth.</p>
<p>Let me summarise the points quickly as follows:</p>
<ul>
<li>The class which is dependent must expose a <kbd>public</kbd> constructor where the dependency can be injected</li>
<li>If more than one dependency is required, then we can add more arguments to the constructor</li>
<li>The dependent class should mark the member variable as <kbd>private readonly</kbd> where dependency instance will be assigned</li>
<li>The dependent class constructor should only do the job of managing the dependency and nothing else</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Injecting with .NET Core 2.0</h1>
                
            
            
                
<p>We saw every example previously, where we initialised using the <kbd>new</kbd> keyword. However, we should use the .NET Core 2.0 way of resolving the dependency:</p>
<pre>    static void Main(string[] args)
    {
       var serviceProvider = new ServiceCollection()
       .AddTransient&lt;IDepartment, Engineering&gt;()
       .AddTransient&lt;Employee&gt;()
       .BuildServiceProvider();

       var emp = serviceProvider.GetService&lt;Employee&gt;();
       emp.EmployeeId = 1;
       emp.EmployeeName = "Sasmita Tripathy";

       var emp1 = serviceProvider.GetService&lt;Employee&gt;();
       emp1.EmployeeId = 2;
       emp1.EmployeeName = "Ganeswar Tripathy";
        
       Console.WriteLine("Emp Name: " + emp.EmployeeName + ",<br/>          Department: " + emp.GetEmployeeDepartment());
       Console.WriteLine();
       Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",<br/>          Department: " + emp1.GetEmployeeDepartment());

        Console.ReadLine();
}</pre>
<p>We use the <kbd>ServiceCollection</kbd> object to register the interfaces with the type we expect when it is resolved. When we do <kbd>serviceProvider.GetService();</kbd>, it returns an employee object with the department as <kbd>Engineering</kbd> since we registered <kbd>IDepartment</kbd> as <kbd>Engineering</kbd> in the collection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation inside ASP.NET Core 2.0</h1>
                
            
            
                
<p>Let's have a closer look at ASP.NET Core 2.0 internal codes for <kbd>ControllerActivatorProvider.cs</kbd> inside <kbd>Microsoft.AspNetCore.Mvc.Core</kbd> <kbd>Controllers</kbd> to understand how Constructor Injection is implemented.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ControllerActivatorProvider.cs</h1>
                
            
            
                
<p>I will show a screenshot of the class where the constructor is written:</p>
<div><img height="419" width="557" src="img/91b877ef-c090-4344-a6c7-592199f1c23f.png"/></div>
<p class="mce-root"><kbd>IControllerActivator</kbd> is the dependency which is injected into the constructor of this class. Then, it is using the instance to do some operation inside the class. We can easily find more of such kind of examples in .NET Core 2.0.</p>
<p>To see how this dependency is resolved, we can check the method <kbd>AddMvcCoreServices</kbd> of the <kbd>MvcCoreServiceCollectionExtensions.cs</kbd> class inside the <kbd>Microsoft.AspNetCore.Mvc.Core</kbd> <kbd>DependencyInjection</kbd>:</p>
<div><img height="207" width="607" src="img/84f0c2b9-30ec-40f1-8bbc-5edd42b9bdd4.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Importance of the Constructor Injection pattern</h1>
                
            
            
                
<p>As the injection is tied to the constructor, this means whenever you try to instantiate a particular class, we are 100% sure that the dependency is shipped or tied with the object created. The guarantee of having the dependency is ensured by the Guard Clause, which verifies the dependency as not <kbd>null</kbd> before assigning that to the <kbd>private readonly</kbd> data member. Otherwise, the construction of class throws an exception.</p>
<p>There is no possibility of having one object of such class without injecting the dependency. Thus, the state of the object is always valid with no discrepancies. Unit testing with mocks becomes easy with this approach. Let's have a look at the pros and cons too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages of the Constructor Injection pattern</h1>
                
            
            
                
<p>This is the most preferable way of respecting the concept of DI. Most DI containers target the constructors. It is also the most common and more widely used pattern for DI. The injected component can be used anywhere in the class because when you create the object, the injected dependency comes into the class automatically and stays in some variable. </p>
<p>Developers prefer this technique when classes require some external dependency to initiate all other operations. As a constructor is involved, an object becomes ready with the dependent object once it is instantiated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Disadvantages of the Constructor Injection pattern</h1>
                
            
            
                
<p>This is not so easy to implement when the class contains many constructors. Moreover, when the number of dependencies increases for a class, updating the constructor each time is not a feasible task.</p>
<p>When you have a number of arguments for a constructor by adding the dependency ones with the existing ones, the class will look messy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Property Injection pattern</h1>
                
            
            
                
<p>In this technique, instead of asking the constructor to support the injection, we will directly inject to the property of the class. Let's get started.</p>
<p>The following diagram depicts one property <kbd>EmployeeDept</kbd>, which can be injected directly with an <kbd>IDepartment</kbd> implementation:</p>
<div><img height="156" width="390" src="img/f37e69e5-b4e1-40e3-8395-a2b7c24b106b.png"/></div>
<p>The <kbd>Employee</kbd> class without the constructor argument for <kbd>IDepartment</kbd> and a new setter property will look something like the following:</p>
<pre>    public class Employee
    {
      public int EmployeeId;
      public string EmployeeName;

      <strong>private IDepartment _employeeDept;</strong>
      <strong>public IDepartment EmployeeDept
      {
        set
        {
          this._employeeDept = value;
        }
      }</strong>

      public Employee(int id, string name)
      {
         EmployeeId = id;
         EmployeeName = name;
      }
    }</pre>
<p>We just removed the <kbd>IDepartment</kbd> argument from the constructor because we are going to directly assign an <kbd>IDepartment</kbd> type object to the property <kbd>EmployeeDept</kbd>. This can be done while creating the <kbd>Employee</kbd> object as follows:</p>
<pre>    static void Main(string[] args)
    {
      Employee emp = new Employee(1, "Sasmita Tripathy")
      {
<strong>        EmployeeDept = new Engineering()</strong>
      };
        
      Employee emp1 = new Employee(2, "Ganeswar Tripathy")
      {
<strong>         EmployeeDept = new Marketing()</strong>
      };
      Console.WriteLine("Emp Name: " + emp.EmployeeName + ",<br/>         Department: " + emp.EmployeeDept.DeptName);
      Console.WriteLine();
      Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",<br/>         Department: " + emp1.EmployeeDept.DeptName);
      Console.ReadLine();
    }</pre>
<p>Thus, by doing <kbd>emp.EmployeeDept = new Engineering();</kbd>, we are directly pushing the <kbd>Engineering</kbd> object into the property <kbd>EmployeeDept</kbd>. The same thing is done for <kbd>emp1</kbd> too.</p>
<p>However, this code won't compile. We are missing something important here. Consider the following screenshot:</p>
<div><img src="img/dbb64f95-24c4-4dc0-bb7b-b52175be846e.png"/></div>
<p>The error is totally self-explanatory. We forgot to include the Getter block as we wanted to print the department name. Consider the following code snippet:</p>
<pre>    private IDepartment _employeeDept;
    public IDepartment EmployeeDept
    {
      get {
            return this._employeeDept;
      }
      set
      {
            this._employeeDept = value;
      }
    }</pre>
<p>Now, we are good. When you run it, you will see the same output as we got in the case of Constructor Injection.</p>
<p>Property Injection is preferred when there is an optional dependency required for the class. What that means is, if you don't supply the value, the class won't mind as it can run without this dependency. If the developer forgets to assign the dependency, it should not affect the flow of the app.</p>
<p>For instance, in our example, if you don't do anything with the property <kbd>EmployeeDept</kbd>, the class will behave as usual as long as you are not reading the property. In the next section, I will tell you how to beautify the code because the code is not yet perfect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Curveball</h1>
                
            
            
                
<p>The problems with the approach which we have taken can be any one of the following:</p>
<ul>
<li>If you don't assign anything to the property (as we developers forget sometimes being lazy), the output won't return you anything when you print.</li>
<li>You can assign null to the property as simply as <kbd>emp.EmployeeDept = null;</kbd>.</li>
<li>Once you assign a dependency to a property, you can easily assign another dependency easily, which might be a problem. This might happen accidentally, however, it will create side effects for the whole system at some point in time. Imagine a situation where you initialized the property with engineering and then changed that to marketing, which is wrong.</li>
</ul>
<p>To handle all these situations, we should introduce more protection to the property. Let's do this:</p>
<pre>    private IDepartment _employeeDept;
    public IDepartment EmployeeDept
    {
      get
      {
          if (this._employeeDept == null)
          this.EmployeeDept = new Engineering();
             return this._employeeDept;
      }
      set
      {
        if (value == null)
           throw new ArgumentNullException("value");
        if (this._employeeDept != null)
           throw new InvalidOperationException();

         this._employeeDept = value;
       }
     }</pre>
<p>Inside the setter, we check for <kbd>null</kbd> and throw an exception. Then, we again investigate whether it is already there and throw an <kbd>InvalidOperationException</kbd>. Likewise, in the Getter, we are assigning a default value as engineering when passed <kbd>null</kbd>. Thus, we guarded our property for all such difficult situations, as previously discussed.</p>
<p>Property Injection is not supported by the .NET Core built-in DI or IoC Container out of the box. Also, there is no such plan to bring this into the default container as of now. You have to use an external container such as Autofac to support this feature.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages of the Property Injection Pattern</h1>
                
            
            
                
<p>We can see the following advantages of having a Setter Injection Pattern:</p>
<ul>
<li>It does not require adding a new constructor or modifying an existing constructor.</li>
<li>This pattern comes in handy if the class has multiple dependencies of different types. Suppose there is a class which will use different types of logging such as logging, to text or logging to the database at the same time in different conditions, then having two setter properties where we can simply inject the required logger to do our task.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Disadvantages of the Property Injection Pattern</h1>
                
            
            
                
<p>Setters are not easy to identify in a particular design to inject some external dependency. Still, they are preferred in some situations. However, we should be careful while using the property which is injected because that might be <kbd>null</kbd>. There should be an extra check for <kbd>null</kbd>, everywhere where you want to use it. As we already discussed, protection must be provided to the property to avoid the inconsistent behavior.</p>
<p>Property Injection is considered as bad practice in most of the cases because it hides the dependencies. When the class is instantiated, there is no guarantee that the dependency object will be available for the class to do any operation, unlike Constructor Injection, where the dependency makes its way through during instantiation itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Method Injection Pattern</h1>
                
            
            
                
<p>As the name suggests, we will inject the dependency into a method like we did in the case of the constructor. This comes in handy when we want different types of dependency in different methods of a class.</p>
<p>Look at the following diagram, which tells us about the <kbd>AssignDepartment(IDepartment)</kbd> method taking <kbd>IDepartment</kbd> as a dependency inside the <kbd>Employee</kbd> class: </p>
<p>&gt;<img height="217" width="321" src="img/c4d5974f-df2b-4a27-b678-d84fa27f333f.png"/></p>
<p>The client can create an object of the <kbd>Employee</kbd> class and then fire <kbd>AssignDepartment</kbd> with the appropriate implementation of <kbd>IDepartment</kbd>, so that dependency is provided.</p>
<p>Let's see how the <kbd>Employee</kbd> class can be coded:</p>
<pre>    public class Employee
    {
        public int EmployeeId;
        public string EmployeeName;
        public IDepartment EmployeeDept;
        <br/>        // Default Constructor added for .NET Core 2.0 DI.<br/>        // So that it can automatically create the instance.<br/>        public Employee() { }
        <br/>        public Employee(int id, string name)
        {
          EmployeeId = id;
          EmployeeName = name;
        }

        <strong>public void AssignDepartment(IDepartment dept)
        {
           EmployeeDept = dept;
           // Other business logic if required.
        }</strong>
     }</pre>
<p>In this particular scenario, we have a method <kbd>AssignDepartment</kbd>, which takes one <kbd>IDepartment</kbd> type argument and then assigns that to the property. An <kbd>Employee</kbd> object can be created accordingly. Consider the following code snippet:</p>
<pre>    Employee emp = new Employee(1, "Sasmita Tripathy");
    emp.AssignDepartment(new Engineering());

    Employee emp1 = new Employee(2, "Ganeswar Tripathy");
    emp1.AssignDepartment(new Marketing());</pre>
<p class="mce-root">It also produces the same output as what we have already seen.</p>
<p>This pattern is useful when we require some dependency, only for some particular operation in a method and not for the whole class. Sometimes, the situation demands a small change which might be an edge case. To accommodate a small change, the simplest way would be to create a method and do whatever you want inside that (using dependencies passed in as arguments) instead of touching the constructors or properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Curveball</h1>
                
            
            
                
<p>In the case of Method Injection, by convention, we should also take care of null check to ensure that the dependency is available before using it:</p>
<pre>    public void AssignDepartment(IDepartment dept)
    {
      EmployeeDept = dept ?? throw new ArgumentNullException("value");
      // Other business logic if required.
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Injecting with .NET Core 2.0</h1>
                
            
            
                
<p>As we did in previous patterns, we will get the instance using the <kbd>GetService</kbd> method and then call the required method by injecting the dependency:</p>
<pre>    Employee emp = serviceProvider.GetService&lt;Employee&gt;();
    emp.EmployeeId = 1;
    emp.EmployeeName = "Sasmita Tripathy";
    emp.AssignDepartment(<strong>serviceProvider.GetService&lt;IDepartment&gt;()</strong>);

    Employee emp1 = serviceProvider.GetService&lt;Employee&gt;();
    emp1.AssignDepartment(<strong>serviceProvider.GetService&lt;IDepartment&gt;()</strong>);
    emp1.EmployeeId = 2;
    emp1.EmployeeName = "Ganeswar Tripathy";</pre>
<p>The next thing you will see is the following as the output:</p>
<div><img src="img/055312b3-271d-43f1-8df4-7710be1f7737.png"/></div>
<p>This happened because we have a constructor which is taking <kbd>integer</kbd> and <kbd>string</kbd> params. The provider is not aware of the process to resolve them, therefore, it throws an exception. The solution is to provide a default constructor, as the service provider is looking for it.</p>
<pre>    public Employee() {  }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation inside .NET Core 2.0</h1>
                
            
            
                
<p>We can get many instances of Method Injection Pattern usage inside the .NET Core 2.0. One of them is inside the simplest and frequently used class <kbd>MvcServiceCollectionExtensions.cs</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">MvcServiceCollectionExtensions.cs</h1>
                
            
            
                
<p>The <kbd>MvcServiceCollectionExtensions.cs</kbd> class contains the method <kbd>AddMvcCore</kbd>, which is an example of Method Injection. The following screenshot shows the method at a glance:</p>
<div><img src="img/9ee3d342-6b6d-4060-8b90-980db41fb1f6.png"/></div>
<p><kbd>IServiceCollection</kbd> is injected into the <kbd>AddMvcCore</kbd> method. After it has been verified as not <kbd>null</kbd>, the service collection is processed further. I am only showing a screenshot of the relevant codes to understand the concept. You can definitely find such examples in other classes.</p>
<p>The <strong>Interface Injection Pattern</strong> is something which we have already discussed in other patterns, where we injected the implementations such as  <kbd>IDepartment</kbd> which is an interface, into the constructor, property or a method. It's recommended to inject the implementation instead of the concrete class to avoid tight coupling. Interface injection allows us to achieve loose coupling along with abstraction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ambient context</h1>
                
            
            
                
<p>Ambient is an adjective meaning completely surrounding or encompassing. This means when we say Ambient context, it denotes some context, which would pertain its existence and behavior in the background or surrounding.</p>
<p>When many classes require the same dependency, we should follow some technique to make it available to every such client.</p>
<p>The patterns we discussed are not appropriate for such a scenario. If you try to make this possible using Constructor Injection, for example, you would end up adding a constructor for every class, having the same dependency injected to it.</p>
<p>Sounds more like a Cross-cutting Concern, doesn't it? To achieve this, we can simply add a static accessor for the dependency. This will make sure that the dependency is reachable to all the clients demanding it.</p>
<p>The concept can be visualized in the following diagram: </p>
<div><img height="231" width="470" src="img/e94dcddc-982d-4c55-8bbb-3f7a0f95a6ff.png"/></div>
<p>Let's consider an example to get a better understanding of the implementation. An abstract class <kbd>DepartmentProvider</kbd> can be designed to provide a static accessor called <kbd>Current</kbd>:</p>
<pre>    abstract class DepartmentProvider
    {
      private static DepartmentProvider current;
      public static DepartmentProvider Current
      {
        get
        {
           return current;
        }
        set
        {
           current = value;
        }
      }
      public virtual Department Department { get; }
    }</pre>
<p>We marked the class as <kbd>abstract</kbd> and there is a <kbd>virtual</kbd> property called <kbd>Department</kbd>, which will be accessed by any class requiring that.</p>
<p>Let's see how we can use the <kbd>Current</kbd> property. The following code uses the class <kbd>MarketingProvider</kbd> instance which is a derived class of  <kbd>DepartmentProvider</kbd>:</p>
<pre>    static void Main(string[] args)
    {
      var serviceProvider = new ServiceCollection()
      .AddTransient&lt;IDepartment, Engineering&gt;()
      .AddTransient&lt;Employee&gt;()
<strong>      .AddTransient&lt;MarketingProvider&gt;()</strong>
      .BuildServiceProvider();<br/>                        
       // Set the Current value by resolving with <br/>          MarketingProvider.
       <strong>DepartmentProvider.Current = serviceProvider.GetService<br/>          &lt;MarketingProvider&gt;();</strong>

       Employee emp = serviceProvider.GetService&lt;Employee&gt;();
       emp.EmployeeId = 1;
       emp.EmployeeName = "Sasmita Tripathy";
       emp.EmployeeDept = DepartmentProvider.Current.Department;

       Employee emp1 = serviceProvider.GetService&lt;Employee&gt;();
       emp1.EmployeeId = 2;
       emp1.EmployeeName = "Ganeswar Tripathy";
       emp1.EmployeeDept = DepartmentProvider.Current.Department;

       Console.WriteLine("Emp Name: " + emp.EmployeeName + ", <br/>         Department: " + emp.EmployeeDept.DeptName); // Marketing
       Console.WriteLine();
       Console.WriteLine("Emp Name: " + emp1.EmployeeName + ",<br/>         Department: " + emp1.EmployeeDept.DeptName); // Marketing
       Console.ReadLine();
    }</pre>
<p>See how we can register <kbd>MarketingProvider</kbd> using the built-in DI container. Then we assigned that to the <kbd>Current</kbd> property by which we are able to get the value as marketing when we read <kbd>DepartmentProvider.Current.Department</kbd>. <kbd>MarketingProvider</kbd> is a child class of <kbd>DepartmentProvider</kbd>, which returns a <kbd>Marketing</kbd> object. Refer to the following code:</p>
<pre>    class MarketingProvider : DepartmentProvider
    {
      public override Department Department
      {
         get { return new Marketing(); }
      }
    }</pre>
<p>So, we made a conclusion here. We can use the <kbd>static</kbd> property wherever we need inside the app and the value will be the same, unless you set it differently in-between.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Curveball</h1>
                
            
            
                
<p>A following are a few important points to remember while implementing an Ambient Context:</p>
<ul>
<li>This should be used only if it is really necessary. Constructor Injection or Property Injection should be the first choice before deciding to use Ambient Context. If you can't decide, just choose other DI patterns.</li>
<li>The Service Locator anti-pattern is quite similar to this pattern in the way it provides the dependency. However, there is a difference and that is Ambient Context supplies a single dependency, whereas Service Locator is responsible for providing all requested dependencies. We will discuss more on Service Locator in <a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank">Chapter 9</a>, <em>Anti-Patterns and Misconceptions on Dependency Injection</em>.</li>
<li>If you don't correctly implement Ambient Context, it will have side effects. Suppose you initiate using one context or provider and during the process, you change it due to some reason. Now, when you read the value, it will provide you with the changed value instead of the first one because of static. That means you need to be very careful while implementing this.</li>
<li>With the implementation we discussed, you can easily set <kbd>null</kbd> to the <kbd>Current</kbd> property <kbd>DepartmentProvider.Current = null;</kbd>. Therefore, we have to protect it by using a guard clause.</li>
</ul>
<p>The following code represents a simple guard clause inside getter and setter blocks:</p>
<pre>    abstract class DepartmentProvider
    {
      private static DepartmentProvider current;
      public static DepartmentProvider Current
      {
        get
        {
<strong>          if (current == null)
          current = new DefaultDepartmentProvider();</strong>
          return current;
        }
        set
        {
<strong>           current = value ?? new DefaultDepartmentProvider();</strong>
        }
      }
      public virtual Department Department { get; }
    }</pre>
<p>We did a null check both in getter and setter and used a backup provider called <kbd>DefaultDepartmentProvider</kbd> to overcome the situation of mishandling the context.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation inside .NET Core 2.0</h1>
                
            
            
                
<p>The <kbd>corefx</kbd> library has a  <kbd>CurrentPrincipal</kbd> <kbd>static</kbd> property inside the partial class <kbd>Thread</kbd> under  <kbd>System.Threading</kbd> namespace.</p>
<pre>    public static IPrincipal CurrentPrincipal
    {
      get
      {
         return CurrentThread._principal;
      }
      set
      {
         CurrentThread._principal = value;
      }
    }</pre>
<p class="mce-root">The usage can be seen in a method <kbd>Demand()</kbd> of the class <kbd>PrincipalPermission</kbd> under the namespace <kbd>System.Security.Permissions</kbd>:</p>
<div><img height="149" width="483" src="img/18fdc3f9-c8d6-4b42-81ca-435b2c7dc3ff.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The advantages of the Ambient Context</h1>
                
            
            
                
<p>Ambient Context is definitely a savior when an app demands the same dependency multiple times during the app execution. It's very hard to realise the fact that while we write codes for injecting dependencies, there are many such instances of asking the same dependency repeatedly within the app. This is the time where we should take the help of the Ambient Context Pattern, and with just a simple <kbd>static</kbd> accessor, we will be able to get the dependency. This not only reduces code but also imposes the DRY principle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The disadvantages of the Ambient Context</h1>
                
            
            
                
<p>Ambient Context is not easy to implement and needs careful attention while using it. By just looking at a class, we can't tell whether it implements the Ambient Context Pattern or not. If the context changes in between execution, the outcome will be different, resulting in side effects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>While implementing DI, we should definitely learn the techniques associated with it. These techniques, otherwise called DI patterns, play a vital role in the application architecture. So, deciding which pattern to use when is the most important factor in the case of injecting dependencies.</p>
<p>Constructor Injection is the most widely used, is easy, and should always be your first choice. However, there are scenarios where you might opt for another pattern.</p>
<p>When you see there are multiple dependencies required for different operations of a class, choose the Method Injection Pattern as it allows you the flexibility to inject dependency as you require.</p>
<p>Another beautiful design case reveals itself while you land on a situation where you need certain dependency at many places in your app. It looks like a Cross-Cutting Concern, however, you expect a certain return type, which is the dependency. For that, you need to use Ambient Context and can't rely on interceptors. This is because you need the returned dependency to do some operation in your class.</p>
<p>Property Injection is something which allows you to inject optional dependency. This means it relies upon a Local Default for sure, otherwise, we might end up in an exception while requesting it.</p>
<p>In <a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank">Chapter 9</a>, <em>Anti-Patterns and Misconceptions on Dependency Injection</em>, we will explore bad practices while implementing DI, which are denoted as anti-patterns.</p>
<p class="mce-root"/>


            

            
        
    </body></html>