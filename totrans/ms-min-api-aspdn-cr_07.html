<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-92"><a id="_idTextAnchor094"/>7</h1>
<h1 id="_idParaDest-93"><a id="_idTextAnchor095"/>Integration with the Data Access Layer</h1>
<p>In this chapter, we will learn about some basic ways to add a data access layer to the minimal APIs in .NET 6.0. We will see how we can use some topics covered previously in the book to access data with <strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) and then with Dapper. These are two ways to access a database.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Using Entity Framework</li>
<li>Using Dapper</li>
</ul>
<p>By the end of this chapter, you will be able to use EF from scratch in a minimal API project, and use Dapper for the same goal. You will also be able to tell when one approach is better than the other in a project.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor096"/>Technical requirements</h1>
<p>To follow along with this chapter, you will need to create an ASP.NET Core 6.0 Web API application. You can use either of the following options:</p>
<ul>
<li>Click on the <strong class="bold">New Project</strong> option in the <strong class="bold">File</strong> menu of Visual Studio 2022, then choose the <strong class="bold">ASP.NET Core Web API</strong> template, select a name and the working directory in the wizard, and be sure to uncheck the <strong class="bold">Use controllers</strong> option in the next step.</li>
<li>Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new Web API application:<pre><strong class="bold">dotnet new webapi -minimal -o Chapter07</strong></pre></li>
</ul>
<p>Now, open the project in Visual Studio by double-clicking on the project file or, in Visual Studio Code, type the following command in the already open console:</p>
<pre><strong class="bold">cd Chapter07</strong>
<strong class="bold">code.</strong></pre>
<p>Finally, you can safely remove all the code related to the <code>WeatherForecast</code> sample, as we don’t need it for this chapter.</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter07">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter07</a>.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor097"/>Using Entity Framework</h1>
<p>We can absolutely say that if we are building an API, it is very likely that we will interact with data.</p>
<p>In addition, this data most probably needs to be persisted after the application restarts or after other events, such as a new deployment of the application. There are many options for <a id="_idIndexMarker370"/>persisting data in .NET applications, but EF is the <a id="_idIndexMarker371"/>most user-friendly and common solution for a lot of scenarios.</p>
<p><strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>) is an extensible, open source, and cross-platform data <a id="_idIndexMarker372"/>access library for .NET applications. It enables developers to work with the database by using .NET objects directly and removes, in most cases, the need to know how to write the data access code directly in the database.</p>
<p>On top of this, EF Core supports a lot of databases, including SQLite, MySQL, Oracle, Microsoft SQL Server, and PostgreSQL.</p>
<p>In addition, it supports an in-memory database that helps to write tests for our applications or to make the development cycle easier because you don’t need a real database up and running.</p>
<p>In the next section, we will see how to set up a project for using EF and its main features.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Setting up the project</h2>
<p>From the <a id="_idIndexMarker373"/>project root, create an <code>Icecream.cs</code> class and give it the following content:</p>
<pre class="source-code">
namespace Chapter07.Models;
public class Icecream
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public string? Description { get; set; }
}</pre>
<p>The <code>Icecream</code> class is an object that represents an ice cream in our project. This class should be called a data model, and we will use this object in the next sections of this chapter to map it to a database table.</p>
<p>Now it’s time to add the EF Core NuGet reference to the project.</p>
<p>In order to do that, you can use one of the following methods:</p>
<ul>
<li>In a new terminal window, enter the following code to add the EF Core <code>InMemory</code> package:<pre>dotnet add package Microsoft.EntityFrameworkCore.InMemory</pre></li>
<li>If you would like to use Visual Studio 2022 to add the reference, right-click on <code>Microsoft.EntityFrameworkCore.InMemory</code> and install the package.</li>
</ul>
<p>In the <a id="_idIndexMarker374"/>next section, we will be adding EF Core to our project.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Adding EF Core to the project</h2>
<p>In order to store <a id="_idIndexMarker375"/>the ice cream objects in the database, we need to set up EF Core in our project.</p>
<p>To set up an in-memory database, add the following code to the bottom of the <code>Program.cs</code> file:</p>
<pre class="source-code">
class IcecreamDb : DbContext
{
    public IcecreamDb(DbContextOptions options) :
      base(options) { }
    public DbSet&lt;Icecream&gt; Icecreams { get; set; } = null!;
}</pre>
<p><code>DbContext</code> object represents a connection to the database, and it’s used to save and query instances of entities in the database.</p>
<p>The <code>DbSet</code> represents the instances of the entities, and they will be converted into a real table in the database.</p>
<p>In this case, we will have just one table in the database, called <code>Icecreams</code>.</p>
<p>In <code>Program.cs</code>, after the builder initialization, add the following code:</p>
<pre class="source-code">
builder.Services.AddDbContext&lt;IcecreamDb&gt;(options =&gt; options.UseInMemoryDatabase("icecreams"));</pre>
<p>Now we are ready to add some API endpoints to start interacting with the database.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>Adding endpoints to the project</h2>
<p>Let’s add <a id="_idIndexMarker376"/>the code to create a new item in the <code>icecreams</code> list. In <code>Program.cs</code>, add the following code before the <code>app.Run()</code> line of code:</p>
<pre class="source-code">
app.MapPost("/icecreams", async (IcecreamDb db, Icecream icecream) =&gt;
{
    await db.Icecreams.AddAsync(icecream);
    await db.SaveChangesAsync();
    return Results.Created($"/icecreams/{icecream.Id}",
                           icecream);
});</pre>
<p>The first parameter of the <code>MapPost</code> function is the DbContext. By default, the minimal API architecture uses dependency injection to share the instances of the DbContext.</p>
<p class="callout-heading">Dependency injection</p>
<p class="callout">If you want to know more about dependency injection, go to <a href="B17902_04.xhtml#_idTextAnchor061"><em class="italic">Chapter 4</em></a><em class="italic">, Dependency Injection in a Minimal API Project</em>.</p>
<p>In order to save an item into the database, we use the <code>AddSync</code> method directly from the entity that represents the object.</p>
<p>To persist the new item in the database, we need to call the <code>SaveChangesAsync()</code> method, which is responsible for saving all the changes that happen to the database before the last call to <code>SaveChangesAsync()</code>.</p>
<p>In a very similar way, we can add the endpoint to retrieve all the items in the <code>icecreams</code> database.</p>
<p>After the code to add an ice cream, we can add the following code:</p>
<pre class="source-code">
app.MapGet("/icecreams", async (IcecreamDb db) =&gt; await db.Icecreams.ToListAsync());</pre>
<p>Also, in this case, the DbContext is available as a parameter and we can retrieve all the items in the database directly from the entities in the DbContext.</p>
<p>With the <code>ToListAsync()</code> method, the application loads all the entities in the database and sends them back as the endpoint result.</p>
<p>Make sure <a id="_idIndexMarker377"/>you have saved all your changes in the project and run the app.</p>
<p>A new browser window will open, and you can navigate to the <code>/swagger</code> URL:</p>
<div><div><img alt="Figure 7.1 – Swagger browser window " height="715" src="img/Figure_7.01_B17902.jpg" width="1070"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Swagger browser window</p>
<p>Select the <strong class="bold">POST/icecreams</strong> button, followed by <strong class="bold">Try it out</strong>.</p>
<p>Replace the request body content with the following JSON:</p>
<pre class="source-code">
{
  "id": 0,
  "name": "icecream 1",
  "description": "description 1"
}</pre>
<p>Click on <strong class="bold">Execute</strong>:</p>
<div><div><img alt="Figure 7.2 – Swagger response " height="660" src="img/Figure_7.02_B17902.jpg" width="1110"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Swagger response</p>
<p>Now we <a id="_idIndexMarker378"/>have at least one item in the database, and we can try the other endpoint to retrieve all the items in the database.</p>
<p>Scroll down the page a little bit and select <strong class="bold">GET/icecreams</strong>, followed by <strong class="bold">Try it out</strong> and then <strong class="bold">Execute</strong>.</p>
<p>You will see the list with one item under <strong class="bold">Response Body</strong>.</p>
<p>Let’s see how to finalize this first demo by adding the other CRUD operations to our endpoints:</p>
<ol>
<li>To get an item by ID, add the following code under the <code>app.MapGet</code> route you created earlier:<pre>app.MapGet("/icecreams/{id}", async (IcecreamDb db, int id) =&gt; await db.Icecreams.FindAsync(id));</pre></li>
</ol>
<p>To check this out, you can launch the application again and use the Swagger UI as before.</p>
<ol>
<li value="2">Next, add an item in the database by performing a post call (as in the previous section).</li>
<li>Click <strong class="bold">GET/icecreams/{id)</strong> followed by <strong class="bold">Try it out</strong>. </li>
<li>Insert the value <code>1</code> in the <code>id</code> parameter field and then click on <strong class="bold">Execute</strong>.</li>
<li>You will see the item in the <strong class="bold">Response Body</strong> section.</li>
<li>The following <a id="_idIndexMarker379"/>is an example of a response from the API:<pre>{
  "id": 1,
  "name": "icecream 1",
  "description": "description 1"
}</pre></li>
</ol>
<p>This is what the response looks like:</p>
<div><div><img alt="Figure 7.3 – Response result " height="770" src="img/Figure_7.03_B17902.jpg" width="1225"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Response result</p>
<p>To update <a id="_idIndexMarker380"/>an item by ID, we can create a new <code>MapPut</code> endpoint with two parameters: the item with the entity values and the ID of the old entity in the database that we want to update.</p>
<p>The code should be like the following snippet:</p>
<pre class="source-code">
app.MapPut("/icecreams/{id}", async (IcecreamDb db, Icecream updateicecream, int id) =&gt;
{
    var icecream = await db.Icecreams.FindAsync(id);
    if (icecream is null) return Results.NotFound();
    icecream.Name = updateicecream.Name;
    icecream.Description = updateicecream.Description;
    await db.SaveChangesAsync();
    return Results.NoContent();
});</pre>
<p>Just to be clear, first of all, we need to find the item in the database with the ID from the parameters. If we don’t find an item in the database, it’s a good practice to return a <code>Not Found</code> HTTP status to the caller.</p>
<p>If we find the entity in the database, we update the entity with the new values and we save all the changes in the database before sending back the HTTP status <code>No Content</code>.</p>
<p>The last <a id="_idIndexMarker381"/>CRUD operation we need to perform is to delete an item from the database.</p>
<p>This operation is very similar to the update operation because, first of all, we need to find the item in the database and then we can try to perform the delete operation.</p>
<p>The following code snippet shows how to implement a delete operation with the right HTTP verb of the minimal API:</p>
<pre class="source-code">
app.MapDelete("/icecreams/{id}", async (IcecreamDb db, int id) =&gt;
{
    var icecream = await db.Icecreams.FindAsync(id);
    if (icecream is null)
    {
        return Results.NotFound();
    }
    db.Icecreams.Remove(icecream);
    await db.SaveChangesAsync();
    return Results.Ok();
});</pre>
<p>In this section, we have learned how to use EF in a minimal API project.</p>
<p>We saw how to add the NuGet packages to start working with EF, and how to implement the entire set of CRUD operations in a minimal API .NET 6 project.</p>
<p>In the next section, we will see how to implement the same project with the same logic but using Dapper as the primary library to access data.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/>Using Dapper</h1>
<p>Dapper is <a id="_idIndexMarker382"/>an <code>IDbConnection</code> object and provides a lot of methods to query the database. This means we have to write queries that are compatible with the database provider.</p>
<p>It supports synchronous and asynchronous method executions. This is a list of the methods that Dapper adds to the <code>IDbConnection</code> interface:</p>
<ul>
<li><code>Execute</code></li>
<li><code>Query</code></li>
<li><code>QueryFirst</code></li>
<li><code>QueryFirstOrDefault</code></li>
<li><code>QuerySingle</code></li>
<li><code>QuerySingleOrDefault</code></li>
<li><code>QueryMultiple</code></li>
</ul>
<p>As we mentioned, it provides an async version for all these methods. You can find the right methods by adding the <code>Async</code> keyword at the end of the method name.</p>
<p>In the next section, we will see how to set up a project for using Dapper with a SQL Server LocalDB.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Setting up the project</h2>
<p>The first <a id="_idIndexMarker385"/>thing we are going to do is to create <a id="_idIndexMarker386"/>a new database. You can use your SQL Server LocalDB instance installed with Visual Studio by default or another SQL Server instance in your environment.</p>
<p>You can execute the following script in your database to create one table and populate it with data:</p>
<pre class="source-code">
CREATE TABLE [dbo].[Icecreams](
     [Id] [int] IDENTITY(1,1) NOT NULL,
     [Name] [nvarchar](50) NOT NULL,
     [Description] [nvarchar](255) NOT NULL)
GO
INSERT [dbo].[Icecreams] ([Name], [Description]) VALUES ('Icecream 1','Description 1')
INSERT [dbo].[Icecreams] ([Name], [Description]) VALUES ('Icecream 2','Description 2')
INSERT [dbo].[Icecreams] ([Name], [Description]) VALUES ('Icecream 3','Description 3')</pre>
<p>Once we have the database, we can install these NuGet packages with the following command in the Visual Studio terminal:</p>
<pre>Install-Package Dapper
Install-Package Microsoft.Data.SqlClient</pre>
<p>Now we can continue to add the code to interact with the database. In this example, we are going to use a repository pattern.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>Creating a repository pattern</h2>
<p>In this <a id="_idIndexMarker387"/>section, we are going to create a simple repository pattern, but we will try to make it as simple as possible so we can understand the main features of Dapper:</p>
<ol>
<li value="1">In the <code>Program.cs</code> file, add a simple class that represents our entity in the database:<pre>public class Icecream
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public string? Description { get; set; }
}</pre></li>
<li>After this, modify the <code>appsettings.json</code> file by adding the connection string at the end of the file:<pre>"ConnectionStrings": {
    "SqlConnection": 
      "Data Source=(localdb)\\MSSQLLocalDB;
       Initial Catalog=Chapter07;
       Integrated Security=True;
       Connect Timeout=30;
       Encrypt=False;
       TrustServerCertificate=False;"
}</pre></li>
</ol>
<p>If you are using LocalDB, the connection string should be the right one for your environment as well.</p>
<ol>
<li value="3">Create a new class in the root of the project called <code>DapperContext</code> and give it the following code:<pre>public class DapperContext
{
    private readonly IConfiguration _configuration;
    private readonly string _connectionString;
    public DapperContext(IConfiguration configuration)
    {
        _configuration = configuration;
        _connectionString = _configuration
          .GetConnectionString("SqlConnection");
    }
    public IDbConnection CreateConnection()
        =&gt; new SqlConnection(_connectionString);
}</pre></li>
</ol>
<p>We injected <a id="_idIndexMarker388"/>with dependency injection the <code>IConfiguration</code> interface to retrieve the connection string from the settings file.</p>
<ol>
<li value="4">Now we are going to create the interface and the implementation of our repository. In order to do that, add the following code to the <code>Program.cs</code> file.<pre>public interface IIcecreamsRepository
{
}
public class IcecreamsRepository : IIcecreamsRepository
{
    private readonly DapperContext _context;
    public IcecreamsRepository(DapperContext context)
    {
        _context = context;
    }
}</pre></li>
</ol>
<p>In the next sections, we will be adding some code to the interface and to the implementation of the repository.</p>
<p>Finally, we can register the context, the interface, and its implementation as a service.</p>
<ol>
<li value="5">Let’s put <a id="_idIndexMarker389"/>the following code after the builder initialization in the <code>Program.cs</code> file:<pre>builder.Services.AddSingleton&lt;DapperContext&gt;();
builder.Services.AddScoped&lt;IIcecreamsRepository, IcecreamsRepository&gt;();</pre></li>
</ol>
<p>Now we are ready to implement the first query.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Using Dapper to query the database</h2>
<p>First of all, let’s <a id="_idIndexMarker390"/>modify the <code>IIcecreamsRepository</code> interface by adding a new method:</p>
<pre class="source-code">
public Task&lt;IEnumerable&lt;Icecream&gt;&gt; GetIcecreams();</pre>
<p>Then, let’s implement this method in the <code>IcecreamsRepository</code> class:</p>
<pre class="source-code">
public async Task&lt;IEnumerable&lt;Icecream&gt;&gt; GetIcecreams()
{
    var query = "SELECT * FROM Icecreams";
    using (var connection = _context.CreateConnection())
    {
        var result = 
          await connection.QueryAsync&lt;Icecream&gt;(query);
        return result.ToList();
    }
}</pre>
<p>Let’s try <a id="_idIndexMarker391"/>to understand all the steps in this method. We created a string called <code>query</code>, where we store the SQL query to fetch all the entities from the database.</p>
<p>Then, inside the <code>using</code> statement, we used <code>DapperContext</code> to create the connection.</p>
<p>Once the connection was created, we used it to call the <code>QueryAsync</code> method and passed the query as an argument.</p>
<p>Dapper, when the results return from the database, converted them into <code>IEnumerable&lt;T&gt;</code> automatically.</p>
<p>The following is the final code of the interface and our first implementation:</p>
<pre class="source-code">
public interface IIcecreamsRepository
{
    public Task&lt;IEnumerable&lt;Icecream&gt;&gt; GetIcecreams();
}
public class IcecreamsRepository : IIcecreamsRepository
{
    private readonly DapperContext _context;
    public IcecreamsRepository(DapperContext context)
    {
        _context = context;
    }
    public async Task&lt;IEnumerable&lt;Icecream&gt;&gt; GetIcecreams()
    {
        var query = "SELECT * FROM Icecreams";
        using (var connection =
              _context.CreateConnection())
        {
            var result = 
              await connection.QueryAsync&lt;Icecream&gt;(query);
            return result.ToList();
        }
    }
}</pre>
<p>In the <a id="_idIndexMarker392"/>next section, we will see how to add a new entity to the database and how to use the <code>ExecuteAsync</code> method to run a query.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>Adding a new entity in the database with Dapper</h2>
<p>Now we <a id="_idIndexMarker393"/>are going to manage adding a new entity to the database for future implementations of the API post request.</p>
<p>Let’s modify the interface by adding a new method called <code>CreateIcecream</code> with an input parameter of the <code>Icecream</code> type:</p>
<pre class="source-code">
public Task CreateIcecream(Icecream icecream);</pre>
<p>Now we must implement this method in the repository class:</p>
<pre class="source-code">
public async Task CreateIcecream(Icecream icecream)
{
    var query = "INSERT INTO Icecreams (Name, Description)
      VALUES (@Name, @Description)";
    var parameters = new DynamicParameters();
    parameters.Add("Name", icecream.Name, DbType.String);
    parameters.Add("Description", icecream.Description,
                    DbType.String);
    using (var connection = _context.CreateConnection())
    {
        await connection.ExecuteAsync(query, parameters);
    }
}</pre>
<p>Here, we <a id="_idIndexMarker394"/>create the query and a dynamic parameters object to pass all the values to the database.</p>
<p>We populate the parameters with the values from the <code>Icecream</code> object in the method parameter.</p>
<p>We create the connection with the Dapper context and then we use the <code>ExecuteAsync</code> method to execute the <code>INSERT</code> statement.</p>
<p>This method returns an integer value as a result, representing the number of affected rows in the database. In this case, we don’t use this information, but you can return this value as the result of the method if you need it.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Implementing the repository in the endpoints</h2>
<p>To add <a id="_idIndexMarker395"/>the final touch to our minimal API, we need to implement the two endpoints to manage all the methods in our repository pattern:</p>
<pre class="source-code">
app.MapPost("/icecreams", async (IIcecreamsRepository repository, Icecream icecream) =&gt;
{
    await repository.CreateIcecream(icecream);
    return Results.Ok();
});
app.MapGet("/icecreams", async (IIcecreamsRepository repository) =&gt; await repository.GetIcecreams());</pre>
<p>In both <a id="_idIndexMarker396"/>map methods, we pass the repository as a parameter because, as usual in the minimal API, the services are passed as parameters in the map methods.</p>
<p>This means that the repository is always available in all parts of the code.</p>
<p>In the <code>MapGet</code> endpoint, we use the repository to load all the entities from the implementation of the repository and we use the result as the result of the endpoint.</p>
<p>In the <code>MapPost</code> endpoint, in addition to the repository parameter, we accept also the <code>Icecream</code> entity from the body of the request and we use the same entity as a parameter to the <code>CreateIcecream</code> method of the repository.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Summary</h1>
<p>In this chapter, we learned how to interact with a data access layer in a minimal API project with the two most common tools in a real-world scenario: EF and Dapper.</p>
<p>For EF, we covered some basic features, such as setting up a project to use this ORM and how to perform some basic operations to implement a full CRUD API endpoint.</p>
<p>We did basically the same thing with Dapper as well, starting from an empty project, adding Dapper, setting up the project for working with a SQL Server LocalDB, and implementing some basic interactions with the entities of the database.</p>
<p>In the next chapter, we’ll focus on authentication and authorization in a minimal API project. It’s important, first of all, to protect your data in the database.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>Part 3: Advanced Development and Microservices Concepts</h1>
<p>In this advanced section of the book, we want to show more scenarios that are typical in backend development. We will also go over the performance of this new framework and understand the scenarios in which it is really useful.</p>
<p>We will cover the following chapters in this section:</p>
<ul>
<li><a href="B17902_08.xhtml#_idTextAnchor109"><em class="italic">Chapter 8</em></a>, <em class="italic">Adding Authentication and Authorization</em></li>
<li><a href="B17902_09.xhtml#_idTextAnchor125"><em class="italic">Chapter 9</em></a>, <em class="italic">Leveraging Globalization and Localization</em></li>
<li><a href="B17902_10.xhtml#_idTextAnchor140"><em class="italic">Chapter 10</em></a>, <em class="italic">Evaluating and Benchmarking the Performance of Minimal APIs</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>