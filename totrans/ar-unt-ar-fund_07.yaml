- en: '*Chapter 5*: Using the AR User Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用AR用户框架'
- en: In this chapter, we will learn how to use the `ARFramework` scene template,
    we will add a main menu for placing virtual objects in the environment. If you
    skipped that chapter or just read through it, you can find the scene template
    and assets in the files provided on this book's GitHub repository.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用`ARFramework`场景模板，我们将添加一个主菜单来在环境中放置虚拟对象。如果您跳过了那一章或只是浏览了一下，您可以在本书GitHub仓库提供的文件中找到场景模板和资产。
- en: For this project, we'll extend the framework with a new *PlaceObject-mode* that
    prompts the user to tap to place a virtual object in the room. The user will have
    a choice of objects from the main menu.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将通过一个新的*PlaceObject模式*扩展框架，提示用户轻触放置虚拟对象在房间中。用户可以从主菜单中选择对象。
- en: In the latter half of the chapter, I'll discuss some advanced AR application
    issues including making an AR-optional project, determining whether a device supports
    a specific AR feature, and adding localization to your **User Interface** (**UI**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我将讨论一些高级AR应用程序问题，包括创建一个可选的AR项目、确定设备是否支持特定的AR功能以及向您的**用户界面**（**UI**）添加本地化。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Planning the project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划项目
- en: Starting with the ARFramework scene template
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ARFramework场景模板开始
- en: Adding a main menu
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加主菜单
- en: Adding PlaceObject mode and instructional UI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加PlaceObject模式和教学UI
- en: Wiring the menu buttons
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接菜单按钮
- en: Doing a Build And Run
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行构建和运行
- en: Hiding tracked objects when not needed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不需要时隐藏跟踪对象
- en: Making an AR-optional project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可选的AR项目
- en: Determining whether a device supports specific AR features at runtime
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时确定设备是否支持特定的AR功能
- en: Adding localization features to a project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向项目中添加本地化功能
- en: By the end of the chapter, you'll be more familiar with the AR user framework
    developed for this book, which we'll use in subsequent chapters as we build a
    variety of different AR application projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将更熟悉为本书开发的AR用户框架，我们将在构建各种不同的AR应用程序项目时使用它。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To implement the project in this chapter, you need Unity installed on your
    development computer, with a mobile device connected that supports AR applications
    (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013), *Setting Up
    for AR Development,* for instructions), including the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中实现项目，您需要在您的开发计算机上安装Unity，并连接一个支持AR应用程序的移动设备（有关说明，请参阅[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发设置*），包括以下内容：
- en: Universal Render Pipeline
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用渲染管线
- en: Input System package
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入系统包
- en: XR Plugin for your target device
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标设备的XR插件
- en: AR Foundation package
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AR Foundation包
- en: We assume you have installed the assets from the Unity `ARF-samples.unitypackage`
    created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*, Your
    First AR Scene*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经安装了[*第2章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*，您的第一个AR场景*中创建的Unity
    `ARF-samples.unitypackage`资产。
- en: Also from [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037), *Your
    First AR Scene,* we created an **AR Input Actions** asset that we'll use in this
    project, containing an **action map** named **ARTouchActions** including (at least)
    a **PlaceObject** action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从[*第2章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)，*您的第一个AR场景*中找到，我们创建了一个**AR输入动作**资产，我们将在本项目中使用它，包含一个名为**ARTouchActions**的**动作映射**，包括（至少）一个**PlaceObject**动作。
- en: We also assume you have the `ARFramework` scene template created in [*Chapter
    4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating an AR User Framework*,
    along with all the prerequisite Unity packages detailed at the beginning of [*Chapter
    4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077) *Creating an AR User Framework*.
    A copy of the template and assets can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)
    (not including the third-party packages that you should install yourself).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您已经安装了[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*，创建AR用户框架*中创建的`ARF-samples.unitypackage`资产，包括在[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*创建AR用户框架*开始部分详细说明的所有先决Unity包。模板和资产可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)（不包括您应自行安装的第三方包）。
- en: 'The AR user framework requires the following prerequisites, as detailed in
    [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating an AR
    User Framework*, including the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: AR用户框架需要以下先决条件，如[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*，创建AR用户框架*中详细说明，包括以下内容：
- en: The Addressables package
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Addressables包
- en: The Localization package
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化包
- en: TextMesh Pro
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TextMesh Pro
- en: The DOTween package from the Asset Store
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Asset Store中的DOTween包
- en: The Serialized Dictionary Lite package from the Asset Store
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Asset Store中的Serialized Dictionary Lite包
- en: The completed scene for this chapter can also be found in the GitHub repository.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成的场景也可以在GitHub仓库中找到。
- en: Planning the project
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目规划
- en: For this project, we'll create a simple demo AR scene starting with the `ARFramework`
    scene template and building up the user framework structure we have set up.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将从`ARFramework`场景模板开始创建一个简单的演示AR场景，并构建我们已设置的用户框架结构。
- en: With the framework, when the app first starts, Startup-mode is enabled and the
    AR Session is initialized. Once the session is ready, it transitions to Scan-mode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该框架，当应用首次启动时，启动模式被启用，AR会话被初始化。一旦会话准备就绪，它将过渡到扫描模式。
- en: If the AR Session determines that the current device does not support AR, Scan-mode
    will transition to NonAR-mode instead. Presently this just puts a text message
    on the screen. See the *Making an AR-optional project* section near the end of
    this chapter for more information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AR会话确定当前设备不支持AR，扫描模式将过渡到非AR模式。目前这只是在屏幕上显示一条文本消息。有关更多信息，请参阅本章末尾附近的*创建可选AR项目*部分。
- en: In Scan-mode, the user is prompted to use their device camera to slowly scan
    the room until AR features are detected, namely, horizontal planes. The **ScanMode**
    script checks for any tracked planes and then transitions to Main-mode.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描模式中，用户被提示使用他们的设备相机缓慢扫描房间，直到检测到AR功能，即水平平面。**ScanMode**脚本检查任何追踪的平面，然后过渡到主模式。
- en: 'Given this, our plan is to add the following features:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的计划是添加以下功能：
- en: The AR session will be configured to detect and track horizontal planes. We'll
    also render point clouds.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AR会话将被配置为检测和跟踪水平平面。我们还将渲染点云。
- en: Main-mode will show a main menu with buttons that lets the user choose objects
    to place in the real-world environment. You can find your own models to use here,
    but we'll include three buttons for a cube, a sphere, and a virus (created in
    [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*, Your First AR
    Scene*).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主模式将显示一个主菜单，其中包含按钮，允许用户选择放置在真实世界环境中的对象。您可以在此处找到自己的模型来使用，但我们将包括三个按钮用于立方体、球体和病毒（在[*第2章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*，您的第一个AR场景*中创建）。
- en: When a place-object button is selected, it will enable a new PlaceObject-mode
    that prompts the user to tap to place the objects onto a detected plane.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择放置对象按钮时，它将启用一个新的放置对象模式，提示用户点击以将对象放置在检测到的平面上。
- en: Tapping on a tracked horizontal plane will create an instance of the object
    in the scene. The app then goes back to Main-mode.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击追踪的水平平面将在场景中创建对象的实例。然后应用返回到主模式。
- en: Tracked AR features (planes and point clouds) will be hidden in Main-mode, and
    visible in PlaceObject-mode.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪的AR功能（平面和点云）将在主模式中隐藏，在放置对象模式中可见。
- en: 'I have chosen to provide a cube, a sphere, and a virus (the virus model was
    created in [*Chapter 2*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*, Your
    First AR Scene*). Feel free to find and use your own models instead. The prefab
    assets I will be using are the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择提供立方体、球体和病毒（病毒模型在[*第2章*](B15145_02_Final_SS_epub.xhtml#_idTextAnchor037)*，您的第一个AR场景*中创建）。您也可以自由地寻找并使用自己的模型。我将使用的预制资源如下：
- en: '`Assets/ARF-samples/Prefabs/` folder)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/ARF-samples/Prefabs/` 文件夹)'
- en: '`Assets/ARF-samples/Prefabs/` folder)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/ARF-samples/Prefabs/` 文件夹)'
- en: '`Assets/_ARFBookAssets/Chapter02/Prefabs/` folder)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/_ARFBookAssets/Chapter02/Prefabs/` 文件夹)'
- en: This is a simple AR demo that will help you become more familiar with the AR
    user framework we developed and will use in subsequent projects in this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的AR演示，将帮助您更熟悉我们开发的AR用户框架，并将在本书后续项目中使用。
- en: Let's get started.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Starting with the ARFramework scene template
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从ARFramework场景模板开始
- en: 'To begin, we''ll create a new scene named `FrameworkDemo` using the `ARFramework`
    scene template, using the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下步骤创建一个名为`FrameworkDemo`的新场景，使用`ARFramework`场景模板：
- en: Select **File | New Scene**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 | 新建场景**。
- en: In the **New Scene** dialog box, select the **ARFramework** template.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新场景**对话框中，选择**ARFramework**模板。
- en: Press **Create**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**创建**。
- en: Select `Scenes/` folder in your project's `Assets` folder, give it the name
    `FrameworkDemo`, and press **Save**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目“资产”文件夹中，选择`Scenes/`文件夹，将其命名为`FrameworkDemo`，然后按**保存**。
- en: 'Note: Unintended clone dependencies'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：意外的克隆依赖项
- en: When creating a new scene from a scene template, if you're prompted right away
    for a name to save the file under, this indicates your scene template has some
    clone dependencies defined. If this is not your intention, cancel the creation,
    select the template asset in your Project window, and ensure all the **Clone**
    checkboxes are cleared in the **Dependencies** list. Then try creating your new
    scene again.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当从场景模板创建新场景时，如果你立即被提示输入文件保存的名称，这表明你的场景模板定义了一些克隆依赖项。如果不是你的意图，取消创建，在项目窗口中选择模板资产，并确保在**依赖项**列表中所有**克隆**复选框都被清除。然后再次尝试创建你的新场景。
- en: 'The new AR scene already has the following game objects included from the template:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 AR 场景已经从模板中包含了以下游戏对象：
- en: The **AR Session** game object
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR 会话**游戏对象'
- en: The **AR Session Origin** rig with the raycast manager and plane manager components.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有射线管理器和平面管理器组件的**AR 会话起源**装置。
- en: '**UI Canvas** is a screen space canvas with Startup UI, Scan UI, Main UI, and
    NonAR UI child panels. It also has the UI Controller component script that we
    wrote.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI Canvas**是一个屏幕空间画布，包含启动 UI、扫描 UI、主 UI 和非 AR UI 子面板。它还具有我们编写的 UI 控制器组件脚本。'
- en: '**Interaction Controller** is a game object with the Interaction Controller
    component script we wrote that helps the app switch between interaction modes,
    including Startup, Scan, Main, and NonAR modes. It also has a **Player Input**
    component configured with the **AR Input Actions** asset we previously created.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互控制器**是一个带有我们编写的交互控制器组件脚本的游戏对象，它帮助应用在启动、扫描、主和非 AR 模式之间切换。它还配置了一个带有我们之前创建的**AR
    输入动作**资产的**玩家输入**组件。'
- en: The **OnboardingUX** prefab from the AR Foundation Demos project that provides
    AR session status and feature detection status messages, and animated onboarding
    graphics prompts.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 AR 基础演示项目的**OnboardingUX**预制件，它提供 AR 会话状态和功能检测状态消息，以及动画引导图形提示。
- en: 'Set up the app title now as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下方式设置应用标题：
- en: In the **Hierarchy** window, unfold the **UI Canvas** object, and unfold its
    child **App Title Panel**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，展开**UI Canvas**对象，然后展开其子**应用标题面板**。
- en: Select the **Title Text** object.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**标题文本**对象。
- en: In its `Place Object Demo`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`放置对象演示`中。
- en: 'The default AR Session Origin already has an AR Plane Manager component. Let''s
    ensure it''s only detecting horizontal planes. Let''s add a point cloud visualization
    too. Follow these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 AR 会话起源已经有一个 AR 平面管理器组件。让我们确保它只检测水平平面。让我们也添加点云可视化。按照以下步骤操作：
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR 会话起源**对象。
- en: In the **Inspector**, set the **AR Plane Manager | Detection Mode** to **Horizontal**
    by first selecting **Nothing** (to clear the list) and then selecting **Horizontal**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，通过首先选择**无**（以清除列表）然后选择**水平**，将**AR 平面管理器 | 检测模式**设置为**水平**。
- en: Click the `ar point cloud`, then add an **AR Point Cloud Manager** component.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`ar point cloud`，然后添加一个**AR 点云管理器**组件。
- en: Find a point cloud visualizer prefab and set the `Assets/ARF-samples/Prefabs/`
    folder).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个点云可视化预制件，并将其设置为`Assets/ARF-samples/Prefabs/`文件夹。
- en: Save your work with **File | Save**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件 | 保存**保存你的工作。
- en: We've created a new scene based on the ARFramework template and added AR trackables
    managers for point clouds and horizontal planes. Next, we'll add the main menu.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经基于 ARFramework 模板创建了一个新场景，并添加了 AR 轨迹管理器以处理点云和水平平面。接下来，我们将添加主菜单。
- en: Adding a main menu
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加主菜单
- en: 'The main menu UI resides under the Menu UI panel (under UI Canvas) in the scene
    hierarchy. We will add a menu panel with three buttons to let you add a cube,
    a sphere, and a virus. We''ll create a menu sub-panel and arrange the menu buttons
    horizontally. Follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单 UI 位于场景层次结构中的菜单 UI 面板（在 UI Canvas 下）。我们将添加一个带有三个按钮的菜单面板，让你添加一个立方体、一个球体和一个病毒。我们将创建一个菜单子面板并将菜单按钮水平排列。按照以下步骤操作：
- en: In the **Hierarchy**, unfold the **UI Canvas**, and unfold its child **Main
    UI** object.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，展开**UI Canvas**，然后展开其子**主 UI**对象。
- en: First, remove the temporary **Main** mode text element. *Right-click* the child
    **Text** object and select **Delete**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除临时的 **主** 模式文本元素。*右键单击* 子 **文本** 对象并选择 **删除**。
- en: '*Right-click* the `Main Menu`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `主菜单`。'
- en: On the `175`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `175`。
- en: I set my background `255`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将我的背景设置为 `255`。
- en: Select `layout`, then select **| Horizontal Layout Group**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `布局`，然后选择 **| 水平布局组**。
- en: 'On the **Horizontal Layout Group** component check the **Control Child Size
    | Width** and **Height** checkboxes (leave the others at their default values,
    **Use Child Scale** unchecked, and **Child Force Expand** checked). The Main Menu
    panel looks like this in the Inspector:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **水平布局组** 组件中勾选 **控制子大小 | 宽度** 和 **高度** 复选框（保留其他默认值，**使用子缩放** 未勾选，**子强制扩展**
    勾选）。在检查器中，主菜单面板看起来如下：
- en: '![Figure 5.1 – The Main Menu panel settings'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 主菜单面板设置'
- en: '](img/Figure_5.01-MainMenu-insp.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01-MainMenu-insp.jpg)'
- en: Figure 5.1 – The Main Menu panel settings
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 主菜单面板设置
- en: 'Now we''ll add three buttons to the menu using the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将按照以下步骤添加三个按钮到菜单中：
- en: '*Right-click* the `Cube Button`.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `立方体按钮`。'
- en: Select its child text object, and set the `Cube` and `48`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其子文本对象，并将 `Cube` 和 `48` 设置为 `48`。
- en: '*Right-click* the `Sphere Button` and change its text to `Sphere`.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `球体按钮` 并将其文本更改为 `Sphere`。'
- en: Repeat *step 3* again, renaming it `Virus Button`, and changing the text to
    `Virus`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重复 *步骤 3*，将其重命名为 `Virus Button`，并更改文本为 `Virus`。
- en: 'The resulting scene hierarchy of the Main Menu is shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单的最终场景层次结构如下截图所示：
- en: '![](img/Figure_5.02-mainmenu-hier.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.02-mainmenu-hier.jpg)'
- en: Figure 5.2 – Main Menu hierarchy
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 主菜单层次结构
- en: 'I decided to go further and add a sprite image of each model to the buttons.
    I created the images by screen-capturing a view of each model, edited them with
    Photoshop, saved them as PNG files, and in Unity made sure the image''s **Texture
    Type** is set to **Sprite (2D and UI)**. I then added a child **Image** element
    to the buttons. The result is as shown in the following image of my menu:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定更进一步，为每个模型添加按钮的精灵图像。我通过截取每个模型的视图来创建图像，使用 Photoshop 编辑它们，将它们保存为 PNG 文件，并在
    Unity 中确保图像的 **纹理类型** 设置为 **精灵（2D 和 UI）**。然后我向按钮添加了一个子 **图像** 元素。以下是我的菜单的图像：
- en: '![Figure 5.3 – Main Menu with icon buttons'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 带图标按钮的主菜单'
- en: '](img/Figure_5.03-mainmenu-iconbuttons.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03-mainmenu-iconbuttons.jpg)'
- en: Figure 5.3 – Main Menu with icon buttons
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 带图标按钮的主菜单
- en: Thus far we have created a Main Menu panel with menu buttons under the Main
    UI. When the app goes into Main-mode, this menu will be displayed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在主 UI 下创建了一个带有菜单按钮的主菜单面板。当应用进入主模式时，此菜单将显示。
- en: Next, we'll add a UI panel that prompts the user to tap the screen to place
    an object into the scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 UI 面板，提示用户触摸屏幕将对象放置到场景中。
- en: Adding PlaceObject-mode with instructional UI
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加带有说明 UI 的 PlaceObject 模式
- en: When the user picks an object from the main menu, the app will enable PlaceObject-mode.
    For this mode, we need a UI panel to prompt the user to tap the screen to place
    the object. Let's create the UI panel first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从主菜单中选择对象时，应用将启用 PlaceObject 模式。为此模式，我们需要一个 UI 面板来提示用户触摸屏幕放置对象。让我们首先创建 UI
    面板。
- en: Creating the PlaceObject UI panel
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 PlaceObject UI 面板
- en: 'The **PlaceObject UI** panel should be similar to the **Scan UI** one, so we
    can duplicate and modify it using the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**PlaceObject UI** 面板应类似于 **扫描 UI** 面板，因此我们可以使用以下步骤进行复制和修改：'
- en: In the **Hierarchy** window, unfold the **UI Canvas**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中，展开 **UI 画布**。
- en: '*Right-click* the `PlaceObject UI`.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `PlaceObject UI`。'
- en: Unfold **PlaceObject UI** and select its child **Animated Prompt**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 **PlaceObject UI** 并选择其子 **动画提示**。
- en: In the **Inspector**, set the **Animated Prompt | Instruction** to **Tap To
    Place**. The resulting component is shown in the following screenshot:![Figure
    5.4 – Animated Prompt settings for the PlaceObject UI panel
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 中，将 **动画提示 | 说明** 设置为 **点击放置**。以下截图显示了生成的组件：![图 5.4 – PlaceObject
    UI 面板的动画提示设置
- en: '](img/Figure_5.04-placeobjectui-insp.jpg)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04-placeobjectui-insp.jpg)'
- en: Figure 5.4 – Animated Prompt settings for the PlaceObject UI panel
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.4 – PlaceObject UI 面板的动画提示设置
- en: Now we add the panel to the UI Controller.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将面板添加到 UI 控制器中。
- en: In the **Hierarchy**, select the **UI Canvas** object.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 **UI 画布** 对象。
- en: In the **Inspector**, at the bottom-right of the **UI Controller** component,
    click the **+** button to add an item to the UI Panels dictionary.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，在**UI Controller**组件的右下角，点击**+**按钮向UI面板字典添加一个项。
- en: Enter `PlaceObject` as text in the **Id** field.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Id**字段中输入`PlaceObject`作为文本。
- en: 'Drag the **PlaceObject UI** game object from the **Hierarchy** onto the **Value**
    slot. The UI Controller component now looks like the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**PlaceObject UI**游戏对象从**层次结构**拖到**值**槽中。UI控制器组件现在看起来如下所示：
- en: '![Figure 5.5 – UI Controller''s UI Panels list with PlaceObject added'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – UI Controller''s UI Panels list with PlaceObject added'
- en: '](img/Figure_5.05-uicontroller-insp.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.05-uicontroller-insp.jpg]'
- en: Figure 5.5 – UI Controller's UI Panels list with PlaceObject added
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 添加了PlaceObject的UI控制器UI面板列表
- en: We added an instructional user prompt for the **PlaceObject** UI. When the user
    chooses to add an object to the scene, this panel will be displayed. Next, we'll
    add the **PlaceObject** mode and script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为**PlaceObject** UI添加了一个指导性用户提示。当用户选择将对象添加到场景中时，此面板将显示。接下来，我们将添加**PlaceObject**模式和脚本。
- en: Creating the PlaceObject mode
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PlaceObject模式
- en: To add a mode to the framework, we create a child GameObject under the **Interaction
    Controller** and write a mode script. The mode script will show the mode's UI,
    handle any user interactions, and then transition to another mode when it is done.
    For PlaceObject-mode, it will display the **PlaceObject UI** panel, wait for the
    user to tap the screen, instantiate the prefab object, and then return to Main-mode.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模式添加到框架中，我们在**Interaction Controller**下创建一个子GameObject并编写一个模式脚本。模式脚本将显示模式的UI，处理任何用户交互，并在完成后过渡到另一个模式。对于PlaceObject模式，它将显示**PlaceObject
    UI**面板，等待用户触摸屏幕，实例化预制对象，然后返回到主模式。
- en: 'Let''s write the `PlaceObjectMode` script as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式编写`PlaceObjectMode`脚本：
- en: Begin by creating a new script in your `Scripts/` folder using *right-click*
    `PlaceObjectMode`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的`Scripts/`文件夹中创建一个新的脚本，使用*右键点击* `PlaceObjectMode`。
- en: '*Double-click* the file to open it for editing and replace the default content,
    starting with the following declarations:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*文件以打开它进行编辑，并替换默认内容，从以下声明开始：'
- en: '[PRE0]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script will use APIs from `ARFoundation` and `ARSubsystems` so we specify
    these in the `using` statements at the top of the script. It will use the `ARRaycastManager`
    to determine which tracked plane the user has tapped. Then it will instantiate
    the `placedPrefab` into the scene.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该脚本将使用`ARFoundation`和`ARSubsystems`的API，所以我们指定这些在脚本顶部的`using`语句中。它将使用`ARRaycastManager`来确定用户触摸了哪个跟踪平面。然后它将实例化`placedPrefab`到场景中。
- en: 'When the mode is enabled, we will show the **PlaceObject UI** panel:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模式启用时，我们将显示**PlaceObject UI**面板：
- en: '[PRE1]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the user selects an object from the Main Menu, we need to tell `PlaceObjectMode`
    which prefab to instantiate, given the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户从主菜单中选择一个对象时，我们需要根据以下代码告诉`PlaceObjectMode`实例化哪个预制体：
- en: '[PRE2]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then when the user taps the screen, the Input System triggers an `OnPlaceObject`
    event (given the `touchPosition` to the `PlaceObject` function, which does a `Raycast`
    to find the tracked horizontal plane. If found, we `Instantiate` the `placedPrefab`
    at the `hitPose` location and orientation. And then the app returns to Main-mode.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后当用户触摸屏幕时，输入系统触发一个`OnPlaceObject`事件（将`touchPosition`传递给`PlaceObject`函数，该函数执行`Raycast`以找到跟踪的水平面。如果找到，我们在`hitPose`位置和方向实例化`placedPrefab`。然后应用程序返回到主模式）。
- en: Save the script and return to Unity.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到Unity。
- en: 'We can now add the mode to the Interaction Controller as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将模式添加到交互控制器中，如下所示：
- en: In the `PlaceObject Mode`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlaceObject Mode`中。
- en: Drag the **PlaceObjectMode** script from the **Project** window onto the **PlaceObject**
    **Mode** object adding it as a component.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**PlaceObjectMode**脚本从**项目**窗口拖到**PlaceObject** **Mode**对象上，将其添加为组件。
- en: Drag the **AR Session Origin** object from the **Hierarchy** onto the **Place
    Object Mode | Raycaster** slot.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Session Origin**对象从**层次结构**拖到**Place Object Mode | Raycaster**槽中。
- en: Now we'll add the mode to the **Interaction Controller**.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们将模式添加到**Interaction Controller**。
- en: In the **Hierarchy**, select the **Interaction Controller** object.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**Interaction Controller**对象。
- en: In the **Inspector**, at the bottom-right of the **Interaction Controller**
    component, click the **+** button to add an item to the **Interaction Modes**
    dictionary.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，在**Interaction Controller**组件的右下角，点击**+**按钮向**交互模式**字典添加一个项。
- en: Enter the `PlaceObject` text in the **Id** field.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Id**字段中输入`PlaceObject`文本。
- en: 'Drag the **PlaceObject Mode** game object from the **Hierarchy** onto the **Value**
    slot. The **Interaction Controller** component now looks like the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **PlaceObject 模式** 游戏对象从 **层次结构** 拖到 **值** 插槽。现在 **交互控制器** 组件看起来如下所示：
- en: '![Figure 5.6 – The Interaction Controller''s Interaction Modes list with PlaceObject
    added'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 添加 PlaceObject 后的交互控制器交互模式列表'
- en: '](img/Figure_5.06-interactionmodes-insp.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.06-interactionmodes-insp.jpg)'
- en: Figure 5.6 – The Interaction Controller's Interaction Modes list with PlaceObject
    added
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 添加 PlaceObject 后的交互控制器交互模式列表
- en: We have now added a `OnPlaceObject` input action event. Upon the input event,
    we use Raycast to determine where in the 3D space the user wants to place the
    object, then the script instantiates the prefab and returns to Main-mode.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已添加了一个 `OnPlaceObject` 输入动作事件。在输入事件发生时，我们使用 Raycast 确定用户想在 3D 空间中的哪个位置放置对象，然后脚本实例化预制件并返回到主模式。
- en: The final step is to wire up the main menu buttons.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将主菜单按钮连接起来。
- en: Wiring the menu buttons
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接菜单按钮
- en: 'When the user presses a main menu button to add an object to the scene, the
    button will tell `PlaceObjectMode` which prefab is to be instantiated. Then PlaceObject
    mode is enabled, which prompts the user to tap to place the object and handles
    the user input action. Let''s set up the menu buttons now using the following
    steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下主菜单按钮以向场景添加对象时，按钮将告诉 `PlaceObjectMode` 哪个预制件将被实例化。然后启用 PlaceObject 模式，提示用户轻触放置对象并处理用户输入动作。现在让我们按照以下步骤设置菜单按钮：
- en: Unfold the **Main Menu** game object in the **Hierarchy** by navigating to **UI
    Canvas / Main UI / Main Menu** and select the **Cube Button** object.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **UI Canvas / Main UI / 主菜单** 在 **层次结构** 中展开 **主菜单** 游戏对象，并选择 **立方体按钮**
    对象。
- en: In its **Inspector**, on the **Button** component, in its **OnClick** section,
    press the **+** button in the bottom right to add an event action.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其 **检查器** 中，在 **按钮** 组件的 **OnClick** 部分，按下右下角的 **+** 按钮以添加事件动作。
- en: From the **Hierarchy**, drag the **PlaceObject Mode** object onto the **OnClick
    Object** slot.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 中将 **PlaceObject Mode** 对象拖到 **OnClick Object** 插槽。
- en: In the **Function** selection list, choose **PlaceObject Mode | SetPlacedPrefab**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **函数** 选择列表中，选择 **PlaceObject Mode | SetPlacedPrefab**。
- en: In the `Assets/ARF-samples/Prefabs/` folder and drag the **AR Placed Cube**
    prefab into the **Game Object** slot for this click event in **Inspector**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/ARF-samples/Prefabs/` 文件夹中，将 **AR Placed Cube** 预制件拖到 **检查器** 中此点击事件的
    **Game Object** 插槽。
- en: Now let the button enable PlaceObject Mode. In its **Inspector**, on the **Button**
    component, in its **OnClick** section, press the **+** button in the bottom right
    to add another event action.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让按钮启用 PlaceObject 模式。在其 **检查器** 中，在 **按钮** 组件的 **OnClick** 部分，按下右下角的 **+**
    按钮以添加另一个事件动作。
- en: From the **Hierarchy**, drag the **Interaction Controller** object onto the
    **OnClick** event's **Object** slot.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 中将 **交互控制器** 对象拖到 **OnClick** 事件的 **Object** 插槽。
- en: In the **Function** selection list, choose **InteractionController | EnableMode**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **函数** 选择列表中，选择 **InteractionController | EnableMode**。
- en: In the string parameter field, enter `PlaceObject`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字符串参数字段中，输入 `PlaceObject`。
- en: 'The Cube Button object''s Button component now has the following **OnClick**
    event settings:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体按钮对象的按钮组件现在具有以下 **OnClick** 事件设置：
- en: '![Figure 5.7 – The OnClick events for the Cube Button'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 立方体按钮的 OnClick 事件'
- en: '](img/Figure_5.07-cubebutton-onclick-insp.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.07-cubebutton-onclick-insp.jpg)'
- en: Figure 5.7 – The OnClick events for the Cube Button
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 立方体按钮的 OnClick 事件
- en: 'Repeat these steps for the Sphere Button and Virus Button. As a shortcut we
    can copy/paste the component settings as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对球体按钮和病毒按钮重复这些步骤。作为一个快捷方式，我们可以按以下方式复制/粘贴组件设置：
- en: With the **Cube Button** selected in the **Hierarchy**, over in the **Inspector**,
    click the three-dot context menu for the **Button** component, and select **Copy
    Component**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 **立方体按钮**，在 **检查器** 中，点击 **按钮** 组件的三点上下文菜单，并选择 **复制组件**。
- en: In the **Hierarchy**, select the **Sphere Button** object.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 **球体按钮** 对象。
- en: In its **Inspector**, click the three-dot context menu for the **Button** component,
    and select **Paste Component Values**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其 **检查器** 中，点击 **按钮** 组件的三点上下文菜单，并选择 **粘贴组件值**。
- en: In the `Assets/ARF-samples/Prefabs/` folder and drag the **AR Placed Sphere**
    prefab into the **Game Object** slot for this click event in **Inspector**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/ARF-samples/Prefabs/` 文件夹中，将 **AR Placed Sphere** 预制件拖到 **检查器** 中此点击事件的
    **Game Object** 插槽。
- en: Likewise, repeat *steps 1-4* for the `Prefabs` folder).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对`Prefabs`文件夹重复*步骤 1-4*）。
- en: Save your work using **File | Save**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件 | 保存**保存您的作品。
- en: Everything should be set up now. We created a new scene using the `PlaceObjectMode`
    script that handles user input actions and instantiates the prefab, and wired
    it all up to the main menu buttons. Let's try it out!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该已经设置好了。我们使用`PlaceObjectMode`脚本创建了一个新场景，该脚本处理用户输入动作并实例化预制体，并将其所有内容连接到主菜单按钮。让我们试试吧！
- en: Performing a Building and Run
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行建筑和运行
- en: 'To build and run the project, use the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行项目，请按照以下步骤操作：
- en: Open the **Build Settings** window using **File | Build Settings**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件 | 构建设置**打开**构建设置**窗口。
- en: Click the `FrameworkDemo`) is not already in the **Scenes In Build** list.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`FrameworkDemo`)尚未在**构建场景列表**中。
- en: Ensure that the `FrameworkDemo` scene is the only one checked in the **Scenes
    In Build** list.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**构建场景列表**中只选中`FrameworkDemo`场景。
- en: Click **Build And Run** to build the project.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建和运行**以构建项目。
- en: 'When the project builds successfully, it starts up in Startup-mode while the
    AR Session is initializing. Then it goes into Scan-mode that prompts the user
    to scan the environment, until at least one horizontal plane is detected and tracked.
    Then it goes into Main-mode and displays the main menu. Screen captures of the
    app running on my phone in each of these modes are shown in the following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目构建成功时，它将在AR会话初始化时启动启动模式。然后它进入扫描模式，提示用户扫描环境，直到至少检测到一个水平平面并跟踪。然后它进入主模式并显示主菜单。以下图显示了在这些模式下在我的手机上运行的应用程序的屏幕截图：
- en: '![Figure 5.8 – Screen captures of Startup-mode, Scan-mode, and Main-mode'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 启动模式、扫描模式和主模式的屏幕截图'
- en: '](img/Figure_5.08-app-1-3.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.08 – 应用程序 1-3 的屏幕截图](img/Figure_5.08-app-1-3.jpg)'
- en: Figure 5.8 – Screen captures of Startup-mode, Scan-mode, and Main-mode
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 启动模式、扫描模式和主模式的屏幕截图]'
- en: On pressing one of the menu buttons, the app goes into PlaceObject-mode, prompting
    the user to tap to place an object. Tapping the screen instantiates the object
    at the specified location in the environment. Then the app returns to Main-mode.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下菜单按钮之一时，应用程序进入PlaceObject模式，提示用户轻触放置对象。轻触屏幕将在环境中指定位置实例化对象。然后应用程序返回主模式。
- en: We now have a working demo AR application for placing various virtual objects
    onto horizontal surfaces in your environment. One improvement might be to hide
    the trackable objects in Main-mode and only display them when needed in PlaceObject-mode.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作演示AR应用程序，可以将各种虚拟对象放置在您环境中的水平表面上。一个可能的改进是在主模式中隐藏可跟踪对象，仅在需要时在PlaceObject模式中显示它们。
- en: Hiding tracked objects when not needed
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不需要时隐藏跟踪对象
- en: When the app first starts tracking, we show the trackable planes and point clouds.
    This is useful feedback to the user when the app first starts and subsequently
    when placing an object. But once we have objects placed in the scene, these trackable
    visualizations can be distracting and unwanted. Let's only show the object while
    in PlaceObject-mode and hide them after at least one virtual object has been placed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用首次开始跟踪时，我们会显示可跟踪的平面和点云。这对于应用首次启动时以及放置对象时向用户提供有用的反馈。但是，一旦我们在场景中放置了对象，这些可跟踪的可视化可能会分散注意力且不受欢迎。让我们只在PlaceObject模式中显示对象，并在至少放置了一个虚拟对象后隐藏它们。
- en: 'In AR Foundation, hiding the trackables requires two separate things: hiding
    the existing trackables that have already been detected, and preventing new trackables
    from being detected and visualized. We will implement both.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在AR Foundation中，隐藏可跟踪对象需要两个单独的操作：隐藏已经检测到的现有可跟踪对象，并防止新的可跟踪对象被检测和可视化。我们将实现这两者。
- en: 'To implement this, we can write a separate component on **PlaceObject mode**
    that shows the trackables when enabled and hides them when disabled. Follow these
    steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以在**PlaceObject模式**上编写一个单独的组件，在启用时显示可跟踪对象，在禁用时隐藏它们。按照以下步骤操作：
- en: Create a new C# script in your `Scripts/` folder named `ShowTrackablesOnEnable`
    and open it for editing.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Scripts/`文件夹中创建一个新的C#脚本，命名为`ShowTrackablesOnEnable`，并打开它进行编辑。
- en: 'At the top of the class, add variable references to `ARSessionOrigin`, `ARPlaneManager`,
    and `ARPointCloudManager`. Also, we will now remember the most recently placed
    object in `lastObject`, and initialize them in `Awake`, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部，添加对`ARSessionOrigin`、`ARPlaneManager`和`ARPointCloudManager`的变量引用。现在，我们将记住最近放置的对象在`lastObject`中，并在`Awake`中初始化它们，如下所示：
- en: '[PRE3]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I've also added an `isStarted` flag that we'll use to prevent the visualizers
    from being hidden when the app starts up.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我还添加了一个 `isStarted` 标志，我们将用它来防止在应用启动时隐藏可视化器。
- en: 'Info: OnEnable and OnDisable can be called before Start'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息：`OnEnable` 和 `OnDisable` 可以在 `Start` 之前被调用
- en: In the life cycle of a `MonoBehaviour` component, `OnEnable` is called when
    the object becomes enabled and active. `OnDisable` is called when the script object
    becomes inactive. `Start` is called on the first frame the script is enabled,
    just before `Update`. See [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html).
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `MonoBehaviour` 组件的生命周期中，当对象被启用并激活时调用 `OnEnable`。当脚本对象变为非活动状态时调用 `OnDisable`。在脚本被启用后的第一帧调用
    `Start`，在 `Update` 之前。请参阅 [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html)。
- en: In our app, it is possible for `OnDisable` to get called before `Start` (when
    we're initializing the scene from `InteractionController`). To prevent `ShowTrackables(false)`
    from getting called before the scene has started, we use an `isStarted` flag in
    this script.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的应用中，`OnDisable` 可能会在 `Start` 之前被调用（当我们从 `InteractionController` 初始化场景时）。为了防止在场景开始之前调用
    `ShowTrackables(false)`，我们在脚本中使用一个 `isStarted` 标志。
- en: 'We will show the trackables when the mode is enabled and hide them when disabled
    using the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模式启用时，我们将显示可追踪对象，当禁用时，将使用以下代码隐藏它们：
- en: '[PRE4]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These call `ShowTrackables`, which we implement as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些调用 `ShowTrackables`，我们按以下方式实现：
- en: '[PRE5]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting `SetTrackablesActive(false)` will hide all the existing trackables.
    Disabling the trackable manager component itself will prevent new trackables from
    being added. We check for null managers in case the component is not present in
    `ARSessionOrigin`.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置 `SetTrackablesActive(false)` 将隐藏所有现有的可追踪对象。禁用可追踪管理器组件本身将防止添加新的可追踪对象。我们检查
    `ARSessionOrigin` 中是否存在空管理器，以防组件不存在。
- en: Save the script.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Back in Unity, select the **PlaceObject Mode** game object in the **Hierarchy**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Unity，在 **Hierarchy** 中选择 **PlaceObject 模式** 游戏对象。
- en: Drag the `ShowTrackablesOnEnable` script onto the **PlaceObject Mode** object.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ShowTrackablesOnEnable` 脚本拖放到 **PlaceObject 模式** 对象上。
- en: Drag the **AR Session Origin** object from the **Hierarchy** into the **Inspector**
    and drop it onto the **Show Trackables On Enable | Session Origin** slot.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AR Session Origin** 对象从 **Hierarchy** 拖到 **Inspector**，然后将其拖放到 **Show Trackables
    On Enable | Session Origin** 插槽中。
- en: Save the scene using **File | Save**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **文件 | 保存** 保存场景。
- en: 'Now when you click **Build And Run** again, the trackables will be shown when
    PlaceObject Mode is enabled, and will be hidden when disabled. Thus, the trackables
    will be visible when Main mode is first enabled but after an object has been placed
    and the app goes back to Main-mode, the trackables will be hidden. This is the
    behavior we desire. The PlaceObject-mode and subsequent Main-mode are shown in
    the following screen captures of the project running on my phone:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您再次点击 **Build And Run** 时，当 PlaceObject 模式启用时，可追踪对象将被显示，当禁用时将被隐藏。因此，当 Main
    模式首次启用时，可追踪对象将是可见的，但在放置对象并应用回到 Main 模式后，可追踪对象将被隐藏。这是我们期望的行为。PlaceObject 模式和随后的
    Main 模式在以下手机运行项目屏幕截图中显示：
- en: '![Figure 5.9 – Screen captures of PlaceObject-mode, and subsequent Main-mode
    with trackables hidden'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – PlaceObject 模式屏幕截图，以及随后隐藏可追踪对象的主模式'
- en: '](img/Figure_5.09-app-4-5.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.09-app-4-5.jpg)'
- en: Figure 5.9 – Screen captures of PlaceObject-mode, and subsequent Main-mode with
    trackables hidden
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – PlaceObject 模式和随后隐藏可追踪对象的主模式屏幕截图
- en: 'Tip: Disable trackables by modifying the plane detection mode'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：通过修改平面检测模式来禁用可追踪对象
- en: To disable plane detection, the method I'm using is to disable the manager component.
    This is the technique given in the example `PlaneDetectionController.cs` script
    in the AR Foundation Samples project. Alternatively, the Unity ARCore XR Plugin
    docs ( [https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html))
    recommend disabling plane detection by setting the `ARPlaneManager` detection
    mode to the value `PlaneDetectionMode.None`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用平面检测，我使用的方法是禁用管理器组件。这是在 AR Foundation 示例项目中提供的 `PlaneDetectionController.cs`
    脚本中给出的技术。作为替代，Unity ARCore XR 插件文档（[https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.xr.arcore@4.1/manual/index.html)）建议通过将
    `ARPlaneManager` 检测模式设置为 `PlaneDetectionMode.None` 来禁用平面检测。
- en: We've now completed a simple AR project to place various virtual objects on
    horizontal planes detected in the environment, using our AR user framework.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了一个简单的 AR 项目，使用我们的 AR 用户框架在环境中检测到的水平平面上放置各种虚拟对象。
- en: 'Further improvements you could add to the project include the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加到项目中的进一步改进包括以下内容：
- en: A reset button in the main menu to remove any virtual objects already placed
    in the scene.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单中的重置按钮，用于移除场景中已放置的任何虚拟对象。
- en: Only allow one instance of a virtual object to be placed in the scene at a time.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只允许放置一个虚拟对象到场景中。
- en: 'The ability to move and resize an existing object (see [*Chapter 7*](B15145_07_Final_SB_epub.xhtml#_idTextAnchor170)*,
    Gallery: Editing Virtual Objects*).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动和调整现有对象大小的能力（参见[*第 7 章*](B15145_07_Final_SB_epub.xhtml#_idTextAnchor170)*，图库：编辑虚拟对象*）。
- en: Can you think of more improvements? Let us know.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您能想到更多的改进吗？请告诉我们。
- en: In the rest of this chapter, we'll discuss some advanced onboarding and user
    experience features you may want to include in your projects at a later time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将讨论一些您可能希望在以后的项目中包含的高级入门和用户体验功能。
- en: Advanced onboarding issues
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级入门问题
- en: 'In this section, we''ll review some other issues related to AR onboarding,
    AR sessions, and devices, including the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些与 AR 入门、AR 会话和设备相关的问题，包括以下内容：
- en: Making an AR-optional project
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可选 AR 的项目
- en: Determining whether the device supports a specific AR feature
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定设备是否支持特定的 AR 功能
- en: Adding localization to your project
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的项目添加本地化支持
- en: Making an AR-optional project
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个可选 AR 的项目
- en: Some applications are intended to be run specifically using AR features and
    should just quit (after a friendly notification to the user) if it's not supported.
    But other applications may want to behave like an ordinary mobile app with an
    extra optional capability of supporting AR features.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序旨在专门使用 AR 功能运行，并且如果不受支持，应该（在向用户发出友好通知后）直接退出。但其他应用程序可能希望表现得像一个普通的移动应用，同时额外提供支持
    AR 功能的可选能力。
- en: For example, a game I recently created, Epoch Resources (available for Android
    at [https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&hl=en_US&gl=US](https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&hl=en_US&gl=US),
    and iOS at [https://apps.apple.com/us/app/epoch-resources/id1455848902](https://apps.apple.com/us/app/epoch-resources/id1455848902))
    is a planetary evolution incremental game with a 3D planet you mine for resources.
    It offers an optional AR-viewing mode where you can "pop" the planet into your
    living room and continue playing the game in AR, as shown in the following image.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我最近创建的一个游戏，Epoch Resources（可在 Android [https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&hl=en_US&gl=US](https://play.google.com/store/apps/details?id=com.parkerhill.EpochResources&hl=en_US&gl=US)
    和 iOS [https://apps.apple.com/us/app/epoch-resources/id1455848902](https://apps.apple.com/us/app/epoch-resources/id1455848902)
    上找到）是一款行星演化的增量游戏，您可以在其中挖掘 3D 行星以获取资源。它提供了一个可选的 AR 观看模式，您可以将行星“弹出”到您的客厅，并在 AR 中继续玩游戏，如下面的图片所示。
- en: '![Figure 5.10 – Epoch Resources is an AR-optional game'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – Epoch Resources 是一款可选 AR 的游戏'
- en: '](img/Figure_5.10-EpochResources.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10-EpochResources.jpg)'
- en: Figure 5.10 – Epoch Resources is an AR-optional game
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – Epoch Resources 是一款可选 AR 的游戏
- en: For an AR-optional application, your app will probably start up as an ordinary
    non-AR app. Then at some point the user may choose to turn on AR-specific features.
    That's when you'll activate the AR Session and handle the onboarding UX.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个可选 AR 的应用程序，您的应用可能最初启动为一个普通的非 AR 应用。然后，在某个时刻，用户可能会选择开启 AR 特定功能。那时，您将激活 AR
    会话并处理用户入门 UX。
- en: None of the projects in this book implement AR-optional so this is an informational
    discussion only. To start, you'll tell the XR Plugin that AR is optional by going
    to **Edit | Project Settings | XR Plug-in Management** and selecting **Requirement
    | Optional** (instead of **Required**) for each of your platforms (ARCore and
    ARKit are set separately).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有项目都没有实现可选 AR，因此这只是一个信息性讨论。首先，您需要通过访问**编辑 | 项目设置 | XR 插件管理**并选择每个平台（ARCore
    和 ARKit 分别设置）的**需求 | 可选**（而不是**必需**）来告诉 XR 插件 AR 是可选的。
- en: You will need a mechanism for running with or without AR. One approach is to
    have separate AR and non-AR scenes that are loaded as needed (see [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个机制来决定是否运行AR或非AR模式。一种方法是有单独的AR和非AR场景，根据需要加载（见[https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html)）。
- en: In the case of the Epoch Resources game, we did not create two separate scenes.
    Rather the scene contains two cameras, the normal default camera for non-AR mode
    and the AR Session Origin (with child camera) for AR mode. We then flip between
    the two cameras when the user toggles viewing modes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在《纪元资源》游戏的情况下，我们没有创建两个独立的场景。相反，场景包含两个摄像头，一个是用于非AR模式的正常默认摄像头，另一个是用于AR模式的AR会话原点（带有子摄像头）。然后当用户切换查看模式时，我们在两个摄像头之间切换。
- en: Another issue you may run into is determining whether the user's device supports
    a specific AR feature at runtime.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的问题之一是在运行时确定用户的设备是否支持特定的AR功能。
- en: Determining whether the device supports a specific AR feature
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定设备是否支持特定的AR功能
- en: It is possible that your app requires a specific AR feature that is not supported
    by all devices. We can ask the Unity AR subsystems what features are supported
    by getting the subsystem descriptor records.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的应用程序需要特定的AR功能，但并非所有设备都支持。我们可以通过获取子系统描述符记录来询问Unity AR子系统支持哪些功能。
- en: 'For example, suppose we are interested in detecting vertical planes. Some older
    devices may support AR but only horizontal planes. The following code illustrates
    how to get and check plane detection support:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们感兴趣的是检测垂直平面。一些较旧的设备可能支持AR，但只支持水平平面。以下代码说明了如何获取和检查平面检测支持：
- en: '[PRE6]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The types of descriptors available in AR Foundation include the following (their
    purpose is self-evident from their names):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: AR Foundation中可用的描述符类型包括以下几种（它们的功能从其名称中显而易见）：
- en: '`XRPlaneSubsystemDescriptor`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRPlaneSubsystemDescriptor`'
- en: '`XRRaycastSubsystemDescriptor`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRRaycastSubsystemDescriptor`'
- en: '`XRFaceSubsystemDescriptor`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRFaceSubsystemDescriptor`'
- en: '`XRImageTrackingSubsystemDescriptor`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRImageTrackingSubsystemDescriptor`'
- en: '`XREnvironmentProbeSubsystemDescriptor`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XREnvironmentProbeSubsystemDescriptor`'
- en: '`XRAnchorSubsystemDescriptor`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRAnchorSubsystemDescriptor`'
- en: '`XRObjectTrackingSubsystemDescriptor`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRObjectTrackingSubsystemDescriptor`'
- en: '`XRParticipantSubsystemDescriptor`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRParticipantSubsystemDescriptor`'
- en: '`XRDepthSubsystemDescriptor`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRDepthSubsystemDescriptor`'
- en: '`XROcclusionSubsystemDescriptor`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XROcclusionSubsystemDescriptor`'
- en: '`XRCameraSubsystemDescriptor`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRCameraSubsystemDescriptor`'
- en: '`XRSessionSubsystemDescriptor`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRSessionSubsystemDescriptor`'
- en: '`XRHumanBodySubsystemDescriptor`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XRHumanBodySubsystemDescriptor`'
- en: Documentation for the AR Subsystems API and these descriptor records can be
    found at [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html).
    For example, the `XRPlaneSubsystemDescriptor` record we used here is documented
    at [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: AR子系统API和这些描述符记录的文档可以在[https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.html)找到。例如，我们这里使用的`XRPlaneSubsystemDescriptor`记录在[https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.2/api/UnityEngine.XR.ARSubsystems.XRPlaneSubsystemDescriptor.Cinfo.html)有文档说明。
- en: If you are planning to distribute your application in different countries, you
    may also be interested in localization.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在不同国家分发你的应用程序，你可能也会对本地化感兴趣。
- en: Adding localization
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加本地化
- en: Localization is the translation of text strings and other assets into local
    languages. It can also specify date and currency formatting, alternative graphics
    for national flags, and so on, to accommodate international markets and users.
    The Unity Localization package provides a standard set of tools and data structures
    for localizing your application. More information can be found at [https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html](mailto:https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html).
    We do not use localization in any projects in this book, except where already
    supported by imported assets such as the Onboarding UX assets from the AR Foundation
    Demos project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化是将文本字符串和其他资产翻译成本地语言的过程。它还可以指定日期和货币格式、国家国旗的替代图形等，以适应国际市场和用户。Unity 本地化包提供了一套标准工具和数据结构，用于本地化您的应用程序。更多信息可以在
    [https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html](mailto:https://docs.unity3d.com/Packages/com.unity.localization@0.10/manual/QuickStartGuide.html)
    找到。在本书中，我们除了使用导入的资产（如 AR Foundation Demos 项目的 Onboarding UX 资产）已经支持本地化的项目外，不使用本地化。
- en: 'The Unity Onboarding UX assets has built-in support for localization of the
    user prompts and explanation of scanning problems. The `ReasonsUX` localization
    tables given with the Onboarding UX project, for example, can be opened by selecting
    **Window | Asset Management | Localization Tables** and is shown in the following
    screenshot. You can see, for example, the second-row **INIT** key says in English,
    **Initializing augmented reality**, along with the same string translated into
    many other languages:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Onboarding UX 资产内置了对用户提示和扫描问题解释的本地化支持。例如，与 Onboarding UX 项目一起提供的 `ReasonsUX`
    本地化表格可以通过选择 **窗口 | 资产管理 | 本地化表格** 来打开，如下面的截图所示。例如，您可以看到第二行的 **INIT** 键在英文中是 **Initializing
    augmented reality**，以及翻译成多种其他语言的相同字符串：
- en: '![Figure 5.11 – The ReasonsUX localization tables included in Onboarding UX
    assets'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 包含在 Onboarding UX 资产中的 ReasonsUX 本地化表格'
- en: '](img/Figure_5.11-Localization-tables.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.11-Localization-tables.jpg)'
- en: Figure 5.11 – The ReasonsUX localization tables included in Onboarding UX assets
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 包含在 Onboarding UX 资产中的 ReasonsUX 本地化表格
- en: 'In the code, the **Initializing augmented reality** message, for example, is
    retrieved with a call like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，例如，使用如下调用检索 **Initializing augmented reality** 消息：
- en: '[PRE7]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we added the onboarding UX prefab (`ARFoundationDemos/UX/Prefabs/ScreenspaceUI`)
    to our scene, I had you disable the **Localization Manager** component because
    it gives runtime errors until it is set up. Provided you''ve installed the **Localization**
    package via **Package Manager** as described earlier in this chapter, we can set
    it up now for the project using the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 onboarding UX 预制件 (`ARFoundationDemos/UX/Prefabs/ScreenspaceUI`) 添加到场景中时，我让您禁用了
    **本地化管理器** 组件，因为它在设置好之前会引发运行时错误。假设您已经通过 **包管理器** 安装了 **本地化** 包，如本章前面所述，我们现在可以使用以下步骤为项目设置它：
- en: Open the **Localization** settings window by going to **Edit | Project Settings
    | Localization**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **编辑 | 项目设置 | 本地化** 打开 **本地化** 设置窗口。
- en: In the `Assets/ARFOundationDemos/Common/Localization/` and drag the `LocalizationSettings`
    asset onto the **Location Settings** slot (or use the *doughnut* icon to open
    the **Location Setting Select** dialog box).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/ARFOundationDemos/Common/Localization/` 中，将 `LocalizationSettings`
    资产拖放到 **位置设置** 槽中（或使用 *甜甜圈* 图标打开 **位置设置选择** 对话框）。
- en: In the settings window, click **Add All**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置窗口中，点击 **添加全部**。
- en: In the **Hierarchy** window, select the **OnboardingUX** object and in the **Inspector**,
    enable the **Localization Manager** component.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中，选择 **OnboardingUX** 对象，并在 **检查器** 中启用 **本地化管理器** 组件。
- en: Open the **Addressables Groups** window using **Window | Asset Management |
    Addressables | Groups**.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **窗口 | 资产管理 | 可寻址 | 组** 打开 **可寻址组** 窗口。
- en: From the **Addressables Groups** menu bar, select **Build | New Build | Default
    Build Script**. You will need to do this for each target platform you are building
    (for example, once for Android and once for iOS).
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **可寻址组** 菜单栏中选择 **构建 | 新构建 | 默认构建脚本**。您需要为每个构建的目标平台执行此操作（例如，一次为 Android，一次为
    iOS）。
- en: As you can see in this last step, the Localization package uses Unity's new
    **Addressables** system for managing, packing, and loading assets from any location
    locally or over the internet ([https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html](https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html)).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在最后一步看到的，本地化包使用 Unity 的新 **Addressables** 系统来管理、打包和从本地或互联网上的任何位置加载资源 ([https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html](https://docs.unity3d.com/Packages/com.unity.addressables@1.12/manual/index.html))。
- en: Note that as I'm writing this, the Onboarding UX `LocalizationManager` script
    does not select the language at runtime. The language must be set in the Inspector
    and compiled into your build.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我写这篇文档的时候，入职 UX 的 `LocalizationManager` 脚本在运行时不会选择语言。语言必须在检查器中设置，并编译到您的构建中。
- en: The AR UI framework we built in this chapter can be used as a template for new
    scenes. Unity makes it easy to set that up.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中构建的 AR UI 框架可以用作新场景的模板。Unity 使其设置变得简单。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we got a chance to use the AR user framework we developed in
    the previous [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating
    an AR User Framework*, in a simple AR *Place Object Demo* project. We created
    a new scene using the `ARFramework` scene template that implements a state machine
    mechanism for managing user interaction modes. It handles user interaction with
    a controller-view design pattern, separating the control scripts from the UI graphics.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有机会使用在上一章[*第 4 章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*，创建
    AR 用户框架*中开发的 AR 用户框架，在一个简单的 AR *放置对象演示*项目中。我们使用 `ARFramework` 场景模板创建了一个新场景，该模板实现了一个状态机机制来管理用户交互模式。它使用控制器-视图设计模式处理用户交互，将控制脚本与
    UI 图形分离。
- en: By default, the scene includes the AR Session and AR Session Origin components
    required by AR Foundation. The scene is set up with a Canvas UI containing separate
    panels that will be displayed for each interaction mode. It also includes an Interaction
    Controller that references separate mode objects, one for each interaction mode.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，场景包括 AR Foundation 所需的 AR Session 和 AR Session Origin 组件。场景配置了一个包含单独面板的
    Canvas UI，每个交互模式将显示不同的面板。它还包括一个引用单独模式对象的交互控制器，每个交互模式一个。
- en: The modes (and corresponding UI) given with the template are Startup, Scan,
    Main, and NonAR. An app using this framework first starts in Startup-mode while
    the AR Session is initializing. Then it goes into Scan-mode, prompting the user
    to scan the environment for trackable features, until a horizontal plane is detected.
    Then it goes into Main-mode and displays the main menu.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 模式（以及相应的 UI）包括启动、扫描、主和非 AR。使用此框架的应用首先在启动模式开始，此时 AR 会话正在初始化。然后它进入扫描模式，提示用户扫描环境中的可追踪特征，直到检测到水平面。然后它进入主模式并显示主菜单。
- en: For this project, we added a main menu that is displayed during Main-mode and
    that contains buttons for placing various virtual objects in the environment.
    Pressing a button enables a new PlaceObject-mode that we added to the scene. When
    PlaceObject-mode is enabled, it displays an instructional animated prompt for
    the user to tap to place an object in the scene. After an object is added, the
    app returns to Main-mode, and the trackables are hidden so you can see your virtual
    objects in the real world without any extra distractions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们添加了一个在主模式期间显示的主菜单，其中包含将各种虚拟对象放置在环境中的按钮。按下按钮将启用我们添加到场景中的新 PlaceObject
    模式。当 PlaceObject 模式启用时，它显示一个指导性的动画提示，用户需要点击以在场景中放置对象。添加对象后，应用返回主模式，可追踪对象被隐藏，这样您就可以在没有额外干扰的情况下在真实世界中看到您的虚拟对象。
- en: In the next chapter, we will go beyond a simple demo project and begin to build
    a more complete AR application – a photo gallery where you can place framed photos
    of your favorite pictures on the drab walls in your home or office.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将超越简单的演示项目，开始构建一个更完整的 AR 应用程序——一个照片画廊，您可以在家中或办公室的乏味墙壁上放置您最喜欢的照片的相框。
