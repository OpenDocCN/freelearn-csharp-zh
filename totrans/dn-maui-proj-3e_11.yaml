- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Calculator Using .NET MAUI Blazor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore a .NET `BlazorWebView`. We will also communicate
    between Blazor and .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the differences between .NET MAUI projects and .NET MAUI Blazor projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML and CSS to define a UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XAML controls with HTML in a WebView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing C# code that will integrate with XAML controls and HTML controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the main .NET MAUI window to resize it to its contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to have Visual Studio for Mac or PC installed, as well as the
    .NET MAUI components. See *Chapter 1*, *Introduction to .NET MAUI*, for more details
    on how to set up your environment. The source code for this chapter is available
    in this book’s GitHub repository: [https://github.com/](https://github.com/)PacktPublishing/MAUI-Projects-3rd-Edition.'
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will discover .NET Blazor and how to use it with .NET MAUI
    to develop a UI for an app. We will explore the different options available for
    hosting a Blazor app within a .NET MAUI app. Communication between the two apps
    is a crucial part of the interoperability and this chapter’s project will show
    you how to send data from .NET MAUI to Blazor and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Blazor is a web framework built on top of .NET. Blazor applications run
    in the browser by using **WebAssembly** (**WASM**), or on a server using SignalR.
    Blazor is one part of the whole ASP.NET ecosystem, and it leverages Razor pages
    for developing the UI. Blazor uses HTML and CSS to render a rich UI. Blazor uses
    a component-based UI, where each component is a Razor markup page. Within a Razor
    page, you can mix and match HTML, CSS, and C# code. There are three deployment
    models for a Blazor app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blazor Server**: In a Blazor Server deployment, the application code runs
    on the server in an ASP.NET Core app, and it communicates with the UI running
    in a browser via SignalR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor WebAssembly**: For Blazor WebAssembly, the entire app runs in the
    browser via WASM. It is an open web standard that makes it possible to run .NET
    code safely in the browser. WASM provides interoperability with JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor Hybrid**: Blazor Hybrid is a blend of native .NET and web technologies.
    Blazor Hybrid apps can be hosted in .NET MAUI, **WPF**, and **Windows Forms**
    applications. Since the hosts are all .NET, the Blazor runtime runs natively within
    the same .NET process and renders the Razor page web UI into a WebView control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have some general knowledge of Blazor, let’s look at the app we
    will build in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the calculator app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to build a calculator app. The UI for the calculator
    is built using Razor pages in Blazor, but the actual mechanics of the calculator
    reside in the .NET MAUI app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project, like all the rest, is a **File** | **New** | **Project...**-style
    project. This means that we will not be importing any code at all. So, this first
    section is all about creating the project and setting up the basic project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to create a new .NET MAUI project. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio 2022 and select **Create a** **new project**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.1 – Visual \uFEFFStudio 2022](img/B19214_11_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Visual Studio 2022
  prefs: []
  type: TYPE_NORMAL
- en: This will open the **Create a new** **project** wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the search field, type in `blazor` and select the **.NET MAUI Blazor App**
    item from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.2 – Create a n\uFEFFew project](img/B19214_11_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Create a new project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `Calculator` as the name of the app, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Configure your new project](img/B19214_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Configure your new project
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Additional information](img/B19214_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Additional information
  prefs: []
  type: TYPE_NORMAL
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it for project creation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by reviewing the structure of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a .NET MAUI Blazor Hybrid project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you run the project, you will see an app, as shown in *Figure 11**.5*. It
    does not resemble the .NET MAUI app template and has a distinctive web feel to
    it. Poke around the app a little bit to see how all the visual elements work together.
    Then, close the application, return to Visual Studio, and continue exploring the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Running the .NET MAUI Blazor template project](img/B19214_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Running the .NET MAUI Blazor template project
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the .NET MAUI Blazor app is a mashup of a .NET MAUI app and
    a Blazor app. If you look at the `Platforms` and `Resources` folders and the `App.xaml`,
    `MainPage.xaml`, and `MauiProgram.cs` files that are normally present in the .NET
    MAUI template. The `wwwroot`, `Data`, `Pages`, and `Shared` folders all support
    the Blazor app. Additionally, you’ll find `_Imports.razor` and `Main.razor` at
    the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Solution Explorer view of a .NET MAUI Blazor project](img/B19214_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Solution Explorer view of a .NET MAUI Blazor project
  prefs: []
  type: TYPE_NORMAL
- en: If you need a refresher on how a .NET MAUI app is structured and works, refer
    to *Chapter 1*. Ignoring how a Blazor app works for the moment, let’s take a look
    at how a Blazor app is hosted by .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all .NET MAUI programs start with the `MauiProgram.cs` file, that seems
    like a good place to start. Open the `MauiProgram.cs` file and inspect its contents.
    The following snippet highlights the differences for a .NET MAUI Blazor app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first highlighted line enables the hosting services for the Blazor app,
    specifically the WebView controller. The second highlighted line enables the developer
    tools (*F12*) within the WebView control, but only in a debug configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.xaml` and `App.xaml.cs` are essentially the same as in a .NET MAUI template
    project, but `MainPage.xaml` is not. Open the `MainPage.xaml` file to inspect
    its contents, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`MainPage` has a single control, `BlazorWebView`. This is a wrapper around
    the native controls to host web pages in apps. The `HostPage` attribute points
    to the starting page – in this case, `wwwroot/index.html`. The `BlazorWebView.RootComponents`
    element identifies the starting points for the Blazor application and the location
    where they are hosted on the page. In this case, `RootComponent` `Main` is rooted
    in the element with an ID of `app`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see where the `app` element is located, open the `index.html` file in the
    `wwwroot` folder and inspect its contents, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The key parts of the file are highlighted in the preceding code. First, the
    `div` element with `id` set to `app` is where the `Main` component is rooted,
    or loaded. In the header of the page, the stylesheets are identified. The first
    stylesheet, `app.css`, is located in the `wwwroot/css` folder of the project.
    The second stylesheet, `Calculator.Styles.css`, is created during the build process
    from isolated CSS files. `_framework/blazor.webview.js` file is imported and is
    responsible for doing all the heavy lifting of getting your Blazor components
    rendered at the right location on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece for us to review before we move on to creating the rest of
    the application is the Blazor components. `Main.razor` is a routing file that
    directs the Blazor runtime to the starting component, `MainLayout.razor`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainLayout.razor` file defines the basic layout of the page, with a navigation
    bar on the left, and the main body consuming the remainder of the page, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `@Body` content is provided by the page that satisfies the route. For the
    first page, that would be `/`. If you look at the files in the `Pages` folder,
    the `Index.razor` file has a `@page` directive with an argument of `/`. So, by
    default, that is the page that would be displayed. The `@page` directive is a
    Razor construct that allows the route to be satisfied without using a controller.
    The `NavLink` entries in the `Shared/NavMenu.razor` file reference the route using
    the `href` attribute. That value is looked up in the list of `@page` directives
    to find a match. If no match is found, then the content in the `<NotFound>` element
    in the `Main.razor` file is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Pages/Counter.razor` page to see how a Razor page works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After the `@page` directive, the page is made up of HTML mixed with some Razor
    directives. Then, there’s the `@code` directive, which contains the C# code for
    the page. The HTML `button` element has its click event mapped to the C# `IncrementCount`
    method using the `@``onclick` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Razor pages, take a look at the official documentation at
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-7.0).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s start creating the project.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET MAUI and Blazor integrate seamlessly – so seamlessly that it is sometimes
    hard to differentiate what is executing where. That makes it very easy to render
    data in both XAML and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started by preparing the project for the calculator. We will start
    by removing much of the template code we won’t be using. Follow these steps to
    prepare the template:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, using `Data` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Pages` folder, delete `Index.razor`, `Counter.Razor`, and `FetchData.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Shared` folder, delete `NavMenu.razor`, `NavMenu.razor.css`, and `SurveyPrompt.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the `Pages` folder, then select **Add** | **Razor Component…**,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Adding a new Razor component](img/B19214_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Adding a new Razor component
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Keypad.razor` and click **Add**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.8 – Razor \uFEFFcomponent](img/B19214_11_8.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Razor component
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new `Keypad.razor` file, add the following highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `MainLayout.razor` file in the `Shared` folder and remove the following
    highlighted sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `MauiProgram.cs` and remove the highlighted lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the project to see the effects of the changes, as shown in *Figure
    11**.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Running the blank calculator app on Windows](img/B19214_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Running the blank calculator app on Windows
  prefs: []
  type: TYPE_NORMAL
- en: Now that the project is ready to be an app, let’s start with the Keypad view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Keypad view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Keypad view is the basic functionality of the calculator. It has buttons
    for each digit, 0 through 9, the decimal separator, *.*, clear, *C*, clear everything,
    *CE*, and, finally, addition, *+*, subtraction, *-*, multiplication, *x*, division,
    */*, *=* to get the result, and *<* to erase the last character. The view has
    three basic components to it – HTML and CSS for styling and the C# code. Each
    of the following sections will guide you through adding each of these components
    for the view, starting with the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Razor files and .NET MAUI XAML files do not have a designer for you to visualize
    your changes. You have to run your app to see the changes you have made, which
    usually involves building, deploying, and then navigating to the view in your
    app. .NET has a time-saving feature called Hot Reload. It works by applying the
    changes you make to your Razor, XAML, CSS, and C# files to the running application
    without you having to stop and restart the app. Try using **Hot Reload** while
    you go through the next set of steps. To apply the changes, use the **Hot Reload**
    button in the **Debug** toolbar. It’s easy to find – it’s the flames icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – The Hot Reload toolbar button](img/B19214_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – The Hot Reload toolbar button
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any point you receive a “Rude Edit” dialog like the following, it just
    means that the change cannot be applied by Hot Reload, so you need to stop, rebuild,
    and restart debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.11 – Hot Reload \uFEFFdialog](img/B19214_11_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Hot Reload dialog
  prefs: []
  type: TYPE_NORMAL
- en: Hot Reload is constantly getting better, so there will be fewer and fewer of
    these cases in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the HTML that will provide you with the UI to interact with the keypad,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the app by using the debugger or pressing *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to see your app in Visual Studio, you can open the **XAML Live Preview**
    pane. To open the **XAML Live Preview** pane, use the Visual Studio menu and select
    **Debug** | **Windows** | **XAML Live Preview**. I usually pin it open so that
    it is always available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Keypad.razor` file in the `Pages` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the highlighted content shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following HTML after `@page` but before the `@``code` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don’t forget to press the `div` and not `table` since it is easier to style
    `div` elements than `table` elements. The keypad is arranged in rows of four buttons,
    except for the top two rows. The top row is the display where the expression or
    result is shown. The second row only has three buttons. The class names have already
    been added to the HTML elements, but since they don’t exist yet, they don’t alter
    the appearance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The keypad doesn’t quite look like a keypad yet, but it will once we add some
    style to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding style to the HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS has been around for a very long time and is the best way to make your HTML
    look its best. Follow these steps to add the styles we used in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure your app is still running and use `Keypad.razor.css` in the `Pages`
    folder. Click the **Show All Templates** button if Visual Studio doesn’t display
    them by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Adding a new CSS file](img/B19214_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Adding a new CSS file
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look in `Pages` folder, you will notice that your new file is now under
    the `Keypad.razor` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 11.13 – A Razor page with an isolated CSS file](img/B19214_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – A Razor page with an isolated CSS file
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio automatically recognized that you wanted to add an `Keypad.razor`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `keypad` style to the `Keypad.razor.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This style will set the width of the element to `300px`, with automatic margins,
    except for the top, which is at `-1.1em`. `-1.1em` moves the top edge of the keypad
    right up against the top of the web view control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the `keypad-body` style using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This style just gives the entire element a border one pixel wide in a dark gray
    color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will save the `keypad-screen` and `keypad-typed` styles for last, so add
    the `keypad-row` style shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This style sets the element width to 100% of its parent, which would be `keypad-body`,
    and sets the background to a pleasing dark gray color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next style to add is `keypad-button`. Use the following code to add the
    style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This style is the base for all the buttons on the keypad, hence it has the most
    attributes. Elements that have this style applied have a border on the right and
    bottom that is 2 pixels wide and uses the same color as the background of the
    row. The `background` attribute of the button is a bit darker than the border
    color, which provides a bit of depth. The text is aligned in the center both vertically
    and horizontally and uses a 25-pixel font size. The width is set to 25% since
    there are four buttons in a row, mostly. The `transition` attribute imposes a
    200-millisecond transition using `ease-in-out`, which accelerates from the start
    to the middle and then decelerates from the middle to the end. `transition` is
    applied to all attributes, so any time an attribute of this style changes, it
    will slowly change from the starting value to the end value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the button is an action button, such as an operator, then an additional
    style is applied, called `operator`. The definition of this style is slightly
    different from the rest of the styles that have been created so far. Instead of
    just being named `operator`, this style is named `keypad-button.operator`. In
    CSS, `.` is a selector; it is used to locate which attributes to apply. In this
    case, we want all elements that have both the `keypad-button` class and the `operator`
    class applied. To add the `keypad-button.operator` class, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These buttons will appear with a slightly darker background with slightly less
    white text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The clear (*C*) and clear everything (*CE*) buttons also have their own class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These buttons will appear with slightly darker backgrounds with red text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, for the desktop, we can add hover highlighting by using the `:hover` pseudo
    selector. Add the hover styles using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The background is altered to an orange color. The change isn’t immediate due
    to the `transition` attribute on the `keypad-button` style, so it will transition
    from dark gray to orange in two-tenths of a second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last button-related style is wide, or `keypad-button.wide`. This style
    makes the button twice as wide as a normal button. To add this style, use the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final two styles, `keypad-screen` and `keypad-typed`, are for displaying
    the expression and the result. Use the following code to add the remaining two
    styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the keypad looks like a real calculator keypad; refer to *Figure 11**.14*
    for an example. Were you able to keep adding styles and seeing the changes in
    your app without having to restart? Remember to click the **Hot Reload** button
    or set the **Hot Reload on File Save** option under the **Hot Reload** button
    menu; Visual Studio will attempt to apply the changes as soon as you save the
    file. Next, we will add the code to enable the buttons to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – HTML keypad with style](img/B19214_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – HTML keypad with style
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In most web pages, you would use `Keypad.razor` file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `@code` directive block, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This declares a field named `inputDisplay` as a `string` element and initializes
    it to the empty string. It also declares a `bool` element and initializes it to
    `false`. `clearInputBeforeAppend` is a flag to keep `inputDisplay` clean. After
    a result is displayed, when the user taps a button, `inputDisplay` should be cleared
    before the character is added to the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the element with the `keypad-typed` class, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will render the contents of the `inputDisplay` variable into the `div`
    element. Note the use of `@` to reference the C# field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To help with validating the input, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When any of the numbers (0 through 9) or the operator buttons are tapped, `inputDisplay`
    will be updated by appending a character to the display. Add the `AppendInput`
    method using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s review the code. The first check is to see whether `inputDisplay` needs
    to be cleared; if so, it’s cleared. Then, a check for operators is made. The next
    check is more complex as it doesn’t allow multiple operators in a row. This check
    uses the `Range` syntax of `^1` to indicate the last character. String interpolation
    is used to convert the last character back into a string, so `IndexOfAny` can
    be used to find that character in the array of symbols. Multiple leading 0s are
    checked and rejected if found. If all the checks pass, the input is appended to
    `inputDisplay`, and the `clearInputBeforeAppend` flag is reset to `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the user presses the `Undo` method using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses the `Range` syntax again, and the capability of strings being
    able to be indexed as arrays. It uses the array syntax to get the elements from
    index 0 to the next to last index and returns it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the user presses the `ClearInput` method using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the user presses the `ClearAll` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the `EvaluateExpression` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method doesn’t evaluate the expression that’s entered yet; that will happen
    in the *Creating the Compute* *service* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step in the `Keypad.razor` file is to hook the methods that were just
    defined so that they are called when the user taps or clicks on that element.
    Like in standard HTML, events are hooked up via attributes on the element that
    reference code, either inline or methods. The attributes in Razor pages use a
    page directive with the event name. For example, the DOM event for handling taps
    or clicks is `click`, so the Razor event name would be `@onclick`. That attribute
    is then assigned to a delegate, which could be any method. The full attribute
    might look like `@onclick="DoSomething"`, where `DoSomething` is a C# method defined
    in the page’s `@``code` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The `AppendInput` method accepts a single string argument, so the delegate cannot
    be just `AppendInput` – it has to be wrapped in an expression so that the parameter
    can be passed along. Expressions in Razor pages are contained in the `@(…)` directive.
    All calls to `AppendInput` from an event directive would look like `@onclick="@(AppendInput("0"))"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the highlighted lines in the following code to update the HTML in the `Keypad.razor`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: More about Razor event handling
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Razor event handling, visit https://learn.microsoft.com/en-us/aspnet/core/blazor/components/event-handling?view=aspnetcore-7.0.
  prefs: []
  type: TYPE_NORMAL
- en: The keypad is nearly complete. At this point, you should be able to enter a
    full expression to evaluate and then clear the display. In the next section, you
    will create a service to evaluate the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Compute service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Compute` service evaluates the expression and returns the result. To illustrate
    how .NET MAUI and the Blazor application can interact with one another, this service
    will be injected from the .NET MAUI dependency injection container into the Blazor
    page. To implement the `Compute` service, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the root of the project named `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Services` folder, add a new C# class file named `Compute`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `Compute.cs` file so that it matches the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code might be shorter than you expected. Instead of writing a lot of code
    to parse the expression and build an expression tree to evaluate, there is already
    a built-in way of evaluating simple expressions: `DataTable`. The `DataTable.Compute`
    method can evaluate all the expressions that can be built from the calculator.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `MauiProgram.cs` file and add the following highlighted line of code
    to register the class with dependency injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To allow the `Keypad.razor` page to use the `Compute` type, it needs to be
    declared with Razor. Open the `_Imports.razor` file and add the following highlighted
    line of code to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Without this line, you could still use the type, but you would have to fully
    qualify it as `Calculator.Services.Compute`. This is the Razor equivalent of `global`
    `using` directives in C# files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open the `Keypad.razor` file and add the following line of code after
    the `@``page` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@inject` directive will use the .NET MAUI dependency injection container
    to resolve the type provided as the first parameter and assign it to the variable
    defined in the second parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `EvaluateExpression` method, the `compute` variable can be used to evaluate
    the expression contained in `inputDisplay`, as shown in the following highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `Evaluate` method is called with `inputDisplay` as the parameter.
    `inputDisplay` is first modified to replace all the `X` values in the string with
    `*` as that is what the `DataTable` expects for multiplication. The result is
    then assigned to `inputDisplay`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, the calculator app can accept input of a combination of numbers
    and operators and evaluate the result, displaying it to the user. The user can
    also clear out the display. In the next section, we will explore more interoperability
    by giving the calculator memory.
  prefs: []
  type: TYPE_NORMAL
- en: Adding memory functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most calculators can store previous calculations. In this section, you will
    add a list of previous calculations to the calculator app and recall previous
    calculations to the `inputDisplay` parameter of the keypad.
  prefs: []
  type: TYPE_NORMAL
- en: The code will use .NET MAUI controls to render right next to `WebViewControl`.
    A new class, `Calculations`, will be used to manage the listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the memory functions to the calculator app, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `ViewModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class named `Calculations` in the `ViewModels` folder and modify
    the file so that it matches the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds two classes – `Calculations`, which is just shorthand for `Observable
    Collection<Calculation>`, and `Calculation`, which is `Tuple<string, string>`
    and defines two properties to reference `Item1` as `Expression` and `Item2` as
    `Result`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a reference to the `CommunityToolkit.Mvvm` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class named `MainPageViewModel` to the `ViewModels` folder and modify
    the file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `MainViewModel` class uses two features of `CommunityToolkit`: `RelayCommand`
    and `IMessenger`. As in the other chapters, `RelayCommand` is used to bind methods
    to XAML actions. `IMessenger` is an interface for sending messages between parts
    of your application. It is helpful when you don’t want to take a hard dependency
    between two classes, especially if it creates a circular reference. `CommunityToolkit`
    provides a default implementation of `IMessenger` called `WeakReferenceMessenger`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `MauiProgram.cs` and add the following `using` declarations to the top
    of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `CreateMauiApp` method make the following highlighted changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds `MainPage`, `MainPageViewModel`, and the default instance of `WeakReferenceMessenger`
    to the dependency injection container. The next few steps will enable `MainPage`
    to be initialized via dependency injection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `MainView.xaml.cs` and make the following highlighted changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As in other chapters, the constructor for the view is updated to accept the
    view model as a parameter, and it is assigned as `BindingContext`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `App.xaml.cs`, modify the constructor, and add the `OnHandlerChanging`
    event handler, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since a .NET MAUI Blazor app does not use `Shell` by default, the views cannot
    be initialized via dependency injection the same way as is done with `Shell`.
    Instead, the instance of `MainPage` is obtained after `Handler` has been set.
    The `OnHandlerChanging` event is used to get the reference to the new `Handler`,
    which then provides `MauiContext` to the dependency injection container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `_Imports.razor` and add the following lines to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `Keypad.razor` and add the following highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will inject the `Calculations` instance as `calculations` and `WeakReference`
    **Messenger** as `messenger` from the .NET MAUI dependency injection container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `ClearAll` and `EvaluateExpression` methods and add an `OnAfter`
    **RenderAsync** method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Shared/MainLayout.razor.css` file and add the following line to the
    `page` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is simply for aesthetics and makes the areas surrounding the calculator
    black.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `MainPage.xaml` file and modify it so that it matches the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `Grid` element with two rows defined is used to contain the new display for
    previous calculations and the original `BlazorWebView` control. The calculations
    are rendered using `ScrollView`, which contains `CollectionView`. The `CollectionView.ItemTemplate`
    property contains `DataTemplate` for each `Calculation`. The `SwipeView` control
    allows the user to swipe in either the up, down, left, or right direction to expose
    additional commands. Each direction has an element to define those actions. For
    `Calculation` items, when the user swipes right, it exposes a `Recall` item, which
    is bound to the `Recall` command of `MainPageViewModel`. The display for `Calculation`
    uses a combination of horizontal and vertical `StackLayout` controls to stack
    `Expression` on top of `Result` with `=`, all aligned to the left.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That completes the main functionality of our calculator app. The next section
    deals with some aesthetics of the main window when running on a desktop such as
    Windows or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing the main window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The calculator app is defined to be a fixed size. Most of the projects in this
    book have allowed the controls to grow or shrink with changes to the window size.
    For our calculator app, the main window should be fixed so that it appears in
    the best way possible. To fix the window size when the app launches, open the
    `App.xaml.cs` file and add the following method to the `App` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateWindow` method is overridden so that the `Window.Created` event can
    have a custom handler attached to it if the app is running on Windows or macOS.
    The work of resizing the window is done in the `Window_Created` method. It uses
    the `defaultHeight` and `defaultWidth` constants to set the new windows’ height,
    width, and location on the screen. The method then waits for all threads to have
    finished before altering the `X` and `Y` properties of the window again, but this
    time accounting for the screen pixel density. Finally, it detaches the event handler
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.1\uFEFF5 – The completed calculator project](img/B19214_11_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – The completed calculator project
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excellent work! In this chapter, you completed a project that used the .NET
    MAUI Blazor template. You created a UI using HTML, updated it with C# code, and
    then implemented a service that was managed by .NET MAUI and injected it into
    a Razor page. Then, you used `CollectionView` to display a list of the previous
    calculations. Within `CollectionView` `ItemTemplate`, the `SwipeView` control
    was used to recall a previous calculation to the keypad for additional editing
    and reevaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extend this project even further, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an additional swipe action to delete a calculation from the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an additional keypad layout for scientific calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next – and final – chapter, you will discover the world of AI as you
    build an object recognition app.
  prefs: []
  type: TYPE_NORMAL
