- en: Chapter 6. Accelerate – Creating Generative Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we are going to learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of procedural animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating multiple objects at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make use of randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to benefit from built-in animation easing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a relatively simple drawing by using basic shapes and then animate
    these shapes in a parametric way. We will also learn how to make use of built-in
    easing functions of Cinder that can make polishing our animations a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, open TinderBox and create a new project with the name `BasicAnimation`.
    Open `xcode/BasicAnimation.xcodeproj` (`vc10\BasicAnimation.sln` on Windows).
    Open `BasicAnimationApp.cpp` in the editor so that we can start making changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to change the window size this time as 640 x 480 px might be too
    small for most of the compositions we will want to create later. To do that, we
    need to override another Cinder `AppBasic` method—`prepareSettings()`. Add a new
    declaration just after the `draw()` method declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the implementation of the method that we just declared just before
    the implementation of the `setup()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the window size. To do that, add the following line of code inside
    the `prepareSettings` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also change the frame rate to something more appropriate for Cinder—60
    frames per second is a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this altogether looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now compile and run your application to test if it works.
  prefs: []
  type: TYPE_NORMAL
- en: Next we are going to draw a solid circle. As you might remember from the previous
    chapters, we have to use the `drawSolidCircle()` function in order to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `draw()` member function implementation in the `BasicAnimationApp.cpp`
    file and add the following line of code just after the `gl::clear()` function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This draws a white circle with a radius of 30 pixels in the center of the window.
    As this chapter is about animation, let's think of some ways to move this circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the stage](img/9564_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, in each frame before we draw something, we use black color
    to clear everything that is left there from the previous frame. We use `gl::clear()`
    to do that. To create the effect of moving something, we need to change the object's
    position in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we will need to replace the values of the `drawSolidCircle` position
    parameters to variables. Let''s declare a new variable that will hold the position
    of the circle on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This variable will hold the `x` and `y` position of the circle that we are drawing
    inside the `draw()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will set the initial value of the variable in the `setup()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a part of the preceding code snippet is the same as we used
    in the `drawSolidCircle()` function call. We just made it changeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to replace the values in the `drawSolidCircle()` function
    to the newly created variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run our application. Nothing much has changed. Don''t worry about
    that and add the following line of code before the `drawSolidCircle()` function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the application again and there it is, a moving circle. Cool!
    We have our first animation! Now let''s do something with the radius of the circle.
    To apply animation to it, we have to declare a new variable again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set its starting value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And add an animation rule and replace the constant value of the circle radius
    parameter of the `drawSolidCircle()` function call in the `draw()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run our application. You should see a big white point disappearing
    in front of your eyes. It might seem that you did something wrong, but don't worry,
    everything is correct. The trick is that we decreased the circle radius by one
    pixel for each frame. It is happening at a rate of 60 times per second and that
    means that the radius of the circle will reach `0` in approximately 1.5 seconds.
    Therefore, if the radius is `0`, the circle becomes invisible as there can be
    no circle without a radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good. Let''s try to move our circle to some fixed location over time.
    Let''s say we want to move it from the top-left corner of the screen to the bottom
    right. To do that we need to set the initial position of the circle to `0`. and
    let''s change the initial `circleRadius` to something smaller as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare another `Vec2f` variable that will hold the target position
    of the circle in the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to set the initial target position somewhere, so we have to add a new
    line in the `setup()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to write some code that creates a smooth transition between
    `currentPosition` and `targetPosition`. Let's do it in the `update()` method implementation
    as it is meant for such calculations. Remember, try to use the `draw()` method
    just for drawing and place all your calculations inside `update()`. It does not
    matter much for a small application such as this one, but as your code grows bigger,
    it is possible that the application won't perform so well or will even crash if
    you don't stick to this simple rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These three lines of code calculate the difference between the current circle
    position and the target circle position. Then, we make the difference between
    these positions smaller by multiplying it with a floating point number that is
    smaller than `0`. Finally, we calculate the new current position by subtracting
    the new difference from the target position of the circle.
  prefs: []
  type: TYPE_NORMAL
- en: This would require a longer code if we didn't make use of the integrated vector
    algebra features of Cinder. As a `Vec2f` object contains two values (the x and
    the y coordinate), when we multiply it with a single value, both values inside
    the `Vec2f` object are multiplied by this value. Furthermore, if we multiply a
    `Vec2f` object with another `Vec2f` object, the first element of the first vector
    is multiplied with the first element of the second one, and the second element
    of the first one is multiplied with the second element of the second one, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now compile and run our application. You should see a circle moving from the
    top-left corner to the bottom-right corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding animation](img/9564_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a bit of unpredictability to this by using the almighty random functions.
    To use them in Cinder, you have to include a header file that contains the necessary
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this in the beginning of the `BasicAnimationApp.cpp` file. Next, we need
    to calculate random target position in the `setup()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now each time you run the application, a different end position will be calculated
    and the circle will fly to a different place on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the current position of the circle to something random as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the application to see the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might seem a bit boring to see just one random animation after you have
    opened an application. People usually expect something more. So how about we calculate
    a new random end position as the circle reaches its current end position? Ok,
    let''s do that! Add the following piece of code in the `update()` method implementation
    just after `currentPosition = targetPosition - difference;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Comment out or delete the following highlighted lines from the `draw()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run our application. This is a bit more interesting, but still it
    needs something more to be complete.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding randomness](img/9564_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How about we try to handle more than one circle on the screen? It would be worth
    explaining how to create a particle system as a separate class, but this won't
    fit in the scope of this book, so we will continue to make some changes in the
    same file.
  prefs: []
  type: TYPE_NORMAL
- en: More circles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define the count of the circles that we want the application to handle.
    Add the following line of code just after the `#include` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go to the class declaration part and change the declarations of
    our variables to arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used the previously defined constant as the size of our arrays.
    By doing that we can change the circle count easily later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to change some code in the `setup()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we wrapped the same code we had before into a `for` loop that iterates
    over all our parameter arrays and sets initial values for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t compile yet as we still have to make changes to the `update()` and `draw()`
    methods in a similar way. Change our `update()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, change our `draw()` method implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run our application now. This looks a bit more interesting!
  prefs: []
  type: TYPE_NORMAL
- en: '![More circles](img/9564_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It seems that 100 circles are not enough, so how about we set the `CIRCLE_COUNT`
    constant to `1000`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: No problem!
  prefs: []
  type: TYPE_NORMAL
- en: But what if we don't want to focus on quantity, but on the quality of movement?
    This is where animation easing joins the game.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in eases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, say we want to make use of the easing algorithms that we saw in the `EaseGallery`
    sample. To do that, we have to change the code by following certain steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the easing functions, we have to include the `Easing.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First we are going to add two more variables, `startPostition` and `circleTimeBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `setup()` method implementation, we have to change the `currentPosition`
    parts to `startPosition` and add an initial value to the `circleTimeBase` array
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to change the `update()` method so that it can be used along
    with the easing functions. They are based on time and they return a floating point
    value between `0` and `1` that defines the `playhead` position on an abstract
    `0` to `1` timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted parts in the preceding code snippet are those that have been
    changed. The most important part of it is the `currentPosition[i]` calculation
    part. We take the distance between the start and end points of the timeline and
    multiply it with the position floating point number that is being returned by
    our easing function, which in this case is `easeOutExpo()`. Again, it returns
    a floating point variable between `0` and `1` that represents the position on
    an abstract `0` to `1` timeline. If we multiply any number with, say, `0.33f`,
    we get one-third of that number, `0.5f`, we get one-half of that number, and so
    on. So, we add this distance to the circle's starting position and we get it's
    current position!
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run our application now. You should see something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using built-in eases](img/9564_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Almost like a snow storm! We will add a small modification to the code though.
    I will add a `TWEEN_SPEED` definition at the top of the code and multiply the
    `time` parameter passed to the ease function with it, so we can control the speed
    of the circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the following line in the `update()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I did this because the default time base for each tween is 1 second. That means
    that each transition is happening exactly for 1 second and that's a bit too fast
    for our current situation. We want it to be slower, so we multiply the time we
    pass to the easing function with a floating point number that is less than `1.0f`
    and greater than `0.0f`. By doing that we ensure that the time is scaled down
    and instead of 1 second we get 5 seconds for our transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'So try to compile and run this, and see for yourself! Here is the full source
    code of our circle-creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Experiment with the properties and try to change the eases. Not all of them
    will work with this example, but at least you will understand how to use them
    to create smooth animations with Cinder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our first generative animation application. We learned
    how to use instance variables for creating smooth movements and random functions
    to generate unpredictable results in predictable scale. We also used static arrays
    to change the count of the circles in the simulation and made use of Cinder easing
    functions that can prove themselves very handy when creating Flash-like applications
    (you might know the TweenLite tweening library, if you have some Flash coding
    background).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tested the application with a relatively high amount of objects.
    This part should prove to you the real power of Cinder as you might know that
    creating a similar application with other frameworks based on non-C++ platforms
    does not run as smooth as this one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about real-time post-processing and basic
    methods for applying image, as well as video effects with Cinder.
  prefs: []
  type: TYPE_NORMAL
