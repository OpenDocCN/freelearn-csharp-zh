- en: The Data-Oriented Technology Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In recent years, we have seen a big push toward multithreading programming.
    The reason is obvious: while we have reached a technological limit on how fast
    a single core can go, we have discovered how to efficiently put thousands of cores
    into our hardware and run each piece of code in parallel to obtain a massive performance
    boost.'
  prefs: []
  type: TYPE_NORMAL
- en: However, moving from single-thread programming to multithreading programming
    is not straightforward. Not every algorithm can easily be split into pieces and,
    even if it can, there are several details you need to take into account so as
    to avoid strange and unpredictable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: When the first version of Unity was released, back in 2005, massive multithreading
    was almost a futuristic scenario. However, fourteen years are the equivalent of
    a geological era in game development, and a game engine needs to adapt itself
    to stay on track with cutting-edge technology.
  prefs: []
  type: TYPE_NORMAL
- en: Unity is currently going through a massive effort to adapt its core design into
    a world dominated by massive multithreading. This effort takes the name of the **Data-Oriented
    Technology Stack** (**DOTS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the components of DOTS:'
  prefs: []
  type: TYPE_NORMAL
- en: The Job System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Entity Component System** (**ECS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Burst Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOTS stack in Unity is exceptionally experimental and, while public, all
    its components are still in an early preview state, meaning that their use should
    be avoided for serious projects. They also change very fast. The official tutorial
    on ECS on [https://learn.unity.com](https://learn.unity.com) is now unusable because
    it is out of date. I will not be surprised if even this chapter, some months from
    now, were to contain many deprecated functions and procedures. Do not worry; I
    will provide a link at the end for where to obtain fresh news on DOTS.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Video games have great multithreading potential. In theory, every `GameObject`
    can be seen as a separate entity with its own life cycle and its own computation
    path. This would instantaneously increase your game performance with a lot of
    `GameObject` instances. Suppose that processing all the updates in the `GameObject` takes
    1 ms. If you could have one thousand similar `GameObject` instances, that would
    take a full second but, if you can assign each update to a separate core, all
    the updates could run in parallel, and your total computation time would be exactly
    1 ms. That represents a 100,000% speed boost!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not so easy. As we said before, you cannot just assign
    a piece of code to a core and expect that everything keeps working. A big problem
    with writing multithreaded code is the risk of race conditions, deadlock, and
    bugs that are notoriously difficult to reproduce and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions are where two or more calculations are racing toward completion,
    but the actual outcome depends on the order in which they finish. Imagine one
    thread trying to add three to a number, whereas another thread multiplies it by
    four. The result will be different, depending on which operation happens first. Deadlock is
    a problem where two or more threads are competing for shared resources, where
    each requires the full resource collection to complete its task, but each has
    reserved a separate small portion of resources and refuses to relinquish control
    of them to another thread, in which case, none of the threads can get any work
    done because neither has the complete set it needs.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, traditionally, Unity APIs are not thread-safe, meaning that
    they cannot be invoked by different threads running in parallel. As a consequence,
    almost all Unity code runs in the main thread, and that includes every `GameObject`
    and `MonoBehaviour` (and that's why if you block a single update, you may end
    up freezing the entire Unity Editor).
  prefs: []
  type: TYPE_NORMAL
- en: Because multithreading is a complex topic, we will go over an example step by
    step.
  prefs: []
  type: TYPE_NORMAL
- en: A small example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you want to have thousands of similar items in your scene. This is
    not a strange request; there may be many valid reasons for that: you may wish
    to render thousands of ships in a gigantic galactic battle, or you may want to
    animate thousands of units for a **Real-Time Strategy** (**RTS**) game, or you
    may want to handle a massive number of particles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, in our demo, we want a scene with 10,000 spinning cubes. So
    let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each cube will have a single `MonoBehaviour` instance that executes a very
    simple rotation cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is self-explanatory: we have a public variable, `rotationSpeed`,
    storing the rotation speed of the cube. Then, in `Update`, we simply rotate the
    cube.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we do not want to insert 10,000 cubes into the scene manually. So, we
    will create a **game manager** that will do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn 10,000 cubes in the scene
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a random rotation speed for each one of them
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we create an empty `GameObject`, and we attach to it a game manager script,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The script simply takes a `cubePrefab` and spawns a certain number of them into
    a *width x height* rectangle of space. The exciting part is the `SpawnCubes` function.
    The function starts with `position` in the origin and starts spawning cubes until
    we reach the opposite corner. This is a pretty standard script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run it, and we should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70a260fc-2726-40fb-a7b6-88cda2e42076.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the frame rate is not optimal. Looking at the stats in the top-right
    corner, you can see that the game is running at ~22 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these values are taken from my non-optimal machine. You may find different
    values. If your computer is so fast that the demo is running perfectly, try to
    increase the number of cubes to 20,000 or more.
  prefs: []
  type: TYPE_NORMAL
- en: 'This FPS value is not optimal. However, we can open the Profiler window (Window
    | Analysis | Profiler) and try to understand how the application behaves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b96698e0-3ea7-40dc-8506-e629cae0ed29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The image is clear: we are allocating almost 1 GB of RAM and spending 45 ms
    per frame, 10 ms of which are used just for the scripts. That''s wrong. The update
    script is straightforward: we are just rotating a cube by a few degrees each frame.'
  prefs: []
  type: TYPE_NORMAL
- en: We should do better. And we will.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Job System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The big block in the DOTS that can provide us with a huge performance-enhancing
    feature is the **C# Job System**. Like all the other DOTS components, the feature
    is still in active development, but has been made public since Unity 2019.1, so
    it would be wise to start becoming familiar with it sooner rather than later,
    as it will introduce considerable changes to how Unity developers will be writing
    high-performance code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b1ed060-e78b-4f34-9e21-7905b738bc6c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we will see, the difference in the quality of a game that uses this system
    versus one that doesn't might become very noticeable, which may cause some fragmentation
    within the Unity development community. It is in our best interests to understand
    and exploit the benefits of the new Job System so that our application will have
    the greatest potential for success.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the C# Job System is to be able to create simple tasks that run
    in background threads to offload work from the main thread. The C# Job System
    will be ideal for tasks that are embarrassingly parallel, such as having hundreds
    of thousands of simple AI agents operating in a scene simultaneously and any problem
    that can be boiled down to thousands of small, independent operations. Of course,
    it can also be used for typical multithreading behavior as well, where we perform
    a number of calculations in the background that are not needed immediately. The
    Job System also introduces some compiler technology improvements to get an even
    greater performance boost than just moving the tasks to separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: A basic job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In essence, a job is just a function running on a separate thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Every job is a struct extending the `IJobinterface` interface. The struct contains
    any data we want for the job to use and a function named `Execute` for the operation
    we want to execute in the job. The previous example, for instance, just adds a
    certain number to the first element of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Because, as we said before, multithreading is a very tricky business, Unity
    offers some limitations in terms of the way in which you can pass and receive
    data to a job (or a set of jobs). The primary constraint is that the `Execute`
    function does not accept any argument and cannot return any value. All the data
    that the job needs must be copied in the struct, and the result must be written
    in the struct as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that we need to copy stuff into the struct seems a significant limitation:
    you cannot pass a reference to a `MonoBehaviour` instance or a reference to `List`.
    Luckily, Unity offers a way to access shared memory in a job using a set of thread-safe
    wrappers using native containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The native containers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NativeArray`: A simple collection of data (the thread-safe equivalent of base
    C# arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeList`: Similar to `NativeArray`, but resizable (the thread-safe equivalent
    of `List`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeHashMap`: The thread-safe version of `HashMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeMultiHashMap`: Similar to `NativeHashMap`, but with multiple values
    per key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeQueue`: A thread-safe version of a **First In, First Out** (**FIFO**)
    queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in our job, we use a one-sized `NativeArray` variable to store input and
    output data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to run the job. To do that, we need to use `MonoBehaviour` to
    initialize and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Start`, we first create an empty `NativeArray`. The first argument of `NativeArrayconstructor`
    is the size; the second argument is `Allocator`. There are actually three allocators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Allocator.Temp`: This is the fastest one, but its life span must be under
    a frame. In fact, Unity forces you to call `Dispose` on such an array before the
    function returns. For this reason, we cannot use `Allocator.Temp` for native containers
    passed as an argument to jobs. Jobs are not guaranteed to complete in the same
    frame in which they start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Allocator.TempJob`: This is slower than `Allocator.Temp` and its lifetime
    is restricted to under four frames. This is the perfect type of `Allocator` for
    passing data to simple jobs that run and return quickly, such as the one in our
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Allocator.Persistent`: This is the slower of the three, but its lifetime is
    unbounded. This is the type of `Allocator` where you want to store persistent
    data or data that jobs need to access for an extended period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we create a new `SimpleJob` instance, passing `number` and `data`
    to it. Then, we schedule and run the job with the `Schedule` function. This will
    return a `jobHandle` instance, which we can use to control the job execution.
    Finally, we wait for the job to be completed and then print the result. Everything
    looks like standard C# code, but the job runs in a separate thread!
  prefs: []
  type: TYPE_NORMAL
- en: Remember to be nice C# citizens and always dispose of native containers manually!
    You do not want to pollute your memory in the same way that you do not want to
    pollute our world.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you attach `SimpleJobRunner` to an empty object, you should
    see the result printed in the debug console. Everything is effected in a multithreading
    style.
  prefs: []
  type: TYPE_NORMAL
- en: A more complex example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spawning a job just to sum two numbers is definitely not an example of optimal
    programming. Unity created jobs to run thousands of them to lift hard work into
    the multithreading domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will now modify our previous spinning cubes example so that the
    actual spinning is performed by jobs. The first thing we want to do is to create
    our job, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This job is a bit more complicated, but do not worry. First, it extends `IJobParallelForTransform`;
    this is a specialized job interface for running parallel transformations of `GameObject`
    instances. You can do the same by extending `IJob`, but, because this is a very
    common use case, Unity wrote most of the code for us. As you can see, the main
    difference is the fact that `Execute` now has two parameters. In our demo, we
    want to run the same job on every one of our 10,000 cubes. In this case, the parameters
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index` represents the `index`^(th) cube in our scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transform` is a reference to the `Transform` of the `index`^(th) cube'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our job takes two inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`speeds`: It is an array containing all the random speeds for every cube. Remember,
    we cannot get a reference to some data of a specific `GameObject`, so we need
    to write all the speeds into shared memory. Note that the field is `[ReadOnly]`; we
    do not want the *i*^(*th*) cube to be able to change the speed of another cube.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deltaTime`: Because a job is completely disconnected from the Unity engine,
    it cannot access `Time` and other thread-unsafe parts of Unity. Therefore, we
    need to pass `deltaTime` ourselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Execute` function is straightforward; we just rotate the cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to call these jobs on every cube, and we need to use a game manager
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining the underlying data as in the classic example. The first
    attributes are the same; the interesting ones are the final three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transformAccessArray` is the array in which we will store `transform` instance
    references of all of our cubes. That''s how our job can access them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jobHandle` is the handle we will use to query the Job System for the state
    of the job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speeds` is the list of random speeds as described before:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Start`, we just initialize all the native containers, and then we spawn
    the cubes. Note that we use the `Allocator.Persistent` allocator because we want
    to initialize the speed on `Start` and then use the same list for the application''s
    entire lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SpawnCubes` function is very similar to the previous one. However, there
    are two crucial lines that differ:'
  prefs: []
  type: TYPE_NORMAL
- en: After we instantiate a cube, we add its `transform` to `transformAccessArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of setting the random speed in the `Rotator` `MonoBehaviour` of the
    cube, we set it in the speeds array. In fact, we should not have the `Rotator`
    component in the Prefab!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, every frame, we need to run the job in parallel on every cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the same pattern as before. We check whether the previous jobs are now
    complete, we instantiate a new job, we set the data, and then we schedule the
    job over the entire **`transformAccessArray`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is correct, we can run the game and see the same scene as before.
    Now, however, we can enjoy ~35 FPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21eab8f0-53da-45f9-bee2-62e2c9deb98d.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at Profiler, we can see that, now, the time used by scripts (the lower
    blue one) is almost invisible. It dropped from 10 ms to 1 ms. That's a 90% improvement!
  prefs: []
  type: TYPE_NORMAL
- en: However, we still have a problem. Our scene is filled by 10,000 `GameObject` instances,
    10,000 `Transforms`, 10,000 `MeshRenderers`, and another 10,000 copies of different
    components. `MonoBehaviour` and `GameObject` are heavy data structures, and they
    are consuming a sensible amount of memory and CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Can we do better? Yes, we can.
  prefs: []
  type: TYPE_NORMAL
- en: The new ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ECS is a brave and ambitious attempt to redesign the core foundation of
    Unity''s design: the `GameObject`-`MonoBehaviour` paradigm. As you can imagine,
    changing the base design pattern of every object in the game is not an easy task.
    So you may ask: Why?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons for that. Let''s look at some of them objectively:'
  prefs: []
  type: TYPE_NORMAL
- en: First, as we said before, `GameObject` and `MonoBehaviour` are heavy objects;
    they carry a lot of internal code and data structures. The overhead introduced
    by `GameObject` instances and `MonoBehaviour` is large enough to limit the number
    of objects  you can have on the screen more than the resources needed to render
    them. That's not a good thing for an abstraction model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, `MonoBehaviour` instances are scattered in memory. This means that
    `GameObject` needs to look around in memory to retrieve all the `MonoBehaviour`
    instances it is connected to, and that the system relies on references. This has
    two problems: it makes caches very inefficient and, more important, it is a problem
    when we want to use `GameObject` instances in a massive multithreading application,
    for instance, by using jobs (we have seen that jobs cannot use references safely).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last, but not least, `MonoBehaviour` instances have a problem from a code design
    point of view: they store both data and behavior. This is not a huge problem.
    After all, a lot of amazing games have been shipped using this paradigm. However,
    it is common in software architecture to separate the data (often called the **model**)
    and the algorithm that uses the data (often called the** controller***). *'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ECS, on the other hand, goes in the direction of separating the data from
    the behavior. It is based on three different components:'
  prefs: []
  type: TYPE_NORMAL
- en: An **entity** is just defined by its set of components. There is literally zero
    abstraction here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **component** is purely data. A `Health` component contains only the life
    points; a `Shield` component contains only the number of shields; a `Rotation`
    component contains only the object orientation, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **system** defines the behavior of entities. A system applies a specific behavior
    to every entity containing a particular set of components. For instance, `MoveAndRotateEnemy`
    may apply translation and rotation to every entity with the `Rotation`, `Translation`,
    and `Enemy` components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is now in its own place.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing ECS and jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is time to apply ECS to our 10,000 spinning cubes. Before we start, we need
    to install the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Window | Package Manager. Click on Advanced and make sure that Show preview
    packages is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, from the list, install the Entities package and the Hybrid Renderer package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa81e2ff-4471-4b32-8ea7-ab842a4d82a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned previously, ECS is changing rapidly. We tested the code in this
    book with version 0.1.1-preview. If you, as a future reader, have a more recent
    version, there is a big chance that there will be some incompatibility. In that
    case, I encourage you to compare the code with the latest examples of ECS contained
    in this official repository: [https://github.com/Unity-Technologies/EntityComponentSystemSamples](https://github.com/Unity-Technologies/EntityComponentSystemSamples).
    I apologize for my lack of forecasting ability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to write the first component. Our cube needs to spin, so we
    need to have a certain `RotationSpeed`. That will be the name of our component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See how simple that is. As we have said before, a component is just data. The
    rotation speed is represented by a single float; therefore, we just need to store
    a simple float.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may ask: how do I attach this component to an entity? Can I still use the
    inspector to set the values? How about all the goodies I love in Unity? Sadly,
    components cannot be attached to `GameObject` (after all, `GameObject` is not
    part of the ECS). Entities do not show up in the scene editor and components do
    not appear in the inspector.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a solution if we want to keep some functionality of the
    Editor, such as, for instance, defining a Prefab that we can spawn 10,000 times.
    Mixing the `GameObject`-`MonoBehaviour` paradigm with ECS is called **hybrid ECS**
    and is the perfect way to keep the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable it for our component, we need to write an `IConvertGameObjectToEntity` implementation. `IConvertGameObjectToEntity`
    is a piece of code that automatically converts a standard `MonoBehaviour` to the
    correspondent component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `RotationSpeedAuthoring` is an `IConvertGameObjectToEntity` implementation
    and a `MonoBehaviour` (so that we can attach it to a `GameObject`). The core of
    the conversion lies in the `Convert` function. The signature is confusing; it
    changed a lot in the past, and it will probably change again in the future. What
    is important is the content: the function takes the data of the `MonoBehaviour`,
    adds it to a new component (in our case, `RotationSpeed`), applies some processing
    (in our case, we convert degrees per second into radians per second), and finally
    attaches the component to the entity.'
  prefs: []
  type: TYPE_NORMAL
- en: We now create `cubePrefab` as before and add the `RotationSpeedAuthoring` `MonoBehaviour`
    to it and, at runtime, `GameObject` will be converted to an entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have everything we need, we just need to write our game controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty standard game manager, but let''s go over the exciting parts.
    First, we have a new attribute: `entityManager`. This is just a reference to the
    primary entity manager. An entity manager, as the name suggests, is a data structure
    where you can perform basic operations on entities, such as checking whether an
    entity is still alive, or creating and editing entities.'
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to create an entity manager. Unity will provide one for you.
    As you can see in `Start`, you just need to reference the main global one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to spawn the cubes. The first interesting line is this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this one, we take the Prefab we built, and we convert it to an entity.
    Every `MonoBehaviour` in the Prefab gets converted into a component and, sometimes,
    more than one. We already know that `RotationSpeedAuthoring` gets converted into
    `RotationSpeed`, but Unity provides conversions for many standard `MonoBehaviour`
    subclasses, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each `Transform` is converted into `Translation`, `Rotation`, and `Scale` components
    (and some less common ones, such as `NonLocalScale`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `MeshRenderer` is converted into the `RenderMesh` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, for each cube position, we need to instantiate a new entity. This is similar
    to how we instantiate a `GameObject`, but we invoke `Instantiate` on `entityManager`,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, we set the `Translation` and `RotationSpeed` components on the entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first is to set the cube position to the computed position, and the latter
    to set the random rotation speed. Note that the component uses radian per second,
    so we need to convert the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have the components, and we have a way to instantiate the
    entities. We are still missing a system to actually move the cubes. We want to
    build a system that takes every entity with `RotationSpeed` and a `Rotation` component
    and make them spin. Not only this, but we also want to use C# jobs so that all
    10,000 cubes spin in parallel. This is a typical pattern and, therefore, Unity
    has a class for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we first need to write our job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the previous job, but with a number of differences. First,
    we extend `IJobForEachinstead` of `IJobParallelForTransform` because entities
    have no `Transforms`. You may note that we pass two type parameters to the `IJobForEach`
    interface. These are the types of components we want to use in our job, namely, `Rotation`
    and `RotationSpeed`. We may put any number of components in there; the important
    thing is that we add the same component, in the same order, as the parameters
    of `Execute`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we extend `IJobForEach<Rotation, RotationSpeed>`, then `Execute`
    will take as parameters a reference to a `Rotation` and a `RotationSpeed` component.
    However, if we extend `IJobForEach<Scale>`, then `Execute` will only take as a
    parameter a reference to a `Scale` component; and so on. This acts as a filter
    over all the entities and makes sure that this job is applied only on entities
    containing `Rotation` and `RotationSpeed` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you may note that we are using some strange types for rotation: `quaterion`,
    with a lower case *q*. This is because Unity developed some new types for vectors
    and quatrains in the ECS that have the advantage of being more optimized for jobs
    and components.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of them but, as usual, they are a work in progress. To find
    up-to-date info on them, check the documentation of the `Unity.Mathematics` module
    here: [https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a job, we need to create a component system that takes advantage
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`JobComponentSystem` is a class designed to build a system that can run using
    C# jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a new class called `RotationSystem`, which extends the
    `JobComponentSystem` class. Inside this class, we override the `OnUpdate` (note:
    `OnUpdate`, not `Update`) method, inside which we just create a new `RotatorJob`
    job and schedule it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to attach the `ECSJobManager` to an empty `GameObject` and
    run the application and see all the cubes spinning as normal. With these changes,
    we finally reach more than 100 FPS! Let''s look at Profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e92b1f4-8470-461a-90a9-4d2c5d97188c.png)'
  prefs: []
  type: TYPE_IMG
- en: The time is so fast that we can see the small spikes of v-sync. Every frame
    takes less than 10 ms; this is less than the time we spend only on scripts using
    the classical non-DOTS approach! That's an incredible speeding up, and the application
    contains less than half the memory.
  prefs: []
  type: TYPE_NORMAL
- en: But guess what. We can still do better.
  prefs: []
  type: TYPE_NORMAL
- en: The burst compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last component of the DOTS is the burst compiler. The burst compiler is
    a compiler that can compile a subset of C# into optimized native code. The main
    goal of Burst is to compile jobs so that they can be as fast and lightweight as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cool thing is that using the burst compiler is extremely easy. First, you
    need to install the Burst package from Window | Package Manager. Then, the only
    thing you need to change is to add the `[BurstCompile]` decorator on top of the
    job definitions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now the job is compiled with Burst, and this will squeeze a bit more
    performance from our application. Our demo is straightforward, and the Burst compilation
    effect is limited—on my machine, I can reach 110 FPS, but for more complex jobs,
    the impact is more significant.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DOTS is the peak of Unity's effort to push Unity into the future of gaming.
    I firmly believe that in the future, DOTS will be a core component of any optimization
    effort, and this chapter will definitely grow into several ones while DOTS becomes
    more stable and is supported by the community.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at this stage, C# jobs and ECS are still very unstable, their
    APIs are changing rapidly and, therefore, I do not advise using them in big, important,
    commercial games. However, I believe it is important to start experimenting with
    them so as to be ready for when their time comes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter merely scratches the surface of the DOTS. There are many more details,
    configurations, and optimizations that can be implemented both in jobs and ECS.
    For more information, the main Unity Hub for DOTS ([https://unity.com/dots](https://unity.com/dots))
    is your best friend.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter effectively concludes all of the techniques we can bestow that
    explicitly aim to improve application performance. However, optimizing your workflow
    is also enormously beneficial. As mentioned previously, the one constant cost
    of performance optimization work is development time. However, if you can speed
    up our development working, saving some time during the more tedious parts of
    the job, then hopefully, you can save yourself enough time to actually implement
    as many optimization techniques we've talked about through this entire book as
    you can. There are a lot of neat little nuances to the Unity Engine that aren't
    well known or clearly documented, and that only become apparent through experience
    with the engine or by involving ourselves in its community. As such, the next
    chapter will be full of hints and tips for improving how to manage your project
    and scenes more effectively and how to make the most of the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
