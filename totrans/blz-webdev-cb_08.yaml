- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the Application Secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focus on essential security practices for Blazor applications,
    as protecting user data and maintaining trust is crucial for any commercial success.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by scaffolding identity – setting up the necessary infrastructure
    for user authentication and management by leveraging the template provided by
    the .NET team. We will look at strategies to prevent unauthorized access and protect
    your component from unwanted actors. Additionally, we will cover a more granular
    approach and secure markup areas to customize the component behavior and ensure
    that sensitive information is only accessible to authorized users. We will explore
    how to define and enforce **roles** and **policies** to centralize and encapsulate
    access levels that align with your security requirements. Next, we will learn
    how to determine users’ **authentication state** and their current access context,
    allowing us to secure and enhance backend logic. We will also discuss how to update
    user identity safely and securely.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand various security mechanisms
    in Blazor and have the best security practices in your skillset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a list of the recipes we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing markup areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying a user’s identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting roles’ and policies’ authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving authentication state in procedural logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, recipes build on one another, resulting in a guide through
    the most often required identity features. For clarity, at the beginning of each
    recipe, you will find instructions on how to set up a working directory and where
    to get the sample objects from. On top of that, this chapter requires that you
    have a working **Structured Query Language** ( **SQL** ) database, a connection
    string to the database instance, and a SQL IDE as you will need to run a few custom
    migrations. Most of the tables will be scaffolded for you, so don’t stress if
    you don’t have much experience with SQL itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code samples are available on GitHub at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth)'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET team provides a template that enables adding authentication to your
    Blazor application rapidly. This template is not only quick to set up but also
    highly customizable. You can streamline the implementation of user authentication,
    registration, and profile management, ensuring that your application is secure
    from the get-go. You get essential features such as login and logout functionality,
    password recovery, and user data management – all crucial for any authentication
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s scaffold a new Blazor project with authentication enabled and explore
    the features it offers out of the box. By the end of this recipe, you will have
    a solid foundation and understanding of the identity system. Whether you’re building
    a simple app or a complex enterprise solution, this approach will save you time
    and effort while ensuring your application meets modern security standards.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will showcase initializing the project with identity, leveraging the GUI
    provided as part of Visual Studio, so the only pre-requirement in this recipe
    is that you start your IDE. Let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the .NET CLI in your environment, you can refer to the *There’s
    more…* section at the end of the recipe, where I’ll provide equivalent commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to scaffold a new Blazor project with identity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Create a new project** from the welcome window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1: Starting the creation of a new project from the welcome window](img/Figure_8.1_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Starting the creation of a new project from the welcome window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the search bar at the top of the panel to find the **Blazor Web App** position
    and confirm by clicking the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2: Selecting Blazor Web App from available project templates](img/Figure_8.2_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Selecting Blazor Web App from available project templates'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a project location and name and confirm by clicking the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3: Setting a project location and name](img/Figure_8.3_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Setting a project location and name'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose **.NET 9.0 (Standard Term Support)** as the target framework, and in
    the **Authentication type** section, select **Individual Accounts** . Make sure
    to check the **Configure for HTTPS** and **Include sample pages** checkboxes,
    and select **Auto (Server and WebAssembly)** and **Per page/component** from the
    interactivity configuration dropdowns. Confirm by clicking the **Create** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4: Configuring the project’s framework, interactivity, and authentication](img/Figure_8.4_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Configuring the project’s framework, interactivity, and authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will arrive at a similar project setup, which may vary depending on the
    name of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Initial solution structure](img/Figure_8.5_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Initial solution structure'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire process is almost the same as we explored in the *Initializing a
    project* recipe in [*Chapter 1*](B22020_01.xhtml#_idTextAnchor020) . Navigate
    there for the first three steps. Here, we focus on *step 4* .
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we land on the project configuration panel. First, we select **.NET
    9 (Standard Term Support)** as our target framework. Then, we have an **Authentication
    type** section. Here, we opt for the **Individual Accounts** option, instructing
    Visual Studio to scaffold the code supporting identity in our application. We
    also enable HTTPS and generate sample pages by checking the respective checkboxes.
    Lastly, to complete the configuration setup, we define the interactivity of our
    application – we will use a per-page/component interactivity location and a mix
    of Server and WebAssembly rendering. Next, we see the result of the scaffolding
    – a solution with two projects for the server and client side, respectively. It
    looks nothing different from the standard Blazor template scaffold, so let’s dive
    into each project to understand how it supports identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the scaffolded projects’ structures look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Scaffolded server- and client-side projects, with enabled authentication](img/Figure_8.6_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Scaffolded server- and client-side projects, with enabled authentication'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first unpack the client-side project (on the right side in *Figure 8*
    *.6* ), as it’s significantly smaller. On the components’ side, we’re getting
    just one relevant to manage identity – **RedirectToLogin** . As the name implies,
    **RedirectToLogin** safely redirects a user to the login page, persisting the
    initial URL so that Blazor can return there. We’re also getting a **UserInfo**
    class – a model containing the user identity details we want to share between
    server- and client-side communication, and one we can easily extend. The backbone
    of sharing the authentication state across render mode boundaries is the **PersistentAuthenticationStateProvider**
    service, which we will explore in the *Supporting roles’ and policies’ authorization*
    recipe. Lastly, we’re getting a minimal setup in the **Program.cs** file. The
    **PersistentAuthenticationStateProvider** service is registered as a singleton
    in the **dependency injection container** ( **DI** ), and with the **AddAuthorizationCore()**
    extension method, all services required to enable authorization in our app are
    registered for us. We also get an invocation of the **AddCascadingAuthenticationState()**
    extension method to add an authentication state as a root-level cascading value
    and make it interceptable in the entire WebAssembly application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server-side project (on the left side in *Figure 8* *.6* ) contains the
    **Data** directory, with an **ApplicationDbContext** class, an **ApplicationUser**
    class, and a **Migrations** subdirectory, indicating that the server-side project
    is responsible for persisting and managing users and their identities. That means
    you must provide a valid connection string to the database where you want to store
    identity data. You’ll find a placeholder **DefaultConnection** node generated
    in the **appSettings.json** file, which you must replace with the connection details
    of your database resource. Next to the **Data** directory, we get a chunk of generated
    components, including an **Account** area, with pages and UI, handling all actions
    required to manage identity in our application. There are components for logging
    in, logging out, managing accounts, and even enabling **two-factor authentication**
    ( **2FA** ), and they’re all Razor-native components. You’ll notice that regardless
    of the interactivity declared when configuring, all the identity components are
    rendered in **server-side rendering** ( **SSR** ) mode by default. As is currently
    an industry standard for applications with a server-side to leverage cookies for
    identity management, we’re also getting a custom **IdentityRedirectManager** wrapper,
    which leverages the default Blazor **NavigationManager** class, extending it with
    identity status cookies and a few redirection resolvers. The **IdentityRedirectManager**
    class is also designed to throw an **InvalidOperationException** exception when
    used outside of the static SSR. In SSR, contrary to other rendering modes, we
    can access an **HttpContext** instance of each request. The **IdentityUserAccessor**
    class is another wrapper class, allowing us to resolve the current user identity
    from the **HttpContext** instance. In the **IdentityComponentsEndpointRouteBuilderExtensions**
    class, we get a mapping for three additional identity endpoints for logging in
    with an external **identity provider** ( **IdP** ), downloading personal user
    data, and logging out. These are missing in the default identity API implementation,
    as they’re native for applications with a UI. The **IdentityNoOpEmailSender**
    class is a placeholder service for sending identity-related emails: confirming
    user email or resetting passwords. You have to implement your own **IEmailSender**
    client before going live. We also get a **PersistingRevalidatingAuthenticationStateProvider**
    class that Blazor uses to share the authentication state across render boundaries
    between server and client code – we will explore that in the *Supporting roles’
    and policies’ authorization* recipe too. The **Program.cs** file gets a bit more
    complex. We will find here the default setup of interactive server and WebAssembly
    components and a default middleware pipeline. However, on top of that, we’re setting
    up the server-side identity features. We register the custom identity services
    (discussed earlier in this section) and invoke the **AddCascadingAuthenticationState()**
    extension method to enable the cascading of the authentication state at a root
    level. We configure the authentication leveraging the **AddAuthentication()**
    extension method. Here’s also where we inform Blazor to use cookies for identity
    persistence with the help of the **AddIdentityCookies()** extension method. In
    **Program.cs** , we also configure the database access for our **ApplicationDbContext**
    class. Lastly, and most importantly, we leverage the **AddIdentityCore()** method
    and the **IdentityBuilder** API to configure the required identity services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the structure of each of the projects, let’s visualize
    how the authentication workflow works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: Authentication workflow between server and client sides of the
    Blazor web app](img/Figure_8.7_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Authentication workflow between server and client sides of the
    Blazor web app'
  prefs: []
  type: TYPE_NORMAL
- en: When a user tries to access the application, their identity is checked. The
    authentication state provider service validates the available authentication cookie
    or lack thereof. If validation is successful, the user gets redirected to the
    page they intended to visit; otherwise, the user lands on the login page. After
    submitting the login form and receiving a successful authentication response from
    the IdP, Blazor persists the user’s identity in the authentication cookie. That
    cookie gets attached to every request between the server and client side, allowing
    **PersistingRevalidatingAuthenticationStateProvider** and **PersistentAuthenticationStateProvider**
    to effectively monitor and recognize the current user and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application for the first time and try to create an account,
    your application will fail. But in a developer-friendly way, you will see an exception
    page, informing you that you didn’t run the initial migration yet, so your backing
    database can’t support identity features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Exception page when you try to create an account without the
    initial migration](img/Figure_8.8_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Exception page when you try to create an account without the initial
    migration'
  prefs: []
  type: TYPE_NORMAL
- en: You will also get a simple **Apply Migrations** button allowing you to apply
    the migrations immediately!
  prefs: []
  type: TYPE_NORMAL
- en: All that code and functionality are ready to use, and you haven’t written a
    single line of your own code yet. Leveraging solution templates and scaffolding
    increases the velocity of the delivery of your application.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In case you’re not using a GUI or Visual Studio, you can leverage the cross-platform
    .NET CLI and scaffold the same template with a single command line. Navigate to
    your working directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the same format of a project that we did through the Visual Studio
    walk-through, with one difference. The project scaffolded with the .NET CLI utilizes
    the SQLite database rather than SQL Server. You can quickly adjust that by navigating
    to the **Program.cs** file of the server-side project and updating the **ApplicationDbContext**
    registration options to use SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Securing pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protecting unauthorized routing is crucial as malicious actors can attempt to
    scrape your application, bypassing the navigation paths enforced by your UI. Ensuring
    that only authorized users can access specific routes helps safeguard sensitive
    data and functionality. Blazor comes with a built-in **Authorize** attribute to
    check access permissions when a user navigates to a page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a routable component that only an authenticated user can navigate
    to by applying the **Authorize** attribute in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we add a secure component to the server-side project, create a **Components**
    / **Recipes** / **Recipe02** directory – this will be your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to protect a component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a routable **Settings** component with a **/** **ch08r02** path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reference the **Microsoft.AspNetCore.Authorization** assembly and attach an
    **Authorize** attribute to the **Settings** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add placeholder markup to the **Settings** component, informing the user that
    they are authorized to see this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we execute a routine step and create a new routable **Settings**
    component, leveraging **@page** . Next, in *step 2* , we reference the **Microsoft.AspNetCore.Authorization**
    assembly with the help of the **@using** directive right below the **@page** declaration.
    Then, we use **@attribute** to attach the **Authorize** attribute. Now, only authenticated
    users can access the **Settings** page. However, it’s important to note that Blazor
    performs a verification of the **Authorize** attribute only as part of the routing
    process and does not apply it to child components’ rendering flow. Lastly, in
    *step 3* , we add some placeholder content to inform users that they are authorized
    to view this page. In the **Settings** markup, we render the page header and a
    **You’re authorized to see** **settings.** message.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re building a markup-less component or simply working in a code-behind
    fashion, you can still leverage the **Authorize** attribute. Here’s how we would
    implement a markup-less version of the **Settings** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we’re no longer in a Razor file, we’re using the syntax of C# attributes.
    By decorating the **Settings** class with a **[Route]** attribute, we enable navigation
    to the **/ch08r02** path. Additionally, by adding the **[Authorize]** attribute,
    we ensure that Blazor only allows routing to this component for authenticated
    users. We effectively achieve the same logical behavior as in the initial implementation.
    As a side note, when you’re working in Razor files, the Razor compiler translates
    all the dedicated **@directive** declarations to attributes – similar to what
    we did with the markup-less component.
  prefs: []
  type: TYPE_NORMAL
- en: Securing markup areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, restricting access to an entire page can be too limiting. You might
    want to expose your landing page to everyone while fine-tuning the elements users
    see in the navigation menu. For example, authenticated users might have access
    to a back office feature that standard users cannot see despite viewing the same
    page. Blazor supports protecting specific markup areas with an **AuthorizeView**
    component. The **AuthorizeView** component allows you to control the visibility
    of content based on the user’s authentication state. It supports various states
    and works seamlessly with **RenderFragment** objects, making it highly flexible
    and versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s leverage the **AuthorizeView** component and add a status message visible
    only to authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we add a protected status message to a component, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe03**
    directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Settings** component from the *Securing pages* recipe or from the
    **Components** / **Recipes** / **Recipe02** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a protected markup area in a component:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Settings** component and remove the **Authorize** attribute
    and the existing **@** **using** directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the authorization status message in the **Settings** markup and wrap
    it in **AuthorizeView** component tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we remove the existing **Authorize** attribute and the **@using**
    directive, required to reference the attribute, from the **Settings** component,
    allowing all users to access the page.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we locate the **You’re authorized to see settings.** authorization
    status message in the **Settings** markup. We then wrap this message inside **AuthorizeView**
    component tags. The **AuthorizeView** component manages content visibility based
    on the user authentication state and accepts **ChildContent** , meaning Blazor
    will render the status message only for authenticated users. This approach ensures
    that only users with the proper credentials see certain content, enhancing the
    security and user experience of your application. You can find more details on
    the **ChildContent** pattern in the *Creating components with customizable content*
    recipe of [*Chapter 1*](B22020_01.xhtml#_idTextAnchor020) .
  prefs: []
  type: TYPE_NORMAL
- en: Blazor will effectively obscure everything inside the **AuthorizeView** component
    from unauthorized users. That means markup, as well as any event handlers or method
    calls. Consequently, you can secure your UI and entire features and functionalities,
    preventing unauthorized users from even knowing they exist.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from **ChildContent** , **AuthorizeView** supports providing the **Authorized**
    , **Authorizing** , and **NotAuthorized** fragments explicitly. With that, you
    can define distinct content for authenticated and unauthenticated users within
    the same component. You would leverage the **Authorizing** fragment to display
    a temporary message indicating that resolving of user’s identity is in progress,
    as you might need to execute some asynchronous and long-running logic. In our
    case, we could opt for the following markup in the **Settings** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The **AuthorizeView** component will evaluate the user’s authentication state
    normally, but this time give the user a feeling of each stage of the process.
    When authenticating the user, Blazor will render the content in **Authorizing**
    tags – a **Give us a few moments…** message. When authentication is complete,
    for the authenticated user, Blazor will render the markup in the **Authorized**
    section and display the expected **You’re authorized to see settings.** message.
    However, contrary to the **Authorized** attribute, an anonymous user will also
    see some content – one within **NotAuthorized** tags, saying **You can’t be here,
    sorry.** , offering meaningful feedback to unauthenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roles in web applications are predefined categories assigned to users that determine
    their access permissions and functionalities within the application. By categorizing
    users into roles, you can manage and control what each user can view and do, enhancing
    security and user experience. Roles provide a clear and structured way to enforce
    access control. Instead of managing permissions for each user, you can assign
    roles and define access rules based on these roles. This approach simplifies the
    administration of user permissions and ensures consistent security policies across
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a small form where authenticated users can create new roles in the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we implement the role creation form, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe04**
    directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Settings** component from the *Securing markup areas* recipe or from
    the **Components** / **Recipes** / **Recipe03** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t scaffolded your project, copy the **StatusMessage** component
    from the **Components** / **Account** / **Shared** directory of the GitHub repository
    to the same path in your server-side project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to set up roles’ support and management:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the server-side project’s **Program.cs** file. Find the section
    where we register identity services, starting with the **AddIdentityCore()** method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the **AddIdentityCore()** method, invoke the **AddRoles()** method and
    leverage the default **IdentityRole** model to declare the application role model.
    Below the **AddEntityFrameworkStores()** method, register a role manager with
    the help of an **AddRoleManager()** builder method with the default **RoleManager**
    service for the **IdentityRole** model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **Settings** component, and below the **@page** directive, add a set
    of **@using** directives referencing the necessary assemblies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the section with **@using** , inject **RoleManager** and **Navigation**
    services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Settings** component, initialize the **@code** block and construct
    an **InputModel** class with a single **RoleName** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the service injections, intercept a cascading value of **HttpContext**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below **HttpContext** , declare an **Input** parameter supplied from a form
    and override the **OnInitialized()** lifecycle method to complete the form initialization
    pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **@code** block with the implementation of a **SaveAsync()** method,
    where you initialize a new **IdentityRole** object and leverage the **RoleManager**
    service to save the new role. Use the **Navigation** service to perform a self-redirect
    and display the operation status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Settings** component markup, locate the **AuthorizeView** tags and
    declare a custom name for the **Context** parameter. Also, replace the authentication
    status message with a **StatusMessage** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below **StatusMessage** , initialize an **EditForm** component, attaching the
    **Input** model and the **SaveAsync()** method to the **Model** and **OnValidSubmit**
    parameters. Remember to declare a unique **EditForm** name as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **EditForm** component, add a paragraph with an editable input box
    binding to the **Input.RoleName** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **EditForm** component by adding a form submit button below the
    role name input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **Program.cs** file of the server-side project
    and locate the section where we register identity services. It’s a section starting
    with an **AddIdentityCore()** method and producing an **IdentityBuilder** object.
    In *step 2* , we invoke the **AddRoles()** method to add role management capabilities
    to the identity system. The **AddRoles()** method is a generic method requiring
    an identity role model class. We leverage the default **IdentityRole** model,
    provided with an identity package. The **IdentityRole** model is enough for our
    needs. Next, below the **AddEntityFrameworkStores()** method, we register the
    role manager using the **AddRoleManager()** builder method with the default **RoleManager**
    service for the **IdentityRole** model. We’ve effectively enabled roles’ support
    and roles’ management in the app.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we move to the **Settings** component. First, we add a set of
    **@using** directives below **@page** to reference the necessary assemblies, allowing
    access to the scaffolded **Account** area and built-in identity services. In *step
    4* , we inject the **RoleManager** and **Navigation** services, handling role
    management and navigation, respectively. In *step 5* , we initialize the **@code**
    block in the **Settings** component. Within the **@code** block, we construct
    an **InputModel** class with a single **RoleName** property. The **InputModel**
    class will hold the details of the new role when a user fills out the form. In
    *step 6* , we intercept a cascading value of **HttpContext** to access the current
    HTTP context – necessary for communicating role creation status later. The **HttpContext**
    object didn’t appear magically – when Blazor renders in SSR mode, it exposes the
    **HttpContext** instance cascadingly by default. In *step 7* , below **HttpContext**
    , we declare an **Input** parameter supplied from a form and override the **OnInitialized()**
    lifecycle method to complete the form initialization pattern. You can learn more
    about building forms in [*Chapter 6*](B22020_06.xhtml#_idTextAnchor203) . In *step
    8* , we complete the **@code** block by implementing a **SaveAsync()** method.
    In **SaveAsync()** , we initialize a new **IdentityRole** object and leverage
    **RoleManager** to save the new role to a database. We use the **Navigation**
    service and **HttpContext** to perform a self-redirect and send an operation status
    back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9* , we switch to the **Settings** markup. First, we locate the **AuthorizeView**
    tags. The **AuthorizeView** component is a generic component, so it exposes a
    **Context** property. Likewise, **EditForm** , which we will use for our form,
    is also a generic component having a **Context** property. We will have a conflict,
    and the app will not compile! To resolve that issue, we give a custom name to
    the **Context** property of **AuthorizeView** . We also replace the existing authentication
    status message with a **StatusMessage** component. The **StatusMessage** component
    intercepts **HttpContext** and resolves the status message from a designated cookie.
    That’s why we needed **HttpContext** in the **@code** block – to attach that status
    cookie correctly. In *step 10* , we initialize an **EditForm** component below
    **StatusMessage** , attaching the **Input** model and the **SaveAsync()** method
    to the **Model** and **OnValidSubmit** parameters, respectively. We also declare
    a unique **FormName** class for **EditForm** . Within **EditForm** , in *step
    11* , we add a paragraph with an editable input box binding to the **Input.RoleName**
    property, allowing the user to enter the new role name. Finally, in *step 12*
    , we complete the **EditForm** component by adding a form submit button below
    the role name input.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a user’s identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modifying a user’s identity can be crucial for tailoring your application’s
    functionality and improving user experience. Having additional identity properties,
    you can enable more personalized interactions and better manage user-specific
    information. In many applications, a username is equivalent to a user’s email,
    and that’s not enough details for displaying personalized greetings, sending customized
    notifications, or generating reports. But worry not. In Blazor, identity is highly
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s allow a user to fill in their first and last name.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before extending the user’s identity, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe05**
    directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Settings** component from the *Creating roles* recipe or from the
    **Components** / **Recipes** / **Recipe03** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the **seed-work.sql** script in the **Samples** directory of the server-side
    project in the GitHub repository and run it on your database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t scaffolded your project, copy the **StatusMessage** component
    from the **Components** / **Account** / **Shared** directory of the GitHub repository
    to the same path in your server-side project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to extend the default user identity model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **ApplicationUser** class in the **Data** directory of the
    server-side project and extend it with **FirstName** and **LastName** properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the **Package Manager Console** , call an Entity Framework command to
    generate a new **AddedUserFullName** database migration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, if you’re using the .NET CLI, generate the same migration using
    the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get a few new files in the **Data** / **Migrations** directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.9: Migration files adding FirstName and LastName properties to ApplicationUser
    in database](img/Figure_8.9_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Migration files adding FirstName and LastName properties to ApplicationUser
    in database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the **AddedUserFullName** migration to the database by calling another
    command in the **Package** **Manager Console** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, if you’re using the .NET CLI, update the database using the
    following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **Settings** component and add one more **@using** directive, next
    to the existing ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below, in the section with injections, replace the **RoleManager** service
    with **IdentityUserAccessor** , **UserManager** , and **SignInManager** services.
    Keep the already available **Navigation** service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block, update the **InputModel** class by replacing the existing
    properties with **FirstName** and **LastName** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the existing **SaveAsync()** method, declare a private **ApplicationUser**
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **_user** declaration, override the **OnInitializedAsync()** lifecycle
    method. Leverage the **UserAccessor** instance to get the user details from the
    database and hydrate the **Input** model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the **@code** block, update the **SaveAsync()** method so that
    it updates **_user** details from the filled **Input** model, persist changes
    with the help of **UserManager** , and refresh the user context using **SignInManager**
    . Lastly, update the status message returned to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Jump to the **Settings** markup area and locate the content area of the existing
    **EditForm** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the existing input label to **First Name** and fix the binding to the
    **Input.FirstName** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the first name, add a paragraph displaying another editable input binding
    to the **Input.LastName** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **ApplicationUser** class in the **Data** directory
    of the server-side project. The **ApplicationUser** class represents the user
    of our application and currently inherits from the default **IdentityUser** class
    to be compatible with the identity schema. Now, we extend our user identity details
    with **FirstName** and **LastName** properties. In *step 2* , we extend the identity
    database using a database migration. Database migrations are a way to manage and
    apply incremental changes to the database schema over time. They allow developers
    to define changes to the database structure, such as adding or modifying tables
    and columns, in code, ensuring that the database is in sync with the application.
    We open the **Package Manager Console** , available in Visual Studio, and generate
    a new **AddedUserFullName** database migration. The Entity Framework tool will
    generate two new files in the **Data** / **Migrations** directory. In *step 3*
    , we apply the **AddedUserFullName** migration to the database using the **Package
    Manager Console** again. We will not explore generated migrations or migration
    commands as they’re not in the scope of this book, but you can find additional
    resources in the *See also* section at the end of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in *step 4* , we open the **Settings** component and extend the set of
    already existing **@using** directives with a reference to a **BlazorCookbook.Auth.Data**
    assembly, where we have the **ApplicationUser** class. In *step 5* , we remove
    the **RoleManager** service injection, as we won’t work with roles. Instead, we’re
    adding a few other identity services. We need **IdentityUserAccessor** to resolve
    the user context from the application **HttpContext** instance. With the help
    of **UserManager** and **SignInManager** , we can safely manipulate and refresh
    user details. In *step 6* , we update the **InputModel** class to support our
    new requirements and replace all existing properties with **FirstName** and **LastName**
    properties, matching the details we want to see on the new form later. At this
    point, you will see some IDE errors, as the existing form is no longer compatible
    with the updated **InputModel** class. We will fix that shortly. In *step 7* ,
    we declare a backing field – a private **ApplicationUser** variable to store a
    reference to the database object representing the currently logged-in user. We
    will use it to persist the first and last name the user provides. In *step 8*
    , we override the **OnInitializedAsync()** lifecycle method. We leverage the injected
    **UserAccessor** service to resolve the **ApplicationUser** object from **HttpContext**
    into the **_user** instance and hydrate the **Input** model with the found details.
    That way, we ensure the form is pre-populated with the current user’s details
    before the UI renders. To complete the **@code** block, in *step 9* , we update
    the **SaveAsync()** method so that it supports the updated **Input** model and
    saves user identity details. We update the persisted **_user** object with data
    coming from the form, filled by the user, and save those changes to the database
    with the help of **UserManager** . After updating, we refresh the user context
    using **SignInManager** and perform a self-redirect to display a **Your profile
    has been updated** message on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in *step 10* , we jump to the **Settings** markup area and locate the
    existing **EditForm** component. We will adjust the form to support filling in
    the user’s first and last names. In *step 11* , we fix the no longer compatible
    input box by binding it to the **Input.FirstName** property. We also update the
    label to **First name** , to make it clear which field the user is updating. Similarly,
    in *step 12* , we add a paragraph with another editable input box with a **Last
    name** label and binding to the **Input.LastName** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the form in place, you can run the app and update the first and last name
    of the account you’ll be using. When you fill the inputs and save the changes,
    you’ll receive a friendly confirmation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Status message confirming that changes were successfully applied](img/Figure_8.10_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Status message confirming that changes were successfully applied'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check changes in the database by displaying the records in the
    **AspNetUsers** table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: Reviewing first and last name updates in the database](img/Figure_8.11_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Reviewing first and last name updates in the database'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ve touched on the concept of database migrations. It’s a
    topic deserving a book of its own, but if you’d like to learn more, go to the
    learning resources prepared by the Microsoft team: [https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting roles’ and policies’ authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing your application might not be just about having an authenticated user;
    it often requires more granular control. You may need to grant access to specific
    features or pages based on the user’s role. Blazor’s native authorization APIs
    – the **Authorize** attribute and the **AuthorizeView** component – support both
    roles and policies that you will find familiar from MVC applications or REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement roles and policies, fine-tuning a settings page to display different
    content for administrators and standard users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we put policies and roles in place, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe06**
    directory – this will be your working directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Settings** component from the *Modifying a user’s identity* recipe
    or from the **Components** / **Recipes** / **Recipe05** directory in the GitHub
    repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t run migrations yet, find the **seed-work.sql** script in the
    **Samples** directory of the server-side project and run it on your database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re not following along, make sure you have roles’ support enabled in
    your server-side project; you must leverage the **AddRoles()** builder API method,
    which we discussed in the *Creating* *roles* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add roles’ and policies’ support, both on the server and client side, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Program.cs** file in the **BlazorCookbook.Auth.Client** project
    – the client-side application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Program.cs** file, find the **AddAuthorizationCore()** method call
    and overload it with **options** to configure the **InternalEmployee** policy
    that checks if a user’s email belongs to the **@** **packt.com** domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still on the client side, open the **UserInfo** class and extend it with a
    **Role** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, navigate to the **PersistentAuthenticationStateProvider** class, and
    in the constructor, extend the **claims** array to include the newly added **Role**
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the server-side application and open the **Program.cs** file of the
    **BlazorCookbook.Auth** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate where the app is built, and just before that, use the authorization
    builder to add the same **InternalEmployee** policy as on the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to an **OnPersistingAsync** method of a **PersistingRevalidatingAuthenticationStateProvider**
    class and extend the logic executed for the authenticated user to append the role
    to the **UserInfo** class that Blazor will send over to the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **Settings** component, and below the **@page** directive, add the
    **Authorize** attribute overloaded with the **InternalEmployee** policy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Settings** markup, find the existing **AuthorizeView** opening tag
    and set the **Roles** parameter to allow **Support** and **Admin** roles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **EditForm** protected area, construct another **AuthorizeView**
    section, protecting a **Shut down the app** button and rendering the content only
    for users in the **Admin** role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re starting with the client-side application, so in *step 1* , we navigate
    to the **Program.cs** file in the **BlazorCookbook.Auth.Client** project. In *step
    2* , we extend the authorization registration by finding the **AddAuthorizationCore()**
    method call and overloading it with options to configure the **InternalEmployee**
    policy. We leverage the **AuthorizationPolicyBuilder** class, which we call **policy**
    , to check if a currently logged-in user’s email belongs to the **@packt.com**
    domain. The **AuthorizationPolicyBuilder** class supports custom assertions (which
    we used) as well as checking claims, usernames, or .NET native **IAuthorizationRequirement**
    objects. In *step 3* , we open the **UserInfo** class and extend it with a **Role**
    property. The **UserInfo** class is a model that Blazor uses to share user identity
    details across render mode boundaries. As we need the WebAssembly side to resolve
    user roles correctly, we must pass them there explicitly. In *step 4* , we complete
    the client-side configuration by extending the constructor of the **PersistentAuthenticationStateProvider**
    class. Blazor uses **PersistentAuthenticationStateProvider** to determine the
    user’s authentication state that arrives from the server side. In the constructor,
    we deserialize the state into a **UserInfo** object and extend the **claims**
    array to include the value of the newly added **Role** property. Now, whenever
    our application runs locally in the browser, the user’s role will still be available
    to verify against.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we switch to the server-side application and open the **Program.cs**
    file of the **BlazorCookbook.Auth** project. In *step 6* , we locate where we
    invoke the **builder.Build()** method to build the app. Right before that, we
    add the same **InternalEmployee** policy as on the client side with the help of
    the authorization builder. As the policy assertion is indeed the same, the server
    API for configuring authorization is slightly different. We invoke the **AddAuthorizationBuilder()**
    method to access the **AuthorizationBuilder** instance as it exposes the **AddPolicy()**
    builder method. In *step 7* , we complete the server-side implementation by navigating
    to the **OnPersistingAsync** method of the **PersistingRevalidatingAuthenticationStateProvider**
    class. That’s the service Blazor uses when passing the user’s identity to the
    browser. We locate the logic for the authenticated user. It already contains the
    sharing of the user’s ID and email. We follow the same implementation pattern
    by grabbing the value of **RoleClaimType** from the current **principal** value
    and passing it on to the **UserRole** object that Blazor will persist as JSON
    inside the outgoing response.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put all that authorization implementation to the test. In *step 8* ,
    we open the **Settings** component and add the **Authorize** attribute. It requires
    a reference to the **Microsoft.AspNetCore.Authorization** assembly, so we grant
    that with the **@using** directive. Then, we leverage the overloading of the **Authorize**
    attribute. We can set the **Policy** property so that the user must meet it to
    access the **Settings** page. That’s where we finally use the **InternalEmployee**
    policy. In *step 9* , we continue to the **Settings** markup. We find the existing
    **AuthorizeView** opening tag, wrapping the form where users can fill in their
    first and last names. We set the **Roles** parameter to **Support** and **Admin**
    values, ensuring that the form renders only when the current user is in any of
    the expected roles. The **Roles** parameter accepts a **string** object, so you
    can provide one or multiple comma-separated roles. You can also have as many protected
    markup areas as you need within the same component. In *step 10* , we construct
    another **AuthorizeView** area below the one already existing. Inside, we construct
    an idle **Shut down the app** button, but we ensure it renders only for users
    in the **Admin** role.
  prefs: []
  type: TYPE_NORMAL
- en: We arrive at a fully functional, secure view that adjusts dynamically to whoever
    is viewing it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8* *.12* shows the store settings to the user with the **Admin** role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Store settings that an admin@packt.com user sees](img/Figure_8.12_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Store settings that an admin@packt.com user sees'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8* *.13* shows the store settings to the user with the **Support**
    role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: Store settings that a support@packt.com user sees](img/Figure_8.13_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Store settings that a support@packt.com user sees'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when I log in as **admin@packt.com** , which has the **Admin**
    role, I can see both the edit form and the most restricted **Shut down the app**
    button. But the moment I change to **support@packt.com** , the **Shut down the
    app** button is gone! I encourage you to check how the UI changes when you log
    in as **user@packt.com** .
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Authorize** attribute supports the same authorization APIs that **AuthorizeView**
    does. Both can use **Roles** and **Policy** to verify the user’s identity against
    specific criteria. You can even use both **Roles** and **Policy** at the same
    time!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With the **Authorize** attribute, we now verify whether the logged-in user
    has any of the three allowed roles: **User** , **Support** , or **Admin** . Additionally,
    we’ve updated the rendering of the user details edit form. Now, **AuthorizeView**
    displays the form to anyone meeting the **InternalEmployee** policy and having
    any of the available roles. We’ve also updated the restrictions on the **Shut
    down the app** button – the user has to have the **Admin** role and belong to
    the **@packt.com** domain, enforced by the **InternalEmployee** policy.'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of **Authorize** and **AuthorizeView** work similarly but are
    applied at different levels. The question remains when to use the attribute and
    when the component suits best. Use **Authorize** when protecting navigation to
    a given resource or page, ensuring that only authorized users can access it. On
    the other hand, use **AuthorizeView** when you need to restrict access to certain
    areas of the markup without affecting the overall routing. This approach provides
    a comprehensive way to secure your Blazor application, ensuring that only authorized
    users can access specific features and content.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving authentication state in procedural logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorporating authentication and authorization into the procedural logic of
    your application is often necessary. Simply manipulating markup visibility may
    not suffice in these scenarios; you need to resolve the current authentication
    state to make informed decisions within your code. That’s where a cascading **AuthenticationState**
    class comes in. The **AuthenticationState** class is a built-in Blazor feature
    that provides information about the user’s authentication status and claims.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a button that redirects internal employees to different areas of a
    ticketing system based on their roles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we leverage authentication state in procedural logic, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side project, create a **Components** / **Recipes** / **Recipe07**
    directory – this will be your working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **FakePages** directory from the **Components** / **Recipes** / **Recipe07**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t run migrations yet, find the **seed-work.sql** script in the
    **Samples** directory of the server-side project and run it on your database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will need to enable interactivity, we can’t use any of the existing **Settings**
    components anymore, so we will create a totally new one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these instructions to leverage authentication state in procedural logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new routable **Settings** component with server-side interactivity
    and an injected **Navigation** service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a **@code** block to intercept the cascading authentication state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **AuthState** parameter, initialize a **GoToTicketsAsync()** method
    and resolve the **user** context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **user** context, check if the user’s **Identity** property has a
    value and redirect to the login page if it’s missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **Identity** verification, check if the user is correctly authenticated
    and redirect to the login page if not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After authentication verification, check if the value of the user’s **Name**
    property belongs to the **@packt.com** domain and, if not, redirect them to the
    landing page of the ticketing system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the user’s domain check, check if the user is in the **Support** or **Admin**
    role and redirect them to the admin panel of the ticketing system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, if the user’s identity doesn’t fit any of the handled cases, redirect
    them to the access denied page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to the markup of the **Settings** component and add a button to navigate
    to the ticketing system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a new routable **Settings** component, rendering in
    an **InteractiveServer** mode as we want our users to navigate to the ticketing
    system with a button click.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow along the entire chapter or have scaffolded your project, you
    will already have a cascading authentication state registered. But to give you
    a comprehensive overview, in both server- and client-side projects, in their **Program.cs**
    files, you will find (or add, if it’s missing) the **builder.Services.AddCascadingAuthenticationState()**
    command that explicitly enables cascading authentication state in your application.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we initialize the **@code** block in the **Settings** component.
    Firstly, we intercept the authentication state. Blazor shares **AuthenticationState**
    as a **Task** parameter – in line with modern web development, where all operations
    are inherently asynchronous and as the **AuthenticationStateProvider** implementation
    might contain asynchronous logic constructing the authentication state. We also
    inject a **NavigationManager** service to help us redirect the user to the intended
    destination. For the next couple of steps, still inside the **@code** block, we
    implement a **GoToTicketsAsync()** method to resolve the redirection destination
    based on the user’s identity context. In *step 3* , we resolve the **user** object
    by awaiting **AuthState** and grabbing the **User** property from the result.
    In *step 4* , we check if the current user has an **Identity** value set, which
    can be **null** if the user hasn’t logged in yet. If the **Identity** value is
    missing, we immediately redirect the user to the login page. In *step 5* , we
    perform an additional check on the **Identity** value using the **IsAuthenticated**
    property to verify if the user is logged in and correctly authenticated. If that
    check fails, we redirect the user to the login page to revalidate their authentication
    state. Now that we are sure the current user has a valid identity, in *step 6*
    , we check if the user is actually an internal employee. We leverage the **Name**
    property of the **user** object, representing the user’s login in the application.
    As, in our case, the **Name** property is equivalent to the user’s email, we verify
    if the user account of the current user we check belongs to the **@packt.com**
    domain. If that check fails, we redirect the user to the **/tickets** page, where
    they can create new support tickets as standard application users. In *step 7*
    , knowing that an internal employee is using the application, we check if they
    have an **Admin** or **Support** role. If they do, we redirect them to the **/tickets/admin**
    page, where they can access the admin panel of the ticketing system. In *step
    8* , we close the implementation of the **GoToTicketsAsync()** method. When all
    the previous authentication and authorization checks fail, we assume the user’s
    account is incomplete and redirect them to the **/tickets/denied** page, indicating
    they can’t access the ticketing system.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9* , we extend the **Settings** component markup. Below the existing
    **h3** header, we add a paragraph with a **button** property that invokes the
    **GoToTicketsAsync()** method upon click, allowing the user to navigate to the
    ticketing system. Effective redirection depends on the result of the procedural
    logic we added and the user’s identity.
  prefs: []
  type: TYPE_NORMAL
