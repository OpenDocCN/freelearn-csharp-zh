<html><head></head><body>
  <div id="_idContainer070">
   <h1 class="chapter-number" id="_idParaDest-135">
    <a id="_idTextAnchor165">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     11
    </span>
   </h1>
   <h1 id="_idParaDest-136">
    <a id="_idTextAnchor166">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Utilizing Asynchronous Programming for Scalability
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Whenever we execute a function, we expect a result, but what happens between the request and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      outputted result?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Imagine you’re in town, and you have a bunch of errands to run, but you’re also hungry and need to eat lunch.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     You walk into a pizza shop, situated within a shopping mall.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     The shop cooks fresh pizza to order.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     It takes around fifteen minutes for the pizza to be prepped and then cooked.
    </span>
    <span class="koboSpan" id="kobo.5.5">
     You can wait around in the shop until the pizza is done, but you need to go to the bank, which has a branch across the road.
    </span>
    <span class="koboSpan" id="kobo.5.6">
     The pizza store owner is a friend of yours and agrees to text you when your pizza is ready to pick up.
    </span>
    <span class="koboSpan" id="kobo.5.7">
     You have an opportunity to get something else done while your pizza is cooking; that’s a much better use of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      your time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     This is a simple analogy for an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      asynchronous
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     The act of walking into the pizza shop is the
    </span>
    <a id="_idIndexMarker441">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     function starting, and you running over to the bank while it is cooking is the function running.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     When your phone beeps with a text to say the pizza is ready, that is the function returning
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      its output.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     This example demonstrates the benefits of an asynchronous function, which allows for the execution of other tasks while waiting for a specific operation to complete.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     Cooking your pizza doesn’t block your overall goal, which is to run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      your errands.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     If the pizza shop owner was a lot less friendly and demanded that you wait in the shop until the pizza was done, that would be an example
    </span>
    <a id="_idIndexMarker442">
    </a>
    <span class="koboSpan" id="kobo.15.1">
     of a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.16.1">
      synchronous
     </span>
    </strong>
    <span class="koboSpan" id="kobo.17.1">
     operation, the opposite of asynchronous.
    </span>
    <span class="koboSpan" id="kobo.17.2">
     Synchronous operations block the progression of your overall goal (running your errands) until the current operation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      is complete.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.19.1">
     Where possible, we want to reap the benefits of asynchronous programming for operations that are executing as part of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.20.1">
      minimal APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.21.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.22.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Understanding and implementing asynchronous patterns in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       minimal API
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      Common pitfalls
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       and challenges
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor167">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     The code for this chapter is available in the GitHub repository at:
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="koboSpan" id="kobo.29.1">
      https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
     </span>
    </a>
    <span class="koboSpan" id="kobo.30.1">
     .
    </span>
    <span class="koboSpan" id="kobo.30.2">
     Visual Studio with the .NET 9 SDK is required to run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      the code.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-138">
    <a id="_idTextAnchor168">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     Understanding and implementing asynchronous patterns in a minimal API
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     The opening pizza
    </span>
    <a id="_idIndexMarker443">
    </a>
    <span class="koboSpan" id="kobo.34.1">
     analogy is hopefully a good, high-level illustration of the difference between asynchronous and synchronous programming.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     Asynchronous programming is significant in minimal APIs because it provides a lot of flexibility for managing the conversations between client and server.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     It is particularly beneficial to long-running operations, where the overall performance of a request would be compromised by operations running in a linear fashion, with each operation blocking
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      the other.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     Asynchronous programming also provides scalability benefits, allowing APIs to cope with high demand.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     This is achieved by ensuring that threads are not blocked.
    </span>
    <span class="koboSpan" id="kobo.36.3">
     Operations in an asynchronous endpoint can register callbacks to ensure that the execution thread can continue running other tasks until that callback is resolved.
    </span>
    <span class="koboSpan" id="kobo.36.4">
     This brings with it other resource benefits such as better management of the thread pool, lower CPU consumption, and decreased memory footprint.
    </span>
    <span class="koboSpan" id="kobo.36.5">
     All of these things are crucial for minimal APIs, which are designed to be as straightforward and efficient
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      as possible.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor169">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     Task-based asynchronous pattern
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     .NET has seen
    </span>
    <a id="_idIndexMarker444">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     the use of several different asynchronous programming patterns on its journey from .NET
    </span>
    <a id="_idIndexMarker445">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     Framework to  .NET core.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     In the .NET Framework days, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.42.1">
      Task-based Asynchronous Pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.43.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.44.1">
      TAP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.45.1">
     ) was the preferred method for managing asynchronous execution.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     Introduced in the Task Parallel Library in .NET 4, it uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.46.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.48.1">
      Task&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     to represent asynchronous operations and to provide a way to handle their results or exceptions.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     The explicit implementation of the TAP is now obsolete in .NET 9, but the example is effective at demonstrating asynchronous operations.
    </span>
    <span class="koboSpan" id="kobo.49.3">
     If we were to use it in a minimal API, it would be situated in the body of an endpoint, with the establishment of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.50.1">
      Task&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.51.1">
     , which would execute a long-running task.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     We would then start the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.52.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.53.1">
     while at the same time telling it what logic it should call back to once it has finished.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     We can see this in this example, which runs a task to grab data from another API and then continues by checking the result
    </span>
    <a id="_idIndexMarker446">
    </a>
    <span class="koboSpan" id="kobo.54.1">
     before returning a response to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker447">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      client:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.57.1">
app.MapGet("/fetch-data", (HttpContext httpContext) =&gt;
{
    HttpClient client = new HttpClient();
    string url =
        "https://jsonplaceholder.typicode.com/posts/1";
    // Initiate the asynchronous operation and return a
    // continuation task
    return client.GetStringAsync(url).ContinueWith(task =&gt;
    {
        if (task.IsCompletedSuccessfully)
        {
            // Task completed successfully, return the data
            return httpContext.Response.WriteAsJsonAsync(
                new { data = task.Result }
            );
        }
        else if (task.IsFaulted)
        {
            // Task faulted, handle the exception
            var errorMessage =
                task.Exception.Flatten().InnerException
                    ?.Message ?? </span><span class="koboSpan" id="kobo.57.2">"An error occurred";
            httpContext.Response.StatusCode =
                StatusCodes.Status500InternalServerError;
            return httpContext.Response.WriteAsJsonAsync(
                new { error = errorMessage }
            );
        }
        else
        {
            // If task was cancelled or some other state,
            // handle accordingly
            httpContext.Response.StatusCode =
                StatusCodes.Status500InternalServerError;
            return httpContext.Response.WriteAsJsonAsync(
                new { error = "Unknown error occurred." </span><span class="koboSpan" id="kobo.57.3">}
            );
        }
    });
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     While this code can
    </span>
    <a id="_idIndexMarker448">
    </a>
    <span class="koboSpan" id="kobo.59.1">
     demonstrate
    </span>
    <a id="_idIndexMarker449">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     asynchronous execution in an API endpoint, it could be a lot more readable.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     Fortunately, back in .NET Framework 4.5 and .NET 5, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.61.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.62.1">
     keywords
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      were introduced.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor170">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     TAP with async/await
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     keywords
    </span>
    <a id="_idIndexMarker450">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     made
    </span>
    <a id="_idIndexMarker451">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     asynchronous
    </span>
    <a id="_idIndexMarker452">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     programming more accessible by allowing us to write asynchronous code that resembles synchronous code.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     This went a long way toward making asynchronous code more readable and therefore understandable.
    </span>
    <span class="koboSpan" id="kobo.70.3">
     In a minimal API, where we’re aiming to be economical with the real estate in our IDE, this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      very valuable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     This is what the endpoint from the last example looks like when using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.73.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.74.1">
     instead of using the original
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      Task-based syntax:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.76.1">
app.MapGet(
    "/fetch-data-async-await",
    async (HttpContext httpContext) =&gt;
{
    HttpClient client = new HttpClient();
    string url =
        "https://jsonplaceholder.typicode.com/posts/1";
    try
    {
        // Asynchronously fetch data from the external
        // service
        string data = await client.GetStringAsync(url);
        await httpContext.Response.WriteAsJsonAsync(
            new { data}
        );
    }
    catch (HttpRequestException ex)
    {
        // Handle error (e.g., network issues, server
        // problems)
        httpContext.Response.StatusCode =
            StatusCodes.Status500InternalServerError;
        await httpContext.Response.WriteAsJsonAsync(
            new
            {
                error =
                    "Error fetching data: " + ex.Message
            });
    }
    catch (Exception ex)
    {
        // Handle any other exceptions
        httpContext.Response.StatusCode =
            StatusCodes.Status500InternalServerError;
        await httpContext.Response.WriteAsJsonAsync(
            new
            {
                error =
                    "An unexpected error occurred: " +
                        ex.Message
            });
    }
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     It’s hopefully clear to see that the section of code in the second example, which starts the asynchronous call to the other API, is much cleaner and shorter than its counterpart in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      first example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     In minimal APIs, we don’t need to do much to make an API endpoint compatible with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     .
    </span>
    <span class="koboSpan" id="kobo.81.2">
     Notice how, in the second example that uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     , the endpoint has the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.84.1">
      async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     keyword preceding the lambda expression defined after the route.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     This, like in regular .NET functions and methods, allows for the use of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.86.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     keyword in the body of the function.
    </span>
    <span class="koboSpan" id="kobo.87.2">
     Without the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.88.1">
      async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.89.1">
     keyword,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.90.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.91.1">
     is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      not supported.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     The first example did not use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.94.1">
      async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.95.1">
     keyword, but it was ultimately still able to create an asynchronous operation.
    </span>
    <span class="koboSpan" id="kobo.95.2">
     This may look like a contradiction until we consider that as well as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.96.1">
      async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.98.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     is notably absent from the first example.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     So, it’s important to remember that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.100.1">
      async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     keyword is not a pre-requisite for any asynchronous code in a minimal API, but it allows for the use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.102.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     , and therefore a simpler implementation
    </span>
    <a id="_idIndexMarker453">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     of
    </span>
    <a id="_idIndexMarker454">
    </a>
    <span class="koboSpan" id="kobo.105.1">
     asynchronous
    </span>
    <a id="_idIndexMarker455">
    </a>
    <span class="koboSpan" id="kobo.106.1">
     operations that resemble
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      synchronous ones.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.108.1">
     By using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     , we can implement the TAP in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      streamlined fashion.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-141">
    <a id="_idTextAnchor171">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     Asynchronous processing pattern
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     There is another well
    </span>
    <a id="_idIndexMarker456">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     defined pattern
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.115.1">
     that achieved asynchronous execution known as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.116.1">
      Asynchronous
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.117.1">
       Processing Pattern
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.118.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     Sometimes referred to as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.120.1">
      deferred processing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     , this pattern can be somewhat complex compared to the TAP, but the
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.122.1">
     principle is the same.
    </span>
    <span class="koboSpan" id="kobo.122.2">
     The flow of control is returned to the consumer of the function while other long-running operations
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.123.1">
     are completed.
    </span>
    <span class="koboSpan" id="kobo.123.2">
     However, in this pattern, the consumer of the function is not the API application’s main
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     thread, but the client making the request to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      API endpoint.
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.126.1">
       Figure 1
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.127.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.128.1">
     demonstrates execution via
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      deferred processing:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer069">
     <span class="koboSpan" id="kobo.130.1">
      <img alt="Figure 11.1: Deferred processing spanning two client requests" src="image/B20968_11_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.131.1">
     Figure 11.1: Deferred processing spanning two client requests
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     We can turn the current
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.133.1">
     example
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.134.1">
     into a version that uses deferred processing relatively easily.
    </span>
    <span class="koboSpan" id="kobo.134.2">
     First, we would need to make an endpoint that starts execution of the long-running task, but then immediately acknowledges the caller by returning a status code.
    </span>
    <span class="koboSpan" id="kobo.134.3">
     However, a status code on its own will not suffice.
    </span>
    <span class="koboSpan" id="kobo.134.4">
     We must return a callback URL for the client.
    </span>
    <span class="koboSpan" id="kobo.134.5">
     This URL will route to another endpoint, which will check to see whether our long-running operation has completed.
    </span>
    <span class="koboSpan" id="kobo.134.6">
     If it has, it will retrieve the relevant data before returning it to the client as a response.
    </span>
    <span class="koboSpan" id="kobo.134.7">
     If the operation has not been completed, it will still respond to the client, indicating that the operation is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.135.1">
      still running.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Let’s start by creating the first endpoint, which will acknowledge the client’s request for the long-running operation to start.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     We’ll also create a dictionary to hold responses waiting to be collected by clients
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      via callbacks:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.138.1">
var results = new ConcurrentDictionary&lt;Guid, string&gt;();
// Endpoint to start the long-running background task
app.MapPost("/start-process", async () =&gt;
{
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.139.1">
     The dictionary has been added as a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      ConcurrentDictionary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     because it is thread-safe, meaning that .NET will automatically manage scenarios where it is accessed by multiple concurrent
    </span>
    <a id="_idIndexMarker463">
    </a>
    <span class="koboSpan" id="kobo.142.1">
     threads.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     An
    </span>
    <a id="_idIndexMarker464">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     example would be  if there are multiple requests to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.144.1">
      the API.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     Next, inside the body of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     endpoint, we generate a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      GUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     to represent the pending request, as well as a string version of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      GUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     that can be referenced in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      callback response:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.153.1">
var requestId = Guid.NewGuid();
var requestIdStr = requestId.ToString();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     All that remains now is to start the long-running task, before returning the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.155.1">
      GUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     to the client so that they can use it in the callback request to see whether their result is ready
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.157.1">
      for retrieval:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.158.1">
// Start the long-running task
_ = Task.Run(async () =&gt;
{
    await Task.Delay(10000); // Simulate a long-running
                             // task (10 seconds)
    results[requestId] = $"Result for {requestIdStr}";
    // Store result in dictionary
});
// Respond with the request ID
return Results.Ok(new { RequestId = requestIdStr });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.159.1">
     Now that the client has a unique identifier in the form of the returned
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      GUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     , it can be used in a second request to get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.162.1">
      the result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.163.1">
     Let’s create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     endpoint for this purpose.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     The endpoint will be a lot simpler than the first.
    </span>
    <span class="koboSpan" id="kobo.165.3">
     It will simply attempt to find an entry in the dictionary that has a key matching the passed-in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      GUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     parameter.
    </span>
    <span class="koboSpan" id="kobo.167.2">
     If the dictionary contains the requested key-value pair, the original long-running operation is completed.
    </span>
    <span class="koboSpan" id="kobo.167.3">
     Otherwise, it must still be running or was never initiated.
    </span>
    <span class="koboSpan" id="kobo.167.4">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     endpoint
    </span>
    <a id="_idIndexMarker465">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     must
    </span>
    <a id="_idIndexMarker466">
    </a>
    <span class="koboSpan" id="kobo.171.1">
     handle both of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      these scenarios:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.173.1">
// Endpoint to get the result based on the request ID
app.MapGet("/get-result/{requestId}", (string requestId) =&gt;
{
    if (Guid.TryParse(requestId, out var guid) &amp;&amp;
        results.TryGetValue(guid, out var result))
    {
        return Results.Ok(new { Result = result });
    }
    return Results.NotFound(new { Error =
        "Result not found or not yet completed."
</span><span class="koboSpan" id="kobo.173.2">    });
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.174.1">
     Go ahead and try calling these two endpoints, one after the other.
    </span>
    <span class="koboSpan" id="kobo.174.2">
     If you request the second endpoint within less than ten seconds of the first one, you should get a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.175.1">
      404 NOTFOUND
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     result with the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.177.1">
      Result not found or not yet completed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     message and then get the expected
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      GUID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     result after ten seconds.
    </span>
    <span class="koboSpan" id="kobo.180.2">
     This will have demonstrated deferred processing in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      simple way.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.182.1">
     To expand your practice of this execution pattern, you should attempt more elaborate use cases, such as
    </span>
    <a id="_idIndexMarker467">
    </a>
    <span class="koboSpan" id="kobo.183.1">
     running
    </span>
    <a id="_idIndexMarker468">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     complicated mathematical calculations or making database or network requests in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      the background.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor172">
    </a>
    <span class="koboSpan" id="kobo.186.1">
     Common pitfalls and challenges
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.187.1">
     Asynchronous
    </span>
    <a id="_idIndexMarker469">
    </a>
    <span class="koboSpan" id="kobo.188.1">
     programming brings with it a series of pitfalls and challenges.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     Let’s go through some examples of things that you should be vigilant about when writing asynchronous code in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      minimal API:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.190.1">
       Deadlocks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.191.1">
      : A deadlock
     </span>
     <a id="_idIndexMarker470">
     </a>
     <span class="koboSpan" id="kobo.192.1">
      occurs when concurrent operations cannot complete due to blocking.
     </span>
     <span class="koboSpan" id="kobo.192.2">
      In a minimal API, this can be seen when the main thread is blocked.
     </span>
     <span class="koboSpan" id="kobo.192.3">
      In the following example, the use of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.193.1">
       Task.Run
      </span>
     </strong>
     <span class="koboSpan" id="kobo.194.1">
      can cause a deadlock because it blocks the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.195.1">
       main thread:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.196.1">
// Deadlock-prone code
public async Task&lt;IActionResult&gt; GetData()
{
    var data = Task.Run(() =&gt;
        GetDataFromDatabase()).Result; // Blocking
                                       // call
    return Ok(data);
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.197.1">
       The way to avoid
      </span>
      <a id="_idIndexMarker471">
      </a>
      <span class="koboSpan" id="kobo.198.1">
       deadlocks would simply be to use
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.199.1">
        await
       </span>
      </strong>
      <span class="koboSpan" id="kobo.200.1">
       when running the task, to ensure that the call does not block the
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.201.1">
        main thread:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.202.1">public async Task&lt;IActionResult&gt; GetData()
{
    var data = await Task.Run(() =&gt;
        GetDataFromDatabase());
    return Ok(data);
}</span></pre>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.203.1">
       Resource Management
      </span>
     </strong>
     <span class="koboSpan" id="kobo.204.1">
      : Where
     </span>
     <a id="_idIndexMarker472">
     </a>
     <span class="koboSpan" id="kobo.205.1">
      possible, minimal API code that manages resources such as database connections or file handles should be disposed of appropriately in an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.206.1">
       asynchronous context.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.207.1">
       Any resource that implements
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.208.1">
        IDisposable
       </span>
      </strong>
      <span class="koboSpan" id="kobo.209.1">
       can make use of a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.210.1">
        using
       </span>
      </strong>
      <span class="koboSpan" id="kobo.211.1">
       statement to automatically dispose of the resource when no longer in use.
      </span>
      <span class="koboSpan" id="kobo.211.2">
       However, when writing asynchronous code for resources, try to use
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.212.1">
        IDisposableAsync
       </span>
      </strong>
      <span class="koboSpan" id="kobo.213.1">
       where
      </span>
      <a id="_idIndexMarker473">
      </a>
      <span class="koboSpan" id="kobo.214.1">
       available.
      </span>
      <span class="koboSpan" id="kobo.214.2">
       This means you use
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.215.1">
        await
       </span>
      </strong>
      <span class="koboSpan" id="kobo.216.1">
       in conjunction with a
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.217.1">
         using
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.218.1">
        statement:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.219.1">
public async Task&lt;IActionResult&gt; GetData()
{
    await using (var dbContext = new DbContext())
    {
        var data = await dbContext.GetDataAsync();
        return Ok(data);
    }
}</span></pre>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.220.1">
       Race conditions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.221.1">
      : A race condition
     </span>
     <a id="_idIndexMarker474">
     </a>
     <span class="koboSpan" id="kobo.222.1">
      is the result of multiple threads accessing and modifying shared data concurrently.
     </span>
     <span class="koboSpan" id="kobo.222.2">
      For example, if you have a static field in your minimal API, and an endpoint that accesses it for modification, you must remember that requests can execute concurrently, with multiple clients potentially running the endpoint logic at the same time.
     </span>
     <span class="koboSpan" id="kobo.222.3">
      This would cause the static field in your API to become inconsistent and therefore inaccurate.
     </span>
     <span class="koboSpan" id="kobo.222.4">
      You must ensure that each operation against shared data is
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.223.1">
       atomic
      </span>
     </em>
     <span class="koboSpan" id="kobo.224.1">
      –  a single operation must complete before
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.225.1">
       another occurs:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.226.1">
private static int _counter = 0;
public async Task&lt;IResult&gt; IncrementCounter()
{
    var newCounterValue = _counter + 1;
    await Task.Delay(100); // Simulate async work
    _counter = newCounterValue;
    return Results.Ok(_counter);
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.227.1">
       In this example, multiple requests to
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.228.1">
        IncrementCounter
       </span>
      </strong>
      <span class="koboSpan" id="kobo.229.1">
       can lead to an inconsistent state
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.230.1">
        of
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.231.1">
         _counter
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.232.1">
        .
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.233.1">
       The solution to
      </span>
      <a id="_idIndexMarker475">
      </a>
      <span class="koboSpan" id="kobo.234.1">
       this problem is to use a synchronization mechanism to manage the state of a shared value.
      </span>
      <span class="koboSpan" id="kobo.234.2">
       The most common synchronization mechanism is
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.235.1">
        lock
       </span>
      </strong>
      <span class="koboSpan" id="kobo.236.1">
       , which uses an
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.237.1">
        object
       </span>
      </strong>
      <span class="koboSpan" id="kobo.238.1">
       to block execution against a particular value while a thread is accessing it.
      </span>
      <span class="koboSpan" id="kobo.238.2">
       This means
      </span>
      <em class="italic">
       <span class="koboSpan" id="kobo.239.1">
        locking
       </span>
      </em>
      <span class="koboSpan" id="kobo.240.1">
       it from access by other threads, forcing them to wait
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.241.1">
        their turn:
       </span>
      </span>
     </p>
     <pre class="source-code"><span class="koboSpan" id="kobo.242.1">private static int _counter = 0;
private static readonly object _counterLock =
    new object();
public async Task&lt;IActionResult&gt; IncrementCounter()
{
    lock (_counterLock)
    {
        var newCounterValue = _counter + 1;
        _counter = newCounterValue;
    }
    await Task.Delay(100); // Simulate async work
    return Ok(_counter);
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.243.1">
       This example shows the establishment and execution of a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.244.1">
        lock
       </span>
      </strong>
      <span class="koboSpan" id="kobo.245.1">
       to ensure that
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.246.1">
        _counter
       </span>
      </strong>
      <span class="koboSpan" id="kobo.247.1">
       is updated by one thread at a time, eliminating the possibility of race conditions occurring within
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.248.1">
        the API.
       </span>
      </span>
     </p>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.249.1">
     Asynchronous
    </span>
    <a id="_idIndexMarker476">
    </a>
    <span class="koboSpan" id="kobo.250.1">
     programming can add a new layer of complexity to any minimal API project, but we’ve demonstrated in this chapter that with careful attention, it can be a powerful tool in optimizing API efficiency.
    </span>
    <span class="koboSpan" id="kobo.250.2">
     Let’s recap the areas covered in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor173">
    </a>
    <span class="koboSpan" id="kobo.252.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     We opened this chapter with the pizza store analogy.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     We introduced  asynchronous programming by likening it to a takeout food order that you don’t simply wait for, but instead continue your ongoing tasks until the pizza is ready for you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      to collect.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.255.1">
     We then laid the foundations for understanding how asynchronous code can benefit a minimal API, with its optimal use of hardware resources and scope for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      application scalability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     We explored some common asynchronous programming patterns, namely the TAP and deferred execution patterns, with examples of how the use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      async/await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     can make asynchronous code more readable by making it look more like synchronous code.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     We explored how Deferred Execution can make an API asynchronous at the client level, allowing the client to receive an acknowledgment that their request has been received, along with a unique identifier for them to reference, stretching the overall end-to-end execution across multiple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      API requests.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     Finally, we addressed the common challenges asynchronous programming presents, particularly in minimal APIs, with three common examples.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     The first was deadlocks, in which execution can no longer be continued on a global scale due to contention between multiple threads or operations.
    </span>
    <span class="koboSpan" id="kobo.261.3">
     Next was poor resource management, in which the code does not account for the asynchronous context when disposing of connections to external resources.
    </span>
    <span class="koboSpan" id="kobo.261.4">
     Lastly, we looked at  race conditions, the classic example of multiple operations competing to update the state of a shared value or resource, causing inconsistent behavior and the creation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      inaccurate data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.263.1">
     No software developer can easily escape the need to manage asynchronous execution, especially in a .NET minimal API.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     Thus, practicing vigilance, combined with good testing and the profiling techniques learned earlier in the book, can go a long way to making the experience as painless
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.264.1">
      as possible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     Next, we will explore a critical method for optimizing the performance of any minimal API –
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.266.1">
      caching.
     </span>
    </span>
   </p>
  </div>
 </body></html>