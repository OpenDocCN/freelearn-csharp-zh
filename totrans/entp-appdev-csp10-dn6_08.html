<html><head></head><body>
		<div><p><a id="_idTextAnchor471"/><a id="_idTextAnchor472"/></p>
			<h1 id="_idParaDest-114"><em class="italic"><a id="_idTextAnchor473"/>Chapter 6</em>: Configuration in .NET 6</h1>
			<p>A configuration<a id="_idIndexMarker444"/> in .NET 6 comprises the default settings as well as the runtime settings for your application; a configuration is a very powerful feature. We can update settings such as feature flags to enable or disable features, dependent service endpoints, database connection strings, logging levels, and much more, and control application behavior at runtime without recompilation.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding configuration</li>
				<li>Leveraging built-in configuration providers</li>
				<li>Building a custom configuration provider</li>
			</ul>
			<p>By the end of this chapter, you'll have a good grasp of configuration concepts, configuration providers, and how to leverage them in your projects, as well as being able to identify the configurations and configuration sources that are appropriate for your applications.<a id="_idTextAnchor474"/><a id="_idTextAnchor475"/></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor476"/>Technical requirements</h1>
			<p>You will need a basic understanding of.NET and Azure. The code for the chapter can be found here: https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter06.<a id="_idTextAnchor477"/><a id="_idTextAnchor478"/></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor479"/>Understanding configuration</h1>
			<p>A<a id="_idIndexMarker445"/> configurati<a id="_idTextAnchor480"/>on is generally stored<a id="_idIndexMarker446"/> as <code>Program.cs</code>), you will get a default configuration provided by .NET 6. In addition, you can configure different built-in and custom configuration sources, and then read them using different configuration providers whenever you need them anywhere in an application<a id="_idTextAnchor481"/>:</p>
			<div><div><img src="img/Figure_6.1_B18507.jpg" alt="Figure 6.1 – Application and configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Application and configuration</p>
			<p>The preceding<a id="_idIndexMarker447"/> diagram shows a high-level relationship between<a id="_idTextAnchor482"/> <a id="_idIndexMarker448"/>an application, a<a id="_idIndexMarker449"/> configuration provider, <a id="_idTextAnchor483"/>and <a id="_idIndexMarker450"/>a configuration file. The application uses the configur<a id="_idTextAnchor484"/>ation provider to read the configuration from the configuration source; the configuration can be environment-specific. <strong class="bold">Env A</strong> could be your development envir<a id="_idTextAnchor485"/>onment and <strong class="bold">Env B</strong> could be<a id="_idTextAnchor486"/> your production environment. At runtime, the application will read the right configurations based on the runtime context and environment where it's running.</p>
			<p>In the next section, we will see how a default configuration works and how to add and read configurations from the <code>appsettings.json</code> <a id="_idTextAnchor487"/><a id="_idTextAnchor488"/>file.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor489"/>Default configuration</h2>
			<p>To understand how a<a id="_idIndexMarker451"/> default config<a id="_idTextAnchor490"/>uration works, let's create a new .NET 6 <a id="_idIndexMarker452"/>web API, set the project name as <code>TestConfiguration</code>, and open <code>Program.cs</code>. The following is a code snippet from the <code>Program.cs</code> file:</p>
			<pre class="source-code"><strong class="bold">var builder = WebApplication.CreateBuilder(args);</strong></pre>
			<pre class="source-code">// Add services to the container.</pre>
			<pre class="source-code">builder.Services.AddControllers();</pre>
			<pre class="source-code">builder.Services.AddEndpointsApiExplorer();</pre>
			<pre class="source-code">builder.Services.AddSwaggerGen();</pre>
			<pre class="source-code">var app = builder.Build();</pre>
			<pre class="source-code">// Configure the HTTP request pipeline.</pre>
			<pre class="source-code">if (app.Environment.IsDevelopment())</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    app.UseSwagger();</pre>
			<pre class="source-code">    app.UseSwaggerUI();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">app.UseHttpsRedirection();</pre>
			<pre class="source-code">app.UseAuthorization();</pre>
			<pre class="source-code">app.MapControllers();</pre>
			<pre class="source-code">app.Run();</pre>
			<p>From the preceding code, we see that <code>WebApplication.CreateBuilder</code> takes care of providing the default configuration for the application.</p>
			<p>The loading of the <a id="_idIndexMarker453"/>configuration is done in the following <a id="_idIndexMarker454"/>order:</p>
			<ol>
				<li><code>MemoryConfigurationProvider</code>: This loads configurations from in-memory collection as configuration key-value pairs.</li>
				<li><code>ChainedConfigurationProvider</code>: This adds the host configuration and sets it as the first source. For more details on the <a id="_idIndexMarker455"/>host configuration, you can use this link: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0</a>. </li>
				<li><code>JsonConfigurationProvider</code>: This loads the configurations from the <code>appsettings.json</code> file.</li>
				<li><code>JsonConfigurationProvider</code>: This loads the configurations from the <code>appsettings.Environment.json</code> file; <code>Environment</code> in <code>appsettings.Environment.json</code> can be set to refer to development, staging, or production.</li>
				<li><code>EnvironmentVariablesConfigurationProvider</code>: This loads environment variable configurations.</li>
			</ol>
			<p>As mentioned at the beginning of this section, a configuration is specified as key-value pairs in sources. Con<a id="_idTextAnchor491"/>figuration providers that are added later (in terms of order) override previous key-value pair settings. For example, if you have a <code>DbConnectionString</code> key in <code>MemoryConfigurationProvider</code> as well as in <code>JsonConfigurationProvider</code>, the value of the <code>DbConnectionString</code> key in <code>JsonConfigurationProvider</code> will override the key-value pair settings of <code>MemoryConfigurationProvider</code>.</p>
			<p>When you debug the <code>Program.cs</code> code, you can see the default configuration provided by <code>CreateDefaultBuilder</code> being<a id="_idIndexMarker456"/> injected into the configuration <a id="_idTextAnchor492"/>as follows:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_6.2_B18507.jpg" alt="Figure 6.2 – Default configuration sources&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Default configurat<a id="_idTextAnchor493"/>ion sources</p>
			<p>Let's see how <a id="_idIndexMarker457"/>we can add the configurations required for our application in the ne<a id="_idTextAnchor494"/><a id="_idTextAnchor495"/>xt section.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor496"/>Adding configurations</h2>
			<p>As we saw in <a id="_idIndexMarker458"/>the previous s<a id="_idTextAnchor497"/>ection, there are multiple configuration sources available. The <code>appsettings.json</code> file is what is most widely used in real-world projects to add the configuration required for an application unless it's a secret and cannot be stored as plain text.</p>
			<p>Let's take a couple of common scenarios where we need configurations:</p>
			<ul>
				<li>If we need an <code>ApplicationInsights</code> instrumentation key to add application telemetry, which can be part of our configuration</li>
				<li>If we have dependent services that need to be invoked, which can be part of our configuration</li>
			</ul>
			<p>These can change from environment to environment (the values differ between development environments and production environments).</p>
			<p>You can add the <a id="_idIndexMarker459"/>following configurations to the <code>appsettings.json</code> file so that you can update it directly when there is a change and start consuming it without recompilation and deployment:</p>
			<pre class="source-code">"ApplicationInsights": {</pre>
			<pre class="source-code">    <strong class="bold">"InstrumentationKey"</strong>: "&lt;Your instrumentation key&gt;"</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"><strong class="bold">"ApiConfigs"</strong>: {</pre>
			<pre class="source-code">    "Service 1": {</pre>
			<pre class="source-code">      "Name": "&lt;Your dependent service name 1&gt;",</pre>
			<pre class="source-code">      "BaseUri": "&lt;Service base uri&gt;",</pre>
			<pre class="source-code">      "HttpTimeOutInSeconds": "&lt;Time out value in</pre>
			<pre class="source-code">        seconds&gt;",      </pre>
			<pre class="source-code">      "ApiURLs": [</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">          "EndpointName": "&lt;End point 1&gt;"</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">          "EndpointName": "&lt;End point 2&gt;"</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">      ]</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    "Service 2": {</pre>
			<pre class="source-code">      "Name": "&lt;Your dependent service name 2&gt;",</pre>
			<pre class="source-code">      "BaseUri": "&lt;Service base uri&gt;",</pre>
			<pre class="source-code">      "HttpTimeOutInSeconds": "&lt;Time out value in</pre>
			<pre class="source-code">       seconds&gt;",      </pre>
			<pre class="source-code">      "ApiURLs": [</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">          "EndpointName": "&lt;End point 1&gt;"</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">          "EndpointName": "&lt;End point 2&gt;"</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">      ]</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>From the preceding code, we see that we have added a key-value pair for the <code>ApplicationInsights</code> instrumentation key, where the key is the <code>InstrumentationKey</code> string, and the value is the actual instrumentation key that the application needs<a id="_idIndexMarker460"/> to instrument telemetry in <code>ApplicationInsights</code>. In the <code>ApiConfigs</code> section, we have added multiple key-value pairs in hierarchical order with the<a id="_idTextAnchor498"/> configuration required to invoke our dependent services.</p>
			<p>In the next section, we will see how to read the configuration <a id="_idTextAnchor499"/><a id="_idTextAnchor500"/>we have added.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor501"/>Reading configurations</h2>
			<p>We have seen<a id="_idTextAnchor502"/> how <a id="_idIndexMarker461"/>we can add configurations to <code>appsettings.json</code>. In this section, we will see how we can read them inside our projects using the different options that are available.</p>
			<p>The <code>builder.Configuration</code> object that you get in <code>Program.cs</code> provided by <code>WebApplication.CreateBuilder</code> implements the <code>Microsoft.Extensions.Configuration.IConfiguration</code> type, and you have the following options available to read in <code>IConfiguration</code>:</p>
			<pre class="source-code">         // Summary:</pre>
			<pre class="source-code">        //     Gets or sets a configuration value.</pre>
			<pre class="source-code">        // Parameters:</pre>
			<pre class="source-code">        //   key:</pre>
			<pre class="source-code">        //     The configuration key.</pre>
			<pre class="source-code">        // Returns:</pre>
			<pre class="source-code">        //     The configuration value.</pre>
			<pre class="source-code">        <strong class="bold">string this[string key] { get; set; }</strong></pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        // Summary:</pre>
			<pre class="source-code">        //Gets the immediate descendant configuration sub-</pre>
			<pre class="source-code">        //sections.</pre>
			<pre class="source-code">        // Returns:</pre>
			<pre class="source-code">        //     The configuration sub-sections.</pre>
			<pre class="source-code">        <strong class="bold">IEnumerable&lt;IConfigurationSection&gt; GetChildren();</strong></pre>
			<pre class="source-code">                </pre>
			<pre class="source-code">        // Summary:</pre>
			<pre class="source-code">        //     Gets a configuration sub-section with the </pre>
			<pre class="source-code">        //     specified key.</pre>
			<pre class="source-code">        // Parameters:</pre>
			<pre class="source-code">        //   key:</pre>
			<pre class="source-code">        //     The key of the configuration section.</pre>
			<pre class="source-code">        // Returns:</pre>
			<pre class="source-code">        //The Microsoft.Extensions.Configuration</pre>
			<pre class="source-code">        //.IConfigurationSection.</pre>
			<pre class="source-code">        // Remarks:</pre>
			<pre class="source-code">        //     This method will never return null. If </pre>
			<pre class="source-code">         // no matching sub-section is found with</pre>
			<pre class="source-code">        //     the specified key, an empty</pre>
			<pre class="source-code">        //Microsoft.Extensions.Configuration.IConfiguration</pre>
			<pre class="source-code">        //     Section will be returned.</pre>
			<pre class="source-code">        <strong class="bold">IConfigurationSection GetSection(string key);</strong></pre>
			<p>Let's see how<a id="_idIndexMarker462"/> we can leverage these options from <code>Iconfiguration</code> to read the config<a id="_idTextAnchor503"/>urations that we added in the previous section, <em class="italic">Adding configurations</em>.</p>
			<p>To read the <code>ApplicationInsights</code> instrumentation key from <code>appsettings.json</code>, we can use the <code>string this[string key] { get; set; }</code> option using the following code in <code>Program.cs</code>:</p>
			<pre class="source-code">builder.Configuration["ApplicationInsights:InstrumentationKey"];</pre>
			<p>To read <code>ApiConfigs</code>, we can use the following code. We can use a delimiter in the configuration keys for the configuration API to read the hierarchical configuration:</p>
			<pre class="source-code">builder.Configuration["ApiConfigs:Service 1:Name"];</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Reading this way using a delimiter is error-prone and difficult to maintain. The preferred approach is to use the <strong class="bold">options</strong> pattern<a id="_idIndexMarker463"/> provided in ASP.NET Core. Instead of reading each key/setting value one by one, the options pattern uses classes, which will also give you strongly typed access to the relat<a id="_idTextAnchor504"/>ed settings.</p>
			<p>When configuration settings are isolated by scenarios into strongly typed classes, the application adheres to two important design principles:</p>
			<ul>
				<li>The <strong class="bold">interface segregation principle</strong> (<strong class="bold">ISP</strong>),<a id="_idTextAnchor505"/> or <a id="_idIndexMarker464"/>encapsulation principle</li>
				<li>Separation of concerns</li>
			</ul>
			<p>With ISP or encapsulation, you read the configuration through a well-defined interface or contract and depend only on the configuration settings you need. Also, if there is a huge configuration file, this will help in the separation of concerns, as different parts of the application won't be dependent on the same configuration, thus allowing them to be decoupled. Let's see how we can leverage the options pattern in our code.</p>
			<p>You can <a id="_idIndexMarker465"/>create the following <code>ApiConfig</code> and <code>ApiUrl</code> classes and add them to your project:</p>
			<pre class="source-code">public class ApiConfig</pre>
			<pre class="source-code">{      </pre>
			<pre class="source-code">    public string Name { get; set; }</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">    public string BaseUri { get; set; }</pre>
			<pre class="source-code">      </pre>
			<pre class="source-code">    public int HttpTimeOutInSeconds { get; set; }</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">    public List&lt;ApiUrl&gt; ApiUrls { get; set; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class ApiUrl</pre>
			<pre class="source-code">{        </pre>
			<pre class="source-code">    public string EndpointName { get; set; }      </pre>
			<pre class="source-code">}</pre>
			<p>Add the following code in <code>Program.cs</code> to read the configuration using the <code>GetSection</code> method, and then call <code>Bind</code> to have the configuration bound to the strongly-typed class that we have:</p>
			<pre class="source-code">List&lt;ApiConfig&gt; apiConfigs = new List&lt;ApiConfig&gt;();</pre>
			<pre class="source-code"><strong class="bold">builder.Configuration.GetSection("ApiConfigs").Bind(apiConfig<a id="_idTextAnchor506"/>s);</strong></pre>
			<p><code>GetSection</code> will read the specific section from <code>appsettings.json</code> with the specified key. <code>Bind</code> will attempt to bind the given object instance to the configuration values by matching property names to the configuration keys. <code>GetSection(string sectionName)</code> will return <code>null</code> if the requested section does not exist. In real-world programs, please ensure that you add null checks.</p>
			<p>In this section, we <a id="_idIndexMarker466"/>saw how we can add and read data from <code>appsettings.json</code> by using a configuration API. I also mentioned that we should use <code>appsettings.json</code> for plain text and not for secrets. In the next section, we will look at built-in configuration providers as well as how to add and read secrets using the Azure Key Vault con<a id="_idTextAnchor507"/><a id="_idTextAnchor508"/>figuration provider.</p>
			<h1 id="_idParaDest-120">Leveraging built-in configuration provide<a id="_idTextAnchor509"/>rs</h1>
			<p>There are multiple <a id="_idIndexMarker467"/>configuration sources available other than <code>appsettings.json</code>, and .NET 6 provides several built-in configuration providers to read from them. The following are built-in providers available for .NET 6:</p>
			<ul>
				<li>The Azure Key Vault configuration provider<a id="_idIndexMarker468"/> reads configurations from Azure Key Vault.</li>
				<li>The file configuration provider<a id="_idIndexMarker469"/> reads configurations from INI, JSON, and XML files.</li>
				<li>The command-line configuration provider<a id="_idIndexMarker470"/> reads configuration from command-line parameters.</li>
				<li>The environment variable configuration provider<a id="_idIndexMarker471"/> reads configurations from environment variables.</li>
				<li>The memory configuration provider<a id="_idIndexMarker472"/> reads configurations from in-memory <a id="_idTextAnchor510"/>collections.</li>
				<li>The Azure App Configuration provider<a id="_idIndexMarker473"/> reads configuration from Azure App configuration.</li>
				<li>The key-per-file configuration provider<a id="_idIndexMarker474"/> reads configurations from a directory's files.</li>
			</ul>
			<p>Let's see how we can<a id="_idIndexMarker475"/> leverage the Azure Key Vault configuration provider and the file configuration provider, as both are important and more widely used when compared to others. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can use the following link to learn about<a id="_idTextAnchor511"/> other configuration providers<a id="_idIndexMarker476"/> that we are not covering in detail here: https://docs.microsoft.com/en-us/dotnet/core/exten<a id="_idTextAnchor512"/><a id="_idTextAnchor513"/>sions/configuration-providers.</p>
			<h2 id="_idParaDest-121">Azure Key Vault configuration<a id="_idTextAnchor514"/> provider</h2>
			<p>Azure Key Vault is a <a id="_idIndexMarker477"/>clo<a id="_idTextAnchor515"/>ud-based service that provides a centralized configuration source for securely storing passwords, certificates, API keys, and other secrets. This helps to keep our application secured and compliant from a security breach. Let's see how we can create a key vault, add a secret to it, and access it from an application using the Azure Key Vault configuration provider.</p>
			<h3>Creating a key vault and adding secrets</h3>
			<p>In this section, we<a id="_idIndexMarker478"/> will use Azure <a id="_idTextAnchor516"/>Cloud Shell to create a key vault and add a secret. Azure Cloud Shell is browser-based and can be used to manage Azure resources. The following is the list of steps you need to take:</p>
			<ol>
				<li value="1">Sign in to the Azure portal using <a href="https://portal.azure.com">https://portal.azure.com</a>. Select the Cloud<a id="_idTextAnchor517"/> Shell icon on the portal page:</li>
			</ol>
			<div><div><img src="img/Figure_6.3_B18507.jpg" alt="Figure 6.3 – Azure Cloud Shell&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Azure Cloud Shell</p>
			<ol>
				<li value="2">You will get the option to select <strong class="bold">Bash</strong> or <strong class="bold">PowerShell</strong>. Choose <strong class="bold">PowerShell</strong>. You <a id="_idTextAnchor518"/>can change shells at any time:</li>
			</ol>
			<div><div><img src="img/Figure_6.4_B18507.jpg" alt="Figure 6.4 – Azure Cloud Shell options – PowerShell and Bash&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Azure Cloud Shell options – PowerShell and Bash</p>
			<ol>
				<li value="3">Create a<a id="_idIndexMarker479"/> resource group with the following command:<pre>az group create --name "{RESOURCE GROUP NAME}" --location {LOCATION}</pre></li>
			</ol>
			<p>The actual command I ran for this demonstration is this:</p>
			<pre>az group create --name "ConfigurationDemoVaultRG" --location "East US"</pre>
			<p><code>{RESOURCE GROUP NAME}</code> stands for the resource group name for the new resource group, and <code>{LOCATION}</code> stands for the Azure region (for your data center).</p>
			<ol>
				<li value="4">Create a key vault in the resource group with the following command:<pre>az keyvault create --name {KEY VAULT NAME} --resource-group "{RESOURCE GROUP NAME}" --location {LOCATION}</pre></li>
			</ol>
			<p>Here's the actual command I ran for this demonstration:</p>
			<pre>az keyvault create --name "TestKeyVaultForConfig" --resource-group "ConfigurationDemoVaultRG" --location "East US"</pre>
			<p><code>{KEY VAULT NAME}</code> is the unique name for the new key vault.</p>
			<p><code>{RESOURCE GROUP NAME}</code> is the resource group name for the new resource group created in the prior step.</p>
			<p><code>{LOCATION}</code> is the Azu<a id="_idTextAnchor519"/>re region (data center).</p>
			<ol>
				<li value="5">Create secrets in t<a id="_idTextAnchor520"/>he key vault as name-value pairs with the following command:<pre>az keyvault secret set --vault-name {KEY VAULT NAME} --name "SecretName" --value "SecretValue"</pre></li>
			</ol>
			<p>Here's the actual command I ran for this demonstration:</p>
			<pre>az keyvault secret set --vault-name "TestKeyVaultForConfig" --name "TestKey" --value "TestValue"</pre>
			<p><code>{KEY VAULT NAME}</code> is the same key vault name that you created in the prior step.</p>
			<p><code>SecretName</code> is the name of your secret.</p>
			<p><code>SecretValue</code> is the value of your secret.</p>
			<p>We have now<a id="_idIndexMarker480"/> successfully created a key vault named <code>TestKeyVaultForConfig</code> and have added a secret with the key as <code>TestKey</code> and the value <a id="_idIndexMarker481"/>as <code>T<a id="_idTextAnchor521"/>estValue</code> using Azure Cloud Shell:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_6.5_B18507.jpg" alt="Figure 6.5 – Azure Key Vault secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Azure Key Vault secrets</p>
			<p>You can also use the Azure <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) to create and manage Azure resou<a id="_idTextAnchor522"/>rces. You can read more about the Azure CLI<a id="_idIndexMarker482"/> here: https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest.</p>
			<p>In the next section, we will see how to give our application access to Key Vault.</p>
			<h3>Granting application access to Key Vault</h3>
			<p>In th<a id="_idTextAnchor523"/>is section, let's<a id="_idIndexMarker483"/> see how our<a id="_idTextAnchor524"/> <code>TestConfiguration</code> web API can get access to Key Vault using the following steps:</p>
			<ol>
				<li value="1">Register <a id="_idIndexMarker484"/>the <code>TestConfiguration</code> application in <strong class="bold">Azure Active Directory</strong> (<strong class="bold">AAD</strong>) and <a id="_idIndexMarker485"/>create an identity. Sign in to the Azure portal using https://portal.azure.com.</li>
				<li>Navigate to <strong class="bold">Azure Active Directory</strong> | <strong class="bold">App Regist<a id="_idTextAnchor525"/>rations</strong>. Click on <strong class="bold">New registration</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_6.6_B18507.jpg" alt="Figure 6.6 – AAD new application registration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – AAD new a<a id="_idTextAnchor526"/>pplication registration</p>
			<ol>
				<li value="3">Fill in the<a id="_idTextAnchor527"/> defaults and click on <strong class="bold">Register</strong>, as shown in the following screenshot, and note down the <strong class="bold">Application (client) ID</strong> value. This will be r<a id="_idTextAnchor528"/>equired later to access Key Vault:</li>
			</ol>
			<div><div><img src="img/Figure_6.7_B18507.jpg" alt="Figure 6.7 – AAD registration completion&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – AAD registration completion</p>
			<ol>
				<li value="4">Click <a id="_idIndexMarker486"/>on <strong class="bold">Certificates &amp; secrets</strong> (<strong class="bold">1</strong>) | <strong class="bold">New client secret</strong> (<strong class="bold">2</strong>) and enter a <strong class="bold">Description</strong> (<strong class="bold">3</strong>) value, then click on <strong class="bold">Add</strong> (<strong class="bold">4</strong>), as shown in the following screenshot. Note down the <strong class="bold">AppClientSecret</strong> value sh<a id="_idTextAnchor529"/>owing under <strong class="bold">New client secret</strong>, which<a id="_idTextAnchor530"/> is what the application can use to prove its<a id="_idTextAnchor531"/> identity when requesting a token:</li>
			</ol>
			<div><div><img src="img/Figure_6.8_B18507.jpg" alt="Figure 6.8 – AAD new application secret creation for its identity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – AAD new application secret creation for its identity</p>
			<ol>
				<li value="5">Give the<a id="_idIndexMarker487"/> application access to Key Vault using an access policy. Search for the key vau<a id="_idTextAnchor532"/>lt you just created and select it:</li>
			</ol>
			<div><div><img src="img/Figure_6.9_B18507.jpg" alt="Figure 6.9 – Key vault search&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure<a id="_idTextAnchor533"/> 6.9 – Key vault search</p>
			<ol>
				<li value="6">In the key vault properties, select<a id="_idTextAnchor534"/> <strong class="bold">Access policies</strong> under <strong class="bold">Settin<a id="_idTextAnchor535"/>gs</strong> and click on <strong class="bold">Add Access Policy</strong>:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_6.10_B18507.jpg" alt="Figure 6.10 – Key Vault access policies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Key Vault access policies</p>
			<ol>
				<li value="7">In the <strong class="bold">Select principal</strong> field, search for your application and select the required <a id="_idIndexMarker488"/>permissions for your application to acc<a id="_idTextAnchor536"/>ess Key Vault, then click on <strong class="bold">Add</strong>:</li>
			</ol>
			<div><div><img src="img/Figure_6.11_B18507.jpg" alt="Figure 6.11 – Add access policy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Fig<a id="_idTextAnchor537"/>ure 6.11 – Add access policy</p>
			<ol>
				<li value="8">After<a id="_idIndexMarker489"/> adding <a id="_idTextAnchor538"/>the policy, you must save it. This will complete the process of granting your application access to Key Vault.</li>
			</ol>
			<p>We have now given our application access to Key Vault. In the next section, we will see how to access Key Vault from our application using the Azure Key Vault configuration provider.</p>
			<h3>Leveraging the Azure Key Vault configuration<a id="_idTextAnchor539"/> provider</h3>
			<p>In this section, we<a id="_idIndexMarker490"/> will make configuration and code changes in our application to leverage the Azure Key Vault configuration provider and access s<a id="_idTextAnchor540"/>ecrets from Key Vault, as follows:</p>
			<div><div><img src="img/Figure_6.12_B18507.jpg" alt="Figure 6.12 – Accessing Key Vault during development&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Accessin<a id="_idTextAnchor541"/>g Key Vault during development</p>
			<p>The following is the <a id="_idIndexMarker491"/>list of changes:</p>
			<ol>
				<li value="1">Add the key vault name, the <code>AppClientId</code> value that you noted down from <em class="italic">Figure 6.7</em>, and the <code>AppClientSecret</code> value that you noted down from AAD from <em class="italic">Figure 6.8</em> to the <code>appsettings.json</code> file <a id="_idTextAnchor542"/>in your <code>TestConfiguration</code> web API:</li>
			</ol>
			<div><div><img src="img/Figure_6.13_B18507.jpg" alt="Figure 6.13 – Key Vault section in appsettings.json&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Key Vault section in appsettings.json</p>
			<ol>
				<li value="2">Install the following NuGet packages:<ul><li><code>Microsoft.Azure.KeyVault</code></li><li><code>Microsoft.Extensions.Configuration.AzureKeyVault</code></li><li><code>Microsoft.Azure.Services.AppAuthentication</code></li></ul></li>
				<li>Update <code>Program.cs</code> to leverage the Azure Key Vault configuration provider to use your key <a id="_idIndexMarker492"/>vault. The following code will add Azur<a id="_idTextAnchor543"/>e Key Vault as another configuration source and get all configurations using the Azure Key Vault configuration provider:<pre>using TestConfiguration;
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
//Removed code for brevity
<strong class="bold">builder.Configuration.AddAzureKeyVault($"https://{builder.Configuration["KeyVault:Name"]}.vault.azure.net/",</strong>
<strong class="bold">builder.Configuration["KeyVault:AppClientId"],</strong>
<strong class="bold">builder.Configuration["KeyVault:AppClientSecret"]);</strong>
var app = builder.Build();
//Removed code for brevity </pre></li>
				<li>Update <code>WeatherForecastController.cs</code> t<a id="_idTextAnchor544"/>o read the secret from Key Vault, as<a id="_idIndexMarker493"/> follows:<pre>[ApiController]
[Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
    private readonly ILogger&lt;WeatherForecastController&gt; _logger;
    <strong class="bold">private readonly IConfiguration _configuration;</strong>
    public WeatherForecastController(ILogger&lt;Weather
ForecastController&gt; logger, <strong class="bold">IConfiguration configuration</strong>)
    {
        _logger = logger;
        <strong class="bold">_configuration = configuration;</strong>
    }  
    [HttpGet]
    public IEnumerable&lt;string&gt; Get()
    {
        <strong class="bold">return new string[] { "TestKey", </strong>
<strong class="bold">         _configuration["TestKey"] };</strong>
    }      
}</pre></li>
			</ol>
			<p>Include all references<a id="_idIndexMarker494"/> as per the code sample shared here. You can run the application and see the results: </p>
			<div><div><img src="img/Figure_6.14_B18507.jpg" alt="Figure 6.14 – Results from Key Vault&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – Results from Key Vault</p>
			<p>The application <a id="_idIndexMarker495"/>will be able to access the key vault using the Azure Key Vault configuration provider and fetch the secrets. It is very simple, as all the heavy lifting is done by .NET 6, and we just need to install the NuGet packages and add a few lines of code. However, you will now probably be thinking about how <code>AppClientId</code> and <code>AppClientSecret</code> have been added to the <code>appsettings.json</code> <a id="_idTextAnchor545"/>config file and about how this is not very secure. You are 100% correct.</p>
			<p>We can fix this in two ways:</p>
			<ul>
				<li>One option is to encrypt and store these values in <code>appsettings.json</code>; they can then be read and decrypted in the code.<p class="callout-heading">Reference</p><p class="callout">For safe storage of app secrets in development, please refer to https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&amp;tabs=windows.</p></li>
				<li>The other option is to use managed identities to access Azure resources, which allows the application to authenticate with Azure Key Vault using AAD authentication without credentials (the application ID and password/client secret).</li>
			</ul>
			<p>Your application can be<a id="_idIndexMarker496"/> authenticated using its identity by any service that supports AAD authentication, such as Azure Key Vault, and this will help us in <a id="_idTextAnchor546"/>getting rid of credentials from code:</p>
			<div><div><img src="img/Figure_6.15_B18507.jpg" alt="Figure 6.15 – Accessing Key Vault in production after deploying an application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Accessing Key Vault in production after deploying an application</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is the best practice we follow for applications that are deployed to production. Managing credentials in code is a common challenge and keeping credentials safe and secure is an important security requirement. Managed identities for Azure resources in AAD help in solving this challenge. Managed identities provide Azure services with an automatically managed identity in AAD. You can use this identity to authenticate any service that supports AAD authentication, including Key Vault, without any credentials in your code.</p>
			<p>You <a id="_idTextAnchor547"/>can read more about managed identities<a id="_idIndexMarker497"/> here: https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-<a id="_idTextAnchor548"/>resources/overview.</p>
			<p>In this section, we<a id="_idIndexMarker498"/> saw how to create a key vault, how to add secrets to Key Vault, how to register our <code>TestConfiguration</code> web API in AAD, how to create a secret or identity, how to give the <code>TestConfiguration</code> web API access to Key Vault, and how to access Key Vault from our code using the Azure Key Vault configuration provider. You can also add Key Vault to your web application by using Visual Studio Connected Services, as described at https://docs.microsoft.com/en-us/azure/key-vault/gener<a id="_idTextAnchor549"/>al/vs-key-vault-add-connected-service:</p>
			<div><div><img src="img/Figure_6.16_B18507.jpg" alt="Figure 6.16 – Azure Key Vault as a connected service&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Azure Key Vault as a connected service</p>
			<p>In the next section, we will see how we can lev<a id="_idTextAnchor550"/><a id="_idTextAnchor551"/>erage the file configuration provider.</p>
			<h2 id="_idParaDest-122">File config<a id="_idTextAnchor552"/>uration provider</h2>
			<p>The file configuration provider<a id="_idIndexMarker499"/> he<a id="_idTextAnchor553"/>lps us to load a configuration from the filesystem. The JSON configuration provider and XML configuration provider derive their inheritance from the file configuration provider class and are used to read key-value pair configurations from JSON files and XML files, respectively. Let's see how we can add them to configuration sources as part of <code>CreateHostB<a id="_idTextAnchor554"/>uilder</code>.</p>
			<h3>JSON configuration <a id="_idTextAnchor555"/>provider</h3>
			<p>The JSON configuration provider<a id="_idIndexMarker500"/> can be configured using the following code in <code>Program.cs</code>:</p>
			<pre class="source-code">//Removed code for brevity</pre>
			<pre class="source-code"><strong class="bold">builder.Configuration.AddJsonFile("AdditionalConfig.json",</strong></pre>
			<pre class="source-code"><strong class="bold">                optional: true,</strong></pre>
			<pre class="source-code"><strong class="bold">                reloadOnChange: true);</strong> </pre>
			<pre class="source-code">//Removed code for<a id="_idTextAnchor556"/> brevity               </pre>
			<p>In this case, the JSON configuration provider will load the <code>AdditionalConfig.json</code> file, and th<a id="_idTextAnchor557"/>ree parameters to the <code>AddJsonFile</code> method provide us with options to specify the filename, whether the file is optional, and whether the file must be reloaded when any changes are made to the file.</p>
			<p>The following is the <code>AdditionalConfig.json</code> sample file:</p>
			<pre class="source-code">{  "TestKeyFromAdditionalConfigJSON":"TestValueFromAdditional ConfigJSON"}</pre>
			<p>Then, we update <code>WeatherForecastController.cs</code> to rea<a id="_idTextAnchor558"/>d key-value pairs from the configurations loa<a id="_idTextAnchor559"/>ded from the <code>AdditionalConfig.json</code> config file, as follows:</p>
			<pre class="source-code">//Removed code for brevity  </pre>
			<pre class="source-code">    [HttpGet]</pre>
			<pre class="source-code">    public Ienumerable&lt;string&gt; Get()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        <strong class="bold">return new string[] { </strong></pre>
			<pre class="source-code"><strong class="bold">          " TestKeyFromAdditionalConfigJSON", </strong></pre>
			<pre class="source-code"><strong class="bold">          _configuration["TestKeyFromAdditionalConfigJSON"] };</strong></pre>
			<pre class="source-code">    }      </pre>
			<pre class="source-code">/<a id="_idTextAnchor560"/>/Removed code for brevity</pre>
			<p>You can run the <a id="_idIndexMarker501"/>application an<a id="_idTextAnchor561"/>d see the results. The application will be able to access the <code>AdditionalConfig.json</code> file and read the configuration. In the next section, we will look at the XML configuration provider.</p>
			<h3>XML configu<a id="_idTextAnchor562"/>ration provider</h3>
			<p>We will add a new <a id="_idIndexMarker502"/>file to the project with the name <code>AdditionalXMLConfig.xml</code> and the required configur<a id="_idTextAnchor563"/>ations. The XML configuration provider can then be configured using the following code in <code>Program.cs</code> to read from the file we added:</p>
			<pre class="source-code">//Removed code for brevity</pre>
			<pre class="source-code"><strong class="bold">builder.Configuration.AddXmlFile("AdditionalXMLConfig.xml",</strong></pre>
			<pre class="source-code"><strong class="bold">                optional: true,</strong></pre>
			<pre class="source-code"><strong class="bold">                reloadOnChange: true);</strong></pre>
			<pre class="source-code">//Removed code for brevity</pre>
			<p>In this case, the XML configuration provider will load the <code>AdditionalXMLConfig.xml</code> file and the three parameters provide us with options to specify the XML file, whether the file is optional or not, and whether the file must be reloaded when any changes are made.</p>
			<p>The <code>AdditionalXMLConfig.xml</code> sample file is as follows:</p>
			<pre class="source-code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</pre>
			<pre class="source-code">&lt;configuration&gt;</pre>
			<pre class="source-code">  &lt;TestKeyFromAdditionalXMLConfig&gt;TestValueFrom</pre>
			<pre class="source-code">AdditionalXMLConfig&lt;/TestKeyFromAdditionalXMLConfig&gt;</pre>
			<pre class="source-code">&lt;/configuration&gt;</pre>
			<p>Next, we update <code>WeatherForecastController.cs</code> to read key-value pairs from the configuration loaded from <code>AdditionalXMLConfig.xml</code> as follows:</p>
			<pre class="source-code">   [HttpGet]</pre>
			<pre class="source-code">    public Ienumerable&lt;string&gt; Get()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        <strong class="bold">return new string[] { </strong></pre>
			<pre class="source-code"><strong class="bold">          "TestKeyFromAdditionalXMLConfig", </strong></pre>
			<pre class="source-code"><strong class="bold">          _configuration["TestKeyFromAdditiona<a id="_idTextAnchor564"/>lXMLConfig"] };</strong></pre>
			<pre class="source-code">    }      </pre>
			<p>You can run the<a id="_idIndexMarker503"/> appli<a id="_idTextAnchor565"/>cation and see the results. The application will be able to access <code>AdditionalXMLConfig.xml</code> and read the configuration. With the JSON config file and the JSON configuration provider available in .NET 6, you don't need the XML config file and the XML configuration provider. That said, what we just covered is for folks who like XML files and open and close tags, for example.</p>
			<p>In the next section, we will see why a custom configuration<a id="_idTextAnchor566"/><a id="_idTextAnchor567"/> provider is required and how to build one.</p>
			<h1 id="_idParaDest-123">Building a custom config<a id="_idTextAnchor568"/>uration provider</h1>
			<p>In the previous <a id="_idIndexMarker504"/>section, we looked at built-in or pre-existing configuration providers in .NET 6. There are scenarios where many systems maintain application configuration settings in a database. These could be managed by the admin from the portal or by the support engineer by running database scripts to create/update/delete application configuration settings as needed. </p>
			<p>.NET 6 doesn't<a id="_idIndexMarker505"/> come with a built-in provider to read configurations from a database.<a id="_idTextAnchor569"/> Let's see how to build a custom configuration provider to read from a database with the following steps:</p>
			<ul>
				<li><strong class="bold">Implement configuration source</strong>: To create an instance of the configuration provider</li>
				<li><strong class="bold">Implement configuration provider</strong>: To load the configuration from the appropriate source</li>
				<li><strong class="bold">Implement configuration extension</strong>: To add the configuration source to the configuration build<a id="_idTextAnchor570"/><a id="_idTextAnchor571"/>er</li>
			</ul>
			<p>Let's begin with the configuration source.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor572"/>Configuration source</h2>
			<p><a id="_idTextAnchor573"/>The responsibility of the configuration source<a id="_idIndexMarker506"/> is to create an instance of the configuration provider and return it to the source. It needs to inherit from the <code>IConfigurationSource</code> interface, which requires us to implement the <code>ConfigurationProvider Build(IConfigurationBuilder builder)</code> method.</p>
			<p>Inside the <code>Build</code> method implementation, we need to create an instance of the custom configuration provider and return the same. There should also be the parameters needed to build the builder. In this case, as we are building a custom SQL configuration provider, the important parameters are the connection string and the SQL query. The following code snippet shows an example implementation of a <code>SqlConfigurationSource</code> class:</p>
			<pre class="source-code">public class SqlConfigurationSource : IConfigurationSource</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        public string ConnectionString { get; set; }</pre>
			<pre class="source-code">        public string Query { get; set; }</pre>
			<pre class="source-code">        public SqlConfigurationSource(string</pre>
			<pre class="source-code">          connectionString, string query)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            ConnectionString = connectionString;</pre>
			<pre class="source-code">            Query = query;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        public IConfigurationProvider</pre>
			<pre class="source-code">         Build(IConfigurationBuilder builder)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            return new SqlConfigurati<a id="_idTextAnchor574"/>onProvider(this);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }  </pre>
			<p>It is very<a id="_idIndexMarker507"/> simple and easy to implement this, as you can see. You get the parameters required to build the provider and create a new instance of the provider, then return the parameters. Let's see how we can build a <a id="_idTextAnchor575"/><a id="_idTextAnchor576"/>SQL configuration provider in the next section.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor577"/>Configuration provider</h2>
			<p><a id="_idTextAnchor578"/>The responsibility of the configuration provider<a id="_idIndexMarker508"/> is to load the required configuration from the appropriate source and return the same. It needs to inherit from the <code>IConfigurationProvider</code> interface, which requires us to implement the <code>Load()</code> method. The configuration provider class can instead inherit from the <code>ConfigurationProvider</code> base class as it has already implemented all the methods in the <code>IConfigurationProvider</code> interface. This will help us save time as we don't need to implement unused methods and can, instead, implement just the <code>Load</code> method.</p>
			<p>Inside the <code>Load</code> method implementation, we need to have the logic to fetch the configuration data from the source. In this case, we will execute a query to fetch the data from the SQL <a id="_idIndexMarker509"/>store. The following code snippet shows an example implementation of a <code>SqlConfigurationProvider</code> class:</p>
			<pre class="source-code">public class SqlConfigurationProvider : ConfigurationProvider</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        public SqlConfigurationSource Source { get; }</pre>
			<pre class="source-code">        public SqlConfigurationProvider</pre>
			<pre class="source-code">         (SqlConfigurationSource source)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            Source = source;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        public override void Load()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            try</pre>
			<pre class="source-code">            {    </pre>
			<pre class="source-code">                // create a connection object  </pre>
			<pre class="source-code">                SqlConnection sqlConnection = new</pre>
			<pre class="source-code">                 SqlConnection(Source.ConnectionString);</pre>
			<pre class="source-code">                // Create a command object  </pre>
			<pre class="source-code">                SqlCommand sqlCommand = new</pre>
			<pre class="source-code">                 SqlCommand(Source.Query, sqlConnection);</pre>
			<pre class="source-code">                sqlConnection.Open();</pre>
			<pre class="source-code">                // Call ExecuteReader to return a </pre>
			<pre class="source-code">                // DataReader  </pre>
			<pre class="source-code">                SqlDataReader salDataReader =</pre>
			<pre class="source-code">                 sqlCommand.ExecuteReader();</pre>
			<pre class="source-code">                while (salDataReader.Read())</pre>
			<pre class="source-code">                {</pre>
			<pre class="source-code">                    Data.Add(salDataReader.GetString(0),</pre>
			<pre class="source-code">                     salDataReader.GetString(1));</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">                salDataReader.Close();</pre>
			<pre class="source-code">                sqlCommand.Dispose();</pre>
			<pre class="source-code">                sqlConnection.Close();</pre>
			<pre class="source-code">            }            </pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<p>Let's see how to bui<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/>ld a configuration extension in the n<a id="_idTextAnchor581"/>ext section.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor582"/>Configuration extension</h2>
			<p>As with other<a id="_idIndexMarker510"/> providers, we can use an extension method to add the configuration source to the configuration builder.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Extension methods are static methods in which you can add methods to existing classes without modifying or recompiling the original class.</p>
			<p>The following code snippet shows an example implementation of a <code>SqlConfigurationExtensions</code> class in the configuration builder:</p>
			<pre class="source-code">public static class SqlConfigurationExtensions</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        public static IConfigurationBuilder</pre>
			<pre class="source-code">         AddSql(this IConfigurationBuilder</pre>
			<pre class="source-code">         configuration, string connectionString,</pre>
			<pre class="source-code">         string query)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            configuration.Add(new</pre>
			<pre class="source-code">             SqlConfigurationSource(connectionString,</pre>
			<pre class="source-code">             query));</pre>
			<pre class="source-code">            return configuration;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<p>The extension method will red<a id="_idTextAnchor583"/>uce the code in our application startup.</p>
			<p>We can add <a id="_idIndexMarker511"/>bootstrapping code to <code>Program.cs</code> just as we added it for other configuration providers, as shown in the following code:</p>
			<pre class="source-code"><strong class="bold">builder.Configuration.AddSql("Connectionstring","Query");</strong> </pre>
			<p>The following screenshot shows some sample configuration settings in a database. You can pass the appropriate connection string and SQL query in <code>config.AddSql()</code> and load the following configuration from the database<a id="_idTextAnchor584"/>. The SQL query may be a simple <code>select</code> statement to read all key-<a id="_idTextAnchor585"/>value pairs, as it is in the following screenshot:</p>
			<div><div><img src="img/Figure_6.17_B18507.jpg" alt="Figure 6.17 – Database configuration settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – Database configuration settings</p>
			<p>Update <code>WeatherForecastController.cs</code> as follows to read key-value pairs from the configuration loaded from the SQL configuration provider:</p>
			<pre class="source-code">    [HttpGet]</pre>
			<pre class="source-code">    public IEnumerable&lt;string&gt; Get()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        <strong class="bold">return new string[] { "TestSqlKey", </strong></pre>
			<pre class="source-code"><strong class="bold">         _configurat<a id="_idTextAnchor586"/>ion["TestSqlKey"] };</strong></pre>
			<pre class="source-code">    }      </pre>
			<pre class="source-code">}</pre>
			<p>You can run the application and see the results. The application will be able to access the SQL configuration and read the configuration.</p>
			<p>This is an <a id="_idIndexMarker512"/>example of just one custom configuration provider. You may be able to think of different scenarios where you would build other different custom configuration providers, such as when reading from CSV files or reading encrypted<a id="_idTextAnchor587"/><a id="_idTextAnchor588"/> values from JSON or XML files and decrypting them.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor589"/>Summary</h1>
			<p>In this chapter, we saw how configuration works in .NET 6, how the default configuration is provided to the application, how to add key-value pair configurations in a hierarchical order, how to read a configuration, how to leverage the Azure Key Vault configuration provider and the file configuration provider, and how to build a custom configuration provider to read from a SQL database. You now have the knowledge that's needed to implement different configurations in your project depending on the specific needs.</p>
			<p>In the next chapter, we w<a id="_idTextAnchor590"/><a id="_idTextAnchor591"/>ill learn about logging and how it works in .NET 6.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor592"/>Questions</h1>
			<p>After reading this chapter, you should be able to answer the following questions:</p>
			<ol>
				<li value="1">What takes care of providing the default configuration for an application in .NET 6?</li>
			</ol>
			<p>a. <code>CreateDefaultBuilder</code></p>
			<p>b. <code>ChainedConfigurationProvider</code></p>
			<p>c. <code>JsonConfigurationProvider</code></p>
			<p>d. All of the above</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="2">Which of the following is not correct?</li>
			</ol>
			<p>a. The Azure Key Vault configuration provider reads configurations from Azure Key Vault.</p>
			<p>b. The file configuration provider reads configurations from INI, JSON, and XML files.</p>
			<p>c. The command-line configuration provider reads configurations from a database.</p>
			<p>d. The memory configuration provider reads configurations from in-memory collections.</p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="3">Which interface is used to access a configuration at runtime and is injected via dependency injection?</li>
			</ol>
			<p>a. <code>IConfig</code></p>
			<p>b. <code>IConfiguration</code></p>
			<p>c. <code>IConfigurationSource</code></p>
			<p>d. <code>IConfigurationProvider</code></p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="4">Which provider/source is recommended for storing secrets in production?</li>
			</ol>
			<p>a. JSON from <code>appsettings.json</code></p>
			<p>b. <code>FileConfiguration</code> from an XML file</p>
			<p>c. <code>AzureKeyVaultProvider</code> from <code>AzureKeyVault</code></p>
			<p>d. The comman<a id="_idTextAnchor593"/><a id="_idTextAnchor594"/>d-line configuration provider from the command line</p>
			<p><strong class="bold">Answer: c</strong></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor595"/>Further reading</h1>
			<ul>
				<li>https://docs.microsoft.com/en-us/aspnet/core/blazor/fundamentals/configuration?view=aspnetcore-6.0</li>
				<li>https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-6.0</li>
			</ul>
		</div>
	</body></html>