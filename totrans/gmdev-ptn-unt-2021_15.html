<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Implementing a Level Editor with Spatial Partition
                </header>
            
            <article>
                
<p><span>In this chapter, we will explore the concept of spatial partitioning. Unlike in previous chapters, the main subject is not traditionally defined as a software design pattern but more as a process and a technique. But because it offers us a reusable and structured approach to solving recurrent game-programming problems, we will treat it as a design pattern in the context of this chapter.</span></p>
<p><span>The approach we are going to take in this chapter is different from previous chapters for the following specific reasons:</span></p>
<ul>
<li><span>We are taking a hands-off approach; in other words, we will not attempt to implement a code example but will instead review some code segments. </span></li>
<li><span>We will not try to stay faithful to any academic definition but will instead use the general concept of spatial partitioning to build a level editor for our racing game.</span></li>
</ul>
<p><span>The simplest definition of spatial partitioning is a process that offers an efficient way of locating objects by collating them in a data structure ordered by their positions. The level editor we are implementing in this chapter will be built with a stack data structure, and the type of object we will keep in a specific order on a stack is a race track segment. These individual segments of the race track will be spawned or deleted in a particular order, depending on their relation to the player's position on the map.</span></p>
<p><span>All of this might sound very abstract, but it's pretty easy to achieve this with the Unity <strong>application programming interface</strong> (<strong>API</strong>), as we will see in this chapter.</span></p>
<div class="packt_infobox">The system we are implementing in this chapter is too elaborate to boil down into a skeleton code example. So, unlike in previous chapters, the code presented is not meant to be reproduced or used as a template. We instead recommend reviewing a complete code example of the level editor in the <kbd>/FPP</kbd> folder of the Git project. The link can be found in the <em>Technical requirements</em> section of this chapter.</div>
<p>In this chapter, we will cover the following topics: </p>
<ul>
<li>Understanding the Spatial Partition pattern</li>
<li>Designing a level editor</li>
<li>Implementing a level editor</li>
<li>Reviewing alternative solutions</li>
</ul>
<h1 id="uuid-4bcb66b3-a4ca-48f8-b4e2-ca35ae17b394">Technical requirements</h1>
<p>We will also be using the following specific Unity engine API features:</p>
<ul>
<li>Stack</li>
<li>ScriptableObjects</li>
</ul>
<p><span>I</span><span>f unfamiliar with these concepts, please review</span> <a href="c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml">Chapter 3</a><span>, </span><em>A Short Primer to Programming in Unity</em><span>.</span></p>
<p>The code files of this chapter can be found on<span> </span>GitHub at the following link: <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter13</a>.</p>
<div class="packt_infobox"><span>A Stack is a linear data structure with two primary operations: </span><strong><span>Push</span></strong><span>,</span><strong><span> </span></strong><span>which adds an element on top of the stack, and </span><strong><span>Pop</span></strong><span>,</span><strong><span> </span></strong><span>which removes</span><strong><span> </span></strong><span>the most recent element from the top.</span></div>
<h1 id="uuid-c14625a0-fffe-4ed2-b11a-4765f44007ef">Understanding the Spatial Partition pattern</h1>
<p class="mce-root">The Spatial Partition pattern name comes from the process known as space partitioning, which plays an integral part in computer graphics and is often used in ray-tracing rendering implementations. The process is utilized to organize objects in virtual scenes by storing them in a space-partitioning data structure such as a <strong>binary space partitioning</strong> (<strong>BSP</strong>) tree; this makes it faster to perform geometry queries on a large set of <strong>three-dimensional</strong> (<strong>3D</strong>) objects. In this chapter, we will use the general concept of spatial partitioning without being faithful to how it's usually implemented in computer graphics.</p>
<p>A very high-level and conceptual way of visualizing spatial partitioning is with the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/338d48b6-7ba3-4d14-849b-a358f2c5816e.png" style="width:20.42em;height:38.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 13.1 – A diagram that illustrates spatial partitioning on a map</div>
<p>The first example represents the position of enemies on the map without any partitioning. If we want to quickly look up the location of enemies in relation to the player, it could be challenging to do this efficiently. Of course, we could use ray casts to calculate the distance between entities, but this could become inefficient as the number of enemies grows.</p>
<p class="mce-root">The next part of the diagram shows that if we partition the map, we can now easily visualize the clusters of enemies in relation to the player's location. In code, we could now quickly look up which enemy is the closest to the player and where there's the largest cluster of them, and because we don't need the exact position of each enemy but just their general geographical relation to the player, just knowing which approximate cell of the grid they are in is good enough.</p>
<div class="packt_infobox"><strong>BSP</strong> is a 3D programming technique that recursively subdivides space into convex pairs using a series of hyperplanes. The method is implemented with a binary-tree data structure. John Carmack has famously used BSP to develop games such as <em>Doom</em> and <em>Quake</em>.</div>
<h2 id="uuid-7a684bd7-b8c0-41e4-bb1a-9c29db646399">When to use the Spatial Partition pattern</h2>
<p>3D programming is beyond the scope of this book, yet the most important takeaway of the description of spatial partitioning is that it offers a solution to organizing a large set of objects in a scene in an optimal manner. Therefore, if you find yourself needing a quick way to query an extensive collection of objects in a scene while keeping track of their spatial relations, keep in mind the principles of spatial partitioning.</p>
<p class="mce-root">In the next section, we will review the overall design of the level editor and examine its technical requirements.</p>
<h1 id="uuid-6356254e-eef8-4665-9ae9-e0e995db8d5c">Designing a level editor</h1>
<p>When working on a multi-disciplinary game development team, the responsibilities of a game programmer are not limited to implementing cool game mechanics and features. We are often tasked with building asset-integration pipelines and editing tools. The most common tool we might need to implement early on in a production cycle is a custom level editor for the level designers on our team.</p>
<p>Before writing a single line of code, we need to keep in mind that our game has no randomness integrated into its core game systems. It's a game of skill in which players have the primary goal of reaching the top of the leaderboard by memorizing each track's intricacies and getting to the finish line as fast as possible.</p>
<p>Thus, based on these core design pillars, we can't use a solution such as procedural generation maps that spawn random obstacles based on specific rules and constraints. Consequently, the level designers in our team will have to design the layout of each race track by hand. </p>
<p>And this brings us to our most significant challenge: in our game, a bike travels through a 3D world in a straight line at very high speeds. If we wish to have a race that lasts more than a dozen seconds, we will need a massive amount of assets in the memory, and our designers will have to deal with editing massive levels in the editor.</p>
<p>This approach is neither efficient during the editing phase nor at runtime. So, instead of managing a single race track as one entity, we will divide it into segments, and each segment will be editable individually and then assembled in a specific order to form a single track.</p>
<p>The following diagram illustrates this high-level concept:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/980dd515-a76d-4ebc-8bd0-00021cb4eb36.png" style="width:34.42em;height:18.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 13.2 – A diagram of the sequencing of track segments</div>
<p>We gain two key benefits from this system, outlined as follows:</p>
<ol>
<li><span>Our level designers can author new tracks by creating new segments and sequencing them in various layouts.</span></li>
<li>We don't need to load the entire content of the race track into memory, just to spawn the segments we need at the right moment in relation to the player's current position.</li>
</ol>
<p>The next diagram illustrates how the track controller uses a stack data structure to manage which track to unload and which ones to spawn in relation to the current position of the player:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/969c0861-9eee-44f6-8d25-12481ba438e6.png" style="width:47.75em;height:40.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 13.3 – A diagram of the segment stack</span></div>
<p>There are two distinct characteristics of our game that we must keep in mind while implementing this system, outlined as follows:</p>
<ol>
<li>The bike never moves from its initial position. It's the track segments that move toward the player. Therefore, the sense of speed and movement is simulated and provides a visual illusion.</li>
</ol>
<ol start="2">
<li>The player can only see forward. There are no rear-view windows or look-back cameras. This camera-view limitation means we can unload track segments immediately after they are behind the player's field of view.</li>
</ol>
<p class="mce-root">In summary, with a single system, we have resolved two potential core issues for our project. Foremost, we are establishing a level design pipeline, and lastly, we have a mechanism to load our levels dynamically with a degree of optimization embedded in the design.</p>
<div class="mce-root packt_infobox">I was inspired by miniature electric-toy slot cars when designing the racing game we are building in this book. One unique aspect of this toy is that you can assemble individual track segments in various configurations. It was sometimes more fun thinking of new and unique track layouts than actually racing the toy cars.</div>
<h1 id="uuid-bfc07258-2ea3-42fe-95b8-683caaf0931e">Implementing a level editor</h1>
<p class="mce-root">In this section, we will review some code that will implement the core components of our level editor. Unlike in previous chapters, we will not try to make this code runnable or testable. Instead, we will review the implementations to understand how we use the general idea of spatial partitioning to build a functional level editor for designers while optimizing the way we load levels at runtime.</p>
<div class="packt_infobox">The code presented in the next section is to be reviewed but not compiled, as it's not a complete self-contained example.</div>
<h2 id="uuid-490e75aa-2e4e-4981-8c12-710f213b0600">Steps for implementing a level editor</h2>
<ol>
<li>To start, we are going to write a <kbd>ScriptableObject</kbd> class named <kbd>Track</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>.</span><span>Generic</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>SpatialPartition<br/></span><span>{</span><span><br/></span><span>    [</span><span>CreateAssetMenu</span><span>(</span><span>fileName </span><span>= </span><span>"New Track"</span><span>, </span><span>menuName </span><span>= </span><span>"Track"</span><span>)]<br/></span><span>    </span><span>public class </span><span>Track </span>: <span>ScriptableObject<br/></span><span>    </span><span>{<br/></span><span>        [</span><span>Tooltip</span><span>(</span><span>"The expected length of segments"</span><span>)] <br/></span><span>        </span><span>public float </span><span>segmentLength</span><span>;<br/></span><span><br/></span><span>        [</span><span>Tooltip</span><span>(</span><span>"Add segments in expected loading order"</span><span>)] <br/></span><span>        </span><span>public </span><span>List</span><span>&lt;</span><span>GameObject</span><span>&gt; </span><span>segments </span><span>= </span><span>new </span><span>List&lt;GameObject&gt;</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p style="padding-left: 60px" class="mce-root">With this <kbd>ScriptableObject</kbd> class, our level designers will be able to design new variations of race tracks by adding segments into a list and then sequencing them in a specific order. Each track asset will be fed to the <kbd>TrackController</kbd> class, which will spawn each segment automatically and in the order that the designers sequenced them.</p>
<p style="padding-left: 60px" class="mce-root">For the player, this process is seamless as it runs in the background, and segments are spawned before they are in the camera's field of view. So, from the point of view of the player, it looks like the whole level is loaded.</p>
<ol start="2">
<li>Next up is the <kbd>TrackController</kbd> class. In it, we are going to implement the segment-loading mechanism, but because it's an extensive class, we are going to divide it up and look at it in sections, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span><span>UnityEngine</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Linq</span><span>;<br/></span><span>using </span><span>System</span><span>.</span><span>Collections</span><span>.</span><span>Generic</span><span>;<br/></span><span><br/></span><span>namespace </span><span>Chapter</span><span>.</span><span>SpatialPartition<br/></span><span>{<br/></span><span>    </span><span>public class </span><span>TrackController </span>: <span>MonoBehaviour<br/></span><span>    </span><span>{<br/></span><span>        </span><span>private float </span><span>_trackSpeed</span><span>;<br/></span><span>        </span><span>private </span><span>Transform </span><span>_prevSeg</span><span>;<br/></span><span>        </span><span>private </span><span>GameObject </span><span>_trackParent</span><span>;<br/></span><span>        </span><span>private </span><span>Transform </span><span>_segParent</span><span>;<br/></span><span>        </span><span>private </span><span>List</span><span>&lt;</span><span>GameObject</span><span>&gt; </span><span>_segments</span><span>;<br/></span><span>        </span><span>private </span><span>Stack</span><span>&lt;</span><span>GameObject</span><span>&gt; </span><span>_segStack</span><span>;<br/></span><span>        </span><span>private </span><span>Vector3 </span><span>_currentPosition </span><span>= </span><span>new </span><span>Vector3</span><span>(</span><span>0</span><span>, </span><span>0</span><span>, </span><span>0</span><span>);<br/><br/>        </span><span>[</span><span>Tooltip</span><span>(</span><span>"List of race tracks"</span><span>)] <br/></span><span>        [</span><span>SerializeField</span><span>]<br/></span><span>        </span><span>private </span><span>Track </span><span>track</span><span>;<br/><br/>        </span><span>[</span><span>Tooltip</span><span>(</span><span>"Initial amount of segment to load at start"</span><span>)] <br/></span><span>        [</span><span>SerializeField</span><span>]<br/></span><span>        </span><span>private int </span><span>initSegAmount</span><span>;<br/><br/>        </span><span>[</span><span>Tooltip</span><span>(</span><span>"Amount of incremental segments to load at run"</span><span>)] <br/></span><span>        [</span><span>SerializeField</span><span>]<br/></span><span>        </span><span>private int </span><span>incrSegAmount</span><span>;<br/><br/>        </span><span>[</span><span>Tooltip</span><span>(</span><span>"Dampen the speed of the track"</span><span>)] <br/></span><span>        [</span><span>Range</span><span>(</span><span>0.0f</span><span>, </span><span>100.0f</span><span>)] <br/></span><span>        [</span><span>SerializeField</span><span>]<br/></span><span>        </span><span>private float </span><span>speedDampener</span><span>;<br/><br/>        </span><span>void </span><span>Awake</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>_segments </span><span>= <br/>                </span><span>Enumerable</span><span>.</span><span>Reverse</span><span>(</span><span>track</span><span>.</span><span>segments</span><span>).</span><span>ToList</span><span>();<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>void </span><span>Start</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>InitTrack</span><span>();<br/></span><span>        }</span></pre>
<p style="padding-left: 60px" class="mce-root">The first section is just the initialization code and is self-explanatory, but the following region of the code gets more interesting:</p>
<pre style="padding-left: 60px"><span>void </span><span>Update</span><span>()<br/></span><span>{<br/></span><span>    </span><span>_segParent</span><span>.</span><span>transform</span><span>.</span><span>Translate</span><span>(<br/></span><span>        </span><span>Vector3</span><span>.</span><span>back </span><span>* </span><span>(</span><span>_trackSpeed </span><span>* </span><span>Time</span><span>.</span><span>deltaTime</span><span>));<br/></span><span>}<br/></span><span><br/></span><span>private void </span><span>InitTrack</span><span>()<br/></span><span>{</span><span><br/></span><span>    </span><span>Destroy</span><span>(</span><span>_trackParent</span><span>);<br/><br/>    </span><span>_trackParent </span><span>= <br/></span><span>        </span><span>Instantiate</span><span>(<br/></span><span>            </span><span>Resources</span><span>.</span><span>Load</span><span>(</span><span>"Track"</span><span>, </span><span>typeof</span><span>(</span><span>GameObject</span><span>))) <br/></span><span>            </span><span>as </span><span>GameObject</span><span>;<br/><br/>    </span><span>if </span><span>(</span><span>_trackParent</span><span>)<br/></span><span>        </span><span>_segParent </span><span>= <br/></span><span>            </span><span>_trackParent</span><span>.</span><span>transform</span><span>.</span><span>Find</span><span>(</span><span>"Segments"</span><span>);<br/><br/>    </span><span>_prevSeg </span><span>= </span><span>null</span><span>;<br/><br/>    </span><span>_segStack </span><span>= </span><span>new </span><span>Stack</span><span>&lt;</span><span>GameObject</span><span>&gt;(</span><span>_segments</span><span>);<br/><br/>    </span><span>LoadSegment</span><span>(</span><span>initSegAmount</span><span>);<br/></span><span>}</span></pre>
<p style="padding-left: 60px" class="mce-root">As we can see, in the <kbd>Update()</kbd> loop, we are moving the track parent object toward the player to simulate movement. And in the <kbd>InitTrack()</kbd> method, we instantiate a track <kbd>GameObject</kbd>, which will act as the container of the track segments. But there's one significant line of code in the function that's a critical component to our segment-loading mechanism, and this is illustrated here:</p>
<pre style="padding-left: 60px"><span>_segStack </span><span>= </span><span>new </span><span>Stack</span><span>&lt;</span><span>GameObject</span><span>&gt;(</span><span>_segments</span><span>);</span></pre>
<p style="padding-left: 60px" class="mce-root"><span>On this line, we are injecting the list of segments into a new Stack container. As mentioned at the beginning of the chapter, an essential part of the spatial-partitioning technique is the organization </span><em><span>of environment objects in a data structure</span></em><span> so that they are easier to query.</span></p>
<p style="padding-left: 60px" class="mce-root"><span>In the next code snippet, we are going to see how we use the Stack data structure to load segments in the correct order:</span></p>
<pre>        <span>private void </span><span>LoadSegment</span><span>(</span><span>int </span><span>amount)<br/></span><span>        {<br/></span><span>            </span><span>for </span><span>(</span><span>int </span><span>i = </span><span>0</span><span>; i &lt; amount; i++)<br/></span><span>            {<br/></span><span>                </span><span>if </span><span>(</span><span>_segStack</span><span>.</span><span>Count </span><span>&gt; </span><span>0</span><span>)<br/></span><span>                {<br/></span><span>                    </span><span>GameObject </span><span>segment = <br/></span><span>                        </span><span>Instantiate</span><span>(<br/></span><span>                            </span><span>_segStack</span><span>.</span><span>Pop</span><span>(), </span><span>_segParent</span><span>.</span><span>transform</span><span>);<br/><br/>                    </span><span>if </span><span>(</span>!<span>_prevSeg</span><span>) <br/></span><span>                        </span><span>_currentPosition</span><span>.</span><span>z </span><span>= </span><span>0</span><span>;<br/><br/>                    </span><span>if </span><span>(</span><span>_prevSeg</span><span>)<br/></span><span>                        </span><span>_currentPosition</span><span>.</span><span>z </span><span>=<br/></span><span>                            </span><span>_prevSeg</span><span>.</span><span>position</span><span>.</span><span>z <br/></span><span>                            </span><span>+ <br/></span><span>                            </span><span>track</span><span>.</span><span>segmentLength</span><span>;<br/><br/>                    </span><span>segment.</span><span>transform</span><span>.</span><span>position </span><span>= </span><span>_currentPosition</span><span>;<br/><br/>                    </span><span>segment.</span><span>AddComponent</span><span>&lt;</span><span>Segment</span><span>&gt;();<br/><br/>                    </span><span>segment.</span><span>GetComponent</span><span>&lt;</span><span>Segment</span><span>&gt;().<br/></span><span>                        </span><span>trackController </span><span>= </span><span>this</span><span>;<br/><br/>                    </span><span>_prevSeg </span><span>= segment.</span><span>transform</span><span>;<br/></span><span>                }<br/></span><span>            }<br/></span><span>        }<br/></span><span><br/></span><span>        </span><span>public void </span><span>LoadNextSegment</span><span>()<br/></span><span>        {<br/></span><span>            </span><span>LoadSegment</span><span>(</span><span>incrSegAmount</span><span>);<br/></span><span>        } <br/></span><span>    }<br/></span><span>}</span></pre>
<p style="padding-left: 60px">The <kbd>LoadSegment()</kbd> private method is at the heart of the system. It accepts <span>as a parameter a specific amount of segments</span>. This value will determine the number of segments that it will load when called. If there are enough segments remaining on the stack, it pops one from the top and initializes it behind the previously loaded segment. It continues this circular process until it has loaded the expected amount.</p>
<p>You might be asking yourself: <em>How do we destroy segments that have passed behind the player?</em> There are many ways we can calculate or detect if one entity is behind another, but for our context, we are going to use a twofold solution. Every segment prefab has an entity called a segment marker loaded at its edge; this is composed of two pillars and an invisible trigger.</p>
<p>Once the bike goes through the trigger, the segment marker deletes its parent <kbd>GameObject</kbd>, as we can see here:</p>
<pre><span>using </span><span>UnityEngine</span><span>;<br/></span><span><br/></span><span>public class </span><span>SegmentMarker </span>: <span>MonoBehaviour<br/></span><span>{</span><span><br/></span><span>    </span><span>private void </span><span>OnTriggerExit</span><span>(</span><span>Collider </span><span>other)<br/></span><span>    {<br/></span><span>        </span><span>if </span><span>(other.</span><span>GetComponent</span><span>&lt;</span><span>BikeController</span><span>&gt;()) <br/></span><span>            </span><span>Destroy</span><span>(</span><span>transform</span><span>.</span><span>parent</span><span>.</span><span>gameObject</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>When an entity with the <kbd>BikeController</kbd> component exits a segment marker's trigger, it requests the destruction of its parent <kbd>GameObject</kbd>, which in this case would be a <kbd>Segment</kbd> entity.</p>
<p class="mce-root">When an entity with the <kbd>BikeController</kbd> component exits a segment marker's trigger, it requests the destruction of its parent <kbd>GameObject</kbd>, which would be a <kbd>Segment</kbd> entity in this context.</p>
<p class="mce-root">As seen in the <kbd>LoadSegment()</kbd> method from the <kbd>TrackController</kbd> class, every time we pop a new segment from the top of the stack, we attach to it a script as a component named <kbd>Segment</kbd>, as seen here:</p>
<pre><span>segment.</span><span>transform</span><span>.</span><span>position </span><span>= </span><span>_currentPosition</span><span>;<br/></span><span><br/>segment.</span><span>AddComponent</span><span>&lt;</span><span>Segment</span><span>&gt;(); <br/><br/></span><span>segment.</span><span>GetComponent</span><span>&lt;</span><span>Segment</span><span>&gt;().</span><span>trackController </span><span>= </span><span>this</span><span>;</span></pre>
<p>Because we are passing the current instance of the <kbd>TrackController</kbd> class to its <kbd>trackController</kbd> parameter, the <kbd>Segment</kbd> object can call back the <kbd>TrackController</kbd> class and request the loading of the following sequence of segments just before it gets destroyed, as we can see here:</p>
<pre><span>using </span><span>UnityEngine</span><span>;<br/></span><span><br/></span><span>public class </span><span>Segment </span>: <span>MonoBehaviour<br/></span><span>{</span><span><br/></span><span>    </span><span>public </span><span>TrackController </span><span>trackController</span><span>;<br/></span><span>    <br/></span><span>    </span><span>private void </span><span>OnDestroy</span><span>()<br/></span><span>    {<br/></span><span>        </span><span>if </span><span>(</span><span>trackController</span><span>) <br/>            </span><span>trackController</span><span>.</span><span>LoadNextSegments</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>This approach creates a circular mechanism that loads and unloads a controlled amount of segments automatically at specific intervals. With this approach, we are managing the number of spawned entities in the scene at a given time. In theory, this will result in a more consistent frame rate.</p>
<p class="mce-root">Another benefit of this approach, which is more gameplay-related, is that the segment markers can act as landmarks for a checkpoint system. Checkpoints are often used in time-limit racing game modes in which a player must reach several points on the track within a specific timeframe.</p>
<div class="packt_infobox">An excellent example of a checkpoint-based racing game is <em>Rad Racer</em> from 1987.</div>
<h2 id="uuid-9f2794b0-6cd5-4b1a-871d-4fe1e5478a95">Using the level editor</h2>
<p><span>You can play with the level editor by opening up the <kbd>/FPP</kbd> </span><span>folder in the Git repository and then do the following:</span></p>
<ul>
<li><span>Under the </span><kbd>/Scenes/Gyms</kbd><span> folder, you should find a scene named </span><kbd>Segment</kbd>. In this scene, you will be able to edit and create new segment prefabs.</li>
<li><span>Under the </span><strong><span class="packt_screen">Assets</span>-&gt; <span class="packt_screen">Create</span>-&gt; <span class="packt_screen">Track</span></strong><span> menu, you have an option to create new track assets.</span></li>
<li>And finally, you can modify and attach new tracks to the <kbd>TrackController</kbd> class<strong> </strong>by opening the <kbd>Track</kbd><strong> </strong>scene under the <strong><kbd>Scenes/Main</kbd><span> </span></strong>folder.</li>
</ul>
<p><span>Feel free to improve the code and, more importantly, have fun!</span></p>
<h2 id="uuid-8afc73b5-aaa1-4f82-9879-5e7cfcdbf9e9">Reviewing the level-editor implementation</h2>
<p>The implementations in this chapter are simplified versions of the code of a more complex system, but if you take the time to review an advanced version of the level editor in the <kbd>/FPP</kbd> folder of the Git project, we will see some improvements, such as the following:</p>
<ul>
<li><strong>Segments</strong>: There's an authoring pipeline for segments that uses ScriptableObjects.</li>
<li><strong>Object pooling</strong>: The <kbd>TrackController</kbd> class is using an object pool to optimize the loading time of individual segments.</li>
</ul>
<div class="packt_infobox">I didn't include these optimizations in the chapter to keep the code examples short and simple, for educational purposes.</div>
<h1 id="uuid-f86a6cc2-e697-43cf-9e2f-6b14659c8a15">Reviewing alternative solutions</h1>
<p>In an actual production context, and if time permits, I would build our game's level editor differently. I would instead design a top-down track editor that would allow the level designers to draw rails and drag and drop obstacles on them. The designers would then be able to save their work in a serialized format.</p>
<p class="mce-root">Then, using spatial-partitioning principles, the tracks would be automatically divided into segments by the <kbd>TrackController</kbd> class and put into an object pool. This approach would automate the process of generating individual segments while optimizing the spawning process.</p>
<p class="mce-root">Consequently, the designers would not have to author individual segments as prefabs, and they could design new tracks while visualizing the entire layout in an editor.</p>
<div class="packt_tip">When I'm building tools and setting up integration pipelines, my end goal is always automation. I always try to automate myself out of a job so that I don't waste time on manual tasks.</div>
<h1 id="uuid-49cfa2ef-11c7-4c8b-b0f3-6dd7581e68a1">Summary</h1>
<p>In this chapter, we took a hands-off approach and reviewed how to build a basic level editor while using the broad ideas of the Spatial Partition pattern. Our goal wasn't to be faithful to standard definitions of the pattern. Instead, we use it as a starting point to build our system. I encourage you to take the time to review the code in the <kbd>/FPP</kbd> folder and refactor it to make it better.</p>
<p class="mce-root">In the next chapter, we will review some alternative patterns that are good to know but have general use cases. Therefore, compared to the previous chapters, the use cases will have a broader scope without being specific to a game mechanic or system. The first pattern that we will tackle is the Adapter pattern. As its name implies, we will use it to integrate an adapter between two incompatible systems.</p>


            </article>

            
        </section>
    </body></html>