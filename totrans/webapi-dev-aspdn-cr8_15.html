<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-331"><a id="_idTextAnchor632"/>15</h1>
<h1 id="_idParaDest-332"><a id="_idTextAnchor633"/>ASP.NET Core Web API Common Practices</h1>
<p>We have introduced a lot of concepts in the previous chapters, including the basics of ASP.NET web API, the RESTful style, Entity Framework, unit testing and integration testing, CI/CD, and so on. You should be able to build a simple ASP.NET Core web API application by yourself. However, there are still many things that we need to learn.</p>
<p>You may have heard the phrase “<em class="italic">there is no silver bullet</em>” before. It means that there are often no simple, universal, or one-size-fits-all solutions to solve all problems. No matter how powerful the technologies, tools, or frameworks are, they are not omnipotent. This is true for ASP.NET Core web API development. However, there are some common practices that can help us build a better ASP.NET Core web API application.</p>
<p>In this chapter, we will summarize the common practices of ASP.NET Core web API development. We will cover the following topics in this chapter:</p>
<ul>
<li>Common practices of ASP.NET Core web API development</li>
<li>Optimizing the performance by implementing caching</li>
<li>Using HttpClientFactory to manage HttpClient instances</li>
</ul>
<p>After reading this chapter, you should be able to expand your knowledge of ASP.NET Core web API development and build a better web API application.</p>
<h1 id="_idParaDest-333"><a id="_idTextAnchor634"/>Technical requirements</h1>
<p>The code example in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter15</a>.</p>
<h1 id="_idParaDest-334"><a id="_idTextAnchor635"/>Common practices of ASP.NET web API development</h1>
<p>In this section, we will introduce some common practices of ASP.NET web API development. Of course, we can’t cover all the common practices in this book. However, we will try to cover the most important ones.</p>
<h2 id="_idParaDest-335"><a id="_idTextAnchor636"/>Using HTTPS instead of HTTP</h2>
<p>In the<a id="_idIndexMarker1650"/> previous chapters, we have used HTTP endpoints for simplicity; however, in the real world, HTTPS should always be used instead of HTTP. HTTPS is a secure version of HTTP, which uses TLS/SSL to encrypt the HTTP traffic, thus preventing data from being intercepted or tampered with by a third party. This ensures the safety and integrity of the data being transmitted.</p>
<p>HTTPS is becoming increasingly popular for websites that require secure data transmission, such as online banking and online shopping. This trend is reflected in the fact that many web browsers, such as Google Chrome, Microsoft Edge, Firefox, and so on, now mark HTTP websites as <strong class="bold">Not Secure</strong> to encourage users to switch to HTTPS. This is a clear indication of the growing trend toward using HTTPS for secure data transmission.</p>
<p>The default ASP.NET Core web API template uses HTTPS by default. You can find the following code in the <code>Program.cs</code> file:</p>
<pre class="source-code">
app.UseHttpsRedirection();</pre> <p>This code redirects all HTTP requests to HTTPS. In the development environment, the ASP.NET Core web API application uses a self-signed certificate. When you deploy your ASP.NET Core web API application to the production environment, you need to use a valid certificate issued by a <a id="_idIndexMarker1651"/>trusted <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>), such as Let’s Encrypt, DigiCert, Comodo, and so on<a id="_idTextAnchor637"/>.</p>
<h2 id="_idParaDest-336"><a id="_idTextAnchor638"/>Using HTTP status codes correctly</h2>
<p>HTTP status codes<a id="_idIndexMarker1652"/> are used to indicate the status of the HTTP request. There are five categories of HTTP status codes:</p>
<ul>
<li>1xx: Informational</li>
<li>2xx: Success</li>
<li>3xx: Redirection</li>
<li>4xx: Client errors</li>
<li>5xx: Server errors</li>
</ul>
<p>The<a id="_idIndexMarker1653"/> following table provides a summary of some of the most commonly used HTTP status codes in RESTful web APIs:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-10">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Status code</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>200</code></p>
</td>
<td class="No-Table-Style">
<p>OK</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>201</code></p>
</td>
<td class="No-Table-Style">
<p>Created</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>202</code></p>
</td>
<td class="No-Table-Style">
<p>Accepted</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>204</code></p>
</td>
<td class="No-Table-Style">
<p>No Content</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>301</code></p>
</td>
<td class="No-Table-Style">
<p>Moved Permanently</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>302</code></p>
</td>
<td class="No-Table-Style">
<p>Found</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>304</code></p>
</td>
<td class="No-Table-Style">
<p>Not Modified</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>400</code></p>
</td>
<td class="No-Table-Style">
<p>Bad Request</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>401</code></p>
</td>
<td class="No-Table-Style">
<p>Unauthorized</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>403</code></p>
</td>
<td class="No-Table-Style">
<p>Forbidden</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>404</code></p>
</td>
<td class="No-Table-Style">
<p>Not Found</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>405</code></p>
</td>
<td class="No-Table-Style">
<p>Method Not Allowed</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>409</code></p>
</td>
<td class="No-Table-Style">
<p>Conflict</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>410</code></p>
</td>
<td class="No-Table-Style">
<p>Gone</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>415</code></p>
</td>
<td class="No-Table-Style">
<p>Unsupported Media Type</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>422</code></p>
</td>
<td class="No-Table-Style">
<p>Unprocessable Entity</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>429</code></p>
</td>
<td class="No-Table-Style">
<p>Too Many Requests</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>500</code></p>
</td>
<td class="No-Table-Style">
<p>Internal Server Error</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>501</code></p>
</td>
<td class="No-Table-Style">
<p>Not Implemented</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>503</code></p>
</td>
<td class="No-Table-Style">
<p>Service Unavailable</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>504</code></p>
</td>
<td class="No-Table-Style">
<p>Gateway Timeout</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.1 – Commonly used HTTP status codes in RESTful web APIs</p>
<p>The <a id="_idIndexMarker1654"/>following list shows the HTTP methods and their corresponding status codes for RESTful web APIs:</p>
<ul>
<li><code>GET</code>: The <code>GET</code> method is<a id="_idIndexMarker1655"/> used to retrieve a single resource or a collection of resources. A <code>GET</code> request should not modify the state of the server. It can return the following status codes:<ul><li><code>200</code>: The resource is found and returned.</li><li><code>404</code>: The resource is not found. Note that if a collection exists but is empty, the <code>GET</code> method should return the <code>200</code> status code instead of the <code>404</code> status code.</li></ul></li>
<li><code>POST</code>: The <code>POST</code> method <a id="_idIndexMarker1656"/>is used to create a new single resource or a collection of resources. It can be also used to update a resource. It can return the following status codes:<ul><li><code>200</code>: The resource is updated successfully.</li><li><code>201</code>: The resource is created successfully. The response should include the identifier of the newly created resource.</li><li><code>202</code>: The <a id="_idIndexMarker1657"/>resource is accepted for processing, but the processing is not yet complete. This status code is often used for long-running operations.</li><li><code>400</code>: The request is invalid.</li><li><code>409</code>: The resource already exists.</li></ul></li>
<li><code>PUT</code>: The <code>PUT</code> method<a id="_idIndexMarker1658"/> is used to update a single resource or a collection of resources. It is rarely used to create resources. It can return the following status codes:<ul><li><code>200</code>: The resource was updated successfully.</li><li><code>204</code>: The resource was updated successfully but there is no content to return.</li><li><code>404</code>: The resource was not found.</li></ul></li>
<li><code>DELETE</code>: The <code>DELETE</code> method is <a id="_idIndexMarker1659"/>used to delete a single resource with a specific <a id="_idIndexMarker1660"/>identifier. It can be used to delete a collection of resources but it is not a common scenario. It can return the following status codes:<ul><li><code>200</code>: The resource was deleted successfully and the response includes the deleted resource.</li><li><code>204</code>: The resource was deleted successfully but there is no content to return.</li><li><code>404</code>: The resource was not found.</li></ul></li>
</ul>
<p>It is important to note that this list is not exhaustive and only applies to RESTful web APIs. When selecting the appropriate HTTP status codes, please consider the specific scenarios. For GraphQL APIs, <code>200</code> is typically used for most responses, with the <code>errors</code> field indicating any e<a id="_idTextAnchor639"/>rrors.</p>
<h2 id="_idParaDest-337"><a id="_idTextAnchor640"/>Using asynchronous programming</h2>
<p>The<a id="_idIndexMarker1661"/> ASP.NET Core web API framework is designed to process requests asynchronously, so we should use asynchronous programming as much as possible. Asynchronous programming allows the application to process multiple tasks concurrently, which can improve the performance of the application. For many I/O-bound operations, such as accessing the database, sending HTTP requests, and operating files, using asynchronous programming can release the thread to process other requests while waiting for the I/O operation to complete.</p>
<p>In C#, you can use the <code>async</code> and <code>await</code> keywords to define and await asynchronous operations. Many methods in .NET have synchronous and asynchronous versions. For example, the <code>StreamReader</code> class has the following synchronous and asynchronous methods to read the content of the stream:</p>
<pre class="source-code">
// Synchronous methodspublic int Read();
public string ReadToEnd();
// Asynchronous methods
public Task&lt;int&gt; ReadAsync();
public Task&lt;string&gt; ReadToEndAsync();</pre>
<p>In these four methods, the methods without the <code>Async</code> suffix are synchronous, which blocks the thread until the operation is completed. In contrast, the methods that have the <code>Async</code> suffix are asynchronous, which returns a <code>Task</code> object immediately and allows the thread to process other requests. When the operation is completed, the <code>Task</code> object will be completed and the thread will continue to process the request. Whenever possible, we should use asynchronous programming to improve the performance of the application.</p>
<p>For I/O operations, we should always use asynchronous programming. For example, when accessing <code>HttpRequest</code> and <code>HttpResponse</code> objects, we should use the asynchronous methods. Here is an example:</p>
<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;Post&gt;&gt; PostAsync()
{
    // Read the content of the request body
    var jsonString = await new StreamReader(Request.Body).ReadToEndAsync();
    // Do something with the content
    var result = JsonSerializer.Deserialize&lt;Post&gt;(jsonString);
    return Ok(result);
}</pre>
<p>In the <a id="_idIndexMarker1662"/>preceding code, the <code>ReadToEndAsync()</code> method is used to read the content of the request body. For this case, we should not use the synchronous <code>ReadToEnd()</code> method because it will block the thread until the operation is completed.</p>
<p>If there are multiple asynchronous operations that need to be executed concurrently, we can use the <code>Task.WhenAll()</code> method to wait for all the asynchronous operations to complete. Here is an example:</p>
<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&gt; GetAsync()
{
    // Simulate a long-running I/O-bound operation
    var task1 = SomeService.DoSomethingAsync();
    var task2 = SomeService.DoSomethingElseAsync();
    await Task.WhenAll(task1, task2);
    return Ok();
}</pre>
<p>In the preceding code, the <code>Task.WhenAll()</code> method waits for the <code>task1</code> and <code>task2</code> tasks to complete. If you need to get the results of the tasks after they are completed, you can use the <code>Result</code> property of the <code>Task</code> object to get the results. Here is an example:</p>
<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&gt; GetAsync()
{
    // Simulate long-running I/O-bound operations
    var task1 = SomeService.DoSomethingAsync();
    var task2 = SomeService.DoSomethingElseAsync();
    await Task.WhenAll(task1, task2);
    var result1 = task1.Result;
    var result2 = task2.Result;
    // Do something with the results
    return Ok();
}</pre>
<p>In the<a id="_idIndexMarker1663"/> preceding code, the <code>Result</code> property of the <code>task1</code> and <code>task2</code> objects is used to get the results of the tasks. As we already used the <code>await</code> keyword to wait for the tasks to be completed, the <code>Result</code> property will return the results immediately. But if we don’t use the <code>await</code> keyword to wait for the tasks to be completed, the <code>Result</code> property will block the thread until the tasks are completed. So, please be careful when using the <code>Result</code> property. Similarly, the <code>Wait()</code> method of the <code>Task</code> object will also block the thread until the task is completed. If you want to wait for a task to complete, use the <code>await</code> keyword instead of the <code>Wait</code> method.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Note that the <code>Task.WhenAll()</code> method is not suitable for all scenarios. For example, EF Core does not support running multiple queries in parallel on the same database context. If you need to execute multiple queries on the same database context, you should use the <code>await</code> keyword to wait for the previous query to complete before executing the next query.</p>
<p>When<a id="_idIndexMarker1664"/> utilizing asynchronous programming, there are several important considerations to keep in mind. These include, but are not limited to, the following:</p>
<ul>
<li>Do not use <code>async void</code> in ASP.NET Core. The only scenario where <code>async void</code> is allowed is in event handlers. If an async method returns <code>void</code>, the exceptions thrown in the method will not be caught by the caller properly.</li>
<li>Do not mix synchronous and asynchronous methods in the same method. Try to use async for the entire process if possible. This allows the entire call stack to be asynchronous.</li>
<li>If you need to use the <code>Result</code> property of the <code>Task</code> object, make sure that the <code>Task</code> object is completed. Otherwise, the <code>Result</code> property will block the thread until the <code>Task</code> object is completed.</li>
<li>If you have a method that only returns the result of another async method, there’s no need to use the <code>async</code> keyword. Just return the <code>Task</code> object directly. For example, the following code is unnecessary:<pre class="source-code">
public async Task&lt;int&gt; GetDataAsync(){    return await SomeService.GetDataAsync();}</pre><p class="list-inset">The following code does not use the <code>async</code>/<code>await</code> keywords, which is better:</p><pre class="source-code">public Task&lt;int&gt; GetDataAsync(){    return SomeService.GetDataAsync();}</pre></li> </ul>
<p>This is because the <code>async</code> keyword will create a state machine to manage the execution of the async method. In this case, it is unnecessary. Returning the <code>Task</code> directly does not create additional<a id="_idTextAnchor641"/> overhead.</p>
<h2 id="_idParaDest-338"><a id="_idTextAnchor642"/>Using pagination for large collections</h2>
<p>It is not<a id="_idIndexMarker1665"/> recommended to return a large collection of resources in a single response, as this can lead to performance issues. Such issues may include the following:</p>
<ul>
<li>The server may require a significant amount of time to query the database and process the response.</li>
<li>The response payload may be quite large, resulting in network congestion. This can negatively impact the performance of the system, leading to increased latency and decreased throughput.</li>
<li>The client may require additional time and resources to process the large response. Deserializing a large JSON object can be computationally expensive for the client. Also, rendering a large collection of items on the UI may cause the client to become unresponsive.</li>
</ul>
<p>In order to efficiently manage large collections, it is recommended to use pagination. <a href="B18971_05.xhtml#_idTextAnchor198"><em class="italic">Chapter 5</em></a> introduces pagination and filtering through the use of the <code>Skip()</code> and <code>Take()</code> methods of the <code>IQueryable</code> interface. Also, we mentioned that the <code>AsNoTracking()</code> method should be used to improve the performance of the read-only queries. This will result in a collection of resources being returned to the client. However, the client may not be aware of whether there are more resources available. To address this issue, we can create a custom class to represent the paginated response. An example of this is provided here:</p>
<pre class="source-code">
public class PaginatedList&lt;T&gt; where T : class{
    public int PageIndex { get; }
    public int PageSize { get; }
    public int TotalPages { get; }
    public List&lt;T&gt; Items { get; } = new();
    public PaginatedList(List&lt;T&gt; items, int count, int pageIndex = 1, int pageSize = 10)
    {
        PageIndex = pageIndex;
        PageSize = pageSize;
        TotalPages = (int)Math.Ceiling(count / (double)pageSize);
        Items.AddRange(items);
    }
    public bool HasPreviousPage =&gt; PageIndex &gt; 1;
    public bool HasNextPage =&gt; PageIndex &lt; TotalPages;
}</pre>
<p>In the preceding code, the <code>PaginatedList&lt;T&gt;</code> class contains a couple of properties to represent the <a id="_idIndexMarker1666"/>pagination information:</p>
<ul>
<li><code>PageIndex</code>: The current page index</li>
<li><code>PageSize</code>: The page size</li>
<li><code>TotalPages</code>: The total number of pages</li>
<li><code>Items</code>: The collection of items on the current page</li>
<li><code>HasPreviousPage</code>: Indicates whether there is a previous page</li>
<li><code>HasNextPage</code>: Indicates whether there is a next page</li>
</ul>
<p>Then, we can use this class in the controller for pagination. Here is an example:</p>
<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&lt;PaginatedList&lt;Post&gt;&gt;&gt; GetPosts(int pageIndex = 1, int pageSize = 10)
{
    var posts = _context.Posts.AsQueryable().AsNoTracking();
    var count = await posts.CountAsync();
    var items = await posts.Skip((pageIndex - 1) * pageSize).Take(pageSize).ToListAsync();
    var result = new PaginatedList&lt;Post&gt;(items, count, pageIndex, pageSize);
    return Ok(result);
}</pre>
<p>In the <a id="_idIndexMarker1667"/>preceding code, besides the <code>Items</code> property, the <code>PaginatedList&lt;T&gt;</code> class also contains the pagination information, such as <code>PageIndex</code>, <code>PageSize</code>, <code>TotalPages</code>, <code>HasPreviousPage</code>, <code>HasNextPage</code>, and so on. The response of the endpoint will be as follows:</p>
<pre class="source-code">
{  "pageIndex": 1,
  "pageSize": 10,
  "totalPages": 3,
  "items": [
    {
      "id": "3c979917-437b-406d-a784-0784170b5dd9",
      "title": "Post 26",
      "content": "Post 26 content",
      "categoryId": "ffdd0d80-3c3b-4e83-84c9-025d5650c6e5",
      "category": null
    },
    ...
  ],
  "hasPreviousPage": false,
  "hasNextPage": true
}</pre>
<p>In this way, the <a id="_idIndexMarker1668"/>clients can implement pagination easily. You can also include more information in the <code>PaginatedList&lt;T&gt;</code> class, such as the links to the previous page and the next page, and so on.</p>
<p>When implementing pagination, it is important to consider sorting and filtering. Generally, the data should be filtered first, followed by sorting and then pagination. For example, the following LINQ query can be used:</p>
<pre class="source-code">
var posts = _context.Posts.AsQueryable().AsNoTracking();posts = posts.Where(x =&gt; x.Title.Contains("Post")).OrderBy(x =&gt; x.PublishDate).Skip((pageIndex - 1) * pageSize).Take(pageSize).ToListAsync();</pre>
<p>The <code>Where()</code> method should be used to filter the data first in order to reduce the amount of data to be sorted. This is important, as sorting is often an expensive operation. Once the data has been filtered, the <code>OrderBy()</code> method can be used to sort it. Finally, the <code>Skip()</code> and <code>Take()</code> methods can be used to pagi<a id="_idTextAnchor643"/>nate the data.</p>
<h2 id="_idParaDest-339"><a id="_idTextAnchor644"/>Specifying the response types</h2>
<p>An <a id="_idIndexMarker1669"/>ASP.NET Core web API endpoint can return various types of responses, such as <code>ActionResult</code>, <code>ActionResult&lt;T&gt;</code>, or a specific type of the object. For example, the following code returns a <code>Post</code> object:</p>
<pre class="source-code">
[HttpGet("{id}")]public async Task&lt;Post&gt; GetAsync(Guid id)
{
    var post = await _postService.GetAsync(id);
    return post;
}</pre>
<p>The preceding code works, but what if the <code>post</code> cannot be found? It is recommended to use <code>ActionResult&lt;T&gt;</code> instead of the specific type of the object. The <code>ActionResult&lt;T&gt;</code> class is a generic class that can be used to return various HTTP status codes. Here is an example:</p>
<pre class="source-code">
public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(Guid id){
    var post = await _context.Posts.FindAsync(id);
    if (post == null)
    {
        return NotFound();
    }
    return Ok(post);
}</pre>
<p>In the<a id="_idIndexMarker1670"/> preceding code, the <code>ActionResult&lt;Post&gt;</code> class is used to return a <code>Post</code> object. If the <code>post</code> cannot be found, the <code>NotFound</code> method is used to return the <code>404 Not Found</code> status code. If the <code>post</code> is found, the <code>Ok</code> method is used to return the <code>200 OK</code> status code.</p>
<p>We can add the <code>[ProducesResponseType]</code> attribute to specify the response types of the endpoint. Here is a complete example:</p>
<pre class="source-code">
[HttpGet("{id}")][ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(Guid id)
{
    var post = await _context.Posts.FindAsync(id);
    if (post == null)
    {
        return NotFound();
    }
    return Ok(post);
}</pre>
<p>In the <a id="_idIndexMarker1671"/>preceding code, there are two <code>[ProducesResponseType]</code> attributes. The first one specifies the <code>200 OK</code> status code and the second one specifies the <code>404 Not Found</code> status code. The <code>[ProducesResponseType]</code> attribute is optional, but it is recommended to use it to specify the response types of the endpoint. The Swagger UI will use the <code>[ProducesResponseType]</code> attribute to generate the response types of the endpoint, as shown in <em class="italic">Figure 15</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to generate the response types of the endpoint" src="img/B18971_15_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Swagger UI uses the [ProducesResponseType] attribute to generate the response types of the endpoint</p>
<p>We can see<a id="_idIndexMarker1672"/> there are possible responses in the Swagger UI. This endpoint can return the <code>200 OK</code> status code or the <code>404 Not Found</code> status code.</p>
<p>To enforce the use of the <code>[ProducesResponseType]</code> attribute, we can use the <code>OpenAPIAnalyzers</code>. This analyzer can be used to report the missing <code>[ProducesResponseType]</code> attribute. Add the following code in the <code>&lt;PropertyGroup&gt;</code> section of the <code>*.</code><code>csproj</code> file:</p>
<pre class="source-code">
&lt;IncludeOpenAPIAnalyzers&gt;true&lt;/IncludeOpenAPIAnalyzers&gt;</pre> <p>Then, we can see the warning in Visual Studio if the controller action does not have the <code>[ProducesResponseType]</code> attribute, as shown in <em class="italic">Figure 15</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 15.2 – Visual Studio displays the warning if the controller action does not have the [ProducesResponseType] attribute" src="img/B18971_15_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – Visual Studio displays the warning if the controller action does not have the [ProducesResponseType] attribute</p>
<p>Visual Studio<a id="_idIndexMarker1673"/> will provide you with a quick fix to add these attributes. This analyzer is very useful and it is recom<a id="_idTextAnchor645"/>mended to use it.</p>
<h2 id="_idParaDest-340"><a id="_idTextAnchor646"/>Adding comments to the endpoints</h2>
<p>Adding XML comments <a id="_idIndexMarker1674"/>to the endpoints can help other developers understand them better. These comments will be displayed in the Swagger UI, providing a comprehensive description of the endpoints. This can be a great resource for developers to use when working with the endpoints.</p>
<p>Adding XML comments to the endpoints is very simple. We just need to add the <code>///</code> comments to them. Visual Studio will automatically generate the XML comments structure when you type <code>///</code>. You need to add the description of the method, the parameters, the return value, and so on. Here is an example:</p>
<pre class="source-code">
/// &lt;summary&gt;/// Get a post by id
/// &lt;/summary&gt;
/// &lt;param name="id"&gt;The id of the post&lt;/param&gt;
/// &lt;returns&gt;The post&lt;/returns&gt;
[HttpGet("{id}")]
[ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(Guid id)
{
    // Omitted for brevity
}</pre>
<p>You can<a id="_idIndexMarker1675"/> also add comments to the model classes. Here is a simple example:</p>
<pre class="source-code">
/// &lt;summary&gt;/// The post model
/// &lt;/summary&gt;
public class Post
{
    /// &lt;summary&gt;
    /// The id of the post
    /// &lt;/summary&gt;
    public Guid Id { get; set; }
    /// &lt;summary&gt;
    /// The title of the post
    /// &lt;/summary&gt;
    public string Title { get; set; }
    /// &lt;summary&gt;
    /// The content of the post
    /// &lt;/summary&gt;
    public string Content { get; set; }
}</pre>
<p>Then, we need to enable the XML documentation file generation in the project file. Open the <code>*.csproj</code> file and add the following code in the <code>&lt;</code><code>PropertyGroup&gt;</code> element:</p>
<pre class="source-code">
&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;&lt;NoWarn&gt;$(NoWarn);1591&lt;/NoWarn&gt;</pre>
<p>The <code>GenerateDocumentationFile</code> property specifies whether an XML documentation<a id="_idIndexMarker1676"/> file should be generated. The <code>NoWarn</code> property can be used to suppress specific warnings, such as the <code>1591</code> warning code, which is associated with missing XML comments. Suppressing this warning is beneficial, as it prevents the warning from appearing when the project is built.</p>
<p>Next, we need to configure the Swagger UI to use the XML documentation file. Open the <code>Program.cs</code> file and update the <code>builder.Services.AddSwaggerGen()</code> method as follows:</p>
<pre class="source-code">
builder.Services.AddSwaggerGen(c =&gt;{
    // The below line is optional. It is used to describe the API.
    // c.SwaggerDoc("v1", new OpenApiInfo { Title = "MyBasicWebApiDemo", Version = "v1" });
    c.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, $"{Assembly.GetExecutingAssembly().GetName().Name}.xml"));
});</pre>
<p>In the preceding code, the <code>IncludeXmlComments</code> method is used to specify the XML documentation file. We can use reflection <code>{Assembly.GetExecutingAssembly().GetName().Name}.xml</code>, to get the name of the XML documentation file. The <code>AppContext.BaseDirectory</code> property is used to get the base directory of the application.</p>
<p>To<a id="_idIndexMarker1677"/> view the comments in the Swagger UI, run the application and open the Swagger UI. As shown in <em class="italic">Figure 15</em><em class="italic">.3</em>, the comments will be displayed:</p>
<div><div><img alt="Figure 15.3 – The Swagger UI displays the comments of the endpoints" src="img/B18971_15_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – The Swagger UI displays the comments of the endpoints</p>
<p>The model classes are also described in the Swagger UI, as shown in <em class="italic">Figure 15</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 15.4 – The Swagger UI displays the comments of the model classes" src="img/B18971_15_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – The Swagger UI displays the comments of the model classes</p>
<p>Displaying<a id="_idIndexMarker1678"/> the comments in the Swagger UI is a great way to provide developer-friendly API documentation. It is highly recommended to add comments to the endpoint<a id="_idTextAnchor647"/>s and model classes.</p>
<h2 id="_idParaDest-341"><a id="_idTextAnchor648"/>Using System.Text.Json instead of Newtonsoft.Json</h2>
<p><code>Newtonsoft.Json</code> is a popular JSON library for .NET and is widely used in many projects. It <a id="_idIndexMarker1679"/>was created as a personal project by James Newton-King in 2006 and has since become the number one library on NuGet, with over one billion downloads. An interesting fact is that in 2022, the downloads of <code>Newtonsoft.Json</code> on NuGet reached an impressive 2.1 billion, surpassing the <code>Int32.MaxValue</code> of 2,147,483,647. This milestone necessitated a change to NuGet to support the continued downloads of <code>Newtonsoft.Json</code>.</p>
<p>Microsoft has introduced a new JSON library, <code>System.Text.Json</code>, with the release of .NET Core 3.0. This library was designed to be high performing by utilizing <code>Span&lt;T&gt;</code>, which provides a type-safe and memory-safe representation of contiguous regions of arbitrary memory. Using <code>Span&lt;T&gt;</code> can reduce memory allocation and improve the performance of .NET code. <code>System.Text.Json</code> is included in the .NET Core SDK and is actively<a id="_idIndexMarker1680"/> being developed. Although it may not have all the features of <code>Newtonsoft.Json</code>, it is a great choice for new projects.</p>
<p>The latest ASP.NET web API template uses <code>System.Text.Json</code> by default. It provides a simple way to serialize and deserialize JSON data. Here is an example:</p>
<pre class="source-code">
var options = new JsonSerializerOptions{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    WriteIndented = true
};
// Serialize
var json = JsonSerializer.Serialize(post, options);
// Deserialize
var post = JsonSerializer.Deserialize&lt;Post&gt;(json, options);</pre>
<p>If you still want to use <code>Newtonsoft.Json</code>, you can install the <code>Microsoft.AspNetCore.Mvc.NewtonsoftJson</code> NuGet package and update the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
builder.Services.AddControllers()    .AddNewtonsoftJson(options =&gt;
    {
        options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
        options.SerializerSettings.Formatting = Formatting.Indented;
    });</pre>
<p>You can <a id="_idIndexMarker1681"/>update the <code>options</code> object to configure the <code>Newtonsoft.Json</code> library. Again, it is recommended to use <code>System.Text.Json</code> instead of <code>Newtonsoft.Json</code> unless you need some specific features of <code>Newtonsoft.Json </code>because <code>System.Text.Json</code> <a id="_idTextAnchor649"/>has better performance.</p>
<h1 id="_idParaDest-342"><a id="_idTextAnchor650"/>Optimizing the performance by implementing caching</h1>
<p>Caching is a<a id="_idIndexMarker1682"/> common technique used to improve the performance of the application. In web API development, caching can store frequently accessed data in a temporary storage, such as memory or disk, to reduce the number of database queries and improve the responsiveness of the application. In this section, we will introduce the caching in ASP.NET Core web API development.</p>
<p>Caching is an effective tool when handling data that is not regularly updated but is costly to compute or obtain from the database. It is also useful when multiple clients access the same data frequently. As an example, consider an e-commerce application that displays a list of categories. The categories of the products are not often changed, yet they are frequently viewed by users. To improve the performance of the application, we can cache the categories. When a user requests the categories, the application can return the cached data directly without querying the database.</p>
<p>In ASP.NET Core, we have several<a id="_idIndexMarker1683"/> options for implementing caching, each suited to a specific scenario:</p>
<ul>
<li><strong class="bold">In-memory caching</strong>: This <a id="_idIndexMarker1684"/>type of caching stores data in the <a id="_idIndexMarker1685"/>memory of the application. It is fast and efficient and is suitable for scenarios where the data does not need to be shared across multiple instances of the application. However, the data will be lost when the application is restarted.</li>
<li><strong class="bold">Distributed caching</strong>: This<a id="_idIndexMarker1686"/> type of caching involves storing<a id="_idIndexMarker1687"/> cached data in a shared storage, such as Redis or SQL Server, which can be accessed by multiple instances of the application. It is suitable for applications that are deployed with multiple instances, such as a web farm, container orchestration, or serverless computing.</li>
<li><strong class="bold">Response caching</strong>: This<a id="_idIndexMarker1688"/> caching technique is based <a id="_idIndexMarker1689"/>on the HTTP caching mechanism.</li>
</ul>
<p>In the following sections, we will introduce the in-memory caching and distributed caching in ASP.NET Core web API development, as well as the output caching, which is <a id="_idTextAnchor651"/>introduced in ASP.NET Core 7.0.</p>
<h2 id="_idParaDest-343"><a id="_idTextAnchor652"/>In-memory caching</h2>
<p>In-memory caching <a id="_idIndexMarker1690"/>is a fast and easy way to store data in an application’s <a id="_idIndexMarker1691"/>memory. ASP.NET Core provides the <code>IMemoryCache</code> interface to facilitate this process. This type of caching is highly versatile, as it can store any type of data in the form of a key-value pair.</p>
<p>The example project in this section can be found in the <code>chapter15/CachingDemo</code> folder. This is a simple ASP.NET Core web API application. It contains a <code>/categories</code> endpoint that returns the categories of products.</p>
<p>To simplify the example, we use a static list to store the categories to simulate a database. When the application queries the categories, it will print a log to indicate that the categories are queried from the database. Here is the code in the <code>CategoryService</code> class:</p>
<pre class="source-code">
public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetCategoriesAsync(){
    // Simulate a database query
    _logger.LogInformation("Getting categories from the database");
    await Task.Delay(2000);
    return Categories;
}</pre>
<p>In the preceding code, we use a <code>Task.Delay()</code> method to simulate a database query. This query takes two seconds to complete, which is slow. As the categories are not often changed, we can use in-memory caching to improve the performance of the application.</p>
<p>To <a id="_idIndexMarker1692"/>use <a id="_idIndexMarker1693"/>in-memory caching, we need to add the <code>Microsoft.Extensions.Caching.Memory</code> NuGet package by running the following command:</p>
<pre class="console">
dotnet add package Microsoft.Extensions.Caching.Memory</pre> <p>Then, we need to register the in-memory caching in the <code>Program</code> class:</p>
<pre class="source-code">
builder.Services.AddMemoryCache();</pre> <p>Next, we can use the <code>IMemoryCache</code> interface in other classes. Inject the <code>IMemoryCache</code> interface into the <code>CategoryService</code> class:</p>
<pre class="source-code">
public class CategoryService(ILogger&lt;CategoryService&gt; logger, IMemoryCache cache)    : ICategoryService
{
    // Omitted for brevity
}</pre>
<p>Update <a id="_idIndexMarker1694"/>the <code>GetCategoriesAsync</code> method<a id="_idIndexMarker1695"/> as follows:</p>
<pre class="source-code">
public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetCategoriesAsync(){
    // Try to get the categories from the cache
    if (_cache.TryGetValue(CacheKeys.Categories, out IEnumerable&lt;Category&gt;? categories))
    {
        _logger.LogInformation("Getting categories from cache");
        return categories ?? new List&lt;Category&gt;();
    }
    // Simulate a database query
    _logger.LogInformation("Getting categories from the database");
    await Task.Delay(2000);
    categories = Categories;
    // Cache the categories for 10 minutes
    var cacheEntryOptions = new MemoryCacheEntryOptions()
        .SetAbsoluteExpiration(TimeSpan.FromMinutes(10));
    _cache.Set(CacheKeys.Categories, categories, cacheEntryOptions);
    return Categories;
}</pre>
<p>In the updated code, we first try to get the categories from the cache by the cache key. If the categories are found in the cache, we return them directly. Otherwise, we query the database and cache the categories for 10 minutes. The <code>SetAbsoluteExpiration()</code> method is used to set the absolute expiration time of the cache entry. After 10 minutes, the cache entry will be removed from the cache.</p>
<p>Run the <a id="_idIndexMarker1696"/>application and send a request to the <code>/categories</code> endpoint. The first request will take 2 seconds to complete, and then the subsequent<a id="_idIndexMarker1697"/> requests will be completed immediately. You may see the following log in the console:</p>
<pre class="source-code">
info: CachingDemo.Services.CategoryService[0]      Getting categories from the database
info: CachingDemo.Services.CategoryService[0]
      Getting categories from cache</pre>
<p>In this way, in-memory caching can significantly improve the performance of the application.</p>
<p>To ensure that the cache does not become bloated with outdated entries, the cache must apply a proper expiration policy. The cache has several options for expiration, two of them are as follows:</p>
<ul>
<li><strong class="bold">Absolute expiration</strong>: The <a id="_idIndexMarker1698"/>cache entry will be removed from the cache after a specified time.</li>
<li><strong class="bold">Sliding expiration</strong>: The <a id="_idIndexMarker1699"/>cache entry will be removed after a predetermined period of time if it is not accessed.</li>
</ul>
<p>When using <code>SlidingExpiration</code>, the cache can be retained indefinitely if it is accessed frequently. To avoid this, we can set the <code>AbsoluteExpiration</code> property or <code>AbsoluteExpirationRelativeToNow</code> property to limit the maximum lifetime of the cache entry. Here is an example:</p>
<pre class="source-code">
var cacheEntryOptions = new MemoryCacheEntryOptions{
    SlidingExpiration = TimeSpan.FromMinutes(10),
    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
};
cache.Set(CacheKeys.Categories, categories, cacheEntryOptions);</pre>
<p>In the preceding code, the <code>SlidingExpiration</code> property is set to 10 minutes, and the <code>AbsoluteExpirationRelativeToNow</code> property is set to 30 minutes. This means that the cache entry will be removed from the cache after 30 minutes, even if it is frequently accessed.</p>
<p>Sometimes <a id="_idIndexMarker1700"/>we may need to manually update the cache entry. For <a id="_idIndexMarker1701"/>example, when a new category is created, or an existing category is updated or deleted, we can remove the cache entry to force the application to query the database again and refresh the cache entry. Move the preceding code to a new method:</p>
<pre class="source-code">
private async Task RefreshCategoriesCache(){
    // Query the database first
    logger.LogInformation("Getting categories from the database");
    // Simulate a database query
    await Task.Delay(2000);
    var categories = Categories;
    // Then refresh the cache
    cache.Remove(CacheKeys.Categories);
    var cacheEntryOptions = new MemoryCacheEntryOptions
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
    };
    cache.Set(CacheKeys.Categories, categories, cacheEntryOptions);
}</pre>
<p>Note that in the preceding code, we should query the database first, then remove the cache entry <a id="_idIndexMarker1702"/>and reset it. Otherwise, the application may query the <a id="_idIndexMarker1703"/>database multiple times if the cache entry is removed before the database query is completed.</p>
<p>Then, we can call the <code>RefreshCategoriesCache()</code> method when a new category is created or an existing category is updated or deleted. Here is an example:</p>
<pre class="source-code">
public async Task&lt;Category?&gt; UpdateCategoryAsync(Category category){
    var existingCategory = Categories.FirstOrDefault(c =&gt; c.Id == category.Id);
    if (existingCategory == null)
    {
        return null;
    }
    existingCategory.Name = category.Name;
    existingCategory.Description = category.Description;
    await RefreshCategoriesCache();
    return existingCategory;
}</pre>
<p>Alternatively, we can create a background task to update the cache entry periodically. A background task is a task that runs behind the scenes without user interaction. It is useful for performing tasks that are not time-sensitive, such as updating the cache entry. To create a background task, we can use the <code>BackgroundService</code> class. Create<a id="_idIndexMarker1704"/> a <a id="_idIndexMarker1705"/>new class named <code>CategoriesCacheBackgroundService</code> that inherits from the <code>BackgroundService</code> class:</p>
<pre class="source-code">
public class CategoriesCacheBackgroundService(    IServiceProvider serviceProvider,
    ILogger&lt;CategoriesCacheBackgroundService&gt; logger,
    IMemoryCache cache)
    : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Remove the cache every 1 hour
        while (!stoppingToken.IsCancellationRequested)
        {
            logger.LogInformation("Updating the cache in background service");
            using var scope = serviceProvider.CreateScope();
            var categoryService = scope.ServiceProvider.GetRequiredService&lt;ICategoryService&gt;();
            var categories = await categoryService.GetCategoriesAsync();
            cache.Remove(CacheKeys.Categories);
            cache.Set(CacheKeys.Categories, categories, TimeSpan.FromHours(1));
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}</pre>
<p>In the preceding code, we use a <code>while</code> loop to reset the cache entry every one hour. Note that you cannot inject the <code>ICategoryService</code> directly because the <code>BackgroundService</code> class will be registered as a singleton service, but the <code>ICategoryService</code> is registered as a scoped service. A singleton service cannot depend on a scoped service. To solve this problem, we need to use the <code>IServiceProvider</code> interface to create a scope and get the <code>ICategoryService</code> from the scope.</p>
<p>Then, register the <code>CacheBackgroundService</code> class in the <code>Program</code> class:</p>
<pre class="source-code">
builder.Services.AddHostedService&lt;CacheBackgroundService&gt;();</pre> <p>When <a id="_idIndexMarker1706"/>the <a id="_idIndexMarker1707"/>background task is executed every one hour, the cache entry will be removed from the cache. The background task should first query the database and then remove the cache entry and reset it. If the cache entry is deleted first, the application may query the database multiple times, resulting in performance issues.</p>
<p>When implementing caching, it is important to consider scenarios where records cannot be found in the database. Let us see how it happens. Update the <code>GetCategoryAsync()</code> method as follows:</p>
<pre class="source-code">
public async Task&lt;Category?&gt; GetCategoryAsync(int id){
    if (cache.TryGetValue($"{CacheKeys.Categories}:{id}", out Category? category))
    {
        logger.LogInformation($"Getting category with id {id} from cache");
        return category;
    }
    // Simulate a database query
    logger.LogInformation($"Getting category with id {id} from the database");
    await Task.Delay(2000);
    var result = Categories.FirstOrDefault(c =&gt; c.Id == id);
    if (result is not null)
    {
        cache.Set($"{CacheKeys.Categories}:{id}", result);
    }
    return result;
}</pre>
<p>In the <a id="_idIndexMarker1708"/>preceding code, if the category cannot be found in the <a id="_idIndexMarker1709"/>cache, we query the database and cache the category. But there is a potential issue here. What if the category with the specified ID does not exist? In this case, the application will not set the cache and each request will query the database. Cache is not used at all. To solve this problem, we can use the <code>GetOrCreateAsync</code> method of the <code>IMemoryCache</code> interface. Here is the updated code:</p>
<pre class="source-code">
public async Task&lt;Category?&gt; GetCategoryAsync(int id){
    var category = await cache.GetOrCreateAsync($"{CacheKeys.Categories}:{id}", async entry =&gt;
    {
        // Simulate a database query
        logger.LogInformation($"Getting category with id {id} from the database");
        await Task.Delay(2000);
        return Categories.FirstOrDefault(c =&gt; c.Id == id);
    });
    return category;
}</pre>
<p>The updated <a id="_idIndexMarker1710"/>code uses the <code>GetOrCreateAsync</code> method to retrieve the category from the cache. If the category is not present, the method will <a id="_idIndexMarker1711"/>execute the specified delegate to fetch it from the database. Upon successful retrieval, the category will be cached and returned. If the category is not found, <code>null</code> will be returned. So, the application will not query the database every time. To avoid the issue mentioned earlier, it is recommended to use the <code>GetOrCreateAsync</code> method to obtain the data from the cache.</p>
<p>There are more important considerations when using in-memory caching:</p>
<ul>
<li><em class="italic">Consider the expiration time of the cache entry</em>. If the data is not often changed, we can set a longer expiration time. Otherwise, use a shorter expiration time. Also, you can use the <code>SlidingExpiration</code> property and the absolute expiration time to achieve a balance between the performance and the freshness of the data.</li>
<li><em class="italic">The in-memory cache can cache any object, but be careful when caching large objects</em>. It is important to limit the size of the cache entry. We can use <code>SetSize</code>, <code>Size</code>, and <code>SizeLimit</code> to limit the size of the cache. Note that when using these methods, the in-memory cache must be registered as a singleton service. Please refer to the documentation for more information at <a href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory">https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory</a>.</li>
<li><em class="italic">Define proper cache keys</em>. The cache keys should be unique and descriptive. Especially, when using caching for users, ensure that the cache keys are unique for each user. Otherwise, the cached data of one user may be used by another user.</li>
<li><em class="italic">Provide a way to fall back to the data source when the cache is </em><em class="italic">not available</em>.</li>
</ul>
<p>There are no hard rules for these settings. You need to consider the specific scenarios and adjust the settings accordingly.</p>
<p>In-memory caching <a id="_idIndexMarker1712"/>is a simple and effective way to improve the performance<a id="_idIndexMarker1713"/> of the application. However, it is not suitable for applications that are deployed with multiple instances. The cached data only works for the current instance. When a client requests the data from another instance, the cached data in the original instance will not be used. To solve this problem, one solution is to implement session affinity, which means the request from a user will always be routed to the same instance. This can be achieved by using a load balancer that supports session affinity, such as Nginx, Azure Application Gateway, and so on. This is out of the scope of this book. Please refer to the documentation of the load balancer for more information.</p>
<p>Another approach to this issue is to implement a d<a id="_idTextAnchor653"/>istributed cache, as outlined in the following section.</p>
<h2 id="_idParaDest-344"><a id="_idTextAnchor654"/>Distributed caching</h2>
<p>Distributed caching offloads<a id="_idIndexMarker1714"/> the cache from the application to a shared storage, such as Redis or SQL Server. The data stored in the distributed cache can be accessed by multiple instances of the application. If the application restarts, the cached data will not be lost. There is no need to implement session affinity when using distributed caching.</p>
<p>There are several<a id="_idIndexMarker1715"/> options to implement distributed <a id="_idIndexMarker1716"/>caching in ASP.NET Core. The following are the most commonly used options:</p>
<ul>
<li><strong class="bold">Redis</strong>: Redis is an<a id="_idIndexMarker1717"/> open-source, in-memory data structure store. It has many features, such as caching, pub/sub, and so on.</li>
<li><strong class="bold">SQL Server</strong>: SQL Server<a id="_idIndexMarker1718"/> can be also used as a distributed cache.</li>
<li><strong class="bold">Azure Cache for Redis</strong>: Azure Cache<a id="_idIndexMarker1719"/> for Redis is a fully managed, open-source, in-memory data structure store. It is based on the popular open-source Redis cache. You can use a local Redis server for development and testing and use Azure Cache for Redis in production.</li>
<li><code>https://github.com/Alachisoft/NCache</code>.</li>
</ul>
<p>In this section, we <a id="_idIndexMarker1721"/>will introduce the Redis cache using the same sample project as the previous section. We use a static <code>Dictionary&lt;int, List&lt;Category&gt;&gt;</code> to store the users’ favorites categories, which simulates<a id="_idIndexMarker1722"/> the data stored in the database. When a user requests the favorites categories, the application will use the user ID as the key to query the database. If we use in-memory caching, the caching key should include the user ID, such as <code>1_Favorites_Categories</code>. However, if this user’s subsequent requests are routed to another instance, there is no way to get the cached data. That is why we need to use the distributed caching.</p>
<p>First, we need to prepare a Redis server. We can use the Docker to run a Redis server. Start Docker Desktop on your machine and run the following command to pull the Redis image:</p>
<pre class="console">
docker pull redis</pre> <p>Then, run the Redis server:</p>
<pre class="console">
docker run --name redis -p 6379:6379 -d redis</pre> <p>The Redis server will be listening on port <code>6379</code>.</p>
<p>To access the Redis server in the terminal, we need to use the <code>redis-cli</code> command. This command is included in the Redis image. Run the following command to access the Redis server:</p>
<pre class="console">
docker exec -it redis redis-cli</pre> <p>The <code>docker exec</code> command is used to execute a command in a running container. The <code>-it</code> option is used to run the command interactively. It means we want to execute the <code>redis-cli</code> command in the container. You will see the following output:</p>
<pre class="console">
127.0.0.1:6379&gt;</pre> <p>This means we have successfully accessed the Redis server. Now we can use the <code>redis-cli</code> command to access the Redis server. For example, we can use the <code>set</code> command to set the value of a key:</p>
<pre class="console">
set my-key "Hello World"</pre> <p>Then, we can use the <code>get</code> command to get the value of the key:</p>
<pre class="console">
get my-key</pre> <p>You will see <code>Hello World</code> in the output.</p>
<p>Now<a id="_idIndexMarker1723"/> the <a id="_idIndexMarker1724"/>Redis server is ready to use. To use the Redis cache in ASP.NET Core, we need to install the <code>Microsoft.Extensions.Caching.StackExchangeRedis</code> NuGet package:</p>
<pre class="console">
dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis</pre> <p>Then, we need to register the Redis cache in the <code>Program</code> class:</p>
<pre class="source-code">
builder.Services.AddStackExchangeRedisCache(options =&gt;    options.Configuration = "localhost:6379";    options.InstanceName = "CachingDemo";
});</pre>
<p>In the preceding code, the <code>AddStackExchangeRedisCache</code> extension method is used to register the Redis cache. We specify the Redis server address and an optional instance name, which is used to create a logical partition for the cache. Note that these configurations can be defined in the <code>appsettings.json</code> file or environment variables, allowing for different Redis instances to be used for development and production purposes.</p>
<p>Next, we can use the <code>IDistributedCache</code> interface to operate the Redis cache. Inject the <code>IDistributedCache</code> interface into the <code>CategoryService</code> class:</p>
<pre class="source-code">
public class CategoryService(ILogger&lt;CategoryService&gt; logger, IMemoryCache cache, IDistributedCache distributedCache) : ICategoryService{
    // Omitted for brevity
}
// Update the <code>GetFavoritesCategoriesAsync()</code> method as follows:
public async Task&lt;IEnumerable&lt;Category&gt;&gt; GetFavoritesCategoriesAsync(int userId)
{
    // Try to get the categories from the cache
    var cacheKey = $"{CacheKeys.FavoritesCategories}:{userId}";
    var bytes = await distributedCache.GetAsync(cacheKey);
    if (bytes is { Length: &gt; 0 })
    {
        logger.LogInformation("Getting favorites categories from distributed cache");
        var serializedFavoritesCategories = Encoding.UTF8.GetString(bytes);
        var favoritesCategories = JsonSerializer.Deserialize&lt;IEnumerable&lt;Category&gt;&gt;(serializedFavoritesCategories);
        return favoritesCategories ?? new List&lt;Category&gt;();
    }
    // Simulate a database query
    logger.LogInformation("Getting favorites categories from the database");
    var categories = FavoritesCategories[userId];
    // Store the result in the distributed cache
    var cacheEntryOptions = new DistributedCacheEntryOptions
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
    };
    var serializedCategories = JsonSerializer.Serialize(categories);
    var serializedCategoriesBytes = Encoding.UTF8.GetBytes(serializedCategories);
    await distributedCache.SetAsync(cacheKey, serializedCategoriesBytes, cacheEntryOptions);
    await Task.Delay(2000);
    return FavoritesCategories[userId].AsEnumerable();
}</pre>
<p>In the <a id="_idIndexMarker1725"/>preceding code, we<a id="_idIndexMarker1726"/> first try to get the favorites categories from the cache using the cache key. If the favorites categories are found in the distributed cache, we return the cached data directly. Otherwise, we query the database and store the result in the distributed cache.</p>
<p>As the Redis cache stores the data as <code>byte[]</code>, to store the cached data, we need to serialize the data into a JSON string and then convert the JSON string into a <code>byte[]</code> value using the <code>Encoding.UTF8.GetBytes()</code> method. Similarly, when getting the cached data, we need to convert the <code>byte[]</code> value to a JSON string using the <code>Encoding.UTF8.GetString()</code> method and then deserialize the JSON string into the strongly-typed object using the <code>JsonSerializer.Deserialize()</code> method.</p>
<p>In addition, the caching key must be a <code>string</code> value.</p>
<p>To make it easier to convert the data to and from <code>byte[]</code>, the <code>IDistributedCache</code> interface has a few extension methods as follows:</p>
<ul>
<li><code>SetStringAsync</code> and <code>SetString</code>: These two methods can save <code>string</code> values directly</li>
<li><code>GetStringAsync</code> and <code>GetString</code>: These two methods can read <code>string</code> values directly</li>
</ul>
<p>To remove a cache entry, we can use the <code>RemoveAsync()</code> method or <code>Remove()</code> method. As we mentioned before, using the asynchronous versions of these methods is preferred.</p>
<p>Run the<a id="_idIndexMarker1727"/> application <a id="_idIndexMarker1728"/>and send some requests to the <code>Categories/favorites/1</code> endpoint. You will see that the logs show the first response was from the database and the subsequent responses were from the distributed cache:</p>
<pre class="console">
info: CachingDemo.Services.CategoryService[0]      Getting favorites categories from the database
info: CachingDemo.Services.CategoryService[0]
      Getting favorites categories from distributed cache</pre>
<p>You can use the <code>redis-cli</code> to examine the cached data. Run the following command to get the keys:</p>
<pre class="console">
127.0.0.1:6379&gt; keys *</pre> <p>The output should look as follows:</p>
<pre class="console">
1) "CachingDemo_FavoritesCategories:1"</pre> <p>Then, use the <code>HGETALL</code> command to show the cached data:</p>
<pre class="console">
127.0.0.1:6379&gt; hgetall CachingDemo_FavoritesCategories:1</pre> <p>Note that you cannot use the <code>GET</code> command here because it is used to retrieve the string values only. The categories data is stored as <code>hash</code> in Redis, so we need to use the <code>HGETALL</code> command.</p>
<p>The output should look as follows, including all the fields of the cached entry:</p>
<pre class="console">
1) "absexp"2) "638322378838137428"
3) "sldexp"
4) "6000000000"
5) "data"
6) " [{\"Id\":1,\"Name\":\"Toys\",\"Description\":\"Soft toys, action figures, dolls, and puzzles\"},{\"Id\":2,\"Name\":\"Electronics\",\"Description\":\"Smartphones, tablets, laptops, and smartwatches\"},{\"Id\":3,\"Name\":\"Clothing\",\"Description\":\"Shirts, pants, dresses, and shoes\"}]"</pre>
<p>Using a<a id="_idIndexMarker1729"/> distributed cache <a id="_idIndexMarker1730"/>can help make applications more scalable by allowing cached data to be shared across multiple instances. However, this does come with the potential cost of increased latency due to the extra network I/O required. Careful consideration should be taken when deciding whether to use a distributed cache.</p>
<p>The <code>IDistributedCache</code> interface does not have the <code>GetOrCreateAsync()</code> method. If the cached data is not found, the application still needs to query the database. To solve this problem, we can implement our own <code>GetOrCreateAsync()</code> method. Create an extension method for the <code>IDistributedCache</code> interface:</p>
<pre class="source-code">
public static class DistributedCacheExtension{
    public static async Task&lt;T?&gt; GetOrCreateAsync&lt;T&gt;(this IDistributedCache cache, string key, Func&lt;Task&lt;T?&gt;&gt; createAsync, DistributedCacheEntryOptions? options = null)
    {
        // Get the value from the cache.
        // If the value is found, return it.
        var value = await cache.GetStringAsync(key);
        if (!string.IsNullOrWhiteSpace(value))
        {
            return JsonSerializer.Deserialize&lt;T&gt;(value);
        }
        // If the value is not cached, then create it using the provided function.
        var result = await createAsync();
        var json = JsonSerializer.Serialize(result);
        await cache.SetStringAsync(key, json, options ?? new DistributedCacheEntryOptions());
        return result;
    }
}</pre>
<p>Now<a id="_idIndexMarker1731"/> the <code>GetFavoritesCategoriesAsync</code> method can be<a id="_idIndexMarker1732"/> updated as follows:</p>
<pre class="source-code">
public async Task&lt;IEnumerable&lt;Category&gt;?&gt; GetFavoritesCategoriesAsync(int userId){
    var cacheKey = $"{CacheKeys.FavoritesCategories}:{userId}";
    var cacheEntryOptions = new DistributedCacheEntryOptions
    {
        SlidingExpiration = TimeSpan.FromMinutes(10),
        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
    };
    var favoritesCategories = await distributedCache.GetOrCreateAsync(cacheKey, async () =&gt;
    {
        // Simulate a database query
        logger.LogInformation("Getting favorites categories from the database");
        var categories = FavoritesCategories[userId];
        await Task.Delay(2000);
        return categories;
    }, cacheEntryOptions);
    return favoritesCategories?.AsEnumerable();
}</pre>
<p>If the <a id="_idIndexMarker1733"/>category is <a id="_idIndexMarker1734"/>not found in the database, the <code>GetOrCreateAsync()</code> method will return <code>null</code> and cache the <code>null</code> value for future requests. In this way, the application will not query the database again and again.</p>
<p>The following table shows the differences between in-memory caching and distributed caching:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-8">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">In-memory caching</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Distributed caching</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Cache data in the memory of the application</p>
</td>
<td class="No-Table-Style">
<p>Cache data in a shared storage</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Suitable for applications that are deployed with a single instance</p>
</td>
<td class="No-Table-Style">
<p>Suitable for applications that are deployed with multiple instances</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>The cached data is lost when the application restarts</p>
</td>
<td class="No-Table-Style">
<p>The cached data is not lost when the application restarts</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>The caching keys can be any <code>object</code></p>
</td>
<td class="No-Table-Style">
<p>The caching keys must be <code>string</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>The cached data value can be any strongly-typed object</p>
</td>
<td class="No-Table-Style">
<p>The cached data is persisted as <code>byte[]</code> and may need serialization and deserialization.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.2 – The differences between in-memory caching and distributed caching</p>
<p>If you would like to<a id="_idIndexMarker1735"/> use other distributed cache, you can install other packages such <a id="_idIndexMarker1736"/>as the following:</p>
<ul>
<li><code>dotnet add </code><code>package Microsoft.Extensions.Caching.SqlServer</code></li>
<li><code>dotnet add </code><code>package NCache.Microsoft.Extensions.Caching.OpenSource</code></li>
</ul>
<p>Please refer to their official documentation for more details<a id="_idTextAnchor655"/>.</p>
<h2 id="_idParaDest-345"><a id="_idTextAnchor656"/>Response caching</h2>
<p>Response caching<a id="_idIndexMarker1737"/> is defined in the RFC 9111 specification (<a href="https://www.rfc-editor.org/rfc/rfc9111">https://www.rfc-editor.org/rfc/rfc9111</a>). It uses the HTTP header <code>cache-control</code> to specify the caching <a id="_idIndexMarker1738"/>behavior. The clients (such as browsers) and immediate proxies (such as CDNs and gateways), can use the <code>cache-control</code> header to determine whether to cache the response and how long to cache it for.</p>
<p>The <code>cache-control</code> header<a id="_idIndexMarker1739"/> has several directives as<a id="_idIndexMarker1740"/> follows:</p>
<ul>
<li><code>public</code>: The response can be cached by the clients and the intermediate proxies.</li>
<li><code>private</code>: The response can be cached by the clients only. A shared cache, such as CDN, must not cache the response.</li>
<li><code>no-cache</code>: For<a id="_idIndexMarker1741"/> requests, the clients must send the request to the server for validation before using a cached copy of the response. For responses, the clients must not use a cached copy of the response without successful validation on the server.</li>
<li><code>no-store</code>: For requests, the clients must not store any part of the request. For responses, the clients must not store any part of the response.</li>
<li><code>max-age</code>: This is the maximum age of the response in seconds. The clients can use the cached copy of the response if it is not expired. For example, <code>max-age=3600</code> means the response can be cached for one hour.</li>
</ul>
<p>We<a id="_idIndexMarker1742"/> can <a id="_idIndexMarker1743"/>use the <code>ResponseCache</code> attribute to specify the caching behavior of the endpoint. Here is an example:</p>
<pre class="source-code">
[HttpGet][ResponseCache(Duration = 60)]
public async Task&lt;ActionResult&lt;IEnumerable&lt;Category&gt;&gt;&gt; Get()
{
    var result = await categoryService.GetCategoriesAsync();
    return Ok(result);
}</pre>
<p>In the preceding code, we use the <code>ResponseCache</code> attribute on the controller to specify the caching behavior of the endpoint. <code>Duration = 60</code> means the response can be cached for 60 seconds.</p>
<p>Run the application and test the <code>/Categories</code> endpoint in the Swagger UI. You will see the <code>cache-control</code> header in the response, as shown here:</p>
<pre class="console">
cache-control: public,max-age=60content-type: application/json; charset=utf-8
date: Sat,07 Oct 2023 03:56:06 GMT
server: Kestrel</pre>
<p>If you <a id="_idIndexMarker1744"/>resubmit the request, the browser will use the cached <a id="_idIndexMarker1745"/>version of the response without sending the request to the server. This is managed by the <code>max-age</code> directive in the <code>cache-control</code> header. After 60 seconds have elapsed, the browser will send the request to the server for validation if the request is resubmitted.</p>
<p>The HTTP-based response caching takes effect on the client side. If multiple clients send requests to the same endpoint, each request will cause the server to handle the request and generate the response. ASP.NET Core provides a server-side response caching middleware to cache the response on the server side. However, this middleware has a few limitations.</p>
<ul>
<li>It only supports the <code>GET</code> and <code>HEAD</code> requests and it does not support requests that contain the <code>Authorization</code>, <code>Set-Cookie</code> headers, and so on.</li>
<li>You cannot invalidate the client-side cached response on the server side when the data is changed.</li>
<li>Additionally, most browsers, such as Chrome and Edge, automatically send requests with the <code>cache-control: max-age=0</code> header, which disables response caching on the client side. As a result, the server will also respect this header and disable server-side response caching.</li>
</ul>
<p>This book does not cover the middleware mentioned; for more information, please refer to the documentation at <a href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware">https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware</a>. We will, however, introduce output caching, which is available in ASP.NET Core 7.0 and later versions. This middleware resolves some of the limitations of the server-side response caching m<a id="_idTextAnchor657"/>iddleware.</p>
<h2 id="_idParaDest-346"><a id="_idTextAnchor658"/>Output caching</h2>
<p>In ASP.NET Core 7.0, Microsoft introduced the output caching middleware. This middleware works in a <a id="_idIndexMarker1746"/>similar way to the server-side response caching<a id="_idIndexMarker1747"/> middleware, but it has<a id="_idIndexMarker1748"/> a few advantages:</p>
<ul>
<li>It configures the caching behavior on the server side, so the client HTTP caching configuration does not affect the output caching configuration.</li>
<li>It has the capability to invalidate the cached response on the server side when the data is changed.</li>
<li>It can use external cache stores, such as Redis, to store the cached response.</li>
<li>It can return a <code>304 Not Modified</code> response to the client when the cached response is not modified. This can save the network bandwidth.</li>
</ul>
<p>However, the output caching middleware<a id="_idIndexMarker1749"/> also has similar limitations to the response caching middleware:</p>
<ul>
<li>It only supports <code>GET</code> and <code>HEAD</code> requests with the <code>200 OK</code> status code</li>
<li>It does not support <code>Authorization</code> and <code>Set-Cookie</code> headers</li>
</ul>
<p>To enable output caching, we need to register the output caching middleware in the <code>Program</code> class:</p>
<pre class="source-code">
builder.Services.AddOutputCache(options =&gt;{
    options.AddBasePolicy(x =&gt; x.Cache());
});</pre>
<p>Then, we need to add the middleware to the HTTP request pipeline:</p>
<pre class="source-code">
app.UseOutputCache();</pre> <p>Next, apply the <code>OutputCache</code> attribute to the endpoints that need to be cached. For example, we can apply the <code>OutputCache</code> attribute to the <code>/</code><code>categories/{id}</code> endpoint:</p>
<pre class="source-code">
[HttpGet("{id}")][OutputCache]
public async Task&lt;ActionResult&lt;Category?&gt;&gt; Get(int id)
{
    var result = await categoryService.GetCategoryAsync(id);
    if (result is null)
    {
        return NotFound();
    }
    return Ok(result);
}</pre>
<p>The <code>GetOrCreateAsync()</code> method is shown as follows:</p>
<pre class="source-code">
public async Task&lt;Category?&gt; GetCategoryAsync(int id){
    // Simulate a database query
    logger.LogInformation($"Getting category with id {id} from the database");
    await Task.Delay(2000);
    return Categories.FirstOrDefault(c =&gt; c.Id == id);
}</pre>
<p>Similarly, we<a id="_idIndexMarker1750"/> use a <code>Task.Delay()</code> method to simulate the<a id="_idIndexMarker1751"/> database query. Run the application and test the <code>/categories/1</code> endpoint in the Swagger UI. You will see that the console log shows that the first response was from the database. The headers of the response look as follows:</p>
<pre class="console">
content-type: application/json; charset=utf-8date: Sat,07 Oct 2023 06:43:02 GMT
server: Kestrel</pre>
<p>Send the request again. You will not see the database query log in the console. The headers of the response look as follows:</p>
<pre class="console">
age: 5content-length: 87
content-type: application/json; charset=utf-8
date: Sat,07 Oct 2023 06:44:39 GMT
server: Kestrel</pre>
<p>You can <a id="_idIndexMarker1752"/>find that the headers of the response contain the <code>age</code> header, which indicates that the response is cached. The <code>age</code> header is the number of seconds since the response was generated.</p>
<p>By default, the <a id="_idIndexMarker1753"/>expiration time of the cached response is 60 seconds. After 60 seconds have elapsed, the next request will query the database again.</p>
<p>We can define different caching policies for different endpoints. Update the <code>AddOutputCache()</code> method as follows:</p>
<pre class="source-code">
builder.Services.AddOutputCache(options =&gt;{
    options.AddBasePolicy(x =&gt; x.Cache());
    options.AddPolicy("Expire600", x =&gt; x.Expire(TimeSpan.FromSeconds(600)));
    options.AddPolicy("Expire3600", x =&gt; x.Expire(TimeSpan.FromSeconds(3600)));
});</pre>
<p>In the preceding code, we added two caching policies. The first <code>Expire600</code> policy will expire the cached response after 10 minutes, and the second one will expire the cached response after 1 hour. Then, we can apply the <code>OutputCache</code> attribute to the endpoints as follows:</p>
<pre class="source-code">
[HttpGet("{id}")][OutputCache(PolicyName = "Expire600")]
public async Task&lt;ActionResult&lt;Category?&gt;&gt; Get(int id)
{
    // Omitted for brevity
}</pre>
<p>Now, the cached response will exp<a id="_idTextAnchor659"/>ire in 10 minutes.</p>
<h2 id="_idParaDest-347"><a id="_idTextAnchor660"/>What caching strategy should I use?</h2>
<p>Caching is a<a id="_idIndexMarker1754"/> useful tool for improving the performance of applications. In this section, we<a id="_idIndexMarker1755"/> introduced a couple of caching techniques, including in-memory caching, distributed caching, response caching, and output caching. Each caching technique has its suitable scenarios. We need to choose the proper caching technique based on the specific scenarios.</p>
<p>Response caching is relatively straightforward to implement; however, it is dependent on the client-side HTTP caching configuration. If the client-side HTTP caching is disabled, response caching will not work as intended. Output caching is more flexible and can be used independently of the client-side HTTP caching configuration. It does not need much effort to implement, but it has a few limitations.</p>
<p>In-memory caching is a fast and easy way to cache data in a single instance of the application. However, it needs session affinity to work properly if there are multiple instances of the application. Distributed caching supports multiple instances, but it needs extra network I/O to access the cache. So, we need to consider the trade-off between the performance and the scalability. If retrieving the data from the database is complex or needs expensive computation and the data is not often changed, we can use distributed caching to reduce the load on the database or the computation. Additionally, we can use in-memory caching and distributed caching together to leverage the advantages of both caching techniques. For example, we can query the data from the in-memory cache first, and if the data is not found, we can then query the distributed cache. Also, consider the expiration time of the cache entry. You may need various expiration policies for different data.</p>
<p>This section only introduces the basic concepts of caching in ASP.NET Core. To learn more about caching, please refer to the documentation at <a href="https://docs.microsoft.com/en-us/aspnet/core/p﻿erformance/caching/">https://docs.microsoft.com/en-us/aspnet/core/performance/caching/</a>.</p>
<h1 id="_idParaDest-348"><a id="_idTextAnchor662"/>Using HttpClientFactory to manage HttpClient instances</h1>
<p>.NET provides the <code>HttpClient</code> class for sending HTTP requests. However, there is some<a id="_idIndexMarker1756"/> confusion when using it. In the past, many developers would misuse the <code>using</code> statement to create a <code>HttpClient</code> instance, as it implements the <code>IDisposal</code> interface. This is not recommended, as the <code>HttpClient</code> class is designed to be reused for multiple requests. Creating a new instance for each request can exhaust the local socket ports.</p>
<p>To solve this problem, Microsoft introduced the <code>IHttpClientFactory</code> interface in ASP.NET Core 2.1. This interface simplifies the management of <code>HttpClient</code> instances. It allows us to use dependency injection to inject <code>HttpClient</code> instances into the application without worrying about the life cycle of the <code>HttpClient</code> instances. In this section, we will introduce how to use the <code>IHttpClientFactory</code> interface to manage <code>HttpClient</code> instances.</p>
<p>You can find the sample application for this section in the <code>samples/chapter15/HttpClientDemo</code> folder.</p>
<p>To demonstrate how to use the <code>IHttpClientFactory</code> interface, we need to have a web API application as the backend service. You can use any sample applications we have created in the previous chapters. In this section, we will use a fake API service: <code>https://jsonplaceholder.typicode.com/</code>. This is a free online REST API service that can be used for testing and prototyping. It provides a set of endpoints, such as <code>/posts</code>, <code>/comments</code>, <code>/albums</code>, <code>/photos</code>, <code>/todos</code>, and <code>/users</code>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">When you create C# models from JSON data, you can use the <strong class="bold">Paste JSON as Classes</strong> feature in Visual Studio. You can find this feature in the <strong class="bold">Edit</strong> <a id="_idTextAnchor663"/>| <strong class="bold">Paste </strong><strong class="bold">Special</strong> menu.</p>
<h2 id="_idParaDest-349"><a id="_idTextAnchor664"/>Creating a basic HttpClient instance</h2>
<p>The <code>IHttpClientFactory</code> interface provides an <code>AddHttpClient()</code> extension method to <a id="_idIndexMarker1757"/>register the <code>HttpClient</code> instances. Add the following code in the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddHttpClient();</pre> <p>Then, we can inject the <code>IHttpClientFactory</code> interface into the controller and use it to create a <code>HttpClient</code> instance:</p>
<pre class="source-code">
[ApiController][Route("[controller]")]
public class PostsController(IHttpClientFactory httpClientFactory) : ControllerBase
{
    [HttpGet]
    public async Task&lt;IActionResult&gt; Get()
    {
        var httpClient = httpClientFactory.CreateClient();
        var httpRequestMessage = new HttpRequestMessage
        {
            Method = HttpMethod.Get,
            RequestUri = new Uri("https://jsonplaceholder.typicode.com/posts")
        };
        var response = await httpClient.SendAsync(httpRequestMessage);
        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();
        var posts = JsonSerializerHelper.DeserializeWithCamelCase&lt;List&lt;Post&gt;&gt;(content);
        return Ok(posts);
    }
    // Omitted for brevity
}</pre>
<p>In the <a id="_idIndexMarker1758"/>preceding code, we use the <code>CreateClient()</code> method to create a <code>HttpClient</code> instance. Then, we create an <code>HttpRequestMessage</code> instance and use the <code>SendAsync()</code> method to send the HTTP request. The <code>EnsureSuccessStatusCode()</code> method is used to ensure the response is successful. If the response fails, an exception will be thrown. The <code>ReadAsStringAsync()</code> method is used to read the response content as a string. Finally, we use the <code>JsonSerializerHelper</code> class to deserialize the JSON string into a list of <code>Post</code> objects.</p>
<p>The <code>JsonSerializerHelper</code> class is defined as follows:</p>
<pre class="source-code">
public static class JsonSerializerHelper{
    public static string SerializeWithCamelCase&lt;T&gt;(T value)
    {
        var options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DictionaryKeyPolicy = JsonNamingPolicy.CamelCase,
        };
        return JsonSerializer.Serialize(value, options);
    }
    public static T? DeserializeWithCamelCase&lt;T&gt;(string json)
    {
        var options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DictionaryKeyPolicy = JsonNamingPolicy.CamelCase,
        };
        return JsonSerializer.Deserialize&lt;T&gt;(json, options);
    }
}</pre>
<p>This is<a id="_idIndexMarker1759"/> because the JSON data returned by the API uses the camel case naming convention. We need to use the <code>JsonNamingPolicy.CamelCase</code> property to deserialize the JSON string into the strongly-typed object. We can pass a <code>JsonSerializerOptions</code> instance to the <code>JsonSerializer.Serialize()</code> and <code>JsonSerializer.Deserialize()</code> methods to specify the serialization and deserialization options. Using a helper method can simplify the code.</p>
<p>The <code>HttpRequestMessage</code> class is a low-level class that represents an HTTP request message. In most cases, we can use the <code>GetStringAsync()</code> method to send a <code>GET</code> request and get the response content as a string, as follows:</p>
<pre class="source-code">
var content = await httpClient.GetStringAsync("https://jsonplaceholder.typicode.com/posts");var posts = JsonSerializerHelper.DeserializeWithCamelCase&lt;List&lt;Post&gt;&gt;(content);
return Ok(posts);</pre>
<p>The <a id="_idIndexMarker1760"/>code to send a <code>POST</code> request is similar:</p>
<pre class="source-code">
[HttpPost]public async Task&lt;IActionResult&gt; Post(Post post)
{
    var httpClient = httpClientFactory.CreateClient();
    var json = JsonSerializer.Serialize(post);
    var data = new StringContent(json, Encoding.UTF8, "application/json");
    var response = await httpClient.PostAsync("https://jsonplaceholder.typicode.com/posts", data);
    var content = await response.Content.ReadAsStringAsync();
    var newPost = JsonSerializer.Deserialize&lt;Post&gt;(content);
    return Ok(newPost);
}</pre>
<p>To send a <code>POST</code> request, we need to serialize the <code>Post</code> object to a JSON string and then convert the JSON string into a <code>StringContent</code> instance. Then, we can use the <code>PostAsync()</code> method to send the request.</p>
<p>The <code>StringContent</code> class is a concrete implementation of the <code>HttpContent</code> class. The <code>HttpContent</code> class is an abstract class that represents the content of an HTTP message. It has the following concrete implementations:</p>
<ul>
<li><code>ByteArrayContent</code>: Represents an <code>HttpContent</code> instance based on a byte array</li>
<li><code>FormUrlEncodedContent</code>: Represents a collection of name/value pairs encoded using <code>application/x-www-form-urlencoded</code> MIME type</li>
<li><code>MultipartContent</code>: Represents a collection of <code>HttpContent</code> instances serialized using <code>multipart/*</code> MIME type</li>
<li><code>StreamContent</code>: Represents an <code>HttpContent</code> instance based on a stream</li>
<li><code>StringContent</code>: Represents an <code>HttpContent</code> instance based on a string</li>
</ul>
<p>The <code>HttpClient</code> class has a few methods and extension methods to send HTTP requests. The following<a id="_idIndexMarker1761"/> table shows the commonly used methods:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Method name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>SendAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends an HTTP request to the specified URI. This method can send any HTTP request.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>GET</code> request to the specified URI.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetStringAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>GET</code> request to the specified URI. This method returns the response body as a string.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetByteArrayAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>GET</code> request to the specified URI. This method returns the response body as a byte array.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetStreamAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>GET</code> request to the specified URI. This method returns the response body as a stream.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetFromJsonAsync&lt;T&gt;()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>GET</code> request to the specified URI. This method returns the response body as a strongly-typed object.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>GetFromJsonAsAsyncEnumerable&lt;T&gt;()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>GET</code> request to the specified URI. This method returns the response body as an <code>IAsyncEnumerable&lt;T&gt;</code> instance.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PostAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>POST</code> request to the specified URI.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PostAsJsonAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>POST</code> request to the specified URI. The request body is serialized as JSON.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PutAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>PUT</code> request to the specified URI.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PutAsJsonAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>PUT</code> request to the specified URI. The request body is serialized as JSON.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DeleteAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>DELETE</code> request to the specified URI.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DeleteFromJsonAsync&lt;T&gt;()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>DELETE</code> request to the specified URI. This method returns the response body as a strongly-typed object.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>PatchAsync()</code></p>
</td>
<td class="No-Table-Style">
<p>Sends a <code>PATCH</code> request to the specified URI.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor665"/>Table 15.3 – The commonly used methods of the HttpClient class</p>
<p>When<a id="_idIndexMarker1762"/> we use the <code>HttpClient</code> instance created by the <code>IHttpClientFactory</code> interface, we need to specify the request URL. We can set the base address of the <code>HttpClient</code> instance when registering the <code>HttpClient</code> instance. Update the <code>AddHttpClient()</code> method in the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddHttpClient(client =&gt;{
    client.BaseAddress = new Uri("https://jsonplaceholder.typicode.com/");
    // You can set more options like the default request headers, timeout, and so on.
});</pre>
<p>Then, we do not need to specify the base address when sending the HTTP request. However, what if we need to send requests to multiple endpoints with different base addresses? Let us see how to solve this problem in the next section.</p>
<h2 id="_idParaDest-350"><a id="_idTextAnchor666"/>Named HttpClient instances</h2>
<p>It is<a id="_idIndexMarker1763"/> tedious to specify the base address of the <code>HttpClient</code> instance or the request URI every time. We can specify some common settings when registering the <code>HttpClient</code> instance. For example, we can specify the base address of the <code>HttpClient</code> instance as follows:</p>
<pre class="source-code">
builder.Services.AddHttpClient("JsonPlaceholder", client =&gt;{
    client.BaseAddress = new Uri("https://jsonplaceholder.typicode.com/");
    // You can set more options like the default request headers, timeout, etc.
    client.DefaultRequestHeaders.Add(HeaderNames.Accept, "application/json");
    client.DefaultRequestHeaders.Add(HeaderNames.UserAgent, "HttpClientDemo");
});</pre>
<p>In the <a id="_idIndexMarker1764"/>preceding code, we register the <code>HttpClient</code> instance with the name <code>JsonPlaceholder</code> and specify the base address of the <code>HttpClient</code> instance. We can also set the default request headers, such as the <code>Accept</code> and <code>User-Agent</code> headers. Then, we can use the <code>JsonPlaceholder</code> name to inject the <code>HttpClient</code> instance into the controller:</p>
<pre class="source-code">
var httpClient = httpClientFactory.CreateClient("JsonPlaceholder");</pre> <p>This is called named <code>HttpClient</code> instances, which allows us to register multiple <code>HttpClient</code> instances with different names. This is useful when we need multiple <code>HttpClient</code> instances with different configurations. By using the name, we can easily access the desired instanc<a id="_idTextAnchor667"/>e.</p>
<h2 id="_idParaDest-351"><a id="_idTextAnchor668"/>Typed HttpClient instances</h2>
<p>To better<a id="_idIndexMarker1765"/> encapsulate the <code>HttpClient</code> instances, we can create a typed <code>HttpClient</code> instance for a specific type. For example, we can create a typed <code>HttpClient</code> instance for the <code>User</code> type:</p>
<pre class="source-code">
public class UserService{
    private readonly HttpClient _httpClient;
    private readonly JsonSerializerOptions _jsonSerializerOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
    };
    public UserService(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.BaseAddress = new Uri("https://jsonplaceholder.typicode.com/");
        _httpClient.DefaultRequestHeaders.Add(HeaderNames.Accept, "application/json");
        _httpClient.DefaultRequestHeaders.Add(HeaderNames.UserAgent, "HttpClientDemo");
    }
    public Task&lt;List&lt;User&gt;?&gt; GetUsers()
    {
        return _httpClient.GetFromJsonAsync&lt;List&lt;User&gt;&gt;("users", _jsonSerializerOptions);
    }
    public async Task&lt;User?&gt; GetUser(int id)
    {
        return await _httpClient.GetFromJsonAsync&lt;User&gt;($"users/{id}", _jsonSerializerOptions);
    }
    // Omitted for brevity
}</pre>
<p>In the preceding<a id="_idIndexMarker1766"/> code, we create a <code>UserService</code> class to encapsulate the <code>HttpClient</code> instance. Register the <code>UserService</code> class in the <code>Program</code> class:</p>
<pre class="source-code">
builder.Services.AddHttpClient&lt;UserService&gt;();</pre> <p>Then, we can inject the <code>UserService</code> class into the controller:</p>
<pre class="source-code">
[ApiController][Route("[controller]")]
public class UsersController(UserService usersService) : ControllerBase
{
    [HttpGet]
    public async Task&lt;ActionResult&lt;List&lt;User&gt;&gt;&gt; Get()
    {
        var users = await usersService.GetUsers();
        return Ok(users);
    }
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;User&gt;&gt; Get(int id)
    {
        var user = await usersService.GetUser(id);
        if (user == null)
        {
            return NotFound();
        }
        return Ok(user);
    }
    // Omitted for brevity
}</pre>
<p>In the preceding<a id="_idIndexMarker1767"/> code, the controller does not need to know the details of the <code>HttpClient</code> instance. It only needs to call the methods of the <code>UserService</code> class. The code is much cleaner.</p>
<p>The <code>IHttpClientFactory</code> interface is the recommended way to manage <code>HttpClient</code> instances. It saves us from the tedious work of managing the lifetime of the <code>HttpClient</code> instances. It also allows us to configure the <code>HttpClient</code> instances in a centralized place. For more information, please refer to the documentation at <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requ﻿ests">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests</a>.</p>
<h1 id="_idParaDest-352"><a id="_idTextAnchor670"/>Summary</h1>
<p>In this chapter, we discussed common practices in ASP.NET Core web API development, such as HTTP status codes, asynchronous programming, pagination, response types, and API documentation. We also explored several caching techniques, including in-memory caching, distributed caching, response caching, and output caching. Each technique has its own advantages and disadvantages, so it is important to consider the trade-offs and choose the appropriate caching strategy for the given scenario. Additionally, we discussed the <code>IHttpClientFactory</code> interface, which simplifies the management of <code>HttpClient</code> instances and allows us to use dependency injection to inject <code>HttpClient</code> instances into the application without worrying about their life cycle.</p>
<p>In the next chapter, we will discuss how to handle errors in ASP.NET Core web API applications and how to monitor the applications using OpenTelemetry.</p>
</div>
</body></html>