<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-90" class="chapter-number"><a id="_idTextAnchor132"/>8</h1>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor133"/>Building and Executing Expressions</h1>
			<p>Expressions in C# are not just great to use as a means of capturing metadata and reason about code; you can also generate expression trees, either based on code represented as lambdas, as we saw in <a href="B19418_07.xhtml#_idTextAnchor118"><span class="No-Break"><em class="ita ic">Chapter 7</em></span></a>, <em class="ita ic">Reasoning about Expressions</em>, or by programmatically adding the different expression node <span class="No-Break">types yourself.</span></p>
			<p>The expressions that you build can then be executed. And with the breadth of capabilities offered with expressions, they’re almost as powerful as generating intermediate language code, as we saw in <a href="B19418_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="ita ic">Chapter 6</em></span></a>, <em class="ita ic">Dynamic Proxy Generation</em>. Since every expression is code that sits inside the specific expression that is executed and performs the task of the expression, you can’t expect the same level of performance as with generating intermediate language that runs natively on the .NET runtime. So, it depends on your use case whether or not you should pick expression generation over <span class="No-Break">proxy generation.</span></p>
			<p>In this chapter, we will look into how we can leverage expressions to express our intent and execute them, and hopefully get some inspiration as to what they can be <span class="No-Break">useful for.</span></p>
			<p>We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating your <span class="No-Break">own expressions</span></li>
				<li>Creating expressions as delegates and <span class="No-Break">executing them</span></li>
				<li>Creating a <span class="No-Break">query engine</span></li>
			</ul>
			<p>From this chapter, you should understand how expression trees are constructed and how you can leverage them to generate logic dynamically that can then <span class="No-Break">be executed.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor134"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8</a>) and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor135"/>Creating your own expressions</h1>
			<p>Expressions are pretty much as powerful and capable as the .NET runtime. That means that we <a id="_idIndexMarker273"/>can express all operations that the intermediate language holds and eventually the runtime executes. Constructs are very different from the intermediate language, as we saw in <a href="B19418_07.xhtml#_idTextAnchor118"><span class="No-Break"><em class="ita ic">Chapter 7</em></span></a>, <em class="ita ic">Reasoning about Expressions</em>. They’re all focused around a tree structure with left and right expressions representing the nodes in <span class="No-Break">the tree.</span></p>
			<p>With expressions, we don’t necessarily need to limit ourselves to using them as a means to filter data, but we could in fact use them to hold logic that performs operations. Since they are just as powerful as the intermediate language, we could go and generate very complex <span class="No-Break">expression trees.</span></p>
			<p>But with great power comes great responsibility. Even though this is possible, it doesn’t mean it’s necessarily a good idea. The structures can be hard to understand and debug, so I would recommend not going all in and treating it as a new <span class="No-Break">programming language.</span></p>
			<p>Let’s say we have a type we want to manipulate the property of. For simplicity, let’s make our type a simple type with a string property that we want <span class="No-Break">to set:</span></p>
			<pre class="source-code">
public class MyType
{
    public string StringProperty { get; set; } =
      String.Empty;
}</pre>
			<p>For this sample, we want to manipulate the <strong class="source-in ine">StringProperty</strong> property, so we’re making it a <strong class="source-in ine">class</strong> rather than a <strong class="source-in ine">record</strong>, enabling us to manipulate <span class="No-Break">its state.</span></p>
			<p>To create an expression representing the property we need to build, start off with something that represents the type the property belongs to. The owning type will also be represented by an expression. For this sample, we don’t want the expression to create an instance of the <strong class="source-in ine">MyType</strong> type but rather manipulate an existing one. The instance it will be working on is represented by a parameter for <span class="No-Break">the expression:</span></p>
			<pre class="source-code">
var parameter = Expression.Parameter(typeof(MyType));</pre>
			<p>The parameter takes the type of the parameter. But you can also give it a name with one of the overloads of the <strong class="source-in ine">.Parameter()</strong> method, which can be very useful for debugging information if one has <span class="No-Break">multiple parameters.</span></p>
			<p>For us to work with the property, we need to use C# reflection to get the <strong class="source-in ine">PropertyInfo</strong> for the property we want <span class="No-Break">to manipulate:</span></p>
			<pre class="source-code">
var property = typeof(MyType).GetProperty
  (nameof(MyType.StringProperty))!;</pre>
			<p>With the parameter representing the instance, we will manipulate the actual property. We can now create an expression representing the property on <span class="No-Break">the type:</span></p>
			<pre class="source-code">
var propertyExpression = Expression.Property
  (parameter,property);</pre>
			<p>The last thing <a id="_idIndexMarker274"/>we want to do is then to do the actual assignment. For this, we use the <span class="No-Break"><strong class="source-in ine">Expression.Assign()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
var assignExpression = Expression.Assign(
    propertyExpression,
    Expression.Constant("Hello world"));</pre>
			<p>The <strong class="source-in ine">Expression.Assign()</strong> method takes the left-hand expression representing the target while the right-hand expression is the source. In the code, we assign it a constant of <span class="No-Break"><strong class="source-in ine">Hello world</strong></span><span class="No-Break">.</span></p>
			<p>Obviously, this is a very simple sample and doesn’t really do much. You can really go to town with expressions and leverage things such as <strong class="source-in ine">Expression.IfThen()</strong> and <strong class="source-in ine">Expression.IfElse()</strong> for <strong class="source-in ine">if</strong>/<strong class="source-in ine">else</strong> statements and you can even go and do <strong class="source-in ine">Expression.Call()</strong> to invoke methods, passing along arguments and dealing with the result. Results can be manipulated with things such as <strong class="source-in ine">Expression.Add()</strong> and <strong class="source-in ine">Expression.Subtract()</strong>. Anything you can imagine can be done. For this book, we’ll just keep it simple with regard to building expressions <span class="No-Break">representing logic.</span></p>
			<p>Expressions aren’t really useful unless we can invoke them and get the result. What we want to do is build out the expression tree we want and then be able to quite easily call them with standard <span class="No-Break">C# code<a id="_idTextAnchor136"/>.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor137"/>Creating expressions as delegates and executing them</h1>
			<p>We can think of expressions as methods or functions we can call. They might have parameters <a id="_idIndexMarker275"/>or not and they might return results or not. We can represent the expressions as either <strong class="source-in ine">Action</strong> or <strong class="source-in ine">Func</strong>. Both are delegate types found in the <strong class="source-in ine">System</strong> namespace. <strong class="source-in ine">Action</strong> represents a parameter-less action that can, if you need to, return results. While <strong class="source-in ine">Func</strong> represents a function that <a id="_idIndexMarker276"/>has one or more parameters and can return a result. Both of these delegate types can take generic parameters representing the input parameter types and the <span class="No-Break">result type.</span></p>
			<p>Delegates are basically just representations of methods. They define a callable signature. We can invoke delegates as <span class="No-Break">methods directly.</span></p>
			<p>With expressions, we can turn them into a callable expression. This is done through <strong class="source-in ine">Expression.Lambda()</strong>. Let’s build on the property assign expression we <span class="No-Break">had earlier:</span></p>
			<pre class="source-code">
var parameter = Expression.Parameter(typeof(MyType));
var property = typeof(MyType).GetProperty
  (nameof(MyType.StringProperty))!;
var propertyExpression = Expression.Property
  (parameter,property);
var assignExpression = Expression.Assign(
    propertyExpression,
    Expression.Constant("Hello world"));</pre>
			<p>We can create the <span class="No-Break">following lambda:</span></p>
			<pre class="source-code">
var lambdaExpression = Expression.Lambda&lt;Action&lt;MyType&gt;&gt;
  (assignExpression, parameter);</pre>
			<p>The <strong class="source-in ine">Expression.Lambda()</strong> method takes a generic parameter – the type of delegate. This delegate can be whatever delegate type you want – your own custom delegate or just use either <strong class="source-in ine">Action</strong> or <strong class="source-in ine">Func</strong>. For this example, we’ll use <strong class="source-in ine">Action&lt;MyType&gt;</strong> since we are going to just call the expression and it will manipulate the instance we give it. We pass along the expression representing the assignment of the value and then the definition of <span class="No-Break">the parameter.</span></p>
			<p>With the lambda expression in place, we can compile the expression down to a callable delegate and <span class="No-Break">call it:</span></p>
			<pre class="source-code">
var expressionAction = lambdaExpression.Compile();
var instance = new MyType();
expressionAction(instance);
Console.WriteLine(instance.StringProperty);</pre>
			<p>The code calls the <strong class="source-in ine">.Compile()</strong> method, which will then compile the expression down into <a id="_idIndexMarker277"/>a delegate we can invoke directly. It creates <a id="_idIndexMarker278"/>an instance of the <strong class="source-in ine">MyType</strong> type and passes it along to the delegate. Running the program, you should now see <span class="No-Break">the following:</span></p>
			<pre class="console">
Hello world</pre>
			<p>This is pretty straightforward and this example probably doesn’t show the <span class="No-Break">full poten<a id="_idTextAnchor138"/>tial.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor139"/>Creating a query engine</h1>
			<p>Let’s switch gears a little bit and increase the complexity a couple of levels and make it a little bit more relevant. One thing we could use expressions for is as a way to do dynamic <a id="_idIndexMarker279"/>querying of data. Some applications might want to even give the end user the ability to create arbitrary queries for your data. I’ve worked on solutions that offered this type of power to the end user, which can be a tough problem to solve if you’re providing a flexible query system for the end user without something such as expressions. I’ve seen solutions that basically just expose SQL directly to the end user instead of trying to tackle this problem. Giving this level of power to the end user can cause problems in the future. What you end up doing is completely obliterating all abstractions between your data storage and your end users. Good luck changing technologies or supporting multiple data storage mechanisms. But luckily, we have the power of expressions in our hands, giving us the opportunity to create an abstraction that puts us in the pit <span class="No-Break">of success.</span></p>
			<p>Expressions, as discussed in <a href="B19418_07.xhtml#_idTextAnchor118"><span class="No-Break"><em class="ita ic">Chapter 7</em></span></a>, <em class="ita ic">Reasoning about Expressions</em>, are disconnected from how they are translated for execution for the target data source. As long as we keep our expression trees simple enough, it should be possible to execute them optimally for the <span class="No-Break">data source.</span></p>
			<p>Building out an <a id="_idIndexMarker280"/>interactive query user interface is involved, so for this book, let’s make it a bit more developer-centric and make our query interface a JSON document. We want to create a data store that can hold data with the capability of being queried with a defined <span class="No-Break">query la<a id="_idTextAnchor140"/>nguage.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor141"/>A MongoDB-like database</h2>
			<p>Let’s build something that resembles a document database. MongoDB can be a good blueprint for this. Obviously, we’re not going to be building a fully capable document database but <a id="_idIndexMarker281"/>will use the characteristics of one and also be inspired <span class="No-Break">by them.</span></p>
			<p>MongoDB has <a id="_idIndexMarker282"/>a query language that is very much like JSON, meaning that you construct the different clauses as key/value expressions. Let’s say we have a document in JSON that looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{ "FirstName": "Jane", "LastName": "Doe", "Age": 57 }</pre>
			<p>With a MongoDB-like syntax, we can do a query that does an equals match for the <strong class="source-in ine">LastName</strong> property <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
{
    "LastName": "Doe"
}</pre>
			<p>To add more properties that needs to match – a typical <strong class="bo d">And</strong> operation – you just simply add another property as a key/value with the value you want it <span class="No-Break">to be:</span></p>
			<pre class="source-code">
{
    "LastName": "Doe",
    "Age": 57
}</pre>
			<p>Sometimes you have <strong class="bo d">Or</strong> statements, saying <em class="ita ic">this</em> or <em class="ita ic">this</em>, with MongoDB that would be expressed <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
{
    "LastName": "Doe",
    "$or": [
        {
            "Age": 57
        }
    ]
}</pre>
			<p>If you want <a id="_idIndexMarker283"/>to do queries that need a value to be greater <a id="_idIndexMarker284"/>than, less than, or similar to, you would need an object structure for the <span class="No-Break">right-hand side:</span></p>
			<pre class="source-code">
{
    "Age": {
        "$gt": 50
    }
}</pre>
			<p>As you can see, in MongoDB, keywords are prefixed with <strong class="source-in ine">$</strong>. We’re not going to implement them all, but just a few – enough to make <span class="No-Break">it i<a id="_idTextAnchor142"/>nteresting.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor143"/>Building a simple query engine</h2>
			<p>With the requirements in place, we’re now ready to start building out the engine that will be <a id="_idIndexMarker285"/>able to parse queries and create expressions that we can call <span class="No-Break">from code.</span></p>
			<p>Start by creating a folder called <strong class="source-in ine">Chapter8</strong>. Change into this folder in your command-line interface and create a new <span class="No-Break">console project:</span></p>
			<pre class="console">
dotnet new console</pre>
			<p>Add a file called <strong class="source-in ine">QueryParser.cs</strong>. Add the following to <span class="No-Break">the file:</span></p>
			<pre class="source-code">
using System.Linq.Expressions;
using System.Text.Json;
namespace Chapter8;
public static class QueryParser
{
    static readonly ParameterExpression
      _dictionaryParameter = Expression.Parameter(typeof
      (IDictionary&lt;string, object&gt;), "input");
}</pre>
			<p>The code adds <a id="_idIndexMarker286"/>the namespaces we’re going to need for this to work and then adds a class that holds, for now, a representation of the parameter we’re going to pass into the query evaluation expression that we will have at <span class="No-Break">the end.</span></p>
			<p>One of the characteristics of document databases is that, by default, they don’t have a definition of the shape of objects being put into them, unlike a SQL database, which has a table definition with columns. To mimic that behavior, you’re going to be using a key/value dictionary represented as <strong class="source-in ine">IDictionary&lt;string, object&gt;</strong>. This is the parameter of <span class="No-Break">the expression.</span></p>
			<p>The query expressions will have the <span class="No-Break">following structure:</span></p>
			<pre class="source-code">
left-hand (operand) right-hand</pre>
			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
LastName equals Doe</pre>
			<p>That means we need to build the correct left value expression and right value expression. Add the following method to the <span class="No-Break"><strong class="source-in ine">QueryParser</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
static Expression GetLeftValueExpression(JsonProperty
  parentProperty, JsonProperty property)
{
    var keyParam =
      Expression.Constant(parentProperty.Name);
    var indexer = typeof(IDictionary&lt;string,
      object&gt;).GetProperty("Item")!;
    var indexerExpr = Expression.Property(
      _dictionaryParameter, indexer, keyParam);
    return property.Value.ValueKind switch
    {
        JsonValueKind.Number =&gt;
          Expression.Unbox(indexerExpr, typeof(int)),
        JsonValueKind.String =&gt;
          Expression.TypeAs(indexerExpr, typeof(string)),
        JsonValueKind.True or JsonValueKind.False =&gt;
          Expression.TypeAs(indexerExpr, typeof(bool)),
        _ =&gt; indexerExpr
    };
}</pre>
			<p>The code is based <a id="_idIndexMarker287"/>on the fact that your query is coming in as a JSON construct. It’s built for recursion, which is why it takes a <strong class="source-in ine">parentProperty</strong> and a <strong class="source-in ine">property</strong>. This is to support more than the <strong class="bo d">equals</strong> operand and support the nested <strong class="bo d">greater than</strong> type of operands. At the top level, the <strong class="source-in ine">parentProperty</strong> and <strong class="source-in ine">property</strong> will be the same, while when we do the nested ones, we need the <strong class="source-in ine">parentProperty</strong> and not the <strong class="source-in ine">property</strong> in the nested expression as that represents the operand <span class="No-Break">and value.</span></p>
			<p>The first thing the code does is create an expression that accesses the dictionary. This is done by using the <strong class="source-in ine">Item</strong> property that exists on <strong class="source-in ine">IDictionary&lt;string, object&gt;</strong>. The <strong class="source-in ine">Item</strong> property is not a property you’ll see on the interface. It represents the indexer when you typically index using <strong class="source-in ine">["SomeString"]</strong>. Indexers are properties that take an argument. The code, therefore, sets up an <strong class="source-in ine">IndexerExpression</strong> by using one of the overloads of the <strong class="source-in ine">Expression.Property()</strong> method. It passes the indexer property and a constant that represents the property on <span class="No-Break">the document.</span></p>
			<p>The last thing the code needs to do is make sure the value being returned is of the correct type. Since we have <strong class="source-in ine">IDictionary&lt;string, object&gt;</strong>, the values are represented as <strong class="source-in ine">object</strong>. You do this to be able to use the different operands (<strong class="source-in ine">=</strong>, <strong class="source-in ine">&gt;</strong>, <strong class="source-in ine">&lt;</strong>). If you don’t do this, you’ll get an exception because it will not know how to deal with comparing <strong class="bo d">object</strong> to the actual type of the <span class="No-Break">right-hand expression.</span></p>
			<p>Numbers are <a id="_idIndexMarker288"/>value types and need to be unboxed, while strings and Booleans need to cast to their <span class="No-Break">actual type.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">JSON numbers are hardcoded to be an <strong class="source-in ine">int</strong>. This is just a simplification for this sample. Numbers could be more than that, such as <strong class="source-in ine">float</strong>, <strong class="source-in ine">double</strong>, <strong class="source-in ine">Int64</strong>, <span class="No-Break">and more.</span></p>
			<p>Now that you have your left-hand expression, you’ll need the <span class="No-Break">right-hand expression:</span></p>
			<pre class="source-code">
static Expression GetRightValueExpression(JsonProperty
  property)
{
    return property.Value.ValueKind switch
    {
        JsonValueKind.Number =&gt;
          Expression.Constant(property.Value.GetInt32()),
        JsonValueKind.String =&gt; Expression.Constant(
          (object)property.Value.GetString()!),
        JsonValueKind.True or JsonValueKind.False =&gt;
          Expression.Constant((object)property.Value
          .GetBoolean()),
        _ =&gt; Expression.Empty()
    };
}</pre>
			<p>The code creates constant expressions that get the value in the correct type. On the <strong class="source-in ine">JsonProperty</strong> type, the <strong class="source-in ine">Value</strong> property is the <strong class="source-in ine">JsonElement</strong> type. It has methods for getting the actual value in the type you’re expecting. Since the query engine is somewhat limited in types, it just supports <strong class="source-in ine">int</strong>, <strong class="source-in ine">string</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-in ine">bool</strong></span><span class="No-Break">.</span></p>
			<p>With the right-hand <a id="_idIndexMarker289"/>side also in place, you’re going to need something that builds on both the left- and right-hand expressions and puts them together as an expression you can use. The defined query capabilities include being able to do <strong class="bo d">greater than</strong>, <strong class="bo d">less than</strong>, and more and we have defined that as a complex object as the value in the key/value part of the query JSON. With that, you need a method that builds the <span class="No-Break">correct expressions.</span></p>
			<p>Add the following method to the <span class="No-Break"><strong class="source-in ine">QueryParser</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
static Expression GetNestedFilterExpression(JsonProperty
  property)
{
    Expression? currentExpression = null;
    foreach (var expressionProperty in
      property.Value.EnumerateObject())
    {
        var getValueExpression = GetLeftValueExpression(
          property, expressionProperty);
        var valueConstantExpression =
          GetRightValueExpression(expressionProperty);
        Expression comparisonExpression =
          expressionProperty.Name switch
        {
            "$lt" =&gt; Expression.LessThan(
              getValueExpression, valueConstantExpression),
            "$lte" =&gt; Expression.LessThanOrEqual(
              getValueExpression, valueConstantExpression),
            "$gt" =&gt; Expression.GreaterThan(
              getValueExpression, valueConstantExpression),
            "$gte" =&gt; Expression.GreaterThanOrEqual(
              getValueExpression, valueConstantExpression),
            _ =&gt; Expression.Empty()
        };
        if (currentExpression is not null)
        {
            currentExpression = Expression.And(
              currentExpression, comparisonExpression);
        }
        else
        {
            currentExpression = comparisonExpression;
        }
    }
    return currentExpression ?? Expression.Empty();
}</pre>
			<p>The code enumerates the object given and makes it possible to have more than one clause. It groups these as <strong class="bo d">And</strong> operations. It leverages the methods you created earlier to get the left- and right-hand expressions and then for each supported operand, uses these to create the correct <span class="No-Break">operand expression.</span></p>
			<p>Since the <strong class="source-in ine">GetNestedFilterExpression</strong> method is only dealing with the nested filter clauses based <a id="_idIndexMarker290"/>on an object, you need a method that will deal with the top-level clause and call into the nested one if it’s a <span class="No-Break">nested object:</span></p>
			<pre class="source-code">
static Expression GetFilterExpression(JsonProperty
  property)
{
    return property.Value.ValueKind switch
    {
        JsonValueKind.Object =&gt;
          GetNestedFilterExpression(property),
        _ =&gt; Expression.Equal(GetLeftValueExpression(
          property, property), GetRightValueExpression(
          property))
    };
}</pre>
			<p>Based on the kind of value, the code chooses to use the nested expression only if it’s an object representation. For everything else, it creates a simple <span class="No-Break"><strong class="bo d">equal</strong></span><span class="No-Break"> expression.</span></p>
			<p>Earlier, we discussed having the ability to do Or operations and not just And operations. Add the following method to the <span class="No-Break"><strong class="source-in ine">QueryParser</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
static Expression GetOrExpression(Expression expression,
  JsonProperty property)
{
   Foreach (var element in property.Value.EnumerateArray())
   {
       var elementExpression = GetQueryExpression(element);
       expression = Expression.OrElse(expression,
         elementExpression);
   }
   return expression;
}</pre>
			<p>We defined the Or expressions as an array of expressions. The code enumerates the value as an array and for each element, it calls <strong class="source-in ine">GetQueryExpression</strong> – the next method we’ll <a id="_idIndexMarker291"/>be needing. From the result, it creates an <strong class="source-in ine">OrElse</strong> expression. The reason for the <strong class="source-in ine">OrElse</strong> expression is that we only want to evaluate the Or if the prior expression evaluates <span class="No-Break">to </span><span class="No-Break"><strong class="source-in ine">false</strong></span><span class="No-Break">.</span></p>
			<p>Go ahead and add the following method to the <span class="No-Break"><strong class="source-in ine">QueryParser</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
static Expression GetQueryExpression(JsonElement element)
{
    Expression? currentExpression = null;
    foreach (var property in element.EnumerateObject())
    {
        Expression expression = property.Name switch
        {
            "$or" =&gt; GetOrExpression(currentExpression!,
              property),
            _ =&gt; GetFilterExpression(property)
        };
        if (currentExpression is not null &amp;&amp; expression is
          not BinaryExpression)
        {
            currentExpression = Expression.And(
              currentExpression, expression);
        }
        else
        {
            currentExpression = expression;
        }
    }
    return currentExpression ?? Expression.Empty();
}</pre>
			<p>Since the query JSON can consist of multiple statements, the code enumerates the object and evaluates <a id="_idIndexMarker292"/>each property. If it is an Or expression, it calls the <strong class="source-in ine">GetOrExpression</strong> method. Anything else goes to the <strong class="source-in ine">GetFilterExpression</strong>. This is the place you could be adding more operations. For each of the properties in the query, it will And <span class="No-Break">them together.</span></p>
			<p>With the <strong class="source-in ine">GetQueryExpression</strong> method in place, we have all the logic for the query engine in place. Now we need an entry point from <span class="No-Break">the outside.</span></p>
			<p>Add the following method to the <span class="No-Break"><strong class="source-in ine">QueryParser</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public static Expression&lt;Func&lt;IDictionary&lt;string, object&gt;,
  bool&gt;&gt; Parse(JsonDocument json)
{
    var element = json.RootElement;
    var query = GetQueryExpression(element);
    return Expression.Lambda&lt;Func&lt;IDictionary&lt;string,
      object&gt;, bool&gt;&gt;(query, _dictionaryParameter);
}</pre>
			<p>The <strong class="source-in ine">Parse</strong> method takes a JSON document representing the query and returns an expression that is meant to be used with single documents where each document is <strong class="source-in ine">IDictionary&lt;string, object&gt;</strong>. It calls into <strong class="source-in ine">GetQueryExpression</strong> to create the actual expression based on the root element of the JSON and then wraps the expression in <a id="_idIndexMarker293"/>a callable <strong class="bo d">lambda</strong> expression that takes a dictionary as <span class="No-Break">a parameter.</span></p>
			<p>Now that you <a id="_idIndexMarker294"/>have your query engine in place, it’s time to create some data and a query, and some code to test <span class="No-Break">it out.</span></p>
			<p>Add a file called <strong class="source-in ine">data.json</strong> and add the following or your own content <span class="No-Break">to it:</span></p>
			<pre class="source-code">
[
    { "FirstName": "Jane", "LastName": "Doe", "Age": 57 },
    { "FirstName": "John", "LastName": "Doe", "Age": 55 },
    { "FirstName": "Michael", "LastName": "Corleone",
      "Age": 47 },
    { "FirstName": "Anthony", "LastName": "Soprano",
      "Age": 51 },
    { "FirstName": "Paulie", "LastName": "Gualtieri",
      "Age": 58 }
]</pre>
			<p>For the query itself, add a file called <strong class="source-in ine">query.json</strong> and add the following or your own query <span class="No-Break">to it:</span></p>
			<pre class="source-code">
{
    "Age": {
        "$gte": 52
    },
    "$or": [
        {
            "LastName": "Doe"
        }
    ]
}</pre>
			<p>You then want to have code that parses these files and creates an expression from <span class="No-Break">the </span><span class="No-Break"><strong class="source-in ine">query.json</strong></span><span class="No-Break">.</span></p>
			<p>To be able to parse the <strong class="source-in ine">data.json</strong> file and get a nice collection of <strong class="source-in ine">Dictionary&lt;string, object&gt;</strong> types, we need a JSON converter. By default, if you try to deserialize JSON into this, the serializer will give you a <strong class="source-in ine">JsonElement</strong> for the value. We want the actual value. The JSON converter listing and walk-through have no value <a id="_idIndexMarker295"/>in this context. They can be found in the GitHub repository referenced at the beginning of <span class="No-Break">the chapter.</span></p>
			<p>In the <strong class="source-in ine">Program.cs</strong> file, replace everything with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var query = File.ReadAllText("query.json");
var queryDocument = JsonDocument.Parse(query);
var expression = QueryParser.Parse(queryDocument);
var documentsRaw = File.ReadAllText("data.json");
var serializerOptions = new JsonSerializerOptions();
serializerOptions.Converters.Add(new Dictionary
  StringObjectJsonConverter());
var documents = JsonSerializer.Deserialize&lt;Ienumerable
  &lt;Dictionary&lt;string, object&gt;&gt;&gt;(documentsRaw,
    serializerOptions)!;
var filtered = documents.AsQueryable().Where(expression);
foreach (var document in filtered)
{
    Console.WriteLine(JsonSerializer.Serialize(document));
}</pre>
			<p>The code loads the <strong class="source-in ine">query.json</strong> and the <strong class="source-in ine">data.json</strong> files and parses them. For the query, you need it as a <strong class="source-in ine">JsonDocument</strong> before it’s passed into the <strong class="source-in ine">QueryParser.Parse()</strong> method, while the data is deserialized into a collection of <span class="No-Break"><strong class="source-in ine">Dictionary&lt;string, object&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Since the documents are <strong class="source-in ine">IEnumerable</strong>, you don’t get the <strong class="source-in ine">.Where()</strong> extension methods you’re looking for. The code therefore does a <strong class="source-in ine">.AsQueryable()</strong> first and then passes the parsed query expression <span class="No-Break">into it.</span></p>
			<p>The filtered <a id="_idIndexMarker296"/>objects can then <span class="No-Break">be enumerated.</span></p>
			<p>Running the code should give you the <span class="No-Break">following result:</span></p>
			<pre class="console">
{"FirstName":"Jane","LastName":"Doe","Age":57}
{"FirstName":"John","LastName":"Doe","Age":55}
{"FirstName":"Paulie","LastName":"Gualtieri","Age":58}</pre>
			<p>The benefit of this approach rather than presenting something such as SQL to the end user is that you now have an abstraction that works with different data stores. You can even apply the same expression in memory as yo<a id="_idTextAnchor144"/>u would for <span class="No-Break">a database.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor145"/>Summary</h1>
			<p>In this chapter, we have learned about the power of building out expressions and expression trees. Not only can they represent queries but, in fact, they can be just as powerful as generating intermediate <span class="No-Break">language code.</span></p>
			<p>With expressions, you get an alternative to intermediate language. They do have some limitations over generating intermediate language code, such as you can’t simply create types and implement interfaces or override the behavior of virtual methods inherited. But as a tool for expressing simpler actions, they are <span class="No-Break">really great.</span></p>
			<p>In the next chapter, we will look at yet another approach to dynamically creating types and implementations by leveraging the capabilities of the <strong class="bo d">Dynamic </strong><span class="No-Break"><strong class="bo d">Language Runtime</strong></span><span class="No-Break">.</span></p>
		</div>
	</body></html>