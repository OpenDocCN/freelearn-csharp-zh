<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Editor Extensions</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI</li><li class="listitem" style="list-style-type: disc">An editor extension to add 100 randomly located copies of a prefab with one menu click</li><li class="listitem" style="list-style-type: disc">A progress bar to display proportion completed of Editor extension processing</li><li class="listitem" style="list-style-type: disc">An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object location in scene</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec126"/>Introduction</h1></div></div></div><p>One aspect of game development in general (and inventories as our particular examples in this chapter) is the distinction about <em>when</em> we undertake an activity. <strong>Run-time</strong> is when the game is running (and when all our software <a class="indexterm" id="id1327"/>and UI choices take affect). However, <strong>design-time</strong> is the<a class="indexterm" id="id1328"/> time when different members of our game design team work on constructing a wide range of game components, including the scripts, audio and visual assets, and the process of constructing each game level (or "scene" in Unity-speak).</p><p>In this chapter, we will<a class="indexterm" id="id1329"/> introduce several recipes that make use of Unity's Editor extensions; these are scripting and multimedia components that enable a game software engineer to make design-time work easier and less likely to introduce errors. Editor extensions allow workflow improvements, thus allowing designers to achieve their goals quicker and more easily; for example, removing the need for any scripting knowledge when generating many randomly located inventory pickups in a scene via a menu choice, or editing the type or properties of pickups being hand-placed in different locations in a level.</p><p>While Editor extensions are quite an advanced topic, having someone on your team who can write custom editor components, such as those we illustrate, can greatly increase the productivity of a small team with only one or two members who are confident at scripting.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec127"/>An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI</h1></div></div></div><p>The use of <strong>enums</strong> and corresponding drop-down menus in the Inspector panel to restrict changes to one of a limited set often works fine (for example, pickup types for a pickup object). However, the trouble with this approach is, when two or more properties are related and need to be changed together, there is a danger of changing one property, for example, pickup type from <strong>Heart</strong> to <strong>Key</strong>, but forgetting to change corresponding properties; for example, leaving the <strong>Sprite Renderer</strong> component still showing a <strong>Heart sprite</strong>. Such mismatches cause problems both in terms of messing up intended level design and, of course, the frustration for the player when they collide with something showing one pickup image, but a different kind of pickup type is added to the inventory!</p><p>If a class of GameObject has several related properties or components, which all need to be changed together, then a good strategy is to use Unity Editor extensions to do all the associated changes each time a different choice is made from a drop-down menu showing the defined set of enumerated choices.</p><p>In this recipe, we introduce <a class="indexterm" id="id1330"/>an Editor extension for PickUp components of GameObjects.</p><div><img alt="An editor extension to allow pickup type (and parameters) to be changed at design time via a custom Inspector UI" src="img/1362OT_12_41.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec400"/>Getting ready</h2></div></div></div><p>This recipe assumes you are starting with project <code class="literal">Simple2Dgame_SpaceGirl</code> setup from the first recipe in <a class="link" href="ch02.html" title="Chapter 2. Inventory GUIs">Chapter 2</a>, <em>Inventory GUIs</em>. A copy of this Unity project is provided in a folder named <code class="literal">unityProject_spaceGirlMiniGame</code> in the <code class="literal">1362_12_01</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec401"/>How to do it...</h2></div></div></div><p>To create an editor<a class="indexterm" id="id1331"/> extension to allow pickup type (and parameters) to be changed at design-time via a custom Inspector UI, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start with a new copy of mini-game <code class="literal">Simple2Dgame_SpaceGirl</code>.</li><li class="listitem">In the <strong>Project</strong> panel, create a new folder named <code class="literal">EditorSprites</code>. Move the following images from folder <code class="literal">Sprites</code> into this new folder: <code class="literal">star</code>, <code class="literal">healthheart</code>, <code class="literal">icon_key_green_100</code>, <code class="literal">icon_key_green_32</code>, <code class="literal">icon_star_32</code>, and <code class="literal">icon_heart_32</code>.<div><img alt="How to do it..." src="img/1362OT_12_55.jpg"/></div></li><li class="listitem">In the <strong>Hierarchy</strong> panel, rename GameObject <code class="literal">star</code> to be named <code class="literal">pickup</code>.</li><li class="listitem">Edit the tags, changing tag <strong>Star </strong>to <strong>Pickup</strong>. Ensure the <code class="literal">pickup</code> GameObject now has the tag <strong>Pickup</strong>.</li><li class="listitem">Add the following C# script <code class="literal">PickUp</code> to GameObject <code class="literal">pickup</code> in the <strong>Hierarchy</strong>:<div><pre class="programlisting">using UnityEngine;
using System;
using System.Collections;

public class PickUp : MonoBehaviour {
  public enum PickUpType {
    Star, Health, Key
  }

  [SerializeField]
  public PickUpType type;

  public void SetSprite(Sprite newSprite){
    SpriteRenderer spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();
    spriteRenderer.sprite = newSprite;
  }
}</pre></div></li><li class="listitem">In the <strong>Project</strong> panel, create a new folder named <code class="literal">Editor</code>. Inside this new folder, create a<a class="indexterm" id="id1332"/> new C# script class named <code class="literal">PickUpEditor</code>, with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
using System;
using UnityEditor;
using System.Collections.Generic;

[CanEditMultipleObjects]
[CustomEditor(typeof(PickUp))]
public class PickUpEditor : Editor
{
  public Texture iconHealth;
  public Texture iconKey;
  public Texture iconStar;

  public Sprite spriteHealth100;
  public Sprite spriteKey100;
  public Sprite spriteStar100;

  UnityEditor.SerializedProperty pickUpType;

  private Sprite sprite;
  private PickUp pickupObject;

  void OnEnable () {
    iconHealth = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_heart_32.png", typeof(Texture)) as Texture;
    iconKey = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_key_32.png", typeof(Texture)) as Texture;
    iconStar = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_star_32.png", typeof(Texture)) as Texture;

    spriteHealth100 = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/healthheart.png", typeof(Sprite)) as Sprite;
    spriteKey100 = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/icon_key_100.png", typeof(Sprite)) as Sprite;
    spriteStar100 = AssetDatabase.LoadAssetAtPath("Assets/EditorSprites/star.png", typeof(Sprite)) as Sprite;

    pickupObject = (PickUp)target;
    pickUpType = serializedObject.FindProperty ("type");
  }


  public override void OnInspectorGUI()
  {
    serializedObject.Update ();

    string[] pickUpCategories = TypesToStringArray();
    pickUpType.enumValueIndex = EditorGUILayout.Popup("PickUp TYPE: ", pickUpType.enumValueIndex, pickUpCategories);

    PickUp.PickUpType type = (PickUp.PickUpType)pickUpType.enumValueIndex;
    switch(type)
    {
    case PickUp.PickUpType.Health:
      InspectorGUI_HEALTH();
      break;

    case PickUp.PickUpType.Key:
      InspectorGUI_KEY();
      break;

    case PickUp.PickUpType.Star:
    default:
      InspectorGUI_STAR();
      break;
    }

    serializedObject.ApplyModifiedProperties ();
  }

  private void InspectorGUI_HEALTH()
  {
    GUILayout.BeginHorizontal();
    GUILayout.FlexibleSpace();
    GUILayout.Label(iconHealth);
    GUILayout.Label("HEALTH");
    GUILayout.Label(iconHealth);
    GUILayout.Label("HEALTH");
    GUILayout.Label(iconHealth);
    GUILayout.FlexibleSpace();
    GUILayout.EndHorizontal();

    pickupObject.SetSprite(spriteHealth100);
  }

  private void InspectorGUI_KEY()
  {
    GUILayout.BeginHorizontal();
    GUILayout.FlexibleSpace();
    GUILayout.Label(iconKey);
    GUILayout.Label("KEY");
    GUILayout.Label(iconKey);
    GUILayout.Label("KEY");
    GUILayout.Label(iconKey);
    GUILayout.FlexibleSpace();
    GUILayout.EndHorizontal();

    pickupObject.SetSprite(spriteKey100);
  }

  private void InspectorGUI_STAR()
  {
    GUILayout.BeginHorizontal();
    GUILayout.FlexibleSpace();
    GUILayout.Label(iconStar);
    GUILayout.Label("STAR");
    GUILayout.Label(iconStar);
    GUILayout.Label("STAR");
    GUILayout.Label(iconStar);
    GUILayout.FlexibleSpace();
    GUILayout.EndHorizontal();

    pickupObject.SetSprite(spriteStar100);
  }
  private string[] TypesToStringArray(){
    var pickupValues = (PickUp.PickUpType[])Enum.GetValues(typeof(PickUp.PickUpType));

    List&lt;string&gt; stringList = new List&lt;string&gt;();

    foreach(PickUp.PickUpType pickupValue in pickupValues){
      string stringName = pickupValue.ToString();
      stringList.Add(stringName);
    }

    return stringList.ToArray();
  }
}</pre></div></li><li class="listitem">In the <strong>Inspector</strong> panel, select GameObject <code class="literal">pickup</code> and choose different values of the drop-down menu <strong>PickUp Type</strong>. You should see corresponding <a class="indexterm" id="id1333"/>changes in the image and icons in the <strong>Inspector</strong> for the <strong>Pick Up (Script)</strong> component (three icons with the name of the type in between). The <strong>Sprite</strong> property of the <strong>Sprite Renderer</strong> component for this GameObject should change. Also, in the <strong>Scene</strong> panel, you'll see the image in the scene change to the appropriate image for the pickup type you have chosen.<div><img alt="How to do it..." src="img/1362OT_12_42.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec402"/>How it works...</h2></div></div></div><p>Our script class <code class="literal">PickUp</code> has the enum <code class="literal">PickUpType</code> with the three values: <code class="literal">Star</code>, <code class="literal">Health</code>, and <code class="literal">Key</code>. Also, there is the variable <code class="literal">type</code>, storing the type of the parent GameObject. Finally, there is a <code class="literal">SetSprite(…)</code> method that sets the <strong>Sprite Renderer</strong> component of the parent GameObject to be set to the provided <code class="literal">Sprite</code> parameter. It is this method that is called from the editor script each time the pickup type is changed from the drop-down menu (with the corresponding sprite for the new type being passed).</p><p>The vast majority of the work<a class="indexterm" id="id1334"/> for this recipe is the responsibility of the script class <code class="literal">PickUpEditor</code>. While there is a lot in this script, its work is relatively straightforward: for each frame, via method <code class="literal">OnInspectorGUI()</code>, a dropdown<a class="indexterm" id="id1335"/> list of <code class="literal">PickUpType</code> values is presented to the user. Based on the value selected from this drop-down list, one of three methods is executed: <code class="literal">InspectorGUI_HEALTH()</code>, <code class="literal">InspectorGUI_KEY()</code>, <code class="literal">InspectorGUI_STAR()</code>. Each of these methods displays three icons and the name of the type in the Inspector beneath the drop-down menu and ends by calling the <code class="literal">SetSprite(…)</code> method of the GameObject being edited in the Inspector to update the <strong>Sprite Renderer</strong> component of the parent GameObject with the appropriate sprite.</p><p>The C# attribute <code class="literal">[CustomEditor(typeof(PickUp))]</code> appearing before our class is declared, tells Unity to use this special editor script to display component properties in the <strong>Inspector</strong> panel for <strong>Pick Up (Script)</strong> components of GameObjects, rather than Unity's default <strong>Inspector</strong> which displays public variables of such scripted components.</p><p>Before and after its main work, the <code class="literal">OnInspectorGUI()</code> method first ensures that any variables relating to the object being edited in the Inspector have been updated —<code class="literal">serializedObject.Update()</code>. The last statement of this method correspondingly ensures that any changes to variables in the editor script have been copied back to the GameObject being edited—<code class="literal">serializedObject.ApplyModifiedProperties()</code>.</p><p>The <code class="literal">OnEnable()</code> method of <a class="indexterm" id="id1336"/>script class <code class="literal">PickUpEditor</code> loads the three small icons (for display in the <strong>Inspector</strong>) and the three larger sprite images (to update the <strong>Sprite Renderer</strong> for display in the <strong>Scene/Game</strong> panels). The <code class="literal">pickupObject</code> variable is set to be a reference to the <code class="literal">PickUp</code> scripted component, allowing us to call the <code class="literal">SetSprite(…)</code> method. The <code class="literal">pickUpType</code> variable is set to be linked to the type variable of the <code class="literal">PickUp</code> scripted component whose special <strong>Inspector</strong> editor view makes this script possible—<code class="literal">serializedObject.FindProperty ("type")</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec403"/>There's more...</h2></div></div></div><p>Here are some<a class="indexterm" id="id1337"/> details you don't want to miss.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec116"/>Offer the custom editing of pickup parameters via Inspector</h3></div></div></div><p>Many pickups have additional properties, rather than simply being an item being carried. For example, a health pickup <a class="indexterm" id="id1338"/>may add health "points" to the player's character, a coin pickup may add money "points" to the characters bank balance, and so on. So, let's add an integer <code class="literal">points</code> variable to our <code class="literal">PickUp</code> class and offer the user the ability to easily edit this points value via a GUI slider in our customer Inspector editor.</p><div><img alt="Offer the custom editing of pickup parameters via Inspector" src="img/1362OT_12_49.jpg"/></div><p>To add an editable points property to our <code class="literal">PickUp</code> objects, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following extra line into C# script <code class="literal">PickUp</code> to create our new integer <code class="literal">points</code> variable:<div><pre class="programlisting">public int points;</pre></div></li><li class="listitem">Add the following extra line into C# script <code class="literal">PickUpEditor</code> to work with our new integer <code class="literal">points</code> variable:<div><pre class="programlisting">UnityEditor.SerializedProperty points;</pre></div></li><li class="listitem">Add the following extra line into the <code class="literal">OnEnable()</code> method in C# script <code class="literal">PickUpEditor</code> to associate our new <code class="literal">points</code> variable with its corresponding value in the <code class="literal">PickUp</code> scripted component of the GameObject being edited:<div><pre class="programlisting">void OnEnable () {
  points = serializedObject.FindProperty ("points");
  pickUpType = serializedObject.FindProperty ("type");
  // rest of method as before…</pre></div></li><li class="listitem">Now we can add an extra line into each GUI method for the different PickUp types. For example, we can add a statement to display an <strong>IntSlider</strong> to the user to be able to see and modify the points value for a <strong>Health PickUp</strong> object. We add a new statement at the end of the <code class="literal">InspectorGUI_HEALTH()</code>method in C# script <code class="literal">PickUpEditor</code> to display a modifiable <strong>IntSlider</strong> representing our new <code class="literal">points</code> variable as follows:<div><pre class="programlisting">private void InspectorGUI_HEALTH(){
  // beginning of method just as before…

  pickupObject.SetSprite(spriteHealth100);

// now display Int Slider for points
  points.intValue = EditorGUILayout.IntSlider ("Health points", points.intValue, 0, 100);
}</pre></div></li></ol></div><p>We provide four parameters to the <code class="literal">IntSlider(…)</code> method. The first is the text label the user will see next to the slider. The second is the initial value the slider displays. The last two are the maximum and minimum values. In our example, we are permitting values from 0 to 100, but if health pickups only offer one, two, or three health points, then we'd just call with <code class="literal">EditorGUILayout.IntSlider ("Health points", points.intValue, 1, 5)</code>. This method returns a new integer value based on where the slider has been <a class="indexterm" id="id1339"/>positioned, and this new value is stored back into the integer value part of our <code class="literal">SerializedProperty</code> variable points.</p><p>Note that the loading and saving of values from the scripted component in the GameObject and our editor script is all part of the work undertaken by our calls to the <code class="literal">Update()</code> method and the <code class="literal">ApplyModifiedProperties()</code> method on the serialized object in the <code class="literal">OnInspectorGUI()</code> method.</p><p>Note that since points may not have any meaning for some pickups, for example, keys, then we simply would not display any slider for the GUI Inspector editor when the user is editing <strong>PickUp</strong> objects of that type.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec117"/>Offer a drop-down list of tags for key-pickup to fit via Inspector</h3></div></div></div><p>While the<a class="indexterm" id="id1340"/> concept of "points" may have no meaning for a key pickup, the concept of the type of lock that a given key fits is certainly something we may wish to implement in a game. Since Unity offers us a defined (and editable) list of string tags for any GameObject, often it is sufficient, and straightforward, to represent the type of lock or door corresponding to a key via its tag. For example, a green key might fit all objects tagged <strong>LockGreen</strong> and so on.</p><div><img alt="Offer a drop-down list of tags for key-pickup to fit via Inspector" src="img/1362OT_12_50.jpg"/></div><p>Therefore, it is very useful to be able to offer a custom Inspector editor for a string property of key pickups that stores the tag of the lock(s) the key can open. This task combines several actions, including using C# to retrieve an array of tags from the Unity editor, then the building <a class="indexterm" id="id1341"/>and offering of a drop-down list of these tags to the user, with the current value already selected in this list.</p><p>To add a selectable list of strings for the tag for lock(s) that a key fits, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following extra line into C# Script <code class="literal">PickUp</code> to create our new integer <code class="literal">fitsLockTag</code> variable:<div><pre class="programlisting">public string fitsLockTag;</pre></div></li><li class="listitem">Add the following extra line into C# script <code class="literal">PickUpEditor</code> to work with our new integer <code class="literal">fitsLockTag</code> variable:<div><pre class="programlisting">UnityEditor.SerializedProperty fitsLockTag;</pre></div></li><li class="listitem">Add the following extra line into the <code class="literal">OnEnable()</code>method in C# script <code class="literal">PickUpEditor</code> to associate our new <code class="literal">fitsLockTag</code> variable with its corresponding value in the PickUp scripted component of the GameObject being edited:<div><pre class="programlisting">void OnEnable () {
  fitsLockTag = serializedObject.FindProperty ("fitsLockTag");
  points = serializedObject.FindProperty ("points");
  pickUpType = serializedObject.FindProperty ("type");
  // rest of method as before…</pre></div></li><li class="listitem">Now we need to add some extra lines of code into the GUI method for key PickUps. We need to add several statements to the end of method <code class="literal">InspectorGUI_KEY()</code> in C# script <code class="literal">PickUpEditor</code> to set up and display a selectable popup drop-down list representing our new <code class="literal">fitsLockTag</code> variable as follows. Replace the <code class="literal">InspectorGUI_KEY()</code> method with the following code:<div><pre class="programlisting">private void InspectorGUI_KEY() {
  GUILayout.BeginHorizontal();
  GUILayout.FlexibleSpace();
  GUILayout.Label(iconKey);
  GUILayout.Label("KEY");
  GUILayout.Label(iconKey);
  GUILayout.Label("KEY");
  GUILayout.Label(iconKey);
  GUILayout.FlexibleSpace();
  GUILayout.EndHorizontal();

  pickupObject.SetSprite(spriteKey100);

  string[] tags = UnityEditorInternal.InternalEditorUtility.tags;
  Array.Sort(tags);
  int selectedTagIndex = Array.BinarySearch(tags, fitsLockTag.stringValue);
  if(selectedTagIndex &lt; 0)  selectedTagIndex = 0;
  selectedTagIndex = EditorGUILayout.Popup("Tag of door key fits: ", selectedTagIndex, tags);

  fitsLockTag.stringValue = tags[selectedTagIndex];
}</pre></div></li></ol></div><p>We've added several statements to the end of this method. First <code class="literal">tags</code>, an array of strings, is created (and sorted), containing the list of tags currently available in the Unity editor for the current game. We then attempt to find the location in this array of the current value of <code class="literal">fitsLockTag</code> — we can use the <code class="literal">BinarySearch(…)</code> method of built-in script class <code class="literal">Array</code> because<a class="indexterm" id="id1342"/> we have alphabetically sorted our array (which also makes it easier for the user to navigate). If the string in <code class="literal">fitsLockTag</code> cannot be found in array <code class="literal">tags</code>, then the first item will be selected by default (index 0).</p><p>The user is then shown the drop-down list via the<a class="indexterm" id="id1343"/> <code class="literal">GUILayout</code> method <code class="literal">EditorGUILayout.Popup(…)</code>, and this method returns the index of whichever item is selected. The selected index is stored into <code class="literal">selectedTagIndex</code>, and the last statement in the method extracts the corresponding string and stores that string into the <code class="literal">fitsLockTag</code> variable.</p><div><div><h3 class="title"><a id="note62"/>Note</h3><p>Note: Rather than displaying all possible tags, a further refinement might remove all items from array 'tags' that do not have the prefix 'Lock'. So the user is only presented with tags such as 'LockBlue' and 'LockGreen', and so on.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec118"/>Logic to open doors with keys based on fitsLockTag</h3></div></div></div><p>In our player collision logic, we can now search through our inventory to see if any key items fit the lock we have collided with. For example, if a green door was collided with, and the player was carrying a key that could open such doors, then that item should be removed from the inventory <code class="literal">List&lt;&gt;</code> and the door should be opened.</p><p>To implement this, you <a class="indexterm" id="id1344"/>would need to add an <code class="literal">if</code> test inside the <code class="literal">OnTriggerEnter()</code> method to detected collision with the item tagged <code class="literal">Door</code>, and then logic to attempt to open the door, and, if unsuccessful, do the appropriate action (for example, play sound) to inform the player they cannot open the door yet (we'll assume we have written a door animation controller that plays the appropriate animation and sounds and when a door is to be opened):</p><div><pre class="programlisting">if("Door" == hitCollider.tag){
  if(!OpenDoor(hitCollider.gameObject))
    DoorNotOpenedAction();
}</pre></div><p>The <code class="literal">OpenDoor()</code> method would <a class="indexterm" id="id1345"/>need to identify which item (if any) in the inventory can open such a door, and, if found, then that item should be removed from the <code class="literal">List&lt;&gt;</code> and the door should be opened by the appropriate method:</p><div><pre class="programlisting">private bool OpenDoor(GameObject doorGO){
  // search for key to open the tag of doorGO
  int colorKeyIndex = FindItemIndex(doorGO.tag);
  if( colorKeyIndex &gt; -1 ){
    // remove key item from inventory List&lt;&gt;
    inventory.RemoveAt( colorKeyIndex );

    // now open the door...
    DoorAnimationController doorAnimationController = doorGO.GetComponent&lt;&gt;(DoorAnimationController);
    doorAnimationController.OpenDoor();

    return true;
  }

  return false;
}</pre></div><p>The following is the code for a method to find the inventory list key item fitting a door tag:</p><div><pre class="programlisting">private int FindItemIndex(string doorTag){
  for (int i = 0; i &lt; inventory.Count; i++){
    PickUp item = inventory[i];
    if( (PickUp.PickUpType.Key == item.type) &amp;&amp; (item.fitsLockTag == doorTag))
      return i;
  }

  // not found
return -1;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec119"/>The need to add [SerializeField] for private properties</h3></div></div></div><p>Note that if we wished to create editor extensions to work with private variables, then we'd need to explicitly add <code class="literal">[SerializeField] </code>in the line immediately before the variable to be changed by the<a class="indexterm" id="id1346"/> editor script. Public variables are serialized by default in Unity, so this was not required for our public <code class="literal">type</code> variable in script class <code class="literal">PickUp</code>, although it's good practice to flag ALL variables that are changeable via an Editor Extension in this way.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec120"/>Learn more from the Unity documentation</h3></div></div></div><p>Unity provides <a class="indexterm" id="id1347"/>documentation pages about editor scripts at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Editor.html">http://docs.unity3d.com/ScriptReference/Editor.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec128"/>An editor extension to add 100 randomly located copies of a prefab with one menu click</h1></div></div></div><p>Sometimes we<a class="indexterm" id="id1348"/> want to create "lots" of pickups, randomly in our scene. Rather than doing this by hand, it is possible to add a custom menu and item to the Unity editor, which, when selected, will execute a script. In this recipe, we create a menu item that calls a script to create 100 randomly positioned star pickup prefabs in the Scene.</p><div><img alt="An editor extension to add 100 randomly located copies of a prefab with one menu click" src="img/1362OT_12_43.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec404"/>Getting ready</h2></div></div></div><p>This recipe assumes you are starting with the project <code class="literal">Simple2Dgame_SpaceGirl</code> setup from the<a class="indexterm" id="id1349"/> first recipe in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec405"/>How to do it...</h2></div></div></div><p>To create an editor extension to add 100 randomly located copies of a prefab with one menu click, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start with a new copy of mini-game <code class="literal">Simple2Dgame_SpaceGirl</code>.</li><li class="listitem">In the <strong>Project</strong> panel, create a new folder named <code class="literal">Prefabs</code>. Inside this new folder, create a new empty prefab named <code class="literal">prefab</code>_<code class="literal">star</code>. Populate this prefab by dragging GameObject <code class="literal">star</code> from the <strong>Hierarchy</strong> panel over <code class="literal">prefab</code>_<code class="literal">star</code> in the <strong>Project</strong> panel. The prefab should now turn blue and have a copy of all of GameObject star's properties and components.</li><li class="listitem">Delete GameObject <code class="literal">star</code> from the <strong>Hierarchy</strong>.</li><li class="listitem">In the <strong>Project</strong> panel, create a new folder named <code class="literal">Editor</code>. Inside this new folder, create a new C# script class named <code class="literal">MyGreatGameEditor</code>, with the following code:<div><pre class="programlisting">using UnityEngine;
using UnityEditor;
using System.Collections;
using System;
public class MyGreatGameEditor : MonoBehaviour {
  const float X_MAX = 10f;
  const float Y_MAX = 10f;

  static GameObject starPrefab;

  [MenuItem("My-Great-Game/Make 100 stars")]
  static void PlacePrefabs(){
    string assetPath = "Assets/Prefabs/prefab_star.prefab";
    starPrefab = (GameObject)AssetDatabase.LoadMainAssetAtPath(assetPath);

    int total = 100;
    for(int i = 0; i &lt; total; i++){
      CreateRandomInstance();
    }
  }

  static void CreateRandomInstance(){
    float x = UnityEngine.Random.Range(-X_MAX, X_MAX);
    float y = UnityEngine.Random.Range(-Y_MAX, Y_MAX);
    float z = 0;
    Vector3 randomPosition = new Vector3(x,y,z);

    Instantiate(starPrefab, randomPosition, Quaternion.identity);
  }
}</pre></div></li><li class="listitem">After 20 to 30 seconds, depending on the speed of your computer, you should now see a new menu appear, <strong>My Great Game</strong>, with a single menu item, <strong>Make 100 stars</strong>. Chose this menu item and, as if by <a class="indexterm" id="id1350"/>magic, you should now see 100 new <strong>prefab_star(Clone)</strong> GameObjects appear in the scene!<div><img alt="How to do it..." src="img/1362OT_12_44.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec406"/>How it works...</h2></div></div></div><p>The core aim of this recipe is to add a new menu, containing a single menu item that will execute the action we desire. C# attribute <code class="literal">[MenuItem("&lt;menuName&gt;/&lt;menuItemName&gt;")]</code> declares the menu name and the menu item name, and Unity will execute the static method that follows in the code listing, each time the menu item is selected by the user.</p><p>In this recipe, the <code class="literal">[MenuItem("My-Great-Game/Make 100 stars")]</code> statement declares the menu name as <code class="literal">My-Great-Game</code> and the menu item as <code class="literal">Make 100 stars</code>. The method immediately following this attribute is the <code class="literal">PlacePrefabs()</code> method. When this method is executed, it makes the <code class="literal">starPrefab</code> variable become a reference to the prefab found via the <code class="literal">Assets/Prefabs/prefab_star.prefab</code> path. Then, a <code class="literal">for</code> loop is executed 100 times, each time calling the <code class="literal">CreateRandomInstance()</code> method.</p><p>The <code class="literal">CreateRandomInstance()</code> method<a class="indexterm" id="id1351"/> creates a Vector3 <code class="literal">randomPosition</code> variable, making use of <code class="literal">X_MAX</code> and <code class="literal">Y_MAX</code> constants. The <code class="literal">Instantiate(...)</code> built-in method is then used to create a new GameObject in the scene, making a clone of the prefab and locating<a class="indexterm" id="id1352"/> it at the position defined by <code class="literal">randomPosition</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec407"/>There's more...</h2></div></div></div><p>Some details you don't want to miss:</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec121"/>Child each new GameObject to a single parent, to avoid filling up the Hierarchy with 100s of new objects</h3></div></div></div><p>Rather than<a class="indexterm" id="id1353"/> having hundreds of new object clones fill up our <strong>Hierarchy</strong> panel, a good way to keep things tidy is to have an empty "parent" GameObject and child a collection of related GameObjects to it. Let's have a GameObject in the <strong>Hierarchy</strong> named <strong>Star-container</strong> and child all the new stars to this object.</p><div><img alt="Child each new GameObject to a single parent, to avoid filling up the Hierarchy with 100s of new objects" src="img/1362OT_12_46.jpg"/></div><p>We need a variable that will be a reference to our container object, <code class="literal">starContainerGO</code>. We also need a new method, <code class="literal">CreateStarContainerGO()</code>, which will find a reference to GameObject <strong>star-container</strong>, if such an object already exists it is deleted, and then the method will create a new empty GameObject and give it this name. Add the following variable and method to our script class:</p><div><pre class="programlisting">static GameObject starContainerGO;

static void CreateStarContainerGO() {
  string containerName = "Star-container";
  starContainerGO = GameObject.Find(containerName);
  if (null != starContainerGO) 
    DestroyImmediate(starContainerGO);
  starContainerGO = new GameObject(containerName);
}</pre></div><p>Before we create the prefab clones, we need to first ensure we have created our star container GameObject. So we need to call our new method as the first thing we do when the <code class="literal">PlacePrefabs()</code> method is executed, so add a statement to call this method at the beginning of the <code class="literal">PlacePrefabs()</code> method:</p><div><pre class="programlisting">static void PlacePrefabs(){
  CreateStarContainerGO();

  // rest of method as before ...
}</pre></div><p>Now we<a class="indexterm" id="id1354"/> need to modify the <code class="literal">CreateRandomInstance()</code> method so that it gets a reference to the new GameObject it has just created and can then child this new object to our <strong>star-container</strong> GameObject variable <code class="literal">starContainerGO</code>. Modify the <code class="literal">CreateRandomInstance()</code> method so that it looks as follows:</p><div><pre class="programlisting">static void CreateRandomInstance() {
  float x = UnityEngine.Random.Range(-X_MAX, X_MAX);
  float y = UnityEngine.Random.Range(-Y_MAX, Y_MAX);
  float z = 0;
  Vector3 randomPosition = new Vector3(x,y,z);

  GameObject newStarGO = (GameObject)Instantiate(starPrefab, randomPosition, Quaternion.identity);
  newStarGO.transform.parent = starContainerGO.transform;
}</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec129"/>A progress bar to display proportion completed of Editor extension processing</h1></div></div></div><p>If an<a class="indexterm" id="id1355"/> Editor task is going to take more than half a second or so, then we should indicate progress complete/remaining to <a class="indexterm" id="id1356"/>the user via a progress bar so that they understand that something is actually happening and the application has not crashed and frozen.</p><div><img alt="A progress bar to display proportion completed of Editor extension processing" src="img/1362OT_12_45.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec408"/>Getting ready</h2></div></div></div><p>This recipe adds to the previous one, so make a copy of that project folder and do your work for this<a class="indexterm" id="id1357"/> recipe with that copy.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec409"/>How to do it...</h2></div></div></div><p>To <a class="indexterm" id="id1358"/>add a progress bar during the loop (and then remove it after the loop is complete), replace the <code class="literal">PlacePrefabs()</code> method with the following code:</p><div><pre class="programlisting">static void PlacePrefabs(){
  string assetPath = "Assets/Prefabs/prefab_star.prefab";
  starPrefab = (GameObject)AssetDatabase.LoadMainAssetAtPath(assetPath);

  int total = 100;
  for(int i = 0; i &lt; total; i++){
    CreateRandomInstance();
    EditorUtility.DisplayProgressBar("Creating your starfield", i + "%", i/100f);
  }

  EditorUtility.ClearProgressBar();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec410"/>How it works...</h2></div></div></div><p>As can be seen, inside the <code class="literal">for</code> loop, we call the <code class="literal">EditorUtility.DisplayProgressBar(...)</code> method, passing three parameters. The first is a string title for the progress bar dialog window, the second is a string to show below the bar itself (usually a percentage is sufficient), and the final parameter is a value between 0.0 and 1.0, indicating the percentage complete to be displayed.</p><p>Since we have loop variable <code class="literal">i </code>that is a number from 1 to 100, we can display this integer followed by a percentage sign for our second parameter and just divide this number by 100 to get the decimal <a class="indexterm" id="id1359"/>value needed to specify how much of the progress bar should be shown as completed. If the loop were running for some other number, we'd just divide the loop counter<a class="indexterm" id="id1360"/> by the loop total to get our decimal progress value. Finally, after the loop has finished, we remove the progress bar with statement <code class="literal">EditorUtility.ClearProgressBar()</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec130"/>An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object location in scene</h1></div></div></div><p>If a level designer wishes to place each pickup carefully "by hand", we can still make this easier than having to drag copies of prefabs manually from the <strong>Projects</strong> panel. In this recipe, we provide a "cross-hairs" GameObject, with buttons in the Inspector allowing the game<a class="indexterm" id="id1361"/> designer to create instances of three different kinds of prefab at precise locations by clicking the appropriate button when the center of the cross-hairs is at the desired location.</p><p>A Unity Editor extension<a class="indexterm" id="id1362"/> is at the heart of this recipe and illustrates how such extensions can allow less technical members of a game development team to take an active role in level creation within the Unity Editor.</p><div><img alt="An editor extension to have an object-creator GameObject, with buttons to instantiate different pickups at cross-hair object location in scene" src="img/1362OT_12_47.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec411"/>Getting ready</h2></div></div></div><p>This recipe assumes you are starting with the project <code class="literal">Simple2Dgame_SpaceGirl</code> setup from the first recipe in <a class="link" href="ch02.html" title="Chapter 2. Inventory GUIs">Chapter 2</a>, <em>Inventory GUIs</em>.</p><p>For this recipe, we have prepared the cross-hairs image you need in a folder named <code class="literal">Sprites</code> in the <code class="literal">1362_12_04</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec412"/>How to do it...</h2></div></div></div><p>To create an object-creator GameObject, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start with a new copy of mini-game <code class="literal">Simple2Dgame_SpaceGirl</code>.</li><li class="listitem">In the <strong>Project</strong> panel, rename GameObject <code class="literal">star</code> as <code class="literal">pickup</code>.</li><li class="listitem">In the <strong>Project</strong> panel, create a new folder named <code class="literal">Prefabs</code>. Inside this new folder, create<a class="indexterm" id="id1363"/> three new empty prefabs named <code class="literal">star, heart</code>, and<code class="literal"> key</code>.</li><li class="listitem">Populate the <code class="literal">star</code> prefab by dragging GameObject <code class="literal">pickup</code> from the <strong>Hierarchy</strong> panel over <code class="literal">star</code> in the <strong>Project</strong> panel. The prefab should now turn blue and have a copy of all of the star GameObject's properties and components.</li><li class="listitem">Add a new tag <code class="literal">Heart</code> in the Inspector. Select GameObject <code class="literal">pickup</code> in the <strong>Hierarchy</strong> panel and assign it the tag <code class="literal">Heart</code>. Also, drag from the <strong>Project</strong> panel (folder <code class="literal">Sprites</code>) the <strong>healthheart</strong> image into the Sprite property of GameObject <code class="literal">pickup</code> so that the player sees the heart image on screen for this pickup item.</li><li class="listitem">Populate the <code class="literal">heart</code> prefab by dragging GameObject <code class="literal">pickup</code> from the <strong>Hierarchy</strong> panel over <code class="literal">heart</code> in the <code class="literal">Prefabs</code> folder in the <strong>Project</strong> panel. The prefab should <a class="indexterm" id="id1364"/>now turn blue and have a copy of all of the pickup GameObject's properties and components.</li><li class="listitem">Add a new tag <code class="literal">Key</code> in the Inspector. Select GameObject's <code class="literal">pickup</code> in the <strong>Hierarchy</strong> panel and assign it this tag <code class="literal">Key</code>. Also, drag from the <strong>Project</strong> panel (folder <code class="literal">Sprites</code>) image <strong>icon_key_green_100</strong> into the Sprite property of GameObject's <code class="literal">pickup</code> so that the player sees the key image on screen for this pickup item.</li><li class="listitem">Populate the <code class="literal">key</code> prefab by dragging GameObject <code class="literal">pickup</code> from the <strong>Hierarchy</strong> panel over <code class="literal">key</code> in the <code class="literal">Prefabs</code> folder in the <strong>Project</strong> panel. The prefab should now turn blue and have a copy of all of the pickup GameObject's properties and components.</li><li class="listitem">Delete GameObject's <code class="literal">pickup</code> from the <strong>Hierarchy</strong>.</li><li class="listitem">In the <strong>Project</strong> panel, create a new folder named <code class="literal">Editor</code>. Inside this new folder, create a new C# script class named <code class="literal">ObjectBuilderEditor</code>, with the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;
using UnityEditor;

[CustomEditor(typeof(ObjectBuilderScript))]
public class ObjectBuilderEditor : Editor{
  private Texture iconStar;
  private Texture iconHeart;
  private Texture iconKey;

  private GameObject prefabHeart;
  private GameObject prefabStar;
  private GameObject prefabKey;

  void OnEnable () {
    iconStar = Resources.LoadAssetAtPath("Assets/EditorSprites/icon_star_32.png", typeof(Texture)) as Texture;
    iconHeart = Resources.LoadAssetAtPath("Assets/EditorSprites/icon_heart_32.png", typeof(Texture)) as Texture;
    iconKey = Resources.LoadAssetAtPath("Assets/EditorSprites/icon_key_green_32.png", typeof(Texture)) as Texture;

    prefabStar = Resources.LoadAssetAtPath("Assets/Prefabs/star.prefab", typeof(GameObject)) as GameObject;
    prefabHeart = Resources.LoadAssetAtPath("Assets/Prefabs/heart.prefab", typeof(GameObject)) as GameObject;
    prefabKey = Resources.LoadAssetAtPath("Assets/Prefabs/key.prefab", typeof(GameObject)) as GameObject;
  }

  public override void OnInspectorGUI(){
    ObjectBuilderScript myScript = (ObjectBuilderScript)target;

    GUILayout.Label("");
    GUILayout.BeginHorizontal();
    GUILayout.FlexibleSpace();
    GUILayout.Label("Click button to create instance of prefab");
    GUILayout.FlexibleSpace();
    GUILayout.EndHorizontal();
    GUILayout.Label("");

    GUILayout.BeginHorizontal();
    GUILayout.FlexibleSpace();
    if(GUILayout.Button(iconStar)) myScript.AddObjectToScene(prefabStar);
    GUILayout.FlexibleSpace();
    if(GUILayout.Button(iconHeart)) myScript.AddObjectToScene(prefabHeart);
    GUILayout.FlexibleSpace();
    if(GUILayout.Button(iconKey)) myScript.AddObjectToScene(prefabKey);
    GUILayout.FlexibleSpace();
    GUILayout.EndHorizontal();

  }
}</pre></div></li><li class="listitem">Our Editor script is expecting to find the three icons in a folder named <code class="literal">EditorSprites</code>, so let's do this. First create a new folder named <code class="literal">EditorSprites</code>. Next drag the three 32 x 32 pixel icons from the <code class="literal">Sprites</code> folder into this <a class="indexterm" id="id1365"/>new <code class="literal">EditorSprites</code> folder. Our Editor script should now be able to load these<a class="indexterm" id="id1366"/> icons for image-based buttons that it will be drawing in the Inspector, from which the user chooses which pickup prefab object to clone into the scene.<div><img alt="How to do it..." src="img/1362OT_12_56.jpg"/></div></li><li class="listitem">From the <strong>Project</strong> panel, drag sprite <strong>cross_hairs.fw</strong> into the <strong>Scene</strong>. Rename this gameObject <code class="literal">object-creator-cross-hairs,</code> and in its <strong>Sprite Renderer</strong> component in the <strong>Inspector,</strong> set <strong>Sorting Layer</strong> to <strong>Foreground</strong>.</li><li class="listitem">Attach the following C# script to GameObject <code class="literal">object-creator-cross-hairs</code>:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ObjectBuilderScript : MonoBehaviour {
  void Awake(){
    gameObject.SetActive(false);
  }

  public void AddObjectToScene(GameObject prefabToCreateInScene){
    GameObject newGO = (GameObject)Instantiate(prefabToCreateInScene, transform.position, Quaternion.identity);
    newGO.name = prefabToCreateInScene.name;
  }
}</pre></div></li><li class="listitem">Select the <strong>Rect Tool</strong> (shortcut key <em>T</em>), and as you drag gameObject <code class="literal">object-creator-cross-hairs</code> and click on the desired icon in the <strong>Inspector</strong>, new pickup GameObjects will be added to the scene's <strong>Hierarchy</strong>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec413"/>How it works...</h2></div></div></div><p>The script class <code class="literal">ObjectBuilderScript</code> has just two methods, one of which has just one statement—the <code class="literal">Awake()</code> method simply makes this GameObject become inactive when the game is running (since we don't want the user to see our cross-hairs created tool during gameplay). The<a class="indexterm" id="id1367"/> <code class="literal">AddObjectToScene(…)</code> method receives a reference to a prefab as a parameter and instantiates a new clone of the prefab in the scene at the location of GameObject <code class="literal">object-creator-cross-hairs</code> at that point in time.</p><p>Script class <code class="literal">ObjectBuilderEditor</code> has a C# attribute <code class="literal">[CustomEditor(typeof(ObjectBuilderScript))]</code> immediately before the class is declared, telling Unity to use this class to control how <code class="literal">ObjectBuilderScript</code> GameObject properties and components are shown to the user in the <strong>Inspector</strong>.</p><p>There are six variables, three<a class="indexterm" id="id1368"/> textures for the icons to form the buttons in the Inspector, and three GameObject references to the prefabs of which instances will be created. The <code class="literal">OnEnable()</code> method assigns values to these six variables using the built-in method <code class="literal">Resources.LoadAssetAtPath()</code>, retrieving the icons from the <strong>Project</strong> folder <code class="literal">EditorSprites</code> and getting references to the prefabs in the <strong>Project</strong> folder <code class="literal">Prefabs</code>.</p><p>The <code class="literal">OnInspectorGUI()</code> method has a variable <code class="literal">myScript</code>, which is set to be a reference to the instance of scripted component<code class="literal"> ObjectBuilderScript</code> in GameObject <code class="literal">object-creator-cross-hairs</code> (so we can call its method when a prefab has been chosen). The method then displays a<a class="indexterm" id="id1369"/> mixture of empty text <code class="literal">Labels</code> (to get some vertical spacing) and <code class="literal">FlexibleSpace</code> (to get some horizontal spacing and centering) and displays three buttons to the user, with icons of star, heart, and key. The scripted GUI technique for Unity custom <strong>Inspector</strong> GUIs wraps an <code class="literal">if</code> statement around each button, and on the frame the user clicks the button, the statement block of the <code class="literal">if</code> statement will be executed. When any of the three buttons is clicked, a call is made to <code class="literal">AddObjectToScene(…)</code> of scripted component<code class="literal"> ObjectBuilderScript</code>, passing the prefab corresponding to the button that was clicked.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec131"/>Conclusion</h1></div></div></div><p>In this chapter, we introduced recipes demonstrating some Unity Editor extension scripts, illustrating how we can make things easier, less script based, and less prone to errors, by limiting and controlling the properties of objects and how they are selected or changed via the <strong>Inspector</strong>.</p><p>The concept of serialization was raised in the Editor extension recipes, whereby we need to remember that when we are editing item properties in the Inspector, each change needs to be saved to<a class="indexterm" id="id1370"/> disk so that the updated property is correct when we next use or edit that item. This is achieved in the <code class="literal">OnInspectorGUI()</code> method by first calling the <code class="literal">serializedObject.Update()</code> method, and after all changes have been made in the Inspector, finally calling the <code class="literal">serializedObject.ApplyModifiedProperties()</code> method. Some sources for more information and examples about custom Editor extensions include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more about <a class="indexterm" id="id1371"/>custom Unity Editors in Ryan Meier's blog, refer to <a class="ulink" href="http://www.ryan-meier.com/blog/?p=72">http://www.ryan-meier.com/blog/?p=72</a></li><li class="listitem" style="list-style-type: disc">For more custom Unity Editor scripts/tutorials, including grids and color pickers, refer to <a class="ulink" href="http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047">http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047</a></li></ul></div></div></body></html>