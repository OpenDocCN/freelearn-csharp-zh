- en: Implementing the RESTful HTTP Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to deal with the logic of our web service
    in the `Catalog.Domain` project. This chapter will walk you through the HTTP part
    of the web service and all the components inside the `Catalog.API` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also demonstrate how to implement and test the controller part of a
    web service. By the end of the chapter, you will be able to implement, test, and
    validate HTTP routes using ASP.NET Core. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the HTTP layer of a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carrying out tests using the tools provided by ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the resilience of the HTTP layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code presented in this chapter is available from the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the item controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section focuses on building the routes to read, writing the catalog data,
    and exposing the functionalities we already built in the domain layer using the
    HTTP protocol. Our controller will include the verbs listed in the following routing
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Verb** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/items` | Retrieves all the items present in our catalog |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/items/{id}` | Retrieves the item with the corresponding ID
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/api/items/` | Creates a new item by taking the body payload of
    the request |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/api/items/{id}` | Updates the item with the corresponding ID |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding routes allow web service consumers to get, add, and update the
    `Item` entities. Before starting the implementation, let''s look at an overview
    of the solution schema that we are going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d956dbc7-7b0d-4763-90fd-f7fa25b3b59f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data
    Access Layer,* and [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), *Implementing
    the Domain Logic,* we implemented and tested, respectively, the `Catalog.Infrastructure`
    and `Catalog.Domain` projects. This chapter focuses on the `Catalog.API` project.
    We are going to build and test the action methods that will call the service layer
    built in the `Catalog.Domain` project. Let''s start by defining a new controller
    in the `Controllers` folder of our `Catalog.API` project, named `ItemController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemController` class will reflect the routes that we defined earlier.
    We should note that we decorated the controller class with the `Route` and `ApiController`
    attributes: the first specifies the base URL of the controller and the second
    provides some utilities and conventions on the responses type produced by the
    action methods. The controller will also use the `IItemService` interface to query
    and write data on our data source. We can use the `IItemService` interface to
    the `ItemController` class via the constructor injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses dependency injection to add the `IItemService` class
    as a dependency of the `ItemController` class. Once we have added the `IItemService`
    interface, we can proceed by implementing the action methods of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing action methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already dealt with action methods in [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*. In the following implementation, we will
    use the `IItemService` interface in the action methods, as follows*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Get` and `GetById` action methods perform read operations by referring
    to the `IItemService` interface and calling the `GetItemsAsync` and `GetItemAsync`
    methods of the underlying service layer, in this case the `IItemService` interface.
    Let''s proceed by using the same approach to implement the `Post` and `Put` action
    methods of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Post` and `Put` actions use `AddItemRequest` and `EditItemRequest`, respectively,
    to bind data from the HTTP request and pass it through the `IItemService` interface.
    Under the hood, the `IItemService` implementation refers to `IItemMapper` to get
    back an entity from the request type and send it through the `IItemRepository`
    implementation. With the help of the dependency injection, we can easily loose
    couple the dependency between the different components. We should also note that
    the `Post` action method uses the `CreatedAtAction()` method exposed by `ControllerBase`
    to retrieve the location of the created resource as part of the response. Once
    we have bound the `IItemService` APIs into the `ItemController` action method,
    we can continue by testing the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing controllers using the WebApplicationFactory<T> class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ASP.NET Core Framework provides a way to perform *integration tests* using
    the `WebApplicationFactory<T>` class. This class allows us to create a new `TestServer`
    that emulates a real HTTP server in a separate process. Therefore, it is possible
    to test our `ItemController` by calling it through an `HttpClient` instance provided
    by the factory. It is essential to note that `WebApplicationFactory` is a generic
    class and that it accepts a `TEntryPoint` type, which is represented by the `Startup`
    class of our web service. Before proceeding with the implementation of the test
    class, let''s create a new project in the `tests` folder that will contain all
    tests related to the `Catalog.API` project. Therefore, we can execute the following
    commands inside the `tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands add a new `Catalog.API.Tests` project into the `tests`
    folder of the solution, which refers to the `Catalog.Fixtures` and `Catalog.API`
    projects. The project is included in the solution file of the project. The next
    section describes how to extend the `WebApplicationFactory` class in order to
    support the execution of the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the WebApplicationFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WebApplicationFactory` class exposes set properties and methods that are
    useful for configuring the instance of the `TestServer` and for creating the proper
    tests fixture for our controllers. In addition, it is possible to extend `WebApplicationFactory`
    by overriding the `ConfigureWebHost` method and substituting the behavior of the
    *dependency injection services* declared in the original `Startup` class of the
    `Catalog.API` project. The `WebApplicationFactory` class is part of the `Microsoft.AspNetCore.Mvc.Testing`
    package; therefore, it is necessary to add the NuGet package to the `Catalog.Fixture`
    project and to the Catalog.API.Tests project by running the following commands
    in the tests folder of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed by creating a new `InMemoryWebApplicationFactory` class inside
    the `Catalog.Fixtures` project. The class will be used by the test classes to
    instantiate a new `TestServer` object. Therefore, the next step is to create a
    new `InMemoryWebApplicationFactory` class that extends the `WebApplicationFactory`
    base class and overrides the `ConfigureWebHost` method to inject the custom *in*-*memory*
    database provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `InMemoryApplicationFactory` class implements the `ConfigureWebHost`
    method, and it initializes an in-memory database using the `UseInMemoryDatabase`
    extension method. It also inserts a new instance of the `TestCatalogContext` class
    in the `CatalogContext` service registered using the dependency injection. Therefore,
    the tests will use the same in-memory database infrastructure we already used
    for the test cases implemented in the `Catalog.Infrastructure.Tests` and `Catalog.Domain.Tests`
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `InMemoryApplicationFactory` implementation creates a new
    scope that will be used to execute the `EnsureCreated` method. Thus, each new
    instance of `InMemoryApplicationFactory` will generate the database from the same
    snapshot of data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the entire implementation is executed in the context of the `ConfigureTestServices`
    method, which provides a way to override the dependency injection services defined
    in the `Startup` class of the `Catalog.API` project.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building
    the Data Access Layer*, the in-memory database is not always the preferred alternative,
    for two reasons. First, it doesn't reflect a real relational database with real
    constraints on the data. Secondly, it is tricky to deal with in-memory databases
    when multiple test methods use the same instance, since they may generate inconsistent
    data. For this reason, we are creating a new instance, using the `UseInMemoryDatabase(Guid.NewGuid().ToString());`
    statement, for each test class. The `Guid.NewGuid()` instruction guarantees uniqueness
    between the instances. In real-world applications, another common approach is
    to create a new instance of a temporary data source and recreate it after each
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have implemented the `InMemoryApplicationFactory` class, it is possible
    to utilize it by implementing the `IClassFixture` interface in our test classes.
    Therefore, let''s start by initializing a new `ItemControllerTests` class in the
    `Catalog.API.Tests` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ItemControllerTests` class provides remarkable test coverage for the action
    methods. First of all, the test class implements the generic `IClassFixture` interface
    provided by the `xUnit.Sdk` package. The `IClassFixture` interface refers to the
    previously defined `InMemoryApplicationFactory<Startup>` and it injects the new
    instance of the `factory` class into the constructor of the test classes. Consequently,
    a new instance of the `factory` will be provided for each test class executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the test methods that cover the get operation of `ItemController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation uses the `CreateClient` method provided by `InMemoryApplicationFactory<Startup>`
    to initialize a new `HttpClient` instance. Therefore, if we take the `get_by_id_should_return_item_data`
    method as an example, it uses the client to call the `/api/items/{id}` route and
    checks that the information returned is not `null`. We can proceed by testing
    the add item operation by adding the following test methods to the `ItemControllerTests`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, we can choose a similar approach for the `Put` action method
    implemented in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `add_should_create_new_record` test method and the `update_should_modify_existing_item`
    method adopt the corresponding approach to test the `Post` and `Put` requests
    and the corresponding action methods. In this case, we are using the same request
    objects we defined for the `ItemServiceTests` and `ItemRepositoryTests` classes.
  prefs: []
  type: TYPE_NORMAL
- en: We can proceed by executing the previously implemented tests by running the
    `dotnet test` command in the solution folder, or by using the test runner of our
    preferred IDE. Later in this next subsection, we will look at how to optimize
    the initialization of the request and hold the test data at a unique point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `IClassFixture` implies that the same `InMemoryApplicationFactory` instance
    will be shared by all the test methods. Therefore, we will have the same underlying
    data for every test method. If we want to keep the tests fully isolated, we can
    avoid the use of the class fixture and initialize a new `InMemoryApplicationFactory`
    instance in the constructor of the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This approach also guarantees isolation between every single test method implemented
    in the test class. Furthermore, the constructor will provide a new instance every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's have a look at how to load test data using xUnit data attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Loading test data using xUnit data attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *xUnit* framework is the preferred choice for testing .NET applications
    and services. The framework also provides some utilities to extend its capabilities
    and to implement a more maintainable testing code. It is possible to extend the
    `DataAttribute` class exposed by the `xUnit.Sdk` namespace to perform custom operations
    inside our attributes. For example, let''s suppose that we create a new custom
    `DataAttribute` to load test data from a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, the implementation decorates the test method using the `LoadData`
    attribute, which is reading an `item` section from a file. Therefore, we will
    have a JSON file that contains all the test records, and we will use the `LoadData`
    attribute to load one of them. To customize the behavior for the `ItemControllerTests`
    class, we should create a new class and extend the `DataAttribute` class provided
    by xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoadDataAttribute` class overrides `GetData(MethodInfo testMethod);`,
    which is supplied by the `DataAttribute` class, and it returns the data utilized
    by the test methods. The implementation of the `GetData` method reads the content
    of the file defined by the `_filePath` attribute; it tries to serialize the content
    of the specified `section` of the file into a generic `object`. Finally, the implementation
    calls the `ToObject` method to convert the generic `JObject` into the type associated
    with the first parameter of the test method. The last step in the process is to
    create a new JSON file called `record-data.json` in the `Catalog.API.Tests` project.
    The file will contain the test data used by our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON snippet has the following fields: `item`, `artist`, and `genre`. The
    fields contain data related to the test entities. Therefore, we will use them
    to deserialize the data into the request models and into the entity types. Consequently,
    we can apply the `LoadData` attribute to the `ItemControllerTests` class in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the test methods accept a `request` parameter of the `Item`, `EditItemRequest`,
    or `AddItemRequest` type, which will contain the data provided by the `record-data.json`
    file. Then, the object is serialized into the `request` parameter and sent using
    the `HttpClient` instance supplied by the `InMemoryApplicationFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`LoadData` serializes the content defined in the `record-data.json` file into
    the `AddItemRequest` type. The request is then serialized as `StringContent` and
    posted using the HTTP client created by the factory. Finally, the method asserts
    that the resultant code is successful and the `Location` header is not `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now verify the behavior of the `ItemController` class by executing the
    `dotnet test` command in the root of the solution, or by running the test runner
    provided by our preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, now we are able to define the test data in a unique central JSON
    file. In addition to this, we can add as much data as we want by adding new sections
    to the JSON file. The next part of this section will focus on improving the resilience
    of the APIs by adding some existence checks and handling exceptions using filters.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the resilience of the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections show a possible implementation of `ItemController` class
    and how to test it using the tools provided by ASP.NET Core. In this section,
    we will learn how to improve the resilience of our service by performing some
    *restriction checks* on the information exposed by the `ItemController`. Additionally,
    we will look at how to present validation errors and how to paginate returned
    data. This section will apply the concepts explained in the previous chapters
    to the web service project.
  prefs: []
  type: TYPE_NORMAL
- en: Existence check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the action filter that performs an existence check
    on the requested data. The filter will be used by the action methods that get
    or edit a single item. As seen in [Chapter 7](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml),
    *Filter Pipeline*, we are going to implement the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The action filter resolves the `IItemService` interface in the constructor
    and uses the injected instance to verify the existence of the entity using the
    `id` present in the request. If the request contains a valid `Guid id`, and the
    `id` exists in our data source, the `OnActionExecutionAsync` method proceeds by
    calling the `await next()` method to continue the pipeline. Otherwise, it stops
    the pipeline and returns a `NotFoundObjectResult` instance. We can apply a filter
    to the action methods of `ItemController` by adding the `[ItemExists]` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After applying the `ItemExists` attribute, the API will return 404 if the ID
    sent by the request doesn''t exist. We can also verify the logic implemented in
    the action filter by injecting a mock instance of the `IItemService` interface
    and making some assertions about the resulting response. In the following test
    class, we will use `Moq` to verify the call to the `next()` method. As a first
    step, we need to add `Moq` to the `Catalog.API.Tests` project by using the following
    command inside the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can proceed by defining the `ItemExistsAttributeTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `ItemExistsAttributeTests` class mocks the whole `IItemService`
    interface to simulate the response of the `GetItemAsync` method. Then, it initializes
    `ItemExistsAttribute` by injecting the mocked `IItemService` interface. Finally,
    it calls the `OnActionExecutionAsync` method exposed by the `filter` class and
    it combines the result with the `Verify` method provided by the `Moq` framework
    to check that the `ItemExistsFilter` class correctly calls the `next()` callback
    method.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-customized errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The customization and serialization of the exceptions is a helpful way to simplify
    *error handling* and improve the monitoring of the web service*.* These techniques
    are sometimes necessary for communicating exceptions to a client so that errors
    can be handled and managed. In general, while the *HTTP status code* provides
    summary information about the status of the request, the content of the response
    provides more detailed information about the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to extend the error handling behavior using filters. First of
    all, let''s create a new standard model that represents an error result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class is under the `Filters` folder structure. It contains an
    `EventId` attribute and a `DetailedMessage` of an `object` type. Secondly, we
    should continue by implementing a new filter that extends the `IExceptionFilter`
    interface. The filter will be triggered when an exception is raised, and it will
    modify the content of the response returned to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements the `IExceptionFilter` interface. The class contains
    the definition of the constructor used to inject some of the dependencies of the
    filter. It also contains the `OnException` method, which initializes a new `JsonErrorPayload`
    object populated with the `eventId` field and the content of the message contained
    in the exception. Depending on the environment, take a look at the `IsDevelopment()`
    check; it also populates the resulting exception object with a detailed error
    message. Finally, the `OnException` method uses the `HttpContext`, defined as
    a parameter, to set the `HttpStatusCode.InternalServerError`, and to add `exceptionObject`
    previously created as a result of the execution. This approach guarantees to handle
    exception in a unique way, by centralizing the serialization and the resulting
    message format of all the errors returned by the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pagination is another essential feature of APIs. `Get` operations usually return
    a significant number of records and information. Sometimes, it is necessary to
    implement pagination to avoid a large response size.
  prefs: []
  type: TYPE_NORMAL
- en: If your APIs are exposed to external clients, it is essential to reduce the
    response size when possible. Additionally, it could be that the client stores
    information in the memory of a device, such as a smartphone or an IoT device,
    that has limited memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to implement maintainable and reusable pagination
    in the `ItemController` class. First of all, we need to create a new pagination
    response model that represents the requested page. We can create a new `PaginatedItemResponseModel.cs`
    file in the `ResponseModels` folder inside the `Catalog.API` project, using the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PaginatedItemsResponseModel` function accepts a generic model, and it
    represents a paginated response type. It also implements some properties related
    to the page, such as `PageIndex`, `PageSize`, and `Total`. Additionally, it includes
    an `IEnumerable` interface that represents the records returned by the response.
    The next step is to change the `Get` action method that is already present in
    the `ItemController` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed the `Get` action method to implement pagination. First of all, note
    that the method receives some parameters related to pagination: the `pageSize`
    and `pageIndex` parameters. Secondly, it executes `IItemService` to get the related
    records and performs a LINQ query to take only the elements of the selected page.
    Finally, it instantiates a new `PaginatedItemsResponseModel<ItemResponse>` with
    the metadata related to the page and the data, and returns the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can cover the implementation using the unit tests by changing the already
    existing `ItemsControllerTests` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `should_get_item_using_pagination` test case uses the `InlineData` attribute
    to test some pagination routes. It calls the `Get` action method, serializes the
    result into a `PaginatedItemsResponseModel<ItemResponse>`, and, finally, it checks
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: Although the pagination implementation technique examined in this chapter provides
    some performance benefits, it doesn't limit the interaction between our service
    and the database. To extend the performance benefits to the data source of the
    service as well, we should consider implementing an ad-hoc query to paginate data
    directly from our data source.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will continue our journey by extending the APIs in order
    to also handle related entities. For now, notice that we are exposing the information
    of the `Item`, `Artist`, and `Genre` entities, without managing the related entities
    and we are not exposing any route to edit the `Artist` and `Genre` entities.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing related entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, the current implementation in the `Catalog.API` project allows
    us to read, and modify the `Item` entity and its relationship with the `Genre`
    and `Artist` entities. In this section, we will enable a client to list and add
    the `Genre` and `Artist` entities. Therefore, we will extend the APIs that allow
    a client to interact with these entities. This implementation requires us to act
    on the full stack of the web service; additionally, it involves the `Catalog.Infrastructure`,
    the `Catalog.Domain`, and the `Catalog.API` projects. Before we begin, let''s
    take a look at the routes we are going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Verb** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/artists` | Retrieves all the artists present in the database
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/artist/{id}` | Retrieves the artist with the corresponding
    ID |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/artist/{id}/items/` | Retrieves the items with the corresponding
    artist ID |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/api/artist/` | Creates a new artist and retrieves it |'
  prefs: []
  type: TYPE_TB
- en: 'In the same way, we will get the corresponding routes for the `Genre` entity
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Verb** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/genre` | Retrieves all the genres present in the database |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/genre/{id}` | Retrieves the genre with the corresponding ID
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/genre/{id}/items/` | Retrieves the items with the corresponding
    genre ID |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/api/genre/` | Creates a new genre and retrieves it |'
  prefs: []
  type: TYPE_TB
- en: 'The routes mentioned in the previous tables provide a way to interact with
    the `Genre` and `Artist` entities. The implementation of these features will follow
    the same approach used by the item entity we have seen in the previous sections.
    Before proceeding, we need to extend the `CatalogContext` class by adding the
    attributes that represent the `Artist` and `Genre` entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now `CatalogContext` also handles the `Artists` and `Genres` entities through
    the use of the `modelBuilder.ApplyConfiguration` method. In the next subsection,
    we will extend the implementation of the data access layer through the use of
    the `Repositories` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to extend our APIs with the related entities, we should start from
    the bottom of our stack. First of all, let''s spread the capabilities of the data
    access layer by adding the following interfaces in the `Repositories` folder of
    the `Catalog.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `IArtistRepository` and `IGenreRepository` interfaces reflect the
    routes initially defined in this section: the `GetAsync` method returns the list
    of the secondary entities, the `GetAsync(Guid id)` returns the single object,
    and the `Add` method allows us to create a new entity. We can now define the actual
    implementations of the specified interfaces. Likewise, the `ItemRepository` class
    implementations will be stored in the `Catalog.Infrastructure` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the `ArtistRepository` type and provides the implementation
    for the `IArtistRepository` interface. The class uses `CatalogContext` as a communication
    hub between our application and the SQL database. The `GetAsync` and `GetAsync(Guid
    id)` methods use the same pattern already implemented in the `ItemRepository`
    class to retrieve the information related to the required entities. Furthermore,
    the `Add` method refers to the `Artists` field exposed by `CatalogContext` to
    add a new artist. It is important to note that, in this case, the `Add` operation
    doesn't update the data source directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by defining the `GenreRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the same way as `ArtistRepository`, we are implementing the operations for
    querying and manipulating the `Genre` entities. Although the names of the methods
    and the implementations are quite similar, I have chosen to keep the repository
    interfaces separated and redefine each implementation separately. A quicker approach
    would be to create a generic class that represents the typical behavior of `ItemRepository`,
    `ArtistRepository`, and `GenreRepository`, but the generic repositories are not
    always the right choice. In addition to this, building the wrong abstraction is
    a lot more expensive than duplicating code, and building a unique generic repository
    for everything means tight coupling the entities.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did with the `ItemRepositoryTests` class, we can proceed by testing `ArtistRepository`
    and `GenreRepository` using the same approach. In [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*, we defined `TestDataContextFactory`, which is
    part of the `Catalog.Fixtures` project. We can use this to instantiate an in-memory
    database for our test purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The previous code explores a way to implement the tests for the `ArtistRepository`
    class. The `ArtistRepositoryTests` class extends `IClassFixture<CatalogContextFactory>`
    to retrieve an instance of the `CatalogContextFactory` type. The test methods
    use the `ContextInstance` attribute to retrieve a new catalog context and to initialize
    a new repository.
  prefs: []
  type: TYPE_NORMAL
- en: They proceed by executing the method as a test and checking the results. It
    is important to notice that every test method uses the `LoadData` attribute in
    order to load the `artist` section of the `record-data.json` file. For brevity,
    I've omitted some of the test cases; however, the concept behind them is identical
    to what we have already seen, and it can be extended to the `GenreRepository`
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the IItemRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another step we can take to extend our web service project with the related
    entities is to implement two new methods to retrieve the items related to an artist
    or a genre in the `IItemRepository` interface: the `GetItemsByArtistIdAsync` and
    `GetItemsByGenreIdAsync` methods. Both of these methods can be used by the `GET
    /api/artists/{id}/items` and `GET /api/genre/{id}/items` routes to retrieve the
    items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by adding the following methods to the `IItemsRepository` interface
    and implementing them in the corresponding implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code extends the `IItemRepository` interface and its implementation in
    order to include the functionalities to query the items using `ArtistId` and `GenreId`.
    Both methods retrieve data using the `Where` clause and by calling the `Include`
    statement to include the related entities in the result of the query. Once we
    have fully extended the repository layer, we can continue by also extending the
    service classes.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the capabilities of the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new `Catalog.Infrastructure` functionalities extend the `Catalog.Domain`
    project and expose `IArtistRepository` and `IGenreRepository` to the controllers
    of the API project. First of all, we should create a couple of new service classes
    in the `Catalog.Domain` project in order to query the underlying `Catalog.Infrastructure`
    layer. Let''s start by defining the `IArtistService` and `IGenreService` interfaces
    in the `Services` folder of the `Catalog.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet contains the declarations of the `IArtistService`
    and `IGenreService` interfaces. For brevity, I've kept them in the same code snippet.
    Both interfaces define the methods in the lists, get the details, and then add
    a related entity. The `GetArtistsAsync()` and `GetGenreAsync()` methods can return
    the complete list of entities or a single entity, depending on whether the `request`
    parameter is specified or not. Additionally, it is possible to retrieve a list
    of `ItemResponse` by artist ID or genre ID using the `GetItemByArtistIdAsync`
    and `GetItemByGenreIdAsync` methods. Finally, we can add a new artist and genre
    using the `AddArtistAsync` and `AddGenreAsync` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding implementation also depends on the definition of the following
    request models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the request classes define the allowed operation for the `Artist` and
    `Genre` entities. They are stored in the `Requests/Artist` and `Requests/Genre`
    folders, respectively. We can continue by implementing the concrete part of the
    `ArtistService` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the properties and the constructor of the `ArtistService`
    class. The implementation injects the `IArtistRepository`, `IItemRepository`,
    `IArtistMapper`, and `IItemMapper` dependencies. The `Repositories` classes will
    be used for communicating with the underlying data source of the application.
    On the other side, the mappers will be called to initialize and map the values
    sent as responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined the dependencies of the `ArtistService` class, we can
    proceed with the implementation of the core methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The implementation represents the methods already defined in the `IArtistService`
    interface. It is quite easy to understand the purpose of the methods by looking
    at
  prefs: []
  type: TYPE_NORMAL
- en: their signatures.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetAsync` method invokes the `IArtistRepository` dependency to map and
    retrieve the result in an `ArtistResponse` object. `GetItemByArtistIdAsync` executes
    the corresponding method with the same name defined in the `IItemRepository` interface.
    Finally, `AddArtistAsync` executes the `Add` method defined in the `IArtistRepository`
    interface and executes the `UnitOfWork.SaveChangesAsync` method to apply the changes
    to the data source, and then map the resulting data.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach can be taken by the `GenreService` implementation class, which
    will depend on the `IGenreRepository` and `IGenreMapper` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the implementation of the `GenreService` class in the official
    GitHub repository of the book: [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should also remember to include the definition of these interfaces
    in the `AddServices` extension method defined in the previous chapter, by incorporating
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These changes register the `IArtistService` and `IGenreService` interfaces in
    order to be used by the controllers and the other dependencies of the application.
    In the next section, we will continue the implementation by adding some validation
    logic to the request models.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the validation mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in the previous chapter, we are using the `FluentValidation`
    package to implement the validation mechanism of the web service. Since we have
    built the service interfaces to handle the `Artist` and `Genre` entities, it is
    now possible to improve the validation checks already present in the `AddItemRequestValidator`
    and `EditItemRequestValidator` classes. Now, we are going to implement the existence
    check for the `Artist`- and `Genre`-related entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by extending the implementation of the `AddItemRequestValidator`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddItemRequestValidator` class now injects the `IArtistService` and `IGenreService`
    interfaces using the constructor injection pattern. In addition to this, the validation
    class defines two methods, `ArtistExists` and `GenreExists`, which will be used
    to verify that the `ArtistId` and `GenreId` fields exist in the database by calling
    the `IArtistService` and `IGenreService` interface methods. Moreover, we can improve
    the validation rules by checking the existence of the related entities in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The new rules bind the `ArtistId` and `GenreId` fields with the `ArtistExists`
    and `GenreExists` methods, respectively. The same approach can be taken for the
    `EditItemRequestValidator` implementation, which will use the same pattern to
    validate the related entities. Therefore, we now need to extend the test classes
    in order to verify the new validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code injects the `Mock<IArtistService>` and `Mock<IGenreService>`
    types into the validator class constructor in order to mock the behavior of the
    service layer and verify the logic of the validator class. It also uses the `ShouldHaveValidationErrorFor`
    method to check the expected response. The `ArtistExists` and `GenreExists` methods
    should throw a validation error in case the ID of one of the related entities
    is missing from the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the dependencies in the Startup class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous few sections, we created the `IArtistService` and `IGenreService`
    interfaces, and their corresponding implementations. Therefore, we want to update
    the dependency graph of the application. Although we have already called the `AddMappers`
    and `AddServices` extension methods of the `DependenciesRegistration` static class
    in the `ConfigureService` method, we need to update the dependencies in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also add `IArtistRepository` and `IGenreRepository` to the `ConfigureService`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `ConfigureServices` method of the `Startup` class defines all the required
    dependencies used by our stack. We are currently able to resolve the dependency
    chain related to the `ArtistController` and `GenreController` classes, which we
    will define in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the related controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Catalog.Domain` project is now capable of handling requests related to
    the `Artist` and `Genre` entities through the logic we implemented in the `IArtistService`
    and `IGenreService` classes. Therefore, we can proceed by creating the controller
    layer to handle the incoming HTTP requests. Since we have different separate entities,
    we are going to implement the `ArtistController` and `GenreController` controller
    classes. Let''s first focus on `ArtistController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code defines the initial signature of the `ArtistController` class:
    the implementation injects the `IArtistService` interface from the service layer
    in order to interact with the information stored in the database. We can proceed
    further, by defining the implementation of the `Get` and `GetById` action methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows the implementation of `ArtistController`, which corresponds
    to the `/api/artist` route. `ArtistController` uses `PaginatedItemsResponseModel`
    to retrieve the information related to all the artists. In the same way, we can
    use the `IAritstService` interface to execute the other operations and map them
    with the action methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `ArtistController` class defines the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Verb** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/artist` | Retrieves all the artists present in the database
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/artist/{id}` | Retrieves the artist with the corresponding
    *ID* |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/artist/{id}/items/` | Retrieves the items with the corresponding
    artist *ID* |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/api/artist/` | Creates a new artist and retrieves it |'
  prefs: []
  type: TYPE_TB
- en: 'For each route, the *catalog service* will retrieve the corresponding data
    by executing the `IArtistService` interface methods. The `ArtistService` implementation
    will dispatch the request to the corresponding method of the repository implementations
    contained in the `Catalog.Infrastructure` project. Similar to `ItemController`,
    we can implement any additional validation behavior by using `FluentValidation`.
    For example, in the case of `AddArtistRequest`, we can proceed with the following
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `AddArtistRequest`, we want to prevent the user from adding empty
    `ArtistName` fields. We can create an additional `AddArtistRequestValidator` class
    under the `Requests/Artist/Validator` path. The validator class contains only
    one rule related to the non-empty `ArtistName` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same implementation pattern can be also taken by the `GenreController`
    class. The following code defines the signature of the class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The code above injects the `IGenreService` interface using the *constructor
    injection* practice. Furthermore, we can proceed by creating the corresponding
    routes we defined for the `ArtistController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The code above defines the `Get`, `GetById`, `GetItemById` and the `Post` action
    methods implemented in the `GenreController` class. Each action calls the underlying
    service layer in order to interact with the database. Although the implementation
    of the action methods is similar to the `ArtistController` class, I still keep
    the classes separate; therefore, the `Genre` and `Artist` entities can evolve
    separately without depending on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Extending tests for the ArtistController class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we expose the API routes through the `ArtistController` and `GenreController`
    classes, we are able to proceed by testing the revealed paths using the same approach
    that we used for `ItemController`. We should continue by creating a new `ArtistControllerTests`
    class in the `Catalog.API.Tests` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code describes the test case for the get paginated artist action
    method and the get by ID action method. Both use the same `InMemoryApplicationFactory`
    factory to set up the fake in-memory data source. It is also possible to combine
    additional tests to verify the add artist process*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The fixture class initializes a new `TestServer` instance for each test method
    and it provides a new `HttpClient` instance through the `CreateClient` method
    to test the routes exposed by the `ArtistController` class. The tests also use
    the `LoadData` attribute to get matching information about the testing records
    from the `record-data.json` file. A similar implementation approach can be taken
    to test the `GenreController` class action methods.
  prefs: []
  type: TYPE_NORMAL
- en: A final overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at a quick overview of the code structure we implemented
    in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data
    Access Layer*, [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), *Implementing
    the Domain Logic*, and this chapter. The following architecture schema illustrates
    the actual construction of the `Catalog.API` solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef6629e2-50a2-4aa8-8e6a-a66028bcd14a.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the web service instance receives the client request, it dispatches the
    request to the corresponding action method of the controller. Following this,
    the action method executes the corresponding function exposed by the service classes
    defined in the `Catalog.Domain` project, which ships the request to the relevant
    repository defined in the `Catalog.Infrastructure` project, and then maps the
    entities with the request and response models.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered various topics regarding the design and development
    of the `Catalog.API` project. Moreover, it has shown you how to build the routes
    of our APIs. The topics covered in this chapter are part of the core implementation
    of our web services; therefore, they provide all the knowledge that is necessary
    for exposing HTTP routes and handling requests and responses in .NET Core. In
    addition to this, the chapter also covered integration testing and implementation
    using the web factory tools provided by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover other additional topics about web services,
    such as how to implement a soft-delete approach to our data and how to use a **Hypermedia
    As The Engine Of Application State** (**HATEOAS**) approach. The chapter will
    also cover some .NET Core-related topics such as a brief introduction to and the
    best practices of asynchronous programming in .NET Core.
  prefs: []
  type: TYPE_NORMAL
