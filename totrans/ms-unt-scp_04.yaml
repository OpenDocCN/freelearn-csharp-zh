- en: Chapter 4. Event-driven Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Update` events for `MonoBehaviour` objects seem to offer a convenient place
    for executing code that should perform regularly over time, spanning multiple
    frames, and possibly multiple scenes. When creating sustained behaviors over time,
    such as artificial intelligence for enemies or continuous motion, it may seem
    that there are almost no alternatives to filling an `Update` function with many
    `if` and `switch` statements, branching your code in different directions depending
    on what your objects need to do at the current time. But, when the `Update` events
    are seen this way, as a default place to implement prolonged behaviors, it can
    lead to severe performance problems for larger and more complex games. On deeper
    analysis, it's not difficult to see why this would be the case. Typically, games
    are full of so many behaviors, and there are so many things happening at once
    in any one scene that implementing them all through the `Update` functions is
    simply unfeasible. Consider the enemy characters alone, they need to know when
    the player enters and leaves their line of sight, when their health is low, when
    their ammo has expired, when they're standing on harmful terrain, when they're
    taking damage, when they're moving or not, and lots more. On thinking initially
    about this range of behaviors, it seems that all of them require constant and
    continuous attention because enemies should always know, instantly, when changes
    in these properties occur as a result of the player input. That is, perhaps, the
    main reason why the `Update` function seems to be the most suitable place in these
    situations but there are better alternatives, namely, event-driven programming.
    By seeing your game and your application in terms of events, you can make considerable
    savings in performance. This chapter then considers the issue of events and how
    to manage them game wide.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game worlds are fully deterministic systems; in Unity, the scene represents
    a shared 3D Cartesian space and timeline inside which finite `GameObjects` exist.
    Things only happen within this space when the game logic and code permits them
    to. For example, objects can only move when there is code somewhere that tells
    them to do so, and under specific conditions, such as when the player presses
    specific buttons on the keyboard. Notice from the example that behaviors are not
    simply random but are interconnected; objects move only when keyboard events occur.
    There is an important connection established between the actions, where one action
    entails another. These connections or linkages are referred to as events; each
    unique connection being a single event. Events are not active but passive; they
    represent moments of opportunity but not action in themselves, such as a key press,
    a mouse click, an object entering a collider volume, the player being attacked,
    and so on. These are examples of events and none of them say what the program
    should actually do, but only the kind of scenario that just happened. Event-driven
    programming starts with the recognition of events as a general concept and comes
    to see almost every circumstance in a game as an instantiation of an event; that
    is, as an event situated in time, not just an event concept but as a specific
    event that happens at a specific time. Understanding game events like these is
    helpful because all actions in a game can then be seen as direct responses to
    events as and when they happen. Specifically, events are connected to responses;
    an event happens and triggers a response. Further, the response can go on to become
    an event that triggers further responses and so on. In other words, the game world
    is a complete, integrated system of events and responses. Once the world is seen
    this way, the question then arises as to how it can help us improve performance
    over simply relying on the `Update` functions to move behaviors forward on every
    frame. And the method is simply by finding ways to reduce the frequency of events.
    Now, stated in this way, it may sound a crude strategy, but it's important. To
    illustrate, let's consider the example of an enemy character firing a weapon at
    the player during combat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the gameplay, the enemy will need to keep track of many properties.
    Firstly, their health, because when it runs low the enemy should seek out medical
    kits and aids to restore their health again. Secondly, their ammo, because when
    it runs low the enemy should seek to collect more and also the enemy will need
    to make reasoned judgments about when to fire at the player, such as only when
    they have a clear line of sight. Now, by simply thinking about this scenario,
    we''ve already identified some connections between actions that might be identified
    as events. But before taking this consideration further, let''s see how we might
    implement this behavior using an `Update` function, as shown in the following
    code sample 4-1\. Then, we''ll look at how events can help us improve on that
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code sample 4-1 shows a heavy `Update` function filled with lots
    of condition checking and responses. In essence, the `Update` function attempts
    to merge event handling and response behaviors into one and the results in an
    unnecessarily expensive process. If we think about the event connections between
    these different processes (the health and ammo check), we see how the code could
    be refactored more neatly. For example, ammo only changes on two occasions: when
    a weapon is fired or when new ammo is collected. Similarly, health only changes
    on two occasions: when an enemy is successfully attacked by the player or when
    an enemy collects a first-aid kit. In the first case, there is a reduction, and
    in the latter case, an increase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these are the only times when the properties change (the events), these
    are the only points where their values need to be validated. See the following
    code sample 4-2 for a refactored enemy, which includes C# properties and a much
    reduced `Update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The enemy class in the code sample 4-2 has been refactored to an event-driven
    design, where properties such as `Ammo` and `Health` are validated not inside
    the `Update` function but on assignment. From here, events are raised wherever
    appropriate based on the newly assigned values. By adopting an event-driven design,
    we introduce performance optimization and cleanness into our code; we reduce the
    excess baggage and value checks as found with the `Update` function in the code
    sample 4-1, and instead we only allow value-specific events to drive our code,
    knowing they'll be invoked only at the relevant times.
  prefs: []
  type: TYPE_NORMAL
- en: Event management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event-driven programming can make our lives a lot easier. But no sooner than
    we accept events into the design do we come across a string of new problems that
    require a thoroughgoing resolution. Specifically, we saw in the code sample 4-2
    how C# properties for health and ammo are used to validate and detect for relevant
    changes and then to raise events (such as `OnDead`) where appropriate. This works
    fine in principle, at least when the enemy must be notified about events that
    happen to itself. However, what if an enemy needed to know about the death of
    another enemy or needed to know when a specified number of other enemies had been
    killed? Now, of course, thinking about this specific case, we could go back to
    the enemy class in the code sample 4-2 and amend it to call an `OnDead` event
    not just for the current instance but for all other enemies using functions such
    as `SendMessage`, as we''ve seen in the previous chapters. But this doesn''t really
    solve our problem in the general sense. In fact, let''s state the ideal case straight
    away; we want every object to optionally listen for every type of event and to
    be notified about them as and when they happen, just as easily as if the event
    had happened to them. So the question that we face now is about how to code an
    optimized system to allow easy event management like this. In short, we need an
    `EventManager` class that allows objects to listen to specific events. This system
    relies on three central concepts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EventListener`: A listener refers to any object that wants to be notified
    about an event when it happens, even its own events. In practice, almost every
    object will be a listener for at least one event. An enemy, for example, may want
    notifications about low health and low ammo among others. In this case, it''s
    a listener for at least two separate events. Thus, whenever an object expects
    to be told when an event happens, it becomes a listener.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventPoster`: In contrast to listeners, when an object detects that an event
    has occurred, it must announce or post a public notification about it that allows
    all other listeners to be notified. In the code sample 4-2, the enemy class detects
    the `Ammo` and `Health` events using properties and then calls the internal events,
    if required. But to be a true poster in this sense, we require that the object
    must raise events at a global level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventManager`: Finally, there''s an overarching singleton `EventManager` object
    that persists across levels and is globally accessible. This object effectively
    links listeners to posters. It accepts notifications of events sent by posters
    and then immediately dispatches the notifications to all appropriate listeners
    in the form of events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting event management with interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first or original entity in the event handling system is the listener—the
    thing that should be notified about specific events as and when they happen. Potentially,
    a listener could be any kind of object or any kind of class; it simply expects
    to be notified about specific events. In short, the listener will need to register
    itself with the `EventManager` as a listener for one or more specific events.
    Then, when the event actually occurs, the listener should be notified directly
    by a function call. So, technically, the listener raises a type-specificity issue
    for the `EventManager` about how the manager should invoke an event on the listener
    if the listener could potentially be an object of any type. Of course, this issue
    can be worked around, as we've seen, using either `SendMessage` or `BroadcastMessage`.
    Indeed, there are event handling systems freely available online, such as `NotificationCenter`
    that rely on these functions. However, in this chapter, we'll avoid them using
    interfaces and use polymorphism instead, as both `SendMessage` and `BroadcastMessage`
    rely heavily on reflection (information on reflection is covered later in [Chapter
    8](ch08.html "Chapter 8. Customizing the Unity Editor"), *Customizing the Unity
    Editor*). Specifically, we'll create an interface from which all listener objects
    derive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the freely available `NotificationCenter` (C# version) is
    available from the Unity wiki at [http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter](http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter).
  prefs: []
  type: TYPE_NORMAL
- en: In C#, an interface is like a hollow abstract base class. Like a class, an interface
    brings together a collection of methods and functions into a single template-like
    unit. But, unlike a class, an interface only allows you to define function prototypes
    such as the name, return type, and arguments for a function. It doesn't let you
    define a function body. The reason being that an interface simply defines the
    total set of functions that a derived class will have. The derived class may implement
    the functions however necessary, and the interface simply exists so that other
    objects can invoke the functions via polymorphism without knowing the specific
    type of each derived class. This makes interfaces a suitable candidate to create
    a `Listener` object. By defining a `Listener` interface from which all objects
    will be derived, every object has the ability to be a listener for events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample 4-3 demonstrates a sample `Listener` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments on the code sample 4-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 06-10**: This enumeration should define a complete list of all possible
    game events that could be raised. The sample code lists only five game events:
    `GAME_INIT`, `GAME_END`, `AMMO_EMPTY`, `HEALTH_CHANGE`, and `DEAD`. Your game
    will presumably have many more. You don''t actually need to use enumerations for
    encoding events; you could just use integers. But I''ve used enumerations to improve
    event readability in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 13-17**: The `Listener` interface is defined as `IListener` using the
    C# interfaces. It supports just one event, namely `OnEvent`. This function will
    be inherited by all derived classes and will be invoked by the manager whenever
    an event occurs for which the listener is registered. Notice that `OnEvent` is
    simply a function prototype; it has no body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on C# interfaces can be found at [http://msdn.microsoft.com/en-us/library/ms173156.aspx](http://msdn.microsoft.com/en-us/library/ms173156.aspx).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the `IListener` interface, we now have the ability to make a listener
    from any object using only class inheritance; that is, any object can now declare
    itself as a listener and potentially receive events. For example, a new `MonoBehaviour`
    component can be turned into a listener with the following code sample 4-4\. This
    code, as in the previous chapters, uses multiple inheritance, that is, it inherits
    from two classes. More information on multiple inheritance can be found at [http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp](http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating an EventManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any object can now be turned into a listener, as we''ve seen. But still the
    listeners must register themselves with a manager object of some kind. Thus, it
    is the duty of the manager to call the events on the listeners when the events
    actually happen. Let''s now turn to the manager itself and its implementation
    details. The manager class will be called `EventManager`, as shown in the following
    code sample 4-5\. This class, being a persistent singleton object, should be attached
    to an empty `GameObject` in the scene where it will be directly accessible to
    every other object through a static instance property. More on this class and
    its usage is considered in the subsequent comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `OnLevelWasLoaded` event can be found at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the comments on the code sample 4-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 003**: Notice the addition of the `System.Collections.Generic` namespace
    giving us access to additional mono classes, including the `Dictionary` class.
    This class will be used throughout the `EventManager` class. More information
    on mono and its classes are explained later in [Chapter 6](ch06.html "Chapter 6. Working
    with Mono"), *Working with Mono*. In short, the `Dictionary` class is a special
    kind of 2D array that allows us to store a database of values based on key-value
    pairing. More information on the `Dictionary` class can be found at [http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 007**: The `EventManager` class is derived from `MonoBehaviour` and
    should be attached to an empty `GameObject` in the scene where it will exist as
    a persistent singleton.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 024**: A private member variable `Listeners` is declared using a `Dictionary`
    class. This structure maintains a hash-table array of key-value pairs, which can
    be looked up and searched like a database. The key-value pairing for the `EventManager`
    class takes the form of `EVENT_TYPE` and `List<Component>`. In short, this means
    that a list of event types can be stored (such as `HEALTH_CHANGE`), and for each
    type there could be none, one, or more components that are listening and which
    should be notified when the event occurs. In effect, the `Listeners` member is
    the primary data structure on which the `EventManager` relies to maintain who
    is listening for what. For more detailed information on the Mono Framework and
    common classes within it, refer to [Chapter 6](ch06.html "Chapter 6. Working with
    Mono"), *Working with Mono*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 029-039**: The `Awake` function is responsible for the singleton functionality,
    that is, to make the `EventManager` class into a singleton object that persists
    across scenes. For more information on persistent singletons, refer to [Chapter
    3](ch03.html "Chapter 3. Singletons, Statics, GameObjects, and the World"), *Singletons,
    Statics, GameObjects, and the World*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 046-063**: The `AddListener` method of `EventManager` should be called
    by a `Listener` object once for each event for which it should listen. The method
    accepts two arguments: the event to listen for (`Event_Type`) and a reference
    to the listener object itself (derived from `IListener`), which should be notified
    if and when the event happens. The `AddListener` function is responsible for accessing
    the `Listeners` dictionary and generating a new key-value pair to store the connection
    between the event and the listener.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 071-088**: The `PostNotification` function can be called by any object,
    whether a listener or not, whenever an event is detected. When called, the `EventManager`
    cycles all matching entries in the dictionary, searching for all listeners connected
    to the current event, and notifies them by invoking the `OnEvent` method through
    the `IListener` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 098-127**: The final methods for the `EventManager` class are responsible
    for maintaining data integrity of the `Listeners` structure when a scene change
    occurs and the `EventManager` class persists. Although the `EventManager` class
    persists across scenes, the listener objects themselves in the `Listeners` variable
    may not do so. They may get destroyed on scene changes. If so, scene changes will
    invalidate some listeners, leaving the `EventManager` with invalid entries. Thus,
    the `RemoveRedundancies` method is called to find and eliminate all invalid entries.
    The `OnLevelWasLoaded` event is invoked automatically by Unity whenever a scene
    change occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dictionaries**'
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about dictionaries is not just their access speed as a dynamic
    array (which is comparatively fast) but also the way you work with them through
    object types and the array subscript operator. In a typical array, every element
    must be accessed by its numerical and integer index, such as `MyArray[0]` and
    `MyArray[1]`. But with dictionaries, the case is different. Specifically, you
    can access elements using objects of `EVENT_TYPE`, which represents the key part
    of the key-value pair, for example, `MyArray[EVENT_TYPE.HEALTH_CHANGE]`. For more
    information on dictionaries, see the official Microsoft documentation at [http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Code folding in MonoDevelop with #region and #endregion'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two preprocessor directives `#region` and `#endregion` (in combination
    with the code folding feature) can be highly useful for improving the readability
    of your code and also for improving the speed with which you can navigate the
    source file. They add organization and structure to your source code without affecting
    its validity or execution. Effectively, `#region` marks the top of a code block
    and `#endregion` marks the end. Once a region is marked, it becomes foldable,
    that is, it becomes collapsible using the `MonoDevelop` code editor, provided
    the code folding feature is enabled. Collapsing a region of code is useful for
    hiding it from view, which allows you to concentrate on reading other areas relevant
    to your needs, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code folding in MonoDevelop with #region and #endregion](img/0655OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling code folding in MonoDevelop
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable code folding in `MonoDevelop`, select **Options** in **Tools** from
    the application menu. This displays the **Options** window. From here, choose
    the **General** tab in the **Text Editor** option and click on **Enable code folding**
    as well as **Fold #regions by default**.'
  prefs: []
  type: TYPE_NORMAL
- en: Using EventManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s see how to put the `EventManager` class to work in a practical
    context from the perspective of listeners and posters in a single scene. First,
    to listen for an event (any event) a listener must register itself with the `EventManager`
    singleton instance. Typically, this will happen once and at the earliest opportunity,
    such as the `Start` function. Do not use the `Awake` function; this is reserved
    for an object''s internal initialization as opposed to the functionality that
    reaches out beyond the current object to the states and setup of others. See the
    following code sample 4-6 and notice that it relies on the `Instance` static property
    to retrieve a reference to the active `EventManager` singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Having registered listeners for one or more events, objects can then post notifications
    to `EventManager` as events are detected, as shown in the following code sample
    4-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after a notification is posted for an event, all the associated listeners
    are updated automatically through `EventManager`. Specifically, `EventManager`
    will call the `OnEvent` function of each listener, giving listeners the opportunity
    to parse event data and respond where needed, as shown in the following code sample
    4-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a demonstration on using `EventManager`, see the `events` folder project
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative with delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces are an efficient and trim way of implementing an event handling
    system, but they are not the only way. We can also use a C# feature, known as
    delegates. Essentially, we can create a function and store a reference to it inside
    a variable. This variable allows you to treat functions as a reference type variable.
    That is, with delegates, you can store references to functions, which can then
    be used later to invoke the function itself. Other languages, such as C++, offer
    a similar behavior through function pointers. By implementing the event system
    using delegates, we eliminate the need for interfaces. Consider the following
    code sample 4-7, which is an alternative implementation of `EventManager` using
    delegates. Relevant code changes are highlighted to help illustrate the differences
    between the interface and delegate implementations. Apart from minor changes to
    accommodate the delegate types, all other functions remained unchanged, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on C# delegates can be found in the Microsoft documentation
    at [http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx](http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the comments on the code sample 4-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 005-011**: Here, the event type enumeration has been shifted into the
    `EventManager` file from the original `IListener` class. Since the delegate implementation
    avoids the need for interfaces and for `IListener` specifically, the enumeration
    can be shifted to the manager source file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 032**: The public member `OnEvent` is declared as a delegate type. Notice
    that the declaration is hybrid insofar as it combines variable declaration style
    with a function prototype. This specifies the function prototype that may be assigned
    to the delegate variable; any function with that structure can be assigned from
    any class or any script file. Thus, the `OnEvent` function becomes a delegate
    type, and this is used in the next statement creating the internal dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 035**: The private dictionary listeners is declared, and for each event
    type, an array of delegates (instead of interfaces) is stored; each delegate refers
    to a function that should be invoked when the event occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 097**: Critically, the `PostNotification` function is called on `EventManager`
    to invoke all the delegates (listener functions) when an event occurs. This happens
    at line 097 with the statement `ListenList[i](Event_Type, Sender, Param);`. This
    invokes the delegate just like a function, as shown in the following screenshot:![Alternative
    with delegates](img/0655OT_04_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the EventManager projects
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding screenshot shows the `EventManager` projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the `EventManager` delegate implementation in action, see the `events_delgateversion`
    folder project in code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: MonoBehaviour events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To close this chapter, let's consider some of the events Unity offers us already
    for working with event-driven programming. The `MonoBehaviour` class already exposes
    a wide range of events that are called automatically under specific conditions.
    These functions or events begin with the prefix `On` and include events such as
    `OnGUI`, `OnMouseEnter`, `OnMouseDown`, `OnParticleCollision`, and others. This
    section considers some details for common event types.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full list of `MonoBehaviour` events can be found in the Unity documentation
    at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
  prefs: []
  type: TYPE_NORMAL
- en: Mouse and tap events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One set of useful events is the mouse-input and touch-input set of events. These
    include `OnMouseDown`, `OnMouseEnter`, and `OnMouseExit`. In the earlier versions
    of Unity, these events were only triggered for mouse-specific events and not touch
    input. But more recently, touch input has been mapped to them; meaning that a
    tap will now register by default as a mouse event. To clarify, `OnMouseDown` is
    called once when a mouse button is pressed down while the cursor is hovering on
    an object. The event is not, however, called repeatedly until the button is released.
    Likewise, `OnMouseEnter` is called once when a cursor first hovers over an object
    without having exited and `OnMouseExit` is called when the cursor hovers away
    from an object it has previously entered. The success of these events depends
    on an object having a collider component attached to approximate its volume within
    which mouse events are detected. This means that none of the mouse events will
    fire without a collider attached to the object.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are occasions when `MouseEvents` will not fire, even with a collider
    attached, because other objects (with colliders) are obscuring the objects you
    need to click on based on the current view from the active camera. That is, the
    clickable objects are in the background. You can, of course, solve the issue (at
    least in many cases) by simply assigning the foreground objects to an `IgnoreRaycast`
    layer making them immune from physics raycast operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign an object to an `IgnoreRaycast` layer, just select the object in
    the scene and then click on the **Layer** dropdown in the Object Inspector, assigning
    the object to the **Ignore Raycast** layer, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse and tap events](img/0655OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assigning objects to the Ignore Raycast layer
  prefs: []
  type: TYPE_NORMAL
- en: 'But even this just isn''t feasible sometimes. Often you''ll need multiple cameras
    and many objects with colliders, and they''ll sometimes obscure objects you want
    to select or adjust according to mouse input events. In these cases, you may need
    to manually handle mouse input events. The following code sample 4-8 achieves
    these, invoking specific mouse events manually on the basis of input. In essence,
    this code uses the `Raycast` system to redirect manually detected input events
    to the `MonoBehaviour` mouse events. This code uses **Coroutines** too; considered
    after the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Coroutines**'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines are a special kind of function. They behave like threads insofar
    as they appear to run in parallel or asynchronously to the main game loop, that
    is, once you execute them, they seem to run in the background. Execution doesn't
    pause or wait until the function is completed as it does with traditional functions.
    This makes Coroutines great for creating asynchronous-looking behaviors. Technically,
    all Coroutines must return a type of `IEnumerator`, contain at least one yield
    statement in their body, and must be launched with the `StartCoroutine` function.
    The yield statement is a special statement that suspends execution of the Coroutine
    until its condition is met. The statement yield return new `WaitForSeconds(x)`
    will pause execution for `x` seconds, resuming after the interval at the next
    line. In contrast, the statement yield returned `null` will suspend execution
    for the current frame, resuming execution at the next line on the next frame.
    More information on Coroutines and their use can be found in the Unity documentation
    at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  prefs: []
  type: TYPE_NORMAL
- en: Application focus and pausing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three additional `MonoBehaviour` events are notable for causing confusion or
    surprise about their operation. They are: `OnApplicationPause`, `OnApplicationFocus`,
    and `OnApplicationQuit`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnApplicationQuit` is sent to all objects in the scene just before the game
    exits but before the scene and its contents are effectively destroyed. If the
    game is being tested in the editor, then `OnApplicationQuit` is called when playback
    is stopped. Significantly, however, `OnApplicationQuit` may not be called for
    iOS devices, which usually don''t quit or exit applications but rather suspend
    them while users do other things, which allows them to return and resume from
    where they left off. If you need or want to receive `OnApplicationQuit` events
    on suspension, you''ll need to enable the relevant option from the **Player Settings**
    window. To access this, navigate to **Edit** | **Project Settings** | **Player**
    from the application menu and then from the Object Inspector, expand the **Other
    Settings** tab for the iOS builds and enable the **Exit on Suspend** checkbox,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application focus and pausing](img/0655OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling the exit on suspend option for iOS
  prefs: []
  type: TYPE_NORMAL
- en: '`OnApplicationFocus` is an event sent to all objects in the scene when the
    game loses focus, typically when the game window is deactivated on desktop computers
    during multitask operations. This can be a significant in-game event, especially
    for multiplayer games where action and events in a shared world continue, even
    when one or more of the players are not actively participating. In these cases,
    you may need to pause or resume specific behaviors or fade-in or fade-out game
    music.'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnApplicationPause` is an ambiguous event because the concept of a pause in
    Unity is not clearly defined. There are, I believe, two distinct kinds of pauses,
    namely, an ultimate and relative pause. The ultimate kind is where every activity
    and every event in a game is totally suspended; in this state, there is no passing
    of time and nothing can move forward. The relative kind, in contrast, is the most
    common. Here, the game is self-conscious or aware of being in a paused state;
    it halts some events, such as in-world events, but allows other events to continue
    such as GUI interaction and user input, which can unpause the game. The `OnApplicationPause`
    event refers to the first kind of pause and not the latter. This event will be
    called when several conditions are met. These are considered in the next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: First, `OnApplicationPause` will only be called on the desktop if the **Run
    In Background** option is not enabled in the **Player Settings** tab, under the
    **Resolution** group, as shown in the following screenshot. This option, when
    disabled, will automatically pause a desktop game whenever the window focus is
    lost. This means `OnApplicationPause` will follow an `OnApplicationFocus` event.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application focus and pausing](img/0655OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Disabling the Run In Background option
  prefs: []
  type: TYPE_NORMAL
- en: In iOS, `OnApplicationPause` will be called whenever the application is minimized
    or pushed into the background.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not rely on the `OnApplicationPause` event for creating your own relative
    pause functionality. To achieve this, use the `Time.timeScale` variable or code
    a more comprehensive system in which you have selective control over which elements
    are paused.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on the manifold benefits available for your applications
    by adopting an event-driven framework consistently through the `EventManager`
    class. In implementing such a manager, we were able to rely on either interfaces
    or delegates, and either method is powerful and extensible. Specifically, we saw
    how it's easy to add more and more functionality into an `Update` function but
    how doing this can lead to severe performance issues. Better is to analyze the
    connections between your functionality to refactor it into an event-driven framework.
    Essentially, events are the raw material of event-driven systems. They represent
    a necessary connection between one action (the cause) and another (the response).
    To manage events, we created the `EventManager` class—an integrated class or system
    that links posters to listeners. It receives notifications from posters about
    events as and when they happen and then immediately dispatches a function call
    to all listeners for the event. In the next chapter, we'll examine cameras and
    rendering.
  prefs: []
  type: TYPE_NORMAL
