<html><head></head><body>
        

                            
                    <h1 class="header-title">Improving Application Performance</h1>
                
            
            
                
<p>The performance of <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) applications, in general, is one of its biggest problems. The more visual layers that our rendered data objects and UIs contain, the more time it takes to render them, so we often need to maintain a balance between making our applications visually appealing and making them perform better.</p>
<p>This situation can be improved by running our WPF applications on more powerful computers. This explains why these applications are most prevalent in the financial industry. However, not everyone can afford to update all of their users' computers for this purpose.</p>
<p>Luckily, there are a number of ways in which we can improve the performance of our WPF applications, and we'll investigate them here. The art of improving application performance really comes down to making a lot of small improvements that, together, all add up to a noticeable difference.</p>
<p>In this chapter, we'll explore how we can better utilize the graphics rendering power of our computer's graphics card and declare our resources more efficiently. We'll investigate how we can improve our application's performance by opting to use lighter weight UI controls, more efficient data binding modes, and by employing other techniques, such as virtualization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Leveraging the power of hardware rendering</h1>
                
            
            
                
<p>As we've already learned, the visuals that WPF can output, while beautiful, can be very CPU-intensive and we often need to bear this in mind when designing our Views. However, rather than compromising our designs, we can offload the intensive rendering processes to the host computer's <strong>Graphics Processing Unit</strong> (<strong>GPU</strong>) instead.</p>
<p>While WPF will default to utilize its software rendering pipeline, it is also able to take advantage of a hardware rendering pipeline. This hardware pipeline leverages features of Microsoft DirectX, as long as the host PC has DirectX version 7, or higher, installed. Furthermore, if the version of DirectX that is installed is version 9 or higher, increased performance improvements will be seen.</p>
<p>The WPF Framework looks at the graphics hardware that is installed on the computer that it is running on and puts it into one of three categories, depending on its features, such as video RAM, shaders, and support for multi-textures. If it does not support version 7 of DirectX or higher, then it is classed in Rendering Tier 0 and will not be used for hardware rendering at all.</p>
<p>However, if it does support DirectX version 7 or higher, but less than version 9, then it is classed in Rendering Tier 1 and will be used for partial hardware rendering. However, as practically all new graphics cards support versions of DirectX higher than 9, they would all be classed in Rendering Tier 2 and would be used for full hardware rendering.</p>
<p>As the UI will freeze during the rendering time, care should be taken to minimize the number of visual layers that are rendered. Therefore, for WPF applications that will run on computers that have graphics hardware classed in Rendering Tier 0 and use software rendering, we need to take extra care.</p>
<p>However, if our application is likely to be run on older computers, or computers with older graphics hardware, we can detect this using the rendering tier and run more efficient code in these instances. We can find out the rendering tier of the host computer's graphics hardware using the static <kbd>Tier</kbd> property of the <kbd>RenderCapability</kbd> class.</p>
<p>Unfortunately, instead of the type of this property being some kind of useful enumeration, it is, in fact, an integer, where only the high-order word represents the value of the tier and can be either <kbd>0</kbd>, <kbd>1</kbd>, or <kbd>2</kbd>. We can attain it by shifting the bits in the integer to read the value from just the last two bytes:</p>
<pre>using System.Windows.Media;

...

int renderingTier = RenderCapability.Tier &gt;&gt; 16; </pre>
<p>Once we know the rendering tier of the host computer's graphics hardware, we can write code accordingly. For example, let's imagine that we had a processor-intensive View, with lots of visuals making up each item in a collection. We could set the tier value to a property and data bind it to the View, where we could select different data templates to use depending on the processing power of the host computer. Let's examine this example by first creating the missing enumeration:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Enums 
{ 
  public enum RenderingTier 
  { 
    Zero = 0, 
    One = 1, 
    Two = 2 
  } 
} </pre>
<p>Next, we need to add a property of the <kbd>RenderingTier</kbd> type into our <kbd>StateManager</kbd> class from <a href="b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml">Chapter 3</a>, <em>Writing Custom Application Frameworks</em>:</p>
<pre>public RenderingTier RenderingTier { get; set; } </pre>
<p>We don't need to inform the <kbd>INotifyPropertyChanged</kbd> interface of any changes to this property because it will only be set once upon application startup. Let's adjust our previous example:</p>
<pre>public App() 
{ 
  StateManager.Instance.RenderingTier =  
    (RenderingTier)(RenderCapability.Tier &gt;&gt; 16); 
} </pre>
<p>After casting the bit shifted integer value into our <kbd>RenderingTier</kbd> enumeration and setting it to the new <kbd>RenderingTier</kbd> property in the <kbd>StateManager</kbd> class, we can then start to use it in our Views to determine the level of visualizations that we can employ:</p>
<pre>&lt;ListBox ItemsSource="{Binding Products}"&gt; 
  &lt;ListBox.Style&gt; 
    &lt;Style TargetType="{x:Type ListBox}"&gt; 
      &lt;Setter Property="ItemTemplate"  
        Value="{StaticResource SimpleDataTemplate}" /&gt; 
      &lt;Style.Triggers&gt; 
        &lt;DataTrigger Binding="{Binding  
          StateManager.Instance.RenderingTier}" Value="One"&gt; 
          &lt;Setter Property="ItemTemplate"  
            Value="{StaticResource MoreComplexDataTemplate}" /&gt; 
        &lt;/DataTrigger&gt; 
        &lt;DataTrigger Binding="{Binding  
          StateManager.Instance.RenderingTier}" Value="Two"&gt; 
          &lt;Setter Property="ItemTemplate"  
            Value="{StaticResource MostComplexDataTemplate}" /&gt; 
        &lt;/DataTrigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/ListBox.Style&gt; 
&lt;/ListBox&gt; </pre>
<p>In this example, we have a <kbd>ListBox</kbd> control that is displaying a collection of products. The idea is that we can declare three different data templates to define what each product will look like. We have a <kbd>SimpleDataTemplate</kbd> template that might just provide a text-based output, a <kbd>MoreComplexDataTemplate</kbd> template that could contain some basic visuals, and a <kbd>MostComplexDataTemplate</kbd> template that could contain several layers of visuals.</p>
<p>In the style that is applied to the list box, we set the default <kbd>SimpleDataTemp</kbd><kbd>late</kbd> template as the value of its <kbd>ItemTemplate</kbd> property. Using the <kbd>RenderingTier</kbd> property of the <kbd>StateManager</kbd> class, we then declare a couple of data triggers to switch the value of the <kbd>ItemTemplate</kbd> property to one of the more complex templates, depending on the rendering tier of the host computer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making more efficient resources</h1>
                
            
            
                
<p>When we reference our resources, we can either use a <kbd>StaticResource</kbd> or a <kbd>DynamicResource</kbd>. If you remember from <a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, <em>Using the Right Controls for the Job</em>, a <kbd>StaticResource</kbd> will look up the value of the resource just once, which is comparative to a compile-time lookup. A <kbd>DynamicResource</kbd> will repeatedly look up the value of the resource each time it is requested, whether it has changed or not, just like a runtime lookup.</p>
<p>For this reason, we should only ever use a <kbd>DynamicResource</kbd> if we really need to, as we can attain a much better performance by using the <kbd>StaticResource</kbd> class instead. If we find that we need to use a lot of <kbd>DynamicResource</kbd> references to access our resources, then we can refactor our code to data bind to properties in our <kbd>StateManager</kbd> class instead of the resources, in order to increase performance.</p>
<p>Another simple way to improve the performance of our resources is to reuse them. Instead of declaring them inline in the place that they are used in the XAML, we should declare them in a suitable resource section and reference them.</p>
<p>In this way, each resource is created just once and shared. To extend this idea further, we could define all of our shared resources in the application resources in the <kbd>App.xaml</kbd> file and share them between all of the application Views.</p>
<p>Imagine a situation where some brush resources were declared inline with the XAML within a <kbd>DataTemplate</kbd> element. Now imagine that this template is set as the <kbd>ItemTemplate</kbd> of an <kbd>ItemsControl</kbd> object and that the collection that is data bound to its <kbd>ItemsSource</kbd> property contains a thousand elements.</p>
<p>The application will, therefore, create a thousand brush objects with identical properties for each brush that is declared locally within the data template. Now compare this to another situation where we declare each required brush just once in a resource section and reference it from the template. It's clear to see the benefit of this method and the huge savings that can be made of the computer's resources.</p>
<p>Furthermore, this idea also affects the <kbd>Resources</kbd> sections of our Views, especially if we are displaying more than one of them at once. If we declare a View to define how each object in a collection should be rendered, then all of the resources that are declared in the View will be initialized once for each element in the collection. In this case, it is better to declare them at the application level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Freezing objects</h1>
                
            
            
                
<p>In WPF, certain resource objects, such as animations, geometries, brushes, and pens, can be made <kbd>Freezable</kbd>. This provides special features that can help to improve the performance of our WPF applications. <kbd>Freezable</kbd> objects can either be frozen or unfrozen. In the unfrozen state, they behave like any other object; however, when frozen, they become immutable and can no longer be modified.</p>
<p>The main benefit of freezing objects is that it can improve application performance, because frozen objects no longer require resources to be consumed when monitoring and issuing change notifications. Another benefit is that a frozen object is also safe to be shared across threads, unlike unfrozen objects.</p>
<p>Many UI-related objects extend the <kbd>Freezable</kbd> class to provide this functionality and most <kbd>Freezable</kbd> objects relate to the graphics sub-system, as rendering visuals is one of the areas where performance improvements are most needed.</p>
<p>Classes such as the <kbd>Brush</kbd>, <kbd>Geometry</kbd>, and <kbd>Transform</kbd> classes contain unmanaged resources and the system must monitor them for changes. By freezing these objects and making them immutable, the system is able to free up its monitoring resources and better utilize them elsewhere. Furthermore, even the memory footprint of a frozen object is considerably less than its unfrozen counterpart.</p>
<p>Therefore, in order to make the greatest performance improvements, we should get used to freezing all of our resources in all of the <kbd>Resource</kbd> sections, as long as we have no plans to modify them. As most resources typically remain unmodified, we are usually able to freeze the vast majority of them and gain significant and noticeable improvements in performance by doing so.</p>
<p>In <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>, <em>Creating Visually Appealing User Interfaces</em>, we learned how to freeze a <kbd>Freezable</kbd> object in code by calling its <kbd>Freeze</kbd> method. Let's now look at how we can freeze our resources in XAML. First, we need to add a XAML namespace prefix to the presentation options namespace to access its <kbd>Freeze</kbd> attribute:</p>
<pre>xmlns:PresentationOptions=
  "http://schemas.microsoft.com/winfx/2006/xaml/presentation/options <br/>" 
mc:Ignorable="PresentationOptions" </pre>
<p>Note that we also include another XAML namespace prefix to be able to access the <kbd>Ignorable</kbd> attribute, and we set our <kbd>PresentationOptions</kbd> prefix as its value. This is because the <kbd>Freeze</kbd> attribute is primarily only recognized by the WPF XAML processor, and, in order to maintain compatibility with other XAML readers, we need to specify that the attribute can be ignored.</p>
<p>We'll find a full example in the <em>Drawing conclusions</em> section coming up soon, but for now, using a resource from an earlier example, let's examine how to freeze a <kbd>Freezable</kbd> object in XAML:</p>
<pre>&lt;DropShadowEffect x:Key="Shadow" BlurRadius="10" Direction="270"  
  ShadowDepth="7" Opacity="0.5" PresentationOptions:Freeze="True" /&gt; </pre>
<p>Some <kbd>Freezable</kbd> objects, such as the animation and geometry objects, can contain other <kbd>Freezable</kbd> objects. When a <kbd>Freezable</kbd> object is frozen, its child objects are also frozen. However, there are a few cases where a <kbd>Freezable</kbd> object cannot be frozen.</p>
<p>One case happens if it has any properties that might change in value, due to animations, data binding, or <kbd>DynamicResource</kbd> references. The other case occurs when the <kbd>Freezable</kbd> object has any child objects that cannot be frozen.</p>
<p>If we are freezing resource type objects in the code behind of a custom control, for example, then we can call the <kbd>CanFreeze</kbd> property of the <kbd>Freezable</kbd> class to check whether each <kbd>Freezable</kbd> object can be frozen before attempting to freeze them:</p>
<pre>EllipseGeometry ellipseGeometry =  
  new EllipseGeometry(new Rect(0, 0, 500, 250)); 
if (ellipseGeometry.CanFreeze) ellipseGeometry.Freeze(); 
Path.Data = ellipseGeometry; </pre>
<p>Once a <kbd>Freezable</kbd> object is frozen, it cannot be modified, and attempting to do so will cause an <kbd>InvalidOperationException</kbd> to be thrown. Note that a <kbd>Freezable</kbd> object cannot be unfrozen; so, to avoid this situation, we can check the value of the <kbd>IsFrozen</kbd> property before attempting to modify the object. If it is frozen, we can make a copy of it using its <kbd>Clone</kbd> method and modify that instead:</p>
<pre>if (ellipseGeometry.IsFrozen) 
{ 
  EllipseGeometry ellipseGeometryClone = ellipseGeometry.Clone(); 
  ellipseGeometryClone.RadiusX = 400; <br/>  ellipseGeometryClone.Freeze();<br/>  Path.Data = ellipseGeometryClone; <br/>} <br/>else ellipseGeometry.RadiusX = 400; </pre>
<p>If a <kbd>Freezable</kbd> object is cloned, any <kbd>Freezable</kbd> children that it might have will also be copied to enable modification. When a frozen object is animated, the animation system will make cloned copies of it in this way so that it can modify them. But, as this adds an overhead to performance, it is advisable not to freeze a <kbd>Freezable</kbd> object if you expect to be animated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the right controls for performance</h1>
                
            
            
                
<p>As we mentioned previously, there are usually several different ways of achieving the same functionality, or UI display, when using WPF. Some ways will provide better performance than others. For example, we learned how some panels do more intensive layout work and, therefore, consume more CPU cycles and/or RAM than others.</p>
<p>Therefore, this is one area that we can investigate in order to make performance improvements. If we do not require the complex layout and resizing abilities of a <kbd>Grid</kbd> panel, then we can gain a performance improvement by utilizing a more efficient <kbd>StackPanel</kbd> or <kbd>Canvas</kbd> panel instead.</p>
<p>Another example could be that if we do not require the ability to select in a collection control, then we should use an <kbd>ItemsControl</kbd> element instead of a <kbd>ListBox</kbd>. While swapping one control will not make much of a performance improvement on its own, making this same swap in the <kbd>DataTemplate</kbd> of an item that will be displayed thousands of times will make a noticeable difference.</p>
<p>As we discovered in <a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, <em>Using the Right Controls for the Job</em>, each time a UI element is rendered, the layout system must complete two passes, a measure pass and an arrange pass, which is collectively known as a layout pass. If the element has children and/or grandchildren, they will all need to complete the layout pass too. This process is intensive and the fewer passes that can be made, the quicker our Views will render.</p>
<p>As mentioned earlier, we need to be careful to ensure that we do not unnecessarily trigger additional passes of the layout system, as this can lead to poor performance. This can occur when adding or removing items to or from a panel, applying transforms on the elements, or by calling the <kbd>UIElement.UpdateLayout</kbd> method, which forces a new layout pass.</p>
<p>Because of the way that changes to a UI element will invalidate its children and force a new layout pass, we need to be especially careful when building hierarchical data in code. If we create the child elements first, then their parent objects, and then the parents of those objects, and so on, we will incur a huge performance hit, due to the existing child items being forced to perform multiple layout passes.</p>
<p>In order to address this issue, we need to always ensure that we build our tree from the top-down, rather than the top-up method just described. If we add the parent element(s) first, then add their children and their children if any, we can avoid the additional layout passes. The performance improvement of using the top-down method is approximately five times quicker to render, and so is not insignificant. Let's take a look at some further control-related performance benefits that we can employ next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing conclusions</h1>
                
            
            
                
<p>When we have a requirement to draw shapes in our UI, such as in our callout window example in <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>, <em>Creating Visually Appealing User Interfaces</em>, we tend to use the abstract <kbd>Shape</kbd> class or, more accurately, one or more of its derived classes.</p>
<p>The <kbd>Shape</kbd> class extends the <kbd>FrameworkElement</kbd> class, so it can make use of the layout system, be styled, have access to a range of stroke and fill properties, and its properties can be data bound and animated. This makes it easy to use and, generally, the preferred method of drawing in WPF applications.</p>
<p>However, WPF also provides lower-level classes that can achieve the same end results, but more efficiently. The five classes that extend the abstract <kbd>Drawing</kbd> class have a much smaller inheritance hierarchy and, as such, have a much smaller memory footprint than their <kbd>Shape</kbd> object-based counterparts.</p>
<p>The two most commonly used classes include the <kbd>GeometryDrawing</kbd> class, which is used to draw geometrical shapes, and the <kbd>DrawingGroup</kbd> class, which is used to combine multiple drawing objects into a single composite drawing.</p>
<p>Additionally, the <kbd>Drawing</kbd> class is also extended by the <kbd>GlyphRunDrawing</kbd> class, which renders text; the <kbd>ImageDrawing</kbd> class, which displays images; and the <kbd>VideoDrawing</kbd> class, which enables us to play video files. As the <kbd>Drawing</kbd> class extends the <kbd>Freezable</kbd> class, further efficiency savings can be made by freezing its instances, that is, if they do not need to be modified afterward.</p>
<p>There is one other, and potentially even more efficient, method of drawing shapes in WPF. The <kbd>DrawingVisual</kbd> class does not provide event handling or layout functionality, so its performance is improved compared with other drawing methods. However, this is a code-only solution and there is no XAML-based <kbd>DrawingVisual</kbd> option.</p>
<p>Furthermore, its lack of layout abilities means that, in order to display it, we need to create a class that extends a class that provides layout support in the UI, such as the <kbd>FrameworkElement</kbd> class. To be even more efficient, though, we could extend the <kbd>Visual</kbd> class, as that is the lightest-weight class that can be rendered in the UI, with the fewest properties and no events to handle.</p>
<p>This class would be responsible for maintaining a collection of <kbd>Visual</kbd> elements to be rendered, creating one or more <kbd>DrawingVisual</kbd> objects to add to the collection, and overriding a property and a method, in order to participate in the rendering process. It could also, optionally, provide event handling and hit-testing capabilities if user interaction was required.</p>
<p>It really depends on what we want to draw. Typically, the more efficient the drawing, the less flexible it is. For example, if we were just drawing some static clipart, background image, or, perhaps, logo, we could take advantage of the more efficient drawing methods. However, if we need our drawing to grow and shrink as the application windows change size, then we'll need to use the less efficient methods that provide more flexibility, or use another class in addition that provides that functionality.</p>
<p> </p>
<p>Let's explore an example that creates the same graphical image using each of the three different drawing methods. We'll define some smiley face emoticons, starting with the <kbd>Shape</kbd>-based method on the left-hand side, the <kbd>Drawing</kbd> object-based method in the center, and the <kbd>DrawingVisual</kbd>-based method on the right. Let's first look at the visual output:</p>
<div><img src="img/e1216ee2-906c-4871-bdd2-139de05898bd.png"/></div>
<p>Now, let's inspect the XAML:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.DrawingView" 
   
   
  xmlns:Controls=
    "clr-namespace:CompanyName.ApplicationName.Views.Controls" 
  xmlns:PresentationOptions=
    "http://schemas.microsoft.com/winfx/2006/xaml/presentation/options" 
  Width="450" Height="150"&gt; 
  &lt;Grid&gt; 
    &lt;Grid.Resources&gt; 
      &lt;RadialGradientBrush x:Key="RadialBrush" RadiusX="0.8" RadiusY="0.8"
        PresentationOptions:Freeze="True"&gt; 
        &lt;GradientStop Color="Orange" Offset="1.0" /&gt; 
        &lt;GradientStop Color="Yellow" /&gt; 
      &lt;/RadialGradientBrush&gt; 
    &lt;/Grid.Resources&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
      &lt;ColumnDefinition /&gt; 
      &lt;ColumnDefinition /&gt; 
      &lt;ColumnDefinition /&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
    &lt;Grid&gt; 
      &lt;Grid.RowDefinitions&gt; 
        &lt;RowDefinition Height="3*" /&gt; 
        &lt;RowDefinition Height="2*" /&gt; 
        &lt;RowDefinition Height="2*" /&gt; 
        &lt;RowDefinition Height="2*" /&gt; 
        &lt;RowDefinition Height="3*" /&gt; 
      &lt;/Grid.RowDefinitions&gt; 
      &lt;Grid.ColumnDefinitions&gt; 
        &lt;ColumnDefinition /&gt; 
        &lt;ColumnDefinition /&gt; 
        &lt;ColumnDefinition /&gt; 
        &lt;ColumnDefinition /&gt; 
        &lt;ColumnDefinition /&gt; 
      &lt;/Grid.ColumnDefinitions&gt; 
      &lt;Ellipse Grid.RowSpan="5" Grid.ColumnSpan="5"  
        Fill="{StaticResource RadialBrush}" Stroke="Black"  
        StrokeThickness="5" /&gt; 
      &lt;Ellipse Grid.Row="1" Grid.Column="1" Fill="Black" Width="20"  
        HorizontalAlignment="Center" /&gt; 
      &lt;Ellipse Grid.Row="1" Grid.Column="3" Fill="Black" Width="20"  
        HorizontalAlignment="Center" /&gt; 
      &lt;Path Grid.Row="3" Grid.Column="1" Grid.ColumnSpan="3" Stroke="Black"
        StrokeThickness="10" StrokeStartLineCap="Round"
        StrokeEndLineCap="Round" Data="M0,10 A10,25 0 0 0 12.5,10" 
        Stretch="Fill" HorizontalAlignment="Stretch" /&gt; 
    &lt;/Grid&gt; 
    &lt;Canvas Grid.Column="1"&gt; 
      &lt;Canvas.Background&gt; 
        &lt;DrawingBrush PresentationOptions:Freeze="True"&gt; 
          &lt;DrawingBrush.Drawing&gt; 
            &lt;DrawingGroup&gt; 
              &lt;GeometryDrawing Brush="{StaticResource RadialBrush}"&gt; 
                &lt;GeometryDrawing.Geometry&gt; 
                  &lt;EllipseGeometry Center="50,50" RadiusX="50"  
                    RadiusY="50" /&gt; 
                &lt;/GeometryDrawing.Geometry&gt; 
                &lt;GeometryDrawing.Pen&gt; 
                  &lt;Pen Thickness="3.5" Brush="Black" /&gt; 
                &lt;/GeometryDrawing.Pen&gt; 
              &lt;/GeometryDrawing&gt; 
              &lt;GeometryDrawing Brush="Black"&gt; 
                &lt;GeometryDrawing.Geometry&gt; 
                  &lt;EllipseGeometry Center="29.5,33" RadiusX="6.75"  
                    RadiusY="8.5" /&gt; 
                &lt;/GeometryDrawing.Geometry&gt; 
              &lt;/GeometryDrawing&gt; 
              &lt;GeometryDrawing Brush="Black"&gt; 
                &lt;GeometryDrawing.Geometry&gt; 
                  &lt;EllipseGeometry Center="70.5,33" RadiusX="6.75"  
                    RadiusY="8.5" /&gt; 
                &lt;/GeometryDrawing.Geometry&gt; 
              &lt;/GeometryDrawing&gt; 
              &lt;GeometryDrawing&gt; 
                &lt;GeometryDrawing.Geometry&gt; 
                  &lt;PathGeometry&gt; 
                    &lt;PathGeometry.Figures&gt; 
                      &lt;PathFigure StartPoint="23,62.5"&gt; 
                        &lt;ArcSegment Point="77,62.5" Size="41 41" /&gt; 
                      &lt;/PathFigure&gt; 
                    &lt;/PathGeometry.Figures&gt; 
                  &lt;/PathGeometry&gt; 
                &lt;/GeometryDrawing.Geometry&gt; 
                &lt;GeometryDrawing.Pen&gt; 
                  &lt;Pen Thickness="7" Brush="Black" StartLineCap="Round"
                    EndLineCap="Round" /&gt; 
                &lt;/GeometryDrawing.Pen&gt; 
              &lt;/GeometryDrawing&gt; 
            &lt;/DrawingGroup&gt; 
          &lt;/DrawingBrush.Drawing&gt; 
        &lt;/DrawingBrush&gt; 
      &lt;/Canvas.Background&gt; 
    &lt;/Canvas&gt; 
    &lt;Canvas Grid.Column="2"&gt; 
      &lt;Canvas.Background&gt; 
        &lt;VisualBrush&gt; 
          &lt;VisualBrush.Visual&gt; 
            &lt;Controls:SmileyFace /&gt; 
          &lt;/VisualBrush.Visual&gt; 
        &lt;/VisualBrush&gt; 
      &lt;/Canvas.Background&gt; 
    &lt;/Canvas&gt; 
  &lt;/Grid&gt; 
&lt;/UserControl&gt; </pre>
<p>The first thing that we can see straight away from this example is that the <kbd>Shape</kbd> object-based method of drawing is far simpler, achieving the same output as the far more verbose <kbd>Drawing</kbd> object-based method in far fewer lines of XAML. Let's now investigate the code.</p>
<p>After defining the <kbd>PresentationOptions</kbd> XAML namespace, we declare a <kbd>RadialGradientBrush</kbd> resource and optimize its efficiency, by freezing it using the <kbd>Freeze</kbd> attribute that was discussed earlier in the chapter. Note that if we were planning on using this control multiple times simultaneously, then we could be even more efficient, by declaring all of our <kbd>Brush</kbd> and <kbd>Pen</kbd> objects in the application resources and referencing them with <kbd>StaticResource</kbd> references.</p>
<p>We then declare an outer <kbd>Grid</kbd> panel that has two columns. In the left column, we declare another <kbd>Grid</kbd> panel, with five rows and five columns. This inner panel is used to position the various <kbd>Shape</kbd> elements that make up the first smiley face. Note that we use star sizing on the row definitions of this panel in order to slightly increase the sizes of the top and bottom rows to better position the eyes and mouth of the face.</p>
<p>Inside the panel, we define an <kbd>Ellipse</kbd> object to create the overall shape of the face, fill it with our brush from the resources, and add an outline with a black brush. We then use two further <kbd>Ellipse</kbd> elements filled with the black brush to draw the eyes and a <kbd>Path</kbd> element to draw the smile. Note that we do not fill the <kbd>Path</kbd> element, as that would look more like an open mouth than a smile.</p>
<p>Two other important points to note are that we must set the <kbd>Stretch</kbd> property to <kbd>Fill</kbd> in order to get the <kbd>Path</kbd> element to fill the available space that we provide it with, and we must set the <kbd>StrokeStartLineCap</kbd> and <kbd>StrokeEndLineCap</kbd> properties to <kbd>Round</kbd> to produce the nice, rounded ends of the smile.</p>
<p>We specify the shape that the <kbd>Path</kbd> element should be using its <kbd>Data</kbd> property and the inline mini-language that we used previously. Let's now break this value down into the various mini-language commands:</p>
<pre>M0,10 A10,25 0 0 0 12.5,10 </pre>
<p>As with the previous example, we start with the Move command, specified by <kbd>M</kbd> and the following coordinate pair, which dictates the start point for the line. The remainder is taken up with the Elliptical Arc command, which is specified by <kbd>A</kbd> and the following five figures.</p>
<p>In order, the five figures of the Elliptical Arc command relate to the size of the arc, or its <em>x</em> and <em>y</em> radii, its rotation angle, a bit field to specify whether the angle of the arc should be greater than 180 degrees or not, another bit field to specify whether the arc should be drawn in a clockwise or an anti-clockwise direction, and, finally, the end point of the arc.</p>
<p>Full details of this path mini-language syntax can be found on the Microsoft website. Note that we could change the bit field of the drawing direction to a <kbd>1</kbd> in order to draw a frown instead:</p>
<pre>M0,10 A10,25 0 0 1 12.5,10 </pre>
<p>Now, let's move onto the second column of the outer <kbd>Grid</kbd> panel now. In this column, we recreate the same smiley face but using the more efficient <kbd>Drawing</kbd> object-based objects. As they cannot render themselves like the <kbd>Shape</kbd> classes and we need to utilize other elements to do that job for us, we define them inside a <kbd>DrawingBrush</kbd> element and use that to paint the background of a <kbd>Canvas</kbd> object.</p>
<p>There are two important things to note here. The first is that we could have used the <kbd>DrawingBrush</kbd> element to paint any class that extends the <kbd>FrameworkElement</kbd> class, such as a <kbd>Rectangle</kbd> element, or another type of panel.</p>
<p>The second is that as we have frozen the <kbd>DrawingBrush</kbd> element using the <kbd>Freeze</kbd> attribute, all of the inner elements that extend the <kbd>Freezable</kbd> type will also be frozen. In this case, that includes the <kbd>GeometryDrawing</kbd> objects, the <kbd>EllipseGeometry</kbd> and <kbd>PathGeometry</kbd> objects, and even the <kbd>Brush</kbd> and <kbd>Pen</kbd> elements that were used to paint them.</p>
<p>When using a <kbd>DrawingBrush</kbd> object to render our drawings, we must define them using the <kbd>Drawing</kbd> property. As we want to build up our image from multiple <kbd>Drawing</kbd>-based objects, we need to wrap them all in a <kbd>DrawingGroup</kbd> object.</p>
<p>In order to recreate the overall shape of the face, we start with a <kbd>GeometryDrawing</kbd> element and specify an <kbd>EllipseGeometry</kbd> object as its <kbd>Geometry</kbd> property value. With this <kbd>GeometryDrawing</kbd> element, we paint the background by setting a reference of our <kbd>RadialGradientBrush</kbd> resource to its <kbd>Brush</kbd> property, and define a new <kbd>Pen</kbd> instance in its <kbd>Pen</kbd> property to specify a stroke for it.</p>
<p>As with all <kbd>Geometry</kbd> objects, we specify its dimensions so that they are in scale with each other, rather than using exact pixel sizes. For example, our View is 150 pixels high; however, instead of setting the <kbd>Center</kbd> property of this <kbd>EllipseGeometry</kbd> object to 75, which is half of the height, we have set it to 50.</p>
<p>As the two radii properties are also set to 50, they remain in scale with the position of the center and the resulting image is scaled to fit the container that it is rendered in. The scale that we use is up to our preference. For example, we could divide or multiply all of the coordinates, radii, and brush and pen thicknesses in our drawing example by the same amount and we would end up with the same face visual.</p>
<p>Next, we add another <kbd>GeometryDrawing</kbd> element with an <kbd>EllipseGeometry</kbd> object specified in its <kbd>Drawing</kbd> property for each of the two eyes on the face. These have no stroke and so have nothing assigned to the <kbd>Pen</kbd> property and are colored only using a black <kbd>Brush</kbd> set to their <kbd>Brush</kbd> properties. The final <kbd>GeometryDrawing</kbd> element hosts a <kbd>PathGeometry</kbd> object that draws the smile on the face.</p>
<p>Note that defining a <kbd>PathGeometry</kbd> object in XAML is far more verbose than using the path mini-language syntax. In it, we need to specify each <kbd>PathFigure</kbd> element in the <kbd>PathFigures</kbd> collection property, although actually declaring the surrounding collection in XAML is optional. In the case of our smile, we just need to define a single <kbd>PathFigure</kbd> element containing an <kbd>ArcSegment</kbd> object.</p>
<p>The <kbd>StartPoint</kbd> property of the <kbd>PathFigure</kbd> element dictates where the arc should start, the <kbd>Size</kbd> property of the <kbd>ArcSegment</kbd> object relates to the size of the arc, or its <em>x</em> and <em>y</em> radii, while its <kbd>Point</kbd> property specifies the end point of the arc.</p>
<p>In order to define round ends for the smile, as we did with the previous smiley face, the <kbd>Pen</kbd> element that we specify for this <kbd>PathGeometry</kbd> object must have its <kbd>StartLineCap</kbd> and <kbd>EndLineCap</kbd> properties set to the <kbd>Round</kbd> member of the <kbd>PenLineCap</kbd> enumeration. This completes the second method of drawing a smiley face.</p>
<p>The third method uses <kbd>DrawingVisual</kbd> objects in code internally and results in a <kbd>Visual</kbd> object. As the items in the <kbd>Children</kbd> collection of the <kbd>Grid</kbd> panel are of the <kbd>UIElement</kbd> type, we cannot add our <kbd>Visual</kbd> control to it directly. Instead, we can set it to the <kbd>Visual</kbd> property of a <kbd>VisualBrush</kbd> element and paint the background of an efficient container, such as a <kbd>Canvas</kbd> control, with it.</p>
<p>Let's now take a look at the code in this <kbd>SmileyFace</kbd> class:</p>
<pre>using System; 
using System.Collections.Generic; 
using System.Windows; 
using System.Windows.Media; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public class SmileyFace : Visual 
  { 
    private VisualCollection visuals; 
 
    public SmileyFace() 
    { 
      visuals = new VisualCollection(this); 
      visuals.Add(GetFaceDrawingVisual()); 
    } 
 
    private DrawingVisual GetFaceDrawingVisual() 
    { 
      RadialGradientBrush radialGradientBrush =  
        new RadialGradientBrush(Colors.Yellow, Colors.Orange); 
      radialGradientBrush.RadiusX = 0.8; 
      radialGradientBrush.RadiusY = 0.8; 
      radialGradientBrush.Freeze(); 
      Pen outerPen = new Pen(Brushes.Black, 5.25); 
      outerPen.Freeze(); 
      DrawingVisual drawingVisual = new DrawingVisual(); 
      DrawingContext drawingContext = drawingVisual.RenderOpen(); 
      drawingContext.DrawEllipse(radialGradientBrush, outerPen,  
        new Point(75, 75), 72.375, 72.375);  
      drawingContext.DrawEllipse(Brushes.Black, null,  
        new Point(44.25, 49.5), 10.125, 12.75); 
      drawingContext.DrawEllipse(Brushes.Black, null,  
        new Point(105.75, 49.5), 10.125, 12.75); 
      ArcSegment arcSegment = 
        new ArcSegment(new Point(115.5, 93.75), new Size(61.5, 61.5), 0,
        false, SweepDirection.Counterclockwise, true); 
      PathFigure pathFigure = new PathFigure(new Point(34.5, 93.75),  
        new List&lt;PathSegment&gt;() { arcSegment }, false); 
      PathGeometry pathGeometry =  
        new PathGeometry(new List&lt;PathFigure&gt;() { pathFigure }); 
      pathGeometry.Freeze(); 
      Pen smilePen = new Pen(Brushes.Black, 10.5); 
      smilePen.StartLineCap = PenLineCap.Round; 
      smilePen.EndLineCap = PenLineCap.Round; 
      smilePen.Freeze(); 
      drawingContext.DrawGeometry(null, smilePen, pathGeometry); 
      drawingContext.Close(); 
      return drawingVisual; 
    } 
 
    protected override int VisualChildrenCount 
    { 
      get { return visuals.Count; } 
    } 
 
    protected override Visual GetVisualChild(int index) 
    { 
      if (index &lt; 0 || index &gt;= visuals.Count)  
        throw new ArgumentOutOfRangeException(); 
      return visuals[index]; 
    } 
  } 
} </pre>
<p>There are several classes that we could have extended our <kbd>SmileyFace</kbd> class from, in order to display it in the UI. As we saw in <a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, <em>Using the Right Controls for the Job,</em> most UI controls have a rich inheritance hierarchy, with each extended class offering some particular functionality.</p>
<p>In order to make the most efficient container for our <kbd>DrawingVisual</kbd>, we want to extend a class that enables it to take part in the layout process, but adds as little additional overhead via unused properties and unrequired event handling as possible. As such, we have chosen the <kbd>Visual</kbd> class, which cannot be used as a UI element directly in the XAML, but it can be displayed as the visual of a <kbd>VisualBrush</kbd> element and used to paint a surface with.</p>
<p>To generate one or more <kbd>DrawingVisual</kbd> elements in our <kbd>SmileyFace</kbd> class, we need to declare and maintain a <kbd>VisualCollection</kbd> instance that will hold the <kbd>Visual</kbd> elements that we want to display. In the constructor, we initialize this collection and add the single <kbd>DrawingVisual</kbd> element that we want to render to it in this example, via the <kbd>GetFaceDrawingVisual</kbd> method.</p>
<p>In the <kbd>GetFaceDrawingVisual</kbd> method, we first declare a new version of our <kbd>RadialBrush</kbd> resource using the <kbd>RadialGradientBrush</kbd> class and a <kbd>Pen</kbd> element and freeze them using their <kbd>Freeze</kbd> methods. Next, we initialize a single <kbd>DrawingVisual</kbd> element and access a <kbd>DrawingContext</kbd> object from its <kbd>RenderOpen</kbd> method, with which to draw our shape.</p>
<p>We use the <kbd>DrawingContext</kbd> object to draw the ellipse that serves as the background for the face first. It is colored using the frozen <kbd>Brush</kbd> and <kbd>pen</kbd> elements. Note that, as the <kbd>Visual</kbd> class has no <kbd>Stretch</kbd> property or concept of size, the dimensions that we use here are exact device-independent pixel dimensions, rather than relative values, as were used in the previous drawing methods.</p>
<p>In this example, our smiley faces are 150 pixels wide by 150 pixels tall, so the center position will be half of that. Therefore, these exact pixel values can be calculated by multiplying the relative values from the previous <kbd>Drawing</kbd>-based example by <kbd>1.5</kbd>.</p>
<p>However, we also need to consider the fact that the outline will be drawn half inside the drawing and half outside. As such, we need to adjust the two radii of this ellipse, reducing them by half of the outline size. As the pen used for this ellipse has a thickness of <kbd>5.25</kbd> device-independent pixels, we need to reduce each radius by <kbd>2.625</kbd>.</p>
<p>Next, we call the <kbd>DrawEllipse</kbd> method again to draw each of the eyes, passing in a black brush and no <kbd>Pen</kbd> element, along with their newly calculated positions and sizes. For the smile, we first need to create an <kbd>ArcSegment</kbd> element and add that to a collection of the <kbd>PathSegment</kbd> type, while initializing a <kbd>PathFigure</kbd> object.</p>
<p>We then add the <kbd>PathFigure</kbd> object to a collection and pass that to the constructor of the <kbd>PathGeometry</kbd> object to initialize it. Next, we define the <kbd>Pen</kbd> object that will be used to draw the smile, ensuring that we set its <kbd>StartLineCap</kbd> and <kbd>EndLineCap</kbd> properties to the <kbd>Round</kbd> member of the <kbd>PenLineCap</kbd> enumeration, as in the previous examples.</p>
<p>We then freeze this <kbd>Pen</kbd> object and pass it, along with the <kbd>PathGeometry</kbd> object, to the <kbd>DrawGeometry</kbd> method of the <kbd>DrawingContext</kbd> object to draw it. Finally, we close the drawing context using its <kbd>Close</kbd> method and return the single <kbd>DrawingVisual</kbd> element that we just created.</p>
<p>While we have now taken care of the code that draws our smiley face, we will not be able to see anything in the UI yet. In order to participate in the rendering process, we need to override a couple of members from the <kbd>Visual</kbd> class, the <kbd>VisualChildrenCount</kbd> property, and the <kbd>GetVisualChild</kbd> method.</p>
<p>When overriding these members, we need to inform the <kbd>Visual</kbd> class of the visuals that we want it to render for us. As such, we simply return the number of items in our internal <kbd>VisualCollection</kbd> object from the <kbd>VisualChildrenCount</kbd> property and return the item in the collection that relates to the specified <kbd>index</kbd> input parameter from the <kbd>GetVisualChild</kbd> method.</p>
<p>In this example, we have added a check for invalid values from the <kbd>index</kbd> input parameter, although this shouldn't ever occur if we output the correct number of items from the <kbd>VisualChildrenCount</kbd> property in the first place.</p>
<p>So, now we have seen three different drawing methods for creating the same visual output, with each being more efficient than the previous one. However, apart from the efficiency differences, we should also be aware of the differences in these drawing methods when it comes to the manipulation and versatility of the elements.</p>
<p>As an example, let's adjust the <kbd>Width</kbd> of our <kbd>DrawingView</kbd> class, set its <kbd>ClipToBounds</kbd> property to <kbd>true</kbd>, and view its new output:</p>
<pre>  Width="225" Height="150" ClipToBounds="True"&gt; </pre>
<p>Let's now run the application again and see the output:</p>
<div><img class="alignnone size-full wp-image-2082 image-border" src="img/a6b6efa1-8049-48ae-b74c-1e4153a7481c.png" style="width:18.25em;height:14.83em;"/></div>
<p>As you can see from the preceding screenshot, these drawing methods behave differently when resized. The first method is redrawn at the current size and the thickness of each drawn line remains the same, even though the width of this face has been narrowed by the space provided to it from the parent <kbd>Grid</kbd> panel.</p>
<p>However, the second and third smiley faces actually look like squashed images, where the thickness of each line is no longer static; the more vertical the line is, the thinner it now becomes. The overall widths of these faces have also been adjusted by the parent <kbd>Grid</kbd> panel.</p>
<p>The third face, however, has only been scaled by the <kbd>VisualBrush</kbd> object that is used to display it. If instead of extending the <kbd>Visual</kbd> class, we had wanted to derive from the <kbd>UIElement</kbd> class to utilize some of its functionality, or perhaps to enable us to display our <kbd>SmileyFace</kbd> control directly in the XAML, then we would see a different output. Let's make a slight adjustment to our class declaration:</p>
<pre>public class SmileyFace : UIElement </pre>
<p>Let's also display it directly in the XAML now, replacing the <kbd>Canvas</kbd> and <kbd>VisualBrush</kbd> objects that previously displayed it:</p>
<pre>&lt;Controls:SmileyFace Grid.Column="2" /&gt; </pre>
<p>Now, if we run the application again and see the output, it will look very different:</p>
<div><img src="img/3e591496-9319-4a2e-9272-1e5730e7942c.png"/></div>
<p>Because we specified exact values for our drawing, our <kbd>SmileyFace</kbd> control does not extend any class that would enable resizing or scaling, and we no longer have the <kbd>VisualBrush</kbd> object to resize it. That is, the drawing remains exactly as it would be at full size, except that it now no longer fits into the space provided to it from the parent <kbd>Grid</kbd> panel.</p>
<p>In order to build the ability to draw the shape at different sizes into our class, we'll need to derive it from a class that provides us with additional properties and functionality. The <kbd>FrameworkElement</kbd> class supplies us with both dimension properties that we can use to draw our shape at the required size and a <kbd>Loaded</kbd> event that we can use to delay the construction of our shape until the relevant size has been calculated by the layout system.</p>
<p>Let's examine the changes that we'd need to make to achieve this:</p>
<pre>public class SmileyFace : FrameworkElement 
{ 
  ...
 
  public SmileyFace() 
  { 
    visuals = new VisualCollection(this); 
    Loaded += SmileyFace_Loaded; 
  } 
 
  private void SmileyFace_Loaded(object sender, RoutedEventArgs e) 
  { 
    visuals.Add(GetFaceDrawingVisual()); 
  } 
 
  private DrawingVisual GetFaceDrawingVisual() 
  { 
    ... 
    DrawingVisual drawingVisual = new DrawingVisual(); 
    DrawingContext drawingContext = drawingVisual.RenderOpen(); 
    drawingContext.DrawEllipse(radialGradientBrush, outerPen,  
      new Point(ActualWidth / 2, ActualHeight / 2), (ActualWidth -  
      outerPen.Thickness) / 2, (ActualHeight - outerPen.Thickness) / 2); 
    drawingContext.DrawEllipse(Brushes.Black, null, new Point(
      ActualWidth / 3.3898305084745761, ActualHeight / 3.0303030303030303),
      ActualWidth / 14.814814814814815, ActualHeight / 11.764705882352942); 
    drawingContext.DrawEllipse(Brushes.Black, null, new Point(
      ActualWidth / 1.4184397163120568, ActualHeight / 3.0303030303030303),
      ActualWidth / 14.814814814814815, ActualHeight / 11.764705882352942); 
    ArcSegment arcSegment = new ArcSegment(new Point(ActualWidth /  
      1.2987012987012987, ActualHeight / 1.6), new Size(ActualWidth /
      2.4390243902439024, ActualHeight /  2.4390243902439024), 0, false,
      SweepDirection.Counterclockwise, true); 
    PathFigure pathFigure = new PathFigure(new Point(ActualWidth /  
      4.3478260869565215, ActualHeight / 1.6), new List&lt;PathSegment&gt;() {
      arcSegment }, false); 
    PathGeometry pathGeometry =
      new PathGeometry(new List&lt;PathFigure&gt;() { pathFigure }); 
    ... 
    return drawingVisual; 
  } 
 
  ...
} </pre>
<p>The first change is that we need to move the call to generate the shape from the constructor to the <kbd>SmileyFace_Loaded</kbd> handling method. If we had not moved this, our shape would have no size, because the <kbd>ActualWidth</kbd> and <kbd>ActualHeight</kbd> properties that are used to define its size would not have been set by the layout system at that time.</p>
<p>Next, in the <kbd>GetFaceDrawingVisual</kbd> method, we need to replace the hardcoded values with divisions of the control's dimensions. The ellipse that draws the whole face is simple to calculate, with a position of half the width and height of the control and radii of half of the width and height of the control minus half of the thickness of the <kbd>Pen</kbd> element that draws its outline.</p>
<p>However, if you were wondering where all of the remaining long decimal divisor values came from, the answer is basic mathematics. The original drawing was 150 pixels wide by 150 pixels tall, so we can divide this by the various positions and sizes of the drawn lines from the previous example.</p>
<p>For example, the ellipse that draws the first eye was previously centered with an <kbd>X</kbd> position of <kbd>44.25</kbd>. So, to calculate our required width divisor, we simply divide <kbd>150</kbd> by <kbd>44.25</kbd>, which equals <kbd>3.3898305084745761</kbd>. Therefore, when the control is provided with <kbd>150</kbd> pixels of space, it will draw the left eye at an <kbd>X</kbd> position of <kbd>44.25</kbd> and it will now scale correctly at all of the other sizes.</p>
<p>The divisors for each position and size of the drawn shapes were all calculated using this method, to ensure that they would be sized appropriately for the space provided to our control. Note that we could have altered the brush and pen thicknesses likewise, but we have opted not to do so in this example for brevity.</p>
<p>When running this example now, we again have a slightly different output:</p>
<div><img src="img/af68f172-08f9-49df-ad19-75ac2b3c2036.png"/></div>
<p>Now, the first and third faces look more similar, with the thicknesses of their drawn lines being static and unchanging along their length, unlike the second face. So, we can see that we have many options when it comes to creating custom drawings, and we need to balance the need for efficiency with the ease of use of the drawing method and also take the use of the resulting image into consideration.</p>
<p>Before moving onto the next topic in this chapter, there are a few further efficiency savings that we can make when drawing complex shapes. If our code uses a large number of <kbd>PathGeometry</kbd> objects, then we can replace them by using a <kbd>StreamGeometry</kbd> object instead.</p>
<p>The <kbd>StreamGeometry</kbd> class is specifically optimized to handle multiple path geometries and shows better performance than can be attained from using multiple <kbd>PathGeometry</kbd> instances. In fact, we have already been using the <kbd>StreamGeometry</kbd> class inadvertently, as that is what is used internally when the binding path mini-language syntax is parsed by the XAML reader.</p>
<p>It can be thought of in a similar way to the <kbd>StringBuilder</kbd> class, in that it is more efficient at drawing complex shapes than using multiple instances of the <kbd>PathGeometry</kbd> class, but it also has some overhead and so only benefits us when replacing a fair number of them.</p>
<p>Finally, rather than display our <kbd>DrawingVisual</kbd> using a <kbd>VisualBrush</kbd>, which is refreshed during each layout pass, if our drawings are never to be manipulated in the UI, it is even more efficient to create actual images from them and display those instead.</p>
<p>The <kbd>RenderTargetBitmap</kbd> class provides a simple way for us to create images from <kbd>Visual</kbd> instances, using its <kbd>Render</kbd> method. Let's explore an example of this:</p>
<pre>using System.IO; 
using System.Windows.Media; 
using System.Windows.Media.Imaging;

...

RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap( 
  (int)ActualWidth, (int)ActualHeight, 96, 96, PixelFormats.Pbgra32); 
renderTargetBitmap.Render(drawingVisual); 
renderTargetBitmap.Freeze();  
PngBitmapEncoder image = new PngBitmapEncoder(); 
image.Frames.Add(BitmapFrame.Create(renderTargetBitmap)); 
using (Stream stream = File.Create(filePath)) 
{ 
  image.Save(stream); 
} </pre>
<p>We start by initializing a <kbd>RenderTargetBitmap</kbd> object with the required dimensions, resolution, and pixel format of the image to create. Note that the <kbd>Pbgra32</kbd> member of the static <kbd>PixelFormats</kbd> class specifies a pixel format that follows the sRGB format, using 32 bits per pixel, with each of the four alpha, red, green, and blue channels receiving 8 bits each per pixel.</p>
<p>Next, we pass our <kbd>DrawingVisual</kbd> element, or any other element that extends the <kbd>Visual</kbd> class, to the <kbd>Render</kbd> method of the <kbd>RenderTargetBitmap</kbd> class to render it. To make the operation more efficient still, we then call its <kbd>Freeze</kbd> method to freeze the object.</p>
<p>In order to save a PNG image file, we first initialize a <kbd>PngBitmapEncoder</kbd> object and add the <kbd>renderTargetBitmap</kbd> variable to its <kbd>Frames</kbd> collection via the <kbd>Create</kbd> method of the <kbd>BitmapFrame</kbd> class. Finally, we initialize a <kbd>Stream</kbd> object using the <kbd>File.Create</kbd> method, passing in the desired file name and path, and call its <kbd>Save</kbd> method to save the file to the computer's hard drive. Alternatively, the <kbd>JpegBitmapEncoder</kbd> class can be used to create a JPG image file.</p>
<p>Let's now move on to find ways of using images more efficiently.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Imaging more efficiently</h1>
                
            
            
                
<p>When an image is displayed in a WPF application, it is loaded and decoded in its full size by default. If your application displays a number of thumbnails from the original images, then you can gain enhanced performance by copying your full-size images and then resizing them to the correct size for the thumbnails, rather than letting WPF do it for you.</p>
<p>Alternatively, you can request that WPF decodes your images to the size required by the thumbnails, although, if you want to display the full-size images, you would really need to decode each full-size image separately. Let's take a look at how we can achieve this by using a <kbd>BitmapImage</kbd> object as the source for an <kbd>Image</kbd> control:</p>
<pre>&lt;Image Width="64"&gt; 
  &lt;Image.Source&gt; 
    &lt;BitmapImage DecodePixelWidth="64" UriSource="pack://application:,,,/
      CompanyName.ApplicationName;component/Images/Image1.png" /&gt; 
  &lt;/Image.Source&gt; 
&lt;/Image&gt; </pre>
<p>The important part of this example is the <kbd>DecodePixelWidth</kbd> property of the <kbd>BitmapImage</kbd> class, which specifies the actual size of the image to decode to. In this example, this would result in a smaller memory footprint as well as faster rendering.</p>
<p>Note that if the <kbd>DecodePixelHeight</kbd> and <kbd>DecodePixelWidth</kbd> properties of the <kbd>BitmapImage</kbd> class are both set, a new aspect ratio will be calculated from their values. However, if only one of these properties is set, then the image's original aspect ratio will be used. It is, therefore, customary to only set one of these properties in order to decode to a different size from the original, while maintaining its aspect ratio.</p>
<p>Normally, when images are used in a WPF application, they are all cached into memory at load time. Another benefit that can be gained if using code in the aforementioned scenario is to set the <kbd>CacheOption</kbd> property of the <kbd>BitmapImage</kbd> class to the <kbd>OnDemand</kbd> enumeration member, which postpones the caching of the relevant image until the image is actually requested to be displayed.</p>
<p>This can save a significant amount of resources at load time, although each image will take a tiny bit longer to display the first time they are displayed. Once the image is cached, however, it will work in exactly the same way as the images created in the default way.</p>
<p>There is one additional property in the <kbd>BitmapImage</kbd> class that can be used to improve the performance when loading multiple image files. The <kbd>CreateOptions</kbd> property is of the <kbd>BitmapCreateOptions</kbd> enumeration type and enables us to specify initialization options that relate to the loading of images. This enumeration can be set using bitwise combinations as it specifies the <kbd>FlagsAttribute</kbd> attribute in its declaration.</p>
<p>The <kbd>DelayCreation</kbd> member can be used to delay the initialization of each image until it is actually required, thereby speeding up the process of loading the relevant View, while adding a tiny cost to the process of requesting each image when it is actually required.</p>
<p>This would benefit a photo gallery type of application, for example, where the initialization of each full-size image could be delayed until the user clicks on the appropriate thumbnail. It is only at that point that the image would be created, but as there would only be a single image to create at that point, the initialization time would be negligible.</p>
<p>While it is possible to set more than one of these members to the <kbd>CreateOptions</kbd> property using the bitwise OR operator (<kbd>|</kbd>), care should be taken to not also set the <kbd>PreservePixelFormat</kbd> member, unless specifically required, as that can result in lower performance. When it is not set, the system will choose the pixel format with the best performance by default. Let's look at a short example:</p>
<pre>private Image CreateImageEfficiently(string filePath) 
{ 
  Image image = new Image(); 
  BitmapImage bitmapImage = new BitmapImage(); 
  bitmapImage.BeginInit(); 
  bitmapImage.CacheOption = BitmapCacheOption.OnDemand; 
  bitmapImage.CreateOptions = BitmapCreateOptions.DelayCreation; 
  bitmapImage.UriSource = new Uri(filePath, UriKind.Absolute);<br/>  bitmapImage.Freeze();<br/>  bitmapImage.EndInit();<br/>  image.Source = bitmapImage; <br/>  return image; <br/>}</pre>
<p>When creating images in code, we need to initialize an instance of the <kbd>BitmapImage</kbd> class to use as the source for the actual <kbd>Image</kbd> object that will be displayed in the UI. When doing so, we need to call its <kbd>BeginInit</kbd> method before making changes to it and then call its <kbd>EndInit</kbd> method afterward. Note that all changes made after initialization will be ignored.</p>
<p>During initialization, we set the <kbd>CacheOption</kbd> property to the <kbd>OnDemand</kbd> member and the <kbd>CreateOptions</kbd> property to the <kbd>DelayCreation</kbd> member. Note that we do not set the <kbd>DecodePixelWidth</kbd> or <kbd>DecodePixelHeight</kbd> properties here, because this code example is setup for initializing the full-size images in our gallery example.</p>
<p>Additionally, note that, in this particular example, we initialize the <kbd>Uri</kbd> object using an absolute file path, by passing the <kbd>Absolute</kbd> member of the <kbd>UriKind</kbd> enumeration into the constructor. If you prefer to work with relative file paths, you can change this line to specify a relative file path by passing the <kbd>Relative</kbd> member to the constructor instead:</p>
<pre>bitmapImage.UriSource = new Uri(filePath, UriKind.Relative); </pre>
<p>Returning to the end of the example now, we can see the call to the <kbd>Freeze</kbd> method, which ensures that the <kbd>BitmapImage</kbd> object will be unmodifiable and in its most efficient state. This line can be omitted if the images need to be modified later.</p>
<p>Finally, we call the <kbd>EndInit</kbd> method to signal the end of the <kbd>BitmapImage</kbd> object initialization, set the <kbd>BitmapImage</kbd> object as the <kbd>Source</kbd> property value of the <kbd>Image</kbd> object to return, and then return the <kbd>Image</kbd> object to the method caller.</p>
<p>Now that we've seen some tips on how to display our images more efficiently, let's investigate how we might do the same for our application's textual output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enhancing the performance of textual output</h1>
                
            
            
                
<p>WPF provides similar options for creating text as it does for drawing shapes; the more versatile the output method, the easier it is to use, but the less efficient it is and vice versa. The vast majority of us opt for the simplest, but least efficient, method of using the high-level <kbd>TextBlock</kbd> or <kbd>Label</kbd> elements.</p>
<p>While this doesn't typically cause us any problems when used in typical forms, there is definitely room for improvement when displaying thousands of text blocks in a data grid, or other collection control. If we require formatted text, we can utilize the more efficient <kbd>FormattedText</kbd> object; otherwise, we can use the lowest-level method and the most efficient <kbd>Glyphs</kbd> elements.</p>
<p>Let's look at an example:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.TextView" 
   
   
  xmlns:Controls=
    "clr-namespace:CompanyName.ApplicationName.Views.Controls" 
  Height="250" Width="325"&gt; 
  &lt;Grid ShowGridLines="True"&gt; 
    &lt;Grid.RowDefinitions&gt; 
      &lt;RowDefinition /&gt; 
      &lt;RowDefinition /&gt; 
      &lt;RowDefinition /&gt; 
      &lt;RowDefinition /&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;Label Content="Quite Efficient" FontFamily="Times New Roman"  
      FontSize="50" FontWeight="Bold" FontStyle="Italic"  
      Foreground="Red" Margin="10,0,0,0" Padding="0" /&gt; 
    &lt;TextBlock Grid.Row="1" Text="More Efficient" 
      FontFamily="Times New Roman" FontSize="50" FontWeight="Bold"
      FontStyle="Italic" Foreground="Black" Margin="10,0,0,0" /&gt; 
    &lt;Controls:FormattedTextOutput Grid.Row="2" Text="More Efficient" /&gt; 
    &lt;Glyphs Grid.Row="3" UnicodeString="Most Efficient"  
      FontUri="C:\WINDOWS\Fonts\timesbi.TTF" FontRenderingEmSize="50"  
      Fill="Black" OriginX="10" OriginY="45" /&gt; 
  &lt;/Grid&gt; 
&lt;/UserControl&gt; </pre>
<p>Here, we have a View that has a <kbd>Grid</kbd> panel with four rows. The first row holds a <kbd>Label</kbd> control, which although fairly efficient, is the least efficient of the textual output methods shown here and, as we'll see soon, should only be used in very specific circumstances. On it, we specify the <kbd>FontFamily</kbd>, <kbd>FontSize</kbd>, <kbd>FontWeight</kbd>, <kbd>FontStyle</kbd>, and <kbd>Foreground</kbd> properties to define how its text should look.</p>
<p>The second row contains a <kbd>TextBlock</kbd> element, which is slightly more efficient, and, like the <kbd>Label</kbd> element, we specify the <kbd>FontFamily</kbd>, <kbd>FontSize</kbd>, <kbd>FontWeight</kbd>, <kbd>FontStyle</kbd>, and <kbd>Foreground</kbd> properties on it directly. It's worth noting that to result in the same visual output, we don't need to set its <kbd>Padding</kbd> property to <kbd>0</kbd>, which was required with the <kbd>Label</kbd> control.</p>
<p>In the third row, we have a custom <kbd>FormattedTextOutput</kbd> control that uses a <kbd>FormattedText</kbd> object internally and is slightly more efficient still. As we'll see shortly, we need to specify the relevant properties of this text object in code.</p>
<p>Finally, we see a <kbd>Glyphs</kbd> element in the fourth row and this represents the most efficient method of outputting text in a WPF application. Note that when using this method of textual output, we don't specify a font family by name, but instead set an exact font file path to its <kbd>FontUri</kbd> property.</p>
<p>As we want to match the bold italic version of the Times New Roman font, we specifically need to set the file path to that exact file. Therefore, we need to specify the <kbd>timesbi.ttf</kbd> file, rather than the normal <kbd>times.ttf</kbd> version. Other than setting the font size to the <kbd>FontRenderingEmSize</kbd> property and the margin to the <kbd>OriginX</kbd> and <kbd>OriginY</kbd> properties, this class is fairly self-explanatory.</p>
<p>Before continuing, let's first take a look at the visual output of this View:</p>
<div><img class="alignnone size-full wp-image-2085 image-border" src="img/b839587f-85d3-46dd-b448-f25cd86a7f9c.png" style="width:32.17em;height:24.42em;"/></div>
<p>Let's now take a look at the code inside the <kbd>FormattedTextOutput</kbd> class:</p>
<pre>using System.Globalization; 
using System.Windows; 
using System.Windows.Media; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public class FormattedTextOutput : FrameworkElement 
  { 
    public static readonly DependencyProperty TextProperty =  
      DependencyProperty.Register(nameof(Text), typeof(string),
      typeof(FormattedTextOutput), new FrameworkPropertyMetadata( 
      string.Empty, FrameworkPropertyMetadataOptions.AffectsRender)); 
 
    public string Text 
    { 
      get { return (string)GetValue(TextProperty); } 
      set { SetValue(TextProperty, value); } 
    } 
 
    protected override void OnRender(DrawingContext drawingContext) 
    { 
      DpiScale dpiScale = VisualTreeHelper.GetDpi(this); <br/>      FormattedText formattedText = new FormattedText(Text, <br/>        CultureInfo.GetCultureInfo("en-us"), FlowDirection.LeftToRight, <br/>        new Typeface("Times New Roman"), 50, Brushes.Red, <br/>        dpiScale.PixelsPerDip);<br/>      formattedText.SetFontStyle(FontStyles.Italic); 
      formattedText.SetFontWeight(FontWeights.Bold); 
      drawingContext.DrawText(formattedText, new Point(10, 0)); 
    } 
  } 
} </pre>
<p>The <kbd>FormattedTextOutput</kbd> class is a fairly simple affair, with a single Dependency Property and its associated CLR wrapper and a single overridden base class method. One very important point to note is our use of the <kbd>AffectsRender</kbd> member of the <kbd>FrameworkPropertyMetadataOptions</kbd> enumeration to specify that changes to this property need to cause a new rendering pass.</p>
<p>Typically, the <kbd>Text</kbd> property will be updated from any data binding after the <kbd>OnRender</kbd> method is called by the <kbd>UIElement</kbd> base class. Without specifying this option, our class will never output any data bound values. By specifying this option, we are, in fact, telling the Framework to call the <kbd>OnRender</kbd> method again each time this property value changes.</p>
<p>In the overridden <kbd>OnRender</kbd> method, we first initialize a <kbd>FormattedText</kbd> object with basic properties, such as the text to render, the current culture, and the color, size, and type of the font to use. Additional style properties can be set using the various set methods that the class exposes. Finally, we call the <kbd>DrawText</kbd> method of the <kbd>DrawingContext</kbd> object specified by the <kbd>drawingContext</kbd> input parameter, passing in the <kbd>FormattedText</kbd> object and the position to render it.</p>
<p>Note that we can use data binding with all of these text rendering methods, so let's now update our previous example to demonstrate this:</p>
<pre>...
&lt;Label Content="{Binding Text}" FontFamily="Times New Roman"  
  FontSize="50" FontWeight="Bold" FontStyle="Italic" Foreground="Red"
  Margin="10,0,0,0" Padding="0" /&gt; 
&lt;TextBlock Grid.Row="1" Text="{Binding Text}" 
  FontFamily="Times New Roman" FontSize="50" FontWeight="Bold"
  FontStyle="Italic" Foreground="Red" Margin="10,0,0,0" /&gt; 
&lt;Controls:FormattedTextOutput Grid.Row="2" Text="{Binding Text}" /&gt; 
&lt;Glyphs Grid.Row="3" UnicodeString="{Binding Text}" FontUri=
  "C:\WINDOWS\Fonts\timesbi.TTF" FontRenderingEmSize="50"  
  Fill="Black" OriginX="10" OriginY="45" /&gt; 
...</pre>
<p>For this example, we can simply hardcode a value in our View Model:</p>
<pre>namespace CompanyName.ApplicationName.ViewModels 
{ 
  public class TextViewModel : BaseViewModel 
  { 
    public string Text { get; set; } = "Efficient"; 
  } 
} </pre>
<p>Although we can data bind when using all of these textual output methods, there are some caveats to be aware of. We've just learned of one relating to the required metadata of the <kbd>Text</kbd> property in our custom <kbd>FormattedTextOutput</kbd> class and there is another relating to the <kbd>Glyphs</kbd> class.</p>
<p>It has a requirement that the <kbd>UnicodeString</kbd> property cannot be empty if the <kbd>Indicies</kbd> property, which represents an alternative method of providing the text to render, is also empty. Unfortunately, because of this requirement, attempting to data bind to the <kbd>UnicodeString</kbd> property, as we did in our extended example, will result in a compilation error:</p>
<pre><strong>Glyphs Indices and UnicodeString properties cannot both be empty.</strong></pre>
<p>To address this issue, we can simply provide a value for the <kbd>FallbackValue</kbd> property of the <kbd>Binding</kbd> class, so that the <kbd>Glyphs</kbd> class can be rest assured that even if there is no data bound value, its <kbd>UnicodeString</kbd> property will have a non-empty value.</p>
<p>Note that setting the <kbd>FallbackValue</kbd> property to an empty string will result in the same error being raised:</p>
<pre>&lt;Glyphs Grid.Row="3" UnicodeString="{Binding Text, FallbackValue='Data
  Binding Not Working'}" FontUri="C:\WINDOWS\Fonts\timesbi.TTF"
  FontRenderingEmSize="50" Fill="Black" OriginX="10" OriginY="45" /&gt; </pre>
<p>There is one further issue regarding data binding; however, this time, it involves the <kbd>Content</kbd> property of the <kbd>Label</kbd> class. Because the <kbd>string</kbd> type is immutable, each time a data bound value updates the <kbd>Content</kbd> property, the previous <kbd>string</kbd> type will be discarded and replaced with the new one.</p>
<p>Furthermore, if the default <kbd>ContentTemplate</kbd> element is used, it will generate a new <kbd>TextBlock</kbd> element and discard the previous element each time the property string is replaced. As a result, updating a data bound <kbd>TextBlock</kbd> is approximately four times quicker than updating a <kbd>Label</kbd> control. Therefore, if we need to update our data bound text values, we should not use a <kbd>Label</kbd> control.</p>
<p>In fact, each method of rendering text has its own purpose. The <kbd>Label</kbd> control should specifically be used to label text fields in a form, and, in doing so, we can take advantage of its access key functionality and its ability to reference a target control. The <kbd>TextBlock</kbd> element is a general-purpose text output method that should be used the majority of the time.</p>
<p>The <kbd>FormattedText</kbd> object should really only be used when we specifically want to format some text in a particular way. It provides the ability to output text with a wide range of effects, such as being able to paint the stroke and fill of the text independently and to format particular ranges of characters within the rendered text string.</p>
<p>The <kbd>Glyphs</kbd> class extends the <kbd>FrameworkElement</kbd> class directly and is, therefore, extremely light-weight and should be utilized when we need to recreate our text output more efficiently than we can by using the alternative methods. Although the <kbd>FormattedText</kbd> class can make use of lower, core level classes to render its output, the most efficient way to render text is to use <kbd>Glyphs</kbd> objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Liking the linking</h1>
                
            
            
                
<p>As you have already seen, each UI element that we use in our Views takes time to render. Simply put, the fewer elements that we use, the quicker the View will be displayed. Those of us that have used <kbd>Hyperlink</kbd> elements in our Views will already be aware that we cannot display them on their own but, instead, have to wrap them inside a <kbd>TextBlock</kbd> element.</p>
<p>However, as each <kbd>Hyperlink</kbd> element is self-contained, with its own navigation URI, content, and property options, we can actually display more than one of them in a single <kbd>TextBlock</kbd> element. This will reduce the render time; therefore, the more <kbd>TextBlock</kbd> elements that we can remove, the quicker it will become. Let's look at an example:</p>
<pre>&lt;ListBox ItemsSource="{Binding Products}" FontSize="14"  
  HorizontalContentAlignment="Stretch"&gt; 
  &lt;ListBox.ItemTemplate&gt; 
    &lt;DataTemplate DataType="{x:Type DataModels:Product}"&gt; 
      &lt;Grid&gt; 
        &lt;Grid.ColumnDefinitions&gt; 
          &lt;ColumnDefinition /&gt; 
          &lt;ColumnDefinition Width="Auto" /&gt; 
          &lt;ColumnDefinition Width="Auto" /&gt; 
        &lt;/Grid.ColumnDefinitions&gt; 
        &lt;TextBlock Text="{Binding Name}" /&gt; 
        &lt;TextBlock Grid.Column="1" 
          Text="{Binding Price, StringFormat=C}" Margin="10,0" /&gt; 
        &lt;StackPanel Grid.Column="2" TextElement.FontSize="14"  
          Orientation="Horizontal"&gt; 
          &lt;TextBlock&gt; 
            &lt;Hyperlink Command="{Binding ViewCommand,  
              RelativeSource={RelativeSource  
              AncestorType={x:Type Views:TextView}}}"  
              CommandParameter="{Binding}"&gt;View&lt;/Hyperlink&gt; 
          &lt;/TextBlock&gt; 
          &lt;TextBlock Text=" | " /&gt; 
          &lt;TextBlock&gt; 
            &lt;Hyperlink Command="{Binding EditCommand,  
              RelativeSource={RelativeSource  
              AncestorType={x:Type Views:TextView}}}"  
              CommandParameter="{Binding}"&gt;Edit&lt;/Hyperlink&gt; 
          &lt;/TextBlock&gt; 
          &lt;TextBlock Text=" | " /&gt; 
          &lt;TextBlock&gt; 
            &lt;Hyperlink Command="{Binding DeleteCommand,  
              RelativeSource={RelativeSource  
              AncestorType={x:Type Views:TextView}}}"  
              CommandParameter="{Binding}"&gt;Delete&lt;/Hyperlink&gt; 
          &lt;/TextBlock&gt; 
        &lt;/StackPanel&gt; 
      &lt;/Grid&gt; 
    &lt;/DataTemplate&gt; 
  &lt;/ListBox.ItemTemplate&gt; 
&lt;/ListBox&gt; </pre>
<p>Here, we have a collection of <kbd>Product</kbd> objects that are data bound to a <kbd>ListBox</kbd>, with each item displaying its name, price, and three commands in the form of <kbd>Hyperlink</kbd> objects. Let's see what this looks like before continuing:</p>
<div><img class="alignnone size-full wp-image-2086 image-border" src="img/71baf69c-b6bc-4216-a5af-32069a49df30.png" style="width:37.50em;height:8.08em;"/></div>
<p>Focusing on the links now, our example uses nine UI elements per item to render these three links. The <kbd>StackPanel</kbd> element keeps them altogether, with each <kbd>Hyperlink</kbd> object having its own <kbd>TextBlock</kbd> element and a further two <kbd>TextBlock</kbd> elements to display the pipe separator characters.</p>
<p>The <kbd>Hyperlink</kbd> objects are data bound to commands in the View Model and the <kbd>CommandParameter</kbd> property is data bound to the whole <kbd>Product</kbd> object that is set as the data source for each item. In this way, we will have access to the relevant <kbd>Product</kbd> instance in the View Model when a link is clicked on.</p>
<p>While there is nothing wrong with this XAML, if we need to be more efficient, then we can replace everything inside the <kbd>StackPanel</kbd> and the panel itself with the following <kbd>TextBlock</kbd> element:</p>
<pre>&lt;TextBlock Grid.Column="2" TextElement.FontSize="14" Foreground="White"&gt; 
  &lt;Hyperlink Command="{Binding ViewCommand, RelativeSource={ 
    RelativeSource AncestorType={x:Type Views:TextView}}}"  
    CommandParameter="{Binding}"&gt;View&lt;/Hyperlink&gt; 
  &lt;Run Text=" | " /&gt; 
  &lt;Hyperlink Command="{Binding EditCommand, RelativeSource={ 
    RelativeSource AncestorType={x:Type Views:TextView}}}"  
    CommandParameter="{Binding}"&gt;Edit&lt;/Hyperlink&gt; 
  &lt;Run Text=" | " /&gt; 
  &lt;Hyperlink Command="{Binding DeleteCommand, RelativeSource={ 
    RelativeSource AncestorType={x:Type Views:TextView}}}"  
    CommandParameter="{Binding}"&gt;Delete&lt;/Hyperlink&gt; 
&lt;/TextBlock&gt; </pre>
<p>As you can see, we now host all three <kbd>Hyperlink</kbd> objects inside a single <kbd>TextBlock</kbd> element and have replaced the two <kbd>TextBlock</kbd> elements that displayed the pipe characters with <kbd>Run</kbd> objects. Using the <kbd>Run</kbd> class is moderately more efficient than using one <kbd>TextBlock</kbd> element inside another.</p>
<p>Now, we need only render six elements per item to produce the links, including using two more efficient elements, rendering three elements fewer per item. However, if we had 1,000 products, we would end up rendering 3,000 fewer UI elements, with 2,000 more efficient replacements, so it is easy to see how this can soon add up to some real efficiency savings.</p>
<p>In this example, we could make further improvements, simply by removing the line under each link. Bizarrely, we can save up to 25 percent of the rendering time taken to render our <kbd>Hyperlink</kbd> elements if we remove their underlines. We can do this by setting their <kbd>TextDecorations</kbd> property to <kbd>None</kbd>:</p>
<pre>&lt;Hyperlink ... TextDecorations="None"&gt;View&lt;/Hyperlink&gt; </pre>
<p>We could extend this idea further, by only displaying the underline when the user's mouse cursor is over the link. In this way, we still give the visual confirmation that the link is, in fact, a link, but we save the initial rendering time:</p>
<pre>&lt;Style TargetType="{x:Type Hyperlink}"&gt;<br/>  &lt;Setter Property="TextDecorations" Value="None" /&gt;<br/>  &lt;Style.Triggers&gt;<br/>    &lt;Trigger Property="IsMouseOver" Value="True"&gt;<br/>      &lt;Setter Property="TextDecorations" Value="Underline" /&gt;<br/>    &lt;/Trigger&gt;<br/>  &lt;/Style.Triggers&gt;<br/>&lt;/Style&gt;</pre>
<p>Let's now turn our attention to a number of performance improvements that we can make when data binding in our applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data binding</h1>
                
            
            
                
<p>The simplest improvement in performance when data binding can be obtained by simply setting the <kbd>Binding.Mode</kbd> property correctly. In order to make data binding possible, the Framework attaches handlers to listen out for changes to our data bound properties.</p>
<p>For two-way bindings, event handlers will be attached to the <kbd>PropertyChanged</kbd> event of the <kbd>INotifyPropertyChanged</kbd> interface to listen to changes in our data Model objects or View Models and to various other <kbd>XxxChanged</kbd> events in the relevant binding target controls to listen to UI-based property changes.</p>
<p>When we only require one-way bindings, we can save some computing resources by setting the <kbd>Mode</kbd> property of the <kbd>Binding</kbd> class to the appropriate member of the <kbd>BindingMode</kbd> enumeration. If you remember, when a data bound property is for display purposes only, we should set its <kbd>Mode</kbd> property to <kbd>OneWay</kbd>, and when we have no need to update an editable field from the View Model, we should set its <kbd>Mode</kbd> property to the <kbd>OneWayToSource</kbd> member.</p>
<p>In doing this, we cut down the number of event handlers listening for changes and, therefore, free up resources to be used where they are actually needed. Once again, the effect of doing this on one binding alone would be negligible, but if we practice this on every relevant binding, then the efficiency improvement will start to make a difference.</p>
<p>Another good practice to get into is to set the <kbd>FallbackValue</kbd> property of the <kbd>Binding</kbd> class on each binding that we declare. As mentioned in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>, doing this will stop the WPF Framework from performing a lookup of the default value of the target Dependency Property when there are data binding errors and will prevent trace statements from being generated and output.</p>
<p>Likewise, setting the <kbd>TargetNullValue</kbd> property is similar to setting the <kbd>FallbackValue</kbd> property in that it is slightly more efficient than not setting it. Again, doing this on a single binding will have a negligible effect; however, if we do this on every binding, it will free up CPU cycles for rendering or other required processes.</p>
<p>In fact, the best binding-related way to increase the performance of our applications is to simply fix any data binding errors that we may have. Each time a binding cannot be resolved, the Framework will perform a number of checks, using up valuable resources, as mentioned previously in this section. Therefore, keeping the Output window free of binding errors is a must when it comes to performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering Dependency Properties</h1>
                
            
            
                
<p>As we saw in the <em>Using the right controls for performance</em> section earlier in this chapter, we need to be careful when setting the metadata for our Dependency Properties. Incorrectly specifying the framework metadata while registering our Dependency Properties can lower performance by forcing the layout system to unnecessarily perform additional layout passes.</p>
<p>In particular, we need to be careful when specifying any of the <kbd>AffectsMeasure</kbd>, <kbd>AffectsArrange</kbd>, <kbd>AffectsParentMeasure</kbd>, <kbd>AffectsParentArrange</kbd>, or <kbd>AffectsRender</kbd> members of the <kbd>FrameworkPropertyMetadataOptions</kbd> enumeration and ensure that they are actually required.</p>
<p>Likewise, if we specify the <kbd>Inherits</kbd> member of the <kbd>FrameworkPropertyMetadataOptions</kbd> enumeration when registering our Dependency Property, we are effectively increasing the length of time that invalidation will take on the property. As such, we should ensure that this particular metadata member is only used when it is really necessary.</p>
<p>One last metadata option that can improve the performance of the application is the <kbd>SubPropertiesDoNotAffectRender</kbd> member. If the type of our Dependency Property is a reference type, we can specify this enumeration member to stop the layout system from checking for changes to all sub-properties of the object, which it would otherwise do by default.</p>
<p>While we may need to call the <kbd>OverrideMetadata</kbd> method of the <kbd>DependencyProperty</kbd> class to override the metadata of the pre-existing properties in the .NET Framework, this comes with a small performance impact. When setting the metadata for our own custom Dependency Properties, we should always use the appropriate <kbd>Register</kbd> or <kbd>RegisterAttached</kbd> method to specify our requirements, as this offers far better performance.</p>
<p>Likewise, when registering our custom Dependency Properties, we should also set their default values using the relevant <kbd>Register</kbd> or <kbd>RegisterAttached</kbd> method as they are created, rather than initializing each instance individually in a constructor, or by using some other method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binding to collections</h1>
                
            
            
                
<p>As you are most probably aware, when dealing with collections that will be updated in a WPF application, we tend to prefer using the generic <kbd>ObservableCollection&lt;T&gt;</kbd> class. The reason for this is because this class implements the <kbd>INotifyCollectionChanged</kbd> interface, which notifies listeners of changes to the collection, such as adding, removing, or clearing items.</p>
<p>What we may not realize is the incredible performance improvement that we get from using this class to hold our data collections. When comparing this with the generic <kbd>List&lt;T&gt;</kbd> class, for example, we note that it does not automatically raise any collection changed event. In order to enable the View to display the updated collection, we need to reset it as the <kbd>ItemsSource</kbd> property value of the relevant collection control.</p>
<p>However, each time that the <kbd>ItemsSource</kbd> property is set, the data bound collection control will clear its current list of items and completely regenerate them again, which can be a time-consuming process. So, to add a single item to an <kbd>ObservableCollection&lt;T&gt;</kbd> takes approximately 20 milliseconds to render, but to reset the <kbd>ItemsSource</kbd> property value could take over 1.5 seconds.</p>
<p>However, if our collection is immutable and we will not be altering it in any way, we do not need to use the generic <kbd>ObservableCollection&lt;T&gt;</kbd> class, as we have no need for its change handlers. Rather than wasting resources on unused change handlers, we can use a different type of collection class.</p>
<p>While there is not a preferred type of collection to use when data binding immutable collections to UI controls, we should try to avoid using the <kbd>IEnumerable</kbd> class as the collection container. This type cannot be used directly by the <kbd>ItemsControl</kbd> class, and, when it is used, the WPF Framework will generate a generic <kbd>IList&lt;T&gt;</kbd> collection to wrap the <kbd>IEnumerable</kbd> instance and this can also negatively affect performance.</p>
<p>In the next few sections, we'll explore other ways in which we can display large collections efficiently.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shrinking data objects</h1>
                
            
            
                
<p>Quite often, our applications will have fairly sizable data objects, with dozens, or even hundreds, of properties. If we were to load all of the properties for each data object when we have thousands of them, our application would slow down and possibly even run out of memory.</p>
<p>We might think that we can save on RAM by simply not populating all of the property values; however, if we use the same classes, we'll soon find that even the default or empty values for these properties may consume too much memory. In general, and with a few exceptions, unset properties take the same amount of RAM as set properties.</p>
<p>If our data model object has a very large number of properties, one solution would be to break it down into much smaller pieces. For example, we could create a number of smaller, sub product classes, such as <kbd>ProductTechnicalSpecification</kbd>, <kbd>ProductDescription</kbd>, <kbd>ProductDimension</kbd>, <kbd>ProductPricing</kbd>, and more.</p>
<p>Rather than building one giant View to edit the whole product, we could then provide a number of smaller Views, perhaps even accessible from different tabs within the same View. In this way, we would be able to just load the <kbd>ProductDescription</kbd> objects for the user to select from and then load the individual sections of the product in each sub View.</p>
<p>There is a significant performance increase to be gained by this method, as binding to a single object with a great many properties can take up to four times longer than binding to a great many objects with fewer properties.</p>
<p>One alternative to breaking our data objects into smaller pieces would be to use the concept of thin data objects. For example, imagine that our <kbd>Product</kbd> class had dozens of properties and that we had thousands of products. We could create a <kbd>ThinProduct</kbd> class that contains only the properties that would be used to identify the full data object to load when selected and those displayed in the product collection.</p>
<p>In this case, we might simply need two properties in our <kbd>ThinProduct</kbd> class, a unique identification property, and a display name property. In this way, we can reduce the memory footprint of our products by a factor of 10 or even more. This means that they can be loaded from the database and displayed in a fraction of the time of the full <kbd>Product</kbd> objects.</p>
<p>In order to facilitate easy transferal between the <kbd>Product</kbd> and <kbd>ThinProduct</kbd> classes, we can add constructors into each class that accepts the other type and updates the relevant properties:</p>
<pre>using System; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class ThinProduct : BaseDataModel 
  { 
    private Guid id = Guid.Empty; 
    private string name = string.Empty; 
 
    public ThinProduct(Product product) 
    { 
      Id = product.Id; 
      Name = product.Name; 
    } 
 
    public Guid Id 
    { 
      get { return id; } 
      set { if (id != value) { id = value;
        NotifyPropertyChanged(); } } 
    } 
 
    public string Name 
    { 
      get { return name; } 
      set { if (name != value) { name = value;
        NotifyPropertyChanged(); } } 
    } 
 
    public override string ToString() 
    { 
      return Name; 
    } 
  } 
} </pre>
<p>The properties in this <kbd>ThinProduct</kbd> class basically mirror those from the <kbd>Product</kbd> class that we saw earlier, but only the ones that are used to identify each instance. A constructor is added that takes an input parameter of type <kbd>Product</kbd> to enable easy transferal between the two. A similar constructor is added to the <kbd>Product</kbd> class, but takes an input parameter of type <kbd>ThinProduct</kbd>:</p>
<pre>public Product(ThinProduct thinProduct) : this() 
{ 
  Id = thinProduct.Id; 
  Name = thinProduct.Name; 
} </pre>
<p>The idea is that we have a View Model that displays a large number of products and in code, we actually load a large number of these much lighter <kbd>ThinProduct</kbd> instances. When the user selects one of the products to view or edit, we use the identification number of the selected item to then load the full <kbd>Product</kbd> object that relates to that identifier.</p>
<p>Given a base collection of these <kbd>ThinProduct</kbd> instances in a property named <kbd>Products</kbd>, we could achieve this as follows. First, let's bind our collection to a <kbd>ListBox</kbd> control:</p>
<pre>&lt;ListBox ItemsSource="{Binding Products}" 
  SelectedItem="{Binding Products.CurrentItem}" ... /&gt; </pre>
<p>When the user selects a product from the list, the collection's <kbd>CurrentItem</kbd> property will hold a reference to the selected item. If we attach a handler to the collection's <kbd>CurrentItemChanged</kbd> delegate when it is first loaded, we can be notified when the item is selected.</p>
<p>At that point, we can load the full <kbd>Product</kbd> object using the identifier from the selected <kbd>ThinProduct</kbd> instance and output the associated feedback to the user:</p>
<pre>private void Products_CurrentItemChanged(ThinProduct oldProduct,  
  ThinProduct newProduct) 
{ 
  GetDataOperationResult&lt;Product&gt; result =  
    await Model.GetProductAsync(newProduct.Id); 
  if (result.IsSuccess) Product = result.ReturnValue; 
  else FeedbackManager.Add(result, false); 
} </pre>
<p>In the next section, we'll find out how we can display our large collections more efficiently using collection controls, rather than having to break up our large classes into smaller classes or create associated thin data objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Virtualizing collections</h1>
                
            
            
                
<p>When we display large numbers of items in our collection controls, it can negatively affect the application's performance. This is because the layout system will create a layout container, such as a <kbd>ComboBoxItem</kbd> in the case of a <kbd>ComboBox</kbd>, for example, for every item in the data bound collection. As only a small subset of the complete number of items is displayed at any one time, we can take advantage of virtualization to improve the situation.</p>
<p>UI virtualization defers the generation and layout of these item containers until each item is actually visible in the relevant collection control, often saving on large amounts of resources. We can take advantage of virtualization without doing anything at all if we use <kbd>ListBox</kbd> or <kbd>ListView</kbd> controls to display our collections, as they use it by default.</p>
<p>Virtualization can also be enabled in <kbd>ComboBox</kbd>, <kbd>ContextMenu</kbd>, and <kbd>TreeView</kbd> controls, although it will have to be done manually. When using a <kbd>TreeView</kbd> control, we can enable virtualization by simply setting the <kbd>VirtualizingStackPanel.IsVirtualizing</kbd> Attached Property to <kbd>True</kbd> on it:</p>
<pre>&lt;TreeView ItemsSource="{Binding Items}" 
  VirtualizingStackPanel.IsVirtualizing="True" /&gt; </pre>
<p>For other controls that use the <kbd>StackPanel</kbd> class internally, such as the <kbd>ComboBox</kbd> and <kbd>ContextMenu</kbd> controls, we can enable virtualization by setting an <kbd>ItemsPanelTemplate</kbd> element hosting an instance of the <kbd>VirtualizingStackPanel</kbd> class with its <kbd>IsVirtualizing</kbd> property set to <kbd>True</kbd> to its <kbd>ItemsPanel</kbd> property:</p>
<pre>&lt;ComboBox ItemsSource="{Binding Items}"&gt; 
  &lt;ComboBox.ItemsPanel&gt; 
    &lt;ItemsPanelTemplate&gt; 
      &lt;VirtualizingStackPanel IsVirtualizing="True" /&gt; 
    &lt;/ItemsPanelTemplate&gt; 
  &lt;/ComboBox.ItemsPanel&gt; 
&lt;/ComboBox&gt; </pre>
<p>Apart from setting the <kbd>IsVirtualizing</kbd> property to <kbd>False</kbd>, there are a few other reasons why UI virtualization may not work. One case is when item containers have manually been added to an <kbd>ItemsControl</kbd> object or one of its derived controls. Another case is when the item containers are of different types.</p>
<p>The final reason why virtualization may not work is not so obvious and relates to the <kbd>CanContentScroll</kbd> property of the <kbd>ScrollViewer</kbd> class. This is an interesting property that specifies whether the <kbd>ScrollViewer</kbd> in a collection control will scroll its items in logical units or physical units. The default value is <kbd>False</kbd>, which smoothly scrolls in terms of physical units.</p>
<p>Physical units relate to the device-independent pixels that WPF works with, while logical units relate to the widths or heights of the collection items, depending on the orientation of the control. As the default value of the <kbd>CanContentScroll</kbd> property is <kbd>False</kbd>, this will need to be set to <kbd>True</kbd> to enable virtualization. This is so that scrolling is performed item by item and not pixel by pixel.</p>
<p>When virtualization is employed in a collection control that extends the <kbd>ItemsControl</kbd> class and the user scrolls, new item containers are created for the newly visible items and the containers for the items that are no longer visible are disposed of.</p>
<p>In version 3.5 of the .NET Framework, an optimization of the virtualization system was introduced. Container recycling enables the collection control to reuse the item containers, instead of creating new ones and disposing of old ones as the user scrolls. This offers an additional performance benefit and can be enabled by setting the <kbd>VirtualizationMode</kbd> Attached Property to a value of <kbd>Recycling</kbd>:</p>
<pre>&lt;TreeView ItemsSource="{Binding Items}" 
  VirtualizingStackPanel.IsVirtualizing="True" /&gt; 
  VirtualizingStackPanel.VirtualizationMode="Recycling" /&gt; </pre>
<p>One further optimization that WPF provides us with is deferred scrolling. Normally, scrolling in a collection control continuously updates the UI. However, if our data items or their item containers have several layers of visuals that define them and scrolling is slow, we can opt to defer the UI update until scrolling has finished.</p>
<p>In order to enable deferred scrolling on a collection control, we need to set the <kbd>ScrollViewer.IsDeferredScrollingEnabled</kbd> Attached Property to <kbd>True</kbd>. Although we don't generally use <kbd>ScrollViewer</kbd> elements in XAML directly, we can also attach this property to collection controls that host a <kbd>ScrollViewer</kbd> element in their control templates:</p>
<pre>&lt;ListBox ItemsSource="{Binding Items}"<br/>  ScrollViewer.IsDeferredScrollingEnabled="True" /&gt; </pre>
<p>We've now investigated performance improvements that we can make with computer hardware, resources, correct control selection, methods of drawing and displaying images, outputting text, linking, data binding, minimizing memory footprints, and data virtualization. There is just one more essential area to look at, that is, events, so let's look at that next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling events</h1>
                
            
            
                
<p>One of the most common causes of memory leaks appearing in an application is the failure to remove event handlers once they are no longer needed. When we attach an event handler to an object's event in the usual way, we are effectively passing that object a reference to the handler and creating a hard reference to it.</p>
<p>When the object is no longer needed and could otherwise be disposed of, the reference in the object that raises the event will prevent that from occurring. This is because the garbage collector cannot collect an object that can be accessed from any part of the application code. In the worst-case scenario, the object being kept alive may contain numerous other objects and, therefore, inadvertently keep them alive as well.</p>
<p>The problem with this is that keeping objects alive after they are no longer needed will unnecessarily increase the memory footprint of the application, in some cases, with dramatic and irreversible consequences, leading to an <kbd>OutOfMemoryException</kbd> being thrown. It is, therefore, essential that we detach our event handlers from the events that they are subscribed to in objects that we have no further use for before trying to dispose of them.</p>
<p>There is, however, an alternative method that we can use to avoid this situation. In the .NET Framework, there is a <kbd>WeakReference</kbd> class and it can be used to remove the hard references caused by attaching event handlers to events using the traditional method.</p>
<p>The basic idea is that the class that raises the event should maintain a collection of <kbd>WeakReference</kbd> instances and add to it each time another class attaches an event handler to the event. Let's now create a new <kbd>WeakReferenceActionCommand</kbd> class from our <kbd>ActionCommand</kbd> class from earlier to use this <kbd>WeakReference</kbd> class:</p>
<pre>using System; 
using System.Collections.Generic; 
using System.Windows.Input; 
 
namespace CompanyName.ApplicationName.ViewModels.Commands 
{ 
  public class WeakReferenceActionCommand : ICommand 
  { 
    private readonly Action&lt;object&gt; action; 
    private readonly Predicate&lt;object&gt; canExecute; 
    private List&lt;WeakReference&gt; eventHandlers = new List&lt;WeakReference&gt;(); 
 
    public WeakReferenceActionCommand(Action&lt;object&gt; action) : <br/>      this(action, null) { } 
 
    public WeakReferenceActionCommand(Action&lt;object&gt; action,  
      Predicate&lt;object&gt; canExecute) 
    { 
      if (action == null) throw new ArgumentNullException("The action <br/>        input parameter of the WeakReferenceActionCommand constructor <br/>        cannot be null."); <br/>      this.action = action; 
      this.canExecute = canExecute; 
    } 
 
    public event EventHandler CanExecuteChanged 
    { 
      add 
      { 
        eventHandlers.Add(new WeakReference(value)); 
        CommandManager.RequerySuggested += value; 
      } 
      remove 
      { 
        if (eventHandlers == null) return; 
        for (int i = eventHandlers.Count - 1; i &gt;= 0; i--) 
        { 
          WeakReference weakReference = eventHandlers[i]; 
          EventHandler handler = weakReference.Target as EventHandler; 
          if (handler == null || handler == value) 
          { 
            eventHandlers.RemoveAt(i); 
          } 
        } 
        CommandManager.RequerySuggested -= value; 
      } 
    } 
 
    public void RaiseCanExecuteChanged() 
    { 
      eventHandlers.ForEach(
        r =&gt; (r.Target as EventHandler)?.Invoke(this, new EventArgs())); 
    } 
 
    public bool CanExecute(object parameter) 
    { 
      return canExecute == null ? true : canExecute(parameter); 
    } 
 
    public void Execute(object parameter) 
    { 
      action(parameter); 
    } 
  } 
} </pre>
<p>We start by adding a declaration of our new collection containing objects of the <kbd>WeakReference</kbd> type to the pre-existing fields. The two constructors remain unchanged, but when attaching handlers in the <kbd>CanExecuteChanged</kbd> event, we now wrap the event handling delegate in a <kbd>WeakReference</kbd> object and add it to the collection. We still need to pass the references to the handlers that get attached through to the <kbd>RequerySuggested</kbd> event of the <kbd>CommandManager</kbd> class as before.</p>
<p>When an event handler is removed, we first double-check that our <kbd>WeakReference</kbd> collection is not <kbd>null</kbd> and simply return control to the caller if it is. If not, we use a <kbd>for</kbd> loop to iterate through the collection in reverse so that we can remove items without affecting the loop index.</p>
<p>We attempt to access the actual event handler from the <kbd>Target</kbd> property of each <kbd>WeakReference</kbd> object in turn, converting it to the <kbd>EventHandler</kbd> base type using the <kbd>as</kbd> keyword. We then remove the <kbd>WeakReference</kbd> instance if its event handler reference is either <kbd>null</kbd> or it matches the handler being removed.</p>
<p>Note that a <kbd>null</kbd> reference in the <kbd>Target</kbd> property would be the result of an event handler from a class that has been disposed of by the garbage collector. As before, we then also detach the event handler from the <kbd>CommandManager.RequerySuggested</kbd> event.</p>
<p>Finally, we need to update our <kbd>RaiseCanExecuteChanged</kbd> method to use our new collection of <kbd>WeakReference</kbd> objects. In it, we again iterate through each instance in the collection using our <kbd>ForEach</kbd> Extension Method and after checking whether its <kbd>Target</kbd> property is <kbd>null</kbd> by using the null conditional operator, call it using the delegate's <kbd>Invoke</kbd> method.</p>
<p>So, the idea here is that we no longer directly hold on to any references to the attached event handlers and are, therefore, free to dispose of those classes at any point without fear of them being kept alive unnecessarily.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we explored a number of options that we can use to increase the performance of our WPF applications. As we have now seen, this is more a case of making a large number of little changes to gain an overall noticeable performance benefit.</p>
<p>We saw that we can utilize the graphics rendering power of our computer's graphics card and declare our resources more efficiently. We investigated ways to improve our application's performance using lighter-weight UI controls and more efficient methods of rendering drawings, images, and text. We also learned how to data bind, display large objects and collections, and handle events with improved performance.</p>
<p>In the next chapter, we will investigate the final requirement for all professional applications, that is, deployment. In it, we will first cover the older method, using the Windows Installer software, and then progress to investigate the more common and up-to-date method, that is, using ClickOnce functionality.</p>


            

            
        
    </body></html>