- en: Chapter 2. Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 调试
- en: Debugging is the process of finding, identifying, and fixing bugs (errors or
    mistakes) in your code, and there are many ways to achieve this. To script effectively,
    you'll need to be aware of the most common workflows and toolsets available to
    you for debugging in Unity. Before considering them further, however, it's important
    to be aware of the general limitations of debugging and what it cannot achieve.
    Debugging is not a magical cure-all to remove all bugs and guarantee an error-free
    application. The computer scientist Edsger W. Dijkstra said, *"Program testing
    can be used to show the presence of bugs, but never to show their absence"*. The
    crucial point is that during testing, you might encounter one or more errors.
    These errors can be identified, tested, and repaired through debugging. Yet, your
    tests—though perhaps extensive and careful—will never cover every possible case
    or scenario on every hardware platform under all conditions, as these combinations
    could be practically infinite. So, you can never be absolutely certain to have
    found all the possible bugs. Even on the release day, there could still be bugs
    in your game, which your testing couldn't detect. Of course, there might actually
    be no bugs remaining at all, but you cannot know this with absolute certainty.
    So, debugging is not about achieving an error-free application. Its aims are more
    modest. It's about systematically testing your game in many common and reasonable
    situations to find and correct as many errors as you encounter or, at least, as
    many severe errors as your time and budget permits. In any case, debugging is
    a critical part of scripting, because without it, you will have no way of tracing
    and fixing errors. Debugging techniques range from simple to complex, and in this
    chapter, we'll cover a broad spectrum of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是查找、识别和修复代码中错误（错误或错误）的过程，并且有许多方法可以实现这一点。为了有效地编写脚本，你需要了解你可用于在Unity中进行调试的最常见的工作流程和工具集。在进一步考虑它们之前，了解调试的一般限制和它无法实现的事情是很重要的。调试不是一种万能的魔法药，可以消除所有错误并保证应用程序无错误。计算机科学家埃德加·W·迪杰斯特拉说：“程序测试可以用来显示错误的存在，但永远不能显示它们的缺失”。关键点是，在测试过程中，你可能会遇到一个或多个错误。这些错误可以通过调试来识别、测试和修复。然而，尽管你的测试可能非常广泛和细致，但你永远无法覆盖所有可能的案例或场景，因为这些组合在实际上可能是无限的。因此，你永远不能绝对确定已经找到了所有可能的错误。即使在发布当天，你的游戏中也可能仍然存在测试无法检测到的错误。当然，实际上可能根本没有任何错误遗留，但你无法绝对确定这一点。因此，调试不是关于实现无错误的应用程序。它的目标更加谦虚。它关于在许多常见和合理的情况下系统地测试你的游戏，以找到和纠正你遇到的所有错误，或者至少是时间预算允许的所有严重错误。无论如何，调试是脚本编写的一个关键部分，因为没有它，你就无法追踪和修复错误。调试技术从简单到复杂，在本章中，我们将涵盖它们的一个广泛范围。
- en: Compilation errors and the console
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译错误和控制台
- en: 'Debugging typically refers to error-busting techniques for runtime use; that
    is, it refers to the things you can do to find and correct errors when your game
    is running. This understanding of debugging, of course, presupposes that your
    code is already valid and compiled. The implicit assumption is that you can write
    valid statements in C# and compile code, and you just want to find runtime errors
    that occur as a result of program logic. Thus, the focus is not on syntax but
    on logic, and this is indeed true. However, in this section, I''ll speak very
    briefly about code compilation, about writing valid code, and using the console
    to find and correct errors of validity. This is important, both to introduce the
    **Console** window generally and also to establish a firm basis of thinking about
    debugging in more depth. Consider the following code sample 2-1 script file (`ErrorScript.cs`):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 调试通常指的是运行时使用的错误排除技术；也就是说，它指的是你在游戏运行时可以做的事情来查找和纠正错误。当然，这种对调试的理解前提是你的代码已经是有效且编译过的。隐含的假设是你能够用C#编写有效的语句并编译代码，而你只是想找到由程序逻辑引起的运行时错误。因此，重点不在于语法，而在于逻辑，这确实是正确的。然而，在本节中，我将非常简要地谈谈代码编译、编写有效代码以及使用控制台查找和纠正有效性错误。这很重要，不仅是为了一般性地介绍**控制台**窗口，也是为了为更深入地思考调试打下坚实的基础。考虑以下代码示例2-1脚本文件（`ErrorScript.cs`）：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To compile the preceding code sample 2-1, simply save the script file in MonoDevelop
    (*Ctrl* + *S*) and then refocus the Unity Editor window. From here, compilation
    will happen automatically. If it doesn't, you can also right-click on the script
    file from the **Project** panel and choose **Reimport** from the context menu.
    For the code sample 2-1, two errors are generated, and these will be shown in
    the **Console** window. If you don't already have the **Console** window open,
    it could be shown by selecting the **Console** option from **Window** from the
    application menu. The **Console** window is highly important, and you'll almost
    always want it open somewhere in the interface. This is where Unity as an engine
    communicates with you as a developer. Thus, if your code has compile errors, Unity
    would list them to **Console**, letting you know what they are.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译前面的代码示例 2-1，只需在 MonoDevelop 中保存脚本文件（*Ctrl* + *S*）然后重新聚焦 Unity 编辑器窗口。从这里，编译将自动发生。如果它没有发生，你也可以从
    **项目** 面板右键单击脚本文件，并在上下文菜单中选择 **重新导入**。对于代码示例 2-1，将生成两个错误，这些错误将在 **控制台** 窗口中显示。如果你还没有打开
    **控制台** 窗口，可以通过从应用程序菜单中选择 **窗口** > **控制台** 来显示它。**控制台** 窗口非常重要，你几乎总是希望它在界面的某个地方打开。这是
    Unity 作为引擎与作为开发者的你沟通的地方。因此，如果你的代码有编译错误，Unity 会将它们列在 **控制台** 中，让你知道它们是什么。
- en: The code sample 2-1 generates two compile-time errors, as shown in the following
    screenshot. These happen because lines 11 and 16 refer to the variable `mynumber`
    that doesn't exist, although `MyNumber` does (case sensitivity). Compile-time
    errors such as these are critical because they render your code invalid. This
    means you cannot compile your code and run your game until the errors are corrected.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例 2-1 生成两个编译时错误，如下截图所示。这些错误发生是因为第 11 行和第 16 行引用了不存在的变量 `mynumber`，尽管 `MyNumber`
    存在（大小写敏感）。这种编译时错误是关键的，因为它们会使你的代码无效。这意味着你无法编译你的代码并运行你的游戏，直到错误被纠正。
- en: '![Compilation errors and the console](img/0655OT_02_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![编译错误和控制台](img/0655OT_02_01.jpg)'
- en: Viewing compilation errors in the Console window
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台窗口中查看编译错误
- en: If compilation errors are not shown in **Console** as expected, then make sure
    that the errors filter is enabled. To enable this, click on the error filter icon
    (a red exclamation mark icon) in the top-right corner of the **Console** window.
    The **Console** window features three filters, comments (**A**), warnings (**B**),
    and errors (**C**), as shown in the following screenshot, to hide and show specific
    messages. These toggle the visibility of each message type in the **Console**
    window. Comments refer to the messages that you, as a programmer, explicitly print
    to the **Console** window from your code using the `Debug.Log` statement. We'll
    see examples of this shortly (you can also use the `Print` function). Warnings
    refer to potential issues or wastages detected in your code. These are syntactically
    valid and will compile even if ignored by you, but they might cause problems or
    have unintended and wasteful results. Errors refer to any compile-time errors
    found in your code that affect its compilation validity, such as with code sample
    2-1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译错误没有按预期显示在 **控制台** 中，请确保错误过滤器已启用。要启用此功能，请单击 **控制台** 窗口右上角的错误过滤器图标（一个红色的感叹号图标）。**控制台**
    窗口有三个过滤器，注释（**A**）、警告（**B**）和错误（**C**），如下截图所示，用于隐藏和显示特定消息。这些切换在 **控制台** 窗口中每种消息类型的可见性。注释是指你作为程序员，使用
    `Debug.Log` 语句从你的代码中显式打印到 **控制台** 窗口的消息。我们很快就会看到这方面的例子（你也可以使用 `Print` 函数）。警告是指检测到你的代码中的潜在问题或浪费。这些在语法上是有效的，即使你忽略它们，也可以编译，但它们可能会引起问题或产生意外和浪费的结果。错误是指任何影响代码编译有效性的编译时错误，例如代码示例
    2-1 中的错误。
- en: '![Compilation errors and the console](img/0655OT_02_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![编译错误和控制台](img/0655OT_02_02.jpg)'
- en: Enabling/disabling the Console window filters
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 启用/禁用控制台窗口过滤器
- en: 'When the console fills with more than one error, the errors are typically listed
    in the order in which they were detected by the compiler, that is, from top to
    bottom. It''s considered best practice to tackle errors in order, because earlier
    errors can cause later ones. Thus, resolving earlier errors can, potentially,
    resolve later ones. To resolve an error, start by double-clicking on the error
    from the **Console** window, and MonoDevelop will open automatically, highlighting
    the line where the error itself was found or where the error was first detected.
    It is important to note that MonoDevelop will take you to the line where the error
    was first detected, although resolving the error will not always involve editing
    that line specifically. Depending on the issue, you will need to change to a different
    line than theone highlighted. If you double-click on the top error (first error)
    in **Console**, as generated by the code sample 2-1, MonoDevelop will open and
    highlight line 11\. You can fix this error in two ways: either by renaming `mynumber`
    to `MyNumber` in line 11 or by renaming the variable `MyNumber` to `mynumber`
    in line 6\. Now, consider the following code sample 2-2:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制台充满了多个错误时，错误通常是按照编译器检测到的顺序列出的，即从上到下。被认为是一种最佳实践，按顺序处理错误，因为早期错误可能会引起后续错误。因此，解决早期错误可能会，潜在地，解决后续错误。要解决一个错误，首先双击**控制台**窗口中的错误，MonoDevelop将自动打开，突出显示错误本身被发现或首次检测到的行。需要注意的是，MonoDevelop会带您到错误首次被检测到的行，尽管解决错误并不总是涉及编辑该行。根据问题，您可能需要更改到突出显示的行以外的行。如果您双击由代码示例2-1生成的**控制台**中的顶部错误（第一个错误），MonoDevelop将打开并突出显示第11行。您可以通过两种方式修复这个错误：要么在第11行将`mynumber`重命名为`MyNumber`，要么在第6行将变量`MyNumber`重命名为`mynumber`。现在，考虑以下代码示例2-2：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code sample 2-2 fixes the errors in code sample 2-1\. However, it leaves us
    with a warning instead (as shown in the following screenshot). This indicates
    that the variable `MyNumber` is never used. It's assigned a value in lines 11
    and 16, but this assignment is never of any ultimate consequence for the application.
    Here, this warning could be ignored and the code would remain valid. Warnings
    should be seen primarily as recommendations made by the compiler about your code.
    How you handle them is ultimately your choice, but I recommend that you try to
    eliminate both errors and warnings wherever practical.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例2-2修复了代码示例2-1中的错误。然而，它给我们留下了一个警告（如以下截图所示）。这表明变量`MyNumber`从未被使用。它在第11行和第16行被赋值，但这种赋值对应用程序的最终结果没有任何影响。在这里，这个警告可以被忽略，代码仍然有效。警告应该主要被视为编译器对您的代码提出的建议。您如何处理它们是您最终的选择，但我建议您在可能的情况下尝试消除错误和警告。
- en: '![Compilation errors and the console](img/0655OT_02_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![编译错误和控制台](img/0655OT_02_03.jpg)'
- en: Try to eliminate both errors and warnings
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试消除错误和警告
- en: Debugging with Debug.Log – custom messages
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Debug.Log进行调试——自定义消息
- en: 'Perhaps, the oldest and most well-known debugging technique in Unity is to
    use `Debug.Log` statements to print diagnostic messages to **Console**, thus illustrating
    program flow and object properties. This technique is versatile and appealing
    because it can be used in practically every **Integrated Development Environment**
    (**IDE**) and not just MonoDevelop. Further, all the Unity objects, including
    vector and color objects, have a convenient `ToString` function that allows their
    internal members (such as *X*, *Y*, and *Z*) to be printed to a human-readable
    string—one that can be easily sent to the console for debugging purposes. For
    example, consider the following code sample 2-3\. This code sample demonstrates
    an important debugging workflow, namely, printing a status message about an object
    at its instantiation. This script, when attached to a scene object, prints its
    world position to **Console**, along with a descriptive message:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，在Unity中最古老且最著名的调试技术是使用`Debug.Log`语句将诊断信息打印到**控制台**，从而说明程序流程和对象属性。这项技术非常灵活且吸引人，因为它可以在几乎每一个**集成开发环境**（**IDE**）中使用，而不仅仅是MonoDevelop。此外，所有Unity对象，包括向量和颜色对象，都有一个方便的`ToString`函数，它允许它们的内部成员（如*X*、*Y*和*Z*）被打印成人类可读的字符串——这种字符串可以轻松地发送到控制台进行调试。例如，考虑以下代码示例2-3。这个代码示例演示了一个重要的调试工作流程，即打印关于对象实例化的状态信息。当这个脚本附加到场景对象上时，它会将其世界位置打印到**控制台**，并附带一条描述性信息：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following screenshot demonstrates the output of this code in **Console**
    when attached to a cube `GameObject`. The `Debug.Log` message is printed in the
    main console message list. If the message is selected with the mouse, **Console**
    will also indicate a script file and line associated with the statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了当附加到立方体`GameObject`时，此代码在**控制台**中的输出。`Debug.Log`消息打印在主控制台消息列表中。如果用鼠标选择该消息，**控制台**还将指示与该语句相关的脚本文件和行。
- en: '![Debugging with Debug.Log – custom messages](img/0655OT_02_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用Debug.Log进行调试 – 自定义消息](img/0655OT_02_04.jpg)'
- en: Debug.Log messages can convert objects to strings, and the Console window also
    indicates an associated script file and line
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Debug.Log消息可以将对象转换为字符串，控制台窗口也会指示相关的脚本文件和行
- en: The main limitations of `Debug.Log` as a debugging technique relate to code
    cleanliness and program complexity. First, the `Debug.Log` statements require
    you to explicitly add code to your source files. When you're done debugging, you'll
    need to either remove the `Debug.Log` statements manually or leave them there,
    which is wasteful and results in confusion, especially if you have to add the
    additional `Debug.Log` statements in many other places. Second, though `Debug.Log`
    is useful to target specific problems or monitor specific variables over time,
    it's ultimately awkward to get a higher-level picture of your code and its execution
    to trace errors whose presence you detect but whose location is entirely unknown.
    These criticisms, however, shouldn't be regarded as advice to avoid using the
    `Debug.Log` statements entirely. They should be considered only to use them appropriately.
    `Debug.Log` works best when an error or problem can be traced to a prime suspect
    object, and you want to observe or monitor its values to see how they change or
    update, especially during events such as `OnStart`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.Log`作为调试技术的局限性主要与代码整洁性和程序复杂性相关。首先，`Debug.Log`语句要求您明确地将代码添加到源文件中。当您完成调试后，您需要手动删除`Debug.Log`语句，或者保留它们，这既浪费资源又会导致混淆，尤其是如果您需要在许多其他地方添加额外的`Debug.Log`语句。其次，尽管`Debug.Log`在针对特定问题或监控特定变量随时间变化时很有用，但最终要获得代码及其执行的高级视图以跟踪您检测到但位置完全未知的问题是很尴尬的。然而，这些批评不应被视为完全避免使用`Debug.Log`语句的建议。它们应仅被视为适当使用它们的考虑。`Debug.Log`在错误或问题可以追溯到主要嫌疑人对象，并且您想观察或监控其值以查看它们如何变化或更新时效果最佳，尤其是在`OnStart`等事件期间。'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Removing the Debug.Log statements**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**移除Debug.Log语句**'
- en: When your game is ready to build and ship, remember to remove or comment away
    any `Debug.Log` statements for extra cleanliness.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的游戏准备构建和发布时，请记住删除或注释掉任何`Debug.Log`语句以获得额外的整洁性。
- en: Overriding the ToString method
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写ToString方法
- en: 'The following code sample 2-3 demonstrates the convenience of the `ToString`
    method when used in conjunction with the `Debug.Log` debugging. `ToString` lets
    you convert an object to a human-readable string that can be output to **Console**.
    In C#, every class inherits the `ToString` method by default. This means that
    using inheritance and polymorphism, you can override the `ToString` method of
    your class that customizes it as required and produce a more readable and accurate
    debug string that represents your class members. Consider the following code sample
    2-4 that overrides `ToString`. If you get into the habit of overriding `ToString`
    for every class you make, your classes will become easier to debug:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例2-3展示了在结合使用`Debug.Log`调试时，`ToString`方法的便利性。`ToString`允许您将对象转换为人类可读的字符串，并将其输出到**控制台**。在C#中，每个类默认继承`ToString`方法。这意味着通过继承和多态，您可以重写您类的`ToString`方法，按需定制它，并生成一个更易读、更准确的调试字符串，该字符串代表您的类成员。考虑以下代码示例2-4，它重写了`ToString`。如果您养成为每个类重写`ToString`的习惯，您的类将更容易调试：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code can be seen in the **Console** window, as
    shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出可以在以下所示的控制台窗口中看到：
- en: '![Overriding the ToString method](img/0655OT_02_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![重写ToString方法](img/0655OT_02_05.jpg)'
- en: Overriding the ToString method to customize debug messages for a class
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重写ToString方法以自定义类的调试消息
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**String.Format**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**String.Format**'
- en: Line 30 of the code sample 2-3 uses the `String.Format` function to build a
    complete string. This function is useful when you need to make one long string
    that includes both literal statements and variable values, which could be different
    types. By inserting the tokens `{0}, {1}, {2}…` inside the string argument, the
    `Format` function will substitute them for the subsequent function arguments in
    the order in which they are provided; that is, `String.Format` will concatenate
    your string argument at the location of the tokens, with string versions of your
    function arguments. Thus, the string `{0}` will be replaced with `OgreName.ToString()`.
    For more information on `String.Format`, see the online documentation at [http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例2-3的第30行使用了`String.Format`函数来构建一个完整的字符串。这个函数在你需要创建一个包含字面语句和变量值的字符串时非常有用，这些值可能是不同类型的。通过在字符串参数中插入标记`{0},
    {1}, {2}…`，`Format`函数将按照提供的顺序将它们替换为后续函数参数；也就是说，`String.Format`将在标记的位置连接你的字符串参数，以及你的函数参数的字符串形式。因此，字符串`{0}`将被替换为`OgreName.ToString()`。有关`String.Format`的更多信息，请参阅[http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx)在线文档。
- en: 'You can section off and isolate blocks of code between the release and debug
    versions that allow you to run debug-specific code when specific flags are enabled.
    When debugging games, for example, you''ll frequently develop two sets or variations
    of code: the release code and the debug code. Imagine a common scenario where
    to find and resolve a bug in the code, you resort to inserting the `Debug.Log`
    statements that print out the values of variables and states of classes. You might
    even insert additional lines, such as `if` statements and loops, to test out alternative
    scenarios and explore how objects react. After amending the code for a while,
    the problem seems repaired, so you remove the additional debug code and continue
    testing as you did earlier. However, later, you discover that the problem has
    returned, or a similar one has arisen. So now you wish you''d kept the debug code
    after all, because it''d be useful again. You might promise yourself that next
    time, you''ll simply comment out the debug code as opposed to deleting it entirely.
    This will let you simply remove the commenting should the code be needed again.
    However, of course, having to comment and uncomment code is also tedious, especially
    if there''re many lines, and they are scattered across multiple files and parts
    of files. You can, however, resolve this problem and similar ones using custom
    global defines. In essence, a global define is a special preprocessor flag that
    you can enable or disable to conditionally compile or exclude blocks of your code.
    By setting the flag to `true`, Unity will automatically compile one version of
    your code, and by setting it to `false`, Unity will compile the other version.
    This will allow you to maintain two versions or variations of your code in only
    one set of source files: one for debug and one for release. Let''s see this in
    practice in Unity. Consider the following code sample 2-5:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在发布和调试版本之间划分并隔离代码块，这样当特定的标志被启用时，你可以运行针对调试的代码。例如，在调试游戏时，你通常会开发两组或多种代码：发布代码和调试代码。想象一个常见的场景，当你需要找到并解决代码中的错误时，你会求助于插入`Debug.Log`语句来打印变量和类的状态值。你可能还会插入额外的行，例如`if`语句和循环，来测试不同的场景并探索对象如何反应。修改代码一段时间后，问题似乎得到了修复，因此你移除了额外的调试代码并继续像之前一样进行测试。然而，后来你发现问题又出现了，或者出现了类似的问题。所以现在你希望你最终还是保留了调试代码，因为它们可能再次有用。你可能会对自己承诺说，下次你将简单地注释掉调试代码，而不是完全删除它。这样，如果代码再次需要，你可以简单地移除注释。然而，当然，必须注释和取消注释代码也是很麻烦的，尤其是如果有很多行，并且它们散布在多个文件和文件的部分。然而，你可以使用自定义的全局定义来解决此问题以及类似的问题。本质上，全局定义是一个特殊的预处理器标志，你可以启用或禁用它来有条件地编译或排除你的代码块。通过将标志设置为`true`，Unity将自动编译你的代码的一个版本，而将标志设置为`false`，Unity将编译另一个版本。这将允许你只在一组源文件中维护两个版本或变体：一个用于调试，一个用于发布。让我们在Unity中实际看看这个例子。考虑以下代码示例2-5：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lines 09–12 feature the core functionality using the preprocessor directives
    `#if` and `#endif` conditional. This conditional is not executed at runtime like
    a regular `if` statement, but at compile time. At compile time, Unity will decide
    whether the global define `SHOW_DEBUG_MESSAGES` is specified or active. If, and
    only if, it is, then lines 10 and 11 will be compiled, otherwise the compiler
    will ignore these lines, treating them as comments. Using this feature, you can
    isolate all debug code within an `#if #endif` block that checks for a debug define
    and activates and deactivates the code on the basis of the `SHOW_DEBUG_MESSAGES`
    define, which applies project-wide to all source files. The question that then
    remains is how is the define set. To set the global define, navigate to **Edit**
    | **Project Settings** | **Player** from the application menu. Then, enter the
    define name in the **Scripting Define Symbols** field, making sure that you press
    the *Enter* key after entering the name to confirm the change, as shown in the
    following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '第 09-12 行使用预处理指令 `#if` 和 `#endif` 进行条件功能。这个条件不是在运行时像常规的 `if` 语句那样执行，而是在编译时执行。在编译时，Unity
    将决定全局定义 `SHOW_DEBUG_MESSAGES` 是否指定或激活。如果，并且只有当它是激活的，那么第 10 和 11 行将被编译，否则编译器将忽略这些行，将它们视为注释。使用这个功能，你可以将所有调试代码隔离在检查调试定义的
    `#if #endif` 块内，并根据 `SHOW_DEBUG_MESSAGES` 定义激活和停用代码，该定义适用于项目范围内的所有源文件。那么剩下的问题是定义是如何设置的。要设置全局定义，从应用程序菜单导航到**编辑**
    | **项目设置** | **玩家**。然后，在**脚本定义符号**字段中输入定义名称，确保在输入名称后按*Enter*键确认更改，如图所示：'
- en: '![Overriding the ToString method](img/0655OT_02_06.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖ToString方法](img/0655OT_02_06.jpg)'
- en: Adding global custom defines from the Unity Editor, which lets you conditionally
    compile code
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unity 编辑器添加全局自定义定义，这允许你条件编译代码
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Removing defines and adding multiple defines**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**移除定义并添加多个定义**'
- en: Simply entering the name of your global define in the **Scripting Define Symbols**
    field is enough for it to take effect and apply across your code. You can delete
    the name to remove the define, but you can also prefix the name with `/` (for
    example, `/SHOW_DEBUG_MESSAGE`) to disable the define, thus making it easier to
    re-enable it later. You can also add multiple defines, separating each with the
    semicolon symbol (for example, `DEFINE1;DEFINE2;DEFINE3…`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在**脚本定义符号**字段中输入你的全局定义名称即可使其生效并应用于你的代码。你可以删除名称来移除定义，但也可以在名称前加上斜杠 `/`（例如，`/SHOW_DEBUG_MESSAGE`）来禁用定义，这样就可以更容易地稍后重新启用它。你还可以添加多个定义，每个定义之间用分号符号分隔（例如，`DEFINE1;DEFINE2;DEFINE3…`）。
- en: Visual debugging
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视调试
- en: Debugging with abstract or textual representations of data (such as `Debug.Log`)
    is often adequate but not always optimal. Sometimes, a picture is worth a thousand
    words. So, for example, when coding the line-of-sight functionality for enemies
    and other characters that allow them to see the player and other objects whenever
    they come in range, it's useful to get a live and graphical representation of
    where the line of sight actually is in the viewport. This line of functionality
    is drawn in terms of lines or as a wireframe cube. Similarly, if an object is
    following a path, it'd be great to draw this path in the viewport that displays
    it as a colored line. The purpose of this is not to create visual aids that will
    really show in the final game but simply to ease the debugging process that lets
    us get a better idea of how the game is working. These kinds of helpers or gizmos
    are a part of visual debugging. Unity already provides us with many gizmos automatically,
    such as the wireframe bounding box for colliders and frustum for cameras. However,
    we also have the ability to create our own gizmos for our own objects. This section
    explores gizmos further.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据的抽象或文本表示（如 `Debug.Log`）进行调试通常足够，但并不总是最优的。有时，一张图片胜过千言万语。所以，例如，当为敌人和其他角色编写视线功能，允许他们在进入范围时看到玩家和其他对象时，获取视图中视线实际位置的实时和图形表示非常有用。这个功能是以线条或线框立方体的形式绘制的。同样，如果一个对象正在沿着路径移动，那么在视图中绘制这条路径并以彩色线条显示它将非常棒。这个目的不是为了创建最终游戏中真正显示的视觉辅助工具，而是为了简化调试过程，让我们更好地了解游戏的工作方式。这些类型的辅助工具或图示是可视调试的一部分。Unity
    已经为我们提供了许多自动的图示，例如碰撞体的线框边界框和摄像机的视锥体。然而，我们也有能力为我们自己的对象创建自己的图示。本节将进一步探讨图示。
- en: 'As mentioned earlier, many Unity objects, such as colliders, trigger volumes,
    NavMesh Agents, cameras, and lights, already offer their own visual aids and gizmos
    when they are selected. These are shown by default in the **Scene** viewport unless
    you switch them off or reduce their size to zero. So, if you''ve added a native
    Unity object and don''t see a gizmo in the **Scene** viewport, then be sure to
    check the **Gizmo** panel that is accessible from the **Scene** toolbar via the
    **Gizmo** button. Enable all the gizmos you want to see and adjust the **Size**
    slider that increases or decreases the gizmo size (choose a size that is best
    for you), as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，许多Unity对象，如碰撞体、触发体积、NavMesh代理、摄像机和灯光，在选择时已经提供了自己的视觉辅助和Gizmo。除非您将其关闭或将其大小减小到零，否则这些默认显示在**场景**视图中。因此，如果您已添加了原生Unity对象但在**场景**视图中看不到Gizmo，请务必检查从**场景**工具栏通过**Gizmo**按钮可访问的**Gizmo**面板。启用您想要看到的所有Gizmo，并调整**大小**滑块以增加或减少Gizmo的大小（选择最适合您的大小），如图所示：
- en: '![Visual debugging](img/0655OT_02_07.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![视觉调试](img/0655OT_02_07.jpg)'
- en: Enabling gizmos in the Scene view
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景视图中启用Gizmo
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Gizmos in the Game tab**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏标签页中的Gizmo**'
- en: Gizmos don't show by default in the **Game** tab. You can, however, change this
    behavior easily using the **Gizmo** button in the top-right corner of the **Game**
    tab toolbar. This menu works just like the **Gizmos** menu for the **Scene** tab,
    as shown in the preceding screenshot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Gizmos默认不会在**游戏**标签页中显示。然而，您可以通过**游戏**标签页工具栏右上角的**Gizmo**按钮轻松更改此行为。此菜单的工作方式与**场景**标签页的**Gizmo**菜单类似，如前一张截图所示。
- en: 'Consider the following code sample 2-6\. This is a sample class that can be
    attached to an object and it relies on the Unity gizmo class to draw a custom
    range of helper gizmos. More information can be found online at [http://docs.unity3d.com/ScriptReference/Gizmos.html](http://docs.unity3d.com/ScriptReference/Gizmos.html).
    Here, this sample class draws a bounding wireframe sphere of a specified radius
    centered on the object that represents its range of attack. In addition, it draws
    a line-of-sight vector that represents the object''s forward direction, providing
    a visual indication of the way the object is facing. All of these gizmos are drawn
    inside the `OnDrawGizmos` event of `MonoBehaviour` on the condition that the variable
    `DrawGizmos` is `true`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例2-6。这是一个可以附加到对象上的示例类，它依赖于Unity的Gizmo类来绘制自定义范围的辅助Gizmo。更多信息可以在网上找到，请参阅[http://docs.unity3d.com/ScriptReference/Gizmos.html](http://docs.unity3d.com/ScriptReference/Gizmos.html)。在此示例中，这个类绘制了一个以指定半径为中心的边界线框球体，代表对象的攻击范围。此外，它还绘制了一条视线向量，代表对象的正面方向，提供了对象朝向的视觉指示。所有这些Gizmo都是在`MonoBehaviour`的`OnDrawGizmos`事件中绘制的，条件是变量`DrawGizmos`为`true`：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows how to draw gizmos that helps with debugging:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何绘制帮助调试的Gizmo：
- en: '![Visual debugging](img/0655OT_02_08.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![视觉调试](img/0655OT_02_08.jpg)'
- en: Drawing gizmos
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制Gizmo
- en: Error logging
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误日志
- en: 'When you compile and build your game to distribute to testers, whether they''re
    collected together in an office or scattered across the globe, you''ll need a
    way to record errors and exceptions as and when they happen during gameplay. One
    way to do this is through logfiles. Logfiles are human-readable text files that
    are generated on the local computer by the game at runtime, and they record the
    details of errors as they occur, if any occur at all. The amount of information
    you record is a matter for careful consideration, as logging too much detail can
    obfuscate the file and too little can render the file useless. However, once a
    balance is reached the tester will be able to send you the log for inspection,
    and this will, hopefully, allow you to quickly pin-point errors in your code and
    repair them effectively, that is without introducing new errors! There are many
    ways to implement logging behavior in Unity. One way is using the native `Application`
    class to receive exception notifications by way of delegates. Consider the following
    code sample 2-7:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并构建游戏以分发给测试人员时，无论他们是在办公室集中还是分布在全球各地，你都需要一种方法来记录游戏过程中发生的错误和异常。一种方法是通过日志文件。日志文件是由游戏在本地计算机上运行时生成的人类可读文本文件，它们记录了错误发生的详细信息，如果发生的话。你记录的信息量是一个需要仔细考虑的问题，因为记录过多的细节可能会使文件变得难以理解，而记录过少则可能使文件无用。然而，一旦达到平衡，测试人员就可以将日志发送给你进行检查，这有望让你能够快速定位代码中的错误并有效地修复它们，也就是说，不会引入新的错误！在Unity中实现日志行为有许多方法。一种方法是通过使用本地的`Application`类通过委托接收异常通知。考虑以下代码示例2-7：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following are the comments for code sample 2-7:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例2-7的注释：
- en: '**Line 22**: A new `StreamWriter` object is created to write debug strings
    to a file on the computer. The file is created inside `Application.persistentDataPath`;
    this points to a system location that is always writable.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第22行**：创建一个新的`StreamWriter`对象，用于将调试字符串写入计算机上的文件。该文件位于`Application.persistentDataPath`内部；这指向一个始终可写的系统位置。'
- en: '**Line 30**: The `Application.RegisterLogCallBack` method is invoked with a
    function reference to `HandleLog` as an argument. This relies on delegates. In
    short, a reference to the `HandleLog` function is passed, and this will be called
    when an error or exception occurs that allows us to write details to a logfile.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第30行**：使用函数引用`HandleLog`作为参数调用`Application.RegisterLogCallBack`方法。这依赖于委托。简而言之，传递了`HandleLog`函数的引用，当发生错误或异常时，这个引用将被调用，允许我们将详细信息写入日志文件。'
- en: '**Line 45**: The `WriteLine` method of `StreamWriter` is called to print textual
    data to the logfile when an error occurs. The error information is provided by
    Unity through the `HandleLog` arguments: `logString`, `stackTrace`, and `LogType`.
    The `StreamWriter` class is part of the Mono Framework, which is an open source
    implementation of the Microsoft NET Framework. More information on `StreamWriter`
    can be found at [http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第45行**：当发生错误时，调用`StreamWriter`的`WriteLine`方法将文本数据打印到日志文件。错误信息由Unity通过`HandleLog`参数提供：`logString`、`stackTrace`和`LogType`。`StreamWriter`类是Mono
    Framework的一部分，Mono Framework是Microsoft .NET Framework的开源实现。有关`StreamWriter`的更多信息，请参阅[http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx)。'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One of the quickest ways to test out your error logger is to create a divide
    by zero error. Don't forget to insert a `Debug.Log (Application.persistentDataPath);`
    line somewhere in your code to print the logfile path to the **Console** window.
    This can help you quickly find the logfile on your system via Windows Explorer
    or Mac Finder. Note that the `persistentDataPath` variable is used as opposed
    to an absolute path, because it varies from operating system to operating system.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试错误记录器的一种快速方法就是创建一个除以零的错误。别忘了在代码中某处插入一行`Debug.Log (Application.persistentDataPath);`，以便将日志文件路径打印到**控制台**窗口。这可以帮助你通过Windows资源管理器或Mac查找器快速找到系统中的日志文件。请注意，使用的是`persistentDataPath`变量而不是绝对路径，因为它们在不同的操作系统之间是不同的。
- en: 'The following screenshot shows how to print errors to a text-based logfile:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何将错误打印到基于文本的日志文件：
- en: '![Error logging](img/0655OT_02_09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![错误记录](img/0655OT_02_09.jpg)'
- en: Printing errors to a text-based logfile can make debugging and bug fixing easier
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误打印到基于文本的日志文件可以使调试和错误修复更容易
- en: 'What are delegates in C#? Imagine that you''re able to create a variable and
    assign it a function reference instead of a regular value. Having done this, you
    can invoke the variable just like a function to call the referenced function at
    a later time. You can even reassign the variable to reference a new and different
    function later. This, in essence, is how delegates work. If you''re familiar with
    C++, delegates are practically equivalent to the function pointers. Thus, delegates
    are special types that can reference and invoke functions. They''re ideal to create
    extensible callback systems and event notifications. For example, by keeping a
    list or array of delegate types, potentially, many different classes can register
    themselves as listeners for callbacks by adding themselves to the list. More information
    on C# can be found at [http://msdn.microsoft.com/en-gb/library/ms173171.aspx](http://msdn.microsoft.com/en-gb/library/ms173171.aspx).
    Consider the following code sample 2-8 for an example of the delegate usage in
    C# with Unity:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的委托是什么？想象一下，你能够创建一个变量并将其分配一个函数引用而不是一个常规值。完成此操作后，你可以像调用函数一样调用该变量，在稍后时间调用引用的函数。你甚至可以在以后重新分配变量以引用新的不同函数。本质上，这就是委托的工作方式。如果你熟悉C++，委托实际上与函数指针相当。因此，委托是特殊类型，可以引用和调用函数。它们非常适合创建可扩展的回调系统和事件通知。例如，通过保持委托类型的列表或数组，许多不同的类可以通过将自己添加到列表中作为回调的监听器来注册自己。有关C#的更多信息，请参阅[http://msdn.microsoft.com/en-gb/library/ms173171.aspx](http://msdn.microsoft.com/en-gb/library/ms173171.aspx)。以下代码示例2-8展示了在Unity中C#委托使用的一个例子：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Editor debugging
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器调试
- en: 'It''s sometimes claimed that Unity has no debugging tools built into the editor,
    but this is not quite true. With Unity, you can play your game and edit the scene
    at the same time while the game is running. You can even observe and edit properties
    in the Object Inspector, both private and public, as we saw earlier. This can
    give you a complete and graphical picture of your game at runtime; and allow you
    to detect and observe a wide range of potential errors. This form of debugging
    should not be underestimated. To get the most from in-editor debugging, activate
    the **Debug** mode from the Object Inspector by clicking on the context menu icon
    in the top-right corner of the inspector and then choose **Debug** from the menu,
    as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候人们声称Unity编辑器没有内置的调试工具，但这并不完全正确。使用Unity，你可以在游戏运行时同时播放游戏和编辑场景。你甚至可以观察和编辑对象检查器中的属性，无论是私有的还是公共的，就像我们之前看到的。这可以给你一个关于游戏运行时的完整和图形化的视图；并允许你检测和观察广泛潜在的错误。这种调试形式不应被低估。要充分利用编辑器中的调试，请通过点击检查器右上角的上下文菜单图标，从对象检查器激活**调试**模式，然后从菜单中选择**调试**，如图所示：
- en: '![Editor debugging](img/0655OT_02_10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器调试](img/0655OT_02_10.jpg)'
- en: Accessing the Debug mode from the Object Inspector
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象检查器访问调试模式
- en: Next, make sure that your viewports are configured appropriately so that they
    allow you to see both the **Scene** and **Game** views simultaneously during the
    **Play** mode, along with the **Stats** panel. To achieve this, disable the **Maximize
    on Play** button from the **Game** tab toolbar if it's activated. Then, arrange
    the **Scene** and **Game** tabs side-by-side in the interface, or else arrange
    them across multiple monitors if you have more than one. Multiple monitors are
    strongly recommended if your budget allows, but a single monitor can work well
    too, provided you invest extra time arranging and sizing each window to best meet
    your needs. In addition, you'll generally want the **Console** window visible
    and the **Project** panel hidden to prevent accidental selection and movement
    of assets, as shown in the following screenshot. Remember that you can also customize
    the Unity GUI Layout. For more information see [http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html](http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保你的视口配置得当，以便在**播放**模式下同时看到**场景**和**游戏**视图，以及**统计**面板。为了实现这一点，如果**游戏**选项卡工具栏中的**最大化播放**按钮被激活，请将其禁用。然后，在界面中将**场景**和**游戏**选项卡并排排列，或者如果你有多个显示器，可以将它们跨多个显示器排列。如果你的预算允许，强烈建议使用多个显示器，但单个显示器也可以很好地工作，只要你投入额外的时间来调整和调整每个窗口的大小，以最好地满足你的需求。此外，你通常希望**控制台**窗口可见，而**项目**面板隐藏，以防止意外选择和移动资源，如下面的截图所示。记住，你还可以自定义Unity
    GUI布局。更多信息请参阅[http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html](http://docs.unity3d.com/Manual/CustomizingYourWorkspace.html)。
- en: '![Editor debugging](img/0655OT_02_11.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器调试](img/0655OT_02_11.jpg)'
- en: Debugging games from the editor using a single monitor layout
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单显示器布局从编辑器调试游戏
- en: Once you're ready for in-editor debugging, click on the play button on the toolbar
    and use pause if you ever need to stop game events to inspect a specific object
    and its values from the Object Inspector. Remember that you can still use the
    transform (position, rotation, and scale) tools in-game to reposition the player
    or enemies, thus trying out new values and seeing which ones work and which ones
    do not. Most importantly, however, all edits to the scene in the **Game** mode,
    via the Object Inspector or transform tools, are temporary and will revert back
    after the **Play** mode ends. For this reason, if you need to make permanent changes
    to settings, then you would need to make them in the **Edit** mode. You can, of
    course, copy and paste values between the **Play** and **Edit** modes using the
    **Component** context menu at any time, as shown in the following screenshot.
    Remember that the hot key (*Ctrl* + *P*) toggles between the **Play** mode and
    (*Ctrl* + *Shift* + *P* between paused and unpaused). A full list of Unity hot
    keys is listed at [http://docs.unity3d.com/Manual/UnityHotkeys.html](http://docs.unity3d.com/Manual/UnityHotkeys.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好在编辑器中进行调试，点击工具栏上的播放按钮，如果你需要停止游戏事件来检查特定对象及其值，可以使用暂停。记住，你仍然可以在游戏中使用变换（位置、旋转和缩放）工具来重新定位玩家或敌人，从而尝试新的值并查看哪些有效，哪些无效。然而，最重要的是，在**游戏**模式下通过对象检查器或变换工具对场景的所有编辑都是临时的，并在**播放**模式结束后恢复。因此，如果你需要永久更改设置，那么你需要在**编辑**模式中做出更改。当然，你可以随时使用**组件**上下文菜单在**播放**和**编辑**模式之间复制和粘贴值，如下面的截图所示。记住，快捷键(*Ctrl*
    + *P*)在**播放**模式之间切换，(*Ctrl* + *Shift* + *P*)在暂停和未暂停之间切换。Unity的完整快捷键列表可以在[http://docs.unity3d.com/Manual/UnityHotkeys.html](http://docs.unity3d.com/Manual/UnityHotkeys.html)找到。
- en: '![Editor debugging](img/0655OT_02_12.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器调试](img/0655OT_02_12.jpg)'
- en: Copying and pasting component values via the Component context menu
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组件上下文菜单复制和粘贴组件值
- en: Using the profiler
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用性能分析器
- en: One additional tool that's used partly for debugging and partly for optimization
    is the **Profiler** window, which is available only in Unity Pro by clicking on
    the **Profiler** tab in **Window** in the application menu, as shown in the following
    screenshot. In short, the profiler gives you a statistical top-down view of how
    time and workload is distributed across the different parts of your game and across
    system hardware components, such as the CPU and graphics card. Using profiler,
    you can determine, for example, how much time is consumed by camera rendering
    in the scene compared to physics calculations or to audio functionality, as well
    as to other categories. It lets you measure performance, compare numbers, and
    assess where performance can be improved. The profiler is not really a tool that
    alerts you to the presence of bugs in your code specifically. However, if you're
    experiencing performance problems in running the game, such as lags and freezes,
    then it could guide you to where optimizations can be made. For this reason, the
    profiler is a tool to which you'll turn if you decide that performance is an issue
    for your game and you need an educated, studied analysis of where to start implementing
    improvements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个部分用于调试和部分用于优化的额外工具是**性能分析器**窗口，它仅在Unity Pro中通过在应用程序菜单的**窗口**中点击**性能分析器**选项卡来访问，如下面的截图所示。简而言之，性能分析器为你提供了一个从上到下的统计视图，展示了时间和工作负载如何在游戏的各个部分以及系统硬件组件（如CPU和显卡）之间分布。使用性能分析器，你可以确定，例如，场景中相机渲染所消耗的时间与物理计算或音频功能相比，以及与其他类别相比。它让你能够测量性能，比较数字，并评估性能可以改进的地方。性能分析器并不是一个专门提醒你代码中存在错误的具体工具。然而，如果你在运行游戏时遇到性能问题，如卡顿和冻结，那么它可能能引导你找到可以进行优化的地方。因此，如果你决定性能是你的游戏问题，并且需要经过教育、研究分析的改进起点，性能分析器是一个你会转向的工具。
- en: '![Using the profiler](img/0655OT_02_13.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用性能分析器](img/0655OT_02_13.jpg)'
- en: The profiler is typically used to diagnose performance issues
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器通常用于诊断性能问题
- en: 'When you run your game with the **Profiler** window open, the graph will populate
    with statistics about the most recent frames. The profiler doesn''t usually record
    information about all the frames since the game began, but only the most recent
    ones as will fit into memory sensibly. There is a toggleable "deep profile" method
    available in the upper toolbar of the **Profiler** window, which allows you (in
    theory) to get extra information about your game, but I''d recommend that you
    avoid this mode. It can cause performance issues with the Unity Editor when running
    asset-heavy and code-heavy games, and it can even freeze the editor altogether.
    Instead, I''d recommend that you only use the default mode. When using this mode,
    in most cases, you''ll want to disable the visualization of **VSync** from the
    **CPU Usage** area to get a better view of other performance statistics, including
    **Rendering** and **Scripts**, as shown in the following screenshot. To do this,
    simply click on the **VSync** icon in the graph index area:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用打开的**Profiler**窗口运行游戏时，图表会填充关于最近帧的统计数据。性能分析器通常不会记录自游戏开始以来的所有帧的信息，而只记录最近的一些帧，这些帧可以合理地放入内存中。在**Profiler**窗口的上部工具栏中有一个可切换的“深度分析”方法，理论上它允许你获取关于游戏的额外信息，但我建议你避免使用此模式。它可能会在运行资源密集型和代码密集型游戏时导致Unity编辑器的性能问题，甚至可能完全冻结编辑器。相反，我建议你只使用默认模式。当使用此模式时，在大多数情况下，你可能会想要从**CPU
    Usage**区域禁用**VSync**的可视化，以获得更好的其他性能统计信息视图，包括**Rendering**和**Scripts**，如下面的截图所示。为此，只需在图表索引区域单击**VSync**图标：
- en: '![Using the profiler](img/0655OT_02_14.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用性能分析器](img/0655OT_02_14.jpg)'
- en: Disabling the VSync display from the CPU usage area in the Profiler window
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Profiler窗口的CPU使用区域禁用VSync显示
- en: 'The horizontal axis of the graph represents frames—the most recent frames added
    to the memory buffer. This axis keeps populating with new data while the game
    is running. The vertical axis represents time or computational expense: higher
    values are expressive of a more demanding and slower frame time. After the graph
    is filled with some data during the **Play** mode, you can pause the game to examine
    its state. Select the frames from the graph to view more information on game performance
    during that frame. When you do this, the **Hierarchy** panel in the bottom half
    of the **Profile** window fills with function data about the code that is being
    executed on the selected frame. When viewing the graph, it''s good practice to
    watch for sudden increases (peaks or spikes), as shown in the following screenshot.
    These indicate frames of sudden and intense activity. Sometimes, they can be one-off
    occurrences that are either unavoidable due to hardware operations or that happen
    legitimately and are not the source of performance problems, such as scene transitions
    or loading screens.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的横轴代表帧——最近添加到内存缓冲区的帧。当游戏运行时，这个轴会持续填充新的数据。纵轴代表时间或计算开销：更高的值表示更苛刻且更慢的帧时间。在**播放**模式下，当图表填充了一些数据后，你可以暂停游戏来检查其状态。从图表中选择帧以查看该帧的游戏性能的更多信息。当你这样做时，**Profile**窗口下半部分的**Hierarchy**面板会填充关于在选定帧上执行的代码的功能数据。在查看图表时，注意观察突然的增加（峰值或尖峰），如下面的截图所示。这些表示突然且强烈的活动帧。有时，它们可能是由于硬件操作而无法避免的一次性事件，或者它们是合法发生的，并不是性能问题的来源，例如场景转换或加载界面。
- en: However, they can indicate trouble too, especially if they happen regularly.
    So, when diagnosing performance issues, looking for spikes is a good place to
    start your investigation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们也可能表示问题，尤其是如果它们经常发生。因此，在诊断性能问题时，寻找峰值是一个好的开始。
- en: '![Using the profiler](img/0655OT_02_15.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![使用性能分析器](img/0655OT_02_15.jpg)'
- en: Selecting a frame from the profiler graph
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能分析器图表中选择帧
- en: 'The **Hierarchy** view lists all the main functions and events in code that
    executes on the selected frame. For each function, there are several crucial properties
    such as **Total**, **Self**, **Time ms**, and **Self ms**, which are shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hierarchy**视图列出了在选定帧上执行的代码中的所有主要函数和事件。对于每个函数，都有几个关键属性，如**Total**、**Self**、**Time
    ms**和**Self ms**，如下所示：'
- en: '![Using the profiler](img/0655OT_02_16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用性能分析器](img/0655OT_02_16.jpg)'
- en: Examining function calls during selected frames
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 检查选定帧中的函数调用
- en: 'Let'' s discuss these crucial properties in more detail:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这些关键属性：
- en: '**Total and Time ms**: The **Total** column represents the proportion of frame
    time consumed by the function. The value of **49.1%**, for example, means that
    49.1 percent of the total time required for the selected frame was consumed by
    the function, including any time taken to call subfunctions (functions called
    within the function). The **Time ms** column expresses the frame consumption time
    in absolute terms, measured in milliseconds. Together, these two values give you
    both a relative and absolute measure of how expensive calling the function is
    on each frame and in total.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Total 和 Time ms**: **Total** 列表示函数消耗的帧时间的比例。例如，**49.1%** 的值意味着所选帧所需的总时间的
    49.1% 被函数消耗，包括调用子函数（函数内部调用的函数）所花费的时间。**Time ms** 列以绝对值表达帧消耗时间，以毫秒为单位。这两个值共同提供了对在每一帧和总体上调用函数代价的相对和绝对度量。'
- en: '**Self and Self ms**: The **Total** and **Total ms** settings measure the expense
    of the function for the selected frame, but they include the total time spent
    inside other functions that were invoked from within the function. Both **Self**
    and **Self ms** exclude this time and express only the total time spent within
    the function, minus any additional time waiting for other functions to complete.
    These values are often the most important when seeking to pinpoint a specific
    function that causes performance problems.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Self 和 Self ms**: **Total** 和 **Total ms** 设置衡量所选帧中函数的消耗，但它们包括从函数内部调用的其他函数所花费的总时间。**Self**
    和 **Self ms** 排除这部分时间，仅表达函数内部所花费的总时间，减去等待其他函数完成的多余时间。这些值在试图确定导致性能问题的特定函数时通常是最重要的。'
- en: More information on the Unity Profiler can be found at [http://docs.unity3d.com/Manual/ProfilerWindow.html](http://docs.unity3d.com/Manual/ProfilerWindow.html).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Unity Profiler 的信息可以在 [http://docs.unity3d.com/Manual/ProfilerWindow.html](http://docs.unity3d.com/Manual/ProfilerWindow.html)
    找到。
- en: Debugging with MonoDevelop – getting started
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MonoDevelop 进行调试 – 入门
- en: Earlier, we encountered the `Debug.Log` method of debugging to print helper
    messages to the console at critical moments in the code to help us see how the
    program executes. This method, while functional, however, suffers some significant
    drawbacks. First off, when writing larger programs with many `Debug.Log` statements
    it's easy to effectively "spam" the console with excessive messages. This makes
    it difficult to differentiate between the ones you need and the ones you don't.
    Second, it's generally a bad practice to change your code by inserting the `Debug.Log`
    statements simply to monitor program flow and find errors. Ideally, we should
    be able to debug without changing our code. Therefore, we have compelling reasons
    to find alternative ways to debug. MonoDevelop can help us here. Specifically,
    in the latest releases of Unity, MonoDevelop can natively attach itself to a running
    Unity process. In doing this, we get access to a range of common debugging tools,
    the kind encountered when developing other types of software, such as breakpoints
    and traces. Presently, the connectivity between MonoDevelop and Unity can be buggy
    however, for some users on some systems. However, when working as intended, MonoDevelop
    can offer a rich and useful debugging experience that allows us to move beyond
    simply writing the `Debug.Log` statements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们遇到了调试的 `Debug.Log` 方法，在代码的关键时刻打印辅助消息到控制台，以帮助我们了解程序的执行情况。然而，这种方法虽然有效，但存在一些显著的缺点。首先，当编写包含许多
    `Debug.Log` 语句的大型程序时，很容易有效地“垃圾邮件”控制台，导致难以区分所需的和不必要的消息。其次，通过插入 `Debug.Log` 语句来更改代码以监控程序流程和查找错误通常是一种不良的做法。理想情况下，我们应该能够在不更改代码的情况下进行调试。因此，我们有许多理由去寻找替代的调试方法。MonoDevelop
    可以在这里帮助我们。具体来说，在 Unity 的最新版本中，MonoDevelop 可以原生地附加到正在运行的 Unity 进程。通过这样做，我们可以访问一系列常见的调试工具，就像在开发其他类型的软件时遇到的那样，例如断点和跟踪。然而，目前
    MonoDevelop 和 Unity 之间的连接可能存在一些问题，对于某些系统上的某些用户来说。但是，当按预期工作的时候，MonoDevelop 可以提供丰富且有用的调试体验，使我们能够超越仅仅编写
    `Debug.Log` 语句的简单方法。
- en: 'To start debugging with MonoDevelop, let''s consider breakpoints. When debugging
    code, you''ll likely need to observe the program flow when it reaches a specified
    line. A breakpoint lets you mark one or more lines in a source file from MonoDevelop,
    and when the program runs in Unity, its execution will pause at the first breakpoint.
    At this pause, you get the opportunity to examine the code and the status of variables
    as well as to inspect and edit their values. You can also continue execution with
    stepping. This lets you push execution forward to the next line, following the
    normal program logic line-by-line. You get the opportunity of inspecting your
    code in each line as it passes. Let''s see an example case. The following code
    sample 2-9 shows a simple script file. When attached to an object, it retrieves
    a list of all objects in the scene (including itself) and then sets their position
    to the world origin (0, 0, 0) when the **Start** function is executed, which occurs
    at level startup:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MonoDevelop开始调试，让我们考虑断点。在调试代码时，您可能会需要观察程序在到达指定行时的流程。断点允许您在MonoDevelop中标记源文件中的一行或多行，当程序在Unity中运行时，其执行将在第一个断点处暂停。在此暂停时，您有机会检查代码和变量的状态，以及检查和编辑它们的值。您还可以通过单步执行继续执行。这允许您按正常程序逻辑逐行推进执行。您有机会在代码经过每一行时检查它。让我们看一个示例案例。以下代码示例2-9显示了一个简单的脚本文件。当附加到对象时，它会检索场景中所有对象（包括自身）的列表，然后在**Start**函数执行时将它们的位置设置为世界原点（0,
    0, 0），该函数在关卡启动时发生：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s set a breakpoint in the highlighted line via MonoDevelop. This will
    pause the program execution whenever it reaches this line. To set the breakpoint,
    position your mouse cursor on the highlighted line, right-click on the left-hand
    gray margin, and choose **New Breakpoint**. Otherwise, use the MonoDevelop application
    menu to choose the **New Breakpoint** option in **Run**, or you can also press
    the *F9* key (or you can left-click on the line number), as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在高亮行上设置一个断点，通过MonoDevelop。当程序执行到达此行时，它将暂停。要设置断点，将鼠标光标置于高亮行上，在左侧灰色边缘处右键单击，并选择**新断点**。否则，可以使用MonoDevelop应用程序菜单在**运行**中选择**新断点**选项，或者您也可以按*F9*键（或者您也可以左键单击行号），如图所示：
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_17.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 入门](img/0655OT_02_17.jpg)'
- en: Creating a new breakpoint in MonoDevelop
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建新的断点
- en: 'The breakpoint line will be highlighted in red. To get this breakpoint to work
    properly with Unity when the game runs, you''ll need to attach MonoDevelop to
    the running Unity process. To do this, make sure that the Unity Editor is running
    alongside MonoDevelop and then choose the **Attach to Process** option from **Run**
    from the MonoDevelop application menu, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 断点行将以红色突出显示。为了使断点在游戏运行时与Unity正常工作，您需要将MonoDevelop附加到正在运行的Unity进程。为此，请确保Unity编辑器与MonoDevelop同时运行，然后从MonoDevelop应用程序菜单中选择**附加到进程**选项，如以下截图所示：
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_18.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 入门](img/0655OT_02_18.jpg)'
- en: Attach to Process
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到进程
- en: 'The **Attach to Process** dialog appears, and the **Unity Editor** should be
    listed as **Process Name** to which MonoDevelop can be attached. The **Debugger**
    drop-down list in the bottom-left corner of the window should be specified as
    **Unity Debugger**. Select the **Unity Editor** option and then choose the **Attach**
    button, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加到进程**对话框出现，**Unity Editor**应列在**进程名称**中，MonoDevelop可以附加到该进程。窗口左下角的**调试器**下拉列表应指定为**Unity
    Debugger**。选择**Unity Editor**选项，然后选择**附加**按钮，如图所示：'
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_19.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 入门](img/0655OT_02_19.jpg)'
- en: Select Unity Editor from the Attach to Process dialog
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从**附加到进程**对话框中选择Unity编辑器
- en: When MonoDevelop is attached to Unity as a process, two new bottom-aligned panes
    will dock themselves to the MonoDevelop interface, and these include the **Watch**
    window and the **Immediate** window, as shown in the following screenshot. These
    windows offer additional debugging information and views when your game runs in
    the Unity Editor, as we'll see in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当MonoDevelop作为进程附加到Unity时，两个新的底部对齐的面板将自动停靠到MonoDevelop界面中，这些面板包括**监视**窗口和**立即**窗口，如以下截图所示。当您的游戏在Unity编辑器中运行时，这些窗口提供了额外的调试信息和视图，我们将在下一节中看到。
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_20.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 入门](img/0655OT_02_20.jpg)'
- en: Two new panes dock themselves to MonoDevelop when attaching to a Unity process
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加到 Unity 进程时，两个新的面板会自动停靠到 MonoDevelop 中
- en: 'Next, return to the Unity Editor and make sure that the script file `DebugTest.cs`,
    as shown in code sample 2-9, is attached to an object in the scene and that the
    scene includes other objects (any objects, such as cubes or cylinders). Then,
    run your game using the play button from the Unity toolbar, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回到 Unity 编辑器，并确保脚本文件 `DebugTest.cs`（如代码示例 2-9 所示）已附加到场景中的对象上，并且场景中包含其他对象（任何对象，例如立方体或圆柱体）。然后，使用
    Unity 工具栏中的播放按钮运行您的游戏，如图所示：
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_21.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 调试 – 入门](img/0655OT_02_21.jpg)'
- en: Running from the Unity Editor in preparation for debugging with MonoDevelop
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unity 编辑器运行以准备使用 MonoDevelop 调试
- en: When you press the play button on the Unity toolbar with MonoDevelop attached,
    the execution of Unity will freeze when the breakpoint is reached (the break mode).
    The focus will switch to the MonoDevelop window with the breakpoint line highlighted
    in yellow inside the source file that indicates the current step of execution,
    as shown in the following screenshot. During this mode, you cannot use the Unity
    Editor, and you cannot switch between viewports or even edit settings inside the
    Object Inspector as you can with in-editor debugging. MonoDevelop is waiting exclusively
    for your input to resume execution. The next few sections will consider some useful
    debugging tools that you can use in the break mode.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在附加 MonoDevelop 时按下 Unity 工具栏上的播放按钮，当达到断点时（断点模式），Unity 的执行将暂停。焦点将切换到带有断点行（在源文件中用黄色突出显示）的
    MonoDevelop 窗口，该行指示当前的执行步骤，如图以下截图所示。在此模式下，您不能使用 Unity 编辑器，并且您不能在视图中切换或甚至像在编辑器调试中那样在对象检查器内编辑设置。MonoDevelop
    正在等待您的输入以恢复执行。接下来的几节将考虑一些在断点模式下可用的有用调试工具。
- en: '![Debugging with MonoDevelop – getting started](img/0655OT_02_22.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 调试 – 入门](img/0655OT_02_22.jpg)'
- en: Entering the break mode from within MonoDevelop
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MonoDevelop 内进入断点模式
- en: Debugging with MonoDevelop – the Watch window
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MonoDevelop 调试 – 观察窗口
- en: A **Watch** window allows you to view the value of a variable that's active
    in memory in the current step, and this includes both local and global variables.
    One way to quickly add a watch for a variable while it is in the break mode is
    to highlight it in the code editor and then hover your mouse over it. When you
    do this, leaving the mouse hovered for a few seconds, a pop-up window appears
    automatically. This window allows the full inspection of a variable, as shown
    in the following screenshot. You can contract and expand the members of a class
    and examine the state of all its variables.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察**窗口允许您查看当前步骤中内存中活动的变量的值，这包括局部和全局变量。在断点模式下快速为变量添加监视的一种方法是在代码编辑器中突出显示它，然后将鼠标悬停在其上。当您这样做时，将鼠标悬停几秒钟，将自动出现一个弹出窗口。此窗口允许完全检查变量，如图以下截图所示。您可以收缩和展开类的成员，并检查所有变量的状态。'
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_23.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 调试 – 观察窗口](img/0655OT_02_23.jpg)'
- en: Inspecting a variable with hover watches in the break mode
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点模式下使用悬停监视检查变量
- en: 'You can inspect practically all variable values for any active object using
    this hover method. However, typically, you''ll want to place a more permanent
    watch on a variable and even a group of variables so that you can see their values
    collated together in a list. For this, you can use the **Watch** window docked
    in the bottom-left corner of the MonoDevelop interface. To add a new watch in
    this window, right-click inside the **Watch** list and choose **Add watch** from
    the context menu, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此悬停方法检查任何活动对象的几乎所有变量值。然而，通常，您可能希望在一个变量甚至一组变量上放置一个更持久的监视，以便您可以在列表中一起查看它们的值。为此，您可以使用位于
    MonoDevelop 界面左下角的**观察**窗口。要在该窗口中添加新的监视，请右键单击**观察**列表，然后从上下文菜单中选择**添加监视**，如图所示：
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_24.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 调试 – 观察窗口](img/0655OT_02_24.jpg)'
- en: Adding a watch to the Watch window
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向观察窗口添加监视
- en: On adding a new watch, you can enter any valid expression or variable name in
    the **Name** field, and the resultant value will be shown in the **Value** column,
    as shown in the following screenshot. The values shown in the **Watch** field
    are valid for the current line of execution only, and they will change as the
    program progresses. Remember that you can add a watch for any valid variable that
    can be referenced in the current scope, including `name`, `tag`, `transform.position`,
    and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新的观察时，您可以在**名称**字段中输入任何有效的表达式或变量名，结果值将在**值**列中显示，如下面的截图所示。在**观察**字段中显示的值仅适用于当前执行行，并且随着程序的进行而改变。请记住，您可以添加任何在当前作用域中可以引用的有效变量的观察，包括`name`、`tag`、`transform.position`等。
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_25.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 观察窗口](img/0655OT_02_25.jpg)'
- en: Adding a watch to the Watch window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察窗口中添加观察
- en: 'You can use the **Watch** window to examine any valid variables and expressions,
    whether they pertain to the active class or line of code. This means you can see
    the value for global variables and any variables related to other classes or objects,
    as long as they''re valid and in memory. However, if you''re only interested in
    viewing local variables, that is, variables whose scope is relevant to the block
    of code being executed in the current step, then you could use the **Locals**
    window instead of **Watch**. This window automatically adds watches for all the
    local variables. You don''t need to add them manually. Here, the **Locals** window
    is by default tabbed next to the **Watch** window:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**观察**窗口来检查任何有效的变量和表达式，无论它们是否与活动类或代码行相关。这意味着您可以看到全局变量的值以及与其它类或对象相关的任何变量，只要它们是有效的并且在内存中。然而，如果您只对查看局部变量感兴趣，即变量的作用域与当前步骤中正在执行的代码块相关，那么您可以使用**局部变量**窗口而不是**观察**窗口。此窗口会自动为所有局部变量添加观察。您不需要手动添加。在这里，**局部变量**窗口默认情况下位于**观察**窗口旁边：
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_26.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 观察窗口](img/0655OT_02_26.jpg)'
- en: Inspecting local variables only with the Locals window
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用**局部变量**窗口检查局部变量
- en: 'If you don''t see any of the relevant **Debug** windows in the MonoDevelop
    interface, such as the **Watch** window or the **Locals** window, you can show
    or hide them manually by clicking on the **Debug Windows** option in **View**
    from the MonoDevelop application menu:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在MonoDevelop界面中没有看到任何相关的**调试**窗口，例如**观察**窗口或**局部变量**窗口，您可以通过点击MonoDevelop应用程序菜单中的**视图**下的**调试窗口**选项来手动显示或隐藏它们：
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_27.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 观察窗口](img/0655OT_02_27.jpg)'
- en: 'One great thing about the **Watch** and **Locals** windows is that they offer
    read and write access to variables. This means that you''re not restricted to
    simply viewing variable values, but you can write to them as well, changing the
    variable from within MonoDevelop. To do this, simply double-click on the **Value**
    field from either the **Watch** or **Locals** window and then enter a new value
    for the variable:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察**和**局部变量**窗口的一个优点是它们提供了对变量的读写访问。这意味着您不仅限于查看变量值，还可以写入它们，在MonoDevelop内部更改变量。要这样做，只需从**观察**或**局部变量**窗口的双击**值**字段，然后为变量输入新值：'
- en: '![Debugging with MonoDevelop – the Watch window](img/0655OT_02_28.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 观察窗口](img/0655OT_02_28.jpg)'
- en: Editing values from the Watch window
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从观察窗口编辑值
- en: Debugging with MonoDevelop – continue and stepping
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MonoDevelop进行调试 – 继续和单步执行
- en: 'After reaching a breakpoint and inspecting your code, it''s likely that you''ll
    want to exit from the break mode and continue program execution in some way. You
    might want to continue program execution, which effectively hands program control
    back to Unity. This allows the execution to continue as normal, until it meets
    the next breakpoint, if any. This method effectively resumes execution as normal,
    and it''ll never pause again unless a new breakpoint is encountered. To continue
    in this way from MonoDevelop, press the *F5* key or press the play button from
    the MonoDevelop toolbar. Otherwise, choose the **Continue Debugging** option in
    **Run** from the MonoDevelop application menu, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到断点并检查你的代码后，你很可能会想要退出断点模式并以某种方式继续程序执行。你可能想继续程序执行，这实际上将程序控制权交还给 Unity。这允许执行继续正常进行，直到遇到下一个断点（如果有的话）。这种方法有效地以正常方式恢复执行，并且除非遇到新的断点，否则永远不会再次暂停。要从
    MonoDevelop 以这种方式继续，请按 *F5* 键或从 MonoDevelop 工具栏中按播放按钮。否则，从 MonoDevelop 应用程序菜单中选择
    **Run** 中的 **Continue Debugging** 选项，如图所示：
- en: '![Debugging with MonoDevelop – continue and stepping](img/0655OT_02_29.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 调试 – 继续和单步执行](img/0655OT_02_29.jpg)'
- en: Exiting the break mode and resuming with Continue Debugging
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 退出断点模式并使用继续调试恢复
- en: 'There are many occasions, however, where you don''t want to continue execution
    in this way. Instead, you want to step execution over the lines of code, line
    by line, evaluating each line as it progresses and examining the program flow
    to see how variables change and are affected by statements. The step mode effectively
    lets you observe the program flow as it happens. There are three main kinds of
    steps in debugging: step over, step into, and step out. Step over instructs the
    debugger to move to the next line of code and then to pause again, awaiting your
    inspection as though the next line were a new breakpoint. If an external function
    call is encountered in the next line, the debugger would invoke the function as
    usual and then step to the next line without stepping into the function. In this
    way, the function is "stepped over". The function still happens, but it happens
    in the continue mode, and the next step or breakpoint is set in the next line
    after the function. To step over, press *F10*, choose the **Step Over** command
    in **Run** from the application menu, or press the **Step Over** button in the
    MonoDevelop toolbar, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多情况下，你不想以这种方式继续执行。相反，你希望逐行执行代码，逐行评估每行，并检查程序流程以查看变量如何变化以及受语句的影响。单步执行模式有效地让你观察程序流程的实时情况。在调试中主要有三种单步执行方式：单步执行、进入和退出。单步执行指示调试器移动到下一行代码，然后再次暂停，等待你的检查，就像下一行是一个新的断点一样。如果在下一行遇到外部函数调用，调试器会像往常一样调用该函数，然后跳到下一行而不进入函数。这样，函数就是“单步执行”的。函数仍然会发生，但它在继续模式下发生，并且下一个步骤或断点设置在函数之后的下一行。要单步执行，请按
    *F10*，从应用程序菜单中选择 **Run** 中的 **Step Over** 命令，或按 MonoDevelop 工具栏中的 **Step Over**
    按钮，如图所示：
- en: '![Debugging with MonoDevelop – continue and stepping](img/0655OT_02_30.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 调试 – 继续和单步执行](img/0655OT_02_30.jpg)'
- en: Stepping over code moves execution to the next statement without stepping into
    an external function
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单步执行代码会将执行移动到下一语句，而不进入外部函数
- en: If an external function call is encountered, the **Step Into** (*F11*) command
    allows debugging to enter this function. This effectively sets the next breakpoint
    in the first line of the entered function that allows debugging to resume in the
    next step. This can be useful if you need to observe how many functions are working
    together. If, at any point, you want to exit the entered function by moving it
    forward in the continue mode, you could use the **Step Out** (*Shift* + *F11*)
    command, and the execution would resume in the next line in the outer function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到外部函数调用，**Step Into** (*F11*) 命令允许调试进入此函数。这实际上在进入函数的第一行设置了下一个断点，允许在下一个步骤中继续调试。如果你需要观察多少个函数协同工作，这可能会很有用。在任何时候，如果你想通过在继续模式下向前移动来退出进入的函数，可以使用
    **Step Out** (*Shift* + *F11*) 命令，并且执行将在外部函数的下一行继续。
- en: Debugging with MonoDevelop – call stack
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MonoDevelop 调试 – 调用堆栈
- en: 'More complex programs typically involve lots of functions and function calls.
    During execution, functions can invoke other functions, and these functions can
    go on to invoke yet more functions in an intricate chain of functions within functions.
    This means that when setting breakpoints inside functions, you can never know
    how the function was invoked initially when it''s actually called at runtime.
    The breakpoint tells you that program execution has reached the specified line,
    but it doesn''t tell you how execution arrived there in the first place. Sometimes,
    it might be easy to deduce, but at other times it can be much harder, especially
    when functions are invoked within loops, conditionals, and nested loops and conditionals.
    Consider the following code sample 2-10, which has been amended from the earlier
    code sample 2-9\. This class contains several functions that invoke other functions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的程序通常涉及大量的函数和函数调用。在执行过程中，函数可以调用其他函数，而这些函数可以继续在函数内部的复杂函数链中调用更多函数。这意味着当在函数内部设置断点时，您永远不知道函数在运行时实际调用时是如何被最初调用的。断点告诉您程序执行已到达指定的行，但它不会告诉您执行最初是如何到达那里的。有时，这可能很容易推断，但有时可能会困难得多，尤其是在函数在循环、条件语句和嵌套循环和条件语句中调用时。考虑以下代码示例2-10，它已被从早期的代码示例2-9中修改。这个类包含几个调用其他函数的函数：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a breakpoint is set in line 38 of code sample 2-10 (highlighted), execution
    will pause when this line is reached. By reading this sample, we can see that
    one route to that function is by the `Start` function calling `Func01`, `Func01`
    calling `Func02`, and then `Func02` finally calling `Func03`. But how do we know
    that this is the only route? It''s technically possible, for example, for another
    class and function elsewhere in the project to invoke `Func03` directly. So, how
    can we know the route by which we''ve reached this function in this step while
    debugging? Based on the tools examined so far, we can''t. However, we can use
    the **Call Stack** window. This window, displayed by default in the bottom-right
    corner of the MonoDevelop interface, lists all the function calls that were made
    to reach the active function for the current step that leads back to the first
    or initial function call. It gives us a breadcrumb trail of function names that
    leads from the active function to the first or initial function. Thus, **Call
    Stack** lists function names upside down, the active or most recent function being
    at the top of the stack that leads downwards to the earliest or first function
    at the bottom of the stack. You can also access the functions at their locations
    to assess the variables in their scope, as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码示例2-10的第38行设置了断点（已高亮显示），当执行到这一行时程序将暂停。通过阅读这个示例，我们可以看到到达该函数的一条路径是通过`Start`函数调用`Func01`，然后`Func01`调用`Func02`，最后`Func02`最终调用`Func03`。但是，我们如何知道这是唯一的路径呢？技术上，例如，项目中的另一个类和函数可以直接调用`Func03`。那么，在调试过程中，我们如何知道我们到达这个函数的路径呢？基于到目前为止检查的工具，我们无法知道。然而，我们可以使用**调用栈**窗口。这个窗口默认显示在MonoDevelop界面的右下角，列出了为达到当前步骤的激活函数而进行的所有函数调用，从而返回到第一个或初始函数调用。它为我们提供了一个从激活函数到第一个或初始函数的函数名称的面包屑路径。因此，**调用栈**以倒序列出函数名称，最活跃或最近的函数位于栈顶，向下延伸到栈底最早或第一个函数。您还可以访问这些函数的位置，以评估它们作用域内的变量，如下所示：
- en: '![Debugging with MonoDevelop – call stack](img/0655OT_02_31.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 调用栈](img/0655OT_02_31.jpg)'
- en: Using Call Stack to trace how a function was initiated during program execution
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调用栈追踪程序执行期间函数的启动过程
- en: Debugging with MonoDevelop – the Immediate window
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MonoDevelop进行调试 – 立即窗口
- en: 'For games, the **Immediate** window acts like the **Console** window, as found
    in many first-person shooter games such as *Unreal*, *Half Life*, or *Call of
    Duty*. The **Immediate** window is docked by default in the bottom-right corner
    of the MonoDevelop interface. It becomes active in the break mode. Using it, we
    can enter expressions and statements that are evaluated immediately as though
    they were part of the source code for this step. We can get and set the values
    for active variables as well as perform additional operations. We can write any
    valid expression, such as `2+2` and `10*5`. The result of these expressions is
    output in the next line in the **Immediate** window, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏，**即时**窗口类似于许多第一人称射击游戏（如*Unreal*、*Half Life*或*Call of Duty*）中的**控制台**窗口。**即时**窗口默认停靠在MonoDevelop界面的右下角。它在断点模式下变为活动状态。使用它，我们可以输入表达式和语句，它们将被立即评估，就像它们是此步骤的源代码的一部分一样。我们可以获取和设置活动变量的值，以及执行其他操作。我们可以编写任何有效的表达式，例如`2+2`和`10*5`。这些表达式的结果将在**即时**窗口的下一行输出，如图所示：
- en: '![Debugging with MonoDevelop – the Immediate window](img/0655OT_02_32.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 即时窗口](img/0655OT_02_32.jpg)'
- en: Evaluating expressions inside the Immediate window
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在即时窗口中评估表达式
- en: 'Of course, you''re not simply restricted to writing isolated statements that
    involve basic arithmetical operations, such as addition and subtraction. You can
    write full expressions that include active variables:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不仅限于编写涉及基本算术运算（如加法和减法）的孤立语句。你可以编写包含活动变量的完整表达式：
- en: '![Debugging with MonoDevelop – the Immediate window](img/0655OT_02_33.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 即时窗口](img/0655OT_02_33.jpg)'
- en: Writing more advanced expressions in the Immediate window
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在即时窗口中编写更高级的表达式
- en: Overall, the **Immediate** window is especially useful to test code, write alternative
    scenarios in the **Immediate** window, and see how they evaluate.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，**即时**窗口特别适用于测试代码，在**即时**窗口中编写替代场景，并查看它们的评估结果。
- en: Debugging with MonoDevelop – conditional breakpoints
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MonoDevelop进行调试 – 条件断点
- en: 'Breakpoints are critical for debugging, and represents the starting point at
    which application execution pauses into a debug state. Often, they''ll be just
    what you need to set a breakpoint and start debugging! However, there are times
    when breakpoints, in their default configuration, can become annoying. One example
    is when a breakpoint is set inside a loop. Sometimes, you only want the breakpoint
    to take effect or pause execution after a loop has exceeded a specified number
    of iterations, as opposed to taking effect from the beginning and on every iteration
    afterwards. By default, a breakpoint inside a loop will pause the execution on
    every iteration, and if the loop is long, such pausing behavior can quickly become
    tiresome. To resolve this, you can set breakpoint conditions that specify the
    states that must be true for the breakpoint to take effect. To set a breakpoint
    condition, right-click on the breakpoint and choose **Breakpoint Properties**
    from the context menu, as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 断点对于调试至关重要，它代表了应用程序执行暂停进入调试状态的开始点。通常，断点正是你设置断点并开始调试所需的东西！然而，有时断点在其默认配置下可能会变得令人烦恼。一个例子是在循环内部设置断点。有时，你可能只想在循环超过指定次数迭代后使断点生效或暂停执行，而不是从开始就在每次迭代后生效。默认情况下，循环内的断点会在每次迭代时暂停执行，如果循环很长，这种暂停行为可能会很快变得令人厌烦。为了解决这个问题，你可以设置断点条件，指定断点生效必须为真的状态。要设置断点条件，右键单击断点，从上下文菜单中选择**断点属性**，如图所示：
- en: '![Debugging with MonoDevelop – conditional breakpoints](img/0655OT_02_34.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 条件断点](img/0655OT_02_34.jpg)'
- en: Accessing Breakpoint Properties to set a condition
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问断点属性来设置条件
- en: Selecting **Breakpoint Properties** will display the **Breakpoint Properties**
    dialog where conditions for the breakpoint can be specified. In the **Condition**
    section, choose the **Break when condition is true** option and then use the **Condition
    expression** field to specify the condition that determines the breakpoint. For
    loop conditions, the expression `i>5` will trigger the breakpoint when the loop
    iterator has exceeded `5`. Of course, the variable `i` should be substituted for
    your own variable names.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**断点属性**将显示**断点属性**对话框，其中可以指定断点的条件。在**条件**部分，选择**当条件为真时中断**选项，然后使用**条件表达式**字段指定确定断点的条件。对于循环条件，表达式`i>5`将在循环迭代器超过`5`时触发断点。当然，变量`i`应替换为您自己的变量名。
- en: '![Debugging with MonoDevelop – conditional breakpoints](img/0655OT_02_35.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 条件断点](img/0655OT_02_35.jpg)'
- en: Setting conditions for a breakpoint
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点的条件
- en: Debugging with MonoDevelop – tracepoints
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MonoDevelop进行调试 – 跟踪点
- en: 'Tracepoints can offer you a neater alternative to using `Debug.Log` statements
    that, as we''ve seen, force us to amend the code we''re debugging. Tracepoints
    work like breakpoints, in that they mark lines within your source file. They don''t
    change the code itself, but (unlike breakpoints) they don''t pause the program
    execution when encountered by the debugger. Instead, they perform a specified
    instruction automatically. Typically, they print a debug statement to the **Application
    Output** window in MonoDevelop, though not to the Unity''s **Console**. To set
    a breakpoint in line 16 of code sample 2-10, position your cursor on line 16 and
    select **Add Tracepoint** in **Run** from the application menu (or press *Ctrl*
    + *Shift* + *F9*), as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪点可以为您提供比使用`Debug.Log`语句更整洁的替代方案，正如我们所看到的，这迫使我们修改正在调试的代码。跟踪点的工作方式类似于断点，即在您的源文件中标记行。它们不会更改代码本身，但（与断点不同）当调试器遇到它们时，它们不会暂停程序执行。相反，它们会自动执行指定的指令。通常，它们会将调试语句打印到MonoDevelop的**应用程序输出**窗口中，但不会打印到Unity的**控制台**。要在代码示例2-10的第16行设置断点，请将光标置于第16行，然后从应用程序菜单中选择**运行**中的**添加跟踪点**（或按*Ctrl*
    + *Shift* + *F9*），如下所示：
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_36.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 跟踪点](img/0655OT_02_36.jpg)'
- en: Adding Tracepoint to the selected line in MonoDevelop
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将跟踪点添加到MonoDevelop中选定的行
- en: 'On selecting the **Add Tracepoint** option, MonoDevelop will show the **Add
    Tracepoint** dialog. The **Trace Text** field allows you to input the text to
    be printed to the **Application Output** window when the tracepoint is encountered
    at runtime. You can also insert the curly braces opening and closing symbols to
    define the regions in the string where expressions should be evaluated. This lets
    you print the values of variables into the debug string, such as `"Loop counter
    is {i}"`, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择**添加跟踪点**选项时，MonoDevelop将显示**添加跟踪点**对话框。**跟踪文本**字段允许你在运行时遇到跟踪点时将文本打印到**应用程序输出**窗口。您还可以插入大括号开闭符号来定义字符串中应评估表达式的区域。这可以让您将变量的值打印到调试字符串中，例如`"循环计数器是
    {i}"`，如下所示：
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_37.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 跟踪点](img/0655OT_02_37.jpg)'
- en: Setting Tracepoint Text
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 设置跟踪点文本
- en: 'After clicking on **OK**, the tracepoint is added to the selected line. Inside
    MonoDevelop, the line will be marked with a diamond shape as opposed to a circle;
    this diamond shape indicates a breakpoint:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**后，跟踪点将被添加到所选行。在MonoDevelop中，该行将以菱形标记，而不是圆形；这个菱形形状表示一个断点：
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_38.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用MonoDevelop进行调试 – 跟踪点](img/0655OT_02_38.jpg)'
- en: Inserting a tracepoint
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 插入跟踪点
- en: 'After setting the tracepoint in the selected line in the code editor and running
    the application via the attachment with MonoDevelop, the game will run as normal,
    directly from the Unity Editor. However, when the tracepoint is encountered, the
    application will not pause or enter the break mode as it would with breakpoints.
    Instead, the tracepoint will automatically output its printed statements to MonoDevelop''s
    **Application Output** window, without causing a pause. By default, this window
    is docked at the bottom of the MonoDevelop interface:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码编辑器中设置所选行的跟踪点并通过MonoDevelop的附加程序运行应用程序后，游戏将正常运行，直接从Unity编辑器中运行。然而，当遇到跟踪点时，应用程序不会暂停或进入断点模式，就像使用断点时那样。相反，跟踪点会自动将打印的语句输出到MonoDevelop的**应用程序输出**窗口，而不会造成暂停。默认情况下，此窗口停靠在MonoDevelop界面的底部：
- en: '![Debugging with MonoDevelop – tracepoints](img/0655OT_02_39.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MonoDevelop 进行调试 – 跟踪点](img/0655OT_02_39.jpg)'
- en: Tracepoints can print statements such as Debug.Log to the Application Output
    window in MonoDevelop
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Tracepoints 可以将诸如 Debug.Log 这样的语句打印到 MonoDevelop 的应用程序输出窗口中
- en: Tracepoints are an effective and helpful alternative to using the `Debug.Log`
    statements inside Unity, and you don't need to amend your code in any way to use
    them as you do with `Debug.Log`. Unfortunately, they don't print directly to Unity's
    **Console**. Instead, they appear inside the **Application Output** window in
    MonoDevelop. However, as long as you recognize this, working with tracepoints
    can be a powerful and useful method to find and remove bugs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪点是使用 Unity 内部的 `Debug.Log` 语句的有效且有用的替代方案，并且你不需要以使用 `Debug.Log` 时的方式修改代码来使用它们。不幸的是，它们不会直接打印到
    Unity 的 **控制台**。相反，它们出现在 MonoDevelop 的 **应用程序输出** 窗口中。然而，只要你认识到这一点，使用跟踪点可以是一种强大且有用的方法来查找和移除错误。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter considered the process of debugging, which is centrally about
    finding and removing errors from your game. There are many methods to achieve
    this end, especially in Unity. Specifically, the methods considered here included
    the `Debug.Log` statement, perhaps the simplest of all debugging methods. Using
    this technique, `Debug.Log` statements are inserted into your code in critical
    lines, and these print diagnostic messages to Unity''s **Console**. Next, we looked
    at is custom defines: using them, you can section off and isolate blocks of your
    code between the release and debug versions; this allows you to run debug-specific
    code when specific flags are enabled. Then, we looked at error logging. This chapter
    demonstrated how to create an error logger class that integrates with native Unity''s
    application class, using delegates. We also saw the profiler; the Unity profiler
    is a pro-only feature that gives us a high-level statistical insight into how
    processing is distributed over time and system resources. In addition, we explored
    in-editor debugging and visual debugging to gain a clearer visual insight into
    our scene, and factors that affect object behavior. Finally, we saw MonoDevelop
    debugging, which does not require us to edit our code. These include breakpoints,
    tracepoints, steps, and watches. Next up, we''ll explore how to work with `GameObjects`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了调试过程，这个过程主要关于从你的游戏中查找和移除错误。在 Unity 中，实现这一目标有许多方法，特别是考虑了以下方法：`Debug.Log`
    语句，可能是所有调试方法中最简单的一种。使用这种技术，`Debug.Log` 语句被插入到代码的关键行中，并将诊断信息打印到 Unity 的 **控制台**。接下来，我们探讨了自定义定义：使用它们，你可以在发布和调试版本之间隔离和分离代码块；这允许你在启用特定标志时运行特定的调试代码。然后，我们讨论了错误日志。本章演示了如何创建一个与原生
    Unity 应用程序类集成的错误记录器类，使用委托。我们还看到了分析器；Unity 分析器是一个专业功能，它为我们提供了对处理如何随时间分布以及系统资源的统计洞察。此外，我们还探讨了编辑器调试和可视化调试，以获得对场景更清晰的视觉洞察，以及影响对象行为因素。最后，我们看到了
    MonoDevelop 调试，这不需要我们编辑代码。这些包括断点、跟踪点、步骤和监视器。接下来，我们将探讨如何与 `GameObjects` 一起工作。
