- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Reasoning about Types Using Reflection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反射进行类型推理
- en: Now that we have covered some of the basics of how metaprogramming can benefit
    you, its core concepts, and a real-world example, it’s time to look inside the
    .NET runtime and see how we can leverage its power.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些元编程如何为你带来好处的基础知识，其核心概念以及一个真实世界的例子，现在是时候深入.NET运行时，看看我们如何利用其力量。
- en: In this chapter, we will have a look at the implicit metadata provided by the
    compiler and the runtime. We’ll see how we can collect all types in a running
    system and use it for discovery.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨编译器和运行时提供的隐式元数据。我们将了解如何收集运行系统中的所有类型，并用于发现。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Assembly discovery in the running process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行过程中的程序集发现
- en: Leveraging library metadata to get project-referenced assemblies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用库元数据获取项目引用的程序集
- en: Discovering types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现类型
- en: Open/closed principle applied
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用开放/封闭原则
- en: By the end of this chapter, you will understand how you can use the powerful
    APIs of the .NET runtime to reason about the types already in the system. You’ll
    learn how this can then be applied to make a more elastic and dynamic code base
    that can grow and ensure its maintainability is preserved.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何使用.NET运行时的强大API来推理系统中已存在的类型。你将学习如何将其应用于创建一个更具弹性和动态的代码库，它可以增长并确保其可维护性得到保留。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to this chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4))
    and builds on top of the **Fundamentals** code found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4)），并且基于[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)中找到的**基础知识**代码。
- en: Assembly discovery in the running process
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行过程中的程序集发现
- en: In .NET, everything we compile ends up inside what is called an **assembly**.
    This is the binary that holds the compiled code in the form of **Intermediate
    Language** (**IL**). Alongside this, there is metadata that goes with it to identify
    types, methods, properties, fields, and any other symbols and metadata.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，我们编译的所有内容最终都会放入一个称为**程序集**的容器中。这是以**中间语言**（**IL**）的形式存储编译代码的二进制文件。与此并行，还有一些元数据与之相关，用于标识类型、方法、属性、字段以及任何其他符号和元数据。
- en: All of these artifacts are discoverable through APIs, and it all starts with
    the **System.Reflection** namespace. Within this namespace, there are APIs that
    allow you to reflect on what’s running. In other languages, this is often referred
    to as **introspection**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工件都可以通过API发现，一切始于**System.Reflection**命名空间。在这个命名空间中，有一些API允许你反射正在运行的内容。在其他语言中，这通常被称为**内省**。
- en: Looking at any instance of any type you’ll see that there is always a **GetType()**
    method you can call. This is part of the reflection capabilities and is implemented
    in the base type of **Object**, which all types implicitly inherit from.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 观察任何类型的任何实例，你会发现总有一个可以调用的**GetType()**方法。这是反射能力的一部分，并在**Object**的基类型中实现，所有类型都隐式继承自该类型。
- en: The **GetType()** method returns a **Type** type that describes the capabilities
    of the particular type – its fields, properties, methods, and more. It also holds
    information about what possible interfaces it implements or a base type it is
    inheriting from. These are very powerful constructs that we will leverage later
    in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetType()**方法返回一个**Type**类型，它描述了特定类型的特性——其字段、属性、方法等。它还包含有关它可能实现或继承自的基类型的信息。这些是非常强大的结构，我们将在本章后面利用它们。'
- en: Instead of starting with individual types, let’s take a step back and see how,
    from no type, we can discover what we have in our running process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不妨从单个类型开始，退一步看看，从没有任何类型开始，我们如何发现我们在运行过程中的内容。
- en: Assembly
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集
- en: 'One of the types in the **System.Reflection** namespace is **Assembly**. This
    is the type representing an assembly, typically a **.dll** file containing the
    IL code. On the **Assembly** type, there are a few static methods. We want to
    focus on one particular method: **.GetEntryAssembly()**. This method lets us,
    at any time, get the assembly that was the starting point, the entry point that
    the .NET runtime called to start our application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Reflection**命名空间中的一个类型是**Assembly**。这是表示程序集的类型，通常是包含IL代码的**.dll**文件。在**Assembly**类型上，有几个静态方法。我们想要关注一个特别的方法：**.GetEntryAssembly()**。此方法允许我们在任何时间获取作为起始点的程序集，即.NET运行时调用以启动我们的应用程序的入口点：'
- en: Let’s create a folder called **Chapter4**. For this chapter, we will create
    a few projects, so let’s start by creating another folder called **AssemblyDiscovery**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为**Chapter4**的文件夹。对于这一章，我们将创建几个项目，所以让我们先创建一个名为**AssemblyDiscovery**的另一个文件夹。
- en: 'Change into this folder in your command-line interface and create a new console
    project:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的命令行界面中切换到这个文件夹，并创建一个新的控制台项目：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will set up the necessary artifacts for the project. Open the **Program.cs**
    file and replace its content with the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将设置项目所需的必要工件。打开**Program.cs**文件，并用以下内容替换其内容：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is accessing the **GetEntryAssembly()** static method on **Assembly**
    to get the assembly that serves as the entry point of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正在访问**Assembly**上的**GetEntryAssembly()**静态方法以获取作为应用程序入口点的程序集。
- en: 'By running this program now, you should get an output that is similar to the
    following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行此程序，你应该得到一个类似于以下输出的结果：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This just prints out the name of the assembly, its version, information about
    the culture the assembly is for, and, if the assembly was signed, its public key.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是打印出程序集的名称、版本、程序集针对的文化信息，以及如果程序集已签名，则其公钥。
- en: 'From the entry assembly, we can now start looking at what assemblies have been
    referenced. Replace the code in **Program.cs** with the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从入口程序集，我们现在可以开始查看哪些程序集已被引用。将**Program.cs**中的代码替换为以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code gets the referenced assemblies from the entry assembly and prints
    them out. You should be see something like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从入口程序集获取引用的程序集并打印出来。您应该看到以下类似的内容：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since we haven’t explicitly referenced any assemblies, we only see **System.Runtime**,
    **System.Consol**, and **System.Linq** as the available assemblies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有显式引用任何程序集，所以我们只看到**System.Runtime**、**System.Consol**和**System.Linq**作为可用的程序集。
- en: This is all very basic but demonstrates the starting point of reasoning about
    your applications and what they’re built from. But we can do so much more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是非常基础的，但展示了关于您的应用程序及其构建方式的推理起点。但我们可以做更多。
- en: Leveraging library metadata to get project referenced assemblies
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用库元数据获取项目引用的程序集
- en: If you are going to gather metadata across a running process, chances are that
    you’re only interested in the assemblies that are part of your solution and not
    all the .NET framework libraries or third-party libraries. There is a performance
    impact of looking through all assemblies for metadata, so filtering down might
    be a good idea.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算跨正在运行的过程收集元数据，那么您可能只对解决方案中的程序集感兴趣，而不是所有的.NET框架库或第三方库。查找所有程序集以获取元数据会有性能影响，因此过滤下来可能是个好主意。
- en: In .NET projects, we can add package references, typically from sources such
    as **NuGet** or your own package sources, but we can also add local project references.
    These are references to other **.csproj** files representing something that we
    want to package in its own assembly. Inside a **.csproj** file, you can identify
    the different references by their XML tags – **<PackageReference/>** or **<ProjectReference/>**.
    Inside Visual Studio or Rider, you will typically see these tags in the explorer
    view as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET项目中，我们可以添加包引用，通常来自**NuGet**或您自己的包源，但我们也可以添加本地项目引用。这些引用指向其他**.csproj**文件，代表我们希望将其打包到自己的程序集中的内容。在**.csproj**文件中，您可以通过它们的XML标签来识别不同的引用
    – **<PackageReference/>**或**<ProjectReference/>**。在Visual Studio或Rider中，您通常会在资源管理器视图中看到这些标签。
- en: The **C#** compiler produces additional metadata to distinguish the different
    types of references all projects have. This can be leveraged in code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**编译器为所有项目产生的不同类型的引用生成额外的元数据。这可以在代码中利用。'
- en: Reusable fundamentals
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用的基础知识
- en: 'Let’s build a reusable library that we can leverage and expand on throughout
    the following chapters. Let’s call this project **Fundamentals**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个可重用的库，我们可以在接下来的章节中利用和扩展它。让我们把这个项目命名为 **Fundamentals**：
- en: 'Create a new folder at the root of where you started building out the chapters
    and call it **Fundamentals**. Change into this folder and create the new project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你开始构建章节的根目录下创建一个新的文件夹，命名为 **Fundamentals**。切换到这个文件夹并创建新的项目：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a new project and adds a file called **Class1.cs**. Remove this
    file as we don’t need it at all.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的项目并添加一个名为 **Class1.cs** 的文件。由于我们根本不需要它，所以请将其删除。
- en: In order for us to be able to get to the proper metadata enabling us to distinguish
    between package or project references, we need to add a NuGet package reference.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们能够获取到适当的元数据，使我们能够区分包或项目引用，我们需要添加一个 NuGet 包引用。
- en: 'The package we’re looking for is **Microsoft.Extensions.DependencyModel**.
    In the terminal, you add the reference by doing the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找的包是 **Microsoft.Extensions.DependencyModel**。在终端中，你可以通过以下步骤添加引用：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have the package, we want to create a system that is capable of
    discovering project references and any additional package references we explicitly
    tell it to load. From these, we want to get all the types so that we can start
    making some serious discoveries about our system.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个包，我们想要创建一个能够发现项目引用和任何我们明确告诉它加载的额外包引用的系统。从这些中，我们想要获取所有类型，这样我们就可以开始对我们系统进行一些严肃的探索。
- en: 'Start by creating a file called **Types.cs**. Then add the following code to
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 **Types.cs** 的文件。然后向其中添加以下代码：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Within this new class, we want to be able to expose all the discovered types.
    Before we can do that, we need to discover them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新类中，我们希望能够公开所有发现的类型。在我们能够做到这一点之前，我们需要发现它们。
- en: 'At the top of the **Types.cs** file before the namespace declaration, add the
    following **using** statements:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Types.cs** 文件的命名空间声明之前，在顶部添加以下 **using** 语句：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a private method called **DiscoverAllTypes()** and start by making it look
    as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 **DiscoverAllTypes()** 的私有方法，并首先让它看起来如下：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code will get the entry assembly and then leverage **DependencyContext**
    from the package you referenced. This model contains more metadata around the
    assemblies (or libraries, as they are called in the **DependencyModel** extension).
    The last thing we do is to load the assemblies we find. For the most part, the
    assemblies are already loaded. But this will guarantee they are loaded and return
    an instance of the assembly. It won’t load it again if it is already loaded.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将获取入口程序集，然后利用你引用的包中的 **DependencyContext**。这个模型包含有关程序集（或称为在 **DependencyModel**
    扩展中称为库）的更多元数据。我们最后要做的就是加载我们找到的程序集。大多数情况下，程序集已经加载。但这将保证它们被加载，并返回一个程序集的实例。如果它已经加载，则不会再次加载它。
- en: The result of this is that we have all the project-referenced assemblies in
    an array. That might not be all you want. If for instance you’re maintaining a
    set of common packages that are shared within your organization and you want to
    discover from these, a common pattern is to have your organization name as part
    of the assembly name, typically at the beginning. That means it’s easy to add
    something that includes all assemblies that are prefixed with a certain string.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做结果是我们在一个数组中拥有所有项目引用的程序集。但这可能不是你想要的全部。例如，如果你在维护一套在组织内部共享的通用包，并且想从这些包中查找，一个常见的模式是将组织名称作为程序集名称的一部分，通常在开头。这意味着很容易添加包含以特定字符串为前缀的所有程序集的内容。
- en: 'Change the signature for the **DiscoverAllTypes()** method to be able to include
    a collection of assembly prefixes for collecting types for discovery:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **DiscoverAllTypes()** 方法的签名更改为能够包含一个用于收集用于发现的程序集前缀的集合：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the **DiscoverAllTypes()**method, add the following at the end:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **DiscoverAllTypes()** 方法中，在末尾添加以下内容：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code looks at the same **RuntimeLibraries**, but this time specifically
    for assemblies that start with the prefixes. There is also error-handling functionality
    here: some assemblies can’t be loaded with the regular **Assembly.Load()** method
    and we just ignore them, as they are not of interest.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查相同的 **RuntimeLibraries**，但这次是针对以特定前缀开始的程序集。这里也有错误处理功能：一些程序集无法使用常规的 **Assembly.Load()**
    方法加载，所以我们只是忽略它们，因为它们对我们没有兴趣。
- en: 'Since we call **.ToList()** at the end of the LINQ query, we can easily combine
    the two collections of assemblies and all the types from all the loaded assemblies
    and return them from the **DiscoverAllTypes()** method. Add the following at the
    end of the **DiscoverAllTypes()** method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在LINQ查询的末尾调用了**.ToList()**，我们可以轻松地将两个程序集集合和所有加载的程序集中的所有类型组合起来，并从**DiscoverAllTypes()**方法返回它们。在**DiscoverAllTypes()**方法的末尾添加以下内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have collected all assemblies and their types and returned them,
    it’s time to expose them to the outside world. We do this by adding a public property
    returning **IEnumerable** of **Type**. We don’t want this to be potentially mutated
    from the outside:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经收集了所有程序集及其类型并返回了它们，现在是时候将它们暴露给外部世界了。我们通过添加一个返回**IEnumerable**类型**Type**的公共属性来实现这一点。我们不希望它从外部被潜在地修改：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last piece of the puzzle for the **Types** class is to add a constructor.
    We want the constructor to take any assembly prefixes for the **DiscoverAllTypes()**
    method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Types**类的最后一部分是添加一个构造函数。我们希望构造函数能够接受**DiscoverAllTypes()**方法的任何程序集前缀：'
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have now encapsulated a type registry that we can leverage for other use
    cases. Now that we have some basic building blocks. Let’s go ahead and create
    a multi-project application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在封装了一个类型注册表，我们可以利用它来处理其他用例。现在我们有一些基本的构建块。让我们继续创建一个多项目应用程序。
- en: Business app
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商业应用程序
- en: Now that we have some basic building blocks. Lets go ahead and create a multi
    project application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一些基本的构建块。让我们继续创建一个多项目应用程序。
- en: 'Inside the **Chapter4** folder, create a folder called **BusinessApp**. In
    this folder, we’re going to create multiple projects that will make up the application.
    Within the **BusinessApp** folder, create one folder called **Domain** and another
    called **Main**. The **Domain** folder will represent the domain logic of our
    application and should be a class library project. Go ahead and create a new .NET
    project in the **Domain** folder:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter4**文件夹中，创建一个名为**BusinessApp**的文件夹。在这个文件夹中，我们将创建多个项目，这些项目将构成应用程序。在**BusinessApp**文件夹中，创建一个名为**Domain**的文件夹和一个名为**Main**的文件夹。**Domain**文件夹将代表我们应用程序的领域逻辑，应该是一个类库项目。在**Domain**文件夹中创建一个新的.NET项目：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Delete the **Class1.cs** file that is generated. Then, in the **Main** folder,
    we want to create a console app:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 删除生成的**Class1.cs**文件。然后，在**Main**文件夹中，我们想要创建一个控制台应用程序：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within the **Main** project you should now add references to the **Fundamentals**
    project and also the **Domain** project:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Main**项目中，你现在应该添加对**Fundamentals**项目和**Domain**项目的引用：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the **Program.cs** file, inside the **Main** project, replace the content
    with the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Program.cs**文件中，在**Main**项目中，将内容替换为以下内容：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code now leverages the **Types** class we put into **Fundamentals**, which
    will look at all our project reference assemblies and give us all the types. Running
    this should give you an output similar to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在利用了我们放入**Fundamentals**中的**Types**类，该类将查看所有项目引用程序集，并给我们所有类型。运行此代码应该会得到类似以下输出：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll notice that some of these types aren’t types you have created at all.
    These are types the C# compiler has put into the projects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到其中一些类型根本不是你创建的。这些是C#编译器放入项目的类型。
- en: 'Go and add a folder called **Employees** in the **Domain** project and within
    it, create a file called **RegisterEmployee.cs** and add the following content:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**Domain**项目，在其中添加一个名为**Employees**的文件夹，并在其中创建一个名为**RegisterEmployee.cs**的文件，并添加以下内容：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By running the **Main** project again, you should now see the added type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行**Main**项目后，你现在应该看到添加的类型：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we have the beginning of a strong foundation for working with types.
    We just need to improve its capabilities to make it even more useful.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就为使用类型打下了坚实的基础。我们只需要提高其功能，使其更加有用。
- en: Discovering types
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型发现
- en: With the **Types** class, we now have a raw approach to get all the types in
    a running system. This can be very helpful on its own as you can now use this
    to perform **Language Integrated Query** (**LINQ**) queries on top of finding
    types that match specific criteria you’d be interested in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**Types**类，我们现在有一种原始的方法来获取运行系统中的所有类型。这本身就可以非常有用，因为你现在可以使用它来执行**语言集成查询**（**LINQ**）查询，以找到符合你感兴趣的具体标准的类型。
- en: A very common scenario in code in general is that we have base classes or interfaces
    that represent characteristics of known artifact types in our system and we create
    specialized versions that override virtual or abstract methods, or just implement
    a specific interface to represent what it is. This is the power of object-oriented
    programming languages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，一个非常常见的场景是我们有基类或接口，它们代表了我们系统中已知工件类型的特征，并且我们创建了专门的版本来覆盖虚拟或抽象方法，或者只是实现一个特定的接口来表示它是什么。这是面向对象编程语言的力量。
- en: With this, we are adding additional implicit metadata into our systems that
    we can leverage. For instance, in [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041),
    *Demystifying through Existing Real-World Examples*, we looked at how ASP.NET
    does this by discovering all classes that have **Controller** as their base type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们向我们的系统中添加了额外的隐式元数据，我们可以利用这些数据。例如，在 [*第3章*](B19418_03.xhtml#_idTextAnchor041)，*通过现有真实世界示例去神秘化*
    中，我们探讨了 ASP.NET 是如何通过发现所有以 **Controller** 为基类的类来实现这一点的。
- en: From my own experience, this is the typical pattern that has been used the most
    on the projects I’ve been doing these things on. In fact, it is so common that
    it is a good idea to optimize the lookup of types on this to avoid the complexity
    when looking up types based on inheritance. An optimized lookup will improve performance
    significantly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，这是我在进行这些项目时使用最多的典型模式。事实上，它如此普遍，以至于优化类型查找以避免基于继承查找时的复杂性是一个好主意。优化的查找将显著提高性能。
- en: 'It would be a bit too verbose to do a full walkthrough of the full lookup cache
    mechanism as there are quite a few moving parts to it. You can find the full code
    here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完整地解释完整的查找缓存机制可能会有些冗长，因为其中涉及许多动态部分。你可以在以下链接中找到完整的代码：[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs).
- en: 'The interface represented by **ContractToImplementorsMap** is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**ContractToImplementorsMap** 所表示的接口如下：'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The purpose of the API of **IContractToImplementorsMap** is to give a fast way
    of getting implementations of a specific type, be it a base class or an interface.
    The implementation of **IContractToImplementorsMap** takes all types it is fed
    and maps these correctly in this cache.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**IContractToImplementorsMap** API 的目的是提供一个快速获取特定类型实现的方法，无论是基类还是接口。**IContractToImplementorsMap**
    的实现会接收所有传入的类型，并将这些类型正确映射到这个缓存中。'
- en: 'You’ll notice that there is a method called **Feed()**. We will have to call
    this in our **Types** class. In addition, we want to have some methods that make
    discovering different types a lot more helpful; for instance, the following methods
    would be helpful:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有一个名为 **Feed()** 的方法。我们将在我们的 **Types** 类中调用这个方法。此外，我们还想有一些方法，使发现不同类型变得更加有用；例如，以下方法将很有帮助：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These methods allow us to find methods that implement a specific interface or
    inherit from a base type. They allow us to find a single instance or multiple
    implementors, based on type either by generic parameter or by passing in the **Type**
    object. Also for convenience, there is a method for finding a type by its name.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法允许我们找到实现特定接口或继承自基类型的方法。它们允许我们根据类型（通过泛型参数或通过传递 **Type** 对象）找到单个实例或多个实现者。为了方便起见，还有一个通过名称查找类型的方法。
- en: You can find the full implementation in the **Fundamentals** folder at the link
    specified at the beginning of the chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章开头指定的链接中找到 **Fundamentals** 文件夹中的完整实现。
- en: Back to business
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到正题
- en: 'Moving back to our business sample, let’s add a second class in the **Employee**
    folder within the **Domain** project called **SetSalaryLevelForEmployee.cs**.
    Make it look like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的业务示例，让我们在 **Domain** 项目中的 **Employee** 文件夹内添加一个名为 **SetSalaryLevelForEmployee.cs**
    的第二个类。让它看起来如下：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The **RegisterEmployee** and **SetSalaryLevelForEmployee** classes both represent
    the data we need to perform the specific actions in our domain business logic.
    These types of actions are often called commands. If we wanted to discover all
    of our commands, we could create an empty interface that we can use for all our
    commands to implement to make it easy for us to discover them. These types of
    empty interfaces used in this way are often referred to as marker interfaces.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册员工**和**为员工设置薪资级别**类都代表了我们在领域业务逻辑中需要执行特定操作的数据。这类操作通常被称为命令。如果我们想发现所有的命令，我们可以创建一个空接口，我们可以使用这个接口让所有命令实现，这样我们就可以轻松地发现它们。这种以这种方式使用的空接口通常被称为标记接口。'
- en: 'In the **Fundamentals** project, add a file called **ICommand.cs** and make
    it look like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在**基础**项目中，添加一个名为**ICommand.cs**的文件，并使其看起来如下：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now need to have a project reference to the **Fundamentals** project from
    the **Domain** project. Run the following from the **Domain** project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从**域**项目到**基础**项目的项目引用。从**域**项目运行以下命令：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the new **ICommand** interface, we can mark the **RegisterEmployee** and
    **SetSalaryLevelForEmployee** commands with it. Open the files for both **RegisterEmployee**
    and **SetSalaryLevelForEmployee** and add the following **using** statements at
    the top of each of the files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的**ICommand**接口，我们可以用它标记**注册员工**和**为员工设置薪资级别**命令。打开**注册员工**和**为员工设置薪资级别**的文件，并在每个文件的顶部添加以下**using**语句：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For both of the class definitions, add **: ICommand** at the end to make them
    implement the **ICommand** interface.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这两个类定义，在末尾添加**: ICommand**，使它们实现**ICommand**接口。'
- en: 'Open the **Program.cs** file in the **Main** project and change it with the
    following content:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Main**项目中的**Program.cs**文件，并使用以下内容进行更改：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the **Main** project should now yield the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**Main**项目现在应该得到以下结果：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Effectively we have now reproduced the necessary infrastructure to mimic what
    ASP.NET is doing for its discovery of items. With this, we have opened our software
    to be more open to expansion.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地，我们现在已经复制了必要的基础设施来模仿ASP.NET对项目发现的操作。有了这个，我们使我们的软件更容易扩展。
- en: Domain concepts
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域概念
- en: The most boring types in most programming languages are the primitives that
    come with the language; typically, your integers, booleans, strings, and such.
    They offer absolutely no interesting or meaningful metadata. They are nothing
    but very primitive.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中最无聊的类型是语言提供的原始数据；通常，你的整数、布尔值、字符串等。它们提供绝对没有有趣或有意义的元数据。它们只是非常原始的。
- en: It’s easy to fall into the trap of using these and end up with primitive obsession.
    Not only are you losing valuable metadata, but it also creates code that can at
    times be unclear and also potentially be error prone as two properties of the
    same primitive type are interchangeable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易陷入使用这些数据的陷阱，最终导致对原始数据的执着。这不仅会使你失去宝贵的元数据，而且有时还会创建出不清楚的代码，甚至可能因为两个相同原始类型的属性可以互换而容易出错。
- en: For applications, there is a great opportunity to move away from primitives
    and bring back meaning to your domain by encapsulating the primitives into meaningful
    types in your domain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，有一个很好的机会通过将原始数据封装到有意义的数据类型中，从而从原始数据中脱离出来，给你的领域带来意义。
- en: The beauty of this is that you’ll not only make your code more readable but
    also understandable and less ambiguous. Doing so moves you away from being primitive-obsessed
    to a place where you will get compiler errors if you do something wrong, putting
    developers on the right foot from the start. On top of all this, you’ll also be
    bringing in tons of metadata that can be leveraged.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种美在于，你不仅会使你的代码更易于阅读，而且更易于理解，并且减少歧义。这样做可以使你从对原始数据的执着转变为一个地方，在那里如果你做错了什么，你会得到编译器错误，从而让开发者从一开始就站在正确的位置。除此之外，你还会带来大量的元数据，这些数据可以被利用。
- en: Key characteristics of primitives are that they are value types. This means
    you can have two instances of the same value and equality checks would indicate
    that they are the same. In **C# 9.0**, we got a new construct called **record**.
    This enables us to create types that are complex types but bare the same characteristics
    as value types. Comparing two complex **record** types with the same values on
    them will be considered equal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型的关键特征是它们是值类型。这意味着你可以有两个相同的值实例，并且相等性检查将表明它们是相同的。在**C# 9.0**中，我们得到了一个新的结构体**record**。这使我们能够创建具有复杂类型但具有与值类型相同特性的类型。比较具有相同值的两个复杂**record**类型将被视为相等。
- en: 'Let’s introduce a base type that can be used for concepts. In the **Fundamentals**
    project, add a file called **ConceptAs.cs** and make it look like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一种可用于概念的基本类型。在**基础**项目中，添加一个名为**ConceptAs.cs**的文件，并使其看起来如下所示：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This implementation gives you a way to encapsulate domain concepts. It’s built
    using generics letting you specify the inner type of the value the concept is
    representing. It is strict on not allowing null values within the encapsulation.
    If you want to allow null values in your code, it should not be within the concept
    but rather on the instance of the concept. Further, the implementation provides
    a convenience operator for automatic conversion to the primitive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现为你提供了一种封装领域概念的方法。它是使用泛型构建的，允许你指定概念所表示的值的内部类型。它对封装内不允许null值执行严格的检查。如果你想在代码中允许null值，它不应在概念内，而应在概念的实例上。此外，实现提供了一个便利操作符，用于自动将概念转换为原始类型。
- en: Typically, when you’re working with databases or you are transferring data across
    the wire in different formats, you want to strip away the concept wrapper and
    just get the primitive. Having the common base type is then a fantastic piece
    of type information that these serializers can work with.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你与数据库一起工作或在不同格式之间传输数据时，你希望去除概念包装，只获取原始类型。然后，具有公共基类型的信息对于这些序列化器可以与之一起工作的类型信息来说是一份极好的信息。
- en: In the **Fundamentals** link that was at the beginning of the chapter, you’ll
    find an example of how to create a **JsonConverter** for **System.Text.Json**
    that will automatically convert any implementations of a concept to the underlying
    value during serialization and back to the concept type when deserializing. With
    the **ConceptAsJsonConverterFactory** implementation in the same location in the
    **Fundamentals** link, you’ll see that it recognizes whether a type can be converted
    if it is a concept based on the **ConceptAs** base type and creates the correct
    converter to serialize and deserialize the concepts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头提到的**基础**链接中，你可以找到一个如何为**System.Text.Json**创建**JsonConverter**的示例，该转换器将在序列化期间自动将概念实现的任何实例转换为底层值，并在反序列化时将它们转换回概念类型。在**基础**链接的同一位置，你可以看到**ConceptAsJsonConverterFactory**实现，它根据**ConceptAs**基类型识别类型是否可以转换，并创建正确的转换器来序列化和反序列化概念。
- en: 'With the **ConceptAs** construct, we can now go and create domain-specific
    implementations. As you’ll find in the code for this chapter ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp)),
    you can create specific concepts. For instance, for the **RegisterEmployee** command
    we created earlier, instead of just using primitives, you can create specific
    types like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ConceptAs**结构体，我们现在可以创建特定领域的实现。正如你将在本章代码（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp)）中找到的那样，你可以创建特定的概念。例如，对于之前创建的**RegisterEmployee**命令，你不仅可以使用原始类型，还可以创建以下特定类型：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you can alter **RegisterEmployee** from before to the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将之前的**RegisterEmployee**修改为以下内容：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will remove any potential mistakes in the code. There is no way you could
    accidentally put **FirstName** into **LastName** or vice versa, as the compiler
    will tell you they’re not of the same type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将消除代码中可能出现的任何潜在错误。你不可能意外地将**FirstName**放入**LastName**或反之亦然，因为编译器会告诉你它们不是同一类型。
- en: Cross-cutting concerns
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 横切关注点
- en: 'With something like a concept in place, we are really starting to enrich our
    application code with meaningful metadata. This creates new opportunities. As
    mentioned earlier for serialization, by having the base type that everything uses,
    we can easily handle serialization in one place for concept types. This is what
    we mean when we talk about cross-cutting concerns: creating constructs or behavior
    once that can be applied across multiple things, automatically.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了类似概念的基础上，我们真正开始丰富我们的应用程序代码，使其包含有意义的元数据。这创造了新的机会。如前所述，对于序列化，由于我们有了所有事物都使用的基类型，我们可以轻松地在单一位置处理概念类型的序列化。这就是我们谈论横切关注点时所指的：创建一次即可应用于多个事物的结构或行为，自动完成。
- en: The possibilities are endless with these things. We could automatically create
    validation rules that are applied for the type whenever it is being used. Or we
    could go ahead and apply authorization policies based on types when they are used.
    For the command pattern and a powerful pipeline-based framework such as ASP.NET,
    this means we can go ahead and create action filters or middleware that can be
    injected into the pipeline that deals with these things automatically – just because
    we now have the metadata we need.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情的可能性是无限的。我们可以自动创建在类型被使用时应用的验证规则。或者，我们可以在使用时根据类型应用授权策略。对于命令模式和强大的基于管道的框架如ASP.NET，这意味着我们可以继续创建可以注入处理这些事物的管道中的操作过滤器或中间件——仅仅因为我们现在有了所需的元数据。
- en: Take security, the one thing you really want to get right. Don’t get us wrong,
    we aim to get everything we do right – but security is the one thing you don’t
    want to mess around with. With the richness of the type system and all the metadata
    that goes with it, you gain access to some great opportunities to make it simpler
    for developers to do the right thing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到安全，这是你真正想要做对的一件事。不要误解我们，我们旨在把我们所做的一切都做好——但安全是你绝对不希望马虎对待的事情。类型系统的丰富性和与之相关的所有元数据，让你有机会让开发者更容易做正确的事情。
- en: One thing that could be done, for instance, is creating authorization policies
    based on namespaces. If you have a command coming in and it belongs to a namespace
    that requires a certain role or claim for the user, you could do that check in
    one place, and by convention, just let developers drop commands or other artifacts
    into the correct place and they’d be secure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以做的事情之一是创建基于命名空间的授权策略。如果你有一个进入的命令属于需要用户特定角色或声明的命名空间，你可以在一个地方进行这个检查，并且按照惯例，让开发者将命令或其他工件放入正确的位置，它们就会是安全的。
- en: Compliance is another area you really want to get right. It can be extremely
    costly if your software is not compliant. Probably the most talked-about compliance
    law over the last few years has been the EU regulation called **GDPR**. If you’re
    not compliant with this, you could end up being fined.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 合规性是另一个你真正想要做对的地方。如果你的软件不合规，可能会非常昂贵。在过去的几年中，最被谈论的合规法律可能是欧盟的法规**GDPR**。如果你不遵守这项规定，你可能会被罚款。
- en: The whole idea of the GDPR is to protect the privacy of the end users of computer
    systems. A lot of systems collect what is known as **Personally Identifiable Information**,
    or **PII** for short. Things such as your name, address, birth date, social security
    number, and a lot more are classified as PII. There is also a requirement for
    transparency for the end users to know what data you have on them and also to
    know the reason for collecting the data. If your company gets audited, you have
    to also show what type of data you’re collecting in a report.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: GDPR的整个想法是为了保护计算机系统最终用户的隐私。许多系统收集被称为**个人身份信息**，简称**PII**的数据。诸如你的姓名、地址、出生日期、社会保障号码等许多信息都被归类为PII。还有一项要求是透明度，让最终用户知道你拥有他们的哪些数据，以及收集数据的原因。如果你的公司接受审计，你必须也在报告中展示你正在收集的数据类型。
- en: 'Building on what you just learned about concepts, we can take it even further
    and create a specialized version of the base **ConceptAs<>** type. Let’s call
    it **PIIConceptAs<>**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在你刚刚学到的概念的基础上，我们可以更进一步，创建基础 **ConceptAs<>** 类型的专用版本。让我们称它为 **PIIConceptAs<>**：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, it inherits from **ConceptAs<>**, giving us the opportunity
    to create serializers and other tooling around this base type once, but it adds
    metadata saying this is a specialized concept for PII.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它继承自 **ConceptAs<>**，这给了我们一次机会，可以围绕这个基础类型一次性创建序列化器和其他工具。但它添加了元数据，说明这是一个专门用于PII的概念。
- en: At runtime in your application, you can quite easily present to the user all
    this information, as well as to any auditor or law enforcement agency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的运行时，你可以相当容易地向用户展示所有这些信息，以及任何审计机构或执法机构。
- en: 'Take the **SocialSecurityNumber** type we made into a concept earlier. Change
    that to be **PIIConceptAs<>** instead:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前创建的**SocialSecurityNumber**类型为例。将其更改为**PIIConceptAs<>**：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see from the code, it doesn’t take much to enrich it with metadata
    that can be leveraged. And with the powerful type discovery you built at the beginning
    of the chapter, you now have the power to quite easily create a simple console
    report of all this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中看到的，要丰富它以利用元数据并不需要太多。而且，在章节开头构建的强大的类型发现功能，你现在可以轻松地创建一个简单的控制台报告，包含所有这些信息：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first thing the code does is do a LINQ query collecting all properties in
    the system from all types that are of the **PIIConceptAs<>** type. As you can
    see, it uses an extension method, which is part of the fundamentals ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
    Since it selects all the properties with **.SelectMany()**, we group it together
    based on the declaring type. Then it just loops through all the types and then
    all the properties and printing out the information.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先执行的操作是使用LINQ查询收集系统中所有**PIIConceptAs<>**类型的所有属性。如您所见，它使用了一个扩展方法，这是基础部分的一部分([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals))。由于它选择了所有具有**.SelectMany()**的属性，所以我们根据声明类型将其分组。然后它只是遍历所有类型和所有属性，并打印出信息。
- en: 'It should yield the following result:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该产生以下结果：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With a fairly low amount of code, we’ve gone from having no additional metadata
    to a much richer model that opens up the opportunity of applying logic in our
    code across the board. In fact, with it, we’re future-proofing our code to a certain
    extent. We could come back to it at a later stage and decide we want to change
    security. Without changing the actual code at all, we could just apply a new rule
    based on the metadata we already have. This is powerful and makes for flexible,
    extensible, and highly maintainable systems.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用少量代码，我们就从没有额外的元数据转变为一个更丰富的模型，这为我们提供了在代码中应用逻辑的机会。实际上，有了它，我们在一定程度上为代码提供了未来保障。我们可以在以后回到它，并决定我们想要更改安全性。实际上，我们不需要更改任何实际代码，只需根据我们已有的元数据应用一条新规则。这很强大，并使系统变得灵活、可扩展和高度可维护。
- en: Open/closed principle applied
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用开放/封闭原则
- en: 'The **open/closed principle** is a principle credited to Bertrand Meyer after
    its appearance in his 1988 book called *Object-Oriented Software Construction*.
    This is a principle regarding types we can apply in our software:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**是伯特兰·梅耶在其1988年出版的《面向对象软件构造》一书中提出的原则。这是一个关于我们可以应用于我们软件中的类型的原理：'
- en: A type is open if it can be extended
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型可以被扩展，则称其为开放
- en: A type is closed when it is available to other types
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个类型对其他类型可用时，它被称为封闭
- en: Classes in C# are open for extension by default. We can inherit from them and
    add new meanings to them. But the base class we’re inheriting from should be closed,
    meaning that there shouldn’t be any need for changes in the base type for the
    new type to work.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的类默认是开放的，可以扩展。我们可以从它们继承并给它们添加新的含义。但是，我们正在继承的基类应该是封闭的，这意味着对于新类型来说，不应该需要更改基类型。
- en: This helps us design our code for extensibility and keep responsibilities in
    the right place.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们为代码的可扩展性设计，并保持责任在正确的位置。
- en: Taking a step back, we can apply some of this same thinking on the system level.
    What if our systems can just be extended with new capabilities without having
    to add configuration at the heart of a type for it to know about the additions?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 退一步来说，我们可以在系统级别应用一些相同的思考。如果我们的系统可以仅通过扩展新功能来扩展，而无需在类型的中心添加配置以了解这些添加，那会怎样？
- en: This type of thinking is what we did earlier with **ICommand** and the implementations.
    The two commands we added were not known by any parts of the system, but by virtue
    of implementing the **ICommand** interface, we could see both types through an
    introspective of our system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思维方式就是我们之前在**ICommand**和实现中做的事情。我们添加的两个命令没有被系统的任何部分所知，但通过实现**ICommand**接口，我们可以通过系统的内省看到这两种类型。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the power of looking inward into our
    running process and collecting all the referenced assemblies and all the types
    of these assemblies. We’ve looked at how we can leverage even more metadata to
    gain access to the types of reference the assemblies are, be they package references
    or project references.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过查看我们正在运行的过程并收集所有引用的程序集及其类型来发挥其力量。我们探讨了如何利用更多的元数据来获取程序集引用的类型，无论是包引用还是项目引用。
- en: From this, we are empowered to start reasoning about types in a more meaningful
    way and really take advantage of the type system. Interfaces can serve as a very
    powerful method to mark types. The interfaces can, of course, enforce implementations
    of members that need to be there, but they can also just act as empty marker interfaces,
    serving as a way to bring explicit metadata into the assemblies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们得以以更有意义的方式对类型进行推理，并真正利用类型系统。接口可以作为标记类型的非常强大的方法。当然，接口可以强制实现需要存在的成员，但它们也可以仅仅作为空标记接口，作为将明确元数据引入程序集的方式。
- en: In the next chapter, we will dive into how we can make full use of custom attributes
    to provide explicit metadata for your applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何充分利用自定义属性为您的应用程序提供明确的元数据。
