<html><head></head><body>
        

                            
                    <h1 class="header-title">Command</h1>
                
            
            
                
<p>I have to admit that the Command pattern might be hard to understand at first. I know that it took me time to master it. Even if its name indicates its core purpose, its actual application is not apparent at first. But once you start playing around with it and comprehend its intricacies, it can become a sturdy pattern to apply when designing specific types of systems, such as user interfaces. Its primary purpose is to offer a way to encapsulate data that is needed to execute an operation or trigger an event at a particular moment.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basic principles behind the Command pattern</li>
<li>Implementing a Universal Controller that we can control multiple devices with</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The following chapter is hands on, so you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following specific Unity engine and C# language concept:</p>
<ul>
<li>Constructors</li>
</ul>
<p>If you are unfamiliar with this concept, please review it before moving forward.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2Our6OF">http://bit.ly/2Our6OF</a></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The basics of the Command pattern</h1>
                
            
            
                
<p>The Command pattern is a solution that makes it possible to centralize the process of invoking specific commands on objects. A real-world correlation I keep in mind when thinking about the Command pattern is a <em>Universal Controller</em>. Back in the day, before the internet and smartphones, most living rooms had multiple devices, each with a specific functionality. You had a stereo to play music, a TV to watch shows, a VHS to play tapes, and so on, but each system had a particular remote control associated with it, so this often caused confusion because of the variety of controllers you needed to manage.</p>
<p>Due to this, the programmable <em>Universal Controller</em> was invented, which resolved this issue and allowed you to control multiple devices from a single remote. This approach worked because a <em>Universal Controller</em> had a standard set of buttons that you could associate with commands and devices.</p>
<p>In a way, the Command pattern is very similar to the concept of a <em>Universal Controller</em> because it permits you to link and invoke specific commands on objects that can handle requests.</p>
<p>Let's review the following diagram, which is of a typical implementation of the Command pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8cad29e3-cc4d-44ca-a948-c53825d38454.png"/></p>
<p class="mce-root"/>
<p>Trying to learn about the Command pattern by looking at a diagram is not the right approach, but it does help us isolate the fundamental classes that are participating in this pattern:</p>
<ul>
<li>An <kbd>Invoker</kbd> is an object that knows how to execute a command and can also do the bookkeeping of executed commands.</li>
<li>The <kbd>Receiver</kbd> is a type of object that can receive commands and execute them.</li>
<li>The <kbd>CommandBase</kbd> is usually an interface or abstract class for concrete command classes. It's the primary layer of abstraction of this pattern.</li>
</ul>
<p>These core classes encapsulate all the information that's needed to execute a command at a specific moment. This will be made more evident when we implement our use case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p class="mce-root">Similar to patterns such as the Strategy and State, the main reason that programmers seem to avoid using the Command pattern is because of its <em>wordiness</em>.<br/>
<br/>
These are the main benefits of the Command pattern:</p>
<ul>
<li class="mce-root"><strong>Sequencing and timing</strong>: The Command pattern gives you the flexibility of executing commands in a sequence or within a specific time frame</li>
<li class="mce-root"><strong>Undo/Redo</strong>: The Command pattern is often used to implement bookkeeping features that permit to rollback commands in specific orders</li>
<li class="mce-root"><strong>Extensibility</strong>: A typical advantage of Behavioral patterns is that they give you the ability to add behaviors with minimal changes having to be made to the main classes</li>
</ul>
<p>These are the drawbacks of the Command pattern:</p>
<ul>
<li><strong>Verbosity</strong>: A common disadvantage of this type of pattern is that it makes your code very verbose and adds a lot more classes to your code base</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p>As a use case, we will actually implement a Universal Controller that will permit us to control multiple devices, including a TV and radio. The main reason we are going to use the Universal Controller concept as an example is because it's going to be easier for us to learn the intricacies of the Command pattern, which we will do by implementing a system that is directly related to managing the invocation of commands on specific objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>Implementing the Command pattern with a specific use case is the best way to master it. The example we are going to write is a perfect fit for the Command pattern because it's all about sending commands to specific receivers:</p>
<ol>
<li>For our first class, we will need to declare the <kbd>RemoteControlDevice</kbd> type in the form of an abstract class:</li>
</ol>
<pre style="padding-left: 60px">abstract class RemoteControlDevice<br/>{<br/>    public abstract void TurnOn();<br/>    public abstract void TurnOff();<br/>}</pre>
<ol start="2">
<li>Next up is the <kbd>Command</kbd> class, which is our core type for this pattern:</li>
</ol>
<pre style="padding-left: 60px">abstract class Command<br/>{<br/>    protected RemoteControlDevice m_Receiver;<br/><br/>    public Command(RemoteControlDevice receiver)<br/>    {<br/>        m_Receiver = receiver;<br/>    }<br/><br/>    public abstract void Execute();<br/>}</pre>
<p style="padding-left: 60px">As we can see, its primary responsibility is to assign a <kbd>Receiver</kbd> object and <kbd>Execute()</kbd> a command.</p>
<p class="mce-root"/>
<ol start="3">
<li>Now, let's implement concrete Command classes, each with their unique responsibility. First off, let's implement <kbd>TurnOnCommand</kbd>, which is used to turn on our devices (receivers):</li>
</ol>
<pre style="padding-left: 60px">class TurnOnCommand : Command<br/>{<br/>    public TurnOnCommand(RemoteControlDevice receiver) : base(receiver)<br/>    {<br/>    }<br/><br/>    public override void Execute()<br/>    {<br/>        m_Receiver.TurnOn();<br/>    }<br/>}</pre>
<ol start="4">
<li>Next up is our <kbd>TurnOffCommand</kbd>, which will, of course, turn off our devices (receivers):</li>
</ol>
<pre style="padding-left: 60px">class TurnOffCommand : Command<br/>{<br/>    public TurnOffCommand(RemoteControlDevice receiver) : base(receiver)<br/>    {<br/>    }<br/><br/>    public override void Execute()<br/>    {<br/>        m_Receiver.TurnOff();<br/>    }<br/>}</pre>
<ol start="5">
<li>There's also our <kbd>KillSwitchCommand</kbd>, which is unique:</li>
</ol>
<pre style="padding-left: 60px">class KillSwitchCommand : Command<br/>{<br/>    private RemoteControlDevice[] m_Devices;<br/>    private static RemoteControlDevice receiver;<br/><br/>    public KillSwitchCommand(RemoteControlDevice[] devices) : base(receiver)<br/>    {<br/>        m_Devices = devices;<br/>    }<br/><br/>    public override void Execute()<br/>    {<br/>        foreach (RemoteControlDevice device in m_Devices)<br/>        {<br/>            device.TurnOff();<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As we can see, <kbd>KillSwitchCommand</kbd> doesn't merely call the <kbd>Execute()</kbd> function on a <kbd>Receiver</kbd> object, but goes through a list of devices and calls the <kbd>TurnOff()</kbd> function on each of them. This means that we are batching the execution of a specific command.</p>
<ol start="6">
<li>Now we need to implement our devices that receive the orders to execute specific commands. Our first receiver is <kbd>Television</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>class TelevisionReceiver : RemoteControlDevice<br/>{<br/>    public override void TurnOn()<br/>    {<br/>        Debug.Log("TV turned on.");<br/>    }<br/><br/>    public override void TurnOff()<br/>    {<br/>        Debug.Log("TV turned off.");<br/>    }<br/>}</pre>
<ol start="7">
<li>Our next receiver is <kbd>Radio</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>class RadioReceiver : RemoteControlDevice<br/>{<br/>    public override void TurnOn()<br/>    {<br/>        Debug.Log("Radio is turned on.");<br/>    }<br/><br/>    public override void TurnOff()<br/>    {<br/>        Debug.Log("Radio is turned off.");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As we can see, both receivers have implemented the <kbd>TurnOn()</kbd> and <kbd>TurnOff()</kbd> functions. They are thus encapsulating the details of their unique behaviors.</p>
<ol start="8">
<li>Furthermore, let's implement a vital player of the <kbd>Command pattern</kbd>, <kbd>Invoker</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class Invoker<br/>{<br/>    private Command m_Command;<br/><br/>    public void SetCommand(Command command)<br/>    {<br/>        m_Command = command;<br/>    }<br/><br/>    public void ExecuteCommand()<br/>    {<br/>        m_Command.Execute();<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This example of <kbd>Invoker</kbd> is straightforward but can easily be extended to bookkeep the commands that are executed through it.</p>
<ol start="9">
<li>Finally, we have our <kbd>Client</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    private RemoteControlDevice m_RadioReceiver;<br/>    private RemoteControlDevice m_TelevisionReceiver;<br/>    private RemoteControlDevice[] m_Devices = new RemoteControlDevice[2];<br/><br/>    void Start()<br/>    {<br/>        m_RadioReceiver = new RadioReceiver();<br/>        m_TelevisionReceiver = new TelevisionReceiver();<br/><br/>        m_Devices[0] = m_RadioReceiver;<br/>        m_Devices[1] = m_TelevisionReceiver;<br/>    }<br/><br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.O))<br/>        {<br/>            Command commandTV = new TurnOnCommand(m_Devices[0]);<br/>            Command commandRadio = new TurnOnCommand(m_Devices[1]);<br/>            <br/>            Invoker invoker = new Invoker();<br/>            <br/>            invoker.SetCommand(commandTV);<br/>            invoker.ExecuteCommand();<br/><br/>            invoker.SetCommand(commandRadio);<br/>            invoker.ExecuteCommand();<br/>        }<br/><br/>        if (Input.GetKeyDown(KeyCode.K))<br/>        {<br/>            Command commandKill = new KillSwitchCommand(m_Devices);<br/>            Invoker invoker = new Invoker();<br/>            invoker.SetCommand(commandKill);<br/>            invoker.ExecuteCommand();<br/>        }<br/>    }<br/>}</pre>
<p>You will notice that there's a specific sequence of calls to be made when invoking a command:</p>
<ol>
<li>Initialize a new Command</li>
<li>Pass it to <kbd>Invoker</kbd></li>
<li><kbd>Invoker</kbd> executes the specified Command</li>
</ol>
<p>With this approach, we are maintaining a consistent channel of communication between those that invoke commands and those that receive them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we reviewed the Command pattern, a unique pattern that tends to confuse a lot of programmers at first because its core usefulness is not always apparent. But once you apply it correctly, it does offer a lot of extensibility when implementing systems that are dependent on executing commands in specific orders on multiple components.<br/>
<br/>
Next up is the Observer pattern, a pattern that's more easily understandable than Command and is the core of C#'s event system.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Practice exercise</h1>
                
            
            
                
<p>The Command pattern is often used to implement the classic undo/redo functionality that you find in most text editors. In our code example, we implemented the groundwork to support this feature. So, as a practice exercise, I recommend that you integrate your own undo/redo feature. You can find cues on the best approach to this in the <kbd>Invoker</kbd> and <kbd>KillSwitchCommand</kbd> classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Applying UML and Patterns,</em> by Craig Larman: <a href="http://www.craiglarman.com">http://www.craiglarman.com</a></li>
</ul>


            

            
        
    </body></html>