- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Getting Started with SignalR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SignalR 入门
- en: In [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012), we introduced the concept
    of real-time web APIs. Various technologies can be used to implement real-time
    web APIs, such as gRPC streaming, long polling, **Server-Sent Events** (**SSE**),
    WebSockets, and so on. Microsoft provides an open-source library called SignalR
    to simplify the implementation of real-time web APIs. In this chapter, we will
    introduce the basics of SignalR and how to use SignalR to implement real-time
    web APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B18971_01.xhtml#_idTextAnchor012) 中，我们介绍了实时 Web API 的概念。可以使用各种技术来实现实时
    Web API，例如 gRPC 流、长轮询、**服务器端事件**（**SSE**）、WebSockets 等。Microsoft 提供了一个名为 SignalR
    的开源库，用于简化实时 Web API 的实现。在本章中，我们将介绍 SignalR 的基础知识以及如何使用 SignalR 实现实时 Web API。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Recap of real-time web APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时 Web API 概述
- en: Setting up SignalR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 SignalR
- en: Building SignalR clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 SignalR 客户端
- en: Using authentication and authorization in SignalR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SignalR 中使用身份验证和授权
- en: Managing users and groups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户和组
- en: Sending messages from other services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他服务发送消息
- en: Configuring SignalR hubs and clients
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 SignalR 端点和客户端
- en: By the end of this chapter, you will be able to use SignalR to implement real-time
    web APIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用 SignalR 实现实时 Web API。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the steps in this chapter, you can download the source code from the
    GitHub repository at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13).
    You can use VS 2022 or VS Code to open the solutions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的步骤，您可以从 GitHub 仓库 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13)
    下载源代码。您可以使用 VS 2022 或 VS Code 打开解决方案。
- en: 'You also need to install the following software:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装以下软件：
- en: '**Node.js**: Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript
    engine. You can download the latest version of Node.js from [https://nodejs.org/en/](https://nodejs.org/en/).
    We will use it to install the required packages for the TypeScript client.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**：Node.js 是基于 Chrome 的 V8 JavaScript 引擎构建的 JavaScript 运行时环境。您可以从
    [https://nodejs.org/en/](https://nodejs.org/en/) 下载 Node.js 的最新版本。我们将使用它来安装 TypeScript
    客户端所需的包。'
- en: Recap of real-time web APIs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时 Web API 概述
- en: We introduced a few technologies that can be used to implement real-time web
    APIs in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012). Each technology has its
    pros and cons. To simplify the implementation of real-time web APIs, Microsoft
    provides SignalR, which supports multiple transports, such as WebSockets, SSE,
    and long polling. SignalR will automatically choose the best transport based on
    the client’s capabilities. On top of that, SignalR provides a simple programming
    model to implement real-time web APIs. Developers do not need to worry about the
    underlying transport details; instead, they can focus on the business logic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B18971_01.xhtml#_idTextAnchor012) 中，我们介绍了几种可以用于实现实时 Web API 的技术。每种技术都有其优缺点。为了简化实时
    Web API 的实现，Microsoft 提供了 SignalR，它支持多种传输方式，如 WebSockets、SSE 和长轮询。SignalR 将根据客户端的能力自动选择最佳传输方式。除此之外，SignalR
    还提供了一个简单的编程模型来实现实时 Web API。开发者无需担心底层传输细节；相反，他们可以专注于业务逻辑。
- en: 'SignalR was first introduced for ASP.NET in 2013\. As of now, SignalR has been
    rewritten for ASP.NET Core and is included in the ASP.NET Core framework. So,
    there are two different versions of SignalR: one for ASP.NET and one for ASP.NET
    Core. If you are using ASP.NET Core, you do not need to install any additional
    packages to use SignalR. There are also some differences between the ASP.NET version
    and the ASP.NET Core version of SignalR. For example, ASP.NET Core SignalR does
    not support Microsoft Internet Explorer. However, most modern applications are
    targeting modern browsers, so this should not be a big issue. In this chapter,
    we will focus on the ASP.NET Core version of SignalR.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 首次在 2013 年为 ASP.NET 介绍。截至目前，SignalR 已经为 ASP.NET Core 重写，并包含在 ASP.NET
    Core 框架中。因此，存在两个不同的 SignalR 版本：一个用于 ASP.NET，另一个用于 ASP.NET Core。如果您正在使用 ASP.NET
    Core，则无需安装任何额外的包即可使用 SignalR。ASP.NET 版本和 ASP.NET Core 版本的 SignalR 之间也有一些差异。例如，ASP.NET
    Core SignalR 不支持 Microsoft Internet Explorer。然而，大多数现代应用程序都针对现代浏览器，因此这不应成为大问题。在本章中，我们将重点关注
    ASP.NET Core 版本的 SignalR。
- en: 'Unlike REST APIs, SignalR clients need to install a SignalR client library
    to communicate with SignalR servers. SignalR provides a couple of client libraries
    for different platforms:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 REST API 不同，SignalR 客户端需要安装 SignalR 客户端库才能与 SignalR 服务器通信。SignalR 为不同的平台提供了一些客户端库：
- en: '**JavaScript client**: This is the most used client library because it can
    be used in both browsers and Node.js applications'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 客户端**：这是最常用的客户端库，因为它可以在浏览器和 Node.js 应用程序中使用'
- en: '**.NET client**: This client can be used for .NET applications, such as Xamarin,
    **Windows Presentation Foundation** (**WPF**), and Blazor'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 客户端**：此客户端可用于 .NET 应用程序，例如 Xamarin、**Windows 表面基础**（**WPF**）和 Blazor'
- en: '**Java client**: This client supports Java 8 and later'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 客户端**：此客户端支持 Java 8 及更高版本'
- en: Other clients, such as the C++ client and Swift client, are not officially supported
    by Microsoft.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其他客户端，如 C++ 客户端和 Swift 客户端，不是由 Microsoft 正式支持的。
- en: SignalR is a good choice for building real-time web APIs. For example, you can
    use SignalR to build a chat application, a real-time dashboard, voting applications,
    whiteboard applications, and so on. SignalR can push data to specific clients
    or groups of clients. It automatically manages connections between clients and
    servers. In the next section, we will introduce the basics of SignalR and build
    a simple chat application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 是构建实时 Web API 的好选择。例如，您可以使用 SignalR 构建聊天应用程序、实时仪表板、投票应用程序、白板应用程序等。SignalR
    可以将数据推送到特定的客户端或客户端组。它自动管理客户端和服务器之间的连接。在下一节中，我们将介绍 SignalR 的基础知识并构建一个简单的聊天应用程序。
- en: Setting up SignalR
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SignalR
- en: 'In this section, we will build a simple chat application using SignalR. The
    chat application will allow users to send messages to a public chat room. The
    messages will be broadcast to all connected clients. This application contains
    four projects:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 SignalR 构建一个简单的聊天应用程序。该聊天应用程序将允许用户向公共聊天室发送消息。消息将被广播到所有已连接的客户端。此应用程序包含四个项目：
- en: '`ChatApp.Server`: This is the ASP.NET Core web API project that provides a
    SignalR hub'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChatApp.Server`：这是提供 SignalR 中心的 ASP.NET Core Web API 项目'
- en: '`ChatApp.TypeScriptClient`: This is a client application written in TypeScript'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChatApp.TypeScriptClient`：这是一个用 TypeScript 编写的客户端应用程序'
- en: '`ChatApp.BlazorClient`: This is a client application written in Blazor, which
    is a web framework for building client-side applications using C#'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChatApp.BlazorClient`：这是一个用 Blazor 编写的客户端应用程序，Blazor 是一个用于使用 C# 构建客户端应用程序的
    Web 框架'
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code of this sample is based on the official SignalR sample provided by
    Microsoft. You can find the original source code at [https://github.com/aspnet/SignalR-samples/tree/main/ChatSample](https://github.com/aspnet/SignalR-samples/tree/main/ChatSample).
    We added the Blazor and MAUI clients to the sample.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码基于 Microsoft 提供的官方 SignalR 示例。您可以在 [https://github.com/aspnet/SignalR-samples/tree/main/ChatSample](https://github.com/aspnet/SignalR-samples/tree/main/ChatSample)
    找到原始源代码。我们向示例中添加了 Blazor 和 MAUI 客户端。
- en: The `ChatApp.Server` application is a simple ASP.NET Core web API application
    that is used to provide a SignalR hub. A SignalR hub is a class to manage connections
    between clients and servers. It is a high-level abstraction for SignalR real-time
    communication. A SignalR hub can be used to send messages to clients and receive
    messages from clients. A SignalR hub can also manage users and groups of clients.
    In ASP.NET Core SignalR, a hub is defined as a middleware component, so we can
    easily add it to the ASP.NET Core pipeline.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatApp.Server` 应用程序是一个简单的 ASP.NET Core Web API 应用程序，用于提供 SignalR 中心。SignalR
    中心是一个用于管理客户端和服务器之间连接的类。它是 SignalR 实时通信的高级抽象。SignalR 中心可以用于向客户端发送消息并从客户端接收消息。SignalR
    中心还可以管理用户和客户端组。在 ASP.NET Core SignalR 中，中心被定义为中间件组件，因此我们可以轻松将其添加到 ASP.NET Core
    管道中。'
- en: 'A SignalR hub has a `Clients` property to manage connections between the server
    and the client. When a user connects to the SignalR hub, a new connection is created.
    One user can have multiple connections. The `Clients` property has some methods
    to manage connections:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 中心有一个 `Clients` 属性来管理服务器和客户端之间的连接。当用户连接到 SignalR 中心时，会创建一个新的连接。一个用户可以有多个连接。`Clients`
    属性有一些用于管理连接的方法：
- en: '`All` is used to call a method on all connected clients.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`All` 用于在所有已连接的客户端上调用方法。'
- en: '`Caller` is used to call a method on the caller.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Caller` 用于在调用者上调用方法。'
- en: '`Others` is used to call a method on all connected clients except the caller.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Others` 用于在除调用者之外的所有已连接客户端上调用方法。'
- en: '`Client` is used to call a method on a specific client.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client` 用于在特定客户端上调用方法。'
- en: '`Clients` is used to call a method on specific connected clients.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clients` 用于在特定的已连接客户端上调用方法。'
- en: '`Group` is used to call a method on a group of clients.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Group` 用于在客户端组上调用方法。'
- en: '`Groups` is used to call a method on multiple groups of clients.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Groups` 用于在多个客户端组上调用方法。'
- en: '`User` is used to call a method on a specific user. Note that one user may
    have multiple connections.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User` 用于在特定用户上调用方法。请注意，一个用户可能有多个连接。'
- en: '`Users` is used to call a method on specified users, including all connections.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Users` 用于在指定的用户上调用方法，包括所有连接。'
- en: '`AllExcept` is used to call a method on all connected clients except specified
    clients.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllExcept` 用于在除了指定客户端之外的所有已连接客户端上调用方法。'
- en: '`GroupExcept` is used to call a method on a group of clients except specified
    clients.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupExcept` 用于在除了指定客户端之外的一组客户端上调用方法。'
- en: '`OthersInGroup` is used to call a method on all clients in a group except the
    caller.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OthersInGroup` 用于在除了调用者之外的一组所有客户端上调用方法。'
- en: We will explore some of these methods in the following sections. You can find
    the complete code of the sample in the `chapter13/v1` folder of the GitHub repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨这些方法中的一些。您可以在 GitHub 仓库的 `chapter13/v1` 文件夹中找到示例的完整代码。
- en: 'Next, follow these steps to create a new solution and set up a `ChatApp.Server`
    project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照以下步骤创建一个新的解决方案并设置 `ChatApp.Server` 项目：
- en: 'Create a new solution called `ChatApp` using the `dotnet new` `sln` command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet new` `sln` 命令创建一个名为 `ChatApp` 的新解决方案：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Program.cs file and add the following code:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Program.cs 文件中添加以下代码：
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'namespace ChatApp.Server.Hubs;public class ChatHub : Hub{    public Task SendMessage(string
    user, string message)    {        return Clients.All.SendAsync("ReceiveMessage",
    username, message);    }}'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'namespace ChatApp.Server.Hubs;public class ChatHub : Hub{    public Task SendMessage(string
    user, string message)    {        return Clients.All.SendAsync("ReceiveMessage",
    username, message);    }}'
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to map the SignalR hub to a URL. Add the following code to the
    `Program.cs` file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 SignalR hub 映射到一个 URL。将以下代码添加到 `Program.cs` 文件中：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Check the `launchSettings.json` file in the `Properties` folder. The default
    `launchSettings.json` file contains `http` and `https` URLs. By default, the `dotnet
    run` command will use the first `http` profile. We can specify for the launch
    profile to use the `https` URL. Use the following command to run the application:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `Properties` 文件夹中的 `launchSettings.json` 文件。默认的 `launchSettings.json` 文件包含
    `http` 和 `https` URL。默认情况下，`dotnet run` 命令将使用第一个 `http` 配置文件。我们可以指定启动配置文件使用 `https`
    URL。使用以下命令运行应用程序：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The SignalR hub is now ready for use. To test it, however, a client must install
    a SignalR client library in order to communicate with the hub. In the following
    section, we will construct client applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR hub 现在已准备好使用。但是，为了测试它，客户端必须安装 SignalR 客户端库才能与 hub 进行通信。在下一节中，我们将构建客户端应用程序。
- en: Building SignalR clients
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 SignalR 客户端
- en: This section will demonstrate how to use SignalR in different platforms by building
    three SignalR clients that consume the same SignalR hub provided by the `ChatApp.Server`
    application. The code for SignalR is largely the same across platforms, making
    it easy to learn and implement in your own applications. As such, you can refer
    to any of these applications to gain an understanding of how to consume a SignalR
    service in your client applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将通过构建三个由 `ChatApp.Server` 应用程序提供的相同 SignalR hub 消费者 SignalR 客户端，来演示如何在不同的平台上使用
    SignalR。SignalR 的代码在各个平台上基本相同，这使得它在您自己的应用程序中学习和实现变得容易。因此，您可以参考这些应用程序中的任何一个来了解如何在客户端应用程序中消费
    SignalR 服务。
- en: Building a TypeScript client
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 TypeScript 客户端
- en: The first client we will build is a TypeScript client. This application is just
    a normal HTML page that uses the SignalR JavaScript client library to communicate
    with the SignalR hub. TypeScript is a superset of JavaScript that provides static
    typing and other features to help developers write better JavaScript code. TypeScript
    code is compiled into JavaScript code, so it can run in any JavaScript runtime,
    such as browsers and Node.js. To learn more about TypeScript, you can visit the
    official website at [https://www.typescriptlang.org/](https://www.typescriptlang.org/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的第一个客户端是一个 TypeScript 客户端。这个应用程序只是一个普通的 HTML 页面，它使用 SignalR JavaScript
    客户端库与 SignalR hub 进行通信。TypeScript 是 JavaScript 的超集，它提供了静态类型和其他功能，以帮助开发者编写更好的 JavaScript
    代码。TypeScript 代码编译成 JavaScript 代码，因此它可以在任何 JavaScript 运行时中运行，例如浏览器和 Node.js。要了解更多关于
    TypeScript 的信息，您可以访问官方网站 [https://www.typescriptlang.org/](https://www.typescriptlang.org/)。
- en: 'To use TypeScript in the application, we need to install it. You can do so
    using the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After installing TypeScript, you can use the following command to check the
    version:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you see the version number, it means that TypeScript is installed successfully.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, follow these steps to create a TypeScript client:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `ChatApp.TypeScriptClient` in the solution folder.
    Then, create a `src` folder in the `ChatApp.TypeScriptClient` folder. The `src`
    folder is used to store the source code of the TypeScript client.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named `index.html` in the `src` folder and add the following
    code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code creates a simple HTML page that contains a textbox and a
    button. The `ul` element is used to display messages.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file named `tsconfig.json` in the `ChatApp.TypeScriptClient` folder
    and add the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is the configuration file for the TypeScript compiler. It
    specifies the target version of JavaScript, the module system, and other options.
    It also specifies the TypeScript files to compile, such as `app.ts`. We will create
    an `app.ts` file in *step 6*.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to set up `npm` so that we can install the required packages.
    Use the following command to initialize `npm`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to install the required packages. Use the following command to
    install the required packages:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new file named `app.ts` in the `src` folder and add the following
    code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code creates a SignalR connection to the SignalR hub. The `connection`
    object is used to send messages to the SignalR hub and receive messages from the
    SignalR hub. The `withURL()` method is used to specify the URL of the SignalR
    hub. In this case, we use `https://localhost:7159/chatHub` as the URL. If your
    SignalR hub is hosted on a different URL, you need to change it accordingly.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the page is loaded, the `connection` object has a couple of methods used
    in this sample:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`on()` method takes two parameters: the first parameter is the name of the
    method, which is `RecieveMessage()`, as we defined in the `ChatHub` class, and
    the second parameter is a callback function that is called when the message is
    received.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invoke()` method is called when the user clicks the `invoke()` method takes
    three parameters: the first parameter is the name of the method we want to invoke
    on the SignalR hub, which is `SendMessage()`, as we defined in the `ChatHub` class,
    the second parameter is the username, and the third parameter is the message.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to use the correct method names. Otherwise, the client will not be
    able to communicate with the SignalR hub.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to compile the TypeScript code to JavaScript code. We will use
    Gulp to automate the compilation process. If you prefer to use other tools, such
    as Webpack, you can use them as well. Use the following command to install Gulp
    globally:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'gulpfile.js in the ChatApp.TypeScriptClient folder and add the following code:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `gulp` configuration file defines some tasks that are used to compile TypeScript
    code to JavaScript and generate a bundle file. Additionally, it copies HTML files
    to the `dist` folder, which is used to store the compiled JavaScript code and
    HTML files. If desired, the folder name can be changed. The bundle file loads
    the SignalR JavaScript client library and the compiled JavaScript code.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gulp` 配置文件定义了一些任务，用于将 TypeScript 代码编译成 JavaScript 并生成捆绑文件。此外，它将 HTML 文件复制到
    `dist` 文件夹，该文件夹用于存储编译后的 JavaScript 代码和 HTML 文件。如果需要，可以更改文件夹名称。捆绑文件加载 SignalR JavaScript
    客户端库和编译后的 JavaScript 代码。'
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a script to the `package.json` file to run `gulp` tasks:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中添加一个脚本来运行 `gulp` 任务：
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The complete `package.json` file should look like this:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的 `package.json` 文件应如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, update the `index.html` file in the `src` folder to load the bundle file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `src` 文件夹中的 `index.html` 文件以加载捆绑文件：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the following command to compile the TypeScript code and copy the HTML
    files to the `dist` folder:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以编译 TypeScript 代码并将 HTML 文件复制到 `dist` 文件夹：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Figure 13.1 – Running the TypeScript client in VS Code](img/B18971_13_01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 在 VS Code 中运行 TypeScript 客户端](img/B18971_13_01.jpg)'
- en: Figure 13.1 – Running the TypeScript client in VS Code
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 在 VS Code 中运行 TypeScript 客户端
- en: You can also try some other tools, such as `http-server`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试一些其他工具，例如 `http-server`。
- en: 'Now, start the SignalR server by running the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令启动 SignalR 服务器：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: // Enable CORSvar corsPolicy = new CorsPolicyBuilder()    .AllowAnyHeader()    .AllowAnyMethod()    .AllowCredentials()    .WithOrigins("http://127.0.0.1:3000")    .Build();builder.Services.AddCors(options
    =>{    options.AddPolicy("CorsPolicy", corsPolicy);});
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 启用 CORSvar corsPolicy = new CorsPolicyBuilder()    .AllowAnyHeader()    .AllowAnyMethod()    .AllowCredentials()    .WithOrigins("http://127.0.0.1:3000")    .Build();builder.Services.AddCors(options
    =>{    options.AddPolicy("CorsPolicy", corsPolicy);});
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Restart the SignalR server and refresh the web page. You should see the **Send**
    button is enabled. Enter a username and a message and click the **Send** button.
    You should see the message displayed in a list, as shown next:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动 SignalR 服务器并刷新网页。您应该看到 **发送** 按钮已启用。输入用户名和消息，然后点击 **发送** 按钮。您应该看到消息显示在列表中，如下所示：
- en: '![Figure 13.2 – Sending a message from the TypeScript client](img/B18971_13_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 从 TypeScript 客户端发送消息](img/B18971_13_02.jpg)'
- en: Figure 13.2 – Sending a message from the TypeScript client
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 从 TypeScript 客户端发送消息
- en: 'Open another browser tab and enter the same URL. Enter a different username
    and a message and click the **Send** button. You should see the message displayed
    in both browser tabs, as shown next:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个浏览器标签，并输入相同的 URL。输入不同的用户名和消息，然后点击 **发送** 按钮。您应该看到两个浏览器标签中都显示了消息，如下所示：
- en: '![Figure 13.3 – Sending a message from another browser tab](img/B18971_13_03.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 从另一个浏览器标签发送消息](img/B18971_13_03.jpg)'
- en: Figure 13.3 – Sending a message from another browser tab
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 从另一个浏览器标签发送消息
- en: The TypeScript client is now complete. This is a very simple client that does
    not use any JavaScript frameworks. The world of frontend development is changing
    rapidly. If you encounter any issues when testing the sample code, you can use
    any other JavaScript frameworks you like, such as React, Angular, or Vue.js. The
    code for SignalR is largely the same for different JavaScript frameworks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 客户端现在已完成。这是一个非常简单的客户端，它不使用任何 JavaScript 框架。前端开发的世界正在迅速变化。如果在测试示例代码时遇到任何问题，可以使用您喜欢的任何其他
    JavaScript 框架，例如 React、Angular 或 Vue.js。SignalR 的代码对于不同的 JavaScript 框架基本相同。
- en: Building a Blazor client
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Blazor 客户端
- en: 'The second client we will build is a Blazor client. Blazor is a web framework
    for building client-side applications using C#. Blazor was first introduced as
    a part of ASP.NET Core 3.0 in 2018\. Blazor supports different hosting models:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的第二个客户端是一个 Blazor 客户端。Blazor 是一个使用 C# 构建客户端应用程序的 Web 框架。Blazor 首次在 2018
    年作为 ASP.NET Core 3.0 的一部分被引入。Blazor 支持不同的托管模型：
- en: '**Blazor Server**: In this hosting model, the Blazor application is hosted
    on an ASP.NET Core server. Remote clients connect to the server using SignalR.
    The server is responsible for handling user interactions and updating the UI over
    a SignalR connection. The application can use the full power of the .NET ecosystem
    and all ASP.NET Core features. This hosting model also allows the client to download
    a small amount of code, meaning the application loads fast, but it requires a
    persistent connection to the server. If the SignalR connection is lost, the application
    will not work.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor Server**：在这种托管模型中，Blazor应用程序托管在ASP.NET Core服务器上。远程客户端通过SignalR连接到服务器。服务器负责处理用户交互并通过SignalR连接更新UI。应用程序可以使用.NET生态系统的全部功能和所有ASP.NET
    Core特性。这种托管模型还允许客户端下载少量代码，这意味着应用程序加载速度快，但需要持续连接到服务器。如果SignalR连接丢失，应用程序将无法工作。'
- en: '**Blazor WebAssembly**: This hosting model runs the Blazor application on a
    WebAssembly .NET runtime in the browser. The Blazor application is downloaded
    to the client, which means that this model requires a larger download size than
    the Blazor Server model. When a Blazor WebAssembly application is hosted within
    an ASP.NET Core application, it is called *hosted Blazor WebAssembly*. The hosted
    Blazor WebAssembly application can share code with the ASP.NET Core application.
    When a Blazor WebAssembly application is hosted in a static website without server-side
    code, it is called *standalone Blazor WebAssembly*. A standalone Blazor WebAssembly
    application acts like a pure client-side application, such as a React application,
    so it can be hosted on any web server or a **content delivery network** (**CDN**).
    Blazor WebAssembly applications can work offline, but the performance depends
    on the client’s hardware.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor WebAssembly**：这种托管模型在浏览器中的WebAssembly .NET运行时上运行Blazor应用程序。Blazor应用程序被下载到客户端，这意味着这种模型比Blazor
    Server模型需要更大的下载量。当一个Blazor WebAssembly应用程序在ASP.NET Core应用程序内托管时，它被称为*托管Blazor
    WebAssembly*。托管Blazor WebAssembly应用程序可以与ASP.NET Core应用程序共享代码。当一个Blazor WebAssembly应用程序在没有服务器端代码的静态网站上托管时，它被称为*独立Blazor
    WebAssembly*。独立的Blazor WebAssembly应用程序类似于纯客户端应用程序，例如React应用程序，因此它可以托管在任何Web服务器或**内容分发网络**（**CDN**）上。Blazor
    WebAssembly应用程序可以离线工作，但性能取决于客户端的硬件。'
- en: '**Blazor Hybrid**: This model allows a Blazor application to run in a .NET
    native app framework, such as WPF, Windows Forms, and MAUI. This model combines
    the power of the web and native applications, and it can use the full power of
    the .NET platform. It is suitable for building cross-platform applications because
    the Blazor code can be shared across different platforms. However, it is still
    required to package the application for different platforms.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor混合模式**：这种模型允许Blazor应用程序在.NET原生应用程序框架（如WPF、Windows Forms和MAUI）中运行。这种模型结合了Web和原生应用程序的力量，并可以使用.NET平台的全部功能。它适合构建跨平台应用程序，因为Blazor代码可以在不同的平台上共享。然而，仍然需要为不同的平台打包应用程序。'
- en: In this sample application, we will use standalone Blazor WebAssembly to build
    the client application because a web-based application is one of the most seen
    scenarios. But it is also possible to use similar code for other hosting models.
    ASP.NET Core 8 brings some improvements to Blazor. To learn more about Blazor,
    you can visit the official website at [https://learn.microsoft.com/en-us/aspnet/core/blazor/](https://learn.microsoft.com/en-us/aspnet/core/blazor/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例应用程序中，我们将使用独立的Blazor WebAssembly来构建客户端应用程序，因为基于Web的应用程序是最常见的场景之一。但也可以使用类似的代码为其他托管模型服务。ASP.NET
    Core 8为Blazor带来了一些改进。要了解更多关于Blazor的信息，您可以访问官方网站[https://learn.microsoft.com/en-us/aspnet/core/blazor/](https://learn.microsoft.com/en-us/aspnet/core/blazor/)。
- en: 'To create a Blazor WebAssembly application, follow these steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Blazor WebAssembly应用程序，请按照以下步骤操作：
- en: 'Navigate to the root folder of the `ChatApp.sln` solution. Create a new Blazor
    WebAssembly application called `ChatApp.BlazorClient` and add the project to the
    solution using the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`ChatApp.sln`解决方案的根目录。创建一个名为`ChatApp.BlazorClient`的新Blazor WebAssembly应用程序，并使用以下命令将其添加到解决方案中：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'page directive in the /Components/Pages/Home.razor file:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`/Components/Pages/Home.razor`文件中的页面指令：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `using` statement imports the SignalR client library to the `Home` component.
    The `implements IAsyncDisposable` statement indicates that the `Home` component
    implements the `IAsyncDisposable` interface. The `IAsyncDisposable` interface
    is used to dispose of resources asynchronously. We will use it to dispose of the
    SignalR connection when the component is no longer in use.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`using`语句将SignalR客户端库导入到`Home`组件中。`implements IAsyncDisposable`语句表示`Home`组件实现了`IAsyncDisposable`接口。`IAsyncDisposable`接口用于异步释放资源。我们将用它来在组件不再使用时释放SignalR连接。
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code to the end of the `Home.razor` file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Home.razor`文件的末尾：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Blazor utilizes the `@code` directive to incorporate C# code into components.
    In this instance, we have defined a few fields and methods for the `Home` component.
    If you compare this code to its TypeScript counterpart, you will find that the
    logic is very similar. The `OnInitializedAsync()` method is used to set up a SignalR
    connection, while the `SendMessage()` method is used to invoke the `SendMessage()`
    method of the SignalR hub to send a message. The `DisposeAsync()` method is used
    to dispose of the SignalR connection when the component is no longer in use. Additionally,
    the `StateHasChanged()` method is used to notify the component to re-render the
    UI.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Blazor利用`@code`指令将C#代码集成到组件中。在这个例子中，我们为`Home`组件定义了一些字段和方法。如果你将此代码与其TypeScript对应版本进行比较，你会发现逻辑非常相似。`OnInitializedAsync()`方法用于设置SignalR连接，而`SendMessage()`方法用于调用SignalR
    hub的`SendMessage()`方法来发送消息。`DisposeAsync()`方法用于在组件不再使用时释放SignalR连接。此外，`StateHasChanged()`方法用于通知组件重新渲染UI。
- en: 'Next, we need to bind these fields to the UI. Add the following code before
    the `@``code` directive:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这些字段绑定到UI上。在`@code`指令之前添加以下代码：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Blazor uses the `@` symbol to indicate a C# expression. The `@bind` directive
    is used to bind the value of the input element to the specified field. The `@onclick`
    directive is used to bind the click event to the specified method. The `@foreach`
    directive is used to iterate over the messages and display them in a list. If
    you are familiar with any modern JavaScript frameworks, such as React, Angular,
    or Vue.js, you will find some similarities between Blazor and these frameworks.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Blazor使用`@`符号来指示C#表达式。`@bind`指令用于将输入元素的值绑定到指定的字段。`@onclick`指令用于将点击事件绑定到指定的方法。`@foreach`指令用于遍历消息并在列表中显示它们。如果你熟悉任何现代JavaScript框架，如React、Angular或Vue.js，你会在Blazor和这些框架之间发现一些相似之处。
- en: 'Next, we need to configure the CORS policy for the SignalR server so that the
    Blazor client can connect to the SignalR hub. Check the `launchSettings.json`
    file in the `Properties` folder. Similar to the SignalR server application, we
    can use the `http` or `https` profile to run the Blazor client application. We
    will use the `https` file in this case. For example, the URL of the sample code
    uses `https://localhost:7093` to run the Blazor client application on the HTTPS
    profile. We need to update the CORS policy in the SignalR server. Update the `Program.cs`
    file of the `ChatApp.Server` project, as shown next:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为SignalR服务器配置CORS策略，以便Blazor客户端可以连接到SignalR hub。检查`Properties`文件夹中的`launchSettings.json`文件。与SignalR服务器应用程序类似，我们可以使用`http`或`https`配置文件来运行Blazor客户端应用程序。在这种情况下，我们将使用`https`配置文件。例如，示例代码的URL使用`https://localhost:7093`在HTTPS配置文件上运行Blazor客户端应用程序。我们需要更新SignalR服务器的CORS策略。更新`ChatApp.Server`项目的`Program.cs`文件，如下所示：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, the SignalR server can accept cross-origin requests from the Blazor client
    application.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，SignalR服务器可以接受来自Blazor客户端应用程序的跨源请求。
- en: 'Run the SignalR server application and the Blazor client application in separate
    terminals using the `dotnet run --launch-profile https` command. You can test
    the Blazor client application by opening the `https://localhost:7093` URL in the
    browser. The Blazor client can chat with the TypeScript client, as shown next:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run --launch-profile https`命令在单独的终端中运行SignalR服务器应用程序和Blazor客户端应用程序。你可以在浏览器中打开`https://localhost:7093`
    URL来测试Blazor客户端应用程序。Blazor客户端可以与TypeScript客户端进行聊天，如下所示：
- en: '![Figure 13.4 – Chatting between the Blazor client and the TypeScript client](img/B18971_13_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – Blazor客户端和TypeScript客户端之间的聊天](img/B18971_13_04.jpg)'
- en: Figure 13.4 – Chatting between the Blazor client and the TypeScript client
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – Blazor客户端和TypeScript客户端之间的聊天
- en: SignalR provides the convenience of real-time communication. Developers do not
    need to operate the underlying transport details; instead, they can use the SignalR
    `Hub` class to send and receive messages easily. In the next section, we will
    explore more features of a SignalR hub.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 提供了实时通信的便利性。开发者不需要操作底层传输细节；相反，他们可以使用 SignalR 的 `Hub` 类轻松发送和接收消息。在下一节中，我们将探讨
    SignalR 集线器（hub）的更多功能。
- en: Using authentication and authorization in SignalR
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SignalR 中使用身份验证和授权
- en: In the previous section, we used the `Hub` class to implement a simple chat
    app. The `Clients.All.SendAsync` method is used to send a message to all connected
    clients. Sometimes, we may want to send a message to a specific client or a group
    of clients. To manage users and groups, we need to know the identity of the user.
    In this section, we will explore how to use authentication and authorization in
    SignalR.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用 `Hub` 类实现了一个简单的聊天应用。`Clients.All.SendAsync` 方法用于向所有已连接的客户端发送消息。有时，我们可能想向特定的客户端或一组客户端发送消息。为了管理用户和组，我们需要知道用户的身份。在本节中，我们将探讨如何在
    SignalR 中使用身份验证和授权。
- en: By default, SignalR uses a `ClaimTypes.NameIdentifier` claim to differentiate
    users. The `ClaimTypes.NameIdentifier` claim is used to uniquely identify a user.
    We introduced claim-based authorization in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307),
    so we will follow the steps from that chapter to add authentication and authorization
    to the SignalR server application. If you are not familiar with ASP.NET Core authentication
    and authorization, you can refer to [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307)
    for more details.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SignalR 使用 `ClaimTypes.NameIdentifier` 断言来区分用户。`ClaimTypes.NameIdentifier`
    断言用于唯一标识用户。我们在 [*第 8 章*](B18971_08.xhtml#_idTextAnchor307) 中介绍了基于断言的授权，因此我们将遵循该章节的步骤将身份验证和授权添加到
    SignalR 服务器应用程序。如果您不熟悉 ASP.NET Core 身份验证和授权，您可以参考 [*第 8 章*](B18971_08.xhtml#_idTextAnchor307)
    获取更多详细信息。
- en: You can find the complete code of the sample in the `chapter13/v2` folder of
    the GitHub repository.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 仓库的 `chapter13/v2` 文件夹中找到示例代码的完整代码。
- en: Adding authentication and authorization to the SignalR server
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将身份验证和授权添加到 SignalR 服务器
- en: 'To add authentication and authorization to the SignalR server, follow these
    steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要将身份验证和授权添加到 SignalR 服务器，请按照以下步骤操作：
- en: 'Install the required packages using the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装所需的包：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a connection string in the `appsettings.json` file:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `appsettings.json` 文件中添加一个连接字符串：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add configurations for JWT tokens in the `appsettings.json` file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `appsettings.json` 文件中添加 JWT 令牌的配置：
- en: '[PRE30]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will use the same SignalR server as the authentication server. So, we will
    use the URL of the SignalR server as the audience and issuer. If you use a different
    authentication server, you need to change the audience and issuer accordingly.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用与身份验证服务器相同的 SignalR 服务器。因此，我们将使用 SignalR 服务器的 URL 作为受众和发行者。如果您使用不同的身份验证服务器，您需要相应地更改受众和发行者。
- en: 'SignalR needs an `IUserIdProvider` interface to get the user ID. Create a new
    folder named `Services` in the `ChatApp.Server` project. Then, create a new class
    called `NameUserIdProvider` in the `Services` folder:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SignalR 需要一个 `IUserIdProvider` 接口来获取用户 ID。在 `ChatApp.Server` 项目中创建一个名为 `Services`
    的新文件夹。然后，在 `Services` 文件夹中创建一个名为 `NameUserIdProvider` 的新类：
- en: '[PRE31]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code implements the `IUserIdProvider` interface. The `GetUserId`
    method returns the user ID of the current user. In this case, we use the username
    as the user ID. You can use any other unique value as the user ID. For example,
    if you want to use the email address as the user ID, you can create an `EmailBasedUserIdProvider`
    class as follows:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码实现了 `IUserIdProvider` 接口。`GetUserId` 方法返回当前用户的用户 ID。在这种情况下，我们使用用户名作为用户 ID。您可以使用任何其他唯一值作为用户
    ID。例如，如果您想使用电子邮件地址作为用户 ID，您可以创建一个名为 `EmailBasedUserIdProvider` 的类，如下所示：
- en: '[PRE32]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Update the `Program.cs` file to add authentication and authorization, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Program.cs` 文件以添加身份验证和授权，如下所示：
- en: '[PRE33]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code is similar to the code in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307).
    A difference is that we configured the `options.Events` property of the `JwtBearerOptions`
    object. The `OnMessageReceived` event is used to check the token in the query
    string. The reason is that WebSocket APIs and SSE do not support the standard
    `Authorization` header, so it is required to attach the token to the query string.
    If the token is found in the query string, it will be used to authenticate the
    user.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码与[*第8章*](B18971_08.xhtml#_idTextAnchor307)中的代码类似。一个区别是我们配置了`JwtBearerOptions`对象的`options.Events`属性。`OnMessageReceived`事件用于检查查询字符串中的令牌。原因是WebSocket
    API和SSE不支持标准的`Authorization`头，因此需要将令牌附加到查询字符串。如果查询字符串中找到令牌，它将被用来验证用户。
- en: We also added the `IUserIdProvider` service to the `NameUserIdProvider` class
    we created earlier. If you want to use the `EmailBasedUserIdProvider` class, you
    need to change the code accordingly. Note that you must not use both at the same
    time.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还向之前创建的`NameUserIdProvider`类中添加了`IUserIdProvider`服务。如果您想使用`EmailBasedUserIdProvider`类，您需要相应地更改代码。请注意，您不能同时使用这两个类。
- en: 'Create a database and run migrations using the following commands:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库并使用以下命令运行迁移：
- en: '[PRE34]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Authorize]public class ChatHub : Hub{    // Omitted for brevity}'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[授权]`public class ChatHub : Hub{    // 省略以节省空间}`'
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the `ChatApp.Server` application, as well as any other client applications.
    Unfortunately, the TypeScript and Blazor clients will not be able to connect to
    the SignalR hub due to the need for user authentication. To access the SignalR
    hub, we need to authenticate the clients.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ChatApp.Server`应用程序以及任何其他客户端应用程序。遗憾的是，TypeScript和Blazor客户端将无法连接到SignalR hub，因为需要用户认证。要访问SignalR
    hub，我们需要验证客户端。
- en: Adding a login endpoint
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加登录端点
- en: To authenticate the clients, we need to provide a login endpoint. We implemented
    a login endpoint in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307). You can follow
    the steps in [*Chapter 8*](B18971_08.xhtml#_idTextAnchor307) to implement the
    login endpoint or copy the code from the sample application. You need to create
    an `AccountController` class that contains register and login endpoints. You also
    need to add some models, such as the `LoginModel` and `AddOrUpdateUserModel` classes.
    With these classes, we can use the `account/register` and `account/login` endpoints
    to register and log in users.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证客户端，我们需要提供一个登录端点。我们在[*第8章*](B18971_08.xhtml#_idTextAnchor307)中实现了登录端点。您可以按照[*第8章*](B18971_08.xhtml#_idTextAnchor307)中的步骤来实现登录端点或从示例应用程序中复制代码。您需要创建一个包含注册和登录端点的`AccountController`类。您还需要添加一些模型，例如`LoginModel`和`AddOrUpdateUserModel`类。有了这些类，我们可以使用`account/register`和`account/login`端点来注册和登录用户。
- en: 'One thing to note here is that when generating a JWT token, we need to add
    a `ClaimTypes.NameIdentifier` claim to the token. SignalR uses this claim to identify
    the user. The following code shows how to add a `ClaimTypes.NameIdentifier` claim
    to the token:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，在生成JWT令牌时，我们需要向令牌中添加一个`ClaimTypes.NameIdentifier`声明。SignalR使用此声明来识别用户。以下代码显示了如何向令牌中添加`ClaimTypes.NameIdentifier`声明：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we need to create some users for testing. Run the `ChatApp.Server` application
    and send a `POST` request to the `account/register` endpoint using Postman or
    any other HTTP client. The following code shows how to create a user using the
    `account/register` endpoint:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为测试创建一些用户。运行`ChatApp.Server`应用程序，并使用Postman或其他HTTP客户端向`account/register`端点发送`POST`请求。以下代码显示了如何使用`account/register`端点创建用户：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create more users such as `user2`, `user3`, and so on. We will use these users
    to test the `Groups` feature later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更多用户，例如`user2`、`user3`等。我们将使用这些用户来测试后续的`Groups`功能。
- en: Authenticating the TypeScript client
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证TypeScript客户端
- en: 'Now, we can authenticate the TypeScript client. To do so, we need to update
    the UI to allow the user to enter the username and password. We also need to update
    the TypeScript code to send the username and password to the login endpoint. Follow
    these steps to update the TypeScript client:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证TypeScript客户端。为此，我们需要更新UI以允许用户输入用户名和密码。我们还需要更新TypeScript代码以将用户名和密码发送到登录端点。按照以下步骤更新TypeScript客户端：
- en: 'Update the HTML content in the `<body>` element as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`<body>`元素中的HTML内容：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code adds a login form to the HTML page. The login form contains
    a username textbox, a password textbox, and a login button. The `divChat` element
    now has a `lblUsername` element to display the username. The `divChat` element
    is hidden by default. We will show it after the user is authenticated.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码将登录表单添加到 HTML 页面。登录表单包含用户名文本框、密码文本框和登录按钮。`divChat` 元素现在有一个 `lblUsername`
    元素来显示用户名。`divChat` 元素默认是隐藏的。用户身份验证后，我们将显示它。
- en: 'Update the `app.ts` file as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `app.ts` 文件：
- en: '[PRE39]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Some codes are omitted. You can find the full code from the books GitHub repository.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些代码被省略了。您可以从书籍的 GitHub 仓库中找到完整的代码。
- en: 'In the preceding code, we use the `fetch` API to send a `POST` request to the
    login endpoint. The login endpoint returns a JWT token if the user is authenticated.
    Then, we store the token in the local storage and show the username in the `divChat`
    element. We also adjusted the creation of the SignalR connection. The `accessTokenFactory`
    property is used to get the token from the local storage. You can add some logic
    to check whether the token is valid or expired. If the token is expired, you can
    redirect the user to the login page or use the `dist` folder:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `fetch` API 向登录端点发送 `POST` 请求。如果用户已通过身份验证，登录端点将返回 JWT 令牌。然后，我们将令牌存储在本地存储中，并在
    `divChat` 元素中显示用户名。我们还调整了 SignalR 连接的创建。`accessTokenFactory` 属性用于从本地存储中获取令牌。您可以添加一些逻辑来检查令牌是否有效或已过期。如果令牌已过期，您可以重定向用户到登录页面或使用
    `dist` 文件夹：
- en: '[PRE40]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the **Live Preview** extension to run the web server. Run the SignalR server
    application as well. You will see a login form, as shown next:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Live Preview** 扩展运行 Web 服务器。同时运行 SignalR 服务器应用程序。您将看到一个登录表单，如下所示：
- en: '![Figure 13.5 – The login form](img/B18971_13_05.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 登录表单](img/B18971_13_05.jpg)'
- en: Figure 13.5 – The login form
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 登录表单
- en: 'Use the username and password you created earlier to log in. You should see
    a chat form, as shown next:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您之前创建的用户名和密码登录。您应该看到一个聊天表单，如下所示：
- en: '![Figure 13.6 – Authenticated chat](img/B18971_13_06.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 已验证聊天](img/B18971_13_06.jpg)'
- en: Figure 13.6 – Authenticated chat
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 已验证聊天
- en: Now, the TypeScript client is authenticated. Next, we will authenticate the
    Blazor client.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，TypeScript 客户端已经进行了身份验证。接下来，我们将验证 Blazor 客户端。
- en: Authenticating the Blazor client
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 Blazor 客户端
- en: 'The code to authenticate the Blazor client is very similar to the TypeScript
    client, so we will not list all the code here. You can find the code in the sample
    application. The following code shows how to log in and set a token to the SignalR
    connection:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 Blazor 客户端的代码与 TypeScript 客户端非常相似，因此我们在此不列出所有代码。您可以在示例应用程序中找到代码。以下代码展示了如何登录并将令牌设置到
    SignalR 连接中：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we inject `HttpClient` to send a `POST` request to the
    login endpoint. Then, we set a token to the SignalR connection. The `AccessTokenProvider`
    property is used to get the token from the `_token` field. Similar to the TypeScript
    client, you can add some logic to check whether the token is valid or expired.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们注入 `HttpClient` 向登录端点发送 `POST` 请求。然后，我们将令牌设置到 SignalR 连接中。`AccessTokenProvider`
    属性用于从 `_token` 字段获取令牌。类似于 TypeScript 客户端，您可以添加一些逻辑来检查令牌是否有效或已过期。
- en: 'Run the three applications. You can use different usernames to log in to the
    two clients and send messages. You should see messages are displayed in both clients,
    as shown next:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行三个应用程序。您可以使用不同的用户名登录到两个客户端并发送消息。您应该看到消息在两个客户端中显示，如下所示：
- en: '![Figure 13.7 – Authenticated chat for different users](img/B18971_13_07.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 不同用户的已验证聊天](img/B18971_13_07.jpg)'
- en: Figure 13.7 – Authenticated chat for different users
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 不同用户的已验证聊天
- en: The clients now support authentication. Next, we will add more features to the
    chat app.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端现在支持身份验证。接下来，我们将向聊天应用添加更多功能。
- en: Managing users and groups
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户和组
- en: 'In the previous section, we implemented basic authentication and authorization
    for the SignalR server. We also updated clients to authenticate users. In this
    section, we will explore how to manage users and groups in SignalR. We want to
    add features to the chat app to enable the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为 SignalR 服务器实现了基本的身份验证和授权。我们还更新了客户端以验证用户。在本节中，我们将探讨如何在 SignalR 中管理用户和组。我们希望为聊天应用添加以下功能：
- en: Allow users to know who is connected to the chat app
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户知道谁连接到了聊天应用
- en: Allow users to send a message to a specific user
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户向特定用户发送消息
- en: Allow users to join groups
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户加入组
- en: Allow users to send a message to a specific group
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the complete code of the sample in the `chapter13/v3` folder of
    the GitHub repository. Let’s start with the first feature.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Managing events in SignalR
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SignalR provides events to notify clients when a user connects or disconnects.
    We can override the `OnConnectedAsync()` and `OnDisconnectedAsync()` methods to
    handle these events. The following code shows how to override the `OnConnectedAsync()`
    method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When a client connects to the SignalR hub, the `OnConnectedAsync()` method will
    be called. In this case, we use the `Clients.All.SendAsync()` method to send a
    message to all connected clients. The `Context.User.Identity.Name` property is
    used to get the username of the current user.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to override the `OnDisconnectAsync()` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we can update the TypeScript client to handle the `UserConnected` and
    `UserDisconnected` events. The following code shows how to handle the `UserConnected`
    event in the TypeScript client:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The code in the Blazor client is very similar:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can run the SignalR server and the two clients. You should see the
    user’s connected and disconnected messages in the chat window. If you refresh
    the page or close the browser tab, you should see a user-disconnected message,
    as shown next:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.8 – User-connected and -disconnec\uFEFFted messages](img/B18971_13_08.jpg)"
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – User-connected and -disconnected messages
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add a feature to allow users to send a message to a specific user.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a specific user
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next feature we want to add is to allow users to send a message to a specific
    user. To do so, we need to know to whom the message is sent. SignalR uses a `ClaimTypes.NameIdentifier`
    claim to differentiate users. To simplify the code, we will pass the username
    as the target user:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code uses the `Clients.User(user)` method to find the connection
    of the specified user.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the TypeScript client to add a textbox to enter the target username.
    The following code shows how to update the HTML content for the `divChat` element:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we can invoke this method from the TypeScript client as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding code, when the `txtToUser` field is not empty, we use the `SendMessageToUser()`
    method to send a message to a specified user. Otherwise, we use the `SendMessage()`
    method to send a message to all connected users.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the Blazor client is very similar:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Please refer to the sample application for the complete code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the three applications. This time, we need to open three browser tabs for
    testing. Use three different usernames to log in to the three clients. Then, we
    can send a message to a specific user, as shown next:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Sending a message to a specific user](img/B18971_13_09.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Sending a message to a specific user
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13**.9*, we sent a message to the `user1` user from `user2`. You
    can see that the message is displayed in the `user1` browser tab but not in the
    `user3` browser tab.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13*.9中，我们从`user2`用户向`user1`用户发送了一条消息。您可以看到，消息显示在`user1`的浏览器标签中，但没有显示在`user3`的浏览器标签中。
- en: You can try to log in to the same username in different browser tabs. You will
    find that both browser tabs will receive the message. This is because SignalR
    uses the `ClaimTypes.NameIdentifier` claim to differentiate users. Each browser
    tab has a different SignalR connection, but they use the same username. Therefore,
    SignalR will treat them as the same user.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试在不同的浏览器标签中登录相同的用户名。您会发现两个浏览器标签都会收到消息。这是因为SignalR使用`ClaimTypes.NameIdentifier`声明来区分用户。每个浏览器标签都有一个不同的SignalR连接，但它们使用相同的用户名。因此，SignalR将它们视为同一用户。
- en: Using strongly typed hubs
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用强类型Hub
- en: 'So far, we have added a couple of methods to the `ChatHub` class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向`ChatHub`类添加了一些方法：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Each method calls the `SendAsync()` method with a string parameter. The string
    parameter is the name of the method to be invoked on the client. The `SendAsync()`
    method is a dynamic method, but it is not type-safe. If we misspell the method
    name, the compiler will not report any error. To improve type safety, we can use
    strongly typed hubs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都使用一个字符串参数调用`SendAsync()`方法。字符串参数是要在客户端上调用的方法名称。`SendAsync()`方法是一个动态方法，但它不是类型安全的。如果我们拼错了方法名称，编译器将不会报告任何错误。为了提高类型安全性，我们可以使用强类型Hub。
- en: 'To use strongly typed hubs, we need to define a hub interface that contains
    client methods. The following code shows how to define a hub interface:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用强类型Hub，我们需要定义一个包含客户端方法的Hub接口。以下代码展示了如何定义Hub接口：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we can update the `ChatHub` class to implement the `IChatClient` interface:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新`ChatHub`类以实现`IChatClient`接口：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, the `SendAsync()` method is no longer used. Instead,
    we use the `RecieveMessage()`, `UserConnected()`, and `UserDisconnected()` methods
    defined in the `IChatClient` interface. The `Hub` class is generic, so we need
    to specify the `IChatClient` interface as the generic type argument. Now, the
    `ChatHub` class is strongly typed. Note that if you use a strongly typed hub,
    the `SendAsync()` method is no longer available.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`SendAsync()`方法不再使用。相反，我们使用在`IChatClient`接口中定义的`RecieveMessage()`、`UserConnected()`和`UserDisconnected()`方法。`Hub`类是泛型的，因此我们需要指定`IChatClient`接口作为泛型类型参数。现在，`ChatHub`类是强类型的。请注意，如果您使用强类型Hub，则`SendAsync()`方法将不再可用。
- en: Next, we will add a feature to allow users to join groups.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个功能，允许用户加入组。
- en: Joining groups
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入组
- en: 'SignalR allows users to join groups. The `Hub` class has a `Groups` property
    to manage groups. The type of the `Groups` property is the `IGroupManager` interface,
    which provides methods such as `AddToGroupAsync()`, `RemoveFromGroupAsync()`,
    and so on. The following code shows how to add a user to a group and remove a
    user from a group:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR允许用户加入组。`Hub`类有一个`Groups`属性来管理组。`Groups`属性的类型是`IGroupManager`接口，它提供了`AddToGroupAsync()`、`RemoveFromGroupAsync()`等方法。以下代码展示了如何将用户添加到组中以及如何从组中移除用户：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding code, we use the `Groups` property to manage groups. The `Context.ConnectionId`
    property is used to get the connection ID of the current user. The `Clients.Group`
    method is used to send a message to all users in the specified group so that they
    can know who has joined or left the group.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`Groups`属性来管理组。`Context.ConnectionId`属性用于获取当前用户的连接ID。`Clients.Group`方法用于向指定组中的所有用户发送消息，以便他们知道谁加入了或离开了该组。
- en: 'Next, we need to update the UI to allow a user to enter the group name. Add
    the following code to the HTML content for the `divChat` element:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新UI以允许用户输入组名。将以下代码添加到`divChat`元素的HTML内容中：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Update the TypeScript code to handle `JoinGroup` and `LeaveGroup` events. The
    following code shows how to handle the `JoinGroup` event:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 更新TypeScript代码以处理`JoinGroup`和`LeaveGroup`事件。以下代码展示了如何处理`JoinGroup`事件：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding code shows two event handlers for the `JoinGroup` and `LeaveGroup`
    events, which invoke the `AddToGroup()` and `RemoveFromGroup()` methods on the
    SignalR hub respectively.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了两个事件处理程序，用于`JoinGroup`和`LeaveGroup`事件，分别在SignalR Hub上调用`AddToGroup()`和`RemoveFromGroup()`方法。
- en: The code in the Blazor client is very similar. We will not list the code here.
    You can find the code in the sample application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor客户端中的代码非常相似。这里不再列出代码。您可以在示例应用程序中找到代码。
- en: 'Now, the client should be able to join and leave groups. When a user joins
    or leaves a group, the other users in the group will receive a message, as shown
    next:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端应该能够加入和离开组。当用户加入或离开组时，组中的其他用户将收到消息，如下所示：
- en: '![Figure 13.10 – Joining and leaving groups](img/B18971_13_10.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 加入和离开组](img/B18971_13_10.jpg)'
- en: Figure 13.10 – Joining and leaving groups
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 加入和离开组
- en: In *Figure 13**.10*, `user3` joined `group1` and then left `group1`. You can
    see that the other users in `group1` received messages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 13*.10 中，`user3` 加入 `group1` 然后离开 `group1`。您可以看到 `group1` 中的其他用户收到了消息。
- en: Next, we will add a feature to allow users to send a message to a specific group.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个功能，允许用户向特定组发送消息。
- en: Sending a message to a group
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向组发送消息
- en: 'The code to send a message to a group is very similar to the code to send a
    message to a specific user. The following code shows how to send a message to
    a group in the `ChatHub` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 向组发送消息的代码与向特定用户发送消息的代码非常相似。以下代码展示了在 `ChatHub` 类中如何向组发送消息：
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding code uses `Clients.Group(group)` to find connections of the users
    in the specified group. Then, it uses the `ReceiveMessage()` method defined in
    the `IChatClient` interface to send a message to users in the group.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `Clients.Group(group)` 来查找指定组中用户的连接。然后，它使用在 `IChatClient` 接口中定义的 `ReceiveMessage()`
    方法向组中的用户发送消息。
- en: 'The Blazor client can invoke this method as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 客户端可以按如下方式调用此方法：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will not list the code for the TypeScript client here. You can find the code
    in the sample application.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处不会列出 TypeScript 客户端的代码。您可以在示例应用程序中找到代码。
- en: 'Now, the client should be able to send a message to a specific group. The following
    figure shows how to send a message to a group:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端应该能够向特定组发送消息。以下图示展示了如何向组发送消息：
- en: '![Figure 13.11 – Sending a message to a group](img/B18971_13_11.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11 – 向组发送消息](img/B18971_13_11.jpg)'
- en: Figure 13.11 – Sending a message to a group
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 向组发送消息
- en: You will see a message displayed for `user1` and `user3` as they are in the
    same group. But `user2` and `user4` will not see the message because they are
    not in `group1`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到 `user1` 和 `user3` 显示了消息，因为他们处于同一个组中。但 `user2` 和 `user4` 将不会看到消息，因为他们不在
    `group1` 中。
- en: Sending messages from other services
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他服务发送消息
- en: So far, we have implemented a chat app that allows users to send messages to
    other users or groups. Sometimes, we need to send messages from other places.
    For example, when an event occurs, we may need to send a message to notify the
    users. In this section, we will explore how to send messages from other services.
    You can find the complete code of the sample in the `chapter13/v4` folder of the
    GitHub repository.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个聊天应用，允许用户向其他用户或组发送消息。有时，我们需要从其他地方发送消息。例如，当发生事件时，我们可能需要发送消息来通知用户。在本节中，我们将探讨如何从其他服务发送消息。您可以在
    GitHub 仓库的 `chapter13/v4` 文件夹中找到示例的完整代码。
- en: 'We will add a REST API endpoint to allow other systems to send messages to
    the SignalR hub. Follow these steps to add a REST API endpoint in the `ChatApp.Server`
    application:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `ChatApp.Server` 应用程序中添加一个 REST API 端点，以允许其他系统向 SignalR 集线器发送消息。按照以下步骤在
    `ChatApp.Server` 应用程序中添加 REST API 端点：
- en: 'Create the following models in the `Models` folder:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中创建以下模型：
- en: '[PRE58]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: These models are used to send messages to the SignalR hub.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些模型用于向 SignalR 集线器发送消息。
- en: Create a new controller or use the existing `AccountController` class in the
    sample application. We will create a `ChatController` class in the `Controllers`
    folder.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例应用程序中创建一个新的控制器或使用现有的 `AccountController` 类。我们将在 `Controllers` 文件夹中创建一个 `ChatController`
    类。
- en: 'Inject the `IHubContext<ChatHub`, `IChatClient>` service into the `ChatController`
    class:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IHubContext<ChatHub, IChatClient>` 服务注入到 `ChatController` 类中：
- en: '[PRE59]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `IHubContext<ChatHub, IChatClient>` service is used to send messages to
    clients. In this example, we use a strongly typed hub. You can also inject the
    `IHubContext<ChatHub>` service if you use a normal SignalR hub.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IHubContext<ChatHub, IChatClient>` 服务用于向客户端发送消息。在这个例子中，我们使用了一个强类型集线器。如果您使用的是普通
    SignalR 集线器，您也可以注入 `IHubContext<ChatHub>` 服务。'
- en: 'Add the following actions to send messages to all users, a specific user, and
    a specific group:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下操作以向所有用户、特定用户和特定组发送消息：
- en: '[PRE60]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code uses the `hubContext.Clients` property to send messages to
    clients. Note that this endpoint is not authenticated. You can add authentication
    and authorization to this endpoint if required.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码使用了 `hubContext.Clients` 属性向客户端发送消息。请注意，此端点未进行身份验证。如果需要，您可以为此端点添加身份验证和授权。
- en: Run the three applications. Use different users to log in and join the group.
    Then, you can test the `chat/all`, `chat/user`, and `chat/group` endpoints using
    Postman or any other HTTP client.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行三个应用程序。使用不同的用户登录并加入群组。然后，您可以使用 Postman 或任何其他 HTTP 客户端测试 `chat/all`、`chat/user`
    和 `chat/group` 端点。
- en: This is how to send messages from external services. In the next section, we
    will explore how to manage SignalR connections.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是从外部服务发送消息的方法。在下一节中，我们将探讨如何管理 SignalR 连接。
- en: Configuring SignalR hubs and clients
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 SignalR 中心和客户端
- en: SignalR provides a `HubOptions` class to configure SignalR hubs. Also, SignalR
    clients have some configuration options. In this section, we will explore how
    to configure SignalR hubs and clients. You can find the complete code of the sample
    in the `chapter13/v5` folder of the GitHub repository.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 提供了一个 `HubOptions` 类来配置 SignalR 中心。此外，SignalR 客户端也有一些配置选项。在本节中，我们将探讨如何配置
    SignalR 中心和客户端。您可以在 GitHub 仓库的 `chapter13/v5` 文件夹中找到示例的完整代码。
- en: Configuring SignalR hubs
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 SignalR 中心
- en: 'Here are some of the configuration options for SignalR hubs:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 SignalR 中心的配置选项：
- en: '`KeepAliveInterval`: This property determines the interval at which a keep-alive
    message is sent to clients. If a client does not receive a message from the server
    within this period of time, it will send a `ping` message to the server in order
    to maintain the connection. When changing this value, it is important to also
    adjust the `serverTimeoutInMilliseconds` or `ServerTimeout` option in the client.
    For best results, it is recommended to set the `serverTimeoutInMilliseconds` or
    `ServerTimeout` option to a value that is double the value of the `KeepAliveInterval`
    property. The default value of `KeepAliveInterval` is 15 seconds.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeepAliveInterval`：此属性确定发送给客户端的保持连接消息的间隔。如果客户端在此时间段内没有从服务器收到消息，它将向服务器发送 `ping`
    消息以维持连接。更改此值时，还重要的是要调整客户端中的 `serverTimeoutInMilliseconds` 或 `ServerTimeout` 选项。为了获得最佳结果，建议将
    `serverTimeoutInMilliseconds` 或 `ServerTimeout` 选项设置为 `KeepAliveInterval` 属性值的两倍。`KeepAliveInterval`
    的默认值是 15 秒。'
- en: '`ClientTimeoutInterval`: This property determines the interval at which the
    server will consider the client disconnected if it has not received a message
    from the client. It is recommended to set `ClientTimeoutInterval` to a value that
    is double the value of the `KeepAliveInterval` property. The default value of
    `ClientTimeoutInterval` is 30 seconds.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientTimeoutInterval`：此属性确定服务器在未从客户端收到消息的情况下，将客户端视为断开连接的间隔。建议将 `ClientTimeoutInterval`
    设置为 `KeepAliveInterval` 属性值的两倍。`ClientTimeoutInterval` 的默认值是 30 秒。'
- en: '`EnableDetailedErrors`: This property determines whether detailed error messages
    are sent to the client. The default value of `EnableDetailedErrors` is `false`
    as error messages may contain sensitive information.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnableDetailedErrors`：此属性确定是否向客户端发送详细错误消息。`EnableDetailedErrors` 的默认值是 `false`，因为错误消息可能包含敏感信息。'
- en: '`MaximumReceiveMessageSize`: This property determines the maximum size of a
    message that the server will accept. The default value of `MaximumReceiveMessageSize`
    is 32 KB. Do not set this value to a very large value as it may cause **denial-of-service**
    (**DoS**) attacks and consume a lot of memory.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaximumReceiveMessageSize`：此属性确定服务器将接受的消息的最大大小。`MaximumReceiveMessageSize`
    的默认值是 32 KB。不要将此值设置得过大，因为它可能引起 **拒绝服务**（**DoS**）攻击并消耗大量内存。'
- en: '`MaximumParallelInvocationsPerClient`: This property determines the maximum
    number of hub method invocations that can be executed in parallel per client.
    The default value of `MaximumParallelInvocationsPerClient` is 1.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaximumParallelInvocationsPerClient`：此属性确定每个客户端可以并行执行的 hub 方法调用的最大数量。`MaximumParallelInvocationsPerClient`
    的默认值是 1。'
- en: '`StreamBufferCapacity`: This property determines the maximum number of items
    that can be buffered in a client upload stream. The default value of `StreamBufferCapacity`
    is 10\. We will introduce streaming in the next section.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamBufferCapacity`：此属性确定客户端上传流中可以缓存的项的最大数量。`StreamBufferCapacity` 的默认值是
    10。我们将在下一节中介绍流。'
- en: 'There are two ways to configure SignalR hubs. The first way is to provide a
    `HubOptions` object to all hubs. The following code shows how to configure the
    `ChatHub` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 SignalR 中心的方式有两种。第一种方式是为所有中心提供一个 `HubOptions` 对象。以下代码展示了如何配置 `ChatHub` 类：
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The second way is to configure the SignalR hubs for each hub. The following
    code shows how to configure the `ChatHub` class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是为每个中心配置 SignalR 中心。以下代码展示了如何配置 `ChatHub` 类：
- en: '[PRE62]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding code is useful if you have multiple hubs and you want to configure
    them differently.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个中心并且想要分别配置它们，上述代码非常有用。
- en: 'Note that if you change the `KeepAliveInterval` or `ClientTimeoutInterval`
    property of the SignalR hub, you need to update the `serverTimeoutInMilliseconds`
    or `ServerTimeout` option in the clients as well. The following code shows how
    to configure the TypeScript client:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您更改 SignalR 中心的 `KeepAliveInterval` 或 `ClientTimeoutInterval` 属性，您还需要在客户端更新
    `serverTimeoutInMilliseconds` 或 `ServerTimeout` 选项。以下代码展示了如何配置 TypeScript 客户端：
- en: '[PRE63]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `HubConnection` object has the `keepAliveIntervalInMilliseconds` property
    and the `serverTimeoutInMilliseconds` property, which can be used to match the
    configuration in the server project.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubConnection` 对象具有 `keepAliveIntervalInMilliseconds` 属性和 `serverTimeoutInMilliseconds`
    属性，这些属性可以用于匹配服务器项目中的配置。'
- en: 'Similarly, you can configure the Blazor client as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您还可以如下配置 Blazor 客户端：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Make sure that the values of the `KeepAliveInterval` and `ClientTimeout/ServerTimeout`
    properties are the same in the server and the client.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 确保服务器和客户端中 `KeepAliveInterval` 和 `ClientTimeout/ServerTimeout` 属性的值相同。
- en: HTTP configuration options
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 配置选项
- en: 'SignalR can automatically negotiate the transport protocol with the client.
    The default transport protocol is WebSockets. If the client does not support WebSockets,
    SignalR will use SSE or long polling. You can configure HTTP options for SignalR.
    The following code shows how to configure HTTP options for the `ChatHub` class:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 可以自动与客户端协商传输协议。默认传输协议是 WebSockets。如果客户端不支持 WebSockets，SignalR 将使用 SSE
    或长轮询。您可以配置 SignalR 的 HTTP 选项。以下代码展示了如何为 `ChatHub` 类配置 HTTP 选项：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding code configures HTTP options for the `ChatHub` class using a `HttpConnectionDispatcherOptions`
    object. In this sample, we configured the `Transports` property to use WebSockets
    and long polling, but not SSE. In addition, we configured the `CloseTimeout` property
    of the `WebSockets` property to 10 seconds, and the `PollTimeout` property of
    the `LongPolling` property to 120 seconds. The default value of the `CloseTimeout`
    property is 5 seconds, meaning that after the server closes, the connection will
    be terminated if clients cannot close the connection within 5 seconds. The default
    value of the `PollTimeout` property is 90 seconds, meaning that the server will
    terminate a poll request after waiting for 90 seconds and then create a new poll
    request.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `HttpConnectionDispatcherOptions` 对象为 `ChatHub` 类配置了 HTTP 选项。在此示例中，我们配置了
    `Transports` 属性以使用 WebSockets 和长轮询，但不使用 SSE。此外，我们还配置了 `WebSockets` 属性的 `CloseTimeout`
    属性为 10 秒，以及 `LongPolling` 属性的 `PollTimeout` 属性为 120 秒。`CloseTimeout` 属性的默认值是 5
    秒，这意味着如果客户端在 5 秒内无法关闭连接，连接将被终止。`PollTimeout` 属性的默认值是 90 秒，这意味着服务器将在等待 90 秒后终止轮询请求，然后创建一个新的轮询请求。
- en: 'The allowed transports can be configured in the client as well. We can configure
    the TypeScript client as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的传输可以在客户端进行配置。我们可以如下配置 TypeScript 客户端：
- en: '[PRE66]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following code shows how to configure the Blazor client:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何配置 Blazor 客户端：
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `HttpTransportType` enum has a `FlagsAttribute` attribute, so you can use
    the bitwise `OR` operator to combine multiple transport protocols.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpTransportType` 枚举具有 `FlagsAttribute` 属性，因此您可以使用位运算符 `OR` 来组合多个传输协议。'
- en: Automatically reconnecting
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动重新连接
- en: 'Sometimes, due to network issues, the SignalR connection may be disconnected.
    For example, if the user’s device is switched from Wi-Fi to cellular, or if the
    user’s device is in a tunnel, the SignalR connection may be disconnected. In this
    case, we want the client to automatically reconnect to the server:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于网络问题，SignalR 连接可能会断开。例如，如果用户的设备从 Wi-Fi 切换到蜂窝网络，或者如果用户的设备处于隧道中，SignalR 连接可能会断开。在这种情况下，我们希望客户端自动重新连接到服务器：
- en: 'SignalR allows the client to automatically reconnect to the server if the connection
    is dropped. The following code shows how to configure the TypeScript client to
    automatically reconnect to the server:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SignalR允许客户端在连接断开时自动重新连接到服务器。以下代码展示了如何配置TypeScript客户端以自动重新连接到服务器：
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Similarly, you can configure the Blazor client as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，您可以按以下方式配置Blazor客户端：
- en: '[PRE69]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By default, when the connection is dropped, the client will try to reconnect
    to the SignalR server in 0, 2, 10, and 30 seconds. You can configure the retry
    policy as follows:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，当连接断开时，客户端将在0秒、2秒、10秒和30秒后尝试重新连接到SignalR服务器。您可以按以下方式配置重试策略：
- en: '[PRE70]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `withAutomaticReconnect()` method accepts an array of numbers to configure
    the delay duration in milliseconds. In the preceding code, the client will try
    to reconnect to the server in 0, 5, and 20 seconds.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`withAutomaticReconnect()`方法接受一个数字数组来配置毫秒级的延迟持续时间。在前面代码中，客户端将在0秒、5秒和20秒后尝试重新连接到服务器。'
- en: 'In the Blazor client, you can configure the retry policy as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blazor客户端中，您可以按以下方式配置重试策略：
- en: '[PRE71]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding code configures the same retry policy as the TypeScript client.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码配置了与TypeScript客户端相同的重试策略。
- en: 'To test the automatic reconnect feature, we can add a label to show the connection
    status. Add the following code to the HTML content for the `divChat` element:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试自动重连功能，我们可以在标签上添加一个显示连接状态的标签。将以下代码添加到`divChat`元素的HTML内容中：
- en: '[PRE72]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, update the TypeScript code to show the connection status:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新TypeScript代码以显示连接状态：
- en: '[PRE73]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can also enable debug logging to see the connection status. The following
    code shows how to do this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以启用调试日志以查看连接状态。以下代码展示了如何进行此操作：
- en: '[PRE74]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can find the complete code in the sample application.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在示例应用程序中找到完整的代码。
- en: 'Run the SignalR server and the TypeScript client. Press *F12* to open the developer
    tools for the TypeScript client. Click the **Network** tab, and you can change
    network conditions to simulate network issues. For example, you can change the
    network to **Offline** to simulate network disconnection, as shown next:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行SignalR服务器和TypeScript客户端。按*F12*打开TypeScript客户端的开发者工具。点击**网络**选项卡，您可以更改网络条件以模拟网络问题。例如，您可以将网络更改为**离线**以模拟网络断开，如下所示：
- en: '![Figure 13.12 – Simulating network disconnection in Chrome developer tools](img/B18971_13_12.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 在Chrome开发者工具中模拟网络断开](img/B18971_13_12.jpg)'
- en: Figure 13.12 – Simulating network disconnection in Chrome developer tools
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 在Chrome开发者工具中模拟网络断开
- en: 'After you change the network to **Offline**, wait for a few seconds (depending
    on the timeout configuration), and you should see the client automatically reconnect
    to the server, as shown next:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网络更改为**离线**后，等待几秒钟（取决于超时配置），您应该会看到客户端自动重新连接到服务器，如下所示：
- en: '![Figure 13.13 – The client automatically reconnects to the server](img/B18971_13_13.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13 – 客户端自动重新连接到服务器](img/B18971_13_13.jpg)'
- en: Figure 13.13 – The client automatically reconnects to the server
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – 客户端自动重新连接到服务器
- en: 'Change the network back to Online, and you should see that the client reconnects
    to the server, as shown next:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网络改回**在线**，您应该会看到客户端重新连接到服务器，如下所示：
- en: '![Figure 13.14 – The client reconnects to the server after the network is back
    online](img/B18971_13_14.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14 – 网络恢复在线后客户端重新连接到服务器](img/B18971_13_14.jpg)'
- en: Figure 13.14 – The client reconnects to the server after the network is back
    online
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 网络恢复在线后客户端重新连接到服务器
- en: Important note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the client fails to reconnect to the server after trying four times, the
    `onclose` event will be triggered. You can add the event handler for the `onclose`
    event to handle the connection close event. For example, you can notify the user
    that the connection is closed and ask the user to refresh the page or manually
    reconnect to the server.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端在尝试四次后仍然无法重新连接到服务器，将触发`onclose`事件。您可以添加`onclose`事件的处理器来处理连接关闭事件。例如，您可以通知用户连接已关闭，并要求用户刷新页面或手动重新连接到服务器。
- en: SignalR in ASP.NET Core 8.0 supports stateful reconnect, allowing the server
    to temporarily store messages when the client is disconnected. Upon reconnection,
    the client will use the same connection ID, and the server will replay any messages
    that were sent while the client was disconnected. This ensures that the client’s
    state is maintained and that no messages are lost.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 8.0 中的 SignalR 支持状态重连，允许服务器在客户端断开连接时临时存储消息。在重新连接后，客户端将使用相同的连接 ID，服务器将回放客户端断开连接期间发送的任何消息。这确保了客户端的状态得到保持，且不会丢失任何消息。
- en: 'To enable stateful reconnect, we need to configure the `AllowStatefulReconnects`
    option for the SignalR hub endpoint as follows:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用状态重连，我们需要为 SignalR 端点配置 `AllowStatefulReconnects` 选项，如下所示：
- en: '[PRE75]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'By default, the maximum buffer size of the stateful reconnect is 100,000 bytes.
    You can change the buffer size as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，状态重连的最大缓冲区大小为 100,000 字节。您可以根据以下方式更改缓冲区大小：
- en: '[PRE76]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, we can configure the TypeScript client to use the stateful reconnect
    as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以配置 TypeScript 客户端以使用状态重连，如下所示：
- en: '[PRE77]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Similarly, you can configure the Blazor client as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，您可以这样配置 Blazor 客户端：
- en: '[PRE78]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To configure the buffer size of the Blazor client, you can configure the `HubConnectionOptions`
    object as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置 Blazor 客户端的缓冲区大小，您可以配置 `HubConnectionOptions` 对象，如下所示：
- en: '[PRE79]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Besides the automatic reconnect feature, you can also manually reconnect to
    the SignalR server if the connection is dropped. You can add an event handler
    for the `onclose` event or `Closed` event to handle the connection close event.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动重连功能外，如果连接断开，您还可以手动重新连接到 SignalR 服务器。您可以为 `onclose` 事件或 `Closed` 事件添加事件处理器来处理连接关闭事件。
- en: Scaling SignalR
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 SignalR
- en: So far, we have implemented a chat app that allows users to send messages to
    other users or groups. We have also explored how to manage SignalR connections.
    You can also use a similar approach to build a real-time notification system,
    a real-time dashboard, and so on. However, the application can only run on a single
    server. If we want to scale the application, for example, using a load balancer
    to distribute requests to multiple servers, server *A* does not know the connections
    on server *B*.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个聊天应用，允许用户向其他用户或组发送消息。我们还探讨了如何管理 SignalR 连接。您也可以使用类似的方法构建实时通知系统、实时仪表板等。然而，该应用只能在单个服务器上运行。如果我们想扩展应用，例如，使用负载均衡器将请求分发到多个服务器，服务器
    *A* 就不知道服务器 *B* 上的连接。
- en: 'SignalR requires a persistent connection between the client and the server.
    That means requests from the same client must be routed to the same server. This
    is called *sticky sessions* or *session affinity*. This is required if you have
    multiple SignalR servers. Besides this requirement, there are some other considerations
    when you scale SignalR:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 需要在客户端和服务器之间建立持久连接。这意味着来自同一客户端的请求必须路由到同一服务器。这被称为 *粘性会话* 或 *会话亲和性*。如果您有多个
    SignalR 服务器，则需要此要求。除了此要求外，在扩展 SignalR 时还有一些其他考虑因素：
- en: If you host the application in Azure, you can use Azure SignalR Service. Azure
    SignalR Service is a fully managed service that helps you scale the SignalR application
    without worrying about the infrastructure. With Azure SignalR Service, you do
    not need to use sticky sessions as all clients connect to Azure SignalR Service.
    This service takes on the responsibility of managing connections and freeing up
    resources on the SignalR servers. For more information, please refer to [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview).
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在 Azure 上托管应用，可以使用 Azure SignalR 服务。Azure SignalR 服务是一个完全托管的服务，可以帮助您扩展 SignalR
    应用而无需担心基础设施。使用 Azure SignalR 服务时，您无需使用粘性会话，因为所有客户端都连接到 Azure SignalR 服务。此服务承担管理连接和释放
    SignalR 服务器资源的责任。有关更多信息，请参阅 [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview)。
- en: If you host the application on your own infrastructure or other cloud providers,
    you can use Redis backplane to synchronize the connections. The Redis backplane
    is a Redis server that uses the pub/sub feature to forward messages to other SignalR
    servers. However, this approach requires sticky sessions for most cases, and the
    SignalR application instances require additional resources to manage connections.
    There are some other SignalR backplane providers, such as SQL Server, NCache,
    and so on.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将应用程序托管在自己的基础设施或其他云服务提供商上，你可以使用 Redis 背板来同步连接。Redis 背板是一个使用 pub/sub 功能将消息转发到其他
    SignalR 服务器的 Redis 服务器。然而，这种方法在大多数情况下需要粘性会话，并且 SignalR 应用程序实例需要额外的资源来管理连接。还有一些其他的
    SignalR 背板提供商，例如 SQL Server、NCache 等。
- en: We will not cover details of how to scale SignalR in this book. You can find
    more information in the official documentation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中不会涵盖如何扩展 SignalR 的细节。你可以在官方文档中找到更多信息。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: SignalR is a powerful library that simplifies the process of building real-time
    web applications. In this chapter, we explored how to use SignalR to build a chat
    app. We introduced basic concepts of SignalR, such as hubs, clients, and connections.
    We created clients using TypeScript and Blazor, which demonstrated how to use
    both TypeScript and .NET to build SignalR clients. We also discussed how to send
    messages to a specific user or group and how to secure SignalR connections using
    JWT authentication. Additionally, we explored how to configure SignalR hubs and
    clients, such as configuring the keep-alive interval, configuring HTTP options,
    and configuring the automatic reconnect feature.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 是一个强大的库，简化了构建实时网络应用程序的过程。在本章中，我们探讨了如何使用 SignalR 来构建聊天应用程序。我们介绍了 SignalR
    的基本概念，如中心点、客户端和连接。我们使用 TypeScript 和 Blazor 创建了客户端，这展示了如何使用 TypeScript 和 .NET 来构建
    SignalR 客户端。我们还讨论了如何向特定用户或组发送消息，以及如何使用 JWT 认证来保护 SignalR 连接。此外，我们还探讨了如何配置 SignalR
    中心点和客户端，例如配置保持活动间隔、配置 HTTP 选项和配置自动重连功能。
- en: 'Although we have covered a lot of features, there is still more to explore,
    such as streaming. For more information, please refer to the official documentation:
    [https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction).
    In the next chapter, we will explore how to deploy ASP.NET Core applications.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经涵盖了众多功能，但仍有许多内容可以探索，例如流式传输。更多详细信息，请参阅官方文档：[https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction)。在下一章中，我们将探讨如何部署
    ASP.NET Core 应用程序。
