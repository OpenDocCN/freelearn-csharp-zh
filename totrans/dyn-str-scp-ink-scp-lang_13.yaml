- en: '*Chapter 10*: Dialogue Systems with ink'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore three different approaches to create a `#`),
    can be used to mark different lines in ink as being associated with certain characters
    in a story. Then, we will discuss an alternative to tags, where the name of the
    speaker precedes their dialogue. Finally, we will conclude the first part by reviewing
    how tags can be used and how both approaches can be combined.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In the second topic, we will look at how to recreate the **click-to-continue**
    dialogue pattern that is found in many video games using ink. We will explore
    various ways of saving time and effort by using tunnels to move to different knots
    and back again in an ink project for use when needed. Following this, we will
    examine several different ways in which to generate dialogue trees in ink where
    players can explore different paths through extended branches of conversation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In the third and final topic, we will look at two common visual patterns in
    which to present dialogue options to players, that is, lists and radial menus,
    and how they affect both writing ink code and how information is displayed to
    a player in Unity. We will begin with the visual pattern of a list, where all
    options are shown to the player in a vertical pattern. Then, we will examine the
    **radial menu pattern**, where options are limited to a smaller number of options
    arranged in a specific, visual way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Writing dialogue in ink using tags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialogue loops and story knots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface models for conversations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unlike previous chapters, where sections built toward a completed project, this
    chapter will examine different approaches toward more visually complex systems.
    Each approach covered by a section can be found online on GitHub as a completed
    project. Only selected files and code, as they relate to the approach of each
    section, will be shown in this chapter. The specific files of each example are
    also noted within each section.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The completed code for the different sections of this chapter can be found on
    GitHub at [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Writing dialogue in Ink using tags
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When ink was first introduced in [*Chapter 1*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014),
    *Text, Flow, Choices, and Weaves*, the importance of a single line was also discussed.
    Each line in ink can consist of code, text, or a combination of the two. Depending
    on the use of other concepts, such as glue or comments, what counts as a single
    line can often be composed of multiple blocks of text or include notes for the
    authors as part of a single line. However, in addition to these previously reviewed
    concepts is another concept that has not previously been discussed: **hashtags**.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'In ink, a new, single *hashtag* is created when a hash (`#`) is used before
    any text. Starting from the hash (`#`) and until the end of that line, any text
    that appears between the two is considered part of the single *tag*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Hashtags in ink are specifically designed to work with other systems. They
    have no meaning within Inky itself and are shown in the middle of the output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A hashtag used within Inky'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B17597.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – A hashtag used within Inky
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: When working with another system such as Unity, hashtags can be used to add
    extra data to a single line in ink. The current tags for the loaded chunk of the
    ink story exist within a property provided by the Story API, called `currentTags`,
    which contains a `List<string>` of all tags detected within the last load of story
    content. As with other text-related content, the `currentTags` property is also
    affected by any usages of the `Continue()` or `ContinueMaximally()` methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by learning how to use hashtags in ink. We will retrieve their
    values using the `currentTags` property in Unity to build a simple dialogue system
    where each spoken line has a name associated with who is communicating it. Next,
    we will examine a different approach to the same dialogue system using speech
    tags in front of the text of each ink line. The last section of this topic will
    compare the two approaches and review when one might be better than the other
    or whether a combination of the two might be needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Tagging ink text
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ink, hashtags are used on a per-line basis. They exist for that line but
    remain part of the current hashtags until the next part of the story is loaded
    using the `Continue()` or `ContinueMaximally()` methods. In this section, we will
    review an example that uses hashtags with dialogue and the name of the speaker
    as part of a single line in ink. We will learn how the `currentTags` property
    is affected using the `Continue()` and `ContinueMaximally()` methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub; these are under the name of *Chapter10-TaggingInkText*. Only
    selected parts of the code will be shown as they relate to the concepts examined
    in this section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Dialogue lines are meaningless unless attributed to a character within a piece
    of work. This helps establish who is communicating and enables you to build continuity
    within the story. In the `Chapter10-TaggingInkText` example, each line of dialogue
    ends with the name of its speaker as a hashtag in ink. This helps attribute who
    is communicating each line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1 (InkDialogueTags.ink):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The ink code of *Example 1* contains the lines of dialogue and the name of
    the speaker for each line. Moving over to Unity, this translates into using the
    `currentTags` property to access the tags after at least one use of the `Continue()`
    or `ContinueMaximally()` methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2 (InkStoryScript.cs):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In *Example 2*, because the `currentTags` property is a `List<string>`, the
    first (`0`) position can be retrieved using the number of its index. The result
    is the separation of the tagged speaker and their lines in Unity despite them
    being written as one line in ink.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Hashtags are a powerful tool in which to add extra data to a single line in
    ink. As demonstrated in this section, they can be used to add the name of the
    character communicating the line at the end each time. However, there is another
    way to achieve the same outcome. In the next section, we will repeat the same
    general code but use *speech tags* in front of each line instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Using speech tags
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In creative writing, a **speech tag** appears before or after some dialogue
    and signals who is doing the communicating. For example, a common example found
    in many novels might use the word *said* in the following way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The use of *Dan said* acts as a *tag* to the speech captured in the quotation
    marks. It signals who is doing the talking (*Dan*) and what is being said (*Hello*).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, many people who write for games or other interactive projects follow
    a slightly different format where the name of the speaker appears before the speech.
    This style borrows from conventions found in screenwriting. The same words used
    in the previous example might appear as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the updated form, the use of quotation marks is dropped, and the name of
    the speaker precedes their words. There is also an introduction of a colon (`:`).
    This marks the end of the speaker and the beginning of their words. In screenwriting,
    both the name of the speaker and their dialogue will be centered. However, in
    an updated form that is more commonly used as part of game writing, this formatting
    is dropped, and the text appears as part of one line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found inside the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-UsingSpeechTags`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The ink code in `Chapter10-UsingSpeechTags` follows a different pattern from
    the one found in the previous section. Instead of the name of the speaker included
    as a hashtag after the dialogue lines, it now precedes it. Often, this format
    is used for dialogue by writers working on video games and other interactive projects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3 (InkSpeechTags.ink):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the *Example 3* code is run in Inky, because the code is no longer using
    hashtags, the first output and weave will be updated:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Speech tag usage in Inky'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B17597.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Speech tag usage in Inky
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Immediately, there is a visual difference between using ink hashtags and formatting
    the dialogue using speech tags. When testing the code in Inky, it is obvious who
    is communicating because their name will precede the text. However, while testing
    in Inky is easier, the removal of the hashtags within the ink code means the `currentTags`
    property cannot be used. Instead, more C# code must be added to parse the name
    from each line of text.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect, parse, and remove the use of the colon (`:`) within the ink output,
    multiple lines of C# code are needed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4 (InkStoryScript.cs):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Example 4* now detects whether a colon (`:`) exists in the output using the
    `Contains()` method. If it does, the string is split into two parts using the
    `Split()` method. The colon (`:`) is then trimmed from the first (`0`) string
    using the `Trim()` method and its value is then used for the speaker''s name.
    The second (`1`) string is used for the output of Ink.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The result of this new code appears to be the same as the previous section.
    However, it uses speech tags to mark who is speaking and when. This makes it easier
    to test the ink code outside of Unity, as hashtags in ink have no meaning in Inky.
    However, this approach also comes with the issue that a colon (`:`) can *only*
    appear as part of the speech tag. If the text contains a colon, the C# code might
    become confused and attempt to split the text as though it contained a speech
    tag instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will compare each of the approaches outlined earlier:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The *first* approach, using hashtags in ink, allows us to add extra data to
    a single line and then use the `currentTags` property to retrieve this in the
    C# code.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *second* approach, using speech tags directly in the text, makes the ink
    code easier to test but creates a need for more C# code to parse the resulting
    ink.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will mention in the next section, there might be contexts in which both
    approaches can be combined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing approaches to tagging dialogue
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ink, hashtags add extra data per line. They can be used, as we learned in
    the *Tagging ink text* section, to add hashtags to each line of dialogue and then
    retrieve this data using the `currentTags` property in C# code as part of a Unity
    project. However, hashtags in ink come with two issues. The first is that they
    can only be used *per line*. The second is that only *one tag per line* can be
    used at a time. This makes hashtags very useful, for example, in the task of adding
    who is communicating to the line, but it also means they can only be used once
    per line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Dialogue can be directly marked using speech tags in the text. As we learned
    in the *Using speech tags* section, a colon can be used to mark who the speaker
    is and what they are communicating. This can be very useful for testing in Inky,
    as the speaker and their lines are closely connected and appear together. However,
    using speech tags in ink requires additional C# code to understand the output.
    Additionally, it means the colon can only be used as part of speech tags, as any
    other user might create confusion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches have benefits and potential obstacles when used separately.
    However, there are also contexts in which both approaches might be combined to
    present the name of the speaker using speech tags and to convey extra data using
    a tag in ink at the same time. For example, many games not only present text to
    a player but also use audio, video, or some type of animation closely linked to
    the text itself. In these cases, the text could contain a speech tag and the ink
    code could also use tags to signal that additional media should be played as part
    of the combined delivery of the dialogue to a player.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'For games with spoken dialogue lines, it is very common to use a database or
    a spreadsheet of the text line and its corresponding audio based on a naming convention
    as part of the same row. Depending on the team, company, and other factors, the
    naming convention might use specific formatting or numbers, but a general example
    might include the type of audio, the character''s name, their state of mind or
    emotion, and any additional information for the context, level, or area of the
    game:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because ink hashtags can add extra data, a single line within the ink code can
    use speech tags to mark who was communicating and then use the hashtag after the
    line with the media file to play. Such code will combine both approaches.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found inside the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-CombiningTags`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The ink code in the `Chapter10-CombiningTags` example uses the combined approach.
    It includes both the name of the speaker preceding the dialogue lines and the
    use of a hashtag with the corresponding media file or reference to be used when
    the line is shown:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5 (InkCombiningTags.ink):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For simplicity, the project for this section only displays the text of the
    hashtag. By adding an extra `Text` game object and associating it with an existing
    property, the adjusted C# code will incorporate the changes to parsing speech
    tags along with the usage of the `currentTags` property:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 6 (InkStoryScript.cs):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In *Example 6*, the new code tests for the number of entries in the `currentTags`
    property. If it contains at least one hashtag, the first (`0`) entry is used as
    text for a `Text` game object. When run, the project shows the speaker, their
    communication, and the name of the media file that will be played or used as part
    of the dialogue in a smaller font.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will recreate some common patterns found in video game
    dialogue. We will learn how to create a click-to-continue pattern as well as more
    complex dialogue trees for players to explore. There will also be advice for those
    starting new projects on how to plan and then allow the code in ink to guide you
    to create an interface in Unity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Dialogue loops and story knots
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing dialogue in ink often means being aware of how it will be used with
    other systems. In the previous section, we investigated two approaches to using
    tags when writing single lines of dialogue. In this topic, we will move away from
    a focus on individual lines and work with the larger structures within an ink
    project. By inspecting two common patterns in which to present choices to a player,
    we will learn how knots in ink can be reused within projects to save future time
    and effort. The last section in this topic also includes advice for starting a
    new project or converting it using ink.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it appears most often, we will begin with a pattern that appears in
    the *Writing dialogue in ink using tags* section as part of the ink code examples
    using tags: click to continue.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Click to continue
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found inside the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-ClickToContinue`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: There are many repeating patterns found in video game writing. One of the most
    common is the **click-to-continue** pattern. This is the presentation of information
    across a series of messages to a player, where they must press a button or click
    on the screen to progress through them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'In ink, one way to create the click-to-continue pattern is with a single choice
    and then, usually, a gathering point to collapse the weave right after it. In
    its most simplistic form, it only contains these concepts and a single word to
    indicate an action, such as *Continue*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Breaking out the click-to-continue code into a knot allows a writer to reuse
    the same section multiple times by writing it once and then tunneling to it and
    back again when needed. In an extended example, the use of a specific knot for
    this purpose saves more lines of code the more times it appears:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 7 (InkClickToContinue.ink):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the code for *Example 7*, the `continue` ink knot is reused multiple times.
    Each usage tunnels to the knot and returns. This allows the code to decrease the
    number of overall lines.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the structure in ink, the amount of C# code can also be reduced. The
    pattern in the ink code can be reflected in a simplified technique in the C# code
    by providing a method and attaching to the overall panel holding two `Text` game
    objects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 8 (InkStoryScript.cs):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the new *Example 8* code, the `ProgressDialogue()` method is used by a `Panel`
    game object as part of an **EventTrigger** component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Event Trigger on the Panel game object'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B17597.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Event Trigger on the Panel game object
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: By associating the `ProgressDialogue()` method with the `Panel` game object,
    you can click on a visual representation of a dialogue. This then loads the next
    part of the click-to-continue pattern based on the ink code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'While the click-to-continue pattern is the most common, there is another, more
    advanced pattern found in many role-playing games and narrative-heavy interactive
    projects: dialogue trees. In this pattern, multiple options are presented with
    each expanding out to separate branches of dialogue for players to explore. In
    the next section, we will learn how to create this pattern in ink and how new
    options can be easily added to branches.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Counting choices for trees
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ink, a weave is composed of one or more choices. Depending on the code following
    each choice, multiple levels can be created, and the flow of an ink story can
    branch off into different paths. When it comes to presenting options, there are
    often contexts where a user will progress through what is known as a **dialogue
    tree**. The use of the word *tree* is named after the shape created by the different
    parts, or branches, with all of them together as a single trunk.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, in role-playing and narrative-heavy games, this pattern appears as part
    of a scene with information about an event or as part of a character explaining
    something to a player. In these scenarios, the normal use of weaves does not quite
    work as intended. Instead of needing to pick a single choice among a set, we need
    to progress *across* the collection instead. For this, a special built-in ink
    function is required: `CHOICE_COUNT()`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The ink runtime keeps track of the current number of options within the loaded
    chunk. This number can be accessed as part of the `CHOICE_COUNT()` ink function.
    When used as part of a conditional option in ink, this allows an author to limit
    the number of options presented to a reader by comparing the current count with
    the value returned by the `CHOICE_COUNT()` function. However, to keep track of
    values across loops, a variable is required:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 9 (oneBranch.ink):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The use of the `count` variable in *Example 9* records the current choice count
    at the start of the loop. Then, for each choice in turn, the value is compared
    with the increased number of uses of the choice before the comparison. The effect
    is the loading of each choice, in turn, from the set. At the beginning of the
    loop, the `This is the first` option will be provided. The use of a gathering
    point will automatically loop the code. This will continue until there are no
    choices left except the sticky choice of `Return`. This last choice will always
    remain and allow the player to either close the dialogue or *return* to a previous
    point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'This model can be extended into multiple branches as well. For each tree, there
    needs to be a separate knot or stitch with tunnels used to move between to maintain
    the flow of the ink story. The use of multiple sections with their choice counts
    also means using another ink concept: temporary variables. The `temp` keyword
    can be used inside any knot or stitch to create a variable that does not exist
    outside of it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10 (multipleBranches.ink):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code for *Example 10*, each branch is broken out into its own
    stitches within a larger collected knot. Starting with the `loop` knot, threads
    are used to pull in the two stitches and create a unified appearance of options
    from two different parts of the code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the structure of the project, the `CHOICE_COUNT()` ink function
    can be used to limit one choice per set, in order, or a more traditional collection
    can be created. Each of these approaches provides different ways in which to create
    a dialogue tree for a player to explore. They can either exhaust each option one
    after another or use tunnels to pass the flow to the knot containing the tree
    structure and then back again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we examined two different structures for dialogue systems:
    click-to-continue and dialogue trees. In the last topic in this chapter, we will
    finally transition from ink structures into their visual representations in Unity.
    We will examine two models for presenting options to users: lists and radial menus.
    We will determine when each is best used and how the models affect both the structures
    in ink and the designs in Unity.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: User interface models for conversations
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a long history of presenting dialogue options to players in video
    games and other interactive projects. From the earliest text prompts to complicated
    layers of menus in more modern video games, each generation of video game systems
    has introduced different methods of presenting information. However, two general
    models appear in many games: lists and radial menus. They can be explained as
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Based on the original presentation of one choice after another in a vertical
    arrangement, the **list pattern** first appeared in early computer games and continues
    in visual designs where there is more space to show a variety of longer-text options
    to a player.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second model, the **radial menu pattern**, generally appears as part of
    role-playing games on video game consoles or mobile game spaces where there is
    limited visual space and, thus, options are arranged in a circle for easy access
    when using a controller.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first section, we will start with lists. As we have already mentioned
    in multiple Unity examples across this book, and in earlier topics in this chapter,
    the vertical arrangement of options is a very common approach. However, we will
    discuss some common pitfalls when using this model and review several examples
    where they are best used and others where you might want to avoid them before
    we move on to cover the radial menu model next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Listing dialogue options
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one question we should ask when considering the user interface model
    of a list: how much visual spacing is allowed for each option? In computer games
    focused on text or with narrative-heavy designs, the list model is often the best
    to use. However, the reason for this is based not on computer games themselves,
    but on the assumed input peripherals used with the system. Often, computer games
    use the mouse as a primary input. This means a user can click on various things
    and scroll through a long *list* of options. Because the user is accustomed to
    this form of input and is willing to move through a longer presentation of text,
    the list is often a great model to follow.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-ListingOptions`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In some role-playing or visual novel-based video games, the player might be
    presented with many options based on their past associations with other characters,
    political parties, or organizations. The number of options might also be influenced
    by certain skills, traits, or other in-game perks that grant the player additional
    benefits within dialogue selection. The `Chapter10-ListingOptions` project is
    based on such a premise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dialogue presented in the ink code, the player is aboard a passenger
    ship and on their way to another city where they encounter another character in
    a crew-only area. There are multiple programmed options for the player to consider,
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 11 (InkListingOptions.ink):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because of the amount of visual space taken up by the dialogue selection in
    the code for *Example 11*, the multiple options extend off the screen. The player
    must scroll down and carefully read over the list in order to consider their choice.
    Such an interface works well in visual designs with a heavy narrative focus or
    on platforms such as desktop computers where the user might feel comfortable reviewing
    everything before making a final decision when progressing through a dialogue
    tree. However, this is not the only model a developer might want to use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine the radial menu pattern. Popularized by
    role-playing games on video game consoles where the number of inputs is limited,
    the radial menu pattern presents not only a design challenge but a writing one
    as well. As we will explore in more detail, the radial menu pattern limits the
    amount of text that appears on the screen and forces a developer to make sure
    the intent of a single word or phrase conveys the outcome the player will experience
    when choosing an option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Presenting a radial menu for dialogue
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many video game controllers have at least one joystick and a limited number
    of buttons. Because of this reduced set of inputs, designing a user interface
    for a player to decide between multiple options often means presenting options
    arranged in a clockwise pattern on the screen. More commonly, this visual design
    pattern is called a **radial menu**. This term takes its name from the mathematical
    concept *radius*, which is the distance from the center of a circle to its perimeter.
    A *radial* menu shows options based on a circular pattern.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The completed project for this section can be found in the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-OptionWheel`. Only selected parts
    of the code will be shown as they relate to the concepts examined in this section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Demonstrating a common use of the radial menu, the `Chapter10-OptionWheel`
    example presents a scene where a player must confront a door and has multiple
    skills based on their in-game statistics. The outcomes for each option are represented
    by the name of the statistic:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 12 (InkOptionWheel.ink):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the code for *Example 12*, there are four options, each with the name of
    an example game statistic. When arranged in a simplified *radial* pattern, they
    might appear as the following in Unity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The arrangement of dialogue options as a simplified radial
    menu'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B17597.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – The arrangement of dialogue options as a simplified radial menu
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The **radial menu pattern** comes with the built-in limitation of reduced visual
    space. As mentioned in the *Listing dialogue options* section, the visual space
    given to the presentation of the options dictates how the information is presented.
    For the radial menu model, this is even more true.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: As with the code for *Example 12*, the options presented on the screen must
    be matched to either the in-game statistics or the known outcomes to the player.
    For example, a player might know that if they select a certain icon, it will match
    a certain action. In these scenarios, they will be limited to no words in Ink
    to represent the option, with Unity taking more of the load to represent the option
    to the player as part of the user interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed the radial menu pattern. Presenting options in
    a clockwise arrangement, this pattern most often appears as part of a dialogue
    system for video game consoles with controllers or as part of a visual design
    with limited visual space. However, the use of the pattern has a direct effect
    on how options are written in ink. In one pattern, that is, lists, longer sentences
    can be included, but a player might not see all of them at once. For the other
    model, that is, the radial menu pattern, the options are only single words or
    perhaps even icons that represent more complex reactions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored three different approaches to dialogue systems.
    In the first approach, we worked through hashtags and speech tags. In ink, we
    can add a hashtag to the end of a line. This allows you to add extra information
    per line such as the speaker for a line of dialogue or which media file to play
    for the line. With speech tags, a colon (`:`) can be added in front of the dialogue
    to mark the speaker. The speech tag helps with testing with Inky but requires
    more C# code in Unity. Hashtags and speech tags can be combined in various contexts
    where the hashtag can represent the media file or additional data for the developer
    whereas the speech tag contains who is communicating the line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In the second approach, we zoomed out from the line-by-line emphasis with tags
    to the structures within ink. To replicate a click-to-continue pattern, we can
    combine a knot and the use of tunnels in ink. This is also true of dialogue trees,
    which we can break out into their own stitches within a larger knot. We also learned
    about the use of the `CHOICE_COUNT()` ink function and how to progress through
    a set of options.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In the final approach, we zoomed out from ink to consider visual designs in
    Unity and how they affect the writing of dialogue. The pattern used, whether a
    list or radial menu, will dictate how dialogue is created within ink. For a list,
    where each option can include multiple lines of text, a player will only see a
    limited selection at a time. For the radial menu pattern, where options are presented
    in a clockwise pattern on the screen, the dialogue within ink will be limited
    or nonexistent. In either case, the visual space for user interface elements directly
    affects how options are presented to a player.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159), *Quest Tracking
    and Branching Narratives*, we will move from smaller dialogue systems to the much
    larger ones of quest tracking and creating branching narratives. While many video
    games often present dialogue to a player, some track multiple values over longer
    periods. We will examine how the `LIST` ink keyword can be used to track quest
    progression and how larger ink projects can be broken up across multiple files
    for easier asset maintenance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a hashtag in ink?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between a hashtag and a speech tag?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How did the term *dialogue tree* get its name?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “**对话树**”这个术语是如何得名的？
- en: What is a list pattern?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**列表模式**？
- en: What is a radial menu pattern?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**径向菜单模式**？
