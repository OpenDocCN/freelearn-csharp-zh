- en: Chapter 6. Working with Mono
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使用Mono
- en: Unity supports two main scripting languages, namely, C# and JavaScript. Developers
    should select one of these two from the outset and apply it consistently throughout
    their project; this writes all scripts in the selected language. Failure to do
    so (by mixing script files in different languages) typically causes unnecessary
    headache and confusion. However, once you've settled on a language, such as C#,
    it usually won't offer everything you need it to do to create games. C#, on its
    own, can neither load and parse XML files to support save-game data, nor can it
    create window objects and GUI widgets to perform advanced search and query behaviors
    on complex data sets and collections. To achieve these additional behaviors and
    lots more, we must turn to external libraries. Some libraries can be purchased
    directly from the Unity's Asset Store, and these are typically used for a specific
    and dedicated purpose. However, Unity ships with the Mono Framework, which is
    a free, cross-platform, and open source implementation of the Microsoft .NET Framework
    (a programming library), and it offers most classes available in this library.
    The .NET Framework features classes to handle strings, file input-output, search
    and sort data, keep track of dynamic lists, parse XML, and more. This means that
    through Mono an extensive toolkit is open to you to effectively and efficiently
    manage data in your application. This chapter explores some of the many ways in
    which Mono can be deployed in a Unity application by considering lists, stacks,
    **Language Integrated Query** (**Linq**), regular expressions, enumerators, and
    so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持两种主要的脚本语言，即C#和JavaScript。开发者从一开始就应该选择这两种语言中的一种，并在整个项目中一致使用；这样所有脚本都使用所选语言编写。如果不这样做（通过混合不同语言的脚本文件），通常会导致不必要的头痛和困惑。然而，一旦你确定了一种语言，比如C#，它通常不会提供你创建游戏所需的所有功能。C#本身不能加载和解析XML文件以支持保存游戏数据，也不能创建窗口对象和GUI小部件以在复杂的数据集和集合上执行高级搜索和查询行为。为了实现这些附加行为和更多功能，我们必须转向外部库。一些库可以直接从Unity的Asset
    Store购买，这些库通常用于特定的和专门的目的。然而，Unity附带Mono框架，这是一个免费、跨平台和开源的Microsoft .NET Framework（编程库）实现，并提供该库中的大多数类。.NET
    Framework具有处理字符串、文件输入输出、搜索和排序数据、跟踪动态列表、解析XML等功能。这意味着通过Mono，你可以获得一个广泛的工具集，以有效地和高效地管理应用程序中的数据。本章通过考虑列表、栈、**语言集成查询**（**Linq**）、正则表达式、枚举器等方式，探讨了Mono在Unity应用程序中部署的许多方法。
- en: 'The following screenshot shows the Mono Framework interface:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Mono框架界面：
- en: '![Working with Mono](img/0655OT_06_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![使用Mono](img/0655OT_06_01.jpg)'
- en: The Mono Framework ships with the Unity engine
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Mono框架随Unity引擎一起提供
- en: Lists and collections
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和集合
- en: 'Perhaps, the most common task when programming games is to store lists of data.
    The nature of this data varies tremendously: high scores, player stats, enemy
    stats, inventory items, weapons, power-ups, level lists, and more. Wherever possible,
    choose static arrays to hold data due to their speed and efficiency. Static arrays
    were considered in detail in [Chapter 1](ch01.html "Chapter 1. Unity C# Refresher"),
    *Unity C# Refresher*. In short, static arrays are created ahead of time, and their
    maximum capacity is fixed from the outset. Items can be added and removed from
    them at runtime, but their total size can never change. If their maximum capacity
    is not utilized, then space would be wasted. Static arrays, as their name implies,
    are an excellent choice for storing lists of data that remain constant, such as
    all levels in the game, all weapons that can possibly be collected, all power-ups
    that can possibly be collected, and so on.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏编程中，最常见的一项任务可能是存储数据列表。这种数据的特点千差万别：高分、玩家统计数据、敌人统计数据、库存物品、武器、升级、关卡列表等等。尽可能选择静态数组来存储数据，因为它们速度快、效率高。静态数组在[第1章](ch01.html
    "第1章。Unity C# 快速回顾")中进行了详细讨论，*Unity C# 快速回顾*。简而言之，静态数组是在事先创建的，它们的最大容量从一开始就是固定的。可以在运行时向它们添加和删除项目，但它们的总大小永远不会改变。如果它们的最大容量没有得到利用，那么空间就会被浪费。正如其名称所暗示的，静态数组是存储保持恒定的数据列表（如游戏中的所有关卡、可能收集的所有武器、可能收集的所有升级等等）的绝佳选择。
- en: However, you'll often need dynamic arrays, which can grow and shrink in capacity
    to exactly accommodate the data you need as it changes, such as when enemies are
    spawned and destroyed, inventory items come and go, weapons are collected and
    discarded, and so on. The Mono Framework offers many classes to maintain lists
    of data. The three main classes are `List`, `Stack`, and `Dictionary`. Each of
    these is useful for a specific purpose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你通常会需要动态数组，它可以根据数据的变化精确地增长和缩小容量，例如，当敌人被生成和销毁，库存物品来来去去，武器被收集和丢弃等情况。Mono框架提供了许多类来维护数据列表。这三个主要类是`List`、`Stack`和`Dictionary`。每个类都适用于特定的目的。
- en: The List class
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`List`类'
- en: 'If you need an unordered, sequential list of items of any single data type,
    that is, a list that grows and shrinks to match the size of the stored data, then
    the `List` class is ideal. `List` is especially good to add and remove items and
    sequentially iterating through all stored items. In addition, the `List` objects
    are editable from the Unity Object Inspector. The following code sample 6-1 uses
    a sample C# file `Using_List.cs`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个无序的、按顺序排列的任何单一数据类型的项列表，即一个随着存储数据的大小而增长和缩小的列表，那么`List`类是理想的。`List`类非常适合添加和删除项，以及按顺序遍历所有存储的项。此外，`List`对象可以通过Unity对象检查器进行编辑。以下代码示例6-1使用了一个示例C#文件`Using_List.cs`：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More details on using `List` can be found in the book's companion files (code
    bundle) at `Chapter06\Collections`. You can also see the `List` class reference
    documentation in the MSDN at [http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于使用`List`的详细信息可以在本书的配套文件（代码包）中找到，位于`Chapter06\Collections`。你还可以在MSDN上查看`List`类的参考文档，网址为[http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx)。
- en: 'The following are the comments for code sample 6-1:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例6-1的注释：
- en: '**Line 03**: To use the `List` class, you must include the `System.Collections.Generic`
    namespace.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第03行**：要使用`List`类，你必须包含`System.Collections.Generic`命名空间。'
- en: '**Line 06**: If your list data type is declared as a `System.Serializable`
    class, then the list would be shown in the Object Inspector.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第06行**：如果你的列表数据类型被声明为`System.Serializable`类，那么列表将在对象检查器中显示。'
- en: '**Line 20**: You can declare and initialize a new list instance in just one
    statement inside the class members'' declaration.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第20行**：你可以在类成员声明中仅用一行语句声明和初始化一个新的列表实例。'
- en: '**Line 27**: New objects are immediately added to the end of the list using
    the `Add` method.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第27行**：使用`Add`方法立即将新对象添加到列表的末尾。'
- en: '**Line 30**: Items can be removed using several methods. `RemoveRange` lets
    you delete several consecutive items from the list. Other removal methods include
    `Remove`, `RemoveAll`, and `RemoveAt`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第30行**：可以使用多种方法删除项。`RemoveRange`允许你从列表中删除多个连续的项。其他删除方法包括`Remove`、`RemoveAll`和`RemoveAt`。'
- en: '**Line 33**: You can cycle through all items in a list using a `foreach` loop.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第33行**：你可以使用`foreach`循环遍历列表中的所有项。'
- en: '**Lines 27-33**: Generally, don''t add or remove items to or from a list while
    looping through it.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第27-33行**：通常，在遍历列表时不要向列表中添加或删除项。'
- en: 'The following screenshot shows the `List` class in the Object Inspector:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了对象检查器中的`List`类：
- en: '![The List class](img/0655OT_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![The List class](img/0655OT_06_02.jpg)'
- en: Viewing the List class in the Object Inspector
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象检查器中查看`List`类
- en: 'The `List` class supports several methods to remove items either individually
    or collectively, and these are intended to be used outside list iterations (loops).
    However, there are times when it''s convenient, or seems simplest, to remove items
    while iterating through a loop, such as when you need to remove each item after
    processing it. A classic case is when you need to delete all reference type objects
    in the scene, such as enemies, while also removing their entry in the array to
    avoid null references. Item removal in a loop, however, can cause problems, because
    it''s easy for an iterator to lose track of where it is and where it should go
    within the array as the total item count changes during the loop. To loop and
    remove in one process, you should traverse the array backwards from the end to
    the start, as opposed to forwards, as shown in the following code sample 6-2:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类支持几种方法来单独或集体地删除项目，这些方法旨在在列表迭代（循环）之外使用。然而，有时在迭代过程中删除项目既方便又简单，例如当你需要处理完每个项目后删除它时。一个典型的例子是在需要删除场景中所有引用类型对象（如敌人）的同时，也删除它们在数组中的条目以避免空引用。然而，在循环中删除项目可能会引起问题，因为迭代器很容易在循环过程中丢失对数组的跟踪，尤其是在项目总数在循环过程中变化时。为了在单个过程中循环和删除，你应该从数组末尾开始向前遍历，而不是从前往后，如下面的代码示例
    6-2 所示：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Dictionary class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Dictionary` 类'
- en: The `List` class is, perhaps, one of the most useful classes in the Mono Framework
    for in-memory data storage. However, let's not forget the `Dictionary` class (similar
    to the `std::map` class in C++). This class is especially useful when you need
    more than just a simple list of items. If you need to search for and get instant
    access to specific elements based on a key value, then the `Dictionary` class
    is essential. For each item in the list, you must save a corresponding key or
    ID that uniquely identifies the item from all others. The `Dictionary` class then
    allows you to get instant access to this item, based solely on its key. This makes
    the `Dictionary` class useful as a true dictionary for word games, for example,
    if you need to look up the meaning or score-value of specific words in a large
    dictionary or database of words. The word itself would be the key, and the word
    definition would be the value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类可能是 Mono 框架中用于内存数据存储的最有用的类之一。然而，我们不要忘记 `Dictionary` 类（类似于 C++ 中的 `std::map`
    类）。这个类在需要不仅仅是简单项目列表的情况下特别有用。如果你需要根据键值搜索并立即访问特定元素，那么 `Dictionary` 类是必不可少的。对于列表中的每个项目，你必须保存一个相应的键或
    ID，该键或 ID 可以唯一地识别该项目。然后 `Dictionary` 类允许你仅基于其键立即访问此项目。这使得 `Dictionary` 类在真正的字典中非常有用，例如，如果你需要在一个大型字典或单词数据库中查找特定单词的含义或分数值。单词本身将是键，而单词定义将是值。'
- en: Now, of course, you can replicate this kind of behavior using multiple `List`
    objects instead of the `Dictionary` class. However, the `Dictionary` class is
    extremely fast in terms of performance, almost lightning fast. You can store vast
    quantities of data inside the dictionary at very little performance cost. This
    makes them highly valuable for a quick data lookup from key values, as shown in
    the following code sample 6-3;
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在你可以使用多个 `List` 对象而不是 `Dictionary` 类来复制这种行为。然而，在性能方面，`Dictionary` 类非常快，几乎像闪电一样快。你可以在字典中以极小的性能成本存储大量数据。这使得它们对于从键值快速查找数据非常有价值，如下面的代码示例
    6-3 所示；
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the comments for code sample 6-3:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-3 的注释：
- en: '**Line 03**: As with the `List` class, you must include the `System.Collections.Generic`
    namespace'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 03**：与 `List` 类一样，你必须包含 `System.Collections.Generic` 命名空间'
- en: '**Line 08**: Here, the dictionary is declared and created in one line; unlike
    the `List` class, `Dictionary` does not appear in the Unity Object Inspector'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 08**：在这里，字典在一行中声明和创建；与 `List` 类不同，`Dictionary` 不出现在 Unity 对象检查器中'
- en: '**Lines 13-23**: The `Dictionary` class is populated using the `Add` method'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 13-23**：`Dictionary` 类使用 `Add` 方法进行填充'
- en: '**Line 27**: Elements in the `Dictionary` class are accessed much like arrays,
    except by specifying each element using its key data instead of an array index'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 27**：在 `Dictionary` 类中访问元素的方式与数组类似，只是通过指定每个元素使用其键数据而不是数组索引'
- en: Tip
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More details on using `Dictionary` can be found in [Chapter 4](ch04.html "Chapter 4. Event-driven
    Programming"), *Event-driven Programming*, when considering event-driven programming
    with an `EventManager`.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于使用`Dictionary`的更多详细信息，可以在[第4章](ch04.html "第4章。事件驱动编程") *事件驱动编程*中找到，当考虑使用`EventManager`进行事件驱动编程时。
- en: The Stack class
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Stack`类'
- en: If you're making a card game where players should pick the top card from a deck,
    if you need an undo history, if you're coding customized path finding, or if you're
    creating a complex spell-casting system or even a Tower of a Hanoi puzzle game
    ([http://en.wikipedia.org/wiki/Tower_of_Hanoi](http://en.wikipedia.org/wiki/Tower_of_Hanoi)),
    the chances are high that you'll need a stack somewhere along the line. A stack
    is a special kind of list based on the **Last in, first out** (**LIFO**) model.
    The concept is about stacking. You can push items into the list, and these stack
    up one atop the other in a vertical tower, with the most recently pushed item
    always at the top. Then, you can pop items from the top of the stack (remove them
    from the array) one by one. The order in which you pop items is always the inverse
    of the order in which they were pushed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在制作一个玩家需要从牌堆中抽取顶牌的卡牌游戏，如果你需要一个撤销历史，如果你正在编写定制的路径查找，或者如果你正在创建一个复杂的施法系统，甚至是一个汉诺塔谜题游戏([http://en.wikipedia.org/wiki/Tower_of_Hanoi](http://en.wikipedia.org/wiki/Tower_of_Hanoi))，那么你很可能在某个环节需要使用到`Stack`。栈是一种基于**后进先出**（**LIFO**）模型的特殊列表。这个概念是关于堆叠的。你可以将项目推入列表，这些项目会堆叠成一个垂直的塔，最近推入的项目始终在顶部。然后，你可以从栈顶（从数组中移除）逐个弹出项目。你弹出项目的顺序始终是它们被推入的顺序的相反。
- en: 'This is why `Stack` is especially useful for the undo or rewind functionality.
    Refer to the following code sample 6-4 for an example on how to use `Stack`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`Stack`在撤销或倒退功能上特别有用。请参考以下代码示例6-4，了解如何使用`Stack`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: IEnumerable and IEnumerator
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`IEnumerable`和`IEnumerator`'
- en: 'When you''re working with collections of data, whether `List`, `Dictionary`,
    `Stack`, or others, you''ll typically want to iterate (or traverse) all items
    in the list or at least some items, based on a specific criteria. In some cases,
    you''ll want to loop through all items in sequence or some items. Most often,
    you''ll want to traverse the items forwards in sequence, but as we''ve seen, there
    are times when reverse traversing is also suitable. You can loop through items
    using a standard for loop. However, this raises some annoyances that the interfaces
    of `IEnumerable` and `IEnumerator` can help us solve. Let''s see what the annoyances
    are. Consider the `for` loop in the following code sample 6-5:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理数据集合时，无论是`List`、`Dictionary`、`Stack`还是其他，你通常会想遍历（或遍历）列表中的所有项目或至少基于特定标准的一些项目。在某些情况下，你可能想按顺序遍历所有项目或某些项目。最常见的是，你希望按顺序正向遍历项目，但正如我们所看到的，有时反向遍历也是合适的。你可以使用标准的`for`循环遍历项目。然而，这引发了一些问题，`IEnumerable`和`IEnumerator`的接口可以帮助我们解决这些问题。让我们看看有哪些问题。考虑以下代码示例6-5中的`for`循环：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are three main annoyances while using a `for` loop. Let's start with the
    first two. The first is that the syntax is not especially inviting for a loop
    that just cycles from left to right, from beginning to end, and we must always
    use an integer iterator variable (`i`) to access each array element as the loop
    proceeds. The second is that the iterator itself is not truly "bounds safe". It
    can, in fact, be incremented or decremented either above or below the array limits
    and cause an out-of-bounds error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`for`循环时，有三个主要的不便之处。让我们先从前两个说起。第一个是不太吸引人使用一个仅仅从左到右、从开始到结束循环的语法，我们必须始终使用一个整数迭代变量（`i`）来访问每个数组元素，随着循环的进行。第二个是迭代器本身并不真正是“界限安全”的。实际上，它可以在数组限制之上或之下增加或减少，从而引发越界错误。
- en: 'These issues can, to some extent, be fixed using the neater `foreach` loop,
    which is bounds safe and uses a simpler syntax, as shown in following code sample
    6-6:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在一定程度上可以通过更整洁的`foreach`循环来解决，它具有界限安全性和更简单的语法，如以下代码示例6-6所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `foreach` loop is simpler and is to be preferred for readability, but there's
    more going on here than first meets the eye. The `foreach` loop works only for
    classes that implement the `IEnumerable` interface. Objects that implement `IEnumerable`
    must return a valid instance to an `IEnumerator` interface. So, for an object
    to work in a `foreach` loop, it must depend on two other interfaces. The question
    that then arises is why is there all this internal complexity for simple looping
    or traversal behavior. The answer is, not only do the `IEnumerable` and `IEnumerator`
    solve the first two problems of simpler syntax and bounds-safe iteration by way
    of the `foreach` loop, but they also solve a third problem. Specifically, they
    allow us to loop through or iterate groups of objects that are not even truly
    array types; that is, they let us iterate through many different types of objects,
    whether or not they're in an array, as though they were in an array. This can
    be very powerful. Let's see this in action in a practical example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环更简单，在可读性方面更受欢迎，但这里的情况比表面看起来要复杂得多。`foreach` 循环仅适用于实现了 `IEnumerable`
    接口的类。实现了 `IEnumerable` 的对象必须返回一个有效的 `IEnumerator` 接口实例。因此，为了使对象能在 `foreach` 循环中工作，它必须依赖于另外两个接口。那么随之而来的问题是，为什么简单的循环或遍历行为会有如此复杂的内部复杂性。答案是，不仅
    `IEnumerable` 和 `IEnumerator` 通过 `foreach` 循环解决了更简单语法和边界安全迭代的前两个问题，而且它们还解决了第三个问题。具体来说，它们允许我们遍历或迭代不是真正数组类型的对象组；也就是说，它们让我们能够像在数组中一样遍历许多不同类型的对象，无论它们是否在数组中。这可以非常强大。让我们通过一个实际例子来看看这个功能是如何工作的。'
- en: Iterating through enemies with IEnumerator
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IEnumerator 遍历敌人
- en: Take, for example, an RPG game that features a medieval world inhabited by many
    different and evil wizard characters (coded in class `Wizard`). For the sake of
    example, these wizards will spawn into the level at random places and random intervals,
    potentially causing untold trouble for the gamer, casting spells, and performing
    evil deeds. The result of such random spawning is that, by default, we cannot
    know in advance how many wizards there will be in the scene at any one time, nor
    can we know where they've been spawned, because it's random. However, there are
    still legitimate reasons why we'd need to find all the wizards; perhaps, all the
    wizards must be disabled, hidden, paused, or killed, or, perhaps, we need a head
    count to prevent overspawning. So, regardless of the wizard spawning and its randomness,
    there are still good justifications for being able to access all the wizards in
    the level on demand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个包含许多不同且邪恶的法师角色（用 `Wizard` 类编码）的中世纪世界为背景的 RPG 游戏为例。为了举例，这些法师将以随机位置和随机间隔出现在关卡中，可能会给玩家带来无法预料的麻烦，施放法术，并执行邪恶行为。这种随机生成的结果是，默认情况下，我们无法预先知道在任何给定时间内场景中会有多少法师，也无法知道它们被生成在哪里，因为这是随机的。然而，我们仍然有合法的理由需要找到所有的法师；也许，所有法师都必须被禁用、隐藏、暂停或杀死，或者，也许我们需要进行人数统计以防止过度生成。因此，无论法师的生成和其随机性如何，仍然有很好的理由能够在需要时访问关卡中的所有法师。
- en: 'We''ve seen already, in [Chapter 2](ch02.html "Chapter 2. Debugging"), *Debugging*,
    one way in which we can retrieve a traversable list of all wizards, as shown in
    the following code sample 6-7:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 2 章](ch02.html "第 2 章。调试") 中看到了一种方法，即 *调试*，我们可以检索所有法师的可遍历列表，如下面的代码示例
    6-7 所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The problem with the `FindObjectsOfType` function is that it's slow and performance
    prohibitive when used frequently. Even the Unity documentation at [http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html](http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html)
    recommends against its repeated use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindObjectsOfType` 函数的问题在于，当频繁使用时，它会变慢，并且性能受限。即使是 Unity 文档在 [http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html](http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html)
    也建议不要重复使用它。'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A sample Unity project using the `IEnumerator` and `IEnumerable` interfaces
    can be found in the book's companion files (code bundle) at `Chapter06\Enumerators`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的配套文件（代码包）中可以找到一个使用 `IEnumerator` 和 `IEnumerable` 接口的 Unity 项目示例，位于 `Chapter06\Enumerators`。
- en: 'So, instead, we can achieve similar behavior using `IEnumerable` and `IEnumerator`,
    and this avoids significant performance penalties. Using these two interfaces,
    we''ll be able to efficiently iterate through all the wizards in the scene, using
    a `foreach` loop, as though they were in an array, as shown in the following code
    sample 6-8:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用 `IEnumerable` 和 `IEnumerator` 实现类似的行为，这避免了显著的性能损失。使用这两个接口，我们将能够高效地遍历场景中的所有巫师，使用
    `foreach` 循环，就像它们在数组中一样，如下面的代码示例 6-8 所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are the comments for code sample 6-8:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-8 的注释：
- en: '**Lines 07 and 39**: Two classes are created here: the first is `WizardEnumerator`,
    which implements `IEnumerator`, and the second is `Wizard`, which implements `IEnumerable`.
    The `WizardEnumerator` class is instantiated simply to iterate over a collection
    of wizards that keeps track of the current wizard in the iteration process. To
    loop through or iterate over all wizards in the scene, it relies on member variables
    for the `Wizard` class, as we''ll see in the upcoming sections.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 07 行和第 39 行**：在这里创建了两个类：第一个是 `WizardEnumerator`，它实现了 `IEnumerator`，第二个是
    `Wizard`，它实现了 `IEnumerable`。`WizardEnumerator` 类被实例化只是为了迭代一个巫师集合，该集合跟踪迭代过程中的当前巫师。为了遍历或迭代场景中的所有巫师，它依赖于
    `Wizard` 类的成员变量，正如我们将在接下来的部分中看到的。'
- en: '**Lines 13, 23, and 29**: The `WizardEnumerator` class implements the methods
    and properties of `IEnumerator`, specifically, `MoveNext` (which iterates over
    to the next wizard in the cycle), `Reset` (which resets the iterator back to the
    first wizard), and `Current` (which returns the active wizard in the cycle).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 13、23 和 29 行**：`WizardEnumerator` 类实现了 `IEnumerator` 的方法和属性，具体来说，`MoveNext`（遍历到循环中的下一个巫师）、`Reset`（将迭代器重置回第一个巫师）和
    `Current`（返回循环中的活动巫师）。'
- en: '**Line 39**: The `Wizard` class encapsulates a wizard character in the scene
    and inherits from two classes: `MonoBehaviour` and `IEnumerable`. This means that
    all the features of both classes come together in this derived class. It internally
    maintains several variables that allow the enumerator to loop through all the
    wizard instances in the scene at any time. First, `Wizard` holds the `FirstCreated`
    and `LastCreated` static members (which are global to all the wizard instances).
    These variables are set when objects are created (see the `Awake` function in
    line 58). `FirstCreated` always refers to the instance of a wizard that was created
    first, and `LastCreated` always to the most recently created instance.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 39 行**：`Wizard` 类封装了场景中的巫师角色，并从两个类继承：`MonoBehaviour` 和 `IEnumerable`。这意味着这两个类的所有功能都结合在这个派生类中。它内部维护了几个变量，允许枚举器在任何时候遍历场景中的所有巫师实例。首先，`Wizard`
    拥有 `FirstCreated` 和 `LastCreated` 静态成员（这些成员对所有巫师实例都是全局的）。这些变量在对象创建时设置（参见第 58 行的
    `Awake` 函数）。`FirstCreated` 总是指向首先创建的巫师实例，而 `LastCreated` 总是指向最近创建的实例。'
- en: '**Lines 48 and 52**: The `Wizard` class also maintains the instance variables,
    `NextWizard` and `PrevWizard`. This implements a doubly-linked list; that is,
    each instance of the wizard points to the previously and subsequently created
    instance, which allows a chain-like connection between all wizards. The first
    wizard will have `PrevWizard` or `null`, and the last wizard will have `NextWizard`
    or `null`. These variables make it possible for the iterator to cycle through
    all wizard instances even when none of them are in an array.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 48 行和第 52 行**：`Wizard` 类还维护了实例变量 `NextWizard` 和 `PrevWizard`。这实现了双向链表；也就是说，每个巫师的实例都指向之前和之后创建的实例，这允许所有巫师之间形成链式连接。第一个巫师将具有
    `PrevWizard` 或 `null`，而最后一个巫师将具有 `NextWizard` 或 `null`。这些变量使得迭代器能够在没有巫师在数组中的情况下遍历所有巫师实例。'
- en: '**Line 86**: The `GetEnumerator` method returns an instance to an `Enumerator`
    object. This is required by the `IEnumerable` interface and allows a `foreach`
    loop across all wizards.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 86 行**：`GetEnumerator` 方法返回一个实例到 `Enumerator` 对象。这是 `IEnumerable` 接口的要求，并允许使用
    `foreach` 循环遍历所有巫师。'
- en: 'Together, the `Wizard` and `WizardEnumerator` classes offer fast, direct, and
    efficient `Wizard` object cycling, even though no array of wizards need to truly
    exist. To see this in practice, in a scene of wizards, the following code sample
    6-9 can enumerate all wizards:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，`Wizard` 和 `WizardEnumerator` 类提供了快速、直接且高效的 `Wizard` 对象循环，即使不需要真正存在一个巫师数组。为了在实践中看到这一点，在一个巫师场景中，以下代码示例
    6-9 可以枚举所有巫师：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also enumerate through all wizards outside a `foreach` loop by accessing
    the `Enumerator` object directly, as shown in the following code sample 6-10:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过直接访问`Enumerator`对象来遍历`foreach`循环外的所有向导，如下面的代码示例6-10所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Strings and regular expressions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和正则表达式
- en: Working with text data is critical and for many reasons. If you need to display
    subtitles, show in-game text, and implement localization functionality (supporting
    multiple languages), then you would be working with text, specifically with Text
    Assets. In Unity, Text Assets refer to any text files included in the Unity project,
    and each asset is treated as one long string even when multiple lines are involved
    (each line is separated by a `\n` escape character). Once your code is presented
    with a string like this, however, there're typically many ways in which you'll
    want to process it. Let's see some common but important string operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与文本数据一起工作至关重要，并且有多个原因。如果您需要显示字幕、显示游戏中的文本以及实现本地化功能（支持多种语言），那么您将处理文本，特别是文本资产。在Unity中，文本资产指的是Unity项目中包含的任何文本文件，即使涉及多行（每行由`\n`转义字符分隔），每个资产也被视为一个长字符串。然而，一旦代码接收到这样的字符串，通常会有许多您想要处理它的方法。让我们看看一些常见但重要的字符串操作。
- en: Null, empty strings, and white space
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空字符串、空字符串和空白
- en: When processing strings, you can't always guarantee validity; sometimes, strings
    are badly formed and don't make sense. For this reason, you'll frequently need
    to validate them before processing. A common way to validate them initially is
    to see whether a string is null, and then (if not null) check the string's length,
    because if the length is `0`, then the string is empty and, therefore, invalid,
    even though it's not `null`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，您不能总是保证其有效性；有时，字符串格式不良且没有意义。因此，在处理之前，您通常会需要验证它们。验证字符串的常见方法首先检查字符串是否为空，然后（如果非空）检查字符串的长度，因为如果长度为`0`，则字符串为空，因此无效，即使它不是`null`。
- en: 'Again, you''ll probably also want to eliminate the possibility that a string
    consists entirely of spaces, because a string that is not `null` and features
    only white space characters will not, in fact, be of `0` length, even though it
    usually means there''s nothing to process. You can validate a string for each
    of these states individually, but the string class in .NET offers a compound or
    all-in-one convenience check for you, specifically the method `IsNullOrWhiteSpace`.
    However, this method was introduced in .NET 4.5, and Mono does not support this
    version. This means a manual implementation is required for equivalent behavior,
    as shown in the following code sample 6-11:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可能还希望消除字符串完全由空格组成的可能性，因为一个既不是`null`又只包含空白字符的字符串实际上长度不是`0`，尽管这通常意味着没有要处理的内容。您可以单独验证字符串的这些状态，但.NET中的字符串类为您提供了复合或一站式便利检查，具体是`IsNullOrWhiteSpace`方法。然而，此方法是在.NET
    4.5中引入的，Mono不支持此版本。这意味着需要手动实现等效行为，如下面的代码示例6-11所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: String comparison
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串比较
- en: 'You''ll frequently need to compare two separate strings, typically, for equality
    to determine whether two strings are identical. You can do this using the `==`
    operator such as `string1 == string2`, but for best performance, use the `theString.Equals`
    method. This method has several versions, all of varying computational expense.
    In general, you should prefer any version that contains an argument of type `StringComparison`.
    When the comparison type is explicitly stated, the operation will perform best,
    as shown in the following code sample 6-12:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会需要比较两个独立的字符串，通常是为了比较它们是否相等，以确定两个字符串是否相同。您可以使用`==`运算符，例如`string1 == string2`，但为了最佳性能，请使用`theString.Equals`方法。此方法有几个版本，计算成本各不相同。通常，您应该选择包含`StringComparison`类型参数的任何版本。当比较类型明确指定时，操作将表现得最好，如下面的代码示例6-12所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `String.Compare` method can be found online in MSDN
    at [http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`String.Compare`方法的更多信息可以在MSDN上找到，网址为[http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx)。
- en: 'Another method to quickly and regularly compare the same two strings for equality
    is to use string hashes, that is, to convert each string into a unique integer
    and then to compare the integers instead, as shown in the following code sample
    6-13:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种快速且定期比较两个相同字符串是否相等的方法是使用字符串哈希，即把每个字符串转换成唯一的整数，然后比较这些整数，如下面的代码示例6-13所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also use the `String.GetHashCode` function from the Mono library to
    retrieve a string's hash code. For more information, visit [http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Mono库中的`String.GetHashCode`函数来获取字符串的哈希码。更多信息，请访问[http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx)。
- en: 'Sometimes, however, you don''t want to compare for equality. Your intention
    might be to determine which string takes more priority alphabetically, that is,
    whether one string would appear before the other if they were both listed alphabetically
    in a dictionary. You can achieve this using the `String.Compare` function. However,
    again, be sure to use a version that features a `StringComparison` type in the
    arguments, as shown in the following code sample 6-14\. With this version, `-1`
    would be returned if `Str1` comes before `Str2`, `1` would be returned if `Str2`
    comes before `Str1`, and `0` would be returned if the two strings are equal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不想比较相等性。你的意图可能是确定哪个字符串在字母顺序上具有更高的优先级，即如果它们在字典中按字母顺序排列，一个字符串是否会出现在另一个之前。你可以使用`String.Compare`函数来实现这一点。然而，再次提醒，确保使用具有`StringComparison`类型参数的版本，如下面的代码示例6-14所示。使用这个版本，如果`Str1`在`Str2`之前，将返回`-1`；如果`Str2`在`Str1`之前，将返回`1`；如果两个字符串相等，将返回`0`。
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although `String.Compare` returns `0` to indicate that two strings are equal,
    never use this function for equality testing. For equality testing, use `String.Equals`
    or hashes, as both perform much faster than `String.Compare`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`String.Compare`返回`0`表示两个字符串相等，但永远不要使用这个函数进行相等性测试。对于相等性测试，请使用`String.Equals`或哈希，因为它们都比`String.Compare`执行得快得多。
- en: String formatting
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'If you''re creating GUI elements, such as high-score HUDs, player names, cash
    counters, or resources indicators, you''ll not only need to show literal text
    but also numerical values inside the strings, for example, by combing the word
    `Score:` with a string representation of the actual score, which will change over
    time depending on player performance. One way to achieve this is the `String.Format`
    method, as shown in the following code sample 6-15:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建GUI元素，例如高分HUD、玩家名称、现金计数器或资源指示器，你不仅需要显示文本，还需要在字符串中显示数值，例如，通过将单词`Score:`与实际分数的字符串表示结合，分数会根据玩家的表现随时间变化。实现这一目标的一种方法是使用`String.Format`方法，如下面的代码示例6-15所示。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: String looping
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串循环
- en: 'So far, we''ve seen `IEnumerable` and `IEnumerator`. Thankfully, these interfaces
    apply to strings and can be used to loop or cycle through every letter in a string.
    This can be achieved using either the `IEnumerator` interface itself or via a
    `foreach` loop. Let''s see both ways, as shown in the following code sample 6-16
    and 6-17:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了`IEnumerable`和`IEnumerator`接口。幸运的是，这些接口适用于字符串，可以用来遍历或循环字符串中的每个字母。这可以通过`IEnumerator`接口本身或通过`foreach`循环实现。让我们看看两种方法，如下面的代码示例6-16和6-17所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating strings
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建字符串
- en: 'To make your code read better, work in a cleaner way, and generally, be more
    consistent with .NET and the way it''s intended to be used. It''s a good practice
    to avoid initializing string variables as: `string MyString = "";`. Instead, try
    the following code for string declaration and assignment using `String.empty`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的代码更易读，以更整洁的方式工作，并且通常与.NET及其预期使用方式保持一致，避免初始化字符串变量为：`string MyString = "";`。相反，尝试以下代码进行字符串声明和赋值，使用`String.empty`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Searching strings
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索字符串
- en: 'If you''re dealing with multiple lines of text read from a file, such as a
    Text Asset, you might need to find the first occurrence of a smaller string inside
    the larger one, for example, finding a smaller and separate word within the larger
    string. You can achieve this using the `String.IndexOf` method. If a match is
    found, the function would return a positive integer that indicates the position
    in the larger string of the first character of the found word as a measured offset
    from the first letter. If no match is found, the function returns `-1`, as shown
    in the following code sample 6-18:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理从文件中读取的多行文本，例如 Text Asset，你可能需要找到较大字符串中较小字符串的第一个出现，例如，在较大字符串中找到一个较小且独立的单词。你可以使用
    `String.IndexOf` 方法来实现这一点。如果找到匹配项，函数将返回一个正整数，表示找到的单词的第一个字符在较大字符串中的位置，作为从第一个字母测量的偏移量。如果没有找到匹配项，函数返回
    `-1`，如下面的代码示例 6-18 所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Regular expressions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'Occasionally, you might need to perform more complex searches on very large
    strings, such as finding all words in a string beginning with a specific letter,
    all words starting with `a` and ending in `t`, and so on. In these cases, you
    would want the results available in an array if there are any. You can achieve
    this effectively using regular expressions (`Regex`). Regular expressions let
    you define a string value using a conventional and specialized syntax, specifying
    a search pattern. For example, the string `[dw]ay` means "find all words that
    end with `ay` and that also begin with either `d` or `w`. Thus, find all occurrences
    of either day or way". The regular expression can then be applied to a larger
    string to perform a search using the `Regex` class. The .NET framework provides
    access to regular expression searches through the `RegularExpressions` namespace,
    as shown in the following code sample 6-19:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要在非常大的字符串上执行更复杂的搜索，例如找到以特定字母开头的所有单词，所有以 `a` 开头并以 `t` 结尾的单词等。在这些情况下，如果你找到了任何结果，你希望结果可用在数组中。你可以有效地使用正则表达式（`Regex`）来实现这一点。正则表达式允许你使用传统和专门的语法定义一个字符串值，指定搜索模式。例如，字符串
    `[dw]ay` 表示“找到所有以 `ay` 结尾且以 `d` 或 `w` 开头的单词。因此，找到 `day` 或 `way` 的所有出现”。然后可以将正则表达式应用于较大的字符串，使用
    `Regex` 类执行搜索。.NET 框架通过 `RegularExpressions` 命名空间提供对正则表达式搜索的访问，如下面的代码示例 6-19 所示：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are the comments for code sample 6-19:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-19 的注释：
- en: '**Line 05**: The `RegularExpressions` namespace must be included in all source
    files using regular expression searches.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 05 行**：使用正则表达式搜索的所有源文件都必须包含 `RegularExpressions` 命名空间。'
- en: '**Lines 09 and 13**: The string `Search` defines the regular expression itself.
    The string `txt` defines the larger string to be searched by the regular expression.
    The string `Search` searches for all occurrences of the words, `day` and `way`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 09 行和第 13 行**：字符串 `Search` 定义了正则表达式本身。字符串 `txt` 定义了要由正则表达式搜索的较大字符串。字符串
    `Search` 搜索所有出现单词 `day` 和 `way`。'
- en: '**Line 19**: The method `Regex.Match` is called to apply a regular expression
    search on the string `txt`. The results are stored in the local variable `m`.
    This variable can be iterated to scan for all results.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 19 行**：调用 `Regex.Match` 方法对字符串 `txt` 应用正则表达式搜索。结果存储在局部变量 `m` 中。这个变量可以被迭代以扫描所有结果。'
- en: '**Line 25**: The results in `m` will include three matches (not two) based
    on the string `txt`. These will include *day* as found in to*day* as well as *day*
    and *way* by themselves.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 25 行**：在 `m` 中的结果将包括基于字符串 `txt` 的三个匹配项（而不是两个）。这些匹配项将包括在 `to*day*` 中找到的
    `day`，以及单独的 `day` 和 `way`。'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on regular expressions can be found online at [http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多有关正则表达式的信息可以在网上找到，链接为 [http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)。
- en: Infinite arguments
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限参数
- en: 'Though not technically a part of .NET or Mono, our exploration of both these
    libraries has touched several times on functions that accept seemingly an endless
    chain of arguments, such as the `String.Format` function. With `String.Format`,
    it''s possible to plug in as many object arguments as you need for inclusion into
    a formatted string. In this section, I want to take a small (and very quick) diversion
    to show that you can code your own functions that accept and process limitless
    arguments; they''re simple to create. Refer to the following code sample 6-20
    for a function that can sum a potentially limitless array of integers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上不属于 .NET 或 Mono 的部分，但我们对这两个库的探索多次触及到接受看似无限链的参数的函数，例如 `String.Format` 函数。使用
    `String.Format`，可以插入所需的所有对象参数以包含到格式化字符串中。在本节中，我想稍微（并且非常快速）偏离一下，展示你可以编写自己的函数来接受和处理无限数量的参数；它们创建起来很简单。请参考以下代码示例
    6-20，该示例可以求和可能无限大的整数数组：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following are the comments for code sample 6-20:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-20 的注释：
- en: '**Line 01**: To accept a potentially infinite number of arguments, use the
    `params` keyword and declare the argument as an array type'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 01**：要接受可能无限数量的参数，请使用 `params` 关键字并将参数声明为数组类型'
- en: '**Line 05**: The `params` argument can be accessed like a regular array'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 05**：`params` 参数可以像常规数组一样访问'
- en: Language Integrated Query
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言集成查询
- en: Obviously, games work with lots of data. They work with not just strings but
    also with objects, databases, tables, documents, and plenty more, too many to
    list here. However, despite the extensiveness and variety of data, there's always
    a common need to filter it, viewing smaller subsets of it as is relevant to our
    needs at the time. For example, given a complete array (or enumerated list) of
    all wizard objects in the scene, we might want to restrict the results even further,
    viewing only wizards whose health is less than 50 percent and whose defense points
    are less than 5\. The purpose is, perhaps, to initiate a mass flee behavior on
    the wizards to find a nearby potion and restore their health before resuming an
    attack on the player. Let's now consider the implementation of this scenario and
    how a technology, Linq, can help us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，游戏处理大量数据。它们不仅处理字符串，还处理对象、数据库、表格、文档等等，太多以至于无法在此列出。然而，尽管数据广泛且种类繁多，但总有过滤数据的共同需求，查看与当时需求相关的较小子集。例如，给定场景中所有法师对象的完整数组（或枚举列表），我们可能希望进一步限制结果，仅查看健康值小于
    50% 且防御点数小于 5 的法师。目的可能是，也许，在法师中启动大规模逃跑行为，寻找附近的药水并恢复他们的健康，然后再继续攻击玩家。现在让我们考虑这个场景的实现以及一项技术，Linq，如何帮助我们。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A complete Linq sample project can be found in the book's companion files (code
    bundle) at `Chapter06\Linq\`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Linq 示例项目可以在本书的配套文件（代码包）中找到，位于 `Chapter06\Linq\`。
- en: 'First, a very basic and sample definition of a wizard enemy class can be given,
    as shown in the following code sample 6-21\. This class includes both the `Health`
    and `Defense` member variables that are critical to our behavior logic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以给出一个非常基本和示例性的法师敌人类定义，如下所示代码示例 6-21。此类包括对行为逻辑至关重要的 `Health` 和 `Defense`
    成员变量：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, given a collection of all enemy objects in the scene, we could filter the
    data into a smaller array according to our criteria with the code, as shown in
    the following code sample 6-22.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给定场景中所有敌人对象的集合，我们可以使用以下代码根据我们的标准将数据过滤到一个更小的数组中，如下所示代码示例 6-22。
- en: 'This code effectively loops through all members, runs them through a conditional
    `if` statement, and then, finally adds the enemy to a results array if it passes
    the condition. The condition, in this case, is whether an enemy''s health is less
    than 50 percent and their defense is less than 5:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码有效地遍历所有成员，通过一个条件 `if` 语句运行它们，然后，最终如果满足条件，将敌人添加到结果数组中。在这种情况下，条件是一个敌人的健康值是否小于
    50%，以及他们的防御是否小于 5：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code works insofar as it restricts a larger data set into a smaller one
    on the basis of a specific criterion. However, Linq lets us achieve the same results
    with less code and often greater performance. Linq is a high-level and specialized
    language to run queries on data sets, including arrays and objects, as well as
    on databases and XML documents. The queries are translated automatically by Linq,
    under the hood, into an appropriate language for the data set used (for example,
    SQL for databases). The aim is to extract the results we need into a regular array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在将较大的数据集根据特定标准限制为较小的数据集方面是有效的。然而，Linq 允许我们用更少的代码和通常更高的性能实现相同的结果。Linq 是一种高级且专门的语言，用于在数据集上运行查询，包括数组、对象，以及数据库和
    XML 文档。Linq 在幕后自动将查询转换为适用于所使用数据集的适当语言（例如，数据库的 SQL）。目标是提取我们需要的成果到一个常规数组中。
- en: 'The following code sample 6-23 demonstrates an alternative approach to the
    preceding code sample 6-22 using Linq:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例 6-23 展示了使用 Linq 对前面代码示例 6-22 的另一种方法：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following are the comments for code sample 6-23:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-23 的注释：
- en: '**Lines 03-04**: To use Linq, you must include the `System.Collections.Linq`
    namespace, and to use `List` objects, you must include the `System.Collections.Generic`
    namespace.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 03-04 行**：要使用 Linq，必须包含 `System.Collections.Linq` 命名空间，并且要使用 `List` 对象，必须包含
    `System.Collections.Generic` 命名空间。'
- en: '**Lines 12-14**: The main body of Linq code occurs here. It consists of three
    main parts. First, we indicated the items to pick from the source data, specifically,
    enemy objects from the data set `Enemies`. Second, we defined the criteria to
    search for, specifically where `EnemyChar.Health <= 50 && EnemyChar.Defense <
    5`. Then, when the criterion is met, we selected that object to add to the results;
    we selected `EnemyChar`. Finally, we converted the results to an array with the
    `ToArray` function.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 12-14 行**：Linq 代码的主体部分在这里出现。它由三个主要部分组成。首先，我们指明了从源数据中选取的项目，具体是从数据集 `Enemies`
    中选取敌人对象。其次，我们定义了搜索的标准，具体是 `EnemyChar.Health <= 50 && EnemyChar.Defense < 5`。然后，当满足条件时，我们选择该对象添加到结果中；我们选择了
    `EnemyChar`。最后，我们使用 `ToArray` 函数将结果转换为数组。'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on Linq can be found online in MSDN at [http://msdn.microsoft.com/en-gb/library/bb397926.aspx](http://msdn.microsoft.com/en-gb/library/bb397926.aspx).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Linq 的信息可以在 MSDN 上找到，网址为 [http://msdn.microsoft.com/en-gb/library/bb397926.aspx](http://msdn.microsoft.com/en-gb/library/bb397926.aspx)。
- en: Linq and regular expressions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linq 和正则表达式
- en: 'Linq, of course, need not work in isolation. It can, for example, be combined
    with regular expressions to extract specific string patterns from a larger string
    that converts the matched results into a traversable array. This can be especially
    useful in processing comma-separated value files (CSV files), for example, where
    data is formatted inside a text file, each entry being separated by a comma character.
    Both Linq and regular expressions can be used to read each value into a unique
    array element very quickly and easily. For example, consider an RTS game where
    human names must be generated for new units. The names themselves are stored in
    a CSV format and are divided into two groups: male and female. On generating a
    character, it can be either male or female, and an appropriate name must be assigned
    to them from the CSV data, as shown in the following code sample 6-24:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Linq 不必独立工作。例如，它可以与正则表达式结合使用，从较大的字符串中提取特定的字符串模式，并将匹配的结果转换为可遍历的数组。这在处理逗号分隔值文件（CSV
    文件）时特别有用，例如，数据格式化在文本文件中，每个条目由逗号字符分隔。Linq 和正则表达式都可以快速、轻松地将每个值读入一个唯一的数组元素。例如，考虑一个即时战略（RTS）游戏，其中必须为新单位生成人类名称。这些名称本身以
    CSV 格式存储，并分为两组：男性和女性。在生成角色时，它可以是男性或女性，并且必须从 CSV 数据中为它们分配一个合适的名称，如下面的代码示例 6-24
    所示：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following are the comments for code sample 6-24:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 6-24 的注释：
- en: '**Line 04**: The member variable `Search` defines a regular expression search
    pattern. The `Search` variable, in this case, is for all words prefixed with `female:`.
    More than this, however, the prefix itself should not be included in the resultant
    strings.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 04 行**：成员变量 `Search` 定义了一个正则表达式搜索模式。在这个例子中，`Search` 变量用于所有以 `female:` 为前缀的单词。然而，更值得注意的是，前缀本身不应包含在结果字符串中。'
- en: '**Line 07**: The member variable `CSVData` defines a complete CSV string with
    both male and female names that are structured in the expected format. This string
    essentially represents the database or data source.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第07行**：成员变量`CSVData`定义了一个包含男性和女性名字的完整CSV字符串，这些名字按照预期的格式结构化。这个字符串本质上代表了数据库或数据源。'
- en: '**Lines 10-11**: Here, Linq is used in conjunction with a regular expression
    search to retrieve all female names from the CSV, minus the prefixes. This list
    is then converted into a string array `FemaleNames`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10-11行**：在这里，Linq与正则表达式搜索结合使用，检索CSV中的所有女性名字，不包括前缀。然后，这个列表被转换成一个字符串数组`FemaleNames`。'
- en: Note
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Strings and the @ symbol**'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**字符串和@符号**'
- en: Notice from line 04 of the code sample 6-24 that the regular expression string
    is prefixed with the symbol `@`. This is a C# convention that allows you to write
    a string literal in a source file; this string literal can contain escape sequences
    (such as `\`) without breaking or invalidating the string itself.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从代码示例6-24的第04行可以看出，正则表达式字符串前面带有符号`@`。这是C#的约定，允许你在源文件中编写字符串字面量；这个字符串字面量可以包含转义序列（如`\`），而不会破坏或使字符串本身无效。
- en: Working with Text Data Assets
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文本数据资产一起工作
- en: Throughout all examples so far, we've considered text directly stored in string
    objects, but you can also work with text files in Unity. Specifically, you can
    load in text from external sources. Here, I will demonstrate how.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的所有示例中，我们都考虑了直接存储在字符串对象中的文本，但你也可以在Unity中处理文本文件。具体来说，你可以从外部源加载文本。在这里，我将演示如何做到这一点。
- en: Text Assets – static loading
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本资产 – 静态加载
- en: 'The first method is to drag-and-drop a text file into a Unity project that
    imports the text asset. The file is imported as a **TextAssets** type, as shown
    here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是拖放一个文本文件到Unity项目中，该项目导入文本资产。文件以**TextAssets**类型导入，如下所示：
- en: '![Text Assets – static loading](img/0655OT_06_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![文本资产 – 静态加载](img/0655OT_06_03.jpg)'
- en: Importing text files into Unity as TextAssets
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本文件导入Unity作为TextAssets
- en: 'You can access the file and its text data from any script file by exposing
    a `TextAsset` public member, as shown in the following code sample 6-25:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过公开一个`TextAsset`公共成员从任何脚本文件访问文件及其文本数据，如下面的代码示例6-25所示：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code means you just need to drag-and-drop the `TextAsset` file onto the
    **Text Data** slot in the Object Inspector, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着你只需将`TextAsset`文件拖放到对象检查器中的**文本数据**槽位，如下所示：
- en: '![Text Assets – static loading](img/0655OT_06_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![文本资产 – 静态加载](img/0655OT_06_04.jpg)'
- en: Accessing text file assets from script
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本访问文本文件资产
- en: Text Assets – loading from the local files
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本资产 – 从本地文件加载
- en: 'Another method to load in text data is externally from the project, that is,
    from files on the local hard drive. Text Data loaded in this way is read into
    the project dynamically from script, not necessarily at scene startup, but whenever
    you execute the necessary code. This means that for longer text files that involve
    heavy processing, lag becomes a serious consideration. In general, therefore,
    it is best to prefer statically loaded Text Assets to dynamic forms. For any dynamic
    assets, I recommend that you load and process them at scene startup to avoid in-game
    lagging, as shown in the following code sample 6-26:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种加载文本数据的方法是从项目外部加载，即从本地硬盘上的文件加载。以这种方式加载的文本数据是通过脚本动态读入项目的，不一定是在场景启动时，而是在你执行必要的代码时。这意味着对于涉及大量处理的较长的文本文件，延迟成为一个严重的考虑因素。因此，通常最好优先选择静态加载的文本资产而不是动态形式。对于任何动态资产，我建议你在场景启动时加载和处理它们，以避免游戏中的延迟，如下面的代码示例6-26所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The code sample 6-26 loads a complete text file into one string object. You
    might, however, prefer to process a text file line by line instead, especially
    if the file is a configuration file where values are specified in separate lines.
    For this, see the following code sample 6-27:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例6-26将整个文本文件加载到一个字符串对象中。然而，你可能更喜欢逐行处理文本文件，特别是如果文件是一个配置文件，其中的值在单独的行中指定。为此，请参阅下面的代码示例6-27：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Text Assets – loading from the INI files
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本资产 – 从INI文件加载
- en: 'Among the many text file types, you can load a common format is the INI file.
    It''s, perhaps, not as common with Unity games, because many developers use the
    `PlayerPreferences` class instead to store application settings. Even so, the
    INI files offer the advantage of storing application configuration data in only
    one place and in the same format across many different platforms. For this reason,
    there are strong reasons to use INI files. Refer to the code sample 6-28 for an
    example INI that uses a key-value pairing format:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多文本文件类型中，可以加载的常见格式是INI文件。也许在Unity游戏中并不那么常见，因为许多开发者使用 `PlayerPreferences` 类来存储应用程序设置。即便如此，INI文件的优势在于可以在一个地方以相同的格式存储应用程序配置数据，跨越许多不同的平台。因此，有充分的理由使用INI文件。请参考代码示例6-28，了解使用键值对格式的示例INI文件：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An ideal data structure to load INI files is the dictionary that mirrors a key-value
    pair structure. For this reason, it'd be great to load an INI file into a dictionary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 加载INI文件的一个理想数据结构是反映键值对结构的字典。因此，将INI文件加载到字典中会非常好。
- en: 'However, neither Unity nor Mono offers native support for this, which means
    we have to code the functionality ourselves, as shown in the following code sample
    6-29:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Unity和Mono都没有提供原生支持，这意味着我们必须自己编写功能代码，如下面的代码示例6-29所示：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A dictionary returned from this function will match the structure of the INI
    file. Therefore, values can be accessed in the form string `Value = MyDictionary["Key"];`.
    You can also enumerate through all key and value members of a dictionary inside
    a `foreach`, as shown in the following code sample 6-30:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从此函数返回的字典将与INI文件的格式相匹配。因此，可以通过字符串形式 `Value = MyDictionary["Key"];` 访问值。您还可以在
    `foreach` 循环中遍历字典中的所有键和值成员，如下面的代码示例6-30所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Text Assets – loading from the CSV files
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本资产 – 从CSV文件加载
- en: 'Earlier in this chapter, we saw how to process a CSV file that features character
    names, both male and female. Let''s now see some source code to load CSV from
    a file on disk into an array of strings, with each string separated by a comma,
    as shown in the following code sample 6-31:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们看到了如何处理具有男性女性角色名称的CSV文件。现在，让我们看看一些源代码，展示如何将磁盘上的CSV文件加载到字符串数组中，每个字符串由逗号分隔，如下面的代码示例6-31所示：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Text Assets – loading from the Web
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本资产 – 从网络加载
- en: 'If you''re making multiplayer games and need to access player or game data
    across the Web, if you need to verify passwords with hashes online, or if you
    need to access a web page to process its elements, then you will need the `WWW`
    class to retrieve text data online, as shown in the following code sample 6-32:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在制作多人游戏，需要在网络上访问玩家或游戏数据，如果需要在线验证密码散列，或者需要访问网页以处理其元素，那么您将需要 `WWW` 类来检索在线文本数据，如下面的代码示例6-32所示：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `WWW` class can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/WWW.html](http://docs.unity3d.com/ScriptReference/WWW.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `WWW` 类的更多信息可以在Unity在线文档中找到，网址为[http://docs.unity3d.com/ScriptReference/WWW.html](http://docs.unity3d.com/ScriptReference/WWW.html)。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter considered a wide range of applications for the Mono Framework
    in practical contexts. It took a three-part structure. First, we explored common
    data structures used in C#, including `List`, `Dictionary`, and `Stack`. From
    there, we moved on to investigate their common usages in storing and searching
    data and in organizing and processing strings. We also explored regular expressions
    for searching strings for patterns of data and the Linq language for filtering
    not only strings but all the collection-type objects available in Mono. Then,
    finally, we examined various methods to import text data, both internally to the
    project and from local files, as well as text data streamed across the Web. The
    next chapter moves into the world of artificial intelligence; it considers path-finding,
    finite state machines, line of sight, decision making, ray casting, and more.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Mono框架在实际环境中的广泛应用。它采用了三部分结构。首先，我们探讨了C#中常用的数据结构，包括 `List`、`Dictionary` 和
    `Stack`。从那里，我们继续研究它们在存储和搜索数据以及组织和处理字符串中的常见用法。我们还探讨了用于在字符串中搜索数据模式的正则表达式，以及用于过滤Mono中所有集合类型对象的Linq语言。最后，我们检查了各种导入文本数据的方法，包括项目内部和本地文件中的文本数据，以及通过网络流过的文本数据。下一章将进入人工智能的世界；它考虑了路径查找、有限状态机、视线、决策、光线投射等内容。
