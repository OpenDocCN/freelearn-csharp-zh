- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Leveraging Globalization and Localization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用全球化和本地化
- en: 'When developing an application, it is important to think about multi-language
    support; a multilingual application allows for a wider audience reach. This is
    also true for web APIs: messages returned by endpoints (for example, validation
    errors) should be localized, and the service should be able to handle different
    cultures and deal with time zones. In this chapter of the book, we will talk about
    **globalization** and **localization**, and we will explain what features are
    available in minimal APIs to work with these concepts. The information and samples
    that will be provided will guide us when adding multi-language support to our
    services and correctly handling all the related behaviors so that we will be able
    to develop global applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，考虑多语言支持非常重要；多语言应用程序可以扩大受众范围。这对于 Web API 也是如此：端点返回的消息（例如，验证错误）应该本地化，并且服务应该能够处理不同的文化并处理时区。在本章中，我们将讨论
    **全球化** 和 **本地化**，并解释最小 API 中可用于处理这些概念的功能。提供的信息和示例将指导我们在服务中添加多语言支持并正确处理所有相关行为，以便我们能够开发全球应用程序。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing globalization and localization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍全球化和本地化
- en: Localizing a minimal API application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化最小 API 应用
- en: Using resource files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资源文件
- en: Integrating localization in validation frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证框架中集成本地化
- en: Adding UTC support to a globalized minimal API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向全球化的最小 API 添加 UTC 支持
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. Refer to the *Technical requirements* section in
    [*Chapter 1*](B17902_01.xhtml#_idTextAnchor014), *Introduction to Minimal APIs*,
    for instructions on how to do so.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的描述，你需要创建一个 ASP.NET Core 6.0 Web API 应用程序。有关如何操作的说明，请参阅 [*第 1 章*](B17902_01.xhtml#_idTextAnchor014)
    *最小 API 简介* 中的 *技术要求* 部分。
- en: If you’re using your console, shell, or Bash terminal to create the API, remember
    to change your working directory to the current chapter number (`Chapter09`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用控制台、shell 或 Bash 终端创建 API，请记住将你的工作目录更改为当前章节号（`Chapter09`）。
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter09](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter09](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter09)。
- en: Introducing globalization and localization
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍全球化和本地化
- en: When thinking about internationalization, we must deal with globalization and
    localization, two terms that seem to refer to the same concepts but actually involve
    different areas. Globalization is the task of designing applications that can
    manage and support different cultures. Localization is the process of adapting
    an application to a particular culture, for example, by providing translated resources
    for each culture that will be supported.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑国际化时，我们必须处理全球化和本地化这两个看似指代相同概念但实际上涉及不同领域的术语。全球化是设计能够管理和支持不同文化的应用程序的任务。本地化是将应用程序适应特定文化的过程，例如，通过为每个将得到支持的文化提供翻译资源。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The terms internationalization, globalization, and localization are often abbreviated
    to *I18N*, *G11N,* and *L10N*, respectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化、全球化和本地化这些术语通常分别缩写为 *I18N*、*G11N* 和 *L10N*。
- en: As with all the other features that we have already introduced in the previous
    chapters, globalization and localization can be handled by the corresponding middleware
    and services that ASP.NET Core provides and work in the same way in minimal APIs
    and controller-based projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在前几章中介绍的所有其他功能一样，全球化和本地化可以通过 ASP.NET Core 提供的相应中间件和服务来处理，并在最小 API 和基于控制器的项目中以相同的方式工作。
- en: You can find a great introduction to globalization and localization in the official
    documentation available at [https://docs.microsoft.com/dotnet/core/extensions/globalization](https://docs.microsoft.com/dotnet/core/extensions/globalization)
    and [https://docs.microsoft.com/dotnet/core/extensions/localization](https://docs.microsoft.com/dotnet/core/extensions/localization),
    respectively. In the rest of the chapter, we will focus on how to add support
    for these features in a minimal API project; in this way, we’ll introduce some
    important concepts and explain how to leverage globalization and localization
    in ASP.NET Core.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Localizing a minimal API application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable localization within a minimal API application, let us go through
    the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to making an application localizable is to specify the supported
    cultures by setting the corresponding options, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our example, we want to support three cultures – English, Italian, and French
    – so, we create an array of `CultureInfo` objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re defining neutral cultures, that is, cultures that have a language but
    are not associated with a country or region. We could also use specific cultures,
    such as `en-US` or `en-GB`, to represent the cultures of a particular region:
    for example, `en-US` would refer to the English culture prevalent in the United
    States, while `en-GB` would refer to the English culture prevalent in the United
    Kingdom. This difference is important because, depending on the scenario, we may
    need to use country-specific information to correctly implement localization.
    For example, if we want to show a date, we have to know that the date format in
    the United States is `M/d/yyyy`, while in the United Kingdom, it is `dd/MM/yyyy`.
    So, in this case, it becomes fundamental to work with specific cultures. We also
    use specific cultures if we need to support language differences across cultures.
    For example, a particular word may have different spellings depending on the country
    (e.g., *color* in the US versus *colour* in the UK). That said, for our scenario
    of minimal APIs, working with neutral cultures is just fine.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we configure `RequestLocalizationOptions`, setting the cultures and specifying
    the default one to use if no information about the culture is provided. We specify
    both the supported cultures and the supported UI cultures:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The supported cultures control the output of culture-dependent functions, such
    as date, time, and number format.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The supported UI cultures are used to choose which translated strings (from
    `.resx` files) are searched for. We will talk about `.resx` files later in this
    chapter.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a typical application, cultures and UI cultures are set to the same values,
    but of course, we can use different options if needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have configured our service to support globalization, we need to
    add the localization middleware to the ASP.NET Core pipeline so it will be able
    to automatically set the culture of the request. Let us do so using the following
    code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的服务以支持全球化，我们需要将本地化中间件添加到 ASP.NET Core 管道中，以便它能够自动设置请求的文化。让我们使用以下代码来完成：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, with `UseRequestLocalization()`, we’re adding `RequestLocalizationMiddleware`
    to the ASP.NET Core pipeline to set the current culture of each request. This
    task is performed using a list of `RequestCultureProvider` that can read information
    about the culture from various sources. Default providers comprise the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，通过 `UseRequestLocalization()`，我们向 ASP.NET Core 管道添加了 `RequestLocalizationMiddleware`
    以设置每个请求的当前文化。这项任务是通过一个可以读取有关文化信息的 `RequestCultureProvider` 列表来执行的。默认提供者包括以下内容：
- en: '`QueryStringRequestCultureProvider`: Searches for the `culture` and `ui-culture`
    query string parameters'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueryStringRequestCultureProvider`: 搜索 `culture` 和 `ui-culture` 查询字符串参数'
- en: '`CookieRequestCultureProvider`: Uses the ASP.NET Core cookie'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieRequestCultureProvider`: 使用 ASP.NET Core 的 cookie'
- en: '`AcceptLanguageHeaderRequestProvider`: Reads the requested culture from the
    `Accept-Language` HTTP header'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AcceptLanguageHeaderRequestProvider`: 从 `Accept-Language` HTTP 头读取请求的文化'
- en: For each request, the system will try to use these providers in this exact order,
    until it finds the first one that can determine the culture. If the culture cannot
    be set, the one specified in the `DefaultRequestCulture` property of `RequestLocalizationOptions`
    will be used.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，系统将按照此确切顺序尝试使用这些提供者，直到找到第一个可以确定文化的提供者。如果无法设置文化，则将使用 `RequestLocalizationOptions`
    的 `DefaultRequestCulture` 属性中指定的文化。
- en: If necessary, it is also possible to change the order of the request culture
    providers or even define a custom provider to implement our own logic to determine
    the culture. More information on this topic is available at [https://docs.microsoft.com/aspnet/core/fundamentals/localization#use-a-custom-provider](https://docs.microsoft.com/aspnet/core/fundamentals/localization#use-a-custom-provider).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，也可以更改请求文化提供者的顺序，甚至可以定义一个自定义提供者以实现我们自己的逻辑来确定文化。有关此主题的更多信息，请参阅 [https://docs.microsoft.com/aspnet/core/fundamentals/localization#use-a-custom-provider](https://docs.microsoft.com/aspnet/core/fundamentals/localization#use-a-custom-provider)。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The localization middleware must be inserted before any other middleware that
    might use the request culture.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化中间件必须插入到任何可能使用请求文化的其他中间件之前。
- en: In the case of web APIs, whether using controller-based or minimal APIs, we
    usually set the request culture through the `Accept-Language` HTTP header. In
    the following section, we will see how to extend Swagger with the ability to add
    this header when trying to invoke methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web API 的情况下，无论是使用基于控制器的 API 还是最小 API，我们通常通过 `Accept-Language` HTTP 头设置请求文化。在下一节中，我们将看到如何扩展
    Swagger 以添加在尝试调用方法时添加此头部的功能。
- en: Adding globalization support to Swagger
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将全球化支持添加到 Swagger
- en: 'We want Swagger to provide us with a way to specify the `Accept-Language` HTTP
    header for each request so that we can test our globalized endpoints. Technically
    speaking, this means adding an **operation filter** to Swagger that will be able
    to automatically insert the language header, using the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 Swagger 能够提供一种方式来指定每个请求的 `Accept-Language` HTTP 头，以便我们可以测试我们的全球化端点。从技术上讲，这意味着向
    Swagger 添加一个 **操作过滤器**，该过滤器能够自动插入语言头，使用以下代码：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, `AcceptLanguageHeaderOperationFilter` takes the `RequestLocalizationOptions`
    object via dependency injection that we have defined at startup and extracts the
    supported languages in the format that Swagger expects from it. Then, in the `Apply()`
    method, we add a new `OpenApiParameter` that corresponds to the `Accept-Language`
    header. In particular, with the `Schema.Enum` property, we provide the list of
    supported languages using the values we have extracted in the constructor. This
    method is invoked for every operation (that is, every endpoint), meaning that
    the parameter will be automatically added to each of them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`AcceptLanguageHeaderOperationFilter` 通过依赖注入获取我们在启动时定义的 `RequestLocalizationOptions`
    对象，并从中提取 Swagger 所期望的格式化的支持语言。然后，在 `Apply()` 方法中，我们添加一个新的 `OpenApiParameter`，它对应于
    `Accept-Language` 头。特别是，通过 `Schema.Enum` 属性，我们使用在构造函数中提取的值提供支持语言列表。此方法对每个操作（即每个端点）都会被调用，这意味着参数将自动添加到每个端点中。
- en: 'Now, we need to add the new filter to Swagger:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将新的过滤器添加到 Swagger 中：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we did with the preceding code, for every operation, Swagger will execute
    the filter, which in turn will add a parameter to specify the language of the
    request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所做的那样，对于每个操作，Swagger都会执行过滤器，该过滤器会添加一个参数来指定请求的语言。
- en: 'So, let’s suppose we have the following endpoint:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设我们有以下端点：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding handler, we just return the culture of the thread. This method
    takes no parameter; however, after adding the preceding filter, the Swagger UI
    will show the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的处理程序中，我们只是返回线程的文化。这种方法不接受任何参数；然而，在添加前面的过滤器后，Swagger UI将显示以下内容：
- en: '![Figure 9.1 – The Accept-Language header added to Swagger ](img/Figure_9.1_B17902.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 添加到Swagger的Accept-Language头](img/Figure_9.1_B17902.jpg)'
- en: Figure 9.1 – The Accept-Language header added to Swagger
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 添加到Swagger的Accept-Language头
- en: 'The operation filter has added a new parameter to the endpoint, allowing us
    to select the language from a dropdown. We can click the **Try it out** button
    to choose a value from the list and then click **Execute** to invoke the endpoint:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 操作过滤器已向端点添加了一个新参数，允许我们从下拉列表中选择语言。我们可以点击**尝试**按钮从列表中选择一个值，然后点击**执行**来调用端点：
- en: '![Figure 9.2 – The result of the execution with the Accept-Language HTTP header
    ](img/Figure_9.2_B17902.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 带有Accept-Language HTTP头的执行结果](img/Figure_9.2_B17902.jpg)'
- en: Figure 9.2 – The result of the execution with the Accept-Language HTTP header
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 带有Accept-Language HTTP头的执行结果
- en: 'This is the result of selecting `it` as a language request: Swagger has added
    the `Accept-Language` HTTP header, which, in turn, has been used by ASP.NET Core
    to set the current culture. Then, in the end, we get and return the culture display
    name in the route handler.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是选择`it`作为语言请求的结果：Swagger已添加`Accept-Language` HTTP头，该头随后被ASP.NET Core用于设置当前文化。然后，在最后，我们在路由处理程序中获取并返回文化显示名称。
- en: This example shows us that we have correctly added globalization support to
    our minimal API. In the next section, we’ll go further and work with localization,
    starting by providing translated resources to callers based on the corresponding
    languages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了我们已经正确地将全球化支持添加到我们的最小API中。在下一节中，我们将进一步探讨并处理本地化，首先根据相应的语言向调用者提供翻译过的资源。
- en: Using resource files
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源文件
- en: Our minimal API now supports globalization, so it can switch cultures based
    on the request. This means that we can provide localized messages to callers,
    for example, when communicating validation errors. This feature is based on the
    so-called `.resx`), a particular kind of XML file that contains key-value string
    pairs representing messages that must be localized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最小API现在支持全球化，因此可以根据请求切换文化。这意味着我们可以向调用者提供本地化消息，例如，在通信验证错误时。这个功能基于所谓的`.resx`文件，这是一种特定的XML文件，包含表示必须本地化的消息的键值字符串对。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These resource files are exactly the same as they have been since the early
    versions of .NET.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源文件与.NET早期版本以来完全相同。
- en: Creating and working with resource files
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用资源文件
- en: 'With resource files, we can easily separate strings from code and group them
    by culture. Typically, resource files are put in a folder called `Resources`.
    To create a file of this kind using Visual Studio, let us go through the following
    steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资源文件，我们可以轻松地将字符串与代码分离，并按文化分组。通常，资源文件放在名为`Resources`的文件夹中。要使用Visual Studio创建此类文件，请按照以下步骤进行：
- en: Important note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Unfortunately, Visual Studio Code does not provide support for handling `.resx`
    files. More information about this topic is available at [https://github.com/dotnet/AspNetCore.Docs/issues/2501](https://github.com/dotnet/AspNetCore.Docs/issues/2501).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Visual Studio Code不支持处理`.resx`文件。有关此主题的更多信息，请参阅[https://github.com/dotnet/AspNetCore.Docs/issues/2501](https://github.com/dotnet/AspNetCore.Docs/issues/2501)。
- en: Right-click on the folder in **Solution Explorer** and then choose **Add** |
    **New Item**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击文件夹，然后选择**添加** | **新项**。
- en: 'In the `Resources`, select the corresponding template, and name the file, for
    example, `Messages.resx`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Resources`中，选择相应的模板，并为文件命名，例如，`Messages.resx`：
- en: '![Figure 9.3 – Adding a resource file to the project ](img/Figure_9.3_B17902.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 将资源文件添加到项目中](img/Figure_9.3_B17902.jpg)'
- en: Figure 9.3 – Adding a resource file to the project
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 将资源文件添加到项目中
- en: The new file will immediately open in the Visual Studio editor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件将立即在Visual Studio编辑器中打开。
- en: 'The first thing to do in the new file is to select **Internal** or **Public**
    (based on the code visibility we want to achieve) from the **Access Modifier**
    option so that Visual Studio will create a C# file that exposes the properties
    to access the resources:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件中要做的第一件事是从 **访问修饰符** 选项中选择 **内部** 或 **公共**（根据我们想要达到的代码可见性），这样 Visual Studio
    就会创建一个 C# 文件，该文件将创建暴露属性以访问资源：
- en: '![Figure 9.4 – Changing the Access Modifier of the resource file ](img/Figure_9.4_B17902.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 修改资源文件访问修饰符](img/Figure_9.4_B17902.jpg)'
- en: Figure 9.4 – Changing the Access Modifier of the resource file
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 修改资源文件访问修饰符
- en: As soon as we change this value, Visual Studio will add a `Messages.Designer.cs`
    file to the project and automatically create properties that correspond to the
    strings we insert in the resource file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更改此值，Visual Studio 将向项目中添加一个 `Messages.Designer.cs` 文件，并自动创建与我们在资源文件中插入的字符串相对应的属性。
- en: Resource files must follow a precise naming convention. The file that contains
    default culture messages can have any name (such as `Messages.resx`, as in our
    example), but the other `.resx` files that provide the corresponding translations
    must have the same name, with the specification of the culture (neutral or specific)
    to which they refer. So, we have `Messages.resx`, which will store default (English)
    messages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件必须遵循精确的命名约定。包含默认文化消息的文件可以具有任何名称（例如，在我们的例子中为 `Messages.resx`），但提供相应翻译的其他
    `.resx` 文件必须具有相同的名称，并指定它们所引用的文化（中性或特定）。因此，我们有 `Messages.resx`，它将存储默认（英语）消息。
- en: Since we also want to localize our messages in Italian, we need to create another
    file with the name `Messages.it.resx`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们还想将我们的消息本地化为意大利语，我们需要创建另一个名为 `Messages.it.resx` 的文件。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t create a resource file for French culture on purpose because this way,
    we’ll see how APS.NET Core looks up the localized messages in practice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意没有为法语文化创建资源文件，这样我们就可以看到 APS.NET Core 在实际中是如何查找本地化消息的。
- en: Now, we can start experimenting with resource files. Let’s open the `Messages.resx`
    file and set `HelloWorld` and `Hello World!`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始对资源文件进行实验。让我们打开 `Messages.resx` 文件，并设置 `HelloWorld` 和 `Hello World!`。
- en: In this way, Visual Studio will add a static `HelloWorld` property in the `Messages`
    autogenerated class that allows us to access values based on the current culture.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，Visual Studio 将在 `Messages` 自动生成的类中添加一个静态 `HelloWorld` 属性，允许我们根据当前文化访问值。
- en: To demonstrate this behavior, also open the `Messages.it.resx` file and add
    an item with the same `HelloWorld`, but now set `Ciao mondo!`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这种行为，也打开 `Messages.it.resx` 文件，并添加一个具有相同 `HelloWorld` 的项，但现在设置为 `Ciao mondo!`。
- en: 'Finally, we can add a new endpoint to showcase the usage of the resource files:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个新的端点来展示资源文件的使用：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding route handler, we simply access the static `Mesasges.HelloWorld`
    property that, as discussed before, has been automatically created while editing
    the `Messages.resx` file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的路由处理程序中，我们简单地访问了静态 `Mesasges.HelloWorld` 属性，正如之前讨论的那样，在编辑 `Messages.resx`
    文件时，该属性已被自动创建。
- en: 'If we now run the minimal API and try to execute this endpoint, we’ll get the
    following responses based on the request language that we select in Swagger:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行最小化 API 并尝试执行此端点，我们将根据在 Swagger 中选择的请求语言获得以下响应：
- en: '![Table 9.1 – Responses based on the request language ](img/B17902_09_Table1.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.1 – 根据请求语言生成的响应](img/B17902_09_Table1.jpg)'
- en: Table 9.1 – Responses based on the request language
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – 根据请求语言生成的响应
- en: When accessing a property such as `HelloWorld`, the autogenerated `Messages`
    class internally uses `ResourceManager` to look up the corresponding localized
    string. First of all, it looks for a resource file whose name contains the requested
    culture. If it is not found, it reverts to the parent culture of that culture.
    This means that, if the requested culture is specific, `ResourceManager` searches
    for the neutral culture. If no resource file is still found, then the default
    one is used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问像 `HelloWorld` 这样的属性时，自动生成的 `Messages` 类内部使用 `ResourceManager` 来查找相应的本地化字符串。首先，它会寻找一个名称包含请求文化的资源文件。如果找不到，它将回退到该文化的父文化。这意味着，如果请求的文化是特定的，`ResourceManager`
    将搜索中性文化。如果仍然找不到资源文件，则使用默认的文件。
- en: 'In our case, using Swagger, we can select only English, Italian, or French
    as a neutral culture. But what happens if a client sends other values? We can
    have situations such as the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，使用 Swagger，我们可以选择仅英语、意大利语或法语作为中性文化。但如果客户端发送其他值会怎样？我们可以有如下情况：
- en: 'The request culture is `it-IT`: the system searches for `Messages.it-IT.resx`
    and then finds and uses `Messages.it.resx`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求文化是 `it-IT`：系统搜索 `Messages.it-IT.resx`，然后找到并使用 `Messages.it.resx`。
- en: 'The request culture is `fr-FR`: the system searches for `Messages.fr-FR.resx`,
    then `Messages.fr.resx`, and (because neither are available) finally uses the
    default, `Messages.resx`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求文化是 `fr-FR`：系统搜索 `Messages.fr-FR.resx`，然后搜索 `Messages.fr.resx`，并且（因为两者都不可用）最后使用默认的
    `Messages.resx`。
- en: 'The request culture is `de` (German): because this isn’t a supported culture
    at all, the default request culture will be automatically selected, so strings
    will be searched for in the `Messages.resx` file.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求文化是 `de`（德语）：因为这不是一个受支持的文化，所以默认请求文化将被自动选择，因此字符串将在 `Messages.resx` 文件中搜索。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a localized resource file exists, but it doesn’t contain the specified key,
    then the value of the default file will be used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在本地化资源文件，但它不包含指定的键，则将使用默认文件中的值。
- en: Formatting localized messages using resource files
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用资源文件格式化本地化消息
- en: 'We can also use resource files to format localized messages. For example, we
    can add the following strings to the resource files of the project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用资源文件来格式化本地化消息。例如，我们可以将以下字符串添加到项目的资源文件中：
- en: '![Table 9.2 – A custom localized message ](img/B17902_09_Table2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.2 – 一个自定义的本地化消息](img/B17902_09_Table2.jpg)'
- en: Table 9.2 – A custom localized message
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2 – 一个自定义的本地化消息
- en: 'Now, let’s define this endpoint:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义这个端点：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As in the preceding code example, we get a string from a resource file according
    to the culture of the request. But, in this case, the message contains a placeholder,
    so we can use it to create a custom localized message using the name that is passed
    to the route handler. If we try to execute the endpoint, we will get results such
    as these:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码示例所示，我们根据请求的文化从资源文件中获取一个字符串。但是，在这种情况下，消息包含一个占位符，因此我们可以使用它通过传递给路由处理器的名称来创建一个自定义的本地化消息。如果我们尝试执行端点，我们将得到如下结果：
- en: '![Table 9.3 – Responses with custom localized messages based on the request
    language ](img/B17902_09_Table3.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.3 – 基于请求语言的定制本地化消息的响应](img/B17902_09_Table3.jpg)'
- en: Table 9.3 – Responses with custom localized messages based on the request language
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.3 – 基于请求语言的定制本地化消息的响应
- en: The possibility to create localized messages with placeholders that are replaced
    at runtime using different values is a key point for creating truly localizable
    services.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建在运行时使用不同值替换占位符的本地化消息，这对于创建真正可本地化的服务是一个关键点。
- en: In the beginning, we said that a typical use case of localization in web APIs
    is when we need to provide localized error messages upon validation. In the next
    section, we’ll see how to add this feature to our minimal API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，我们提到在 Web API 中本地化的典型用例是在验证时需要提供本地化错误消息。在下一节中，我们将看到如何将此功能添加到我们的最小 API 中。
- en: Integrating localization in validation frameworks
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在验证框架中集成本地化
- en: In [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation and
    Mapping*, we talked about how to integrate validation into a minimal API project.
    We learned how to use the `MiniValidation` library, rather than `FluentValidation`,
    to validate our models and provide validation messages to the callers. We also
    said that `FluentValidation` already provides translations for standard error
    messages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B17902_06.xhtml#_idTextAnchor082)，*探索验证和映射*中，我们讨论了如何将验证集成到最小 API
    项目中。我们学习了如何使用 `MiniValidation` 库，而不是 `FluentValidation`，来验证我们的模型并向调用者提供验证消息。我们还提到
    `FluentValidation` 已经为标准错误消息提供了翻译。
- en: However, with both libraries, we can leverage the localization support we have
    just added to our project to support localized and custom validation messages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这两个库，我们可以利用我们刚刚添加到项目中的本地化支持来支持本地化和自定义验证消息。
- en: Localizing validation messages with MiniValidation
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MiniValidation 本地化验证消息
- en: Using the `MiniValidation` library, we can use validation based on **Data Annotations**
    with minimal APIs. Refer to [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring
    Validation and Mapping*, for instructions on how to add this library to the project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MiniValidation` 库，我们可以使用基于 **数据注释** 的验证与最小 API。有关如何将此库添加到项目的说明，请参阅 [*第 6
    章*](B17902_06.xhtml#_idTextAnchor082)，*探索验证和映射*。
- en: 'Then, recreate the same `Person` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新创建相同的 `Person` 类：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Every validation attribute allows us to specify an error message, which can
    be a static string or a reference to a resource file. Let’s see how to correctly
    handle the localization for the `Required` attribute. Add the following values
    in resource files:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个验证属性都允许我们指定一个错误消息，它可以是静态字符串或对资源文件的引用。让我们看看如何正确处理`Required`属性的本地化。在资源文件中添加以下值：
- en: '![Table 9.4 – Localized validation error messages used by Data Annotations
    ](img/B17902_09_Table4.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![表9.4 – 数据注释使用的本地化验证错误消息](img/B17902_09_Table4.jpg)'
- en: Table 9.4 – Localized validation error messages used by Data Annotations
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.4 – 数据注释使用的本地化验证错误消息
- en: We want it so that when a required validation rule fails, the localized message
    that corresponds to `FieldRequiredAnnotation` is returned. Moreover, this message
    contains a placeholder, because we want to use it for every required field, so
    we also need the translation of property names.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望当必需的验证规则失败时，返回与`FieldRequiredAnnotation`对应的本地化消息。此外，此消息包含一个占位符，因为我们希望将其用于每个必需字段，因此我们还需要属性名称的翻译。
- en: 'With these resources, we can update the `Person` class with the following declarations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些资源，我们可以使用以下声明更新`Person`类：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each validation attribute, such as `Required` (as used in this example), exposes
    properties that allow us to specify the name of the resource to use and the type
    of class that contains the corresponding definition. Keep in mind that the name
    is a simple string, with no check at compile time, so if we write an incorrect
    value, we’ll only get an error at runtime.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个验证属性，如`Required`（如本例中所示），都公开了允许我们指定要使用的资源名称和包含相应定义的类的类型的属性。请记住，名称是一个简单的字符串，编译时没有检查，所以如果我们写了一个错误值，我们只有在运行时才会得到错误。
- en: Next, we can use the `Display` attribute to also specify the name of the field
    that must be inserted in the validation message.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`Display`属性来指定必须插入验证消息中的字段名称。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the complete declaration of the `Person` class with localized data
    annotations on the GitHub repository at https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/blob/main/Chapter09/Program.cs#L97.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/blob/main/Chapter09/Program.cs#L97上找到带有本地化数据注释的`Person`类的完整声明。
- en: 'Now we can re-add the validation code shown in [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082),
    *Exploring Validation and Mapping*. The difference is that now the validation
    messages will be localized:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新添加[*第6章*](B17902_06.xhtml#_idTextAnchor082)，*探索验证和映射*中显示的验证代码。不同的是，现在验证消息将是本地化的：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the messages contained in the `errors` dictionary that
    is returned by the `MiniValidator.TryValidate()` method will be localized according
    to the request culture, as described in the previous sections. We also specify
    the `title` parameter in the `Results.ValidationProblem()` invocation because
    we want to localize this value too (otherwise, it will always be the default `One
    or more validation errors occurred`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`MiniValidator.TryValidate()`方法返回的`errors`字典中包含的消息将根据请求文化进行本地化，如前几节所述。我们还指定了`Results.ValidationProblem()`调用中的`title`参数，因为我们还想本地化这个值（否则，它将始终是默认的`One
    or more validation errors occurred`）。
- en: If instead of data annotations, we prefer using `FluentValidation`, we know
    that it supports localization of standard error messages by default from [*Chapter
    6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation and Mapping*. However,
    with this library, we can also provide our translations. In the next section,
    we’ll talk about implementing this solution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢使用`FluentValidation`而不是数据注释，我们知道它默认支持标准错误消息的本地化[*第6章*](B17902_06.xhtml#_idTextAnchor082)，*探索验证和映射*。然而，使用这个库，我们还可以提供我们的翻译。在下一节中，我们将讨论实现此解决方案的方法。
- en: Localizing validation messages with FluentValidation
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FluentValidation本地化验证消息
- en: With `FluentValidation`, we can totally decouple the validation rules from our
    models. As said before, refer to [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082),
    *Exploring Validation and Mapping*, for instructions on how to add this library
    to the project and how to configure it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FluentValidation`，我们可以完全解耦验证规则和我们的模型。如前所述，请参阅[*第6章*](B17902_06.xhtml#_idTextAnchor082)，*探索验证和映射*，了解如何将此库添加到项目中以及如何配置它。
- en: 'Next, let us recreate the `PersonValidator` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新创建`PersonValidator`类：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the case that we haven’t specified any messages, the default ones will be
    used. Let’s add the following resource to customize the `NotEmpty` validation
    rule:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定任何消息，将使用默认消息。让我们添加以下资源来自定义`NotEmpty`验证规则：
- en: '![Table 9.5 – The localized validation error messages used by FluentValidation
    ](img/B17902_09_Table5.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![表9.5 – FluentValidation使用的本地化验证错误消息](img/B17902_09_Table5.jpg)'
- en: Table 9.5 – The localized validation error messages used by FluentValidation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.5 – FluentValidation使用的本地化验证错误消息
- en: Note that, in this case, we also have a placeholder that will be replaced by
    the property name. However, different from data annotations, `FluentValidation`
    uses a placeholder with a name to better identify its meaning.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们还有一个占位符，它将被属性名称替换。然而，与数据注释不同，`FluentValidation`使用带有名称的占位符来更好地识别其含义。
- en: 'Now, we can add this message in the validator, for example, for the `FirstName`
    property:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在验证器中添加这条消息，例如，对于`FirstName`属性：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use `WithMessage()` to specify the message that must be used when the preceding
    rule fails, following which we add the `WithName()` invocation to overwrite the
    default property name used for the `{PropertyName}` placeholder of the message.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`WithMessage()`来指定在之前的规则失败时必须使用的消息，之后我们添加`WithName()`调用以覆盖消息的`{PropertyName}`占位符所使用的默认属性名称。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the complete implementation of the `PersonValidator` class with
    localized messages in the GitHub repository at https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/blob/main/Chapter09/Program.cs#L129.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库中找到`PersonValidator`类的完整实现以及本地化消息，网址为https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/blob/main/Chapter09/Program.cs#L129。
- en: 'Finally, we can leverage the localized validator in our endpoint, as we did
    in [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation and
    Mapping*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的端点中利用本地化的验证器，就像我们在[*第6章*](B17902_06.xhtml#_idTextAnchor082)中做的那样，*探索验证和映射*：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As in the case of data annotations, the `validationResult` variable will contain
    localized error messages that we return to the caller using the `Results.ValidationProblem()`
    method (again, with the definition of the `title` property).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据注释的情况一样，`validationResult`变量将包含本地化错误消息，我们使用`Results.ValidationProblem()`方法（再次，使用`title`属性的定义）将其返回给调用者。
- en: Tip
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In our example, we have seen how to explicitly assign translations for each
    property using the `WithMessage()` method. `FluentValidation` also provides a
    way to replace all (or some) of its default messages. You can find more information
    in the official documentation at [https://docs.fluentvalidation.net/en/latest/localization.xhtml#default-messages](https://docs.fluentvalidation.net/en/latest/localization.xhtml#default-messages).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们已经看到如何使用`WithMessage()`方法显式地为每个属性分配翻译。`FluentValidation`还提供了一种替换所有（或部分）其默认消息的方法。你可以在官方文档中找到更多信息，网址为[https://docs.fluentvalidation.net/en/latest/localization.xhtml#default-messages](https://docs.fluentvalidation.net/en/latest/localization.xhtml#default-messages)。
- en: 'This ends our overview of localization using resource files. Next, we’ll talk
    about an important topic when dealing with services that are meant to be used
    worldwide: the correct handling of different time zones.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们使用资源文件进行本地化的概述。接下来，我们将讨论处理旨在全球使用的服务时的重要话题：正确处理不同的时区。
- en: Adding UTC support to a globalized minimal API
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为全局化的最小API添加UTC支持
- en: So far, we have added globalization and localization support to our minimal
    API because we want it to be used by the widest audience possible, irrespective
    of culture. But, if we think about being accessible to a worldwide audience, we
    should consider several aspects related to globalization. Globalization does not
    only pertain to language support; there are important factors we need to consider,
    for example, geographic locations, as well as time zones.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的最小API添加了全球化和本地化支持，因为我们希望它能够被尽可能广泛的受众使用，无论文化如何。但是，如果我们考虑让全球受众能够访问，我们应该考虑与全球化相关的几个方面。全球化不仅涉及语言支持；还有一些重要的因素我们需要考虑，例如地理位置以及时区。
- en: So, for example, we can have our minimal API running in Italy, which follows
    *Central European Time* (CET) (GMT+1), while our clients can use browsers that
    execute a single-page application, rather than mobile apps, all over the world.
    We could also have a database server that contains our data, and this could be
    in another time zone. Moreover, at a certain point, it may be necessary to provide
    better support for worldwide users, so we’ll have to move our service to another
    location, which could have a new time zone. In conclusion, our system could deal
    with data in different time zones, and, potentially, the same services could switch
    time zones during their lives.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以让我们的最小API在意大利运行，意大利遵循中欧时间（CET）（GMT+1），而我们的客户可以使用全球范围内的浏览器来执行单页应用程序，而不是移动应用。我们还可以有一个包含我们数据的数据库服务器，这可能是另一个时区。此外，在某个时刻，可能需要为全球用户提供更好的支持，因此我们必须将我们的服务迁移到另一个位置，这可能具有新的时区。总之，我们的系统可以处理不同时区的数据，并且，潜在地，同一服务在其生命周期中可能需要切换时区。
- en: 'In these situations, the ideal solution is working with `DateTimeOffset`, a
    data type that includes time zones and that `JsonSerializer` fully supports, preserving
    time zone information during serialization and deserialization. If we could always
    use it, we’d automatically solve any problem related to globalization, because
    converting a `DateTimeOffset` value to a different time zone is straightforward.
    However, there are cases in which we can’t handle the `DateTimeOffset` type, for
    example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，理想的解决方案是使用`DateTimeOffset`数据类型，它包含时区信息并且`JsonSerializer`完全支持，在序列化和反序列化过程中保留时区信息。如果我们总能使用它，我们就能自动解决与全球化相关的任何问题，因为将`DateTimeOffset`值转换为不同的时区是直接的。然而，有些情况下我们无法处理`DateTimeOffset`类型，例如：
- en: When we’re working on a legacy system that relies on `DateTime` everywhere,
    updating the code to use `DateTimeOffset` isn’t an option because it requires
    too many changes and breaks the compatibility with the old data.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在一个依赖于`DateTime`的遗留系统上工作时，更新代码以使用`DateTimeOffset`不是一个选择，因为它需要太多的更改，并且与旧数据不兼容。
- en: We have a database server such as MySQL that doesn’t have a column type for
    storing `DateTimeOffset` directly, so handling it requires extra effort, for example,
    using two separate columns, increasing the complexity of the domain.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个数据库服务器，例如MySQL，它没有直接存储`DateTimeOffset`的列类型，因此处理它需要额外的努力，例如使用两个单独的列，增加了领域的复杂性。
- en: In some cases, we simply aren’t interested in sending, receiving, and saving
    time zones – we just want to handle time in a “universal” way.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能对发送、接收和保存时区并不感兴趣——我们只想以“通用”的方式处理时间。
- en: 'So, in all the scenarios where we can’t or don’t want to use the `DateTimeOffset`
    data type, one of the best and simplest ways to deal with different time zones
    is to handle all dates using *Coordinated Universal Time* (*UTC*): the service
    must assume that the dates it receives are in the UTC format and, on the other
    hand, all the dates returned by the API must be in UTC.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有我们无法或不想使用`DateTimeOffset`数据类型的情况下，处理不同时区的最佳和最简单的方法之一是使用协调世界时（*UTC*）处理所有日期：服务必须假设它接收的日期是UTC格式，另一方面，API返回的所有日期都必须是UTC格式。
- en: 'Of course, we must handle this behavior in a centralized way; we don’t want
    to have to remember to apply the conversion to and from the UTC format every time
    we receive or send a date. The well-known JSON.NET library provides an option
    to specify how to treat the time value when working with a `DateTime` property,
    allowing it to automatically handle all dates as UTC and convert them to that
    format if they represent a local time. However, the current version of Microsoft
    `JsonSerializer` used in minimal APIs doesn’t include such a feature. From [*Chapter
    2*](B17902_02.xhtml#_idTextAnchor023), *Exploring Minimal APIs and Their Advantages*,
    we know that we cannot change the default JSON serializer in minimal APIs, but
    we can overcome this lack of UTC support by creating a simple `JsonConverter`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须集中处理这种行为；我们不希望每次接收或发送日期时都要记住应用UTC格式的转换。知名的JSON.NET库提供了一个选项，用于指定在处理`DateTime`属性时如何处理时间值，允许它自动将所有日期视为UTC，并在它们表示本地时间时将它们转换为该格式。然而，在最小API中使用的Microsoft
    `JsonSerializer`的当前版本不包括此功能。从[*第2章*](B17902_02.xhtml#_idTextAnchor023)，*探索最小API及其优势*，我们知道我们无法更改最小API中的默认JSON序列化器，但我们可以通过创建一个简单的`JsonConverter`来克服对UTC支持的缺乏：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this converter, we tell `JsonSerializer` how to treat `DateTime` properties:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此转换器，我们告诉 `JsonSerializer` 如何处理 `DateTime` 属性：
- en: When `DateTime` is read from JSON, the value is converted to UTC using the `ToUniversalTime()`
    method.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从 JSON 中读取 `DateTime` 时，值将使用 `ToUniversalTime()` 方法转换为 UTC。
- en: When `DateTime` must be written to JSON, if it represents a local time (`DateTimeKind.Local`),
    it is converted to UTC before serialization – then, it is serialized using the
    `Z` suffix, which indicates that the time is UTC.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `DateTime` 必须写入 JSON 时，如果它表示本地时间（`DateTimeKind.Local`），则在序列化之前将其转换为 UTC –
    然后，使用 `Z` 后缀进行序列化，表示时间是 UTC。
- en: 'Now, before using this converter, let’s add the following endpoint definition:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在使用此转换器之前，让我们添加以下端点定义：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s try to call it, for example, with a date formatted as `2022-03-06T16:42:37-05:00`.
    We’ll obtain something similar to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个格式为 `2022-03-06T16:42:37-05:00` 的日期来调用它。我们将得到以下类似的结果：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The input date, containing a time zone, has automatically been converted to
    the local time of the server (in this case, the server is running in Italy, as
    stated at the beginning), as also demonstrated by the `dateKind` field. Moreover,
    `serverDate` contains a date that is relative to the server time zone.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 包含时区的输入日期已自动转换为服务器的本地时间（在本例中，服务器位于意大利，如开头所述），这也可以通过 `dateKind` 字段得到证明。此外，`serverDate`
    包含一个相对于服务器时区的日期。
- en: 'Now, let’s add `UtcDateTimeConverter` to `JsonSerializer`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `UtcDateTimeConverter` 添加到 `JsonSerializer`：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this configuration, every `DateTime` property will be processed using
    our custom converters. Now, execute the endpoint again, using the same input as
    before. This time, the result will be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，每个 `DateTime` 属性都将使用我们的自定义转换器进行处理。现在，再次执行端点，使用之前相同的输入。这次，结果将如下所示：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The input is the same, but our `UtcDateTimeConverter` has now converted the
    date to UTC and, on the other hand, has serialized the server date as UTC; now,
    our API, in a centralized way, can automatically handle all dates as UTC, no matter
    its time zone or the time zones of the callers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输入相同，但我们的 `UtcDateTimeConverter` 现在已将日期转换为 UTC，另一方面，已将服务器日期序列化为 UTC；现在，我们的 API
    以集中的方式可以自动处理所有日期作为 UTC，无论其时区或调用者的时区如何。
- en: 'Finally, there are two other points to make all the systems correctly work
    with UTC:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有两个其他要点以确保所有系统都能正确地使用 UTC：
- en: When we need to retrieve the current date in the code, we always have to use
    `DateTime.UtcNow` instead of `DateTime.Now`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要在代码中获取当前日期时，我们总是必须使用 `DateTime.UtcNow` 而不是 `DateTime.Now`
- en: Client applications must know that they will receive the date in UTC format
    and act accordingly, for example, invoking the `ToLocalTime()` method
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端应用程序必须知道它们将接收到 UTC 格式的日期，并相应地操作，例如，调用 `ToLocalTime()` 方法
- en: In this way, the minimal API is truly globalized and can work with any time
    zone; without having to worry about explicit conversion, all times input or output
    will be always in UTC, so it will be much easier to handle them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，最小化 API 真正实现了全球化，可以与任何时区一起工作；无需担心显式转换，所有输入或输出的时间都将始终是 UTC，因此处理它们将变得更加容易。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Developing minimal APIs with globalization and localization support in mind
    is fundamental in an interconnected world. ASP.NET Core includes all the features
    needed to create services that can react to the culture of the user and provide
    translations based on the request language: the usage of localization middleware,
    resource files, and custom validation messages allows the creation of services
    that can support virtually every culture. We have also talked about the globalization-related
    problems that could arise when working with different time zones and shown how
    to solve it using the centralized UTC date time format so that our APIs can seamlessly
    work irrespective of the geographic location and time zone of clients.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个互联互通的世界中，考虑到全球化和本地化支持来开发最小化 API 是至关重要的。ASP.NET Core 包含创建能够根据用户文化做出反应并提供基于请求语言翻译的服务所需的所有功能：使用本地化中间件、资源文件和自定义验证消息可以创建几乎支持所有文化的服务。我们还讨论了在处理不同时区时可能出现的全球化相关问题，并展示了如何使用集中的
    UTC 日期时间格式来解决这些问题，以便我们的 API 可以无缝地在任何地理位置和时间区工作。
- en: In [*Chapter 10*](B17902_10.xhtml#_idTextAnchor140), *Evaluating and Benchmarking
    the Performance of Minimal APIs*, we will talk about why minimal APIs were created
    and analyze the performance benefits of using minimal APIs over the classic controller-based
    approach.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B17902_10.xhtml#_idTextAnchor140)，*评估和基准测试最小API的性能*，我们将讨论为什么创建最小API，并分析使用最小API相对于经典基于控制器的方法的性能优势。
