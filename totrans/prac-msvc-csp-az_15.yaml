- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous Communication with Messages and Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we updated our services using binary communication.
    However, some services don’t need connected services: the client and the server
    do not need to be connected at the same time, which means communication can be
    done asynchronously. This communication can be done by sending messages to a queue
    or publishing events.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use Azure services for asynchronous communication – that
    is, Azure Queue Storage and Azure Event Hubs. We’ll also use Apache Kafka as an
    alternative option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Differentiate message queues and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send and receive messages using a queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish and subscribe events with Azure Event Hubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Apache Kafka for event processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription
    and Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ch15` folder contains the projects for this chapter, along with their outputs.
    To add the functionality from this chapter, you can start with the source code
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be considering the following projects in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost`: The .NET Aspire host project. The app model has been
    enhanced by adding Azure Storage, Azure Event Hubs, and Apache Kafka services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.BotQ`: This is a new project that contains nearly the same code
    as `Codebreaker.Bot`. However, instead of using a REST API to trigger gameplay,
    a message queue is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs`: This project has been updated so that it doesn’t forward
    completed games to `live-service` directly. Instead, it publishes events to Azure
    Event Hubs or Apache Kafka depending on the launch profile startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Live`: This project has been changed so that it subscribes to
    events from Azure Event Hubs using async streams. The SignalR implementation has
    also been changed so that it uses async streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Ranking`: This is a new project that receives events from Azure
    Event Hubs or Kafka, writes this information to an Azure Cosmos DB database, and
    offers a REST service to retrieve the rank of the day. With Event Hub, we have
    a different way to receive events than we do when using `live-service`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing messages and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we used connected network communication with all the
    services. First, we look into the communication between the bot and the game APIs
    as shown in *Figure 15**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 - Synchronous communication between the bot and the game APIs](img/B21217_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 - Synchronous communication between the bot and the game APIs
  prefs: []
  type: TYPE_NORMAL
- en: The bot service can be accessed via REST. The bot service itself invokes the
    game APIs service via gRPC (all other clients use REST with the game APIs service).
    The bot service then continues communication with the game APIs service, sends
    moves until the game is complete, and continues with the next game until a specified
    number of games is played. The bot client invokes the bot service via REST which
    is (like gRPC) synchronous communication, with request/reply. The bot service
    here doesn’t have a synchronous implementation, as the bot client doesn’t need
    to wait until all the games are played – the HTTP protocol would timeout during
    this time. Instead, the bot service returns an HTTP `ACCEPTED` answer (status
    code 202) with a unique identifier which can be used by the client to check for
    a status. The protocol itself is synchronous, as the client waits for answer 202.
  prefs: []
  type: TYPE_NORMAL
- en: When a game ends, the next part of the communication is shown with *Figure 15**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 - Synchronous communication initiated from the game APIs](img/B21217_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 - Synchronous communication initiated from the game APIs
  prefs: []
  type: TYPE_NORMAL
- en: The game APIs service informs the ranking service and the live service using
    gRPC. The live service continues communication via SignalR to inform all connected
    clients about the game end. The ranking service will be implemented in this chapter
    to write all ended games to a new database. To simplify this image, some services
    that are used within the communication are not shown. There’s synchronous communication
    between the game APIs and Azure Cosmos DB, similar to the ranking service.
  prefs: []
  type: TYPE_NORMAL
- en: With synchronous communication, if there’s a delay in one of the services, the
    delay goes back to the original caller. If there’s an error in one of the services,
    the client does not receive a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft Azure offers several services that can be used to create asynchronous
    communication: Azure Queue Storage, the Azure Service Bus, Azure Event Gird, and
    Azure Event Hub. Let’s have a look at a new version of the new sequence with the
    communication with the bot client and the bot service in *Figure 15**.3*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 - Asynchronous communication between the bot client and the bot
    service](img/B21217_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 - Asynchronous communication between the bot client and the bot
    service
  prefs: []
  type: TYPE_NORMAL
- en: With the new implementation the Azure Queue Storage comes into play. The bot
    service registers with the queue to receive messages. The bot client, instead
    of using HTTP to communicate with the bot service, sends a message to the queue.
    The bot client does not need to wait if anybody started to work on this message.
    For the client, the job is done. The bot service, because it registered to receive
    messages, receives the message from the queue and plays the games in the same
    way as before, this doesn’t change.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at the asynchronous communication initiated by the game APIs service
    in *Figure 15**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Asynchronous communication initiated from the game APIs](img/B21217_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Asynchronous communication initiated from the game APIs
  prefs: []
  type: TYPE_NORMAL
- en: Here, the Azure Event Hub comes into play. The game APIs service, instead of
    doing synchronous communication both with the ranking and the live services, just
    communicates with the event hub. A game-ended event is pushed to this service.
    The game APIs doesn’t need to know who is interested in this event, who is receiving
    this event. Here, two subscribers, the ranking service and the live service are
    registered, and receive this event. From here on, communication is the same as
    before. The ranking service writes the received information to a database (which
    is not shown), and the live service forwards this information to clients that
    are subscribed to the live service – if they are subscribed to the same game type
    that is stored with the event.
  prefs: []
  type: TYPE_NORMAL
- en: The important difference between using message queues and events can be seen
    in this scenario. When sending a message to a queue, just one receiver deals with
    the message. Multiple readers can be connected to the same queue (for performance
    reasons), but only one reader processes the message. If the message is processed
    successfully, it’s removed from the queue. With events, multiple subscribers receive
    and process the same event.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the different options that are available with Microsoft Azure
    for messages and events.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Azure offers Azure Queue Storage (part of the Azure Storage Account)
    and Service Bus queues that can be used for queuing messages. Azure Queue Storage
    is the simpler and cheaper option to use, but Azure Service Bus offers a lot more
    features, such as ordering guarantees, atomic operations, sending messages in
    a batch, duplicate detection, and more. See [https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted](https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To publish and subscribe to events, you can use Azure Event Grid and Azure
    Event Hubs. **Azure Event Grid** is easy to use to subscribe to events with most
    Azure resources. In the Azure portal, with most resources, you can see the **Events**
    menu in the left bar. For example, when opening an Azure Storage Account, after
    clicking on **Events**, click **Event Subscription**. With a storage account,
    you’ll see event types such as **Blob Created**, **Blob Deleted**, **Blob Renamed**,
    **Directory Created**, **Directory Deleted**, **Directory Renamed**, **Blob Tier
    Changed**, and others, as shown in *Figure 15**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Create Event Subscription](img/B21217_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Create Event Subscription
  prefs: []
  type: TYPE_NORMAL
- en: Event types are predefined by Azure resources. With event subscriptions, you
    can specify where the event should be fired. You can choose this with the endpoint,
    which can be an Azure function, a storage queue, a hybrid connection, a Webhook,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Event Grid also allows you to specify custom topics to be defined, high throughput
    with up to 10,000,000 events per second, and 100,000 operations a month for free.
    This service is available as a PaaS offering running on Azure with the name **Event
    Grid on Kubernetes with Azure Arc** on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: To support even more events, massive scaling with partitions, and a big data
    streaming platform with low latency, **Azure Event Hubs** can be used. This service
    offers reliable event delivery where events are stored for up to 7 days in case
    they have not been delivered. Event Hubs also has great integration with streaming
    analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update the Codebreaker solution with Azure Queues and Azure Event Hubs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, .NET Aspire has planned support with Azure Event Grid.
    Event Hubs, Queue Storage, and Azure Service Bus are already available.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start reading from Azure Queue Storage with the Codebreaker bot service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service that reads from Azure Queue Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Codebreaker.Bot` project we used previously offers a minimal API service.
    With the updates, a REST API isn’t needed – a simple console application will
    do. Just create a new console application (`dotnet new console -o Codebreaker.BotQ`)
    and copy the source code from `Codebreaker.Bot`. The new bot will also use gRPC
    for communication with the game APIs service. Because this isn’t an ASP.NET Core
    application, these NuGet packages are needed for gRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Google.Protobuf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grpc.Net.ClientFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grpc.Tools`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the DI container, we also need `Microsoft.Extensions.Hosting`, and for the
    .NET Aspire Storage Queues component, we need `Aspire.Azure.Storage.Queues`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll update the app model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining app-model for Azure Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the AppHost project, reference the newly created project, `Codebreaker.BotQ`,
    and add the `Aspire.Hosting.Azure.Storage` NuGet package so that you can use the
    Azure Storage resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke the `AddAzureStorage` method to specify Azure Storage with the app model:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Azure Storage resource supports queues, tables, and blobs. This time, we’ll
    use queues, hence why we’re invoking the `AddQueues` extension method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project configuration references the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to using the new bot project instead of the old one. The new project
    references the queue to pass the connection string. In addition, we specify the
    `Loop` and `Delay` parameters, which are read from the configuration and set as
    environment variables on starting `bot-service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values are specified within the AppHost development configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/appsettings.Development.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The new `bot-service` can read values from the storage queue in a loop – which
    is configured here. When published with Azure, the loop isn’t needed. This will
    be covered later in the *Deploying the solution to Microsoft* *Azure* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the app model has been specified, let’s continue with the new bot project.
  prefs: []
  type: TYPE_NORMAL
- en: Using the storage queue component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the previous bot project, we received values so that we could start playing
    a sequence of games. The same information is needed with the new bot:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Count` property is for the number of games to play, the `Delay` property
    is for the delay between games, and the `ThinkTime` property is for the value
    of the think time between game moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BotQueueClientOptions` class is used to receive the configuration values
    that are passed from the AppHost:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the constructor of the `BotQueueClient` class, `options`, `logger`,
    the previously used `CodebreakerTimer`, and `QueueServiceClient` are injected:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `QueueService` client class is from the `Azure.Storage.Queues` namespace
    and communicates with the Azure Storage queue resources to get information about
    queues, as well as to create queues. With the implementation of `CodebreakerTimer`,
    a timer is used to play game after game. It uses the values we receive in the
    message from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RunAsync` method kicks off the work:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To read messages from the queue, we use the `QueueClient` class. The `QueueServiceClient`
    method, `GetQueueClient`, returns `QueueClient` to communicate with the queue
    named `botqueue`. With the app model we specified earlier, only the storage account
    is created, not the queue itself. We create the queue if it doesn’t already exist.
    Then – in a loop – we invoke `ProcessMessagesAsync`. If the loop isn’t set, messages
    are retrieved only once. This can be used when publishing Azure Container Apps
    jobs, as will be discussed in the *Deploying the solution to Microsoft* *Azure*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A dead letter queue can be checked to find out if there have been issues with
    messages. When a message cannot be successfully processed a few times, for example,
    when the receiver throws, the message is written to the dead letter queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `ProcessMessageAsync` reads a message from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.BotQ/Endpoints/BotQueueClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, attributes of the queue are checked to see if there’s a message available
    using the `ApproximateMessagesCount` property. If this is the case, messages are
    retrieved using `ReceiveMessagesAsync`. This method reads the messages from the
    queue, at which point the messages can no longer be seen by others. The time the
    message is not visible can be set with the `visibilityTimeout` parameter. The
    default is 30 seconds. When successfully deserializing the message, it is deleted
    using `DeleteMessageAsync`. The `timer.Start` method starts a task to play the
    games asynchronously. So, if a game takes longer to play (with many games or with
    higher think times), this does not influence deleting the message. If the message
    returns to the queue, it can be processed again. The implementation checks for
    the dequeue count of the message that’s retrieved. If it’s read three times, the
    message goes to a dead-letter queue and can be manually checked for issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s configure the DI container:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.BotQ/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureQueueClient` method is defined with the `Aspire.Azure.Storage.Queues`
    NuGet package. This method configures the Aspire component and registers the `QueueService`
    client with the DI container. With the environment variables passed by the AppHost,
    these values are retrieved using `builder.Configuration.GetSection` and configured
    with the `BotQueueClientOptions` class, which defines the loop’s behavior. Other
    than this, the timer, game runner, and gRPC are configured in the same way as
    the previous bot service implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to run the application and test queues.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set breakpoints within the new bot service project to verify the functionality
    of the queue. When you start the application, an Azure Storage Account is created.
    With the initialization of `BotQueueClient`, message queues are created. This
    can verified in the Azure portal, as shown in *Figure 15**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Storage queues created](img/B21217_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Storage queues created
  prefs: []
  type: TYPE_NORMAL
- en: 'The `botqueue` and `dead-letter` storage queues have been created. Now, open
    `botqueue` to pass a valid JSON message, as shown in *Figure 15**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Add message to queue](img/B21217_15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Add message to queue
  prefs: []
  type: TYPE_NORMAL
- en: '`BotMessage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With a valid JSON message, you will see that the message is processed. After
    sending a message that’s not in JSON format, you’ll see the message in the dead-letter
    queue – after some retries.
  prefs: []
  type: TYPE_NORMAL
- en: As the bot now starts playing games when we send messages, let’s get into the
    next enhancement – using Azure Event Hubs.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing messages to Azure Event Hubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Azure Event Hubs, we’ll implement the game APIs service so that we can
    publish events.
  prefs: []
  type: TYPE_NORMAL
- en: Defining app-model for Event Hubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Azure Event Hubs with the AppHost project, the `Aspire.Hosting.Azure.EventHubs`
    NuGet package is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Event Hubs needs to be added to the app model:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureEventHubs` method, adds an Azure Event Hubs namespace, `AddEventHub`,
    as an event hub. A namespace is a management container with network endpoints
    and access control. The default Event Hub namespace that’s created is in the Standard
    tier. For development, you can change this to the Basic tier. Event hubs are created
    within namespaces. For scalability, event hubs use one or more partitions. By
    default, the event hub is created with four partitions. A partition contains an
    ordered stream of events. The number of partitions doesn’t change the price, but
    the number of throughput units does. With the number of throughput units, you
    specify a number of events per second. The number of partitions should be equal
    to or higher than the number of throughput units. Throughput units can be changed
    as needed; the number of partitions can only be changed in premium and dedicated
    tiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the event hub specified, we can reference it:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the game APIs service, we replace the referenced live service with the
    event hub. The reference to live service is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can look at the game APIs service.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET Aspire Event Hubs component to produce events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the .NET Aspire Event Hubs component, we must add the `Aspire.Azure.Messaging.EventHub`
    NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this package, we can configure the DI container:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the game APIs service, to send information about completed games, in previous
    chapters, we created the `LiveReportClient` class to call a REST service and the
    `GrpcLiveReportClient` class to invoke a gRPC service. Now, we can implement the
    same interface we used earlier – `IGameReport` with the `EventHubReportProducer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending events can easily be done, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/EventHubReportProducer.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `EventHubReportProducer` class injects the `EventHubProducerClient` class
    to send events to the event hub. `GameSummary` is converted into `BinaryData`
    with `BinaryData.FromObjectAsJson`. The `EventData` class from the `Azure.Messaging.EventHubs`
    namespace allows us to pass a string, `BinaryData`, and `ReadOnlyMemory<byte>`.
    Then, the event is published by invoking the `SendAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve published some events, let’s subscribe to them.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to Azure Event Hubs events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Codebreaker.Live` project previously offered a gRPC service that was invoked
    by the game APIs service to publish completed games via SignalR. Instead of offering
    a gRPC service, we can subscribe to events.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Codebreaker.Ranking` project so that you can offer minimal APIs.
    This project will receive the same events as `Codebreaker.Live` but write them
    to a database to offer ranks for games based on days, weeks, and months.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `Codebreaker.Ranking` project, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Add the newly created project as a reference to `Codebreaker.AppHost`, and reference
    `Codebreaker.ServiceDefaults` to configure the service defaults. Now, we can update
    app model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining app-model for Event Hubs subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the AppHost project, the live and ranks projects reference the event hub,
    similar to the events publishing project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to events can be done in two ways, either with the event hub consumer
    client or the event processor client. The event hub consumer client is simpler
    to use and supports async streams. The event processor client is more powerful
    and supports receiving from multiple partitions in parallel. The second option
    needs to save checkpoints in an Azure blob storage account. We use the same account
    that we already use for queues.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement both versions. The Codebreaker live service uses async streams,
    and the event hub consumer client with the class `EventHubConsumerClient` fits
    its need. The Codebreaker ranking service makes use of the event processor client,
    using `EventProcessorClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Event Hubs component with async streaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the `Codebreaker.Live` project, references to the `Aspire.Azure.Messaging.EventHubs`
    NuGet package are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Codebreaker.Live` project was created in [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317).
    Here, we’ll create a new SignalR hub to offer streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureEventHubConsumerClient` method configures the `EventHubConsumerClient`
    class as a singleton within the DI container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must create a new SignalR hub to inject `EventHubConsumerClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Endpoints/StreamingLiveHub.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By using the primary constructor, `EventHubConsumerClient` is injected to retrieve
    the events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `SubscribeToGameCompletions` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/Endpoints/StreamingLiveHub.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: SignalR supports async streaming with methods returning `IAsyncEnumerable`.
    The `SubscribeToGameCompletions` method receives a game type parameter that only
    returns game completions of this game type. `EventHubConsumerClient` supports
    async streaming by invoking the `ReadEventsAsync` method. If the received game
    summary is of the requested game type, it’s returned to the client via the async
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the middleware needs to be configured so that it references
    the new hub:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Live/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update the client by using async streaming and the new link:'
  prefs: []
  type: TYPE_NORMAL
- en: LiveTestClient/StreamingLiveClient.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With the same SignalR initialization configuration we created in [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317),
    the client now uses the `StreamAsync` method from the SignalR `HubConnection`
    class to async stream the results that are returned from the service.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes, you can already test and run the solution, starting from
    the message queue up to the SignalR streaming client, to receive completed games.
    However, let’s add another Event Hubs client to process messages, this time with
    the Event Hubs processor.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET Aspire Event Hubs component to process messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Codebreaker.Ranking` project receives events, writes those events to an
    Azure Cosmos database, and offers minimal APIs to get ranking information from
    the players. This project references the .NET Aspire `Aspire.Azure.Messaging.EventHubs`
    and `Aspire.Azure.Storage.Blobs` components:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Ranking/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`AddAzureEventProcessorClient` registers a singleton instance of the `EventProcessorClient`
    class. We connect to the same namespace and event hub, so this configuration is
    the same. What’s different is that `AddKeyedAzureBlobClient` is a method from
    the .NET Aspire Blob Storage component. This method registers a singleton instance
    with the DI container to read and write blobs. The storage is connected to the
    event hub by setting `BlobClientServiceKey` to write checkpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also simplify the configuration by not registering a keyed configuration.
    The one default storage component that’s registered is automatically used from
    the event hub component.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the event hub configuration, an EF Core context must be configured
    to write the received game summary information to an Azure Cosmos DB database.
    Check out [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063) for more details. Contrary
    to [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we register an EF Core context
    factory with the DI container, which allows us to inject this into a singleton
    object and create the context objects with a shorter lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The registered `GameSummaryEventProcessor` is our implementation for dealing
    with events:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The class injects `EventProcessorClient` and the EF Core context factory. This
    class implements methods to start and stop the processing of events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StartProcessingAsync` method is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you start processing events by invoking the `StartProcessingAsync` method,
    the `EventProcessorClient` class fires .NET events that are invoked when messages
    are received, and on errors: `ProcessEventAsync` and `ProcessErrorAsync`. A received
    message is converted from binary into a `GameSummary` object and written to the
    database. In addition to that, the checkpoint in the storage account is written
    so that we know which event message was processed last.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When this is in place, start the application, open the Azure portal to send
    messages to the bot queue to let the bot play some games, and monitor how events
    are sent. *Figure 15**.8* shows the Azure portal showing Event Hub metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Event Hub metrics](img/B21217_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Event Hub metrics
  prefs: []
  type: TYPE_NORMAL
- en: Apart from checking the Event Hub metrics, verify the data that’s been written
    to the rankings database. Also, start the SignalR client application so that you
    can monitor event data with async streaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Event Hub instance in the Azure portal and select **Configuration**
    within the **Settings** category (see *Figure 15**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Event Hub configuration](img/B21217_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Event Hub configuration
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the configured partition count and can disable the hub. Regarding
    `ranking-service` is not running on one day, there’s still enough time to process
    the games afterward.
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure how data is captured (**Features** | **Capture**) with
    an Azure Storage Account (**Avro** serialization format) or Azure Data Lake (**Parquet**
    or **Delta Lake** serialization format). Make sure you check out the pricing options
    before configuring capturing or other SKUs.
  prefs: []
  type: TYPE_NORMAL
- en: Mentioning prices, what do you need to be aware of when you’re deploying the
    solution to Microsoft Azure?
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the solution to Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using a low load, the complete solution is not expensive when it’s running
    on Microsoft Azure. CPU power typically results in higher cost. How many containers
    are running with Azure Container Apps? `bot-service`, the `game-apis` service,
    `live-service`, `ranking-service`, and the Redis container. The `game-apis` service
    should scale with the minimum value set to 1, which provides a fast response for
    the first user so that they get a fast first answer. If you scale to 1 when the
    service is idle, there’s an idle price that reduces the cost of the CPU considerably.
    `bot-service`, `live-service`, and `ranking-service` can scale down to 0, which
    means there’s no cost in terms of CPU and memory. However, be aware of custom
    health checks (covered in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294)), which
    can play against scaling to 0\. With `live-service`, if there’s no listener to
    query for running games, you can’t subscribe to events. Thus, cost only applies
    if clients are connected.
  prefs: []
  type: TYPE_NORMAL
- en: The bot contains a loop that keeps running and checks the queue repeatedly.
    This is not necessary with the Azure Container Apps environment. Here, we can
    create an **Azure Container Apps job** resource. This resource is only started
    based on a trigger – for example, a cron time or an event such as a message available
    in a storage queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating Azure Container Apps jobs is not yet supported with .NET Aspire out
    of the box. However, this is possible with some customization. Here’s what you
    need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the project with `azd init`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `azd infra synth` to create Bicep files and manifest files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Azure resources using `azd provision`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the manifest file of the project that should be deployed as a Container
    App Job instead of a Container App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the projects using `azd deploy` (you can deploy project by project using
    `azd deploy <service>` or deploy all).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the quick updates that are made to .NET Aspire, check out the README
    file in this chapter’s GitHub repository for the latest updates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at an alternative option to using Azure services.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apache Kafka for event processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Kafka can be an alternative to using Azure Queue Storage and Azure Event
    Hubs – especially when it comes to on-premises solutions. This technology is used
    by many companies in their on-premises environments for high performance application-to-application
    messaging, supports a scalable multiple producers and consumers environment (like
    Event Hub), and supports a read-only-once scenario like message queues.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the AppHost with the `OnPremises` launch profile will now use the previously
    created `Codebreaker.Bot`. This uses a REST API instead of message queues, replaces
    the event publishing mechanism of the `game-apis` service, and makes the event
    subscription from `ranking-service` use Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll change `app-model`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache Kafka with app-model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the Apache Kafka resource with `app-model`, we must add the `Aspire.Hosting.Kafka`
    NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `AddKafka` method adds a Docker container for local development. This resource
    is referenced from the `game-apis` service and `ranking-service` to forward the
    connection. `StartupMode` is configured with the launch profile and forwarded
    as an environment variable to both of these projects so that they can choose between
    Azure Event Hubs and Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll use an Aspire component to publish events.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Apache Kafka events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to publishers and subscribers, the `Aspire.Confluent.Kafka` NuGet
    package is used. Within this package, in the `Confluent.Kafka` namespace, the
    `IProducer` interface is defined. An object of this type is injected with the
    `KafkaGameReportProducer` class to publish completed games:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/KafkaGameReportProducer.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`KafkaGameReportProducer` implements the same interface that was used before
    – that is, `IGameReport`. The generic parameters of the `IProducer` interface
    define types for the key and the value. With Kafka, serializers can be specified,
    which allows for custom serialization. We can use simple strings that easily work
    across different platforms. With .NET, we can use the `System.Text.Json` serializer
    to serialize `GameSummary` objects to strings.'
  prefs: []
  type: TYPE_NORMAL
- en: The `IProducer` interface defines the `ProduceAsync` method to publish messages.
    The first parameter names a topic. Upon invoking the `ProduceAsync` method, the
    message is sent to a Kafka broker service. The message is kept there until it
    is read by a subscriber for the topic – up to a retention period. The default
    retention period is 1 week. To send messages to multiple subscribers (`live-service`
    and `ranking-service`), a list of topics is used.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProduceAsync` method returns `DeliveryResult` when the message is delivered
    to the broker. We don’t wait for the message to be delivered; instead, we use
    a loop to send the same message with multiple topics. `Task.WhenAll` could be
    used to wait for all deliveries or the `Flush` method to wait until a timeout
    is reached. The `Flush` method returns the number of items in the queue. Before
    the producer gets disposed of, you need to make sure that all messages are delivered
    to the broker. Because the producer is configured as a singleton with the DI container,
    we can keep the flush for later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must configure the DI container:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AddKafkaProducer` method registers the `IProducer` interface as a singleton.
    `kafkamessaging` is the string that’s used with `app-model` to get the connection
    string to the Kafka server. With the `KafkaProducerSettings` parameter, telemetry
    configuration and producer settings can be configured. Here, the `AllowAutoCreateTopics`
    setting is set to `true` – which is the default with producers. With consumers,
    this value is `false` by default. The previously created `KafkaGameReportProducer`
    class is registered as a singleton as well. The `IGameReport` interface is already
    used by the `GameService` class to report completed games, regardless of how this
    reporting is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s subscribe to these events with the ranking service.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to Apache Kafka events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Subscriber applications such as `Codebreaker.Ranking` need the same .NET Aspire
    component package to be referenced. When it comes to consumer classes, the `IConsumer`
    interface must be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Ranking/GameSummaryKafkaConsumer.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The ranking service subscribes to messages with the `ranking` topic using the
    `Subscribe` method. The topic was used when publishing messages. If the topic
    doesn’t exist because a message hasn’t been written yet, the `Consume` method
    throws a `ConsumeException` error. This exception is caught, and the `Consume`
    method is repeated after a delay. A game might not be completed when the ranking
    service starts up and the Docker container of the Kafka service hasn’t been configured
    to keep state.
  prefs: []
  type: TYPE_NORMAL
- en: When a message is received, it is written to the database, as we saw earlier
    with Azure Event Hubs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to configure the DI container:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Ranking/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To register the `IConsumer` interface, we use the `AddKafkaConsumer` method.
    `GroupId` needs to be configured with a Kafka consumer client. Groups are used
    for scalability. Similar to Azure Event Hubs, Kafka makes use of partitions. Multiple
    subscribers using the same group ID receive messages from different partitions.
    This allows for high scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the solution with the `OnPremises` launch profile. Start the Open
    API page of the bot to let it play some games and debug and monitor the services.
    *Figure 15**.10* shows metrics counts for the `game-apis` service with the bytes
    transmitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Kafka metrics](img/B21217_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Kafka metrics
  prefs: []
  type: TYPE_NORMAL
- en: Check the bytes, the messages that have been published and subscribed to, and
    the queue sizes for the publisher and the subscriber. Now is also a good time
    to take a break and play a few rounds of Codebreaker.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to decouple services by using asynchronous
    communication technologies, messages, and events. With Microsoft Azure, we used
    queues from an Azure Storage Account and events from Azure Event Hubs. Instead
    of using these PaaS services, you can also run Kafka within a Docker container
    in an Azure Container Apps environment, but you need to configure this with the
    app model.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned the differences between using message queues and a publish/subscribe
    event model with multiple subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the .NET Aspire component for Azure Service Bus in the
    *Further reading* section. This service offers more features with message queues,
    and you’ll learn about some concepts you already know about from Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: After all the different services, in the next chapter we’ll look into what more
    we should think about when deploying the application to the production environment,
    and we’ll deploy the solution to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*.NET Aspire Azure Blob Storage* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component](https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Aspire Azure Queue Storage* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component](https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure Event Hubs* *documentation*: [https://learn.microsoft.com/en-us/azure/event-hubs/](https://learn.microsoft.com/en-us/azure/event-hubs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.*NET Aspire Azure Event Hubs* *component*: [https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs](https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Aspire Azure Service Bus* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Aspire RabbitMQ* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Aspire Apache Kafka* *component*: [https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component](https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache Kafka .NET* *Client*: [https://docs.confluent.io/kafka-clients/dotnet/current/overview.html](https://docs.confluent.io/kafka-clients/dotnet/current/overview.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
