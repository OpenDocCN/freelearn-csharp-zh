- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: 'Enlightening Worlds: Illuminating Scenes with the Universal Render Pipeline'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《照亮世界：使用通用渲染管线照亮场景》
- en: '**Lighting** is a complex topic and there are several possible ways to handle
    it, with each one having its pros and cons. In order to get the best possible
    quality and performance, you need to know exactly how your renderer handles lighting,
    and that is exactly what we are going to work on in this chapter. We will discuss
    how lighting is handled in Unity’s **Universal Render Pipeline** (**URP**), as
    well as how to properly configure it to adapt our scene’s mood with proper lighting
    effects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**照明**是一个复杂的话题，有几种可能的方式来处理它，每种方法都有其优缺点。为了获得最佳的质量和性能，你需要确切地知道你的渲染器如何处理照明，这正是我们将在本章中探讨的内容。我们将讨论在Unity的**通用渲染管线**（**URP**）中如何处理照明，以及如何正确配置它以适应场景的氛围，并使用适当的照明效果。'
- en: 'In this chapter, we will examine the following lighting concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下照明概念：
- en: Applying lighting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用照明
- en: Applying shadows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用阴影
- en: Optimizing lighting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照明优化
- en: At the end of the chapter, we will have properly used the different Unity illumination
    systems like direct lights and lightmapping to reflect a cloudy and rainy night.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将正确使用不同的Unity照明系统，如直接光照和光照贴图，来反映多云和雨夜的景象。
- en: Applying lighting
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用照明
- en: When discussing ways to process lighting in a game, there are two main ways
    we can do so, known as **Forward rendering** and **Deferred rendering**, each
    having some variants. Both handle lighting in a different order, with different
    techniques, requirements, pros, and cons. Forward rendering is usually recommended
    for performance, while Deferred rendering is usually recommended for quality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论在游戏中处理照明的不同方法时，我们有两种主要的方法，称为**前向渲染**和**延迟渲染**，每种方法都有一些变体。它们以不同的顺序、不同的技术、不同的要求和优缺点来处理照明。前向渲染通常推荐用于性能，而延迟渲染通常推荐用于质量。
- en: 'Also, in Unity, the Forward Renderer comes with three modes: **Multi-Pass Forward**,
    which is used in the Built-In Renderer (the old Unity renderer), **Single-Pass
    Forward,** which is used by default in URP, and **Single-Pass Forward+**, the
    only form of Forward that **HDRP** (**High Definition Render Pipeline**) supports,
    as well as an option for URP. We have several modes because each one has different
    characteristics and limitations, making them ideal for different types of games.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Unity中，前向渲染器有三种模式：**多次遍历前向**，用于内置渲染器（旧的Unity渲染器），**单次遍历前向**，默认用于URP，以及**单次遍历前向+**，这是**HDRP**（**高清晰度渲染管线**）支持的唯一形式，也是URP的一个选项。我们有几个模式，因为每个模式都有不同的特性和限制，使它们适用于不同类型的游戏。
- en: Choosing between them depends on the kind of game you are creating and the platform
    you need to run the game on. Your chosen option will change a lot due to the way
    you apply lighting to your scene, so it’s crucial you understand which system
    you are dealing with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪种方法取决于你正在创建的游戏类型以及你需要在该平台上运行游戏。你选择的选项将因你如何将照明应用到场景中而大量改变，因此了解你正在处理哪个系统至关重要。
- en: 'In the next section, we will discuss the following real-time lighting concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论以下实时照明概念：
- en: Discussing lighting methods
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论照明方法
- en: Configuring ambient lighting with skyboxes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用天空盒配置环境照明
- en: Configuring lighting in URP
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URP中配置照明
- en: Let’s start by comparing the previously mentioned lighting methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先比较一下之前提到的照明方法。
- en: Discussing lighting methods
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论照明方法
- en: 'To recap, we’ve mentioned three main ways of processing lighting:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们提到了处理照明的三种主要方法：
- en: Forward rendering (Single Pass)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染（单次遍历）
- en: Forward rendering (Multi-Pass)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染（多次遍历）
- en: Forward+ rendering (Single Pass)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向+渲染（单次遍历）
- en: Deferred rendering
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟渲染
- en: 'Refer to the documentation to see how to enable each of these modes for testing.
    For example, to enable Deferred rendering in URP, use this link: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/rendering/deferred-rendering-path.html#how-to-enable](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/rendering/deferred-rendering-path.html#how-to-enable)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考文档了解如何为测试启用这些模式中的每一个。例如，要在URP中启用延迟渲染，请使用此链接：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/rendering/deferred-rendering-path.html#how-to-enable](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/rendering/deferred-rendering-path.html#how-to-enable)
- en: 'Before we look at the differences between each, let’s talk about the things
    they have in common. Those three renderers start drawing the scene by determining
    which objects can be seen by the camera—that is, the ones that fall inside the
    camera’s frustum (the area the camera sees)—and provide a giant pyramid that can
    be seen when you select the camera:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看它们之间的差异之前，让我们谈谈它们共有的东西。这三个渲染器开始绘制场景，通过确定哪些物体可以被相机看到——即那些落在相机视锥体（相机所看到的区域）内的物体——并提供一个当选择相机时可以看到的巨大金字塔：
- en: '![Image result for unity occlusion culling](img/B21361_12_01_PE.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for unity occlusion culling](img/B21361_12_01_PE.png)'
- en: 'Figure 12.1: Camera rendering only the objects that fall inside its viewing
    area (frustum), culling (or hiding) the ones that are out'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：相机仅渲染其视锥体内的物体，裁剪（或隐藏）那些在外的物体
- en: After that, Unity will order them from the nearest to the camera to the farthest
    (transparent objects are handled a little bit differently, but let’s ignore that
    for now). It’s done like this because it’s more probable that objects nearer to
    the camera will cover most of the camera, so they will occlude others (will block
    other objects from being seen), preventing us from wasting resources calculating
    pixels for the occluded ones.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Unity 将按照从相机最近到最远（透明物体处理方式略有不同，但在此我们先忽略这一点）的顺序对它们进行排序。这样做的原因是因为靠近相机的物体更有可能覆盖大部分相机视野，因此它们会遮挡其他物体（会阻止其他物体被看到），从而避免我们浪费资源去计算被遮挡物体的像素。
- en: Finally, Unity will try to render the objects in that order. This is where differences
    start to arise between lighting methods, so let’s start comparing the two Forward
    rendering variants. For each object, Single-Pass Forward rendering will calculate
    the object’s appearance, including all the lights that are affecting the object,
    in one shot, or what we call a draw call.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Unity 将尝试按照这个顺序渲染物体。这就是光照方法之间开始出现差异的地方，所以让我们开始比较两种前向渲染变体。对于每个物体，单次遍历前向渲染将在一次操作中计算物体的外观，包括所有影响该物体的光源，或者我们称之为绘制调用。
- en: 'A **draw call** is the exact moment when Unity asks the video card to actually
    render the specified object. All the previous work executed by Unity (like, for
    example, setting which shader is going to be used) was just preparation for this
    moment. In the case of the Multi-Pass Forward Renderer, by simplifying a little
    bit of the actual logic, Unity will render the object once per light that affects
    the object; so, if the object is being lit by three lights, Unity will render
    the object three times, meaning that three draw calls will be issued, and three
    calls to the GPU will be made to execute the rendering process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制调用**是 Unity 请求显卡实际渲染指定物体的确切时刻。Unity 所执行的所有先前工作（例如，设置将要使用的着色器）都是为了这一刻做准备。在多遍历前向渲染器的情况下，通过稍微简化实际逻辑，Unity
    将根据影响物体的每个光源渲染物体一次；因此，如果物体被三个光源照亮，Unity 将渲染物体三次，这意味着将发出三个绘制调用，并对 GPU 进行三次调用以执行渲染过程：'
- en: '![](img/B21361_12_02_PE.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21361_12_02_PE.png](img/B21361_12_02_PE.png)'
- en: 'Figure 12.2: Left image, first draw call of a sphere affected by two lights
    in Multi-Pass; middle image, second draw call of the sphere; and right image,
    the combination of both draw calls'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：左图，多遍历中受两个光源影响的球体的第一次绘制调用；中图，球体的第二次绘制调用；右图，两次绘制调用的组合
- en: Now is when you are probably thinking, *“Why should I use Multi-Pass? Single
    Pass is more performant!”* And yes, you are right! Single Pass is much more performant
    than Multi-Pass, meaning our game will run at higher frames per second, though
    here comes the great but. A draw call in a GPU has a limited amount of operations
    that can be executed, so you have a limit to the complexity of the draw call.
    Calculating the appearance of an object and all the lights that affect it is very
    complex, and in order to make it fit in just one draw call, Single Pass executes
    simplified versions of lighting calculations, meaning less lighting quality and
    fewer features. They also have a limit on how many lights can be handled in one
    shot, which, at the time of writing this book, is eight per object; you can configure
    fewer if you want, but the default value is good for us. This sounds like a small
    number, but it’s usually just enough.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能正在想，“为什么我要使用Multi-Pass？Single Pass性能更好！”是的，你是对的！Single Pass比Multi-Pass性能更好，这意味着我们的游戏将以更高的帧率运行，尽管这里有一个大但。GPU中的绘制调用可以执行的操作数量是有限的，所以你有一个绘制调用复杂性的限制。计算一个物体及其影响它的所有光源的外观非常复杂，为了使其适应仅一个绘制调用，Single
    Pass执行了光照计算的简化版本，这意味着光照质量较低，功能较少。它们还对一次可以处理的光源数量有限制，在撰写本书时，每个物体为八个；如果你愿意，可以配置得更少，但默认值对我们来说已经足够好了。这听起来像是一个小数字，但通常已经足够了。
- en: On the other side, Multi-Pass can apply any number of lights you want and can
    execute different logic for each light. Let’s say our object has four lights that
    are affecting it, but there are two lights that are affecting it drastically because
    they are nearer or have higher intensity, while the remaining ones affecting the
    object are just enough to be noticeable. In this scenario, we can render the first
    two lights with higher quality and the remaining ones with cheap calculations—no
    one will be able to tell the difference.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Multi-Pass可以应用你想要的任意数量的光源，并且可以为每个光源执行不同的逻辑。假设我们的物体有四个影响它的光源，但有两个光源因为它们更近或强度更高，对物体的影响非常显著，而剩下的光源对物体的影响只是足够引起注意。在这种情况下，我们可以用更高的质量渲染前两个光源，而剩下的光源则用简单的计算——没有人会注意到区别。
- en: 'In this case, Multi-Pass can calculate the first two lights using **pixel lighting**
    and the remaining ones using **vertex lighting**. The difference is in their names;
    pixel calculates light per object pixel, while vertex calculates lighting per
    object vertex and fills the pixels between these vertexes, thereby interpolating
    information between vertexes. You can clearly see the difference in the following
    images:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Multi-Pass可以使用**像素光照**计算前两个光源，而剩下的光源则使用**顶点光照**。区别在于它们的名称；像素是按对象像素计算光照，而顶点是按对象顶点计算光照，并填充这些顶点之间的像素，从而在顶点之间插值信息。你可以在以下图像中清楚地看到区别：
- en: '![](img/B21361_12_03_PE.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_03_PE.png)'
- en: 'Figure 12.3: Left image, a sphere being rendered with vertex lighting; right
    image, a sphere being rendered with pixel lighting'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：左图，使用顶点光照渲染的球体；右图，使用像素光照渲染的球体
- en: In Single Pass, calculating everything in a single draw call forces you to use
    vertex lighting or pixel lighting; you cannot combine them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Single Pass中，在一个绘制调用中计算所有内容迫使你必须使用顶点光照或像素光照；你不能将它们结合起来。
- en: Finally, we also have Forward+, which is a variant of Single-Pass Forward but
    with an optimization to render a higher number of lights, at the expense of some
    extra processing to allow that. You should choose this if you plan to use Forward
    but you want to support more lights than the limit.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有Forward+，这是Single-Pass Forward的一个变体，但为了渲染更多的光源，需要一些额外的处理。如果你计划使用Forward但想要支持超过限制的光源，你应该选择这个选项。
- en: So, to summarize the differences between Single Pass and Multi-Pass, in Single
    Pass, you have better performance because each object is just drawn once, but
    you are limited in the number of lights that can be applied, while in Multi-Pass,
    you need to render the object several times, but with no limits on the number
    of lights, and you can specify the exact quality you want for each light. There
    are other things to consider, such as the actual cost of a draw call (one draw
    call can be more expensive than two simple ones), and special lighting effects
    such as toon shading, but let’s keep things simple.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了总结单次遍历和多次遍历之间的差异，在单次遍历中，由于每个对象只绘制一次，因此性能更好，但你受到可应用光源数量的限制，而在多次遍历中，你需要渲染对象多次，但光源数量没有限制，并且你可以为每个光源指定你想要的精确质量。还有其他一些需要考虑的事情，例如实际绘制调用的成本（一个绘制调用可能比两个简单的调用更昂贵），以及如卡通着色等特殊光照效果，但让我们保持简单。
- en: Finally, let’s briefly discuss Deferred rendering. Even though we are not going
    to use it, it’s interesting to know why we are not doing that. After determining
    which objects fall inside the frustum and ordering them, Deferred will render
    the objects without any lighting, generating what is called a **G-Buffer**. A
    G-Buffer is a set of several images that contain different information about the
    objects of the scene, such as the colors of their pixels (without lighting), the
    direction of each pixel (known as **normals**), and how far from the camera the
    pixels are.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要讨论一下延迟渲染。即使我们不会使用它，了解为什么我们不这样做也是很有趣的。在确定哪些对象位于视锥体内并对它们进行排序后，延迟渲染将不应用任何光照来渲染对象，生成所谓的
    **G-Buffer**。G-Buffer 是一组包含有关场景中对象不同信息的图像，例如像素的颜色（无光照）、每个像素的方向（称为 **法线**）以及像素与相机之间的距离。
- en: 'You can see a typical example of a G-Buffer in the following image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图像中看到 G-Buffer 的典型示例：
- en: '![](img/B21361_12_04_PE.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_04_PE.png)'
- en: 'Figure 12.4: Left image, plain colors of the objects; middle image, depths
    of each pixel; and right image, normals of the pixels'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：左图，对象的纯色；中图，每个像素的深度；右图，像素的法线
- en: Normals are directions, and the *x*, *y*, and *z* components of the directions
    are encoded in the RGB components of the colors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 法线是方向，方向的 *x*、*y* 和 *z* 分量编码在颜色的 RGB 分量中。
- en: 'After rendering all the objects in the scene, Unity will iterate over all lights
    that can be seen in the camera, thus applying a layer of lighting over the G-Buffer,
    taking information from it to calculate that specific light. After all the lights
    have been processed, you will get the following result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染场景中的所有对象之后，Unity 将遍历相机中可见的所有光源，从而在 G-Buffer 上应用一层光照，从中获取信息来计算特定光源。处理完所有光源后，你将得到以下结果：
- en: '![](img/B21361_12_05_PE.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_05_PE.png)'
- en: 'Figure 12.5: Combination of the three lights that were applied to the G-Buffer
    shown in the previous image'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：对前一个图像中显示的 G-Buffer 应用了三个光源的组合
- en: As you can see, the Deferred part of this method comes from the idea of calculating
    lighting as the last stage of the rendering process. This is better because you
    won’t waste resources calculating lighting from objects that can potentially be
    occluded. If the floor of the image is being rendered first in **Forward** mode,
    the pixels that the rest of the objects are going to occlude were calculated in
    vain. Also, there’s the pro that Deferred just calculates lighting in the exact
    pixels that the light can reach. As an example, if you are using a flashlight,
    Unity will calculate lighting only in the pixels that fall inside the cone of
    the flashlight. The con here is that Deferred is not supported by some relatively
    old video cards and that you can’t calculate lighting with vertex lighting quality,
    so you will need to pay the price of pixel lighting, which is not recommended
    on low-end devices (or even necessary in simple graphics games).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方法中的延迟部分源于将光照计算作为渲染过程的最后阶段的想法。这更好，因为你不会浪费资源去计算可能被遮挡的对象的光照。如果图像的地面首先在
    **前向** 模式下渲染，那么其他对象将要遮挡的像素将被无用地计算。此外，延迟渲染的优点是它只计算光照能够到达的确切像素。例如，如果你使用手电筒，Unity
    将只计算手电筒锥体内的像素的光照。这里的缺点是延迟渲染不支持一些相对较旧的显卡，并且你不能使用顶点光照质量来计算光照，因此你需要付出像素光照的代价，这在低端设备上（甚至在简单的图形游戏中）是不推荐的（甚至可能是必要的）。
- en: So, why are we using URP with Single-Pass Forward (the default value)? Because
    it offers the best balance between performance, quality, and simplicity. In this
    game, we won’t be using too many lights, so we won’t worry about the light number
    limitations of Single Pass. If you need more lights, you can use Deferred or Forward+,
    but consider the extra hardware requirements and the performance cost of not having
    per-vertex lighting options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们使用URP和单次绘制前向（默认值）？因为它在性能、质量和简单性之间提供了最佳平衡。在这个游戏中，我们不会使用太多光照，所以我们不会担心单次绘制的光照数量限制。如果你需要更多光照，可以使用延迟或前向+，但请考虑额外的硬件要求以及没有顶点光照选项的性能成本。
- en: 'So, to recap what we have seen so far, let’s compare the systems:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了总结我们迄今为止所看到的内容，让我们比较一下这些系统：
- en: '**Forward rendering** (**Single Pass**): Renders objects in a single GPU draw
    call with a limited number of lights applied per object (9 at the time of writing
    this). Allows to render lights with either vertex or pixel lighting (the latter
    being more taxing on the GPU). Is the preferred option if your game works with
    the light count limit.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前向渲染**（**单次绘制**）：在单个GPU绘制调用中渲染对象，每个对象应用有限数量的光照（撰写本文时为9个）。允许使用顶点光照或像素光照（后者对GPU的负担更大）。如果你的游戏与光照数量限制相匹配，这是首选选项。'
- en: '**Forward rendering** (**Multi-Pass**): Renders objects with an unlimited number
    of lights but using one additional draw call per per-pixel light. Is not available
    on URP, so we can’t use it in this project.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前向渲染**（**多遍绘制**）：使用每像素光照进行一次额外的绘制调用，但可以渲染无限数量的光照。在URP上不可用，因此我们无法在本项目中使用它。'
- en: '**Forward+ rendering** (**Single Pass**): Bypasses the limitation of Single-Pass
    Foward, allowing the rendering of an unlimited number of lights per object; but
    it doesn’t support vertex lighting. It’s recommended when there’s a need for more
    lights than regular Forward.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前向+渲染**（**单次绘制**）：绕过单次绘制前向的限制，允许每个对象渲染无限数量的光照；但不支持顶点光照。当需要比常规前向更多光照时推荐使用。它。'
- en: '**Deferred rendering**: It renders all objects first, then applies lighting
    on the pixels that each light touches. It’s recommended when using an extensive
    number of lights. Test on the lowest target device whether Forward+ or Deferred
    works better under your device hardware, game’s configuration, and light count.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟渲染**：首先渲染所有对象，然后对每个光照接触的像素应用光照。当使用大量光照时推荐使用。测试在最低目标设备上，Forward+或延迟渲染在你的设备硬件、游戏配置和光照数量下哪个表现更好。'
- en: 'If you want to know more about the different rendering paths and how to activate
    them, check this link: https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/urp-universal-renderer.html#rendering-path-comparison'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于不同的渲染路径以及如何激活它们的信息，请查看此链接：https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/urp-universal-renderer.html#rendering-path-comparison
- en: Now that we have a very basic notion of how URP handles lighting, let’s start
    using it!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对URP如何处理光照有了非常基本的了解，让我们开始使用它吧！
- en: Configuring ambient lighting with skyboxes
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用天空盒配置环境光照
- en: There are different light sources that can affect a scene, such as the sun,
    flashlights, and light bulbs. Those are known as **direct lights**—that is, objects
    that emit light rays. Then, we have **indirect light**, which represents how the
    direct light bounces on other objects, like walls. However, calculating all the
    bounces of all the rays emitted by all the lights is extremely costly in terms
    of performance and requires special hardware that supports ray tracing. The problem
    is that not having indirect light will generate unrealistic results, where you
    can observe places where the sunlight doesn’t reach being completely dark because
    no light is bouncing from other places where light hits.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的光源可以影响场景，例如太阳、手电筒和灯泡。这些被称为**直接光照**——即发射光线的对象。然后，我们有**间接光照**，它表示直接光照如何在其他对象上反弹，如墙壁。然而，计算所有光源发出的所有光线的所有反弹是非常昂贵的，从性能角度来看，需要支持光线追踪的特殊硬件。问题是，没有间接光照将产生不真实的结果，你可以观察到阳光无法到达的地方完全黑暗，因为没有来自光线击中其他地方的光线反弹。
- en: 'In the next image you can see an example of how this could look in a wrongly
    configured scene:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图片中，你可以看到这种配置错误场景的示例：
- en: '![](img/B21361_12_06_PE.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_06_PE.png)'
- en: 'Figure 12.6: Shadows projected on a mountain without ambient lighting'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：无环境光照的山上投影的阴影
- en: If you ever experience this problem, the way to solve it performantly is by
    using approximations of those bounces. These are what we call **ambient light**.
    This represents a base layer of lighting that usually applies a little bit of
    light based on the color of the sky, but you can choose whatever color you want.
    As an example, on a clear night, we can pick a dark blue color to represent the
    tint from the moonlight.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到这个问题，通过使用那些反弹的近似值来解决问题的性能方法是有效的。这些就是我们所说的**环境光**。这代表了一个基础的光照层，通常根据天空的颜色应用一点光，但您可以选择任何您想要的颜色。例如，在晴朗的夜晚，我们可以选择深蓝色来代表月光带来的色调。
- en: 'If you create a new scene in Unity 2023, usually this is done automatically,
    but in cases where it isn’t, or the scene was created through other methods, it
    is convenient to know how to manually trigger this process by doing the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Unity 2023中创建一个新的场景，通常这是自动完成的，但在没有自动完成或通过其他方法创建场景的情况下，了解如何通过以下操作手动触发此过程是方便的：
- en: 'Click on **Window | Rendering | Lighting**. This will open the Scene Lighting
    Settings window:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**窗口 | 渲染 | 光照**。这将打开场景光照设置窗口：
- en: '![](img/B21361_12_07.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_07.png)'
- en: 'Figure 12.7: Lighting Settings location'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：光照设置位置
- en: 'Click the **Generate Lighting** button at the bottom of the window. If you
    haven’t saved the scene so far, a prompt will ask you to save it, which is necessary:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口底部的**生成光照**按钮。如果您到目前为止还没有保存场景，将弹出一个提示要求您保存，这是必要的：
- en: '![](img/B21361_12_08.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_08.png)'
- en: 'Figure 12.8: Generate Lighting button'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：生成光照按钮
- en: 'See the bottom-right part of the Unity window to check the progress calculation
    bar to check when the process has finished:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Unity窗口的右下角，检查进度计算条，以查看何时完成过程：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_12_09.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度低](img/B21361_12_09.png)'
- en: 'Figure 12.9: Lighting generation progress bar'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：光照生成进度条
- en: 'You can now see how completely dark areas are lit by the light being emitted
    by the sky:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以看到完全黑暗的区域是如何被天空发出的光照亮的：
- en: '![](img/B21361_12_10_PE.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_10_PE.png)'
- en: 'Figure 12.10: Shadows with ambient lighting'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：带有环境光照的阴影
- en: Now, by doing this, we have better lighting, but it still looks like a sunny
    day. Remember, we want to have rainy weather. In order to do that, we need to
    change the default sky too so that it’s cloudy. You can do that by downloading
    a **skybox**. The current sky you can see around the scene is just a big cube
    containing textures on each side, and those textures have a special projection
    to prevent us from detecting the edges of the cube.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这样做，我们有了更好的光照，但它仍然看起来像晴天。记住，我们想要的是雨天。为了做到这一点，我们需要更改默认的天空，使其多云。您可以通过下载一个**skybox**来实现这一点。您现在在场景周围看到的当前天空只是一个包含每个面的纹理的大立方体，这些纹理有一个特殊的投影，以防止我们检测到立方体的边缘。
- en: 'We can download six images for each side of the cube and apply them to have
    whatever sky we want, so let’s do that:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为立方体的每一面下载六张图片，并将它们应用到我们想要的任何天空，让我们这样做：
- en: You can download skybox textures from wherever you want, but here, I will choose
    the Asset Store. Open it by going to **Window | Asset Store** and going to the
    Asset Store website.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从任何地方下载skybox纹理，但在这里，我将选择Asset Store。通过访问**窗口 | Asset Store**并进入Asset Store网站来打开它。
- en: 'Look for **Categories | 2D | Textures & Materials | Sky** in the category list
    on the right. Remember that you need to make that window wider if you can’t see
    the category list:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的分类列表中查找**分类 | 2D | 纹理与材质 | 天空**。记住，如果您看不到分类列表，请尝试将窗口变宽：
- en: '![A screenshot of a phone  Description automatically generated with low confidence](img/B21361_12_11_PE.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![手机截图  描述自动生成，置信度低](img/B21361_12_11_PE.png)'
- en: 'Figure 12.11: Textures & Materials'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：纹理与材质
- en: Remember to check the **Free Assets** checkbox in the **Price** options.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在**价格**选项中勾选**免费资源**复选框。
- en: 'Pick any skybox you like for a rainy day. Take into account that there are
    different formats for skyboxes. We are using the six-image format, so check that
    before downloading one. There’s another format called **Cubemap**, which is essentially
    the same, but we will stick with the six-image format as it is the simplest one
    to use and modify. In my case, I have chosen the skybox pack shown in *Figure
    12.12*. Download and import it, as we did in *Chapter 4*, *Seamless Integration:
    Importing and Integrating Assets.*'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择任何适合雨天的一天天空盒。考虑到天空盒有不同的格式。我们使用的是六图像格式，所以在下载之前请检查。还有一种格式叫做**立方体贴图**，本质上与它相同，但我们将继续使用六图像格式，因为它是最简单且易于使用和修改的格式。在我的情况下，我选择了*图12.12*中显示的天空盒包。下载并导入它，就像我们在*第4章*中做的那样，*无缝集成：导入和整合资源*。
- en: '![A screenshot of a cell phone  Description automatically generated with low
    confidence](img/B21361_12_12_PE.png)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![手机截图，自动生成描述，置信度低](img/B21361_12_12_PE.png)'
- en: 'Figure 12.12: Selected skybox set for this book'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.12：为此本书选择的天空盒集
- en: Create a new material by using the **+** icon in the **Project** window and
    selecting **Material**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**项目**窗口中使用**+**图标并选择**材质**来创建一个新的材质。
- en: Set the **Shader** option of that material to **Skybox/6 sided**. Remember that
    the skybox is just a cube, so we can apply a material to change how it looks.
    The skybox shader is prepared to apply the six textures.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该材质的**Shader**选项设置为**Skybox/6面**。记住，天空盒只是一个立方体，因此我们可以应用材质来改变其外观。天空盒着色器已准备好应用六个纹理。
- en: 'Drag the six textures to the **Front**, **Back**, **Left**, **Right**, **Up**,
    and **Down** properties of the material. The six downloaded textures will have
    descriptive names so that you know which textures go where:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将六个纹理拖动到材质的**Front**、**Back**、**Left**、**Right**、**Up**和**Down**属性。六个下载的纹理将具有描述性的名称，以便你知道哪些纹理放在哪里：
- en: '![](img/B21361_12_13.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_13.png)'
- en: 'Figure 12.13: Skybox material settings'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：天空盒材质设置
- en: Drag the material directly into the sky in the Scene view. Be sure you don’t
    drag the material into an object because the material will be applied to it.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质直接拖动到场景视图中的天空上。确保不要将材质拖动到对象上，因为材质将被应用到它上面。
- en: 'Repeat *steps 1* to *4* of the ambient light calculation steps (**Lighting
    Settings** | **Generate Lighting**) to recalculate it based on the new skybox.
    In the following image, you can see the result of my project so far:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复环境光计算步骤的*步骤1*到*4*（**光照设置** | **生成光照**）以根据新的天空盒重新计算它。在以下图像中，你可以看到我项目到目前为止的结果：
- en: '![](img/B21361_12_14_PE.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_14_PE.png)'
- en: 'Figure 12.14: Applied skybox'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：应用的天空盒
- en: Now that we have a good base layer of lighting, we can start adding light objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个良好的光照基础层，我们可以开始添加灯光对象。
- en: Configuring lighting in URP
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在URP中配置光照
- en: 'We have three main types of dynamic lights we can add to our scene:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向场景添加三种主要的动态灯光类型：
- en: '**Directional light**: This is a light that represents the sun. This object
    emits light rays in the direction it is facing, regardless of its position. As
    an example, if you slowly rotate this object, you can generate a day/night cycle:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**：这是一种代表太阳的灯光。该对象以它面对的方向发射光线，无论其位置如何。例如，如果你慢慢旋转这个对象，你可以生成白天/夜晚周期：'
- en: '![A picture containing screenshot, design, graphic design, graphics  Description
    automatically generated](img/B21361_12_15_PE.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计、图形设计、图形的图片，自动生成描述](img/B21361_12_15_PE.png)'
- en: 'Figure 12.15: Directional light results'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：方向光结果
- en: '**Point light**: This light represents a light bulb, which emits rays in an
    omnidirectional way. The difference it has compared to directional lights is that
    its position matters because it’s closer to our objects. Also, because it’s a
    weaker light, the intensity of this light varies according to the distance, so
    its effect has a range—the further the object from the light, the weaker the received
    intensity:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：这种灯光代表一个灯泡，以全向方式发射光线。与方向光相比，它的不同之处在于其位置很重要，因为它更靠近我们的对象。此外，因为它是一种较弱的灯光，所以光强度会根据距离变化，因此其效果有一个范围——物体离光源越远，接收到的强度越弱：'
- en: '![](img/B21361_12_16_PE.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_16_PE.png)'
- en: 'Figure 12.16: Point light results. The yellow circles represent the range of
    the light'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：点光源结果。黄色圆圈代表光的范围
- en: '**Spotlight**: This kind of light represents a light cone, such as the one
    emitted by a flashlight. It behaves similarly to point lights in that its position
    matters and the light intensity decays over a certain distance. But here the direction
    it points to (hence its rotation) is also important, given it will specify where
    to project the light:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**：这种灯光代表一个光锥，例如手电筒发出的光。它在行为上类似于点光源，其位置很重要，光线强度会在一定距离内衰减。但在这里，它指向的方向（因此它的旋转）也很重要，因为它将指定光线投射的位置：'
- en: '![A picture containing screenshot, origami  Description automatically generated](img/B21361_12_17_PE.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、折纸的图片，自动生成的描述](img/B21361_12_17_PE.png)'
- en: 'Figure 12.17: Spotlight results. The yellow cone represents the light area'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：聚光灯效果。黄色锥体代表光照区域
- en: 'So far, we have nice, rainy, ambient lighting, but the only direct light we
    have in the scene, the directional light, isn’t correctly set up; it looks like
    this is the actual weather in our scene, so let’s change that:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了很好的、下雨的、环境照明，但场景中唯一的直接光源，即方向光，设置不正确；这看起来像是场景中的实际天气，所以让我们改变一下：
- en: Select the **Directional Light** object in the **Hierarchy** window and then
    look at the **Inspector** window.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**方向光**对象，然后查看**检查器**窗口。
- en: Click the **Color** property in the **Emission** section to open the Color Picker.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发射**部分的**颜色**属性以打开颜色选择器。
- en: Select a dark gray color to achieve a state in which the sun rays have been
    partially occluded by clouds.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择深灰色以实现太阳光被云层部分遮挡的状态。
- en: 'Set **Shadow Type** to **No Shadows**. Now that we have a cloudy day, the sun
    does not project clear shadows, but we will talk more about shadows in a moment:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**阴影类型**设置为**无阴影**。既然是多云天气，太阳不会投射清晰的阴影，但我们稍后会更多地讨论阴影：
- en: '![](img/B21361_12_18.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_18.png)'
- en: 'Figure 12.18: Soft directional light with no shadows'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：无阴影的柔和方向光
- en: 'Now that the scene is darker, we can add some lights to light up the scene,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景变暗了，我们可以添加一些灯光来照亮场景，如下所示：
- en: Create a spotlight by going to **GameObject | Light | Spotlight**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**游戏对象 | 光 | 聚光灯**来创建一个聚光灯。
- en: Select it. Then, in the **Inspector** window, set **Inner / Output Spot Angle**
    in the **Shape** section to **90** and **120**, which will increase the angle
    of the cone.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它。然后，在**检查器**窗口中，在**形状**部分将**内/输出聚光角度**设置为**90**和**120**，这将增加锥形的角度。
- en: Set **Range** in the **Emission** section to `50`, meaning that the light can
    reach up to 50 meters, decaying along the way.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发射**部分将**范围**设置为`50`，这意味着光线可以达到50米，并在途中衰减。
- en: 'Set **Intensity** in the **Emission** section to `1000`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发射**部分将**强度**设置为`1000`：
- en: '![](img/B21361_12_19.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_19.png)'
- en: 'Figure 12.19: Spotlight settings'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：聚光灯设置
- en: 'Position the light at one corner of your game’s base, pointing it at the center:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将灯光放置在游戏基地的一个角落，指向中心：
- en: '![](img/B21361_12_20_PE.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_20_PE.png)'
- en: 'Figure 12.20: Spotlight placement'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：聚光灯位置
- en: Duplicate that light by selecting it and pressing *Ctrl+D* (*Command+D* on a
    Mac).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择它并按*Ctrl+D*（在Mac上为*Command+D*）来复制该灯光。
- en: 'Put it in the opposite corner of the base:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它放置在基地的对面角落：
- en: '![](img/B21361_12_21_PE.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_21_PE.png)'
- en: 'Figure 12.21: Two spotlight results'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：两个聚光灯效果
- en: You can keep adding lights to the scene but take care that you don’t go too
    far—remember the light limits. Also, you can download some light posts to put
    in where the lights are located to visually justify the origin of the light. Now
    that we have achieved proper lighting, we can talk about shadows.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续向场景添加灯光，但要注意不要过度——记住灯光限制。此外，你可以在灯光所在的位置下载一些灯柱来从视觉上证明光源的起源。现在我们已经实现了适当的照明，我们可以谈谈阴影。
- en: Applying shadows
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用阴影
- en: Maybe you are thinking that we already have shadows in the scene, but actually,
    we don’t. The darker areas of the object, the ones that are not facing the lights,
    don’t have shadows—they are not being lit, and that’s quite different from a shadow.
    In this case, we are referring to the shadows that are projected from one object
    to another—for example, the shadow of the player being projected on the floor,
    or from the mountains to other objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你认为场景中已经有了阴影，但实际上并没有。物体的较暗区域，即不面向灯光的区域，没有阴影——它们没有被照亮，这与阴影有很大不同。在这种情况下，我们指的是从一个物体投射到另一个物体的阴影——例如，玩家投射到地板上的阴影，或者从山脉投射到其他物体上。
- en: 'Shadows can increase the quality of our scene, but they also cost a lot to
    calculate, so we have two options: not using shadows (recommended for low-end
    devices such as mobiles) or finding a balance between performance and quality
    according to our game and the target device.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 影子可以增强我们场景的质量，但它们在计算上也很耗费资源，因此我们有两种选择：不使用影子（推荐用于低端设备，如手机）或者根据我们的游戏和目标设备在性能和质量之间找到一个平衡点。
- en: '![](img/B21361_12_22.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_22.png)'
- en: 'Figure 12.22: Area 1: an area not being lit because it doesn’t face the light.
    Area 2: an area not being lit because it is shadowed by the other cube'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：区域1：一个没有光照的区域，因为它没有面向光源。区域2：一个没有光照的区域，因为它被另一个立方体所遮挡
- en: 'In this section, we are going to discuss the following topics about shadows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下关于影子的主题：
- en: Understanding shadow calculations
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解影子计算
- en: Configuring performant shadows
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置高性能的影子
- en: Let’s start by discussing how Unity calculates shadows.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论Unity如何计算影子。
- en: Understanding shadow calculations
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解影子计算
- en: In game development, it is well-known that shadows are costly in terms of performance,
    but why? An object has a shadow when a light ray hits another object before reaching
    it. In that case, no lighting is applied to that pixel from that light. The problem
    here is the same problem we have with the light that ambient lighting simulates—it
    would be too costly to calculate all possible rays and their collisions. So, again,
    we need an approximation, and here is where shadow maps kick in.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，众所周知，影子在性能方面是昂贵的，但为什么？当一个光束在到达目标物体之前击中另一个物体时，物体就会产生影子。在这种情况下，该光不会对该像素应用任何光照。这里的问题与我们处理环境光照模拟中的光的问题相同——计算所有可能的光线和它们的碰撞将非常昂贵。因此，我们再次需要一个近似值，这就是影子贴图发挥作用的地方。
- en: A **shadow map** is an image that’s rendered from the point of view of the light,
    but instead of drawing the full scene with all the color and lighting calculations,
    it will render all the objects in grayscale, where black means that the pixel
    is very far from the light and whiter means that the pixel is nearer to the light.
    If you think about it, each pixel contains information about where a **ray** of
    light hits. By knowing the position and orientation of the light, you can calculate
    the position that each “ray” hits using the shadow map.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**影子贴图**是从光的角度渲染的图像，但它不会绘制带有所有颜色和光照计算的完整场景，而是将所有物体以灰度渲染，其中黑色表示像素非常远离光源，而更白则表示像素更接近光源。如果你这么想，每个像素都包含有关光线**射线**击中位置的信息。通过了解光源的位置和方向，你可以使用影子贴图计算出每个“射线”击中的位置。'
- en: 'In the following image, you can see the shadow map of our directional light:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，你可以看到我们方向光的影子贴图：
- en: '![A red square object with a black background  Description automatically generated
    with low confidence](img/B21361_12_23_PE.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![一个红色方块物体，背景为黑色  描述由低置信度自动生成](img/B21361_12_23_PE.png)'
- en: 'Figure 12.23: Shadow map generated by the directional light of our scene'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：由场景中的方向光生成的影子贴图
- en: 'In *Chapter 18*, *Performance Wizardry: Optimizing Your Game with Profiler
    Tools*, we will see how to use the Frame Debugger to analyze all draw calls. This
    allows you to see the generation of the shadow maps.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第18章*，*性能魔法：使用Profiler工具优化你的游戏*中，我们将看到如何使用帧调试器分析所有绘制调用。这允许你看到影子贴图的生成。
- en: Each type of light calculates shadow maps slightly differently, especially the
    point light. Since it’s omnidirectional, it needs to render the scene several
    times in all its directions (front, back, left, right, up, and down) in order
    to gather information about all the rays it emits. We won’t talk about this in
    detail here, though, as we could talk about it all day.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每种光线类型在计算影子贴图时略有不同，尤其是点光源。由于它是全方向的，它需要从所有方向（前、后、左、右、上、下）渲染场景多次，以便收集关于它发出的所有光线的信息。不过，我们在这里不会详细讨论这个问题，因为我们可以整天都在讨论它。
- en: 'Now, something important to highlight here is that shadow maps are textures,
    and as such, they have a resolution. The higher the resolution, the more “rays”
    our shadow map calculates. You are probably wondering what a low-resolution shadow
    map looks like when it has only a few rays in it. Take a look at the following
    image to see one:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里需要强调的一个重要问题是，影子贴图是纹理，因此它们具有分辨率。分辨率越高，我们的影子贴图计算的光线就越多。你可能想知道低分辨率影子贴图是什么样子，当它里面只有很少的光线时。看看以下图像以查看一个例子：
- en: '![](img/B21361_12_24_PE.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_24_PE.png)'
- en: 'Figure 12.24: Hard shadows rendered with a low-resolution shadow map'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：使用低分辨率阴影图渲染的硬阴影
- en: 'The problem here is that having fewer rays generates bigger shadow pixels,
    resulting in a pixelated shadow. Here, we have our first configuration to consider:
    what is the ideal resolution for our shadows? You will be tempted to just increase
    it until the shadows look smooth, but of course, that will increase how long it
    will take to calculate it, so it will impact the performance considerably unless
    your target platform can handle it (mobiles definitely can’t). Here, we can use
    the **Soft Shadows** trick, where we can apply a blurring effect over the shadows
    to hide the pixelated edges, as shown in the following image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，射线越少，产生的阴影像素就越大，导致阴影出现像素化。在这里，我们考虑的第一个配置是：我们的阴影的理想分辨率是多少？你可能会想直接增加它，直到阴影看起来平滑，但当然，这将增加计算所需的时间，因此会显著影响性能，除非你的目标平台能够处理它（移动设备肯定不能）。在这里，我们可以使用**软阴影**技巧，在阴影上应用模糊效果以隐藏像素化的边缘，如下面的图像所示：
- en: '![A picture containing screenshot, design, art  Description automatically generated](img/B21361_12_25_PE.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、设计、艺术的图片，自动生成描述](img/B21361_12_25_PE.png)'
- en: 'Figure 12.25: Soft Shadows rendered with a low-resolution shadow map'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：使用低分辨率阴影图渲染的软阴影
- en: Of course, the blurry effect is not free, but combining it with low-resolution
    shadow maps, if you accept its blurry result, can generate a nice balance between
    quality and performance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模糊效果不是免费的，但结合低分辨率阴影图，如果你接受其模糊的结果，可以在质量和性能之间产生良好的平衡。
- en: 'Now, low-resolution shadow maps have another problem, which is called **shadow
    acne**. This is the lighting error you can see in the following image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，低分辨率的阴影图还有一个问题，这被称为**阴影痤疮**。这是你在以下图像中可以看到的照明错误：
- en: '![](img/B21361_12_26_PE.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_26_PE.png)'
- en: 'Figure 12.26: Shadow acne from a low-resolution shadow map'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：低分辨率阴影图产生的阴影痤疮
- en: A low-resolution shadow map generates false positives because it has fewer “rays”
    calculated. The pixels to be shaded between the rays need to interpolate information
    from the nearest ones. The lower the shadow map’s resolution, the larger the gap
    between the rays, which means less precision and more false positives. One solution
    would be to increase the resolution, but again, there will be performance issues
    (as always).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 低分辨率的阴影图产生假阳性，因为它计算出的“射线”较少。需要在射线之间着色的像素需要从最近的像素中插值信息。阴影图的分辨率越低，射线之间的间隙就越大，这意味着精度更低，假阳性更多。一个解决方案是增加分辨率，但同样，会有性能问题（总是如此）。
- en: 'We have some clever solutions to this, such as using **depth bias**. An example
    of this can be seen in the following image:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些巧妙的解决方案，比如使用**深度偏差**。以下图像就是一个例子：
- en: '![A picture containing line, parallel, rectangle, design  Description automatically
    generated](img/B21361_12_27_PE.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![包含线条、平行、矩形、设计的图片，自动生成描述](img/B21361_12_27_PE.png)'
- en: 'Figure 12.27: A false positive between two far “rays.” The highlighted area
    thinks the ray hit an object before reaching it'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27：两个远“射线”之间的假阳性。高亮区域认为射线在到达之前击中了物体
- en: 'The concept of **depth bias** is simple—so simple that it seems like a big
    cheat, and actually, it is, but game development is full of them! To prevent false
    positives, we “push” the rays a little bit further, just enough to make the interpolated
    rays reach the surface being lit:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度偏差**的概念很简单——简单到似乎是一种很大的作弊，实际上确实如此，但游戏开发中充满了这样的技巧！为了防止假阳性，我们将光线稍微推远一点，刚好足够让插值光线达到被照亮的表面：'
- en: '![A picture containing line, parallel, rectangle, design  Description automatically
    generated](img/B21361_12_28_PE.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![包含线条、平行、矩形、设计的图片，自动生成描述](img/B21361_12_28_PE.png)'
- en: 'Figure 12.28: Rays with a depth bias to eliminate false positives'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28：具有深度偏差的光线以消除假阳性
- en: 'Of course, as you are probably expecting, this problem isn’t solved easily
    without having a caveat. Pushing depth generates false negatives in other areas,
    as shown in the following image. It looks like the cube is floating, but actually,
    it is touching the ground—the false negatives generate the illusion that it is
    floating:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如你可能预料的那样，没有一些注意事项，这个问题是不会轻易解决的。增加深度会在其他区域产生假阴性，如下面的图像所示。看起来立方体像是漂浮的，但实际上它是在接触地面——假阴性产生了它漂浮的错觉：
- en: '![](img/B21361_12_29_PE.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_29_PE.png)'
- en: 'Figure 12.29: False negatives due to a high depth bias'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29：由于高深度偏差产生的假阴性
- en: 'Of course, we have a counter trick to this situation known as **normal bias**;
    this method specifically adjusts the object’s mesh by shifting it in the direction
    the object is facing, rather than following the path of the rays. This one is
    a little bit tricky, so we won’t go into too much detail here, but the idea is
    that combining a little bit of depth bias and another bit of normal bias will
    reduce the false positives, but not completely eliminate them. Therefore, we need
    to learn how to live with that and hide these shadow discrepancies by cleverly
    positioning objects:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一种对抗这种情况的技巧，称为**法线偏差**；这种方法特别通过将对象网格在对象面向的方向上移动来调整对象，而不是跟随光线的路径。这个方法有点棘手，所以我们不会在这里过多详细说明，但想法是结合一点深度偏差和一点法线偏差可以减少误报，但不会完全消除它们。因此，我们需要学会如何与之共存，并通过巧妙地定位对象来隐藏这些阴影差异：
- en: '![A close-up of a cube  Description automatically generated with low confidence](img/B21361_12_30_PE.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![一个立方体的特写  描述自动生成，置信度低](img/B21361_12_30_PE.png)'
- en: 'Figure 12.30: Reduced false positives, which is the result of combining depth
    and normal bias'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30：减少了误报，这是结合深度和法线偏差的结果
- en: There are several other aspects that affect how shadow maps work, with one of
    them being the light range. The smaller the light range, the less area the shadows
    will cover. The same shadow map resolution can add more detail to that area, so
    try to reduce the light ranges as much as you can, as we will do in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 影响阴影贴图工作方式的其他几个方面，其中之一是光程。光程越小，阴影覆盖的区域就越小。相同的阴影贴图分辨率可以增加该区域的更多细节，所以尽量减少光程，就像我们在下一节中将要做的那样。
- en: I can imagine your expression right now; yes, lighting is complicated, and we’ve
    only just scratched the surface! But keep your spirits up! After a little trial
    and error fiddling with the settings, you will understand it better. We’ll do
    that in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象你现在的心情；是的，光照很复杂，我们只是刚刚触及表面！但保持你的士气！经过一点尝试和错误地调整设置后，你会更好地理解它。我们将在下一节中这样做。
- en: If you are really interested in learning more about the internals of the shadow
    system, I recommend that you look at the concept of **shadow cascades**, an advanced
    topic about directional lights and shadow map generation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的对了解阴影系统内部结构感兴趣，我建议你看看**阴影级联**的概念，这是一个关于方向光和阴影贴图生成的进阶主题。
- en: Configuring performant shadows
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: 'Because we are targeting mid-end devices, we will try to achieve a good balance
    of quality and performance here, so let’s start enabling shadows just for the
    spotlights. The directional light shadow won’t be that noticeable, and actually,
    a rainy sky doesn’t generate clear shadows, so we will use that as an excuse to
    not calculate those shadows. In order to do this, do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的目标是中端设备，所以我们将尝试在这里实现质量和性能的良好平衡，所以让我们开始只为聚光灯启用阴影。方向光阴影不会那么明显，实际上，雨天不会产生清晰的阴影，所以我们将以此为借口不计算那些阴影。为了做到这一点，请执行以下操作：
- en: 'Select both spotlights by clicking them in the Hierarchy while pressing *Ctrl*
    (*Command* on Mac). This will ensure that any changes made in the Inspector window
    will be applied to both:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中点击两个聚光灯，同时按*Ctrl*（在Mac上为*Command*），这将确保在检查器窗口中进行的任何更改都将应用于两者：
- en: '![A picture containing text, font, screenshot, graphics  Description automatically
    generated](img/B21361_12_31_PE.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图、图形的图片  描述自动生成](img/B21361_12_31_PE.png)'
- en: 'Figure 12.31: Selecting multiple objects'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31：选择多个对象
- en: 'In the Inspector window, set **Shadow Type** in the **Shadows** section to
    **Soft Shadows**. We will be using low-resolution shadow maps here and the soft
    mode can help to hide the pixelated resolution:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中，将**阴影类型**在**阴影**部分设置为**软阴影**。在这里我们将使用低分辨率的阴影贴图，软模式可以帮助隐藏像素化的分辨率：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_12_32_PE.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度低](img/B21361_12_32_PE.png)'
- en: 'Figure 12.32: Soft Shadows setting'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32：软阴影设置
- en: 'Select **Directional light** and set **Shadow Type** to **No Shadows** to prevent
    it from casting shadows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**方向光**并将**阴影类型**设置为**无阴影**以防止其产生阴影：
- en: '![](img/B21361_12_33.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_33.png)'
- en: 'Figure 12.33: No Shadows setting'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33：无阴影设置
- en: Create a cube (**GameObject** | **3D Object** | **Cube**) and place it near
    one of the lights, just to have an object that we can cast shadows on for testing
    purposes.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体（**GameObject** | **3D Object** | **Cube**），并将其放置在灯光附近，以便我们有一个可以用于测试目的投射阴影的对象。
- en: 'Now that we have a base test scenario, let’s fiddle with the shadow map resolution
    settings, preventing shadow acne in the process:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的测试场景，让我们调整阴影图分辨率设置，防止阴影痤疮：
- en: Go to **Edit | Project Settings**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑** | **项目设置**。
- en: 'In the left-hand side list, look for **Graphics** and click it:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中，查找**图形**并单击它：
- en: '![](img/B21361_12_34.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_34.png)'
- en: 'Figure 12.34: Graphics settings'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34：图形设置
- en: 'In the properties that appear after selecting this option, click in the box
    below **Scriptable Render Pipeline Settings**—the one that contains a name. In
    my case, this is **URP-HighFidelity**, but yours may be different if you have
    a different version of Unity:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择此选项后出现的属性中，点击**可脚本渲染管线设置**下面的框——包含名称的那个。在我的情况下，这是**URP-HighFidelity**，但如果您有不同版本的Unity，它可能不同：
- en: '![](img/B21361_12_35.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_35.png)'
- en: 'Figure 12.35: Current Render Pipeline setting'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35：当前渲染管线设置
- en: 'Doing that will highlight an asset in the **Project** window, so be sure that
    the window is visible before selecting it. Select the highlighted asset:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此操作将在**项目**窗口中突出显示一个资产，因此在选择之前请确保窗口是可见的。选择突出显示的资产：
- en: '![](img/B21361_12_36.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_36.png)'
- en: 'Figure 12.36: Current pipeline highlighted'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36：当前管线突出显示
- en: 'This asset has several graphics settings related to how URP will handle its
    rendering, including lighting and shadows. Expand the **Lighting** section to
    reveal its settings:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此资产包含多个与URP如何处理其渲染相关的图形设置，包括光照和阴影。展开**光照**部分以显示其设置：
- en: '![](img/B21361_12_37.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_37.png)'
- en: 'Figure 12.37: Pipeline Lighting Settings'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37：管线光照设置
- en: The **Shadow Atlas Resolution** setting under the **Additional Lights** subsection
    represents the shadow map resolution for all the lights that aren’t the directional
    light (since it’s the main light). Set it to `1024` if it’s not already at that
    value.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加光源**子部分下的**阴影图分辨率**设置表示所有非方向光源的阴影图分辨率（因为它是主光源）。如果它尚未设置为该值，请将其设置为`1024`。
- en: 'Under the **Shadows** section, you can see the **Depth** and **Normal** bias
    settings, but those will affect all lights. Even if right now our directional
    light doesn’t have shadows, we want only to affect additional lights bias values
    as they have a different Shadow Atlas Resolution value compared to the main one
    (directional light). So, instead, select **spotlights** and set **Bias** to **Custom**
    and **Depth** and **Normal Bias** to `0.25` in order to reduce them as much as
    we can before we remove the shadow acne:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**阴影**部分下，您可以查看**深度**和**法线**偏差设置，但它们将影响所有光源。即使现在我们的方向光没有阴影，我们也只想影响额外的光源偏差值，因为它们的阴影图分辨率与主光源（方向光）不同。因此，选择**聚光灯**，并将**偏差**设置为**自定义**，将**深度**和**法线偏差**设置为`0.25`，以便在我们移除阴影痤疮之前尽可能减少它们：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_12_38_PE.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成，置信度低](img/B21361_12_38_PE.png)'
- en: 'Figure 12.38: Bias settings'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38：偏差设置
- en: This isn’t entirely related to shadows, but in the Univeral Rendering Pipeline
    settings asset, you can change the **Per Object Light** limit to increase or reduce
    the number of lights that can affect the object (no more than eight). For now,
    the default is good as is.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这并不完全与阴影相关，但在通用渲染管线设置资产中，您可以更改**每个对象光照**限制以增加或减少可以影响对象的光源数量（不超过八个）。目前，默认设置就很好。
- en: If you followed the shadow cascades tip presented earlier, you can play with
    the **Cascades** value a little bit to enable shadows for directional light to
    note the effect. Remember that those shadow settings only work for directional
    light.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您遵循了之前提供的阴影级联提示，您可以稍微调整**级联**值以启用方向光阴影并注意其效果。请记住，这些阴影设置仅适用于方向光。
- en: We don’t have shadows in **directional light**, but in any other case, consider
    reducing the **Max Distance** value in the **Shadows** section, which will affect
    the directional light shadows range.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**方向光**中没有阴影，但在任何其他情况下，请考虑在**阴影**部分中减少**最大距离**值，这将影响方向光阴影的范围。
- en: Select both spotlights in the Hierarchy and set them so that they have a 50-meter
    **Range**. See how the shadows improve in quality before and after this change.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择两个聚光灯，并将它们的范围设置为50米。看看在这次更改前后阴影的质量是如何提高的。
- en: Remember that those values only work in my case, so try to fiddle with the values
    a little bit to see how that changes the result—you may find a better setup for
    your scene if it was designed differently from mine. Also, remember that not having
    shadows is always an option, so consider that if your game is running low on frames
    per second, also known as FPS (and there isn’t another performance problem lurking).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些值只适用于我的情况，所以试着调整一下这些值，看看它们是如何改变结果的——如果你设计的场景与我的不同，你可能会找到一个更好的设置。此外，记住没有阴影始终是一个选项，所以如果你的游戏每秒帧数较低（也称为FPS）且没有其他性能问题，也请考虑这一点。
- en: You’re probably thinking that that is all we can manage for performance in terms
    of lighting, but luckily, that’s not the case! We have another resource we can
    use to improve it further, known as static lighting.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为在光照性能方面我们只能做到这一步了，但幸运的是，情况并非如此！我们还有另一种资源可以利用来进一步改进它，这就是所谓的静态光照。
- en: Optimizing lighting
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化光照
- en: We mentioned previously that not calculating lighting is good for performance,
    but what about not calculating lights, but still having them? Yes, it sounds too
    good to be true, but it is actually possible (and, of course, tricky). We can
    use a technique called static lighting or baking, which allows us to calculate
    lighting once and use the cached result.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，不计算光照对性能有好处，但如果不计算灯光，但仍然有灯光呢？是的，这听起来太好了，以至于不真实，但实际上是可能的（当然，也很棘手）。我们可以使用一种称为静态光照或烘焙的技术，它允许我们一次性计算光照并使用缓存的计算结果。
- en: 'In this section, we will cover the following concepts related to static lighting:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与静态光照相关的以下概念：
- en: Understanding static lighting
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态光照
- en: Baking lightmaps
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烘焙光照贴图
- en: Applying static lighting to dynamic objects
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将静态光照应用于动态对象
- en: Understanding static lighting
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解静态光照
- en: 'The idea is pretty simple: just do the lighting calculations once, save the
    results, and then use those instead of calculating lighting all the time.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：只需进行一次光照计算，保存结果，然后使用这些结果而不是每次都进行光照计算。
- en: You may be wondering why this isn’t the default technique to use. This is because
    it has some limitations, with the big one being dynamic objects. **Precalculating
    shadows** means that they can’t change once they’ve been calculated, but if an
    object that is casting a shadow is moved, the shadow will still be there. So,
    the main thing to take into account here is that you can’t use this technique
    with moving objects. Instead, you will need to mix **static** or **baked lighting**
    for static objects and **real-time lighting** for dynamic (moving) objects. Also,
    consider that aside from this technique being only valid for static objects, it
    is also only valid for static lights. Again, if a light moves, the precalculated
    data becomes invalid.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么这不是默认的技术。这是因为它有一些限制，最大的限制是动态对象。**预计算阴影**意味着一旦计算完成，它们就不能改变，但如果一个投射阴影的对象被移动，阴影仍然会存在。所以，这里要考虑的主要问题是你不能使用这种技术来处理移动的对象。相反，你需要为静态对象混合**静态**或**烘焙光照**，对于动态（移动）对象则使用**实时光照**。此外，考虑到这种技术只适用于静态对象，它也只适用于静态灯光。再次强调，如果灯光移动，预计算的数据就变得无效了。
- en: 'Another limitation you need to take into account is that precalculated data
    can have a huge impact on memory. That data occupies space in RAM, maybe hundreds
    of MB, so you need to consider if your target platform has enough space. Of course,
    you can reduce the precalculated lighting quality to reduce the size of that data,
    but you need to consider if the loss of quality deteriorates the look and feel
    of your game too much. As with all options regarding optimization, you need to
    balance two factors: performance and quality.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑的另一个限制是，预计算的数据可能会对内存产生巨大影响。这些数据占用RAM空间，可能达到数百MB，因此你需要考虑你的目标平台是否有足够的空间。当然，你可以降低预计算光照的质量以减小数据的大小，但你需要考虑这种质量损失是否会对你的游戏的外观和感觉产生太大的影响。就像所有关于优化的选项一样，你需要平衡两个因素：性能和质量。
- en: We have several kinds of precalculated data in our process, but the most important
    one is what we call **lightmaps**. A lightmap is a texture that contains all the
    shadows and lighting for all the objects in the scene, so when Unity applies the
    precalculated or baked data, it will look at this texture to know which parts
    of the static objects are lit and which aren’t.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的过程中，我们有几种预先计算的数据，但最重要的一个是所谓的**光照贴图**。光照贴图是一种包含场景中所有对象的所有阴影和光照的纹理，因此当Unity应用预先计算或烘焙的数据时，它会查看这个纹理以确定静态对象的哪些部分被照亮，哪些没有被照亮。
- en: 'You can see an example of a lightmap in the following image:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图像中看到一个光照贴图的例子：
- en: '![Image result for lightmap unity](img/B21361_12_39_PE.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for lightmap unity](img/B21361_12_39_PE.png)'
- en: 'Figure 12.39: Left, a scene with no lighting; middle, a lightmap holding precalculated
    data from that scene; and right, the lightmap being applied to the scene'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39：左，没有光照的场景；中，包含该场景预先计算数据的光照贴图；右，光照贴图被应用到场景中
- en: Having lightmaps has its own benefits. The baking process is executed in Unity,
    before the game is shipped to users, so you can spend plenty of time calculating
    stuff that you can’t do at runtime, such as improved accuracy, light bounces,
    light occlusion in corners, and light from emissive objects. However, that can
    also be a problem. Remember, dynamic objects still need to rely on real-time lighting,
    and that lighting will look very different compared to static lighting, so we
    need to tweak them a lot so the user does not notice the difference.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有光照贴图有其自身的优点。烘焙过程在游戏发布给用户之前在Unity中执行，因此你可以花大量时间计算在运行时无法执行的事情，例如提高精度、光照反弹、角落的光照遮挡以及发射物体的光照。然而，这也可能是一个问题。记住，动态对象仍然需要依赖于实时光照，而且与静态光照相比，这种光照看起来会很不同，所以我们需要调整很多，以便用户不会注意到差异。
- en: Now that we have a basic notion of what static lighting is, let’s dive into
    how to use it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对静态光照有了基本的了解，让我们深入了解如何使用它。
- en: Baking lightmaps
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙光照贴图
- en: To use lightmaps, we need to make some preparations regarding the 3D models.
    Remember that meshes have **UVs**, which contain information about which part
    of the texture needs to be applied to each part of the model. Sometimes, to save
    texture memory, you can apply the same piece of texture to different parts. For
    example, in a car’s texture, you wouldn’t have four wheels; you’d just have one,
    and you can apply that same piece of texture to all the wheels. The problem here
    is that static lighting uses textures in the same way, but here, it will apply
    the lightmaps to light the object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用光照贴图，我们需要对3D模型做一些准备工作。记住，网格有**UV**，它包含有关纹理的哪一部分需要应用到模型每个部分的信息。有时，为了节省纹理内存，你可以将同一块纹理应用到不同的部分。例如，在汽车的纹理中，你不会有多达四个轮子；你只有一个，并且你可以将同一块纹理应用到所有的轮子上。这里的问题是静态光照以相同的方式使用纹理，但在这里，它将应用光照贴图来照亮对象。
- en: In the wheel scenario, the problem would be that if one wheel receives shadows,
    all of them will have it, because all the wheels share the same texture space.
    The usual solution is to have a second set of UVs in the model with no texture
    space being shared, just for use with lightmapping.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在轮子场景中，问题可能是如果一个轮子接收到阴影，所有的轮子都会有，因为所有的轮子共享相同的纹理空间。通常的解决方案是在模型中有一组没有共享纹理空间的第二个UV集，专门用于光照贴图。
- en: 'Sometimes, downloaded models are already prepared for lightmapping, and sometimes
    they aren’t, but luckily, Unity has us covered in those scenarios. To be sure
    a model will calculate lightmapping properly, let’s make Unity automatically generate
    the **Lightmapping UVs** by doing the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，下载的模型已经为光照贴图做好了准备，有时则没有，但幸运的是，Unity在这些情况下为我们提供了支持。为了确保模型能够正确计算光照贴图，让我们通过以下步骤让Unity自动生成**光照贴图UV**：
- en: Select the mesh asset (FBX) in the **Project** window.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择网格资产（FBX）。
- en: In the **Model** tab, look for the **Generate Lightmap UVs** checkbox at the
    bottom and check it.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**模型**选项卡中，找到底部的**生成光照贴图UV**复选框并勾选它。
- en: 'Click the **Apply** button at the bottom:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的**应用**按钮：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_12_40_PE.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_12_40_PE.png)'
- en: 'Figure 12.40: Generate Lightmap UVs setting'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.40：生成光照贴图UV设置
- en: Repeat this process for every model. Technically, you can only do this in the
    models where you get artifacts and weird results after baking lightmaps, but for
    now, let’s do this in all the models just in case.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个模型重复此过程。技术上，你只能在烘焙光照贴图后出现伪影和奇怪结果的模型中这样做，但为了以防万一，我们现在就在所有模型中这样做。
- en: 'After preparing the models for being lightmapped, the next step is to tell
    Unity which objects are not going to move. To do so, do the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备模型进行光照贴图后，下一步是告诉Unity哪些对象不会移动。为此，请执行以下操作：
- en: Select the object that won’t move.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不会移动的对象。
- en: 'Check the **Static** checkbox at the top right of the Inspector window:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口右上角勾选**静态**复选框：
- en: '![](img/B21361_12_41.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_41.png)'
- en: 'Figure 12.41: Static checkbox'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.41：静态复选框
- en: Repeat this for every static object (this isn’t necessary for lights; we will
    deal with those later).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个静态对象重复此操作（对于灯光来说这不是必要的；我们稍后会处理这些）。
- en: You can also select a container of several objects, check the **Static** checkbox,
    and click the **Yes, All Children** button in the prompt to apply the checkbox
    to all child objects.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以选择多个对象的容器，勾选**静态**复选框，并在提示中点击**是，所有子对象**按钮，将复选框应用到所有子对象。
- en: 'Consider that you may not want every object, even if it’s static, to be lightmapped,
    because the more objects you lightmap, the more texture size you will require.
    As an example, the terrain could be too large and would consume most of the lightmapping’s
    size. Usually, this is necessary, but in our case, the spotlights are barely touching
    the terrain. Here, we have two options: leave the terrain as dynamic, or better,
    directly tell the spotlights to not affect the terrain since one is only lit by
    ambient lighting and the directional light (which is not casting shadows).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你可能不希望每个对象，即使它是静态的，都被光照贴图，因为光照贴图的对象越多，你需要的纹理大小就越大。例如，地形可能太大，会消耗大部分光照贴图的大小。通常，这是必要的，但在这个案例中，聚光灯几乎接触不到地形。在这里，我们有两种选择：将地形保留为动态的，或者更好的是，直接告诉聚光灯不要影响地形，因为其中一个只受到环境光和方向光（不会投射阴影）的影响。
- en: 'Remember that this is something we can do because of our type of scene; however,
    you may need to use other settings in other scenarios. You can exclude an object
    from both real-time and static lighting calculations by doing the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们之所以能这样做，是因为我们的场景类型；然而，在其他情况下，你可能需要使用其他设置。你可以通过以下方式从实时和静态光照计算中排除一个对象：
- en: Select the object to exclude.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要排除的对象。
- en: 'In the Inspector window, click the **Layer** dropdown and click on **Add Layer…**:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中，点击**层**下拉菜单，然后点击**添加层…**：
- en: '![](img/B21361_12_42_PE.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_42_PE.png)'
- en: 'Figure 12.42: Layer creation button'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.42：创建层按钮
- en: 'Here, you can create a layer, which is a group of objects that are used to
    identify which objects are not going to be affected by lighting. In the **Layers**
    list, look for an empty space and type in any name for those kinds of objects.
    In my case, I will only exclude the terrain, so I have just named it **Terrain**:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以创建一个层，这是一个用于识别哪些对象不会受到光照影响的对象组。在**层**列表中，寻找一个空白区域，并输入任何名称来命名这类对象。在我的案例中，我只排除地形，所以我将其命名为**地形**：
- en: '![](img/B21361_12_43_PE.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_43_PE.png)'
- en: 'Figure 12.43: Layers list'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.43：层列表
- en: 'Once again, select the terrain, go to the **Layer** dropdown, and select the
    layer you created in the previous step. This way, you can specify that this object
    belongs to that group of objects:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择地形，转到**层**下拉菜单，并选择之前步骤中创建的层。这样，你可以指定这个对象属于那一组对象：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_12_44_PE.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B21361_12_44_PE.png)'
- en: 'Figure 12.44: Changing a GameObject’s layer'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.44：更改GameObject的层
- en: 'Select all the spotlights, look for the **Culling Mask** in the **Rendering**
    section in the Inspector window, click it, and uncheck the layer you created previously.
    This way, you can specify that those lights won’t affect that group of objects:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有聚光灯，在检查器窗口的**渲染**部分查找**剔除遮罩**，点击它，取消选中之前创建的层。这样，你可以指定这些灯光不会影响那一组对象：
- en: '![](img/B21361_12_45_PE.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_45_PE.png)'
- en: 'Figure 12.45: Light Culling Mask'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.45：光照剔除遮罩
- en: Now, you can see how those selected lights are not illuminating or applying
    shadows to the terrain.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以看到那些选定的灯光并没有照亮或投射到地形上。
- en: 'Now, it’s time for the lights since the **Static** checkbox won’t work for
    them. For them, we have the following three modes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候设置灯光了，因为**静态**复选框对它们不起作用。对于它们，我们有以下三种模式：
- en: '**Realtime**: A light in Realtime mode will affect all objects, both static
    and dynamic, using real-time lighting, meaning there’s no pre-calculation. This
    is useful for lights that are not static, such as the player’s flashlight, a lamp
    that is moving due to the wind, and so on.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时**：实时模式下的灯光将影响所有对象，无论是静态的还是动态的，使用实时光照，这意味着没有预先计算。这对于不是静态的灯光很有用，例如玩家的手电筒、因风而移动的灯等。'
- en: '**Baked**: The opposite of Realtime, this kind of light will only affect static
    objects with lightmaps. This means that if the player (dynamic) moves under a
    baked light on the street (static), the street will look lit, but the player will
    still be dark and won’t cast any shadows on the street. The idea is to use this
    on lights that won’t affect any dynamic object, or on lights that are barely noticeable
    on them, so that we can increase performance by not calculating them.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙**：实时模式的对立面，这种灯光只会影响带有光照贴图的静态对象。这意味着如果玩家（动态）在街道（静态）上的烘焙灯光下移动，街道看起来会被照亮，但玩家仍然保持黑暗，不会在街道上投下任何阴影。这种想法是用于不会影响任何动态对象的灯光，或者对它们几乎不可见的灯光，这样我们就可以通过不计算它们来提高性能。'
- en: '**Mixed**: This is the preferred mode in case you are not sure which one to
    use. This kind of light will calculate lightmaps for static objects, but will
    also affect dynamic objects, combining its Realtime lighting with the baked one
    (like Realtime lights also do).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：如果你不确定使用哪种模式，这是首选模式。这种灯光将为静态对象计算光照贴图，但也会影响动态对象，将其实时光照与烘焙光照相结合（就像实时灯光也做的那样）。'
- en: In our case, our directional light will only affect the terrain, and because
    we don’t have shadows, applying lighting to it is relatively cheap in URP, so
    we can leave the directional light as Realtime so that it won’t take up any lightmap
    texture area.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们的方向光将只影响地形，而且因为我们没有阴影，在URP中应用光照相对便宜，所以我们可以将方向光保留为实时，这样它就不会占用任何光照贴图纹理区域。
- en: 'Our spotlights are affecting the base, but actually, they are only applying
    lighting to them—we have no shadows because our base is empty. In this case, it
    is preferable to not calculate lightmapping whatsoever. However, for learning
    purposes, I will add a few objects as obstacles to the base to cast some shadows
    and justify the use of lightmapping, as shown in the following image:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聚光灯正在影响基础，但实际上，它们只是在应用光照——我们没有阴影，因为我们的基础是空的。在这种情况下，最好是根本不计算光照贴图。然而，为了学习目的，我将添加一些作为障碍物到基础上的对象，以投射一些阴影并证明使用光照贴图的必要性，如图所示：
- en: '![](img/B21361_12_46_PE.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_46_PE.png)'
- en: 'Figure 12.46: Adding objects to project light'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.46：添加对象以投射光线
- en: 'Here, you can see how the original design of our level changes constantly during
    the development of the game, and that’s something you can’t avoid—bigger parts
    of the game will change over time. Now, we are ready to set up the light modes
    and execute the baking process, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们的关卡原始设计在游戏开发过程中是如何不断变化的，这是你无法避免的——游戏的大部分内容会随着时间的推移而改变。现在，我们准备设置灯光模式并执行烘焙过程，如下所示：
- en: Select the **Directional Light** in the Hierarchy.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择**方向光**。
- en: Set the **Mode** property in the **General** section in the Inspector window
    to **Realtime** (if it’s not already in that mode).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口的**通用**部分将**模式**属性设置为**实时**（如果它还没有处于该模式）。
- en: Select both spotlights.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个聚光灯。
- en: 'Set their render **Mode** to **Mixed**:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们的渲染**模式**设置为**混合**：
- en: '![](img/B21361_12_47_PE.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_47_PE.png)'
- en: 'Figure 12.47: Mixed lighting setting for spotlights; the mode will be Realtime
    for the directional light'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.47：聚光灯的混合光照设置；方向光模式将是实时
- en: Open the **Lighting Settings** window (**Window | Rendering | Lighting**).
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**光照设置**窗口（**窗口 | 渲染 | 光照**）。
- en: 'We want to change some of the settings of the baking process. In order to enable
    the controls for this, click the **New** button. This will create an asset with
    lightmapping settings that can be applied to several scenes in case we want to
    share the same settings multiple times:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要更改烘焙过程的某些设置。为了启用这些控制，点击**新建**按钮。这将创建一个具有光照贴图设置的资产，可以应用于多个场景，以防我们想要多次使用相同的设置：
- en: '![](img/B21361_12_48.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_12_48.png)'
- en: 'Figure 12.48: Creating lighting settings'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.48：创建光照设置
- en: 'Reduce the quality of lightmapping, just to make the process go faster. Just
    to reiterate, the lighting can easily be reduced by using settings such as **Lightmap
    Resolution**, **Direct Samples**, **Indirect Samples**, and **Environment Samples**,
    all of them located under the **Lightmapping Settings** category. In my case,
    I have those settings applied as shown in the following image. Note that even
    reducing those will take time; we have too many objects in the scene due to the
    modular level design:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 降低光照贴图的质量，以便加快处理过程。再次强调，可以通过使用**光照贴图分辨率**、**直接采样**、**间接采样**和**环境采样**等设置来轻松降低照明质量，所有这些设置都位于**光照贴图设置**类别下。在我的情况下，我已经将这些设置应用如下所示。请注意，即使降低这些设置也需要时间；由于模块化关卡设计，场景中对象太多：
- en: '![](img/B21361_12_49.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_49.png)'
- en: 'Figure 12.49: Scene lighting settings'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.49：场景照明设置
- en: Click **Generate Lighting**, which is the same button we used previously to
    generate ambient lighting.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成照明**，这是我们之前用来生成环境照明的相同按钮。
- en: 'Wait for the process to complete. You can do this by checking the progress
    bar at the bottom right of the Unity Editor. Note that this process could take
    even hours in large scenes, so be patient:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待处理完成。您可以通过检查 Unity 编辑器右下角的进度条来完成此操作。请注意，在大型场景中，这个过程可能需要数小时，所以请耐心等待：
- en: '![](img/B21361_12_50_PE.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_50_PE.png)'
- en: 'Figure 12.50: Baking progress bar'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.50：烘焙进度条
- en: 'After the process has completed, you can check the bottom part of the **Lighting
    Settings** window, where you can see how many lightmaps need to be generated.
    We have a maximum lightmap resolution, so we probably need several of them to
    cover the entire scene. Also, it informs us of their size so that we can consider
    their impact in terms of RAM. Finally, you can check out the **Baked Lightmaps**
    section to see them:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理完成后，您可以检查**照明设置**窗口的底部部分，在那里您可以查看需要生成多少光照贴图。我们有一个最大光照贴图分辨率，因此我们可能需要几个来覆盖整个场景。此外，它还会告诉我们它们的大小，以便我们可以考虑它们在内存方面的影响。最后，您可以在**烘焙光照贴图**部分查看它们：
- en: '![](img/B21361_12_51.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_51.png)'
- en: 'Figure 12.51: Generated lightmaps'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.51：生成的光照贴图
- en: 'Now, based on the results, you can move objects, modify light intensities,
    or make whatever correction you would need in order to make the scene look the
    way you want and recalculate the lighting every time you need to. In my case,
    those settings gave me good enough results, which you can see in the following
    image:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据结果，您可以移动对象、修改光照强度，或进行任何必要的校正，以使场景看起来如您所愿，并在需要时重新计算照明。在我的情况下，这些设置给了我足够好的结果，您可以在以下图像中看到：
- en: '![](img/B21361_12_52_PE.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_52_PE.png)'
- en: 'Figure 12.52: Lightmap result'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.52：光照贴图结果
- en: We still have plenty of small settings to touch on, but I will leave you to
    discover those through trial and error or by reading the Unity documentation about
    lightmapping over at [https://docs.unity3d.com/Manual/Lightmappers.html](https://docs.unity3d.com/Manual/Lightmappers.html).
    Reading the Unity manual is a good source of knowledge and I recommend that you
    start using it—any good developer, no matter how experienced, should read the
    manual.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有很多小的设置要讨论，但我将让您通过试错或阅读 Unity 关于光照贴图的文档来发现这些内容，文档可在[https://docs.unity3d.com/Manual/Lightmappers.html](https://docs.unity3d.com/Manual/Lightmappers.html)找到。阅读
    Unity 手册是获取知识的好方法，我建议您开始使用它——无论经验如何丰富，任何优秀的开发者都应该阅读手册。
- en: Applying static lighting to static objects
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将静态照明应用于静态对象
- en: 'When marking objects as static in your scene, you probably figured out that
    all the objects in the scene won’t move, so you probably checked the **static**
    checkbox for everyone. That’s OK, but you should always put a dynamic object into
    the scene to really be sure that everything works OK—no game has totally static
    scenes. Try adding a capsule and moving it around to simulate our player, as shown
    in the following image. If you pay attention to it, you will notice something
    odd—the shadows being generated by the lightmapping process are not being applied
    to our dynamic object:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在场景中将对象标记为静态时，您可能已经发现场景中的所有对象都不会移动，因此您可能为每个人检查了**静态**复选框。这没问题，但您应该始终将一个动态对象放入场景中，以确保一切正常——没有游戏是完全静态的场景。尝试添加一个胶囊并将其移动到周围，以模拟以下图像中的玩家。如果您注意观察，您会注意到一些奇怪的事情——由光照贴图过程生成的阴影没有被应用到我们的动态对象上：
- en: '![](img/B21361_12_53_PE.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_53_PE.png)'
- en: 'Figure 12.53: Dynamic object under a lightmap’s precalculated shadow'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.53：光照贴图预计算阴影下的动态对象
- en: You may be thinking that Mixed Light Mode was supposed to affect both dynamic
    and static objects, and that is exactly what it’s doing. The problem here is that
    everything related to static objects is precalculated into those lightmap textures,
    including the shadows they cast, and because our capsule is dynamic, it wasn’t
    there when the pre-calculation process was executed. So, in this case, because
    the object that cast the shadow was static, its shadow won’t affect any dynamic
    object.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为混合光照模式应该影响动态和静态对象，这正是它所做的事情。问题在于，与静态对象相关的一切，包括它们投射的阴影，都被预先计算到那些光照贴图中，而由于我们的胶囊是动态的，所以在预计算过程中并没有包含在内。因此，在这种情况下，由于投射阴影的对象是静态的，它的阴影不会影响任何动态对象。
- en: Here, we have several solutions. The first would be to change the Static and
    Realtime mixing algorithm to make everything near the camera use Realtime lighting
    and prevent this problem (at least near the focus of attention of the player),
    which will have a big impact on performance. The alternative is to use **Light
    Probes**. When we baked information, we only did that on lightmaps, meaning that
    we have information on lighting just over surfaces, not in empty spaces. Because
    our player is traversing the empty spaces between those surfaces, we don’t know
    exactly how the lighting would look in those spaces, such as the middle of a corridor.
    Light Probes are a set of points in those empty spaces where Unity also pre-calculates
    information, so when some dynamic object passes through the Light Probes, it will
    sample information from them. In the following image, you can see some Light Probes
    that have been applied to our scene. You will notice that the ones that are inside
    shadows are going to be dark, while the ones exposed to light will have a greater
    intensity.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有几种解决方案。第一种是将静态和实时混合算法更改为使相机附近的物体使用实时光照并防止这个问题（至少在玩家注意力的焦点附近），这将大大影响性能。另一种选择是使用**光探针**。当我们烘焙信息时，我们只在光照贴图上做了这件事，这意味着我们只在表面上有关光照的信息，而不是在空旷的空间中。由于我们的玩家正在穿越这些表面之间的空旷空间，我们不知道这些空间中的光照会是什么样子，比如走廊的中间。光探针是一组位于这些空旷空间中的点，Unity也会在这些点上预先计算信息，因此当一些动态对象通过光探针时，它会从它们那里采样信息。在下面的图像中，你可以看到一些已经应用于我们场景的光探针。你会注意到那些处于阴影中的将会变暗，而那些暴露在光中的将会具有更大的强度。
- en: 'This effect will be applied to our dynamic objects:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果将应用于我们的动态对象：
- en: '![](img/B21361_12_54_PE.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_54_PE.png)'
- en: 'Figure 12.54: Spheres representing Light Probes'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.54：代表光探针的球体
- en: 'If you move your object through the scene now, it will react to the shadows,
    as shown in the following two images, where you can see a dynamic object being
    lit outside a baked shadow and being dark inside:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在将你的对象在场景中移动，它将响应阴影，如下面的两张图像所示，你可以看到动态对象在烘焙阴影外被照亮，而在阴影内变暗：
- en: '![](img/B21361_12_55_PE.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_55_PE.png)'
- en: 'Figure 12.55: Dynamic object receiving baked lighting from Light Probes'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.55：动态对象接收来自光探针的烘焙光照
- en: 'In order to create Light Probes, do the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建光探针，请执行以下操作：
- en: Create a group of Light Probes by going to **GameObject | Light | Light Probe
    Group**.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**GameObject | Light | Light Probe Group**创建一个光探针组。
- en: 'Fortunately, we have some guidelines on how to place them. It is recommended
    to place them where the lighting changes, such as inside and outside shadow borders.
    However, that is complicated. The simplest and recommended approach is to just
    drop a grid of Light Probes all over your playable area. To do that, you can simply
    copy and paste the Light Grid Group several times to cover the entire base:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一些关于如何放置它们的指导方针。建议将它们放置在光照变化的地方，比如在阴影的内外。然而，这很复杂。最简单且推荐的方法是将光探针网格覆盖在可玩区域上。为此，你可以简单地多次复制和粘贴光探针组来覆盖整个基础：
- en: '![](img/B21361_12_56_PE.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_56_PE.png)'
- en: 'Figure 12.56: Light Probe grid'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.56：光探针网格
- en: 'Another approach would be to select one group and click the **Edit Light Probes**
    button to enter Light Probe edit mode. This is the last button that appears in
    the button bar at the top-left corner of the scene view after selecting a light
    probe (the one that looks like three connected dots):'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是选择一个组并点击**编辑光探针**按钮进入光探针编辑模式。这是在场景视图中选择光探针（看起来像三个相连的点）后，出现在顶部左侧按钮栏中的最后一个按钮：
- en: '![](img/B21361_12_57.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_12_57.png)'
- en: 'Figure 12.57: Light Probe Group edit button'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.57：光探针组编辑按钮
- en: Click the **Select All** button and then **Duplicate Selected** to duplicate
    all the previously existing probes.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全选**按钮，然后**复制所选**以复制所有之前存在的探头。
- en: Using the translate gizmo, move them next to the previous ones, extending the
    grid in the process. Consider that the nearer the probes are, you more you will
    need to cover the terrain, which will generate more data. However, Light Probes
    data is relatively cheap in terms of performance, so you can have lots of them,
    as seen in *Figure 12.55*.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“平移工具”将它们移到上一个旁边，在这个过程中扩展网格。考虑到探头越近，你需要覆盖的地形就越多，这将生成更多数据。然而，从性能角度来看，光探头数据相对便宜，所以你可以有很多，如*图12.55*所示。
- en: Repeat *steps 4* and *5* until you’ve covered the entire area.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤4*和*步骤5*，直到覆盖整个区域。
- en: Regenerate lighting with the **Generate Lighting** button in **Lighting Settings**.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**光照设置**中的**生成光照**按钮重新生成光照。
- en: With that, you have precalculated lighting on the Light Probes affecting our
    dynamic objects, combining both worlds to get cohesive lighting.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就在光探头上预先计算了灯光，影响我们的动态对象，将两个世界结合起来以获得一致的光照。
- en: 'Lighting is a complex topic; there are even people who work exclusively on
    getting it right and performant for your game. If you want to learn more, there
    are plenty of resources, like the following link: https://blog.unity.com/engine-platform/shedding-light-on-universal-render-pipeline-for-unity-2021-lts'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光是一个复杂的话题；甚至有些人专门从事确保你的游戏中的灯光正确且高效的工作。如果你想了解更多，有很多资源，如下面的链接：https://blog.unity.com/engine-platform/shedding-light-on-universal-render-pipeline-for-unity-2021-lts
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed several lighting topics, such as how Unity calculates
    lights and shadows, how to deal with different light sources such as direct and
    indirect lighting, how to configure shadows, how to bake lighting to optimize
    performance, and how to combine dynamic and static lighting so that the lights
    aren’t disconnected from the world they affect. This was a long chapter, but lighting
    deserves that. It is a complex subject that can improve the look and feel of your
    scene drastically, as well as reduce your performance dramatically. It requires
    a lot of practice, and here, we tried to summarize all the important knowledge
    you will need to start experimenting with it. Be patient with this topic; it is
    easy to get incorrect results, but you are probably just one checkbox away from
    solving it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几个光照话题，例如Unity如何计算灯光和阴影，如何处理不同的光源，如直接和间接照明，如何配置阴影，如何烘焙光照以优化性能，以及如何结合动态和静态光照，以确保灯光不会与它们影响的世界脱节。这是一个很长的章节，但灯光值得这样。它是一个可以极大地改善场景外观和感觉的复杂主题，同时也可以显著降低性能。它需要大量的练习，在这里，我们试图总结所有你需要开始实验的重要知识。对这个主题要有耐心；很容易得到错误的结果，但你可能只需勾选一个复选框就能解决问题。
- en: Now that we have improved all we can in the scene settings, in the next chapter,
    we will apply a final layer of graphic effects using the Unity post-processing
    stack, which will apply full-screen image effects—the ones that will give us that
    cinematic look and feel that all games have nowadays.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尽可能改进了场景设置，在下一章中，我们将使用Unity后处理堆栈应用最终层图形效果，这将应用全屏图像效果——那些能给我们带来如今所有游戏都有的电影般外观和感觉的效果。
- en: Learn more on Discord
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。提问、为其他读者提供解决方案、通过“问我任何问题”的环节与作者聊天，以及更多。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
