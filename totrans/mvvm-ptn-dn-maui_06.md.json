["```cs\npublic void UpdateServings(int servings)\n{\n    var factor = servings / (double)baseServings;\n    DisplayAmount = factor * baseAmount;\n}\n```", "```cs\npublic int NumberOfServings\n{\n    get => _numberOfServings;\n    set\n    {\n        if (SetProperty(ref _numberOfServings, value))\n        {\n            Ingredients.ForEach(\n                i => i.UpdateServings(value));\n        }\n    }\n}\n```", "```cs\n    <VerticalStackLayout\n        Margin=\"0,10\" Spacing=\"10\"\n        BindableLayout.ItemsSource=\"{Binding\n    IngredientsList.Ingredients}\">\n    </VerticalStackLayout>\n    ```", "```cs\n    <VerticalStackLayout ... >\n        <BindableLayout.ItemTemplate>\n            <DataTemplate x:DataType=\n              \"vms:RecipeIngredientViewModel\" >\n            </DataTemplate>\n        </BindableLayout.ItemTemplate>\n    </VerticalStackLayout>\n    ```", "```cs\n    <DataTemplate x:DataType=\n      \"vms:RecipeIngredientViewModel\">\n        <HorizontalStackLayout Spacing=\"5\">\n            <Label\n                FontAttributes=\"Bold\" FontSize=\"16\"\n                Text=\"{Binding IngredientName,\n                  StringFormat='{0}:', Mode=OneTime}\"\n                VerticalOptions=\"Center\" />\n            <Label Text=\"{Binding DisplayAmount,\n    Mode=OneWay}\" VerticalOptions=\"Center\" />\n            <Label\n                Text=\"{Binding Measurement, Mode=OneTime}\"\n                VerticalOptions=\"Center\" />\n        </HorizontalStackLayout>\n    </DataTemplate>\n    ```", "```cs\n<ContentPage.Resources>\n    <DataTemplate x:Key=\"recipeIngredientTemplate\"\n              x:DataType=\"vms:RecipeIngredientViewModel\">\n        ...\n    </DataTemplate>\n</ContentPage.Resources>\n...\n    <VerticalStackLayout\n        Margin=\"0,10\"\n        BindableLayout.ItemsSource=\"{Binding IngredientsList.Ingredients}\"\n        BindableLayout.ItemTemplate=\"{StaticResource\n          recipeIngredientTemplate}\"\n        Spacing=\"10\"/>\n```", "```cs\n    public class InstructionsDataTemplateSelector :\n      DataTemplateSelector\n    {\n        protected override DataTemplate\n          OnSelectTemplate(object item, BindableObject\n            container) { }\n    }\n    ```", "```cs\n    public DataTemplate NoteTemplate { get; set; }\n    public DataTemplate InstructionTemplate { get; set; }\n    ```", "```cs\n    protected override DataTemplate OnSelectTemplate\n      (object item, BindableObject container)\n    {\n        if (item is InstructionViewModel)\n            return InstructionTemplate;\n        else if(item is NoteViewModel)\n            return NoteTemplate;\n        return null;\n    }\n    ```", "```cs\n    <ContentPage.Resources>\n    ...\n        <DataTemplate x:Key=\"instructionTemplate\"\n          x:DataType=\"vms:InstructionViewModel\">\n            <VerticalStackLayout Spacing=\"10\">\n                <Label FontSize=\"20\" Text=\"{Binding Index,\n                 StringFormat='{0:D2}.', Mode=OneTime}\" />\n                <Label Margin=\"10,0\" Text=\"{Binding\n                  Description, Mode=OneTime}\" />\n            </VerticalStackLayout>\n        </DataTemplate>\n    </ContentPage.Resources>\n    ```", "```cs\n    <DataTemplate x:Key=\"noteTemplate\" x:DataType=\n      \"vms:NoteViewModel\">\n        <Grid Margin=\"20,0\" ColumnDefinitions=\"35,*\">\n            <Label\n                FontFamily=\"MaterialIconsRegular\"\n                FontSize=\"20\" Text=\"&#xe873;\"\n                TextColor=\"LightSlateGray\" />\n            <Label\n                Grid.Column=\"1\" FontAttributes=\"Italic\"\n                Text=\"{Binding Note, Mode=OneTime}\"\n                TextColor=\"LightSlateGray\" />\n        </Grid>\n    </DataTemplate>\n    ```", "```cs\n    xmlns:selectors=\"clr-namespace:Recipes\n      .Mobile.TemplateSelectors\"\n    ```", "```cs\n    <selectors:InstructionsDataTemplateSelector\n        x:Key=\"instructionDataTemplateSelector\"\n        InstructionTemplate=\"{StaticResource\n          instructionTemplate}\"\n        NoteTemplate=\"{StaticResource noteTemplate}\" />\n    ```", "```cs\n    <VerticalStackLayout Padding=\"10\">\n        <Label FontAttributes=\"Italic,Bold\"\n            FontSize=\"16\" Text=\"Instructions\" />\n        <VerticalStackLayout\n            Margin=\"0,10\" Spacing=\"10\"\n    BindableLayout.ItemsSource=\"{Binding\n              Instructions}\"\n            BindableLayout.ItemTemplateSelector=\n              \"{StaticResource instruction\n                DataTemplateSelector}\"/>\n    </VerticalStackLayout>\n    Instructions property of our ViewModel to the BindableLayout ItemsSource property. Additionally, by using the StaticResource markup extension and the key we used in the resource dictionary for our DataTemplateSelector, we set the ItemTemplateSelector property. The result is shown in *Figure 6**.2*:\n    ```", "```cs\n<VerticalStackLayout\n    BindableLayout.EmptyView=\"Nothing to see here\"\n    ... >\n```", "```cs\n<VerticalStackLayout\n    ...>\n        <BindableLayout.EmptyView>\n            <Label Text=\"Nothing to see here\"\n                FontAttributes=\"Bold\" />\nEmptyViewTemplate, we can specify a DataTemplate that needs to be shown when the bound collection is empty or null. This means that in this template, you can bind to values on the parent UI element or any other accessible context within the UI hierarchy. This flexibility enables you to create dynamic and context-aware empty views that can display relevant information or provide interactive elements based on the available data context.\nAs we saw earlier, data binding and the `INotifyPropertyChanged` interface allow the UI to stay in sync with the data on ViewModels, ensuring automatic updates. However, when it comes to dynamically adding or removing items from collections, the binding engine alone will not automatically reflect these changes in the UI. To achieve this kind of behavior, we need to explore the `ICollectionChanged` interface.\nThe ICollectionChanged interface\nThe `ICollectionChanged` interface provides a powerful mechanism for notifying the UI about changes in a collection itself, rather than on individual items within the collection. By implementing this interface, a collection can raise events that inform the binding engine and UI elements about structural changes, such as additions, removals, or modifications to the collection itself.\nWhile it is possible to assign an updated list of items to a property on your ViewModel and trigger the `PropertyChanged` event, dynamically changing a collection requires a more optimal approach. By utilizing a collection that implements the `INotifyCollectionChanged` interface, we can achieve more efficient rendering of the UI. Instead of needing to re-render the entire collection on the UI, the binding engine can perform updates in a more optimized manner, resulting in improved performance and responsiveness.\nThe `ICollectionChanged` interface defines the `CollectionChanged` event, which is raised whenever the collection undergoes a structural change. This event provides detailed information about the type of change that occurred, such as whether an item was added, removed, or modified, and the position at which the change occurred. Let’s see what this means in terms of binding modes.\nThe ICollectionChanged interface and binding modes\nTo use this interface as efficiently as possible, it’s very important to understand how different binding modes affect this behavior.\nOneTime binding\nWhen using `OneTime` binding, the UI will perfectly update when items inside the collection change. However, there’s a caveat: if a new instance is assigned to the property holding the collection, this change won’t reflect in the UI. In such cases, instead of assigning a new instance, we need to clear the existing collection and add the new items to it. Importantly, the property setter should not trigger the `NotifyPropertyChanged` event as it’s unnecessary for `OneTime` binding.\nOneWay binding\n`OneWay` binding might offer more flexibility, allowing you to replace the collection with a new instance and reflect this in the UI. In this mode, make sure the property setter calls the `NotifyPropertyChanged` event to update the UI. While `OneWay` binding allows for greater flexibility, replacing an entire collection can be resource-intensive, requiring the UI to re-render the collection. This is especially important to consider when dealing with large datasets. If only a few items change, modifying the existing collection is often more efficient than replacing it.\nBy understanding these subtleties, you can make more informed decisions on what data binding mode to use.\nLet’s put this into action and add some functionality to the *Recipes!* app by leveraging the `ObservableCollection` class.\nUsing the ObservableCollection\nThe `ObservableCollection` class is a specialized collection class provided by .NET that implements the `ICollectionChanged` interface out of the box.\nLet’s enhance the functionality of our *Recipes!* app by introducing a `Shopping List` feature. We want to provide users with the ability to add ingredients from the list of recipe ingredients to a separate `Shopping List`. To achieve this, we will associate a button with each ingredient in the list. When the user taps the button, the corresponding ingredient will be added to an `ObservableCollection` named `ShoppingList`. As a result, the UI will be automatically updated each time an ingredient is added or removed from the list:\n\n1.  Let’s start by adding an additional property, `ShoppingList`, of type `Observable` **Collection<RecipeIngredientViewModel>** to `RecipeDetailViewModel`:\n\n    ```", "```cs\n\n    We are automatically assigning a new instance to this property, which makes perfect sense: the instance of this property will not change as we will be adding and removing items from the collection. As `ObservableCollection` implements the `IObservableCollection` interface, the UI will remain in sync as the `CollectionChanged` event will be triggered when we manipulate the collection.\n\n     2.  Currently, we don’t have functionality for managing items in the `ShoppingList` collection. So, let’s add the following to `RecipeDetailViewModel`:\n\n    ```", "```cs\n\n    The `AddToShoppingList` method will be responsible for adding an instance of `RecipeIngredientViewModel` to the `ShoppingList` collection if the given ViewModel isn’t already in there. The `RemoveFromShoppingList` method, on the other hand, will remove the item from `ShoppingList`.\n\n    For both methods, we’ve also created two corresponding commands, which we need to instantiate in the constructor of `RecipeDetailViewModel`, as shown here:\n\n    ```", "```cs\n\n     3.  Next, add the following XAML to the `VerticalStackLayout` that shows the ingredients of the recipe:\n\n    ```", "```cs\n\n    Below the list of ingredients, we’ve added a label with the text `\"Shopping list\"`, followed by another `VerticalStackLayout`. The `ShoppingList` property is bound to the `BindableLayout.ItemsSource` property. We’ve added an `EmptyView` property that will be shown when no items are on the list.\n\n    The `ItemTemplate`, which will be rendered for each item in `ShoppingList`, will be added in a few steps.\n\n     4.  Let’s add a `Button` to the `ItemTemplate` of the `VerticalStackLayout` showing the ingredients. The `Button`’s `Command` should be bound to the `AddToShoppingListCommand` on the `RecipeDetailViewModel` as shown here:\n\n    ```", "```cs\n\n    The `Button`’s `Command` property is bound to the `AddToShoppingListCommand` on the `RecipeDetailViewModel`. As the `Button`’s `BindingContext` is the current `RecipeIngredientViewModel`, we need to use relative binding to point to the `RecipeDetailViewModel`. `CommandParameter` is data bound by just defining `{ Binding }`. This will bind it to the binding context of the UI element itself, which is the current `RecipeIngredientViewModel`. As a result, the `RecipeIngredientViewModel` instance is passed to the `AddShoppingList` method, allowing us to add it to the `ShoppingList` collection.\n\n     5.  Finally, we can define the `ItemTemplate` of the `ShoppingList` items. We can copy the `DataTemplate` of the `\"Ingredients list\"`. However, we need to update the `Button` to this:\n\n    ```", "```cs\n\nWith everything in place, users can now add ingredients from `\"Ingredients list\"` to `\"Shopping list\"`, from which items can also be removed again. Here’s what it looks like:\n![Figure 6.3: Shopping list](img/B20941_06_03.jpg)\n\nFigure 6.3: Shopping list\nBy using `ObservableCollection` – or any collection that implements `IObservableCollection` – it becomes very easy and efficient to keep a list of objects in sync with the UI.\nDon’t overuse ObservableCollection\nIt is important to use `ObservableCollection` judiciously in your application. This specialized collection should be utilized when the collection itself dynamically changes, such as when items are added or removed, and the UI needs to reflect those changes. However, if the collection is fixed or assigned to a property in its entirety, there is no need to use `ObservableCollection`.\nAs we mentioned earlier, using `BindableLayout` is very easy to use and is perfect for showing small collections. For more advanced scenarios, there is `CollectionView`. Let’s have a look at it!\nWorking with CollectionView\n`CollectionView` is an advanced control specifically designed for efficiently displaying large amounts of data. It offers all the properties available in `BindableLayout`, such as `ItemsSource`, `ItemTemplate`, `ItemTemplateSelector`, `EmptyView`, and `EmptyViewTemplate`. Additionally, `CollectionView` provides a wealth of powerful features, including item grouping, header and footer support, item selection and highlighting, item virtualization, and incremental loading of data as the user scrolls. These features enable you to create highly interactive and engaging user interfaces while efficiently managing and presenting your data. Item virtualization ensures that only the visible items are rendered, optimizing performance and memory usage, especially for large collections.\nOther specialized controls\nAside from `CollectionView`, there are other specialized controls, such as `CarouselView` and `ListView`, for displaying collections in .NET MAUI. These controls also support `ItemsSource` binding and allow you to define an `ItemTemplate` or `DataTemplateSelector`. Each comes with a unique set of features and use cases, but the basic principles of data binding remain similar.\nNow, let’s explore a simple example of using `CollectionView`. In our `RecipesOverviewViewModel`, we expose an `ObservableCollection` of `RecipeListItemViewModel`s called `Recipes`. Each `RecipeListItemViewModel` represents a recipe and contains a subset of properties relevant to displaying it on an overview page, such as the recipe’s ID, title, image, and favorite status. While the recipe’s ID may not be necessary for direct display on the screen, it is valuable for identifying the selected item for navigation purposes or implementing features such as “favoriting” an item from the list. For our app to start on `RecipesOverviewPage`, we need to update the `AppShell.xaml` file, as shown in the following snippet:\n\n```", "```cs\n<CollectionView\n    ItemsSource=\"{Binding Recipes}\">\n    <CollectionView.ItemTemplate>\n        <DataTemplate>\n            ...\n        </DataTemplate>\n    </CollectionView.ItemTemplate>\n</CollectionView>\n```", "```cs\n    public class RatingGroup : List<UserReviewViewModel>\n    {\n        public string Key { get; private set; }\n        public RatingGroup(string key,\n            List<UserReviewViewModel> reviews) :\n              base(reviews)\n        {\n            Key = key;\n        }\n    }\n    ```", "```cs\n    List<RatingGroup> _groupedReviews = new();\n    public List<RatingGroup> GroupedReviews\n    {\n        get => _groupedReviews;\n        private set => SetProperty(ref _groupedReviews,\n          value);\n    }\n    public RecipeRatingsDetailViewModel(...)\n    {\n       ...\n        Reviews = new() { ... };\n        GroupedReviews = Reviews.GroupBy(r =>\n          Math.Round(r.Rating / .5) * .5)\n            .OrderByDescending(g => g.Key)\n            .Select(g => new RatingGroup(g.Key.ToString(),\n              g.ToList()))\n            .ToList();\n    }\n    ```", "```cs\n    <CollectionView\n            IsGrouped=\"True\"\n            ItemsSource=\"{Binding GroupedReviews}\">\n    ...\n    </CollectionView>\n    ```", "```cs\n    <CollectionView.GroupHeaderTemplate>\n        <DataTemplate x:DataType=\"{x:Type\n          vms:RatingGroup}\">\n            <Label\n                Margin=\"0,25,0,0\" FontSize=\"16\"\n                Text=\"{Binding Key, StringFormat='{0}\n                  stars Reviews'}\" />\n        </DataTemplate>\n    </CollectionView.GroupHeaderTemplate>\n    <CollectionView.GroupFooterTemplate>\n        <DataTemplate x:DataType=\"{x:Type\n          vms:RatingGroup}\">\n            <Label FontSize=\"12\" Text=\"{Binding Count,\n              StringFormat='{0} reviews'}\" />\n        </DataTemplate>\n    </CollectionView.GroupFooterTemplate>\n    ```", "```cs\n    public ObservableCollection<object> SelectedReviews \n    { get; } = new();\n    ```", "```cs\n    public RelayCommand ReportReviewsCommand { get; }\n    public RecipeRatingsDetailViewModel()\n    {\n        ...\n        ReportReviewsCommand = new\n            RelayCommand(ReportReviews,\n            () => SelectedReviews.Any());\n    }\n    private void ReportReviews()\n    {\n        var selectedReviews = SelectedReviews\n            .Cast<UserReviewViewModel>().ToList();\n        //do reporting\n        SelectedReviews.Clear();\n    }\n    ```", "```cs\n    public RecipeRatingsDetailViewModel()\n    {\n    .   ...\n        SelectedReviews.CollectionChanged +=\n            SelectedReviews_CollectionChanged;\n    }\n    private void SelectedReviews_CollectionChanged(object?\n      sender, NotifyCollectionChangedEventArgs e)\n    => ReportReviewsCommand.NotifyCanExecuteChanged();\n    ```", "```cs\n    <CollectionView\n        IsGrouped=\"True\"\n        ItemsSource=\"{Binding GroupedReviews}\"\n        SelectedItems=\"{Binding SelectedReviews}\"\n        SelectionMode=\"Multiple\">\n    ```", "```cs\n    <CollectionView\n        ...\n        SelectedItem=\"{Binding SelectedRecipe,\n          Mode=TwoWay}\"\n        SelectionChangedCommand=\"{Binding\n          NavigateToSelectedDetailCommand}\"\n        SelectionMode=\"Single\">\n    ```", "```cs\n    RecipeListItemViewModel? _selectedRecipe;\n    public RecipeListItemViewModel? SelectedRecipe\n    {\n        get => _selectedRecipe;\n        set => SetProperty(ref _selectedRecipe, value);\n    }\n    public AsyncRelayCommand NavigateTo\n      SelectedDetailCommand { get; }\n    ```", "```cs\n    public RecipesOverviewViewModel()\n    {\n    ...\n        NavigateToSelectedDetailCommand = new\n          AsyncRelayCommand(NavigateToSelectedDetail);\n    }\n    ```", "```cs\n    private Task NavigateToSelectedDetail()\n    {\n        if (SelectedRecipe is not null)\n        {\n            //ToDo navigate to selected item\n            SelectedRecipe = null;\n        }\n        return Task.CompletedTask;\n    }\n    ```", "```cs\n    private async Task TryLoadMoreItems()\n    {\n        //Dummy implementation\n        if (Recipes.Count < TotalNumberOfRecipes)\n        {\n            await Task.Delay(250);\n            foreach (var item in items)\n            {\n                Recipes.Add(item);\n            }\n        }\n    }\n    ```", "```cs\n    public AsyncRelayCommand TryLoadMoreItemsCommand \n    { get; }\n    public RecipesOverviewViewModel()\n    {\n        Recipes = new ObservableCollection\n          <RecipeListItemViewModel>(items);\n        TryLoadMoreItemsCommand = new AsyncRelayCommand\n          (TryLoadMoreItems);\n    }\n    ```", "```cs\n    <CollectionView\n        ItemsSource=\"{Binding Recipes}\"\n        RemainingItemsThreshold=\"5\"\n        RemainingItemsThresholdReachedCommand=\"{Binding\n          TryLoadMoreItemsCommand}\"\n        ...>\n    ```", "```cs\n\n```"]