- en: Chapter 1. Threading Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 线程基础
- en: 'In this chapter, we will cover the basic tasks to work with threads in C#.
    You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用 C# 中的线程的基本任务。您将学习以下食谱：
- en: Creating a thread in C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中创建线程
- en: Pausing a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停线程
- en: Making a thread wait
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使线程等待
- en: Aborting a thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止线程
- en: Determining a thread state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定线程状态
- en: Thread priority
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程优先级
- en: Foreground and background threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前台和后台线程
- en: Passing parameters to a thread
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向线程传递参数
- en: Locking with a C# lock keyword
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# lock 关键字进行锁定
- en: Locking with a `Monitor` construct
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Monitor` 构造进行锁定
- en: Handling exceptions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: At some point of time in the past, the common computer had only one computing
    unit and could not execute several computing tasks simultaneously. However, operating
    systems could already work with multiple programs simultaneously, implementing
    the concept of multitasking. To prevent the possibility of one program taking
    control of the CPU forever, causing other applications and the operating system
    itself to hang, the operating systems had to split a physical computing unit across
    a few virtualized processors in some way and give a certain amount of computing
    power to each executing program. Moreover, an operating system must always have
    priority access to the CPU and should be able to prioritize CPU access to different
    programs. A thread is an implementation of this concept. It could be considered
    as a virtual processor that is given to the one specific program and runs it independently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的某个时刻，常见的计算机只有一个计算单元，不能同时执行多个计算任务。然而，操作系统已经能够同时处理多个程序，实现了多任务的概念。为了防止一个程序永远控制
    CPU，导致其他应用程序和操作系统本身挂起，操作系统必须以某种方式将物理计算单元分割成几个虚拟化处理器，并给每个正在执行的程序分配一定量的计算能力。此外，操作系统必须始终具有对
    CPU 的优先访问权，并且应该能够对不同程序进行 CPU 访问的优先级排序。线程是这个概念的实现。它可以被认为是一个分配给特定程序并独立运行的虚拟处理器。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a thread consumes a significant amount of operating system resources.
    Trying to share one physical processor across many threads will lead to a situation
    where an operating system is busy just managing threads instead of running programs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，线程消耗大量的操作系统资源。试图在许多线程之间共享一个物理处理器将导致操作系统忙于仅管理线程而不是运行程序。
- en: Therefore, while it was possible to enhance computer processors, making them
    execute more and more commands per second, working with threads was usually an
    operating system task. There was no sense in trying to compute some tasks in parallel
    on a single-core CPU because it would take more time than running those computations
    sequentially. However, when processors started to have more computing cores, older
    programs could not take advantage of this because they just used one processor
    core.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然可以增强计算机处理器，使其每秒执行更多命令，但通常与线程的交互是操作系统任务。在单核 CPU 上尝试并行计算某些任务是没有意义的，因为这会比顺序运行这些计算花费更多时间。然而，当处理器开始拥有更多计算核心时，旧程序无法利用这一点，因为它们只使用一个处理器核心。
- en: To use a modern processor's computing power effectively, it is very important
    to be able to compose a program in a way that it can use more than one computing
    core, which leads to organizing it as several threads that communicate and synchronize
    with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用现代处理器的计算能力，能够以某种方式编写程序，使其能够使用多个计算核心，这导致将其组织为几个相互通信和同步的线程，这一点非常重要。
- en: The recipes in this chapter focus on performing some very basic operations with
    threads in the C# language. We will cover a thread's life cycle, which includes
    creating, suspending, making a thread wait, and aborting a thread, and then, we
    will go through the basic synchronization techniques.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱专注于使用 C# 语言对线程执行一些非常基本的操作。我们将涵盖线程的生命周期，包括创建、挂起、使线程等待和终止线程，然后，我们将介绍基本同步技术。
- en: Creating a thread in C#
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 中创建线程
- en: Throughout the following recipes, we will use Visual Studio 2015 as the main
    tool to write multithreaded programs in C#. This recipe will show you how to create
    a new C# program and use threads in it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的食谱中，我们将使用 Visual Studio 2015 作为编写 C# 多线程程序的主要工具。本食谱将向您展示如何创建一个新的 C# 程序并在其中使用线程。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A free Visual Studio Community 2015 IDE can be downloaded from the Microsoft
    website and used to run the code samples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 Microsoft 网站下载免费的 Visual Studio Community 2015 IDE 并用于运行代码示例。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found in the `BookSamples\Chapter1\Recipe1`
    directory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此食谱，您需要 Visual Studio 2015。没有其他先决条件。此食谱的源代码位于 `BookSamples\Chapter1\Recipe1`
    目录中。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载此书的示例代码文件。如果您在其他地方购买了此书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以将文件直接通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的 **支持** 选项卡上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **代码下载与勘误表**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **搜索** 框中输入书籍名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买此书的来源。
- en: Click on **Code Download**.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **代码下载**。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，请确保使用最新版本的以下软件解压或提取文件夹：
- en: WinRAR/7-Zip for Windows
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR/7-Zip for Windows
- en: Zipeg/iZip / UnRarX for Mac
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg/iZip / UnRarX for Mac
- en: 7-Zip/PeaZip for Linux
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip/PeaZip for Linux
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to create a new C# program and use threads in it, perform
    the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在 C# 程序中创建新程序并使用线程，请按照以下步骤操作：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: Make sure that the project uses .NET Framework 4.6 or higher; however, the code
    in this chapter will work with previous versions.![How to do it...](img/B05292_01_01.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目使用 .NET Framework 4.6 或更高版本；然而，本章中的代码也可以与之前的版本兼容。![如何操作...](img/B05292_01_01.jpg)
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下 `using` 指令：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program. The output will be something like the following screenshot:![How
    to do it...](img/B05292_01_02.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。输出将类似于以下截图：![如何操作...](img/B05292_01_02.jpg)
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step 1 and 2, we created a simple console application in C# using .Net Framework
    version 4.0\. Then, in step 3, we included the `System.Threading` namespace, which
    contains all the types needed for the program. Then, we used the `using static`
    feature from C# 6.0, which allows us to use the `System.Console` type's static
    methods without specifying the type name.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 和 2 中，我们使用 .Net Framework 版本 4.0 创建了一个简单的 C# 控制台应用程序。然后，在步骤 3 中，我们包含了
    `System.Threading` 命名空间，其中包含程序所需的所有类型。然后，我们使用了 C# 6.0 的 `using static` 功能，这使得我们可以使用
    `System.Console` 类的静态方法而不需要指定类型名称。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An instance of a program that is being executed can be referred to as a process.
    A process consists of one or more threads. This means that when we run a program,
    we always have one main thread that executes the program code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正在执行的程序实例可以称为进程。进程由一个或多个线程组成。这意味着当我们运行程序时，我们始终有一个主线程来执行程序代码。
- en: In step 4, we defined the `PrintNumbers` method, which will be used in both
    the main and newly created threads. Then, in step 5, we created a thread that
    runs `PrintNumbers`. When we construct a thread, an instance of the `ThreadStart`
    or `ParameterizedThreadStart` delegate is passed to the constructor. The C# compiler
    creates this object behind the scenes when we just type the name of the method
    we want to run in a different thread. Then, we start a thread and run `PrintNumbers`
    in the usual manner on the main thread.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 4 中，我们定义了 `PrintNumbers` 方法，该方法将在主线程和新创建的线程中使用。然后，在步骤 5 中，我们创建了一个运行 `PrintNumbers`
    的线程。当我们构造线程时，会将 `ThreadStart` 或 `ParameterizedThreadStart` 委托的实例传递给构造函数。C# 编译器在后台创建此对象，当我们只是输入想要在另一个线程中运行的函数名称时。然后，我们启动一个线程，并在主线程中以常规方式运行
    `PrintNumbers`。
- en: As a result, there will be two ranges of numbers from 1 to 10 randomly crossing
    each other. This illustrates that the `PrintNumbers` method runs simultaneously
    on the main thread and on the other thread.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，将会有两个从1到10的随机交叉的数字范围。这说明了`PrintNumbers`方法在主线程和其他线程上同时运行。
- en: Pausing a thread
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停线程
- en: This recipe will show you how to make a thread wait for some time without wasting
    operating system resources.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向你展示如何使线程等待一段时间而不浪费操作系统资源。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe2`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，你需要 Visual Studio 2015。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter1\Recipe2`中找到。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to make a thread wait without wasting operating system resources,
    perform the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何在不浪费操作系统资源的情况下使线程等待，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program is run, it creates a thread that will execute a code in the
    `PrintNumbersWithDelay` method. Immediately after that, it runs the `PrintNumbers`
    method. The key feature here is adding the `Thread.Sleep` method call to a `PrintNumbersWithDelay`
    method. It causes the thread executing this code to wait a specified amount of
    time (2 seconds in our case) before printing each number. While a thread sleeps,
    it uses as little CPU time as possible. As a result, we will see that the code
    in the `PrintNumbers` method, which usually runs later, will be executed before
    the code in the `PrintNumbersWithDelay` method in a separate thread.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它创建了一个线程，该线程将在`PrintNumbersWithDelay`方法中执行代码。紧接着，它运行`PrintNumbers`方法。这里的关键特性是在`PrintNumbersWithDelay`方法中添加了`Thread.Sleep`方法调用。这会导致执行此代码的线程在打印每个数字之前等待指定的时间（在我们的例子中是2秒）。当线程休眠时，它尽可能少地使用CPU时间。因此，我们将看到通常运行较晚的`PrintNumbers`方法中的代码将在单独的线程中先于`PrintNumbersWithDelay`方法中的代码执行。
- en: Making a thread wait
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使线程等待
- en: This recipe will show you how a program can wait for some computation in another
    thread to complete to use its result later in the code. It is not enough to use
    the `Thread.Sleep` method because we don't know the exact time the computation
    will take.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向你展示程序如何等待另一个线程中的某些计算完成，以便稍后在代码中使用其结果。仅使用`Thread.Sleep`方法是不够的，因为我们不知道计算的确切时间。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe3`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，你需要 Visual Studio 2015。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter1\Recipe3`中找到。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how a program waits for some computation in another thread to
    complete in order to use its result later, perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解程序如何等待另一个线程中的某些计算完成以便稍后使用其结果，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program is run, it runs a long-running thread that prints out numbers
    and waits two seconds before printing each number. But, in the main program, we
    called the `t.Join` method, which allows us to wait for the thread `t` to complete
    working. When it is complete, the main program continues to run. With the help
    of this technique, it is possible to synchronize execution steps between two threads.
    The first one waits until another one is complete and then continues to work.
    While the first thread waits, it is in a `blocked` state (as it is in the previous
    recipe when you call `Thread.Sleep`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它运行一个长时间运行的线程，打印数字并等待两秒钟后再打印每个数字。但是，在主程序中，我们调用了 `t.Join` 方法，这允许我们等待线程
    `t` 完成工作。当它完成时，主程序继续运行。借助这种技术，可以在两个线程之间同步执行步骤。第一个线程会等待另一个线程完成，然后继续工作。当第一个线程等待时，它处于
    `blocked` 状态（就像在之前的菜谱中调用 `Thread.Sleep` 时一样）。
- en: Aborting a thread
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止线程
- en: In this recipe, we will describe how to abort another thread's execution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将描述如何终止另一个线程的执行。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe4`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，你需要 Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter1\Recipe4`
    找到。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to abort another thread''s execution, perform the following
    steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何终止另一个线程的执行，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the static `System.Threading.Thread`, add the following code snippet
    below the `Main` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态 `System.Threading.Thread`，在 `Main` 方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program and a separate number-printing thread run, we wait for
    six seconds and then call a `t.Abort` method on a thread. This injects a `ThreadAbortException`
    method into a thread, causing it to terminate. It is very dangerous, generally
    because this exception can happen at any point and may totally destroy the application.
    In addition, it is not always possible to terminate a thread with this technique.
    The target thread may refuse to abort by handling this exception by calling the
    `Thread.ResetAbort` method. Thus, it is not recommended that you use the `Abort`
    method to close a thread. There are different methods that are preferred, such
    as providing a `CancellationToken` object to cancel a thread execution. This approach
    will be described in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"),
    *Using a Thread Pool*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序和单独的数字打印线程运行时，我们等待六秒钟，然后在线程上调用 `t.Abort` 方法。这会将 `ThreadAbortException` 方法注入到线程中，导致其终止。这非常危险，通常因为这个异常可能在任何时刻发生，可能会完全破坏应用程序。此外，并不总是可以使用这种方法终止线程。目标线程可能会通过调用
    `Thread.ResetAbort` 方法来处理这个异常，从而拒绝终止。因此，不建议使用 `Abort` 方法来关闭线程。有其他更推荐的方法，例如提供一个
    `CancellationToken` 对象来取消线程执行。这种方法将在 [第 3 章](ch03.html "第 3 章。使用线程池") *使用线程池*
    中描述。
- en: Determining a thread state
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定线程状态
- en: This recipe will describe the possible states a thread could have. It is useful
    to get information about whether a thread is started yet or whether it is in a
    blocked state. Note that because a thread runs independently, its state could
    be changed at any time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将描述线程可能具有的可能状态。了解线程是否已启动或是否处于阻塞状态是有用的。请注意，由于线程是独立运行的，其状态可能在任何时候发生变化。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe5`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，你需要 Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter1\Recipe5`
    找到。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to determine a thread state and acquire useful information
    about it, perform the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何确定线程状态并获取有关它的有用信息，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two different threads; one of them
    will be aborted and the other runs successfully. The thread state is located in
    the `ThreadState` property of a `Thread` object, which is a C# enumeration. At
    first, the thread has a `ThreadState.Unstarted` state. Then, we run it and assume
    that for the duration of 30 iterations of a cycle, the thread will change its
    state from `ThreadState.Running` to `ThreadState.WaitSleepJoin`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个不同的线程；其中一个将被终止，而另一个将成功运行。线程状态位于 `Thread` 对象的 `ThreadState` 属性中，这是一个
    C# 枚举。一开始，线程处于 `ThreadState.Unstarted` 状态。然后，我们运行它，并假设在 30 次循环迭代的过程中，线程的状态将从 `ThreadState.Running`
    变为 `ThreadState.WaitSleepJoin`。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that the current `Thread` object is always accessible through the `Thread.CurrentThread`
    static property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当前的 `Thread` 对象始终可以通过 `Thread.CurrentThread` 静态属性访问。
- en: If this does not happen, just increase the number of iterations. Then, we abort
    the first thread and see that now it has a `ThreadState.Aborted` state. It is
    also possible that the program will print out the `ThreadState.AbortRequested`
    state. This illustrates, very well, the complexity of synchronizing two threads.
    Keep in mind that you should not use thread abortion in your programs. I've covered
    it here only to show the corresponding thread state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生这种情况，只需增加迭代次数。然后，我们终止第一个线程，并看到现在它处于 `ThreadState.Aborted` 状态。程序也可能打印出
    `ThreadState.AbortRequested` 状态。这很好地说明了同步两个线程的复杂性。请记住，你不应该在程序中使用线程终止。这里只是为了展示相应的线程状态。
- en: Finally, we can see that our second thread `t2` was completed successfully and
    now has a `ThreadState.Stopped` state. There are several other states, but they
    are partly deprecated and not as useful as those we examined.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到我们的第二个线程 `t2` 成功完成，并且现在处于 `ThreadState.Stopped` 状态。还有其他几种状态，但它们部分已弃用，不如我们检查的那些状态有用。
- en: Thread priority
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程优先级
- en: This recipe will describe the different options for thread priority. Setting
    a thread priority determines how much CPU time a thread will be given.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将描述线程优先级的不同选项。设置线程优先级决定了线程将获得多少 CPU 时间。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe6`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，你需要 Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在 `BookSamples\Chapter1\Recipe6`
    找到。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何完成...
- en: 'To understand the workings of thread priority, perform the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解线程优先级的工作原理，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下 `using` 指令：
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two different threads. The first one,
    `threadOne`, has the highest thread priority `ThreadPriority.Highest`, while the
    second one, that is `threadTwo`, has the lowest `ThreadPriority.Lowest` priority.
    We print out the main thread priority value and then start these two threads on
    all available cores. If we have more than one computing core, we should get an
    initial result within two seconds. The highest priority thread should calculate
    more iterations usually, but both values should be close. However, if there are
    any other programs running that load all the CPU cores, the situation could be
    quite different.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个不同的线程。第一个线程 `threadOne` 具有最高的线程优先级 `ThreadPriority.Highest`，而第二个线程
    `threadTwo` 具有最低的 `ThreadPriority.Lowest` 优先级。我们打印出主线程的优先级值，然后在这些所有可用的核心上启动这两个线程。如果我们有多个计算核心，我们应在两秒内得到一个初始结果。通常，具有最高优先级的线程会计算更多的迭代次数，但这两个值应该很接近。然而，如果有其他程序正在运行并加载所有
    CPU 核心，情况可能会有很大不同。
- en: To simulate this situation, we set up the `ProcessorAffinity` option, instructing
    the operating system to run all our threads on a single CPU core (number 1). Now,
    the results should be very different, and the calculations will take more than
    two seconds. This happens because the CPU core runs mostly the high-priority thread,
    giving the rest of the threads very little time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这种情况，我们设置了 `ProcessorAffinity` 选项，指示操作系统在我们的单个 CPU 核心上（编号 1）运行所有线程。现在，结果应该非常不同，计算将超过两秒钟。这是因为
    CPU 核心主要运行高优先级线程，给其他线程的时间非常少。
- en: Note that this is an illustration of how an operating system works with thread
    prioritization. Usually, you should not write programs relying on this behavior.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个演示操作系统如何与线程优先级协同工作的示例。通常，你不应该编写依赖于这种行为的程序。
- en: Foreground and background threads
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前台和后台线程
- en: This recipe will describe what foreground and background threads are and how
    setting this option affects the program's behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述前台和后台线程是什么，以及设置此选项如何影响程序的行为。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe7`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter1\Recipe7`
    中找到。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the effect of foreground and background threads on a program,
    perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解前台和后台线程对程序的影响，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下 `using` 指令：
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two different threads. By default,
    a thread that we create explicitly is a foreground thread. To create a background
    thread, we manually set the `IsBackground` property of the `threadTwo` object
    to `true`. We configure these threads in a way that the first one will be completed
    faster, and then we run the program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个不同的线程。默认情况下，我们显式创建的线程是前台线程。为了创建后台线程，我们手动将 `threadTwo` 对象的 `IsBackground`
    属性设置为 `true`。我们配置这些线程的方式是，第一个线程将更快完成，然后我们运行程序。
- en: 'After the first thread is complete, the program shuts down and the background
    thread is terminated. This is the main difference between the two: a process waits
    for all the foreground threads to complete before finishing the work, but if it
    has background threads, they just shut down.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个线程完成之后，程序将关闭，后台线程将被终止。这是两者之间的主要区别：一个进程在完成工作之前会等待所有前台线程完成，但如果它有后台线程，它们只需关闭即可。
- en: It is also important to mention that if a program defines a foreground thread
    that does not get completed; the main program does not end properly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，如果一个程序定义了一个未完成的前台线程，主程序将无法正确结束。
- en: Passing parameters to a thread
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向线程传递参数
- en: This recipe will describe how to provide code that we run in another thread
    with the required data. We will go through the different ways to fulfill this
    task and review common mistakes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何为我们在另一个线程中运行的代码提供所需的数据。我们将探讨完成此任务的不同方法，并回顾常见的错误。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe8`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter1\Recipe8`
    中找到。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to pass parameters to a thread, perform the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何向线程传递参数，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下 `using` 指令：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE22]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE23]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it first creates an object of the `ThreadSample`
    class, providing it with a number of iterations. Then, we start a thread with
    the object's `CountNumbers` method. This method runs in another thread, but it
    uses the number `10`, which is the value that we passed to the object's constructor.
    Therefore, we just passed this number of iterations to another thread in the same
    indirect way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它首先创建一个`ThreadSample`类的对象，向它提供一个迭代次数。然后，我们通过对象的`CountNumbers`方法启动一个线程。这个方法在另一个线程中运行，但它使用数字`10`，这是我们传递给对象构造函数的值。因此，我们只是以相同的方式间接地将这个迭代次数传递给另一个线程。
- en: There's more…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Another way to pass data is to use the `Thread.Start` method by accepting an
    object that can be passed to another thread. To work this way, a method that we
    started in another thread must accept one single parameter of the type `object`.
    This option is illustrated by creating a `threadTwo` thread. We pass `8` as an
    object to the `Count` method, where it is cast to an `integer` type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种传递数据的方式是使用`Thread.Start`方法，通过接受可以传递给另一个线程的对象。为了这样工作，我们在另一个线程中启动的方法必须接受一个类型为`object`的单个参数。这个选项通过创建一个`threadTwo`线程来展示。我们将`8`作为对象传递给`Count`方法，在那里它被转换为`integer`类型。
- en: The next option involves the use of lambda expressions. A lambda expression
    defines a method that does not belong to any class. We create such a method that
    invokes another method with the arguments needed and start it in another thread.
    When we start the `threadThree` thread, it prints out 12 numbers, which are exactly
    the numbers we passed to it via the lambda expression.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项涉及到lambda表达式的使用。lambda表达式定义了一个不属于任何类的方法。我们创建这样的方法，它调用另一个方法并传递所需的参数，然后在另一个线程中启动它。当我们启动`threadThree`线程时，它打印出12个数字，这正是我们通过lambda表达式传递给它的数字。
- en: The use of lambda expressions involves another C# construct named `closure`.
    When we use any local variable in a lambda expression, C# generates a class and
    makes this variable a property of this class. So, actually, we do the same thing
    as in the `threadOne` thread, but we do not define the class ourselves; the C#
    compiler does this automatically.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式涉及到另一个名为`closure`的C#结构。当我们在一个lambda表达式中使用任何局部变量时，C#会生成一个类，并将这个变量作为这个类的属性。所以，实际上，我们做的和在`threadOne`线程中做的是同一件事，但我们不是自己定义这个类；C#编译器会自动完成这个操作。
- en: This could lead to several problems; for example, if we use the same variable
    from several lambdas, they will actually share this variable value. This is illustrated
    by the previous example where, when we start `threadFour` and `threadFive`, they
    both print `20` because the variable was changed to hold the value `20` before
    both threads were started.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致几个问题；例如，如果我们从几个lambda表达式中使用相同的变量，它们实际上会共享这个变量的值。这在前面的例子中得到了说明，当我们启动`threadFour`和`threadFive`时，它们都打印出`20`，因为变量在两个线程启动之前被更改为保留`20`的值。
- en: Locking with a C# lock keyword
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C# lock关键字进行锁定
- en: This recipe will describe how to ensure that when one thread uses some resource,
    another does not simultaneously use it. We will see why this is needed and what
    the thread safety concept is all about.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将描述如何确保当一个线程使用某些资源时，另一个线程不会同时使用它。我们将看到为什么这是必要的，以及线程安全概念是什么。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe9`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，你需要Visual Studio 2015。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter1\Recipe9`找到。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to use the C# lock keyword, perform the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使用C#的lock关键字，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE24]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE25]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE26]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it first creates an object of the `Counter` class.
    This class defines a simple counter that can be incremented and decremented. Then,
    we start three threads that share the same counter instance and perform an increment
    and decrement in a cycle. This leads to nondeterministic results. If we run the
    program several times, it will print out several different counter values. It
    could be `0`, but mostly won't be.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它首先创建一个`Counter`类的对象。这个类定义了一个简单的计数器，它可以增加和减少。然后，我们启动三个线程，它们共享同一个计数器实例，并在循环中进行增加和减少操作。这会导致非确定性的结果。如果我们运行程序几次，它将打印出几个不同的计数器值。可能是`0`，但大多数情况下不会是。
- en: This happens because the `Counter` class is not thread-safe. When several threads
    access the counter at the same time, the first thread gets the counter value `10`
    and increments it to `11`. Then, a second thread gets the value `11` and increments
    it to `12`. The first thread gets the counter value `12`, but before a decrement
    takes place, a second thread gets the counter value `12` as well. Then, the first
    thread decrements `12` to `11` and saves it into the counter, and the second thread
    simultaneously does the same. As a result, we have two increments and only one
    decrement, which is obviously not right. This kind of a situation is called a
    race condition and is a very common cause of errors in a multithreaded environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Counter`类不是线程安全的。当多个线程同时访问计数器时，第一个线程获取计数器的值`10`并将其增加到`11`。然后，第二个线程获取值`11`并将其增加到`12`。第一个线程获取计数器的值`12`，但在减量发生之前，第二个线程也获取了计数器的值`12`。然后，第一个线程将`12`减到`11`并保存到计数器中，而第二个线程同时做同样的操作。结果是我们有两个增加操作和一个减少操作，这显然是不正确的。这种情况被称为竞争条件，是多线程环境中错误的一个非常常见原因。
- en: To make sure that this does not happen, we must ensure that while one thread
    works with the counter, all other threads wait until the first one finishes the
    work. We can use the `lock` keyword to achieve this kind of behavior. If we lock
    an object, all the other threads that require an access to this object will wait
    in a blocked state until it is unlocked. This could be a serious performance issue
    and later, in [Chapter 2](ch02.html "Chapter 2. Thread Synchronization"), *Thread
    Synchronization*, you will learn more about this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这种情况不会发生，我们必须确保当一个线程正在与计数器一起工作时，所有其他线程都等待直到第一个线程完成工作。我们可以使用`lock`关键字来实现这种行为。如果我们锁定一个对象，所有需要访问这个对象的其他线程都将等待在阻塞状态，直到它被解锁。这可能会成为一个严重的性能问题，稍后，在[第2章](ch02.html
    "第2章。线程同步")中，你将学习更多关于这个内容。
- en: Locking with a Monitor construct
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Monitor构造函数进行锁定
- en: This recipe illustrates another common multithreaded error called a deadlock.
    Since a deadlock will cause a program to stop working, the first piece in this
    example is a new `Monitor` construct that allows us to avoid a deadlock. Then,
    the previously described `lock` keyword is used to get a deadlock.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了另一种常见的多线程错误，称为死锁。由于死锁会导致程序停止工作，这个例子中的第一个部分是一个新的`Monitor`构造函数，它允许我们避免死锁。然后，使用之前描述的`lock`关键字来引发死锁。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe10`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，你需要Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在`BookSamples\Chapter1\Recipe10`找到。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To understand the multithreaded error deadlock, perform the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解多线程错误死锁，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE28]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE29]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the program.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start with the `LockTooMuch` method. In this method, we just lock the
    first object, wait for a second, and then lock the second object. Then, we start
    this method in another thread and try to lock the second object and then the first
    object from the main thread.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`LockTooMuch`方法开始。在这个方法中，我们只锁定第一个对象，等待一秒钟，然后锁定第二个对象。然后，我们在另一个线程中启动这个方法，并尝试从主线程锁定第二个对象，然后是第一个对象。
- en: If we use the `lock` keyword like in the second part of this demo, there will
    be a deadlock. The first thread holds a `lock` on the `lock1` object and waits
    while the `lock2` object gets free; the main thread holds a `lock` on the `lock2`
    object and waits for the `lock1` object to become free, which will never happen
    in this situation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像在这个演示的第二部分中那样使用`lock`关键字，将会出现死锁。第一个线程持有`lock1`对象的`lock`，等待`lock2`对象变得空闲；主线程持有`lock2`对象的`lock`，等待`lock1`对象变得空闲，但在这个情况下永远不会发生。
- en: 'Actually, the `lock` keyword is syntactic sugar for the `Monitor` class usage.
    If we were to disassemble code with `lock`, we would see that it turns into the
    following code snippet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`lock`关键字是`Monitor`类使用的语法糖。如果我们使用`lock`反汇编代码，我们会看到它变成了以下代码片段：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Therefore, we can use the `Monitor` class directly; it has the `TryEnter` method,
    which accepts a timeout parameter and returns `false` if this timeout parameter
    expires before we can acquire the resource protected by `lock`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以直接使用`Monitor`类；它有一个`TryEnter`方法，该方法接受一个超时参数，如果在我们可以获取由`lock`保护的资源之前超时参数过期，则返回`false`。
- en: Handling exceptions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: This recipe will describe how to handle exceptions in other threads properly.
    It is very important to always place a `try/catch` block inside the thread because
    it is not possible to catch an exception outside a thread's code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述如何正确处理其他线程中的异常。始终在线程内部放置`try/catch`块非常重要，因为不可能在线程代码外部捕获异常。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe11`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter1\Recipe11`中找到。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the handling of exceptions in other threads, perform the following
    steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解在其他线程中处理异常，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE31]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE32]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE33]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the program.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two threads that will throw an exception.
    One of these threads handles an exception, while the other does not. You can see
    that the second exception is not caught by a `try/catch` block around the code
    that starts the thread. So, if you work with threads directly, the general rule
    is to not throw an exception from a thread, but to use a `try/catch` block inside
    a thread code instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个将抛出异常的线程。其中一个线程处理异常，而另一个没有。你可以看到第二个异常没有被代码启动部分的`try/catch`块捕获。所以，如果你直接与线程工作，一般规则是不要从线程中抛出异常，而是在线程代码内部使用`try/catch`块。
- en: 'In the older versions of .NET Framework (1.0 and 1.1), this behavior was different
    and uncaught exceptions did not force an application shutdown. It is possible
    to use this policy by adding an application configuration file (such as `app.config`)
    that contains the following code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework的旧版本（1.0和1.1）中，这种行为是不同的，未捕获的异常不会强制应用程序关闭。可以通过添加包含以下代码片段的应用程序配置文件（例如`app.config`）来使用此策略：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
