- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: Welcome to the first chapter in which you’ll start your amazing adventure with
    data structures and algorithms in the context of the **C# programming language**.
    First, we’ll provide a short introduction to this language. You will get to know
    how broad its possibilities are, in how many scenarios you can apply this language,
    as well as some basic constructions that you can use. This isn’t a C# course,
    so we won't be presenting various features one by one, and only a brief description
    will be provided.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第一章，在这里你将开始一段令人惊叹的旅程，学习在**C#编程语言**背景下数据结构和算法。首先，我们将对这个语言进行简要介绍。你将了解到它的可能性有多么广泛，你可以在多少场景下应用这种语言，以及你可以使用的一些基本构造。这不是一个C#课程，因此我们不会逐一介绍其各种特性，而只会提供简要的描述。
- en: The remaining part of this chapter is dedicated to **data types**, both built-in
    and user-defined, which you can use in your applications. First, you will learn
    what the difference is between value and reference types. Then, you will go through
    various available data types, starting with value types. Here, we will cover integral
    numeric types, floating-point numeric types, Boolean types, Unicode characters,
    constants, enumerations, value tuples, struct types, and nullable value types.
    Finally, we’ll cover reference types, including object and string types, as well
    as classes, records, interfaces, and delegates, together with dynamic and nullable
    reference types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将致力于**数据类型**，包括内置和用户定义的数据类型，你可以在你的应用程序中使用。首先，你将了解值类型和引用类型之间的区别。然后，你将了解各种可用的数据类型，从值类型开始。在这里，我们将涵盖整数数值类型、浮点数值类型、布尔类型、Unicode字符、常量、枚举、值元组、结构类型和可空值类型。最后，我们将涵盖引用类型，包括对象和字符串类型，以及类、记录、接口和委托，以及动态和可空引用类型。
- en: As you can see, you have quite a long journey before you. However, if you get
    to know the basics well, it will be much easier for you to get the most out of
    the content presented in the remainder of this book. I, as the author, am keeping
    my fingers crossed for you – good luck!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你面前还有很长的路要走。然而，如果你能很好地掌握基础知识，那么你将更容易从本书剩余部分的内容中获得最大收益。作为作者，我在为你祈祷——祝你好运！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: C# as a programming language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种编程语言，C#
- en: .NET-based console applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于.NET的控制台应用程序
- en: The division of data types between value and reference types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的数据类型划分
- en: Value types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型
- en: Reference types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: C# as a programming language
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为一种编程语言，C#
- en: As a developer, you have probably heard about many programming languages, including
    **C#**, **Java**, **C++**, **C**, **PHP**, and **Ruby**. In all of them, you can
    use various data structures, as well as implement algorithms, to solve both basic
    and complex problems. However, each language has a specificity that’s visible
    while implementing data structures and accompanying algorithms. As mentioned previously,
    this book only focuses on the C# programming language. This is also the main topic
    of this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你可能已经听说过许多编程语言，包括**C#**、**Java**、**C++**、**C**、**PHP**和**Ruby**。在所有这些语言中，你都可以使用各种数据结构，并实现算法来解决基本和复杂的问题。然而，每种语言在实现数据结构和相应的算法时都有其独特性。如前所述，这本书只关注C#编程语言。这也是本节的主要内容。
- en: The C# language, pronounced *C sharp*, is a **modern, general-purpose, strongly
    typed, and object-oriented programming language that can be used while developing
    a wide range of applications**, such as web, mobile, desktop, distributed, and
    embedded solutions, as well as even games! It cooperates with various additional
    technologies and platforms, including **ASP.NET Core**, **XAML**, and **Unity**.
    Therefore, when you learn the C# language, as well as get to know more about data
    structures and algorithms in the context of this programming language, you can
    use such skills to create more than one particular type of software. What’s more,
    even if you decide to change your primary programming language to another, your
    knowledge regarding data structures and algorithms will still be useful. You might
    be wondering, *how is this possible?* The answer turns out to be very simple –
    you will understand how various data structures work, how you can implement them,
    as well as how you can apply them to solve various problems with specialized algorithms.
    But let’s go back to the C# language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言，发音为*C sharp*，是一种**现代、通用、强类型和面向对象的编程语言，可用于开发各种应用程序**，例如Web、移动、桌面、分布式和嵌入式解决方案，甚至游戏！它与各种附加技术和平台协同工作，包括**ASP.NET
    Core**、**XAML**和**Unity**。因此，当你学习C#语言，并在此编程语言的背景下了解更多关于数据结构和算法的知识时，你可以使用这些技能来创建多种类型的软件。更重要的是，即使你决定将你的主要编程语言更改为另一种，你对数据结构和算法的知识仍然有用。你可能想知道，*这是如何可能的？*
    答案出乎意料地简单——你将理解各种数据结构是如何工作的，如何实现它们，以及如何将它们应用于使用专用算法解决各种问题。但让我们回到C#语言。
- en: The current version of the language is **C# 12**. It is worth mentioning its
    interesting history in terms of various versions of the language (including 2.0,
    3.0, 5.0, and 8.0) in which new features were added to increase language possibilities.
    When you take a look at the release notes for particular versions, you will see
    how the language is being improved and expanded over time to be a powerful and
    convenient solution for developers. New features are pretty awesome and can significantly
    simplify your work and allow you to refactor the code so that it’s shorter, as
    well as easier to understand and maintain. That’s great work that’s been done
    by the team developing C# that you can now benefit from while writing your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当前语言的版本是**C# 12**。值得提及的是，它在各种语言版本（包括2.0、3.0、5.0和8.0）中的有趣历史，在这些版本中，新功能被添加以增加语言的可能性。当你查看特定版本的发布说明时，你会看到语言是如何随着时间的推移而不断改进和扩展，成为一个强大且方便的解决方案，供开发者使用。新功能非常出色，可以显著简化你的工作，并允许你重构代码，使其更短，同时更容易理解和维护。这是C#开发团队所做的一项出色工作，你现在可以在编写代码时从中受益。
- en: The syntax of the C# programming language is similar to other languages, such
    as Java or C++. For this reason, if you know such languages, you should easily
    be able to understand the code written in C#. As an example, similarly as in the
    languages mentioned previously, the code consists of statements that end with
    semicolons (`;`). The curly brackets, namely `{` and `}`, are used to group statements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C#编程语言的语法与其他语言类似，例如Java或C++。因此，如果你了解这些语言，你应该能够轻松理解用C#编写的代码。例如，与之前提到的语言类似，代码由以分号（`;`）结尾的语句组成。花括号，即`{`和`}`，用于分组语句。
- en: 'There are a few categories of statements, including the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种语句类别，包括以下内容：
- en: '`if` and `switch`. The `if` statement allows you to conditionally execute code,
    depending on the provided condition. The `switch` statement makes it possible
    to choose a statement list to execute using the **pattern match**.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`和`switch`。`if`语句允许你根据提供的条件有条件地执行代码。`switch`语句使得使用**模式匹配**选择要执行的语句列表成为可能。'
- en: '`do-while`, `while`, `for`, and `foreach`. They are related to **loops** and
    are used to execute a part of code many times while the condition is met.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-while`、`while`、`for`和`foreach`。它们与**循环**相关，用于在满足条件时多次执行代码的一部分。'
- en: '`break`, `continue`, and `goto`. They are used to control the execution of
    loops, such as to break it or move to the next iteration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`、`continue`和`goto`。它们用于控制循环的执行，例如用于中断循环或移动到下一个迭代。'
- en: '`throw`, `try-catch`, `try-finally`, and `try-catch-finally`. They are connected
    to handling exceptions that can be thrown in various parts of the code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`、`try-catch`、`try-finally`和`try-catch-finally`。它们与处理代码中可能抛出的异常有关。'
- en: Other statements exist as well, such as `lock`, `yield`, `checked`, `unchecked`,
    and `fixed`. You will see some of the statements presented in the preceding list
    in the code snippets shown in the following chapters of this book, along with
    explanations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他语句，例如`lock`、`yield`、`checked`、`unchecked`和`fixed`。你将在本书后续章节中展示的代码片段中看到前述列表中的某些语句，以及相应的解释。
- en: Developing various applications in the C# language is also simplified by the
    availability of many additional great features, such as **Language Integrated
    Query** (**LINQ**), which allows developers to get data from various sources,
    including SQL databases and XML documents, consistently. There are also some approaches
    to shorten the required code, such as using Lambda expressions, pattern matching,
    properties, expression-bodied members, records, and string interpolations. It
    is worth mentioning automatic **garbage collection**, which greatly simplifies
    the task of releasing memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言的许多附加优秀功能也简化了各种应用程序的开发，例如**语言集成查询**（**LINQ**），它允许开发者从各种来源获取数据，包括SQL数据库和XML文档，并且可以一致地操作。还有一些方法可以缩短所需的代码，例如使用Lambda表达式、模式匹配、属性、表达式成员体、记录和字符串插值。自动**垃圾回收**也值得提及，它极大地简化了释放内存的任务。
- en: Where can you find more information?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 哪里可以找到更多信息？
- en: You can learn more about the newest version of the C# language at [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12).
    The language history is shown at [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history).
    A set of detailed information about the language reference (including value and
    reference types) is available at [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference).
    You can find there information about available data types with a set of details,
    including the supported value ranges and precisions, which are presented later
    in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12)上了解更多关于C#语言最新版本的信息。语言的历史可以在[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history)中查看。一套关于语言参考（包括值类型和引用类型）的详细信息可以在[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference)中找到。你可以在那里找到有关可用数据类型的信息，包括支持的值范围和精度，这些信息将在本章后面部分展示。
- en: Of course, the solutions mentioned previously are only a very limited subset
    of features that are available while developing in C#. You will see some others
    in the following parts of this book, along with examples and detailed descriptions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，之前提到的解决方案只是C#开发中可用功能的一个非常有限的子集。你将在本书的后续部分看到一些其他功能，包括示例和详细描述。
- en: .NET-based console applications
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于.NET的控制台应用程序
- en: To keep things simple, while reading this book, you will create many console-based
    applications, but the data structures and algorithms could be used in other kinds
    of solutions as well. The console-based applications will be created in **Microsoft
    Visual Studio 2022 Community**. This **integrated development environment** (**IDE**)
    is a comprehensive solution for developing various kinds of projects and is equipped
    with many great features that simplify the development and testing of your applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，在阅读这本书的过程中，你将创建许多基于控制台的应用程序，但数据结构和算法也可以用于其他类型的解决方案。基于控制台的应用程序将在**Microsoft
    Visual Studio 2022 Community**中创建。这个**集成开发环境**（**IDE**）是开发各种项目的综合解决方案，并配备了简化应用程序开发和测试的许多优秀功能。
- en: 'Just after launching the IDE, we can proceed by creating a new project. To
    create one, follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动IDE之后，我们可以通过创建一个新的项目来继续操作。要创建一个项目，请按照以下步骤进行：
- en: Click on **File** | **New** | **Project** in the main menu.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中点击**文件** | **新建** | **项目**。
- en: Choose **Console App** on the right in the **Create a new** **project** window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建新项目**窗口的右侧选择**控制台应用程序**。
- en: Type the name of the project (**Project name**), select a location for the files
    (**Location**), and enter the name of the solution (**Solution name**). Then,
    press **Next**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目的名称（**项目名称**），选择文件的位置（**位置**），并输入解决方案的名称（**解决方案名称**）。然后，按**下一步**。
- en: In the **Additional information** window, set the framework version to **.NET
    8.0 (Long Term Support)** and ensure that **Do not use top-level statements**
    is unchecked. If you are ready, click on the **Create** button to automatically
    create the project and generate the necessary files.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加信息**窗口中，将框架版本设置为**.NET 8.0（长期支持**）并确保**不使用顶层语句**选项未被勾选。如果你准备好了，点击**创建**按钮来自动创建项目和生成必要的文件。
- en: Congratulations! You’ve just created the first project. But what’s inside?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了第一个项目。但里面有什么？
- en: Let’s take a look at the **Solution Explorer** window, which presents the structure
    of the project. It is worth mentioning that the project is included in the solution
    with the same name. Of course, a solution could contain more than one project,
    which is a common scenario while developing more complex applications. You can
    see how it works if you browse the GitHub repository of this book. It contains
    one solution with over 40 projects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看**解决方案资源管理器**窗口，它展示了项目的结构。值得一提的是，项目以相同的名称包含在解决方案中。当然，一个解决方案可以包含多个项目，这在开发更复杂的应用程序时是一个常见的场景。如果你浏览这本书的GitHub仓库，你可以看到它包含一个包含40多个项目的解决方案。
- en: Don’t have Solution Explorer?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有解决方案资源管理器？
- en: If you cannot find the **Solution Explorer** window, you can open it by choosing
    the **View** | **Solution Explorer** option from the main menu. Similarly, you
    could open other windows, such as **Output** or **Class View**. If you cannot
    find a suitable window (for example, **C# Interactive**) directly within the **View**
    option, you can find it in the **View** | **Other** **Windows** node.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找不到**解决方案资源管理器**窗口，你可以通过从主菜单中选择**视图** | **解决方案资源管理器**选项来打开它。同样，你也可以打开其他窗口，例如**输出**或**类视图**。如果你在**视图**选项中找不到合适的窗口（例如，**C#交互式窗口**），你可以在**视图**
    | **其他** **窗口**节点中找到它。
- en: The automatically generated project contains the **Dependencies** element, which
    presents additional dependencies used by the project. It is worth noting that
    you could easily add references by choosing the **Add Project Reference**, **Add
    Shared Project Reference**, or **Add COM Reference** option from the context menu
    of the **Dependencies** element. Moreover, you can install additional packages
    using **NuGet Package Manager**, which can be launched by choosing **Manage NuGet
    Packages** from the **Dependencies** context menu.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的项目包含**依赖项**元素，它展示了项目使用的额外依赖项。值得注意的是，你可以通过从**依赖项**元素的上下文菜单中选择**添加项目引用**、**添加共享项目引用**或**添加COM引用**选项来轻松添加引用。此外，你可以使用**NuGet包管理器**安装额外的包，这可以通过从**依赖项**上下文菜单中选择**管理NuGet包**来启动。
- en: Write from scratch or reuse existing packages?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是从头开始编写还是重用现有包？
- en: It is a good idea to take a look at packages that are already available before
    writing the complex module on your own since a suitable package could already
    be available for developers. In such a case, you could not only shorten the development
    time but also reduce the chance of introducing mistakes. However, please check
    the license conditions and ensure that the external module is reliable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己编写复杂的模块之前查看已经可用的包是个好主意，因为可能已经有一个合适的包可供开发者使用。在这种情况下，你不仅可以缩短开发时间，还可以减少引入错误的机会。然而，请检查许可证条件并确保外部模块是可靠的。
- en: 'The `Program.cs` file contains the main code in C#. You could adjust the behavior
    of the application by changing the following default implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs`文件包含C#中的主代码。你可以通过更改以下默认实现来调整应用程序的行为：'
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The initial content of this file contains just two lines. The first contains
    the comment, while the other writes the following text in the console when the
    program is launched:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的初始内容只有两行。第一行是注释，而另一行在程序启动时会在控制台写入以下文本：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It looks so simple and easy to modify, doesn’t it? This is true and the default
    implementation of this file has changed significantly over the last few years
    due to the functionality of `Program` class is defined, together with the `Main`
    static method, where the logic of the simple program is placed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来如此简单且易于修改，不是吗？这是真的，并且由于`Program`类及其`Main`静态方法（其中放置了简单程序的逻辑）的功能，这个文件的默认实现在过去几年中已经发生了显著变化。
- en: 'So, what will the default code look like if you disable the top-level statements?
    Let’s take a look at it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你禁用了顶层语句，默认代码会是什么样子呢？让我们来看看：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code contains the definition of the `Program` class within the
    `GettingStarted` namespace. This class contains the `Main` static method, which
    is called automatically when the application is launched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含`GettingStarted`命名空间内`Program`类的定义。这个类包含一个`Main`静态方法，当应用程序启动时会自动调用。
- en: Before proceeding, let’s take a look at the structure of the project in the
    file explorer, not in the **Solution Explorer** window. Are such structures the
    same?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看文件资源管理器中项目的结构，而不是在**解决方案资源管理器**窗口中。这些结构是否相同？
- en: How to open a project directory
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如何打开项目目录
- en: You could open the directory with the project in the file explorer by choosing
    the **Open Folder in File Explorer** option from the context menu of the project
    node in the **Solution** **Explorer** window.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在**解决方案资源管理器**窗口的项目节点上下文菜单中选择**在文件资源管理器中打开文件夹**选项，在文件资源管理器中打开包含项目的目录。
- en: First of all, you can see the `bin` and `obj` directories, which are generated
    automatically. Both contain `Debug` and `Release` directories, whose names are
    related to the configuration set in the IDE. After building the project, a subdirectory
    of the `bin` directory (that is, `Debug` or `Release`) contains the `net8.0` directory
    with `.exe`, `.dll`, and `.pdb` files. What’s more, there is no `Dependencies`
    directory, but there is the `.csproj` file, which contains the XML-based configuration
    of the project. Similarly, the solution-based `.sln` configuration file is located
    in the solution’s directory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以看到自动生成的`bin`和`obj`目录。这两个目录都包含`Debug`和`Release`目录，其名称与在IDE中设置的配置相关。在构建项目后，`bin`目录的子目录（即`Debug`或`Release`）包含带有`.exe`、`.dll`和`.pdb`文件的`net8.0`目录。更重要的是，没有`Dependencies`目录，但有一个`.csproj`文件，其中包含基于XML的项目配置。同样，基于解决方案的`.sln`配置文件位于解决方案目录中。
- en: Ignore some files and directories using Git
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git忽略某些文件和目录
- en: If you are using a `bin` and `obj` directories, as well as the `.csproj.user`
    file. I strongly encourage you to use a version control system for various projects,
    as well as to **commit and push changes frequently**. If you can, you can also
    try to automate the process of testing and deployment, such as by introducing
    **continuous integration** and **continuous delivery** (**CI/CD**). The introduction
    of such procedures can have a very positive impact on the quality and stability
    of your great applications, regardless of their types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`bin`和`obj`目录，以及`.csproj.user`文件，我强烈建议你为各种项目使用版本控制系统，并频繁地**提交和推送更改**。如果你能的话，你也可以尝试自动化测试和部署的过程，例如通过引入**持续集成**和**持续交付**（**CI/CD**）。引入这样的流程可以对您优秀应用程序的质量和稳定性产生非常积极的影响，无论它们的类型如何。
- en: As you already know how to create projects for the examples we’ll be covering
    in this book, let’s focus on the available data types and their basic divisions,
    as well as write some code!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们将在本书中涵盖的示例创建项目，让我们专注于可用的数据类型及其基本划分，以及编写一些代码！
- en: Division of data types
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型的划分
- en: While developing applications in the C# language, you could use various data
    types, which are divided into two main groups, namely **value types** and **reference
    types**. The difference between them is quite simple – **a variable of a value
    type directly contains data, while a variable of a reference type just stores
    a reference to data, which is located** **somewhere else**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在用C#语言开发应用程序时，你可以使用各种数据类型，这些数据类型分为两大类，即**值类型**和**引用类型**。它们之间的区别相当简单——**值类型的变量直接包含数据，而引用类型的变量仅存储对数据的引用，该数据位于**
    **其他地方**。
- en: 'Here’s an illustration of this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '![Figure 1.1 – The difference between value and reference types](img/B18069_01_1.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 值类型和引用类型之间的区别](img/B18069_01_1.jpg)'
- en: Figure 1.1 – The difference between value and reference types
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 值类型和引用类型之间的区别
- en: As you can see, a variable of a **value type** (shown as **A**) stores its actual
    **value** directly in the **stack** memory, while a variable of a **reference
    type** only stores a **reference** here. The actual value is located in the **heap**
    memory. Therefore, it is possible to have two or more variables of a reference
    type that reference the same value, as indicated by the **C** and **D** boxes
    in the preceding figure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**值类型的变量**（显示为**A**）直接在**栈**内存中存储其**实际值**，而**引用类型的变量**在这里只存储一个**引用**。实际值位于**堆**内存中。因此，可以有两个或更多引用类型的变量引用相同的值，如前图中**C**和**D**框所示。
- en: Be careful – it is a simplification!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 小心——这是一个简化！
- en: Please remember that this is some kind of simplification because value types
    are not always stored on the stack. There are some scenarios when they are stored
    on the heap. If you are interested in this topic, you can read much more about
    it at [https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/](https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这仅仅是一种简化，因为值类型并不总是存储在栈上。在某些情况下，它们会被存储在堆上。如果你对这个主题感兴趣，你可以在[https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/](https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/)上阅读更多关于它的内容。
- en: Of course, a difference between value and reference types is important while
    programming and you should know which types belong to the groups mentioned previously.
    Otherwise, you could make mistakes in the code that could be quite difficult to
    find.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在编程时区分值类型和引用类型的差异很重要，你应该知道哪些类型属于之前提到的组。否则，你可能会在代码中犯一些相当难以发现的错误。
- en: For instance, you should be careful while comparing two objects with the `==`)
    since **two variables of a value type are equal if their data are equal, while
    two variables of a reference type are equal if they reference the** **same location**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你使用 `==` 比较两个对象时应该小心，因为**值类型的两个变量如果数据相等，则它们是相等的，而引用类型的两个变量如果它们引用了** **同一位置**，则它们是相等的**。
- en: You should also take care while assigning a variable of a reference type to
    another variable and while passing a variable of a reference type as an argument
    to a method and updating its data. This is because the change can be reflected
    in other variables that are referencing the same object. In contrast, while using
    a value type, the variable value is copied while it’s being passed as an argument
    to a method, returning a result from a method, or assigning it to another variable,
    so you only modify data in one location.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你在将引用类型的变量赋值给另一个变量，或者将引用类型的变量作为参数传递给方法并更新其数据时也应该小心。这是因为更改可能会反映在其他引用同一对象的变量中。相比之下，在使用值类型时，变量值在作为参数传递给方法、从方法返回结果或将其赋值给另一个变量时会被复制，所以你只修改一个位置的数据。
- en: Does the division between value and reference types seem clear to you? If so,
    let’s proceed to the next section, where the value types will be described in
    more detail, and some code snippets will be provided.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的区别对你来说是否清晰？如果是的话，让我们继续到下一节，在那里将更详细地描述值类型，并提供一些代码片段。
- en: Value types
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: 'To give you a better understanding of data types, let’s start by analyzing
    the first group, namely **value types**. They are further divided into the following
    categories:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更好地理解数据类型，让我们首先分析第一组，即**值类型**。它们进一步分为以下类别：
- en: '**Structs**encapsulating data and functionalities, which are divided into the
    following categories:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装数据和功能的结构**，它们分为以下类别：'
- en: '**Built-in value types**, also referred to as **simple types**. These are divided
    into:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置值类型**，也称为**简单类型**。这些分为：'
- en: '**Integral** **numeric types**'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数** **数值类型**'
- en: '**Floating-point** **numeric types**'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点** **数值类型**'
- en: '**Boolean values**'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**'
- en: '**Unicode** **UTF-16 characters**'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unicode** **UTF-16字符**'
- en: '**Value tuples**'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值元组**'
- en: '**User-defined** **struct types**'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户定义** **结构类型**'
- en: '**Constants**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**'
- en: '**Enumerations**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**'
- en: All of these groups will be described in this section, starting with the simple
    types.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组都将在本节中描述，首先是简单类型。
- en: Integral numbers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: The first group of built-in value types are the `System` namespace. Such types
    differ by the number of bytes used and whether signed or unsigned integral values
    are represented by them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内置值类型的第一个组是`System`命名空间。这些类型通过使用的字节数以及它们是否表示有符号或无符号整数值而有所不同。
- en: Imagine an integer value
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个整数值
- en: If you want to better visualize an integer value, you can find some examples
    around you – the publication year of this book, the number of legs of your table,
    and the number of keys on your keyboard. All of these are integer values, such
    as `2024`, `4`, and `84`. Yes, I counted the number of keys on my keyboard, especially
    for you!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported integral numeric types are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`Byte` (the `byte` keyword), as 8-bit unsigned'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sbyte` (`sbyte`), as 8-bit signed'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16` (`short`), as 16-bit signed'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint16` (`ushort`), as 16-bit unsigned'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int32` (`int`), as 32-bit signed'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UInt32` (`uint`), as 32-bit unsigned'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int64` (`long`), as 64-bit signed'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UInt64` (`ulong`), as 64-bit unsigned'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IntPtr` (`nint`), as 32- or 64-bit (platform-dependent) signed'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.UintPtr` (`nuint`), as 32- or 64-bit (platform-dependent) unsigned'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the types differ by the number of bytes for storing values and
    therefore by the range of available values. As an example, the `byte` data type
    supports values in the range from 0 to 255, `sbyte` from -128 to 127, `short`
    from -32,768 to 32,767, and `uint` from 0 to 4,294,967,295\. Is it a huge number?
    Yes, it is. However, let’s take a look at the range for `ulong`, which is from
    0 to 18,446,744,073,709,551,615.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify values for integral types in the following modes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`45`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x` or `0X` as a prefix – for example, `0xff` for 255.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0b` or `0B` as a prefix – for example, `0b1101110` for 110\. It can be also
    written as `0b_0110_1110` to improve the readiness of the number.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an exemplary code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last remark we’ll make is about the default value for any built-in integral
    numeric type. You probably won’t be surprised if I told you that it is **zero**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point numbers
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second group of built-in value types are **floating-point numeric types**,
    which allow you to store **floating-point values**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a floating-point value
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a floating-point value, you can measure your current
    body temperature in Celsius degrees, get your height in centimeters, count the
    money that you currently have in your wallet, or take a look at your computer’s
    processor frequency provided in GHz. All of these values are floating-point ones
    – for example, `36.6`, `184.8`, `105.34`, and `1.7`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use three floating-point numeric types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`Single` (`float`) using 32 bits – for example, `1.53f` (`f` or `F` suffix)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double` (`double`) using 64 bits – for example, `1.53` (no suffix or `d`/`D`
    suffix)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decimal` (`decimal`) using 128 bits – for example, `1.53M` (`m` or `M` suffix)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As the number of used bits differs from 32 up to 128 bits, the range and precision
    of values differ significantly. Just take a look at the numbers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`float` stores numbers between ±1.5×10−45 and ±3.4×1038'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` stores numbers between ±5.0×10−324 and ±1.7×10308'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal` stores numbers between ±1.0×10-28 and ±7.9228×1028'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be surprised that even though `decimal` values use twice as many bits
    as the `double` type does, its range is significantly smaller. However, the `decimal`
    type is a good choice for monetary calculations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶，尽管`decimal`值使用的位数是`double`类型的两倍，但其范围却显著更小。然而，`decimal`类型是货币计算的好选择。
- en: In the end, remember that the default value for any floating-point numeric type
    is **zero**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，任何浮点数值类型的默认值是**零**。
- en: Boolean values
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: Regarding `Boolean` type or the `bool` keyword. This makes it possible to store
    a `true` or `false`. The default value is `false`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Boolean`类型或`bool`关键字。这使得可以存储`true`或`false`。默认值是`false`。
- en: Imagine a Boolean value
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个布尔值
- en: 'If you want to visualize a Boolean value, answer the following questions: are
    you currently reading this book? Do you have at least 5 years of experience? Have
    you finished university? You can only answer these questions with *yes* (`true`)
    or *no* (`false`). No other answers are accepted. So, you can store such replies
    as Boolean variables.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想可视化一个布尔值，请回答以下问题：您目前正在阅读这本书吗？您有至少5年的经验吗？您已经完成大学学业了吗？您只能用*是*（`true`）或*否*（`false`）来回答这些问题。不接受其他答案。因此，您可以存储这样的回复作为布尔变量。
- en: 'Let’s take a look at the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: char letter = 'M';
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: char letter = 'M';
- en: char bullet = '\u25cf';
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: char bullet = '\u25cf';
- en: char special = char value is \0 (U+0000).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: char special = char value is \0 (U+0000).
- en: Constants
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: It is worth noting that you can also define **constant values**. **Each constant
    value is an** **immutable value** **that cannot be changed**. Constant values
    can only be created from simple types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您还可以定义**常量值**。**每个常量值都是一个** **不可变值** **，不能更改**。常量值只能从简单类型创建。
- en: Imagine a constant
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个常量
- en: If you want to remember constant values easily, think about some immutable values,
    such as the number of days in a week (`7`), the number of millimeters in a centimeter
    (`10`), the highest acceptable temperature value for a sensor (`90`), or the maximum
    number of iterations for your algorithm (`5`). None of these values can be changed
    after creation and can be defined as constants.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想轻松记住常量值，请考虑一些不可变值，例如一周中的天数（`7`）、厘米中的毫米数（`10`）、传感器可接受的最高温度值（`90`）或算法的最大迭代次数（`5`）。这些值在创建后都不能更改，可以定义为常量。
- en: 'You can use the `const` keyword to create a constant value, as shown in the
    following line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`const`关键字来创建一个常量值，如下所示：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another interesting fact is that the constant expressions for which all operands
    are constant values of simple types are evaluated at compile time. This has a
    positive impact on the performance of your application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事实是，对于所有操作数都是简单类型常量值的常量表达式，它们在编译时就会被评估。这对您应用程序的性能有积极影响。
- en: Enumerations
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举
- en: Apart from the already mentioned types, the value types contain **enumerations**.
    **Each has a set of** **named constants** **to specify the available set** **of**
    **values**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经提到的类型外，值类型还包含**枚举**。**每个枚举都有一个** **命名常量** **集合**，用于指定可用的值集。
- en: Imagine an enumeration
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个枚举
- en: If you want to better visualize an enumeration, try to specify available colors
    for your car while configuring it (for example, black, white, gray, red, and yellow),
    languages supported by your app (for example, English, Polish, and German), or
    currencies in which you accept payments (for example, PLN, USD, and EUR). In all
    of these scenarios, there is a precisely defined list of available values to select,
    so they are good representatives of enumerations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地可视化一个枚举，在配置汽车时尝试指定可用的颜色（例如，黑色、白色、灰色、红色和黄色），应用程序支持的语言（例如，英语、波兰语和德语），或您接受的货币（例如，PLN、USD和EUR）。在这些所有场景中，都有一个精确定义的可选值列表，因此它们是枚举的良好代表。
- en: 'An example definition is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例定义如下：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: CurrencyEnum currency = CurrencyEnum.Pln;
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CurrencyEnum currency = CurrencyEnum.Pln;
- en: switch (currency)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: switch (currency)
- en: '{'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'case CurrencyEnum.Pln: /* Polish zloty */ break;'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'case CurrencyEnum.Pln: /* 波兰兹罗提 */ break;'
- en: 'case CurrencyEnum.Usd: /* American Dollar */ break;'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'case CurrencyEnum.Usd: /* 美元 */ break;'
- en: 'default: /* Euro */ break;'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'default: /* 欧元 */ break;'
- en: '}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: CurrencyEnum currency = CurrencyEnum.Pln;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CurrencyEnum currency = CurrencyEnum.Pln;
- en: switch (currency)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: switch (currency)
- en: '{'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'case CurrencyEnum.Pln: /* Polish zloty */ break;'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'case CurrencyEnum.Pln: /* 波兰兹罗提 */ break;'
- en: 'case CurrencyEnum.Usd: /* American Dollar */ break;'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'case CurrencyEnum.Usd: /* 美元 */ break;'
- en: 'default: /* Euro */ break;'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'default: /* 欧元 */ break;'
- en: '}'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: enum CurrencyEnum { Pln, Usd, Eur };
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: enum CurrencyEnum { Pln, Usd, Eur };
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Flags]'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[标志]'
- en: enum ActionEnum
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: enum ActionEnum
- en: '{'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: None    = 0b_0000_0000, // 0
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: None    = 0b_0000_0000, // 0
- en: List    = 0b_0000_0001, // 1
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: List    = 0b_0000_0001, // 1
- en: Details = 0b_0000_0010, // 2
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Details = 0b_0000_0010, // 2
- en: Add     = 0b_0000_0100, // 4
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Add     = 0b_0000_0100, // 4
- en: Edit    = 0b_0000_1000, // 8
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Edit    = 0b_0000_1000, // 8
- en: Delete  = 0b_0001_0000, // 16
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Delete  = 0b_0001_0000, // 16
- en: Publish = 0b_0010_0000  // 32
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Publish = 0b_0010_0000  // 32
- en: '}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ActionEnum guest = ActionEnum.List;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ActionEnum guest = ActionEnum.List;
- en: ActionEnum user = ActionEnum.List | ActionEnum.Details;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ActionEnum user = ActionEnum.List | ActionEnum.Details;
- en: ActionEnum editor = ActionEnum.List | ActionEnum.Add
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ActionEnum editor = ActionEnum.List | ActionEnum.Add
- en: List and Details permissions to a user, the combined permission is equal to
    00000011. The admin with full access to the system has combined permission equal
    to 00111111. Simple and efficient, isn’t it?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将List和Details权限赋予用户，组合权限等于00000011。拥有系统完全访问权限的管理员组合权限等于00111111。简单且高效，不是吗？
- en: It’s worth mentioning that enumerations allow you to replace some *magical strings*
    (such as `Pln` or `Usd`) with constant values. This has a very positive impact
    on code quality. What’s more, it significantly simplifies refactoring, maintenance,
    and introducing changes in the code in the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，枚举允许你用一些*魔法字符串*（如`Pln`或`Usd`）替换常量值。这对代码质量有非常积极的影响。更重要的是，它显著简化了重构、维护以及在将来对代码的更改。
- en: Value tuples
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 值元组
- en: The value tuple type is represented by the `System.ValueTuple` type and is **a
    lightweight data structure that allows you to group multiple data elements of
    specific types**. It has a very simple syntax, in which you just need to specify
    the types of all data members and, optionally, provide their names. All of the
    elements are public fields, so a tuple type is a **mutable value type**. What’s
    more, **it is a very data-centric type, so you cannot even define methods** **within
    it**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 值元组类型由`System.ValueTuple`类型表示，它是一个轻量级的数据结构，允许你将多个特定类型的数据元素组合在一起。它具有非常简单的语法，你只需要指定所有数据成员的类型，并且可选地提供它们的名称。所有元素都是公共字段，因此元组类型是一个**可变的值类型**。更重要的是，它是一个非常以数据为中心的类型，因此你甚至不能在它内部定义方法。
- en: Imagine a value tuple
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个值元组
- en: If you want to understand a value tuple more easily, stop for a moment to think
    about the programming problem when you need to return a result from a method that
    consists of two or three values, such as a price in the chosen currency and the
    used conversion rate from the base currency, or a set of statistics consisting
    of minimum, maximum, and average values. As a solution, you can define a dedicated
    class, record, or struct and use it as a return type. However, this data structure
    will only be used once, and it will unnecessarily complicate the project and future
    changes. Another solution is to use `out` parameters for the method. However,
    such parameters cannot be used in all circumstances. To solve this problem, you
    can use a value tuple type and simply specify the types of data members that are
    returned from the method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更容易地理解值元组，请暂时停下来思考一下当你需要从由两个或三个值组成的方法返回结果时的编程问题，例如所选货币的价格和从基础货币使用的转换率，或者由最小值、最大值和平均值组成的统计集合。作为解决方案，你可以定义一个专门的类、记录或结构体，并将其用作返回类型。然而，这种数据结构将只使用一次，并且会不必要地使项目复杂化并影响未来的更改。另一个解决方案是使用`out`参数。然而，这种参数不能在所有情况下使用。为了解决这个问题，你可以使用值元组类型，并简单地指定从方法返回的数据成员类型。
- en: 'Even though the value tuple type seems to be straightforward, it can be used
    in various scenarios. Let’s take a look at the following code snippet, where we
    use a value tuple and specify the type of data members returned from the method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管值元组类型看起来很简单，但它可以在各种场景中使用。让我们看看以下代码片段，其中我们使用值元组并指定从方法返回的数据成员类型：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Min = 4 / Max = 13 / Avg = 8.33
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值 = 4 / 最大值 = 13 / 平均值 = 8.33
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: (int min, int max, double avg) = Calculate(4, 8, 13);
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (int min, int max, double avg) = Calculate(4, 8, 13);
- en: Console.WriteLine($"Min = {min} / Max = {max}
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"最小值 = {min} / 最大值 = {max}
- en: / Avg = {avg:F2}");
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: / 平均值 = {avg:F2}");
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (int, int, double) Calculate(params int[] numbers)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (int, int, double) Calculate(params int[] numbers)
- en: '{'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (numbers.Length == 0) { return (0, 0, 0); }
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: if (numbers.Length == 0) { return (0, 0, 0); }
- en: int min = int.MaxValue;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: int min = int.MaxValue;
- en: int max = int.MinValue;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: int max = int.MinValue;
- en: int sum = 0;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = 0;
- en: foreach (int number in numbers)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (int number in numbers)
- en: '{'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (number > max) { max = number; }
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: if (number > max) { max = number; }
- en: if (number < min) { min = number; }
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: if (number < min) { min = number; }
- en: sum += number;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: sum += number;
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return (min, max, (double)sum / numbers.Length);
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: return (min, max, (double)sum / numbers.Length);
- en: '}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: using Statistics = (int Min, int Max, double Avg);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: using Statistics = (int Min, int Max, double Avg);
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Statistics Calculate(params int[] numbers)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Statistics Calculate(params int[] numbers)
- en: '{'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /* (...) */
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: /* (...) */
- en: return (min, max, (double)sum / numbers.Length);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: return (min, max, (double)sum / numbers.Length);
- en: '}'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Statistics result = Calculate(4, 8, 13);
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Statistics result = Calculate(4, 8, 13);
- en: Console.WriteLine($"Min = {result.Min} / Max = {result.Max}
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"Min = {result.Min} / Max = {result.Max}");
- en: / Avg = {result.Avg:F2}");
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: / Avg = {result.Avg:F2}");
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: public readonly struct Price
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: public readonly struct Price
- en: '{'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public Price(decimal amount, CurrencyEnum currency)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: public Price(decimal amount, CurrencyEnum currency)
- en: '{'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Amount = amount;
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Amount = amount;
- en: Currency = currency;
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Currency = currency;
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public readonly decimal Amount { get; init; }
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: public readonly decimal Amount { get; init; }
- en: public readonly CurrencyEnum Currency { get; init; }
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: public readonly CurrencyEnum Currency { get; init; }
- en: public override string ToString()
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: public override string ToString()
- en: => $"{Amount} {Currency}";
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: => $"{Amount} {Currency}";
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: public readonly struct Price(
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: public readonly struct Price(
- en: decimal amount, CurrencyEnum currency)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: decimal amount, CurrencyEnum currency)
- en: '{'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public readonly decimal Amount { get; init; } = amount;
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: public readonly decimal Amount { get; init; } = amount;
- en: public readonly CurrencyEnum Currency { get; init; }
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: public readonly CurrencyEnum Currency { get; init; }
- en: = currency;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: = currency;
- en: public override string ToString()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: public override string ToString()
- en: => $"{Amount} {Currency}";
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: => $"{Amount} {Currency}";
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: public enum CurrencyEnum { Pln, Usd, Eur };
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: public enum CurrencyEnum { Pln, Usd, Eur };
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Price priceRegular = new(100, CurrencyEnum.Pln);
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Price priceRegular = new(100, CurrencyEnum.Pln);
- en: Console.WriteLine(priceRegular);
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(priceRegular);
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 100 Pln
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 100 Pln
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Price priceDiscount = priceRegular priceRegular instance and set the value of
    the Amount property to 50. However, values of the remaining properties are the
    same as in the priceRegular instance, so Currency is set to Pln.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Price priceDiscount = priceRegular priceRegular 实例并将 Amount 属性的值设置为 50。然而，其余属性的值与
    priceRegular 实例相同，因此货币设置为 Pln。
- en: To conclude the topic of user-defined structs, it’s worth remembering that the
    default value for each of them is created by setting all reference-type fields
    to `null` and all value-type fields to their default values.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结用户定义的结构体主题，值得记住的是，每个它们的默认值是通过将所有引用类型字段设置为 `null` 以及所有值类型字段设置为它们的默认值来创建的。
- en: Nullable value types
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值类型
- en: Now that we’ve come to the end of this section regarding value types, think
    about a scenario where you need to store either a particular value, such as a
    numeric one (for example, 154), or information that a value is not provided. One
    of the possible solutions is to use two variables. The first specifies whether
    the value is provided (the `bool` type), while the other stores a numeric value
    (for example, of the `int` type). However, is it possible to only use one variable
    instead of two? The answer is yes! To achieve this, you can use a `null` value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了关于值类型的本节结尾，请考虑一个需要存储特定值（例如数值，例如，154）或信息（表示值未提供）的场景。一个可能的解决方案是使用两个变量。第一个指定值是否提供（`bool`
    类型），而另一个存储数值（例如，`int` 类型）。然而，是否可能只使用一个变量而不是两个？答案是肯定的！为了实现这一点，您可以使用 `null` 值。
- en: Imagine a nullable value type
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个可空值类型
- en: If you want to understand nullable value types more easily, think about the
    scenario of calculating the age of a user of your portal. If the user provides
    you with their date of birth, the task is pretty simple. However, what about a
    situation when such a date is missing? You cannot calculate their age, so the
    age variable can be set to `null` instead of an integer value. Here, you can use
    the `int?` type.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更容易地理解可空值类型，请考虑计算您门户用户年龄的场景。如果用户向您提供了他们的出生日期，任务相当简单。然而，如果缺少这样的日期，您无法计算他们的年龄，因此年龄变量可以设置为
    `null` 而不是整数值。在这里，您可以使用 `int?` 类型。
- en: 'As for its implementation, you can use the `?` operator just after a type name
    or use the `System.Nullable<T>` structure, which has the same effect, as shown
    here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其实现，您可以在类型名后直接使用 `?` 操作符，或者使用 `System.Nullable<T>` 结构，它们具有相同的效果，如下所示：
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: if (age != null) { Console.WriteLine(age.Value); }
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: if (age != null) { Console.WriteLine(age.Value); }
- en: 'if (note.??)GetValueOrDefault method. Examples for both are shown here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: if (note.??)GetValueOrDefault 方法。以下为两种方法的示例：
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: DateTime date = new(1988, 11, 9);
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime date = new(1988, 11, 9);
- en: int? age = GetAgeFromBirthDate(date);
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: int? age = GetAgeFromBirthDate(date);
- en: 'age ??= 18; // The same as: age = age ?? 18;'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: age ??= 18; // 与：age = age ?? 18; 相同
- en: int? GetAgeFromBirthDate(DateTime date)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: int? GetAgeFromBirthDate(DateTime date)
- en: '{'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: double days = (DateTime.Now - date).TotalDays;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: double days = (DateTime.Now - date).TotalDays;
- en: 'return days > 0 ? (int)(days / 365) : null;'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'return days > 0 ? (int)(days / 365) : null;'
- en: '}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: string? GetFormatted(float? number)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: string? GetFormatted(float? number)
- en: => numberGetFormatted method returns null if null is provided as the number
    parameter. Otherwise, it returns the number formatted using the specified format.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: => numberGetFormatted 方法如果提供 null 作为数字参数，则返回 null。否则，它返回使用指定格式格式化的数字。
- en: Don’t forget that a default value for a nullable value type represents `null`.
    This means that the `HasValue` property returns `false`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，可空值类型的默认值代表 `null`。这意味着 `HasValue` 属性返回 `false`。
- en: Reference types
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型
- en: The second main group of types is `object`, `string`, `delegate`, and `dynamic`.
    Moreover, you can declare **classes**, **records**, and **interfaces**. **Nullable
    reference types** exist as well. All of these types will be described in this
    section. Let’s get started!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组主要类型是 `object`、`string`、`delegate` 和 `dynamic`。此外，还可以声明 **类**、**记录** 和 **接口**。**可空引用类型**也存在。本节将描述所有这些类型。让我们开始吧！
- en: Objects
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: The `Object` class (the `object` alias) is declared in the `System` namespace
    and performs an important role while developing applications in C#. Why? Because
    all other types in the `Object`. This means that built-in value types, built-in
    reference types, as well as user-defined value types and user-defined reference
    types, are derived from the `Object` class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 类（`object` 别名）在 `System` 命名空间中声明，并在使用 C# 开发应用程序时扮演着重要的角色。为什么？因为 `Object`
    中的所有其他类型。这意味着内置的值类型、内置的引用类型，以及用户定义的值类型和用户定义的引用类型，都派生自 `Object` 类。'
- en: Imagine an object
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个对象
- en: If you want to understand the object type more easily, think about it as “*something*.”
    As everything is “*something*,” everything is an object. Representatives of various
    value types and reference types are objects. Oh no – objects are everywhere around
    you! ;-)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更容易地理解对象类型，可以将其视为“*某物*”。因为所有东西都是“*某物*”，所以所有东西都是对象。各种值类型和引用类型的代表都是对象。哦不——对象无处不在！;-)
- en: 'Let’s take a look at a set of methods that are available for all objects:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看所有对象都可用的一组方法：
- en: '`ToString` returns a string representation of the object'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToString` 返回对象的字符串表示形式'
- en: '`GetType` returns a type of the instance'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetType` 返回实例的类型'
- en: '`Equals` checks whether the object is equal to a given object'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Equals` 检查对象是否等于给定的对象'
- en: '`GetHashCode` uses the hash function and returns its result'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetHashCode` 使用哈希函数并返回其结果'
- en: 'As the `Object` type is the base entity for all value types, this means that
    it is possible to convert a variable of any value type (for example, `int` or
    `float`) into the `object` type, as well as to convert a variable of the `object`
    type into a specific value type. Such operations are named **boxing** (the first)
    and **unboxing** (the other), as shown here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Object` 类型是所有值类型的基实体，这意味着可以将任何值类型的变量（例如，`int` 或 `float`）转换为 `object` 类型，也可以将
    `object` 类型的变量转换为特定的值类型。这些操作被称为 **装箱**（前者）和 **拆箱**（后者），如下所示：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: string firstName = "Marcin", lastName = "Jamro";
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: string firstName = "Marcin", lastName = "Jamro";
- en: int year = 1988;
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: int year = 1988;
- en: string note = firstName + " " + lastName.ToUpper()
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: string note = firstName + " " + lastName.ToUpper()
- en: + " was born in " + year;
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: + " 出生于 " + year;
- en: string initials = firstName[0] + "." + lastName[0] + ".";
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: string initials = firstName[0] + "." + lastName[0] + ".";
- en: '[PRE27]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: string note = string.Format("{0} {1} was born in {2}",
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: string note = string.Format("{0} {1} 出生于 {2}",
- en: firstName, lastName.ToUpper(), year);
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: firstName, lastName.ToUpper(), year);
- en: '[PRE28]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: string note = $"{firstName} {lastName.ToUpper()}
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: string note = $"{firstName} {lastName.ToUpper()}
- en: was born in ,10 value for the minimum 10 characters and right alignment, as
    well as a negative ,-10 value for the minimum 10 characters and left alignment)
    or the :F2 for a floating-point number with two digits after a comma or :HH:mm
    for presenting an hour with minutes).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 出生于 ,10 值用于最小 10 个字符和右对齐，以及负值 `-10` 用于最小 10 个字符和左对齐）或 `:F2` 用于带有逗号后两位小数的浮点数或
    `:HH:mm` 用于显示带分钟的小时）。
- en: 'Here’s some example code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例代码：
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This example presents a simple table with body temperatures for three people,
    namely `Marcin`, `Adam`, and `Martyna`, together with their birth dates. The alignments
    (for example, `-8`) and format strings (for example, `dd.MM.yyyy`) are used. What’s
    more, the `> 40.0f`), high (`> 37.0f`), normal (`> 36.0f`), low (`> 35.0f`), or
    very low. The latter is the final case and is also called the `_` and matches
    all other values.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本例展示了一个简单的表格，包含三个人的体温，即 `Marcin`、`Adam` 和 `Martyna`，以及他们的出生日期。使用了对齐方式（例如，`-8`）和格式字符串（例如，`dd.MM.yyyy`）。更重要的是，还有
    `> 40.0f`（高）、`> 37.0f`（正常）、`> 36.0f`（低）、`> 35.0f`（非常低）。后者是最后一种情况，也称为 `_`，并匹配所有其他值。
- en: 'When you execute this code, you’ll see the following result:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行此代码时，你会看到以下结果：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, the C# language is equipped with various possibilities, even
    related to just the `string` type. What’s more, you can combine different features,
    such as the interpolation string with the `switch` statement and pattern matching
    to create code that is easy to understand and maintain.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，C# 语言配备了各种可能性，甚至与 `string` 类型相关。更重要的是，你可以组合不同的特性，例如，将字符串插值与 `switch` 语句和模式匹配结合起来，以创建易于理解和维护的代码。
- en: However, you should keep in mind that `string` is not a typical reference type
    and its behavior is a bit different than in the case of other reference types.
    You can see such a difference while comparing two `string` variables using the
    `==` operator. Here, two `string` instances are the same if they contain the same
    sequence of characters, so it is a similar behavior as in the case of value types.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该记住，`string` 不是一个典型的引用类型，其行为与其他引用类型略有不同。你可以在使用 `==` 操作符比较两个 `string` 变量时看到这种差异。在这里，如果两个
    `string` 实例包含相同的字符序列，则它们是相同的，所以这与值类型的行为相似。
- en: Classes
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: As mentioned previously, C# is an object-oriented language and supports declaring
    classes together with various members, including `public`, `protected`, `internal`,
    `private`, and `file`. These access modifiers are mentioned together with classes,
    but you should remember that they can be used for some other types as well.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C# 是一种面向对象的语言，支持声明类以及各种成员，包括 `public`、`protected`、`internal`、`private`
    和 `file`。这些访问修饰符与类一起提及，但你应该记住，它们也可以用于某些其他类型。
- en: Imagine a class
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个类
- en: If you want to visualize a class, think about a vehicle. Each vehicle has some
    properties, namely brand, model, color, length, width, height, and weight. A vehicle
    can perform some actions, such as taking a given distance. You can also define
    more specific variants of vehicles, such as a car, a plane, and a boat. Each has
    the same properties as the base vehicle, as well as has some additional ones,
    such as a number plate and a fuel type (for example, petrol, diesel, or electric)
    for a car. It also has the action of a door opening. You can also create instances
    of such classes – for example, you can create three instances of a car that differ
    by model and number plate, as well as create an instance of a plane. Then, you
    can perform actions on such instances.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要可视化一个类，想想一辆车。每辆车都有一些属性，即品牌、型号、颜色、长度、宽度、高度和重量。一辆车可以执行一些动作，例如行驶一定的距离。你还可以定义更具体的车辆变体，例如汽车、飞机和船。每个都有与基本车辆相同的属性，以及一些额外的属性，例如汽车的牌照和燃料类型（例如，汽油、柴油或电动）。它还具有开门的动作。你还可以创建此类类的实例
    - 例如，你可以创建三个不同型号和牌照的汽车实例，以及创建一个飞机实例。然后，你可以在这些实例上执行动作。
- en: 'An example class is shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了一个示例类：
- en: '[PRE31]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Person` class contains the `_location` private field with the default value
    set to an empty string (`string.Empty`) and two public `Name` and `Age`). You
    will use the properties quite often while writing the code examples shown in this
    book, so let’s stop for a moment to explain them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类包含一个 `_location` 私有字段，默认值设置为空字符串 (`string.Empty`)，以及两个公共的 `Name`
    和 `Age`。你将在编写本书中展示的代码示例时经常使用这些属性，所以让我们停下来解释一下。'
- en: 'Each property is a member of a class that provides a mechanism for reading
    and writing using **accessors**:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都是类的成员，它提供了使用 **访问器** 读写机制：
- en: '`get` to return the property value'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` 用于返回属性值'
- en: '`set` to assign a new value for the property'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 用于为属性分配新值'
- en: '`init` to set a value during object construction and prevent modifications'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 用于在对象构造期间设置值并防止修改'
- en: 'By combining such accessors, a property can be put in one of the following
    instances:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合这样的访问器，属性可以置于以下实例之一：
- en: '`get` accessor and without the `set` accessor'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` 访问器和没有 `set` 访问器'
- en: '`set` accessor and without the `get` accessor'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 访问器而没有 `get` 访问器'
- en: '`get` and `set` accessors'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` 和 `set` 访问器'
- en: Another interesting feature is a required variant of the property, which is
    specified by the `required` keyword placed just after the access modifier, as
    shown in the case of the `Age` property. It requires that the client code initializes
    the property, and it is a good idea to mark properties as `required` if they should
    be initialized at the beginning of using the class instance. It is also worth
    noting that a property has an accessibility level as one of the access modifiers,
    including `public` and `private`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是属性的必需变体，它由紧跟在访问修饰符之后的 `required` 关键字指定，如 `Age` 属性的例子所示。它要求客户端代码初始化属性，如果应该在类实例使用开始时初始化属性，则将属性标记为
    `required` 是一个好主意。还值得注意的是，属性具有一个访问级别，它是访问修饰符之一，包括 `public` 和 `private`。
- en: 'Let’s take a closer look at the example class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看示例类：
- en: It contains a default constructor that sets a value of the `Name` property to
    `---` using the **expression** **body definition**.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个默认构造函数，使用 **表达式体定义** 将 `Name` 属性的值设置为 `---`。
- en: It contains a constructor that takes one parameter and sets the value of the
    `Name` property.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个接受一个参数的构造函数，并设置 `Name` 属性的值。
- en: It contains the `Relocate` method, which updates the value of the private field.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个 `Relocate` 方法，该方法更新私有字段的值。
- en: It contains the `GetDistance` method, which calls the `GetDistance` static method
    from the `DistanceHelpers` class and returns the distance between two cities provided
    in kilometers. The implementation of the helper class is not shown in the preceding
    code. Note that if you are curious about how you can create a real implementation
    of the mechanism for calculating the distance between cities, you can take a look
    at [*Chapter 8*](B18069_08.xhtml#_idTextAnchor296), *Exploring Graphs*, where
    such an application of graphs will be mentioned.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个 `GetDistance` 方法，该方法调用 `DistanceHelpers` 类的 `GetDistance` 静态方法，并返回两个城市之间的距离（以公里为单位）。辅助类的实现没有在前面的代码中展示。请注意，如果你对如何创建计算城市之间距离的机制的实际实现感到好奇，可以查看[*第8章*](B18069_08.xhtml#_idTextAnchor296)，*探索图论*，其中将提到这种图的用途。
- en: 'You can create an instance of the class using the `new` operator. Then, you
    can perform various operations on the object that’s been created, such as calling
    a method, as shown here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `new` 运算符创建类的实例。然后，你可以对创建的对象执行各种操作，例如调用方法，如下所示：
- en: '[PRE32]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the C# language is still being developed and improved, new amazing features
    were introduced in the following versions and are related to classes as well.
    For example, with the newest version, you can use some concepts that make it possible
    to significantly limit the amount of code. The following code shows some of them:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 语言仍在开发和改进中，后续版本中引入了一些新的令人惊叹的功能，这些功能也与类相关。例如，在新版本中，你可以使用一些概念，这些概念可以显著减少代码量。以下代码展示了其中的一些：
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code performs almost the same role as the previous variant, but
    it is even shorter. If you also like such improvements, keep reading – you will
    see various possibilities of the C# language in the remaining chapters of this
    book.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码几乎与之前的变体执行相同的角色，但它更短。如果你也喜欢这样的改进，请继续阅读——你将在本书剩余的章节中看到 C# 语言的多种可能性。
- en: Let’s proceed to the next section, which is dedicated to records.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一节，该节专门介绍记录。
- en: Records
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 记录
- en: 'In the recent versions of the C# language, another great reference type was
    introduced: `record` or `record` `class` keyword.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 语言的最新版本中，又引入了一个伟大的引用类型：`record` 或 `record class` 关键字。
- en: Value type records exist as well
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型记录也存在
- en: It is worth noting that `record struct` construction exists as well. This construction
    represents a value type with similar functionality. However, in this book, I’ll
    focus on the reference type version only. Of course, you can try another version
    on your own.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`record struct` 构造也存在。这种构造表示具有相似功能的值类型。然而，在这本书中，我将只关注引用类型版本。当然，你也可以自己尝试另一种版本。
- en: One great thing about records is that a smaller amount of code needs to be written
    because the compiler automatically generates the public `init`-only properties
    (called `Deconstruct` method with a set of `out` parameters, each one representing
    a positional parameter. **This means that this data type is data-centric and is
    intended to be immutable, providing a short and** **clear syntax.**
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的一个很好的特点是，需要编写的代码量更少，因为编译器会自动生成只读的`init`属性（称为具有一系列`out`参数的`Deconstruct`方法，每个参数代表一个位置参数。**这意味着这种数据类型是数据中心的，并且旨在不可变，提供了一种简短且**
    **清晰的语法。**
- en: Imagine a record
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个记录
- en: If you want to visualize a record, stand up and take a look at yourself in your
    mirror, focusing on your beautiful T-shirt. It has some properties, such as size
    (for example, S, M, or L), color (for example, white or red), and brand. All of
    these properties are immutable, so you cannot change them as you cannot resize
    your favorite T-shirt since it is produced. So, as your nice T-shirt is data-centric
    and its properties are immutable, it is a good representative of a record. Smile
    to yourself in your mirror and come back to reading the first chapter of this
    book!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想可视化一个记录，站起来，在镜子前看看自己，专注于你那漂亮的T恤。它有一些属性，例如尺寸（例如，S、M或L）、颜色（例如，白色或红色）和品牌。所有这些属性都是不可变的，所以你不能改变它们，就像你不能改变你最喜欢的T恤的大小，因为它已经生产出来了。所以，由于你的漂亮的T恤以数据为中心且其属性不可变，它是一个很好的记录代表。对着镜子对自己微笑，然后回到这本书的第一章阅读！
- en: 'Let’s take a look at the following example of a record declaration:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下记录声明的示例：
- en: '[PRE34]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That’s all! Now, you have a record with five immutable properties (`Name`,
    `Breed`, `Height`, `Weight`, and `Age`), as well as a constructor with five parameters
    related to the positional parameters on the record declaration. You can use it
    to create a new instance, as shown in the following line of code:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！现在，你有一个包含五个不可变属性（`Name`、`Breed`、`Height`、`Weight`和`Age`）的记录，以及一个与记录声明中的位置参数相关的五个参数的构造函数。你可以用它来创建一个新的实例，如下面的代码行所示：
- en: '[PRE35]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Console.WriteLine(rex);
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(rex);
- en: '[PRE36]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Dog { Name = Rex, Breed = Schnauzer, Height = 40,
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Dog { Name = Rex, Breed = Schnauzer, Height = 40,
- en: Weight = 11, Age = 5 }
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Weight = 11, Age = 5 }
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: rex.Name = "Puppy";
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: rex.Name = "Puppy";
- en: '[PRE38]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: public record Dog
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: public record Dog
- en: '{'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public required string Name { get; set; }
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: public required string Name { get; set; }
- en: public required string Breed { get; set; }
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: public required string Breed { get; set; }
- en: public required int Height { get; set; }
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: public required int Height { get; set; }
- en: public required float Weight { get; set; }
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: public required float Weight { get; set; }
- en: public required int Age { get; set; }
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: public required int Age { get; set; }
- en: '}'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Dog beauty = rex Beauty is created, based on Rex. All of the values of the properties
    are taken from Rex, apart from Name and Height, as specified after the with keyword.
    You also need to remember that you can adjust both positional properties and properties
    created using the standard syntax that have the init or set accessor. In such
    a case, a shallow copy is created, so for value types, a copy is used, while for
    reference types, only a reference is copied, so both a source and a target property
    will reference the same instance of a reference type.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Dog beauty = rex Beauty is created, based on Rex. All of the values of the properties
    are taken from Rex, apart from Name and Height, as specified after the with keyword.
    You also need to remember that you can adjust both positional properties and properties
    created using the standard syntax that have the init or set accessor. In such
    a case, a shallow copy is created, so for value types, a copy is used, while for
    reference types, only a reference is copied, so both a source and a target property
    will reference the same instance of a reference type.
- en: 'Let’s take a look at the following line:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下行：
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: public interface IDevice
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: public interface IDevice
- en: '{'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string Model { get; set; }
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: string Model { get; set; }
- en: string Number { get; set; }
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: string Number { get; set; }
- en: int Year { get; set; }
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: int Year { get; set; }
- en: void Configure(DeviceConfiguration configuration);
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: void Configure(DeviceConfiguration configuration);
- en: bool Start();
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: bool Start();
- en: bool Stop();
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: bool Stop();
- en: '}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE41]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: public class Display
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: public class Display
- en: ': IDevice'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ': IDevice'
- en: '{'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public string Model { get; set; }
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: public string Model { get; set; }
- en: public string Number { get; set; }
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: public string Number { get; set; }
- en: public int Year { get; set; }
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: public int Year { get; set; }
- en: public int Diagonal { get; set; }
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: public int Diagonal { get; set; }
- en: public void Configure(
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: public void Configure(
- en: DeviceConfiguration configuration) { (...) }
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: DeviceConfiguration configuration) { (...) }
- en: public bool Start() { (...) }
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: public bool Start() { (...) }
- en: public bool Stop() { (...) }
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: public bool Stop() { (...) }
- en: '}'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Mean arithmetic = (a, b, c) => (a + b + c) / 3;
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Mean arithmetic = (a, b, c) => (a + b + c) / 3;
- en: Mean geometric = delegate (double a, double b, double c)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Mean geometric = delegate (double a, double b, double c)
- en: '{ return Math.Pow(a * b * c, 1 / 3.0); };'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '{ return Math.Pow(a * b * c, 1 / 3.0); };'
- en: Mean harmonic = Harmonic;
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Mean harmonic = Harmonic;
- en: double a = arithmetic.Invoke(5, 6.5, 7);
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: double a = arithmetic.Invoke(5, 6.5, 7);
- en: double g = geometric.Invoke(5, 6.5, 7);
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: double g = 几何函数.Invoke(5, 6.5, 7);
- en: double h = harmonic.Invoke(5, 6.5, 7);
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: double h = 调谐函数.Invoke(5, 6.5, 7);
- en: Console.WriteLine($"{a:F2} / {g:F2} / {h:F2}");
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine($"{a:F2} / {g:F2} / {h:F2}");
- en: double Harmonic(double a, double b, double c) =>
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: double Harmonic(double a, double b, double c) =>
- en: 3 / ((1 / a) + (1 / b) + (1 / c));
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 3 / ((1 / a) + (1 / b) + (1 / c));
- en: 'Mean delegate specifies the required signature of a method for calculating
    a mean value of three floating-point numbers. It is instantiated with the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 平均委托指定了计算三个浮点数平均值所需的方法的签名。它使用以下方式实例化：
- en: A `arithmetic`)
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A `算术`)
- en: An `geometric`)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: An `几何`)
- en: A `harmonic`)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A `调谐`)
- en: 'Each delegate is invoked by calling the `Invoke` method. The results are presented
    in the console, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 每个委托都是通过调用 `Invoke` 方法来调用的。结果将在控制台显示，如下所示：
- en: '[PRE43]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the Lambda expression is shown, so it is a good idea to tell you a bit
    more about such a construction. It uses the `=>` operator, which separates the
    input parameters and the `(a, b, c)`. They are the same as the parameters of the
    delegate. On the right-hand side, there is the Lambda body, which calculates the
    result as a sum of inputs divided by 3\. While developing applications in C#,
    you will use Lambda expressions quite often and it is a nice feature that can
    have a positive impact on your code quality.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，展示了 Lambda 表达式，因此最好告诉你更多关于这种结构的信息。它使用 `=>` 操作符，该操作符将输入参数和 `(a, b, c)` 分隔开来。它们与委托的参数相同。在右侧，是
    Lambda 体，它将结果计算为输入值的和除以3。在用 C# 开发应用程序时，你将经常使用 Lambda 表达式，这是一个可以对你的代码质量产生积极影响的良好特性。
- en: Dynamics
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 动力学
- en: Apart from the types we’ve already described, `dynamic` is available for developers.
    **It allows you to bypass type checking during compilation so that you can perform
    it during runtime.** Such a mechanism can be useful while you’re accessing some
    types of **application programming** **interfaces** (**APIs**).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已描述的类型之外，`dynamic` 对开发者也是可用的。**它允许你在编译时绕过类型检查，以便在运行时进行。**这种机制在访问某些类型的 **应用程序编程**
    **接口**（**API**）时可能很有用。
- en: Imagine a dynamic type
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个动态类型
- en: If you want to better visualize a dynamic type, ask someone nearby to put a
    blindfold on you and then give you a set of instructions on how to move from one
    room to another and sit in a chair – for example, walk 5 steps forward, turn right,
    walk 10 steps forward, and then sit down. If the instructions are correct, you
    will go to the other room and sit comfortably in the chair. However, if anything
    is wrong, you won’t know this by listening to all the instructions at the beginning,
    only when you hit a wall or sit on the floor instead of in the chair. This situation
    is somewhat similar to using dynamic types. If the instructions are correct, the
    application will work correctly, but if something is wrong, it may hurt. ;-)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地可视化动态类型，可以让附近的人给你蒙上眼睛，然后给你一套指令，告诉你如何从一个房间移动到另一个房间并坐在椅子上——例如，向前走5步，向右转，向前走10步，然后坐下。如果指令正确，你将到达另一个房间并舒适地坐在椅子上。然而，如果有什么错误，你不会在开始时通过听所有指令就知道，只有当你撞到墙或坐在地板上而不是椅子上时才会知道。这种情况与使用动态类型有些相似。如果指令正确，应用程序将正常工作，但如果有什么错误，可能会造成伤害。;-)
- en: 'You will not use the `dynamic` type while reading this book. However, to provide
    a short introduction to this feature, take a look at the code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书时，你不会使用 `dynamic` 类型。然而，为了简要介绍这个特性，请看一下以下代码：
- en: '[PRE44]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Random random = new();
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Random random = new();
- en: List<Measurement?> measurements = [];
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: List<Measurement?> measurements = [];
- en: for (int i = 0; i < 100; i++)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 0; i < 100; i++)
- en: '{'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Measurement? measurement = random.Next(3) != 0
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Measurement? measurement = 随机数.Next(3) != 0
- en: '? new(DateTime.Now, random.Next(1000) / 1000.0f)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '? new(DateTime.Now, 随机数.Next(1000) / 1000.0f)'
- en: ': null;'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ': null;'
- en: measurements.Add(measurement);
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: measurements.Add(measurement);
- en: Console.WriteLine(IsValid(measurement)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(IsValid(measurement)
- en: '? measurement!.ToString()'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '? 测量值!.ToString()'
- en: ': "-");'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ': "-");'
- en: await Task.Delay(100);
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: await Task.Delay(100);
- en: '}'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static bool IsValid(Measurement? measurement)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: static bool IsValid(Measurement? measurement)
- en: '{'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return measurement != null
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: return 测量值 != null
- en: '&& measurement.Value >= 0.0f'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '&& 测量值.Value >= 0.0f'
- en: '&& measurement.Value <= 1.0f;'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '&& 测量值.Value <= 1.0f;'
- en: '}'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public record null, if the measurement is not received correctly from some external
    device. Within the for loop, we simulate getting a measurement by using the Random
    class. Statistically, about 2/3 of total measurements are retrieved correctly
    (the Measurement instance is then created) and the remaining 1/3 of total measurements
    are not retrieved (null is used instead). Such values are added to the measurements
    list. Then, we need to check whether the obtained reading is correct – that is,
    apart from being provided, its value is within the range of <0.0, 1.0>. We perform
    this check using the IsValid static method while taking the nullable Measurement
    instance as a parameter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当从某些外部设备未能正确接收到测量值时，使用`public record null`。在for循环中，我们通过使用Random类来模拟获取测量值。从统计上看，大约2/3的总测量值被正确检索（此时创建Measurement实例），而剩余的1/3总测量值没有被检索（使用null代替）。这些值被添加到测量值列表中。然后，我们需要检查获得的读数是否正确——也就是说，除了提供之外，其值还应在<0.0,
    1.0>的范围内。我们使用IsValid静态方法并传递可空的Measurement实例作为参数来执行此检查。
- en: Finally, we just need to show information about a reading in the console. For
    the correct reading, we present a formatted value of the `Measurement` instance.
    Otherwise, we use a dash (`-`). However, if we write `measurement.ToString()`,
    we will receive a warning stating “*Dereference of a possibly null reference*”
    because the compiler does not know that we’re checking whether the measurement
    is not `null` within the `IsValid` method. We can avoid this warning using the
    null-forgiving operator by adding the `!` sign just after the variable name, before
    calling the `ToString` method. A small explanation may also be required for the
    line containing the `Delay` method call. It is only used to simulate the real
    behavior of the device, from which we read a measurement each 100 ms.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需在控制台显示读数信息。对于正确的读数，我们展示`Measurement`实例的格式化值。否则，我们使用破折号（`-`）。然而，如果我们编写`measurement.ToString()`，我们将收到一条警告信息，指出“*可能为null的引用解引用*”，因为编译器不知道我们在`IsValid`方法中检查测量值是否为`null`。我们可以通过在调用`ToString`方法之前，变量名后添加`!`符号来使用null忽略运算符来避免此警告。对于包含`Delay`方法调用的行，可能也需要一个小解释。它仅用于模拟从每个100毫秒读取一次测量值的设备的真实行为。
- en: As you can see, both nullable value types and nullable reference types provide
    you with very similar semantics (such as `bool?` for a nullable value type and
    `string?` for a nullable reference type), but they are implemented in other ways.
    A nullable value type uses `System.Nullable<T>` internally (for example, `System.Nullable<System.Boolean>`
    for `bool?`), while a non-nullable value type uses another type (just `System.Boolean`
    for `bool`). The nullable reference type uses the same type for both nullable
    and non-nullable variants. This means that `string?` and `string` are provided
    by the `System.String` class in both cases.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可空值类型和可空引用类型为你提供了非常相似的语义（例如，`bool?`用于可空值类型和`string?`用于可空引用类型），但它们的实现方式不同。可空值类型在内部使用`System.Nullable<T>`（例如，对于`bool?`是`System.Nullable<System.Boolean>`），而非可空值类型使用另一种类型（对于`bool`是`System.Boolean`）。可空引用类型对可空和非可空变体使用相同的类型。这意味着在两种情况下，`string?`和`string`都是由`System.String`类提供的。
- en: Summary
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: This was only the first chapter of this book, but it contained quite a lot of
    information that will be useful while you’re reading the remaining ones. First,
    the **C# programming language** was briefly presented with a focus on showing
    various data types, both value and reference ones. You learned the difference
    between them and why understanding this difference is so important while developing
    applications.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是本书的第一章，但它包含了在阅读剩余章节时将非常有用的信息。首先，简要介绍了**C#编程语言**，重点是展示各种数据类型，包括值类型和引用类型。你学习了它们之间的区别以及为什么在开发应用程序时理解这种区别如此重要。
- en: Next, you saw various **value types**, including the built-in ones, such as
    integral numeric types, floating-point numeric types, Boolean type, and Unicode
    characters. Then, you learned about constants, enumerations, value tuples, user-defined
    struct types, and nullable value types. All of these were equipped with detailed
    descriptions, as well as some code examples to make understanding easier and faster.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你看到了各种**值类型**，包括内置的类型，例如整数数值类型、浮点数值类型、布尔类型和Unicode字符。然后，你学习了常量、枚举、值元组、用户定义的结构类型和可空值类型。所有这些类型都配备了详细的描述，以及一些代码示例，以便更容易、更快地理解。
- en: Finally, you learned about the second group of types, namely **reference types**.
    Here, you saw the object and string types, classes, records, interfaces, as well
    as delegate and dynamic types. Then, you learned about nullable reference types.
    Again, a lot of information was supported by explanations and some code fragments.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了第二组类型，即**引用类型**。在这里，你看到了对象和字符串类型、类、记录、接口，以及委托和动态类型。然后，你学习了可空引用类型。同样，大量的信息都通过解释和一些代码片段得到了支持。
- en: With this introduction, you should be ready to proceed to the next chapter and
    learn **what algorithms are and why they are so important**. Let’s go!
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个介绍，你应该已经准备好进入下一章，学习**算法是什么以及为什么它们如此重要**。让我们开始吧！
- en: '[PRE45]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
