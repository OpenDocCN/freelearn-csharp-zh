- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Broadcasting Real-Time Communication Using SignalR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SignalR进行实时通信广播
- en: In this chapter, you will be introduced to SignalR, a technology that enables
    a developer to create a service that can have multiple clients and broadcast messages
    to all of them or a subset of them live in real time. The canonical example is
    a group chat app. Other examples include notification systems and dashboards that
    need instantly up-to-date information like stock prices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解SignalR，这是一种技术，它使开发者能够创建一个可以拥有多个客户端，并能实时向所有客户端或其中一部分客户端广播消息的服务。典型的例子是群聊应用。其他例子包括需要即时更新信息的系统，如股票价格。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding SignalR
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SignalR
- en: Building a live communication service using SignalR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SignalR构建实时通信服务
- en: Building a web client using the SignalR JavaScript library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SignalR JavaScript库构建Web客户端
- en: Building a .NET console app client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个.NET控制台应用程序客户端
- en: Streaming data using SignalR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SignalR进行数据流
- en: Understanding SignalR
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SignalR
- en: To understand the problem that SignalR solves, we need to understand what web
    development is like without it. The foundation of the web is HTTP, which for more
    than 30 years has been great for building general-purpose websites and services.
    However, the web was not designed for specialized scenarios that require a web
    page to be instantaneously updated with new information as it becomes available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解SignalR解决的问题，我们需要了解没有它时Web开发是什么样的。Web的基础是HTTP，超过30年来，它对于构建通用网站和服务来说一直很好。然而，Web并没有为需要网页即时更新新信息的特定场景而设计。
- en: The history of real-time communication on the web
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络上实时通信的历史
- en: To understand the benefits of SignalR, it helps to know the history of HTTP
    and how organizations worked to make it better for real-time communication between
    clients and servers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解SignalR的好处，了解HTTP的历史以及组织如何努力使其更适合客户端和服务器之间的实时通信是有帮助的。
- en: In the early days of the Web in the 1990s, browsers had to make a full-page
    HTTP `GET` request to the web server to get fresh information to show to the visitor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代Web的早期，浏览器必须向Web服务器发送完整的HTTP `GET`请求，以获取新鲜信息向访客展示。
- en: In late 1999, Microsoft released Internet Explorer 5 with a component named
    **XMLHttpRequest** that could make asynchronous HTTP calls in the background.
    This, alongside **dynamic HTML** (**DHTML**), allowed parts of the web page to
    be updated with fresh data smoothly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在1999年底，微软发布了带有名为**XMLHttpRequest**组件的Internet Explorer 5，该组件可以在后台进行异步HTTP调用。这，连同**动态HTML**（**DHTML**），使得网页的部分可以平滑地用新鲜数据更新。
- en: The benefits of this technique were obvious, and soon, all browsers added the
    same component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优势很明显，很快，所有浏览器都添加了相同的组件。
- en: AJAX
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX
- en: Google took maximum advantage of this capability to build clever web applications
    such as Google Maps and Gmail. A few years later, the technique became popularly
    known as **Asynchronous JavaScript and XML** (**AJAX**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Google充分利用这一功能构建了像Google Maps和Gmail这样的聪明Web应用。几年后，这项技术被普遍称为**异步JavaScript和XML**（**AJAX**）。
- en: 'AJAX still uses HTTP to communicate, however, and that has limitations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AJAX仍然使用HTTP进行通信，但它有一些局限性：
- en: First, HTTP is a request-response communication protocol, meaning that the server
    cannot push data to the client. It must wait for the client to make a request.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，HTTP是一个请求-响应通信协议，这意味着服务器不能向客户端推送数据。它必须等待客户端发起请求。
- en: Second, HTTP request and response messages have headers with lots of potentially
    unnecessary overhead.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，HTTP请求和响应消息具有包含大量可能不必要的开销的头部。
- en: WebSocket
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket
- en: '**WebSocket** is full-duplex, meaning that either the client or server can
    initiate communicating new data. WebSocket uses the same TCP connection for the
    life cycle of the connection. It is also more efficient in the message sizes that
    it sends because they are minimally framed with 2 bytes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket**是全双工的，这意味着客户端或服务器都可以发起新的通信数据。WebSocket在整个连接生命周期中使用相同的TCP连接。它发送的消息大小也更有效率，因为它们以2个字节的最小帧格式发送。'
- en: WebSocket works over HTTP ports `80` and `443` so it is compatible with the
    HTTP protocol, and the WebSocket handshake uses the HTTP **Upgrade** header to
    switch from the HTTP protocol to the WebSocket protocol.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket通过HTTP端口`80`和`443`工作，因此它与HTTP协议兼容，WebSocket握手使用HTTP的**Upgrade**头从HTTP协议切换到WebSocket协议。
- en: Modern web apps are expected to deliver up-to-date information. Live chat is
    the canonical example, but there are lots of potential applications, from stock
    prices to games.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用程序预期提供最新的信息。实时聊天是典型的例子，但还有许多潜在的应用，从股价到游戏。
- en: 'Whenever you need the server to push updates to the web page, you need a web-compatible,
    real-time communication technology. WebSocket could be used, but it is not supported
    by all clients. You can check which clients support WebSocket using the web page
    found at the following link: [https://caniuse.com/websockets](https://caniuse.com/websockets).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你需要服务器将更新推送到网页，你都需要一种兼容网页的、实时通信技术。WebSocket 可以使用，但并非所有客户端都支持它。您可以使用以下链接中的网页检查哪些客户端支持
    WebSocket：[https://caniuse.com/websockets](https://caniuse.com/websockets)。
- en: 'WebSocket or WebSockets? “The **WebSocket** protocol was standardized by the
    IETF as RFC 6455 in 2011\. The current API specification allowing web applications
    to use this protocol is known as *WebSockets*.” From the Wikipedia page found
    at the following link: [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 或 WebSockets？ “**WebSocket** 协议于 2011 年由 IETF 标准化为 RFC 6455。允许网络应用程序使用此协议的当前
    API 规范被称为 *WebSockets*。” 有关更多信息，请参阅以下链接中的维基百科页面：[https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)。
- en: Introducing SignalR
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 SignalR
- en: '**ASP.NET Core SignalR** is an open-source library that simplifies adding real-time
    web functionality to apps by being an abstraction over multiple underlying communication
    technologies, which allows you to add real-time communication capabilities using
    C# code.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASP.NET Core SignalR** 是一个开源库，通过在多个底层通信技术之上提供抽象，简化了向应用程序添加实时 Web 功能的过程，允许您使用
    C# 代码添加实时通信功能。'
- en: The developer does not need to understand or implement the underlying technology
    used, and SignalR will automatically switch between underlying technologies depending
    on what the visitor’s web browser supports. For example, SignalR will use WebSocket
    when it’s available and gracefully falls back on other technologies such as AJAX
    long polling when it isn’t, while your application code stays the same.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者不需要理解或实现底层技术，SignalR 将根据访问者的 Web 浏览器支持的底层技术自动切换。例如，当 WebSocket 可用时，SignalR
    将使用 WebSocket，当不可用时，它将优雅地回退到其他技术，如 AJAX 长轮询，而您的应用程序代码保持不变。
- en: 'SignalR is an API for server-to-client **remote procedure calls** (**RPCs**).
    The RPCs call JavaScript functions on clients from server-side .NET code. SignalR
    has hubs to define the pipeline and handles the message dispatching automatically
    using two built-in hub protocols: JSON and a binary one based on MessagePack.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 是一个服务器到客户端的 **远程过程调用**（RPCs）API。RPCs 从服务器端的 .NET 代码调用客户端的 JavaScript
    函数。SignalR 有中心点来定义管道，并自动使用两个内置中心点协议：JSON 和基于 MessagePack 的二进制协议来处理消息分发。
- en: 'On the server side, SignalR runs everywhere that ASP.NET Core runs: Windows,
    macOS, or Linux servers. SignalR supports the following client platforms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，SignalR 在 ASP.NET Core 运行的任何地方都可以运行：Windows、macOS 或 Linux 服务器。SignalR
    支持以下客户端平台：
- en: JavaScript clients for current browsers including Chrome, Firefox, Safari, and
    Edge.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括 Chrome、Firefox、Safari 和 Edge 在内的当前浏览器的 JavaScript 客户端。
- en: .NET clients including Blazor, .NET MAUI, and Xamarin for Android and iOS mobile
    apps.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 客户端，包括 Blazor、.NET MAUI 和用于 Android 和 iOS 移动应用的 Xamarin。
- en: Java 8 and later.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 及以后版本。
- en: Azure SignalR Service
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure SignalR 服务
- en: Earlier, I mentioned that it would be good practice to separate the SignalR
    service hosting project from the web project that uses the JavaScript library
    to act as a client. This is because a SignalR service potentially needs to handle
    lots of simultaneous client requests and respond quickly to them all.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到，将 SignalR 服务托管项目与使用 JavaScript 库作为客户端的 Web 项目分开是一个好的实践。这是因为 SignalR 服务可能需要处理大量的并发客户端请求，并且需要快速响应对所有请求。
- en: Once you separate the SignalR hosting, you can take advantage of **Azure SignalR
    Service**. This offers global reach and a world-class data center and network,
    and it scales to millions of connections while meeting SLAs like providing compliance
    and high security.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将 SignalR 托管分离出来，您就可以利用 **Azure SignalR 服务**。这提供了全球覆盖和世界级的数据中心和网络，并且可以扩展到数百万个连接，同时满足
    SLA，如提供合规性和高安全性。
- en: 'You can learn more about Azure SignalR Service at the following link: [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多关于 Azure SignalR 服务的相关信息：[https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview)。
- en: Designing method signatures
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计方法签名
- en: When designing the method signatures for a SignalR service, it is good practice
    to define methods with a single message parameter rather than multiple simple
    type parameters. This good practice is not enforced by the technology with SignalR,
    so you will have to be disciplined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当为 SignalR 服务设计方法签名时，定义具有单个消息参数的方法而不是多个简单类型参数是良好实践。这种良好实践不是由 SignalR 技术强制执行的，因此您必须自律。
- en: 'For example, instead of passing multiple `string` (or other type) values, define
    a type with multiple properties to use as the single `Message` parameter, as shown
    in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，而不是传递多个 `string`（或其他类型）值，定义一个具有多个属性的类型，用作单个 `Message` 参数，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The reason for this good practice is that it allows future changes like adding
    a third property for the message `Title`. For the bad practice example, a third
    `string` parameter named `title` would need to be added and existing clients would
    get errors because they are not sending the extra `string` value. But using the
    good practice example will not break the method signature so existing clients
    can continue to call it as before the change. On the server side, the extra `Title`
    property will just have a `null` value that can be checked for, and perhaps be
    set to a default value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种良好实践的原因是它允许未来的更改，例如为消息 `Title` 添加第三个属性。对于不良实践的例子，需要添加一个名为 `title` 的第三个 `string`
    参数，并且现有的客户端会因为它们没有发送额外的 `string` 值而得到错误。但是，使用良好实践的例子不会破坏方法签名，因此现有的客户端可以像更改之前一样继续调用它。在服务器端，额外的
    `Title` 属性将只有一个 `null` 值，可以进行检查，也许可以将其设置为默认值。
- en: SignalR method parameters are serialized as JSON, so all nested objects are
    accessible in JavaScript if needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 方法参数被序列化为 JSON，因此如果需要，所有嵌套对象在 JavaScript 中都是可访问的。
- en: Now that we’ve explored the fundamentals of SignalR and its various aspects
    like good practices for method signature design, let’s walk through how to build
    a live communication service using SignalR.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了 SignalR 的基础知识及其各个方面，如方法签名设计的好实践，让我们来看看如何使用 SignalR 构建实时通信服务。
- en: Building a live communication service using SignalR
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SignalR 构建实时通信服务
- en: The SignalR *server* library is included in ASP.NET Core, but the JavaScript
    *client* library is not automatically included in the project. Remember, SignalR
    supports multiple client types, and a web page using JavaScript is just one of
    them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 的 **服务器** 库包含在 ASP.NET Core 中，但 JavaScript 的 **客户端** 库不是自动包含在项目中的。记住，SignalR
    支持多种客户端类型，而使用 JavaScript 的网页只是其中之一。
- en: We will use the **Library Manager CLI** to get the client library from **unpkg**,
    a **content delivery network** (**CDN**) that can deliver anything found in the
    Node.js package manager.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Library Manager CLI** 从 **unpkg** 获取客户端库，**unpkg** 是一个可以交付 Node.js 包管理器中找到的任何内容的
    **内容分发网络**（**CDN**）。
- en: 'Let’s add a SignalR server-side hub and client-side JavaScript to an ASP.NET
    Core MVC project to implement a chat feature that allows visitors to send messages
    to:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 ASP.NET Core MVC 项目中添加一个 SignalR 服务器端中心和一个客户端 JavaScript，以实现一个允许访客向以下地址发送消息的聊天功能：
- en: Everyone currently using the website.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前正在使用网站的每个人。
- en: Dynamically defined groups.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态定义的组。
- en: A single specified user.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定单个用户。
- en: '**Good Practice**: In a production solution, it would be better to host the
    SignalR hub in a separate web project so that it can be hosted and scaled independently
    from the rest of the website. Live communication can often put excessive load
    on a website.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在生产解决方案中，最好将 SignalR 中心托管在单独的 Web 项目中，以便它可以独立于网站的其他部分进行托管和扩展。实时通信往往会对网站造成过大的负载。'
- en: Defining some shared models
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一些共享模型
- en: 'First, we will define two shared models that can be used on both the server-side
    and client-side .NET projects that will work with our chat service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义两个可以在服务器端和客户端 .NET 项目中使用的共享模型，这些项目将与我们的聊天服务一起工作：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下列所示：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Solution file and folder: `Chapter11`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter11`
- en: 'Project file and folder: `Northwind.Common`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.Common`
- en: In the `Northwind.Common` project, rename the `Class1.cs` file to `UserModel.cs`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.Common`项目中，将`Class1.cs`文件重命名为`UserModel.cs`。
- en: 'Modify its contents to define a model for registering a user’s name, unique
    connection ID, and the groups that they belong to, as shown in the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容以定义一个用于注册用户姓名、唯一连接ID以及他们所属的组别的模型，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Good Practice**: In a real-world app, you would want to use a collection
    of `string` values for the `Groups` property, but this coding task is not about
    how to provide a web user experience for editing multiple `string` values. We
    will provide a simple text box instead and focus on learning SignalR.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：在实际应用中，您可能希望为`Groups`属性使用`string`值的集合，但这个编码任务并不是关于如何提供编辑多个`string`值的Web用户体验。我们将提供一个简单的文本框，并专注于学习SignalR。'
- en: 'In the `Northwind.Common` project, add a class file named `MessageModel.cs`.
    Modify its contents to define a message model with properties for whom the message
    is sent to and who the message was sent from, and the message body, as shown in
    the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.Common`项目中，添加一个名为`MessageModel.cs`的类文件。修改其内容以定义一个消息模型，包含消息接收者、消息发送者以及消息正文等属性，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Enabling a server-side SignalR hub
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用服务器端SignalR中心
- en: 'Next, we will enable a SignalR hub on the server side in an ASP.NET Core MVC
    project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在ASP.NET Core MVC项目中在服务器端启用一个SignalR中心：
- en: 'Use your preferred code editor to add a new project, as defined in the following
    list:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器添加一个新项目，如下面的列表所示：
- en: 'Project template: **ASP.NET Core Web App (Model-View-Controller)** / `mvc`'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**ASP.NET Core Web App (Model-View-Controller)** / `mvc`
- en: 'Solution file and folder: `Chapter11`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter11`
- en: 'Project file and folder: `Northwind.SignalR.Service.Client.Mvc`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.SignalR.Service.Client.Mvc`
- en: 'Authentication type: None.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证类型：无。
- en: 'Configure for HTTPS: Selected.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置HTTPS：已选择。
- en: 'Enable Docker: Cleared.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用Docker：已清除。
- en: 'Do not use top-level statements: Cleared.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用顶级语句：已清除。
- en: 'In the `Northwind.SignalR.Service.Client.Mvc` project, treat warnings as errors
    and add a project reference to the `Northwind.Common` project, as shown in the
    following markup:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.SignalR.Service.Client.Mvc`项目中，将警告视为错误，并添加对`Northwind.Common`项目的项目引用，如下面的标记所示：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `Properties` folder, in `launchSettings.json`, in the `https` profile,
    modify the `applicationUrl` to use port `5111` for `https` and `5112` for `http`,
    as shown highlighted in the following configuration:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Properties`文件夹中，在`launchSettings.json`中，在`https`配置文件中，修改`applicationUrl`以使用端口`5111`进行`https`连接和`5112`进行`http`连接，如下面高亮显示的配置所示：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `Northwind.SignalR.Service.Client.Mvc` project, add a class file named
    `ChatHub.cs`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.SignalR.Service.Client.Mvc`项目中，添加一个名为`ChatHub.cs`的类文件。
- en: 'In `ChatHub.cs`, modify its contents to inherit from the `Hub` class and implement
    two methods that can be called by a client, as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChatHub.cs`中，修改其内容以继承自`Hub`类并实现两个可以被客户端调用的方法，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note the following:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: '`ChatHub` has a private field to store a list of registered users. It is a
    dictionary with their name as a unique key.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChatHub`有一个私有字段用于存储已注册用户列表。它是一个以他们的名字作为唯一键的字典。'
- en: '`ChatHub` has two methods that a client can call: `Register` and `SendMessage`.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChatHub`有两个客户端可以调用的方法：`Register`和`SendMessage`。'
- en: '`Register` has a single parameter of type `UserModel`. The user’s name, connection
    ID, and groups are stored in the static dictionary so that the user’s name can
    be used to look up the connection ID later and send messages directly to that
    one user. After registering a new user or updating the registration of an existing
    user, a message is sent back to the client informing them of success.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Register`方法接受一个类型为`UserModel`的单个参数。用户的姓名、连接ID和组别被存储在静态字典中，以便以后可以使用用户姓名查找连接ID并直接向该用户发送消息。在注册新用户或更新现有用户的注册信息后，会向客户端发送一条消息，告知他们操作成功。'
- en: '`SendMessage` has a single parameter of type `MessageModel`. The method branches
    based on the value of the `To` property. If `To` does not have a value, it calls
    the `All` property to get a proxy that will communicate with every client. If
    `To` has a value, the `string` is split using comma separators into an array.
    Each item in the array is checked to see if it matches a user in `Users`. If it
    matches, it calls the `Client` method to get a proxy that will communicate just
    with that one client. If it does not match, the item might be a group, so it calls
    the `Group` method to get a proxy that will communicate with just the members
    of that group. Finally, it sends the message asynchronously using the proxy.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendMessage` 有一个类型为 `MessageModel` 的单个参数。该方法根据 `To` 属性的值进行分支。如果 `To` 没有值，它调用
    `All` 属性以获取一个将与每个客户端通信的代理。如果 `To` 有值，则使用逗号分隔符将 `string` 分割成一个数组。检查数组中的每个项是否与 `Users`
    中的用户匹配。如果匹配，它调用 `Client` 方法以获取一个将仅与该客户端通信的代理。如果不匹配，该项可能是一个组，因此它调用 `Group` 方法以获取一个将仅与该组成员通信的代理。最后，它使用代理异步发送消息。'
- en: 'In `Program.cs`, import the namespace for your SignalR hub, as shown in the
    following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入你的 SignalR 中心的命名空间，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the section that configures services, add a statement to add support for
    SignalR to the services collection, as shown in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置服务的部分，添加一个语句以向服务集合添加对 SignalR 的支持，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the section that configures the HTTP pipeline, before the call to map controller
    routes, add a statement to map the relative URL path `/chat` to your SignalR hub,
    as shown in the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置 HTTP 管道的部分，在调用映射控制器路由之前，添加一个语句将相对 URL 路径 `/chat` 映射到你的 SignalR 中心，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building a web client using the SignalR JavaScript library
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SignalR JavaScript 库构建 Web 客户端
- en: 'Next, we will add the SignalR client-side JavaScript library so that we can
    use it on a web page:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 SignalR 客户端 JavaScript 库，以便我们可以在网页上使用它：
- en: Open a command prompt or terminal for the `Northwind.SignalR.Service.Client.Mvc`
    project/folder.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Northwind.SignalR.Service.Client.Mvc` 项目/文件夹的命令提示符或终端。
- en: 'Install the Library Manager CLI tool, as shown in the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下命令安装库管理器 CLI 工具：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tool might already be installed globally. To update it to the latest version,
    repeat the command but replace `install` with `update`.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此工具可能已经全局安装。要更新到最新版本，重复命令，但将 `install` 替换为 `update`。
- en: 'Enter a command to add the `signalr.js` and `signalr.min.js` libraries to the
    project from the `unpkg` source, as shown in the following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令将 `signalr.js` 和 `signalr.min.js` 库添加到项目，从 `unpkg` 源，如下面的命令所示：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Never copy long commands from a PDF and paste them directly to the command
    prompt. Always clean them up in a basic text editor to remove extraneous new lines
    and so on and then recopy them. To make it easier to enter long command lines,
    you can copy them from the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 PDF 中复制长命令并直接粘贴到命令提示符是不推荐的。始终在基本的文本编辑器中清理它们，以删除多余的换行符等，然后再重新复制。为了更容易输入长命令行，你可以从以下链接复制它们：[https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md)
- en: 'Note the success message, as shown in the following output:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意成功消息，如下面的输出所示：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Visual Studio 2022 also has a GUI for adding client-side JavaScript libraries.
    To use it, right-click a web project and then navigate to **Add** | **Client Side
    Libraries**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 还有一个用于添加客户端 JavaScript 库的 GUI。要使用它，右键单击一个 Web 项目，然后导航到 **添加**
    | **客户端库**。
- en: Adding a chat page to the MVC website
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 MVC 网站添加聊天页面
- en: 'Next, we will add chat functionality to the home page:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向主页添加聊天功能：
- en: 'In `Views/Home`, in `Index.cshtml`, modify its contents, as shown in the following
    markup:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Views/Home` 的 `Index.cshtml` 中，修改其内容，如下面的标记所示：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note the following:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: 'There are three sections on the page: **Register User**, **Send** **Message**,
    and **Messages received**.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面上有三个部分：**注册用户**、**发送消息**和**收到的消息**。
- en: The **Register User** section has two inputs for the visitor’s name, a comma-separated
    list of the groups that they want to be a member of, and a button to click to
    register.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册用户**部分有两个输入框用于访客的姓名，一个逗号分隔的列表，列出他们想要成为成员的组，以及一个点击以注册的按钮。'
- en: The **Send Message** section has three inputs for the name of the user that
    the message is from, the names of users and groups that the message will be sent
    to, and the body of the message – and a button to click to send the message.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送消息**部分有三个输入框，分别用于输入消息发送者的用户名、消息接收者的用户名和群组名，以及消息正文，还有一个点击按钮来发送消息。'
- en: The **Messages received** section has a bullet list element that will be dynamically
    populated with a list item when a message is received.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收到的消息**部分有一个项目符号列表元素，当收到消息时，会动态填充一个列表项。'
- en: There are two script elements for the SignalR JavaScript client-side library
    and the JavaScript implementation of the chat client.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个脚本元素用于SignalR JavaScript客户端库和聊天客户端的JavaScript实现。
- en: 'In `wwwroot/js`, add a new JavaScript file named `chat.js` and modify its contents,
    as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`wwwroot/js`中添加一个名为`chat.js`的新JavaScript文件，并修改其内容，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note the following:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The script creates a SignalR hub connection builder specifying the relative
    URL path to the chat hub on the server `/chat`.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本创建了一个SignalR中心连接构建器，指定服务器上聊天中心的相对URL路径`/chat`。
- en: The script disables the **Register** and **Send** buttons until the connection
    is successfully established to the server-side hub.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本在成功连接到服务器端中心之前禁用**注册**和**发送**按钮。
- en: An `input` event handler is added to the **My name** text box to keep it synchronized
    with the **From** text box.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**我的名字**文本框添加了一个`input`事件处理器，以保持它与**来自**文本框同步。
- en: When the connection gets a `ReceiveMessage` call from the server-side hub, it
    adds a list item element to the `messages` bullet list. The content of the list
    item contains details of the message like `from`, `to`, and `body`. For the two
    models that we defined in C#, note that JavaScript uses camelCase compared to
    C#, which uses PascalCase.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接从服务器端中心接收到`ReceiveMessage`调用时，它会在`messages`项目符号列表中添加一个列表项元素。列表项的内容包含消息的详细信息，如`from`、`to`和`body`。对于我们在C#中定义的两个模型，请注意，JavaScript使用camelCase，而C#使用PascalCase。
- en: The message is formatted using a JavaScript interpolated `string`. This feature
    requires backticks `` ` `` at the start and end of the `string` value and the
    use of curly brackets `${}` for dynamic placeholders.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息使用JavaScript插值`string`格式化。此功能需要在`string`值的开始和结束处使用反引号`` ` ``，并使用花括号`${}`来表示动态占位符。
- en: A `click` event handler is added to the **Register User** button that creates
    a register model with the user’s name and their groups and then invokes the `Register`
    method on the server side.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**注册用户**按钮添加了一个`click`事件处理器，该处理器创建一个包含用户名和其群组的注册模型，然后在服务器端调用`Register`方法。
- en: A `click` event handler is added to the **Send Message** button that creates
    a message model with the `from`, `to`, and `body`, and then invokes the `SendMessage`
    method on the server side.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**发送消息**按钮添加了一个`click`事件处理器，该处理器创建一个包含`from`、`to`和`body`的消息模型，然后在服务器端调用`SendMessage`方法。
- en: Testing the chat feature
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试聊天功能
- en: 'Now we are ready to try sending chat messages between multiple website visitors:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好尝试在多个网站访客之间发送聊天消息：
- en: 'Start the `Northwind.SignalR.Service.Client.Mvc` project website using the
    `https` profile:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`https`配置文件启动`Northwind.SignalR.Service.Client.Mvc`项目网站：
- en: If you are using Visual Studio 2022, then select the **https** profile in the
    toolbar, and then start the `Northwind.SignalR.Service.Client.Mvc` project without
    debugging.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio 2022，则在工具栏中选择**https**配置文件，然后在不进行调试的情况下启动`Northwind.SignalR.Service.Client.Mvc`项目。
- en: 'If you are using Visual Studio Code, then at the command prompt or terminal,
    enter the following command:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio Code，则在命令提示符或终端中输入以下命令：
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On Windows, if Windows Defender Firewall blocks access, then click **Allow access**.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，如果Windows Defender防火墙阻止访问，则点击**允许访问**。
- en: Start Chrome and navigate to `https://localhost:5111/`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Chrome并导航到`https://localhost:5111/`。
- en: 'Note that `Alice` is already entered for the name, and `Sales,IT` is already
    entered for her groups. Click **Register User**, and note the response back from
    the **SignalR Chat**, as shown in *Figure 11.1*:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`Alice`的名字已经输入，`Sales,IT`群组也已经输入。点击**注册用户**，注意**SignalR聊天**返回的响应，如图*图11.1*所示：
- en: '![](img/B19587_11_01.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_11_01.png)'
- en: 'Figure 11.1: Registering a new user in chat'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：在聊天中注册新用户
- en: Open a new Chrome window or start another browser like Firefox or Edge.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Chrome窗口或启动另一个浏览器，如Firefox或Edge。
- en: Navigate to `https://localhost:5111/`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`https://localhost:5111/`。
- en: Enter `Bob` for the name, `Sales` for his groups, and then click **Register
    User**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Bob`作为姓名，`Sales`作为他的组，然后点击**注册用户**。
- en: Open a new Chrome window or start another browser like Firefox or Edge.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Chrome窗口或启动另一个浏览器，如Firefox或Edge。
- en: Navigate to `https://localhost:5111/`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`https://localhost:5111/`。
- en: Enter `Charlie` for the name, `IT` for his groups, and then click **Register
    User**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Charlie`作为姓名，`IT`作为他的组，然后点击**注册用户**。
- en: Arrange the browser windows so that you can see all three simultaneously.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整浏览器窗口，以便可以同时看到所有三个窗口。
- en: 'A great tool for arranging windows is PowerToys and its FancyZones feature.
    Learn more at the following link: [https://learn.microsoft.com/en-us/windows/powertoys/](https://learn.microsoft.com/en-us/windows/powertoys/).'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PowerToys及其FancyZones功能是管理窗口的绝佳工具。更多信息请访问以下链接：[https://learn.microsoft.com/en-us/windows/powertoys/](https://learn.microsoft.com/en-us/windows/powertoys/)。
- en: 'In Alice’s browser, enter the following:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Alice的浏览器中输入以下内容：
- en: '**To**: `Sales`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：`Sales`'
- en: '**Body**: `Sell more!`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：`卖更多！`'
- en: Click **Send Message**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送消息**。
- en: 'Note that Alice and Bob receive the message, as shown in *Figure 11.2*:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Alice和Bob收到了消息，如图11.2所示：
- en: '![](img/B19587_11_02.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_11_02.png)'
- en: 'Figure 11.2: Alice sends a message to the Sales group'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：Alice向Sales组发送消息
- en: 'In Bob’s browser, enter the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bob的浏览器中输入以下内容：
- en: '**To**: `IT`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：`IT`'
- en: '**Body**: `Fix more bugs!`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：`修复更多错误！`'
- en: Click **Send Message**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送消息**。
- en: 'Note that Alice and Charlie receive the message, as shown in *Figure 11.3*:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Alice和Charlie收到了消息，如图11.3所示：
- en: '![](img/B19587_11_03.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_11_03.png)'
- en: 'Figure 11.3: Bob sends a message to the IT group'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：Bob向IT组发送消息
- en: 'In Alice’s browser, enter the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Alice的浏览器中输入以下内容：
- en: '**To**: `Bob`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：`Bob`'
- en: '**Body**: `Bonjour Bob!`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：`你好，Bob！`'
- en: Click **Send Message**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送消息**。
- en: Note that only Bob receives the message.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，只有Bob收到了消息。
- en: 'In Charlie’s browser, enter the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Charlie的浏览器中输入以下内容：
- en: '**To**: Leave it empty.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：留空。'
- en: '**Body**: `Everybody dance now!`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：`现在大家都跳舞吧！`'
- en: Click **Send Message**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送消息**。
- en: 'Note that everyone receives the message, as shown in *Figure 11.4*:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，每个人都收到了消息，如图11.4所示：
- en: '![](img/B19587_11_04.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_11_04.png)'
- en: 'Figure 11.4: Charlie sends a message to everyone'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：Charlie向所有人发送消息
- en: 'In Charlie’s browser, enter the following:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Charlie的浏览器中输入以下内容：
- en: '**To**: `HR,Alice`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件人**：`HR,Alice`'
- en: '**Body**: `Is anyone in HR listening?`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：`有人正在听HR吗？`'
- en: Click **Send Message**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送消息**。
- en: 'Note that Alice receives the message sent directly to her, but since the HR
    group does not exist, no one receives the message sent to that group, as shown
    in *Figure 11.5*:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Alice收到了直接发送给她的消息，但由于HR组不存在，没有收到发送给该组的消息，如图11.5所示：
- en: '![](img/B19587_11_05.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_11_05.png)'
- en: 'Figure 11.5: Charlie sends a message to Alice and a group that does not exist'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：Charlie向Alice和一个不存在的组发送消息
- en: Close the browsers and shut down the web server.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器并关闭Web服务器。
- en: Building a .NET console app client
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建.NET控制台应用程序客户端
- en: You have just seen a .NET service hosting a SignalR hub, and a JavaScript client
    exchanging messages with other clients via that SignalR hub. Now, let’s create
    a .NET client for SignalR.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到了一个.NET服务托管SignalR中心，以及一个JavaScript客户端通过该SignalR中心与其他客户端交换消息。现在，让我们创建一个.NET客户端用于SignalR。
- en: Creating a .NET client for SignalR
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SignalR的.NET客户端
- en: 'We will use a console app, although any .NET project type would need the same
    package reference and implementation code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用控制台应用程序，尽管任何.NET项目类型都需要相同的包引用和实现代码：
- en: 'Use your preferred code editor to add a new project, as defined in the following
    list:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器添加一个新项目，如下所示：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Solution file and folder: `Chapter11`'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter11`
- en: 'Project file and folder: `Northwind.SignalR.Client.Console`'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.SignalR.Client.Console`
- en: 'Add a package reference for the ASP.NET Core SignalR client and a project reference
    for `Northwind.Common`, treat warnings as errors, and globally and statically
    import the `System.Console` class, as shown in the following markup:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为ASP.NET Core SignalR客户端添加包引用，并为`Northwind.Common`添加项目引用，将警告视为错误，并在全局和静态导入`System.Console`类，如下所示：
- en: '[PRE15]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Build the project to restore packages and build referenced projects.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包并构建引用的项目。
- en: 'In `Program.cs`, delete the existing statements, import namespaces for working
    with SignalR as a client and the chat models, and then add statements to prompt
    the user to enter a username and groups to register with, create a hub connection,
    and finally, listen for received messages, as shown in the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，导入用于作为客户端处理 SignalR 和聊天模型的命名空间，然后添加语句提示用户输入用户名和要注册的组，创建中心连接，并最终监听接收到的消息，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing the .NET console app client
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 .NET 控制台应用程序客户端
- en: 'Let’s start the SignalR service and call it from the console app:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 SignalR 服务，并在控制台应用程序中调用它：
- en: Start the `Northwind.SignalR.Service.Client.Mvc` project website using the `https`
    profile without debugging.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 配置文件（不进行调试）启动 `Northwind.SignalR.Service.Client.Mvc` 项目的网站。
- en: Start Chrome and navigate to `https://localhost:5111/`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Chrome 并导航到 `https://localhost:5111/`。
- en: Click **Register User**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **注册用户**。
- en: Start the `Northwind.SignalR.Client.Console` project.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.SignalR.Client.Console` 项目。
- en: 'Enter your name and the groups: `Sales,Admins`.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你的名字和组：`Sales,Admins`。
- en: Arrange the browser and console app windows so that you can see both simultaneously.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器和控制台应用程序窗口排列好，以便你可以同时看到它们。
- en: 'In Alice’s browser, enter the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Alice 的浏览器中输入以下内容：
- en: '**To**: `Sales`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送到**：`Sales`'
- en: '**Body**: `Go team!`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：`Go team!`'
- en: '**C**lick **Send Message**, and note that Alice and you receive the message,
    as shown in *Figure 11.6*:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**点击** **发送消息**，并注意 Alice 和你都能收到消息，如图 *11.6* 所示：'
- en: '![](img/B19587_11_06.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_11_06.png)'
- en: 'Figure 11.6: Alice sends a message to the Sales team including a user in a
    console app'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：Alice 在控制台应用程序中向销售团队发送消息，包括一个用户
- en: In the console app, press *Enter* to stop it from listening.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，按 *Enter* 键停止监听。
- en: Close Chrome and shut down the web server.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Chrome 并关闭 Web 服务器。
- en: Streaming data using SignalR
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SignalR 进行数据流
- en: So far, we have seen how SignalR can broadcast structured messages to one or
    more clients. This works well with data that is relatively small and structured
    and exists completely at a point in time. But what about data that comes in parts
    over time?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 SignalR 如何向一个或多个客户端广播结构化消息。这对于相对较小且结构化的数据，并且完全存在于某个时间点的情况效果很好。但是，对于随着时间的推移分批到达的数据怎么办呢？
- en: '**Streams** can be used for these scenarios. SignalR supports both service-to-client
    (downloading data from a stream) and client-to-service (uploading data to a stream).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**可以用于这些场景。SignalR 支持服务到客户端（从流中下载数据）和客户端到服务（将数据上传到流）。'
- en: To enable download streaming, a hub method must return `IAsyncEnumerable<T>`
    (only supported by C# 8 or later) or `ChannelReader<T>`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用下载流，中心方法必须返回 `IAsyncEnumerable<T>`（仅支持 C# 8 或更高版本）或 `ChannelReader<T>`。
- en: To enable upload streaming, a hub method must accept a parameter of type `IAsyncEnumerable<T>`
    (only supported by C# 8 or later) or `ChannelReader<T>`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用上传流，中心方法必须接受类型为 `IAsyncEnumerable<T>`（仅支持 C# 8 或更高版本）或 `ChannelReader<T>`
    的参数。
- en: Defining a hub for streaming
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用于流的中心
- en: 'Let’s add some streaming methods to see how they work in action:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些流方法来看看它们在实际操作中的工作情况：
- en: 'In the `Northwind.Common` project, add a new file named `StockPrice.cs` and
    modify its content to define a `record` for stock price data, as shown in the
    following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.Common` 项目中，添加一个名为 `StockPrice.cs` 的新文件，并修改其内容以定义股票价格数据的 `record`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Build the `Northwind.SignalR.Service.Client.Mvc` project to update its referenced
    projects.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `Northwind.SignalR.Service.Client.Mvc` 项目以更新其引用的项目。
- en: 'In the `Northwind.SignalR.Service.Client.Mvc` project, add a new class named
    `StockPriceHub.cs`, and modify its contents to define a hub with two streaming
    methods, as shown in the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.SignalR.Service.Client.Mvc` 项目中，添加一个名为 `StockPriceHub.cs` 的新类，并修改其内容以定义一个具有两个流方法的中心，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `Northwind.SignalR.Service.Client.Mvc` project, in `Program.cs`, register
    the stock price hub after the statement that registers the chat hub, as shown
    in the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.SignalR.Service.Client.Mvc` 项目的 `Program.cs` 中，在注册聊天中心的语句之后注册股票价格中心，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating a .NET console app client for streaming
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于流传输的 .NET 控制台应用程序客户端
- en: 'Now, we can create a simple client to download a stream of data from the SignalR
    hub and upload a stream of data to the SignalR hub:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个简单的客户端来从 SignalR 中心下载数据流并将其上传到 SignalR 中心：
- en: 'Use your preferred code editor to add a new project, as defined in the following
    list:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器添加一个新项目，如下面的列表所示：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Solution file and folder: `Chapter11`'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter11`
- en: 'Project file and folder: `Northwind.SignalR.Client.Console.Streams`'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.SignalR.Client.Console.Streams`
- en: 'In the `Northwind.SignalR.Client.Console.Streams` project file, treat warnings
    as errors, add a package reference for the ASP.NET Core SignalR client, add a
    project reference to `Northwind.Common`, and globally and statically import the
    `System.Console` class, as shown highlighted in the following markup:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.SignalR.Client.Console.Streams` 项目文件中，将警告视为错误，添加 ASP.NET Core SignalR
    客户端包引用，添加对 `Northwind.Common` 的项目引用，并全局和静态导入 `System.Console` 类，如下所示突出显示的标记：
- en: '[PRE20]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `Northwind.SignalR.Client.Console.Streams` project, add a new class
    file named `Program.Methods.cs`, and modify its content to define static methods
    in the partial `Program` class to generate ten random four-letter stock codes
    asynchronously, as shown in the following code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.SignalR.Client.Console.Streams` 项目中，添加一个名为 `Program.Methods.cs`
    的新类文件，并修改其内容以在部分 `Program` 类中定义静态方法，异步生成十个四字母的随机股票代码，如下所示代码：
- en: '[PRE21]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `Northwind.SignalR.Client.Console.Streams` project, in `Program.cs`,
    delete the existing statements. Import namespaces for working with SignalR as
    a client, and then add statements to prompt the user to enter a stock, create
    a hub connection, listen for received streams of stock prices, and then send an
    asynchronous stream of stocks to the service, as shown in the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.SignalR.Client.Console.Streams` 项目中，在 `Program.cs` 中删除现有语句。导入用于作为客户端处理
    SignalR 的命名空间，然后添加提示用户输入股票、创建 Hub 连接、监听接收到的股票价格流，并将异步股票流发送到服务的语句，如下所示代码：
- en: '[PRE22]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Testing the streaming service and client
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试流服务客户端
- en: 'Finally, we can test the streaming data functionality:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试流数据功能：
- en: Start the `Northwind.SignalR.Service.Client.Mvc` project website using the `https`
    profile without debugging.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `https` 配置不带调试启动 `Northwind.SignalR.Service.Client.Mvc` 项目网站。
- en: Start the `Northwind.SignalR.Client.Console.Streams` console app without debugging.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动 `Northwind.SignalR.Client.Console.Streams` 控制台应用程序。
- en: Arrange the console windows for the ASP.NET Core MVC website and the client
    console app so that you can see both side by side.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ASP.NET Core MVC 网站和客户端控制台应用程序的控制台窗口排列在一起，以便你可以并排看到它们。
- en: 'In the client console app, press *Enter* to use the Microsoft stock code, as
    shown in the following output:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端控制台应用程序中，按 *Enter* 使用微软股票代码，如下所示输出：
- en: '[PRE23]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the website console window, wait for about ten seconds, and note that several
    stock prices have been generated in the service but not yet sent to the client,
    as shown in the following output:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站控制台窗口中等待大约十秒钟，并注意在服务中已生成但尚未发送给客户端的几个股票价格，如下所示输出：
- en: '[PRE24]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the client console app, press *n* to receive the next updated price. Keep
    pressing *n* until the prices have been sent from the service and read by the
    client, and then press *y*, and note that a cancellation token is received by
    the SignalR service so it stops, and the client now starts uploading stocks, as
    shown in the following output:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端控制台应用程序中，按 *n* 接收下一个更新的价格。继续按 *n* 直到服务发送价格并由客户端读取，然后按 *y*，注意 SignalR 服务收到一个取消令牌所以停止，客户端现在开始上传股票，如下所示输出：
- en: '[PRE25]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the website console window, note that the random stock codes are received,
    as shown in the following output:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站控制台窗口中，注意接收到了随机股票代码，如下所示输出：
- en: '[PRE26]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Close both console windows.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭两个控制台窗口。
- en: Practicing and exploring
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作和深入探索本章主题来测试你的知识和理解。
- en: Exercise 11.1 – Test your knowledge
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What transports does SignalR use, and which is the default?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SignalR 使用哪些传输方式，默认的是哪种？
- en: What is a good practice for RPC method signature design?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPC 方法签名设计的好习惯是什么？
- en: What tool can you use to download the SignalR JavaScript library?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么工具下载 SignalR JavaScript 库？
- en: What happens if you send a SignalR message to a client with a connection ID
    that does not exist?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你向一个连接 ID 不存在的客户端发送 SignalR 消息会发生什么？
- en: What are the benefits of separating a SignalR service from other ASP.NET Core
    components?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SignalR 服务与其他 ASP.NET Core 组件分离有什么好处？
- en: Exercise 11.2 – Explore topics
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.2 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解更多关于本章涵盖主题的详细信息：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-11---broadcasting-real-time-communication-using-signalr](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-11---broadcasting-real-time-communication-using-signalr)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-11---broadcasting-real-time-communication-using-signalr](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-11---broadcasting-real-time-communication-using-signalr)'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: The history of technologies before SignalR.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR 之前的技术历史。
- en: The concepts and technologies that underpin SignalR.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支撑 SignalR 的概念和技术。
- en: Implementing the chat functionality using SignalR, including building a hub
    hosted in a website project, and clients using JavaScript and a .NET console app.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SignalR 实现聊天功能，包括在网站项目中构建一个 hub，以及使用 JavaScript 和 .NET 控制台应用程序的客户端。
- en: Downloading and uploading streams of data using SignalR.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SignalR 下载和上传数据流。
- en: In the next chapter, you will learn about GraphQL, another standard that enables
    client control over the data returned from a service.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解 GraphQL，这是另一个允许客户端控制从服务返回的数据的标准。
