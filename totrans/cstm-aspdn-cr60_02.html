<html><head></head><body>
		<div id="_idContainer010">
			<h1 id="_idParaDest-25"><em class="italic"><a id="_idTextAnchor031"/>Chapter 2</em>: Customizing App Configuration</h1>
			<p>This second chapter is about application configuration, how to use it, and how to customize the ASP.NET configuration to employ different ways to configure your app. Perhaps you already have an existing <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) configuration or want to share a <strong class="bold">YAML Ain't Markup Language</strong> (<strong class="bold">YAML</strong>) configuration file over different kinds of applications. Sometimes, it also makes sense to read configuration values out of a database. </p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Configuring the configuration</li>
				<li>Using typed configurations</li>
				<li>Configuration using <strong class="bold">Initialization</strong> (<strong class="bold">INI</strong>) files</li>
				<li>Configuration providers</li>
			</ul>
			<p><a id="_idTextAnchor032"/>The topics in this chapter refer to the hosting layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_2.1_B17996.jpg" alt="Figure 2.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-26">T<a id="_idTextAnchor033"/><a id="_idTextAnchor034"/>echnical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) application. Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new mvc -n ConfigureSample -o ConfigureSample</p>
			<p>Now, open the project in Visual Studio by double-clicking the project file or, in <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), by typing the following command in the already open console:</p>
			<p class="source-code">cd ConfigureSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter02">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor035"/>Configuring the configuration</h1>
			<p>Let's start by looking at how<a id="_idIndexMarker016"/> to configure your various configuration options. </p>
			<p>Since ASP.NET Core 2.0, the configuration is hidden in the default configuration of <strong class="source-inline">WebHostBuilder</strong> and is no longer part of <strong class="source-inline">Startup.cs</strong>. This helps to keep the startup clean and simple. </p>
			<p>In ASP.NET Core 3.1 up to ASP.NET Core 5.0, the code looks like this:</p>
			<p class="source-code">// ASP.NET Core 3.0 and later</p>
			<p class="source-code">public class Program</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static void Main(string[] args)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        CreateWebHostBuilder(args).Build().Run();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static IHostBuilder CreateHostBuilder(string[] </p>
			<p class="source-code">      args) =&gt;</p>
			<p class="source-code">        Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">            .ConfigureWebHostDefaults(webBuilder =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                webBuilder.UseStartup&lt;Startup&gt;();</p>
			<p class="source-code">            }</p>
			<p class="source-code">}</p>
			<p>In ASP.NET Core 6.0, Microsoft<a id="_idIndexMarker017"/> introduced the minimal <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) approach that simplifies<a id="_idIndexMarker018"/> the configuration a lot. This doesn't use <strong class="source-inline">Startup</strong> and adds all the configuration in the <strong class="source-inline">Program.cs</strong> file. Let's see how it looks here:</p>
			<p class="source-code">Var builder = WebApplication.CreateBuilder(args);</p>
			<p class="source-code">// Add services to the container.</p>
			<p class="source-code">builder.Services.AddControllersWithViews();</p>
			<p class="source-code">var app = builder.Build();</p>
			<p class="source-code">// The rest of the file isn't relevant for this chapter</p>
			<p>Fortunately, in both versions, you are also able to override the default settings to customize the configuration in the way you need it. In both versions, we extend <strong class="source-inline">IWebHostBuilder</strong> with the <strong class="source-inline">ConfigureAppConfiguration()</strong> method where the magic will happen.</p>
			<p>This is what the configuration looks like in ASP.NET Core 3.1 and ASP.NET Core 5.0:</p>
			<p class="source-code">Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">    .ConfigureWebHostDefaults(webBuilder =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        webBuilder</p>
			<p class="source-code">          .ConfigureAppConfiguration((builderContext,</p>
			<p class="source-code">            config) =&gt;</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // configure configuration here</p>
			<p class="source-code">        })</p>
			<p class="source-code">        .UseStartup&lt;Startup&gt;();</p>
			<p class="source-code">    });</p>
			<p>This is what the code looks like when using<a id="_idIndexMarker019"/> the minimal API approach. You also can use <strong class="source-inline">ConfigureAppConfiguration</strong> to configure the app configuration:</p>
			<p class="source-code">builder.WebHost.ConfigureAppConfiguration((builderContext, config) =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    // configure configuration here</p>
			<p class="source-code">});</p>
			<p>But there is a much simpler approach, by accessing the <strong class="source-inline">Configuration</strong> property of the builder:</p>
			<p class="source-code">builder.Configuration.AddJsonFile(</p>
			<p class="source-code">     "appsettings.json",</p>
			<p class="source-code">     optional: false,</p>
			<p class="source-code">     reloadOnChange: true);</p>
			<p>When you create a new ASP.NET Core project, you will already have <strong class="source-inline">appsettings.json</strong> and <strong class="source-inline">appsettings.Development.json</strong> configured. You can, and should, use these configuration files to configure your app; this is the preconfigured way, and most ASP.NET Core developers will look for an <strong class="source-inline">appsettings.json</strong> file to configure the application. This is absolutely fine and works pretty well.</p>
			<p>The following code snippet shows the encapsulated<a id="_idIndexMarker020"/> default configuration to read the <strong class="source-inline">appsettings.json</strong> files:</p>
			<p class="source-code">var env = builder.Environment;</p>
			<p class="source-code">builder.Configuration.SetBasePath(env.ContentRootPath);</p>
			<p class="source-code">builder.Configuration.AddJsonFile(</p>
			<p class="source-code">    "appsettings.json", </p>
			<p class="source-code">    optional: false, </p>
			<p class="source-code">    reloadOnChange: true);</p>
			<p class="source-code">builder.Configuration.AddJsonFile(</p>
			<p class="source-code">    $"appsettings.{env.EnvironmentName}.json", </p>
			<p class="source-code">    optional: true, </p>
			<p class="source-code">    reloadOnChange: true);</p>
			<p class="source-code">builder.Configuration.AddEnvironmentVariables();</p>
			<p>This configuration also sets the base path of the application and adds the configuration via environment variables. </p>
			<p>Whenever you customize the application configuration, you should add the configuration via environment variables as a final step, using the <strong class="source-inline">AddEnvironmentVariables()</strong> method. The order of the configuration matters and the configuration providers that you add later on will override the configurations added previously. Be sure that the environment variables always override the configurations that are set via a file. This way, you also ensure that the configuration of your application on an Azure App Service will be passed to the application as environment variables.</p>
			<p><strong class="source-inline">IConfigurationBuilder</strong> has a lot of extension methods to add more configurations, such as XML or INI configuration files and in-memory configurations. You can find additional configuration providers built by the community to read in YAML files, database values, and<a id="_idIndexMarker021"/> a lot more. In an upcoming section, we will see how to read INI files. First, we will look at using typed configurati<a id="_idTextAnchor036"/><a id="_idTextAnchor037"/>ons.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor038"/>Using typed configurations</h1>
			<p>Before trying to read INI files, it makes<a id="_idIndexMarker022"/> sense for you to see how to use typed configurations instead of reading the configuration via <strong class="source-inline">IConfiguration</strong>, key by key.</p>
			<p>To read a typed configuration, you need to define the type to configure. I usually create a class called <strong class="source-inline">AppSettings</strong>, as follows:</p>
			<p class="source-code">namespace ConfigureSample;</p>
			<p class="source-code">public class AppSettings</p>
			<p class="source-code">{</p>
			<p class="source-code">    public int Foo { get; set; }</p>
			<p class="source-code">    public string Bar { get; set; }</p>
			<p class="source-code">}</p>
			<p>This is a simple <strong class="bold">Plain Old CLR Object</strong> (<strong class="bold">POCO</strong>) class that will only contain the application setting<a id="_idIndexMarker023"/> values, as illustrated in the following code snippet. These classes can then be filled with specific configuration sections inside the <strong class="source-inline">ConfigureServices</strong> method in <strong class="source-inline">Startup.cs</strong> until ASP.NET Core 5.0:</p>
			<p class="source-code">services.Configure&lt;AppSettings&gt;</p>
			<p class="source-code">   (Configuration.GetSection("AppSettings"));</p>
			<p>Using the minimal API approach, you need to configure the <strong class="source-inline">AppSettings</strong> class, like this:</p>
			<p class="source-code">builder.Services.Configure&lt;AppSettings&gt;(</p>
			<p class="source-code">    builder.Configuration.GetSection("AppSettings"));</p>
			<p>This way, the typed configuration also gets registered as a service in the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) container and can be used everywhere<a id="_idIndexMarker024"/> in the application. You are able to create different configuration types for each configuration section. In most cases, one section should be fine, but sometimes<a id="_idIndexMarker025"/> it makes sense to divide the settings into different sections. The next snippet shows how to use the configuration in an MVC controller:</p>
			<p class="source-code">using Microsoft.Extensions.Options;</p>
			<p class="source-code">// ...</p>
			<p class="source-code">public class HomeController : Controller</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly AppSettings _options;</p>
			<p class="source-code">    public HomeController(IOptions&lt;AppSettings&gt; options)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _options = options.Value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public IActionResult Index()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        ViewData["Message"] = _options.Bar;</p>
			<p class="source-code">        return View();</p>
			<p class="source-code">    }</p>
			<p><strong class="source-inline">IOptions&lt;AppSettings&gt;</strong> is a wrapper around our <strong class="source-inline">AppSettings</strong> type, and the <strong class="source-inline">Value</strong> property contains the actual instance of <strong class="source-inline">AppSettings</strong>, including the values from the configuration file.</p>
			<p>To try reading the settings in, the <strong class="source-inline">appsettings.json</strong> file needs to have the <strong class="source-inline">AppSettings</strong> section configured, otherwise the values are null or not set. Let's now add the section<a id="_idIndexMarker026"/> to the <strong class="source-inline">appsettings.json</strong> file, as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "Logging": {</p>
			<p class="source-code">        "LogLevel": {</p>
			<p class="source-code">            "Default": "Warning"</p>
			<p class="source-code">        }</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "AllowedHosts": "*",</p>
			<p class="source-code">    "AppSettings": {</p>
			<p class="source-code">        "Foo": 123,</p>
			<p class="source-code">        "Bar": "Bar"</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Next, we'll examine how INI files can be used for confi<a id="_idTextAnchor039"/><a id="_idTextAnchor040"/>guration.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor041"/>Configuration using INI files</h1>
			<p>To also use INI files<a id="_idIndexMarker027"/> to configure the application, you will need to add the INI configuration<a id="_idIndexMarker028"/> inside the <strong class="source-inline">ConfigureAppConfiguration()</strong> method in <strong class="source-inline">Program.cs</strong>, as follows:</p>
			<p class="source-code">builder.Configuration.AddIniFile(</p>
			<p class="source-code">    "appsettings.ini", </p>
			<p class="source-code">    optional: false, </p>
			<p class="source-code">    reloadOnChange: true);</p>
			<p class="source-code">builder.Configuration.AddJsonFile(</p>
			<p class="source-code">    $"appsettings.{env.EnvironmentName}.ini", </p>
			<p class="source-code">    optional: true, </p>
			<p class="source-code">    reloadOnChange: true);</p>
			<p>This code loads the INI files the same way as the <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) configuration files. The first line is a required<a id="_idIndexMarker029"/> configuration, and the second line is an optional configuration depending on the current runtime environment.</p>
			<p>The INI file could look like this:</p>
			<p class="source-code">[AppSettings]</p>
			<p class="source-code">Bar="FooBar"</p>
			<p>As you can see, this file contains a section called <strong class="source-inline">AppSettings</strong> and a property called <strong class="source-inline">Bar</strong>.</p>
			<p>Earlier, we said<a id="_idIndexMarker030"/> that the order of the configuration matters. If you add<a id="_idIndexMarker031"/> the two lines to configure via INI files after the configuration via JSON files, the INI files will override the settings from the JSON files. The <strong class="source-inline">Bar</strong> property gets overridden with <strong class="source-inline">"FooBar"</strong> and the <strong class="source-inline">Foo</strong> property stays the same because it will not be overridden. Also, the values out of the INI file will be available via the typed configuration created previously.</p>
			<p>Every other configuration provider will work the same way. Let's now see how a configuration provi<a id="_idTextAnchor042"/><a id="_idTextAnchor043"/>der will look.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor044"/>Configuration providers</h1>
			<p>A configuration provider is an implementation of <strong class="source-inline">IConfigurationProvider</strong> that is created by a configuration source, which is an implementation of <strong class="source-inline">IConfigurationSource</strong>. The configuration provider then reads the data from somewhere and provides it via <strong class="source-inline">Dictionary</strong>.</p>
			<p>To add a custom<a id="_idIndexMarker032"/> or third-party configuration provider to ASP.NET Core, you will need to call the <strong class="source-inline">Add</strong> method on <strong class="source-inline">ConfigurationBuilder</strong> and insert the configuration source. This is just an example:</p>
			<p class="source-code">// add new configuration source</p>
			<p class="source-code">builder.Configuration.Add(new MyCustomConfigurationSource</p>
			<p class="source-code">{</p>
			<p class="source-code">    SourceConfig = //configure whatever source</p>
			<p class="source-code">    Optional = false,</p>
			<p class="source-code">    ReloadOnChange = true</p>
			<p class="source-code">});</p>
			<p>Usually, you would create an extension method to add the configuration source more easily, as illustrated here:</p>
			<p class="source-code">builder.Configuration.AddMyCustomSource("source", optional: false, reloadOnChange: true);</p>
			<p>A really detailed concrete<a id="_idIndexMarker033"/> example about how to create a custom configuration provider has been written by Andrew Lock. You can find this in the <em class="italic">Further reading</em> section <a id="_idTextAnchor045"/>of this chapter.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor046"/>Summary</h1>
			<p>In most cases, you will not need to add a different configuration provider or create your own configuration provider, but it's good to know how to change it, just in case. Also, using a typed configuration is a nice way to read and provide the settings. In classic ASP.NET, we used a manually created façade to read the application settings in a typed manner. Now, this is automatically done by just providing a type. This type will be automatically instantiated, filled, and provided, via DI.</p>
			<p>To learn more about customizing DI in ASP.NET Core 6.0, let's have a look at the next chapter.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor047"/>Further reading</h1>
			<p>You can refer to the following source for m<a id="_idTextAnchor048"/>ore information:</p>
			<ul>
				<li><em class="italic">Creating a custom ConfigurationProvider in ASP.NET Core to parse YAML</em>, <em class="italic">Andrew Lock</em>: <a href="https://andrewlock.net/creating-a-custom-iconfigurationprovider-in-asp-net-core-to-parse-yaml/">https://andrewlock.net/creating-a-custom-iconfigurationprovider-in-asp-net-core-to-parse-yaml/</a></li>
			</ul>
		</div>
	</body></html>