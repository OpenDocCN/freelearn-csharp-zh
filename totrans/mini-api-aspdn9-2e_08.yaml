- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Integrating Minimal APIs with Data Sources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将最小化 API 与数据源集成
- en: Despite us working with minimal APIs, an API would have to be even more minimal
    not to work with an external state, which is not to say that it doesn’t happen.
    For example, an API might be in place to simply perform a calculation or validate
    data, which, on their own, are not necessarily use cases that require some kind
    of managed data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用的是最小化 API，但为了不与外部状态交互，API 可能需要更加最小化，这并不意味着这种情况不会发生。例如，一个 API 可能仅仅用于执行计算或验证数据，这些操作本身可能并不一定需要某种类型的管理数据。
- en: However, it is fair to say that a wide range of production APIs have some element
    of **create, read, update, delete** ( **CRUD** ) functionality. In the examples
    shown in previous chapters, such as the **Employee** API and the **Todo Item**
    API, we have referred to entities or objects, all of which would be potentially
    created, updated, deleted, or retrieved. The examples we explored stored these
    domain objects in memory, meaning that they would disappear with the application
    when it is stopped. It is now time to move that data into an external data source,
    where it can be persisted and managed separately from the minimal APIs we write.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以说，广泛的实际生产 API 都包含一些 **创建、读取、更新、删除** ( **CRUD** ) 功能。在前面章节中展示的示例中，例如 **Employee**
    API 和 **Todo Item** API，我们提到了实体或对象，所有这些都有可能被创建、更新、删除或检索。我们探索的示例将这些域对象存储在内存中，这意味着当应用程序停止时，它们会消失。现在是时候将数据移动到外部数据源，在那里它可以被持久化并独立于我们编写的最小化
    API 进行管理。
- en: We will explore two fundamental methods of moving data between data sources
    in this book. Firstly, in this chapter, we will explore direct database connections
    with the **SqlConnection** type in addition to MongoDB Driver for SQL and NoSQL
    database types, respectively. The next chapter will cover the second method, which
    is **object-relational mapping** ( **ORM** ). Each method has its own configuration
    requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将探讨在数据源之间移动数据的两种基本方法。首先，在本章中，我们将探索使用 **SqlConnection** 类型直接与 SQL 和 NoSQL
    数据库类型进行数据库连接，以及 MongoDB 驱动。下一章将涵盖第二种方法，即 **对象关系映射** ( **ORM** )。每种方法都有自己的配置要求。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding data integration in minimal APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解最小化 API 中的数据集成
- en: Connecting to SQL Server with **SQLConnection**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **SqlConnection** 连接到 SQL Server
- en: Connecting to a NoSQL database with a MongoDB Driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB 驱动连接到 NoSQL 数据库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter is quite hands-on, using several different technologies. As a
    result, you will need the following to be installed on your machine:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章非常注重实践，使用了多种不同的技术。因此，你需要在你的机器上安装以下内容：
- en: Visual Studio 2022
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: Microsoft SQL Server 2022 Developer Edition
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server 2022 开发者版
- en: Microsoft SQL Server Management Studio
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server Management Studio
- en: MongoDB Community Server
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Community Server
- en: MongoDB Compass
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Compass
- en: You will need to download and install all of the listed software. Installation
    for all products is wizard-based, so follow each of the wizards until you have
    them installed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载并安装所有列出的软件。所有产品的安装都是基于向导的，所以按照每个向导的指示操作，直到它们被安装。
- en: You might already have Visual Studio 2022 installed if you have been following
    along with the code examples in previous chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随前几章中的代码示例，你可能已经安装了 Visual Studio 2022。
- en: If you have been using Visual Studio Code, it is recommended that you now switch
    to Visual Studio 2022.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用 Visual Studio Code，建议你现在切换到 Visual Studio 2022。
- en: Alternatively, you can host your SQL and MongoDB servers on a cloud platform,
    such as Microsoft Azure or **Amazon Web Services** ( **AWS** ). Please note that
    the configuration and deployment of these data sources in the cloud are outside
    of the scope of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以在云平台上托管你的 SQL 和 MongoDB 服务器，例如 Microsoft Azure 或 **Amazon Web Services**
    ( **AWS** )。请注意，这些数据源在云中的配置和部署超出了本书的范围。
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
- en: Understanding data integration in minimal APIs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解最小化 API 中的数据集成
- en: In the first chapter, we defined APIs and their purpose. It is worth reiterating
    this definition in relation to data sources. APIs act as a gateway to a system,
    offering programmatic access to that system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们定义了 API 及其目的。在数据源方面重申这个定义是值得的。API 作为系统的网关，提供对该系统的编程访问。
- en: In many cases, the objective of a client connecting to a system via an API is
    to work with data. That data has to be stored somewhere – preferably a source
    separate from the API itself so that it can be externally managed and persistent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，客户端通过 API 连接到系统的目的是处理数据。这些数据必须存储在某处——最好是 API 本身之外的源，以便可以外部管理和持久化。
- en: minimal APIs offer various connection methods to data sources. For the purposes
    of this chapter, we are going to focus on the most common persistent data storage
    types, those being **SQL** and **NoSQL** .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最小 API 为数据源提供各种连接方法。为了本章的目的，我们将重点关注最常见的持久数据存储类型，即 **SQL** 和 **NoSQL**。
- en: SQL versus NoSQL
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 与 NoSQL
- en: It’s highly likely that as a reader of this book, you are at least somewhat
    familiar with SQL and NoSQL, but by way of a brief primer, SQL databases are relational
    databases, meaning that data is stored in a collection of tables, with records
    represented by rows and columns in each table. NoSQL is less structured than SQL
    in that the data can be stored in various formats, including documents, key-value
    pairs, column families, or graphs. Data is stored in these various formats in
    collections of entities.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的读者，你很可能至少对 SQL 和 NoSQL 有一定的了解，但为了简短介绍，SQL 数据库是关系型数据库，这意味着数据存储在一系列表中，每个表中的记录由行和列表示。NoSQL
    比 SQL 结构更松散，因为数据可以存储在各种格式中，包括文档、键值对、列族或图。数据以这些各种格式存储在实体集合中。
- en: 'There are many SQL and NoSQL products to choose from, with the mainstream ones
    outlined in *Table 8.1* :'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 SQL 和 NoSQL 产品可供选择，其中主流产品在 *表 8.1* 中概述：
- en: '| **Relational Databases** | **NoSQL Databases** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **关系型数据库** | **NoSQL 数据库** |'
- en: '| MySQL | Mongo DB ( document store) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | MongoDB (文档存储) |'
- en: '| PostgreSQL | Cassandra (column family store) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | Cassandra (列族存储) |'
- en: '| Microsoft SQL Server | Redis ( key-value store) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 微软 SQL Server | Redis (键值存储) |'
- en: '| Oracle Database | DynamoDB ( key-value store) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Oracle 数据库 | DynamoDB (键值存储) |'
- en: '| SQLite | CouchDB ( document store) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| SQLite | CouchDB (文档存储) |'
- en: '| MariaDB | Cosmos DB ( multi-model database) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| MariaDB | Cosmos DB (多模型数据库) |'
- en: 'Table 8.1: Examples of mainstream database platforms'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1：主流数据库平台的示例
- en: Regardless of whether the data stores are SQL- or NoSQL-based, there are numerous
    ways that minimal APIs can access them, with different design patterns that can
    be adopted to ensure the consistency and integrity of the data being managed between
    the database and the API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不论数据存储是基于 SQL 还是 NoSQL，都有许多方式可以让最小化 API 访问它们，可以采用不同的设计模式来确保在数据库和 API 之间管理的数据的一致性和完整性。
- en: We’re going to start exploring data sources via minimal APIs with a direct connection
    to a SQL database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始通过最小 API 探索数据源，这些 API 直接连接到 SQL 数据库。
- en: Depending on your use case, the data connection method you choose is really
    important for optimal performance and security resilience, as is the way you manage
    connection lifetimes, the way queries are written, and how you pass parameters
    into commands and queries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的用例，你选择的数据连接方法对于最佳性能和安全性至关重要，同样重要的是你管理连接生命周期的办法、编写查询的方式以及将参数传递到命令和查询中的方式。
- en: Direct SQL commands offer a lot of flexibility, as they act in the same way
    as they would if you had a database IDE open and you were writing queries in them.
    A connection is initiated to a database, a query or command is executed, and then
    the connection is disposed of.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 直接 SQL 命令提供了很多灵活性，因为它们的作用方式就像你打开了数据库 IDE 并在其中编写查询一样。与数据库建立连接，执行查询或命令，然后断开连接。
- en: Let us start by exploring direct connection methods. We will continue to use
    the example of the **Employee** API, first connecting to a Microsoft SQL database,
    and then connecting to a MongoDB instance (NoSQL).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先探索直接连接方法。我们将继续使用 **Employee** API 的例子，首先连接到 Microsoft SQL 数据库，然后连接到 MongoDB
    实例（NoSQL）。
- en: Connecting to and integrating with SQL databases
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到并集成 SQL 数据库
- en: We will start with an example that uses Microsoft SQL. First, open SQL Server
    Management Studio and create a database called **MyCompany** , with one table,
    **Employees** .
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个使用 Microsoft SQL 的示例开始。首先，打开 SQL Server Management Studio，创建一个名为 **MyCompany**
    的数据库，其中包含一个名为 **Employees** 的表。
- en: 'You can use the SQL script in the following code block to create the table
    with the relevant columns and data types for this example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码块中的 SQL 脚本来创建具有相关列和数据类型的表：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the **Employees** table, we have set the **Id** column as an identity column,
    meaning that it will be populated by SQL Server on insertion of any record, with
    the **Id** value incrementing by **1** on each insertion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Employees** 表中，我们将 **Id** 列设置为标识列，这意味着 SQL Server 将在插入任何记录时填充它，每次插入时 **Id**
    值增加 **1**。
- en: We now have everything we need to set up a connection to the database from our
    minimal API project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了从我们的最小 API 项目设置数据库连接所需的一切。
- en: Let us go back into the **Employee** API and set up the database connection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 **Employee** API，并设置数据库连接。
- en: Configuring the connection to the database and retrieving records
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置数据库连接和检索记录
- en: 'SQL databases use a **connection string** to allow access from a code base.
    In this case, I am using Windows Authentication with my local SQL server, so I
    can use a simple connection string that assumes the currently logged-in Windows
    user is able to access my SQL server. Alternatively, if you are using a SQL server,
    you will need to generate a slightly different connection string. The simplest
    way to form the connection string is to use the guides for Microsoft SQL servers
    found at [https://connectionstrings.com](https://connectionstrings.com) , where
    (based on your authentication type) you can generate the appropriate string. The
    following code shows some simple examples of connection strings for each authentication
    type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数据库使用 **连接字符串** 来允许从代码库访问。在这种情况下，我正在使用 Windows 身份验证和我的本地 SQL 服务器，因此我可以使用一个简单的连接字符串，假设当前登录的
    Windows 用户能够访问我的 SQL 服务器。如果你使用的是 SQL 服务器，你需要生成一个稍微不同的连接字符串。形成连接字符串的最简单方法是使用 Microsoft
    SQL 服务器在 [https://connectionstrings.com](https://connectionstrings.com) 找到的指南，根据你的身份验证类型，你可以生成适当的字符串。以下代码显示了每种身份验证类型的简单连接字符串示例：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have a connection string, we can store it somewhere within the API
    where it can be easily retrieved. A good place to do this would be in a configuration
    file, which is, by default, offered to us in the form of **appsettings.json**
    .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了连接字符串，我们就可以将其存储在API的某个地方，以便可以轻松检索。一个不错的选择是将它放在配置文件中，默认情况下，它以 **appsettings.json**
    的形式提供给我们。
- en: 'Open **appsettings.json** and add your connection string as shown (I am using
    SQL authentication in my JSON example, but you will need to add your Windows Authentication
    connection string if appropriate):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '打开 **appsettings.json** 并添加你的连接字符串，如下所示（我在我的JSON示例中使用 SQL 身份验证，但如果你需要，你需要添加你的
    Windows 身份验证连接字符串）： '
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your **appsettings.json** file may have extra template values when you create
    your project. For simplicity, when following this example, it might be best to
    overwrite the content of the existing **appsettings.json** file with the example
    content shown in the preceding code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建项目时，你的 **appsettings.json** 文件可能包含额外的模板值。为了简化，在遵循此示例时，最好是将现有 **appsettings.json**
    文件的内容覆盖为前面代码中显示的示例内容。
- en: Next, we will create a service that will manage the interactions with the database.
    This service will be injected into our API endpoints using dependency injection
    (see [*Chapter 7*](B20968_07.xhtml#_idTextAnchor119) for more details on dependency
    injection).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个服务来管理与数据库的交互。这个服务将通过依赖注入（见 [*第7章*](B20968_07.xhtml#_idTextAnchor119)
    了解依赖注入的更多细节）注入到我们的API端点。
- en: 'We will register the service as a **singleton** . Doing this allows us to cleanly
    specify that there should only be one instance of the service, meaning that any
    requests coming into the API will share that service. Let us first get started
    with the creation of this database service by creating a new interface called
    **IDatabaseService** . This interface will lay out the **contract** for any services
    that are created for the purposes of speaking to a database:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册该服务为 **单例**。这样做可以让我们清楚地指定应该只有一个服务实例，这意味着进入API的任何请求都将共享该服务。让我们首先通过创建一个名为
    **IDatabaseService** 的新接口来开始创建这个数据库服务的创建。这个接口将为任何创建用于与数据库通信的服务定义 **契约**：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don’t worry if you see an error at this point stating that **Employee** isn’t
    a known type. When it is created later, this error will clear.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在此时看到错误信息，指出 **Employee** 不是一个已知的类型，请不要担心。当它稍后被创建时，这个错误将会消失。
- en: We can now create our service in the form of a concrete class that implements
    **IDatabaseService** . Create the class, calling it **SQLService** .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个实现 **IDatabaseService** 的具体类来形成我们的服务。创建这个类，命名为 **SQLService**。
- en: Once the **SQLService** class has been created, add a constructor that receives
    **IConfiguration** as a parameter, saving its value to a local **readonly** field.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 **SQLService** 类，添加一个构造函数，它接收 **IConfiguration** 作为参数，并将它的值保存到一个局部的 **readonly**
    字段中。
- en: More on IConfiguration
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 IConfiguration 的信息
- en: '**IConfiguration** is already registered for dependency injection in an ASP.NET
    application. It represents the content of **appsettings.json** .'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**IConfiguration** 已经在 ASP.NET 应用程序中注册用于依赖注入。它代表了 **appsettings.json** 的内容。'
- en: 'This field will contain the connection string, and will allow it to be referenced
    in all queries and commands executed by the service, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段将包含连接字符串，并允许它在服务执行的所有查询和命令中引用，如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we’re going to finish off this service by adding the ability to add and
    retrieve employee records from the database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加添加和检索员工记录的功能来完善这个服务。
- en: 'We will use the same **Employee** class that we added in the examples from
    previous chapters. As a convenient reminder, this code block shows the **Employee**
    class that will act as the model for the database records:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前章节示例中添加的相同的 **Employee** 类。作为一个方便的提醒，这个代码块显示了将作为数据库记录模型的 **Employee**
    类：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will be seeing errors by now (in the Visual Studio error list, and in the
    form of red lines under the code) stating that the class does not fully implement
    the **IDatabaseService** interface. We should add the two functions specified
    in the interface to the **SqlService** class to correct this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能会看到一些错误（在 Visual Studio 错误列表中，以及代码下方的红色线条形式）指出类没有完全实现 **IDatabaseService**
    接口。我们应该将接口中指定的两个函数添加到 **SqlService** 类中，以纠正这个问题。
- en: 'Let’s start with **GetEmployeesAsync()** . The aim of this function is to return
    a list containing all the employees in the database. Start by creating the function
    definition and, in the body, instantiate a new **Employee** list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 **GetEmployeesAsync()** 开始。这个函数的目的是返回包含数据库中所有员工的列表。首先创建函数定义，并在主体中实例化一个新的
    **Employee** 列表：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before going further, make sure you add the **Microsoft.Data.SqlClient** NuGet
    package, as this will be required. You can do this by going to **Tools** | **Manage
    NuGet Packages** | **Package Manager Console** , and then typing the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经添加了 **Microsoft.Data.SqlClient** NuGet 包，因为这将是有必要的。你可以通过前往 **工具**
    | **管理 NuGet 包** | **包管理器控制台**，然后输入以下命令来完成此操作：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will open a new connection to SQL Server using **SqlConnection** .
    By wrapping the instance in a **using** statement, we are ensuring that once the
    control flow ha s exited the body of the **using** statement, the connection is
    automatically disposed of, thanks to **SqlConnection** implementing **IDisposable**
    :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 **SqlConnection** 打开一个新的 SQL Server 连接。通过将实例包裹在一个 **using** 语句中，我们确保一旦控制流离开了
    **using** 语句的主体，连接就会自动释放，这得益于 **SqlConnection** 实现了 **IDisposable** 接口：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, you have a connection open that will be automatically disposed
    of. This is good because we’re responsibly managing the use of an external resource.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你已经打开了一个将会自动释放的连接。这是好事，因为我们正在负责任地管理外部资源的使用。
- en: 'Next, inside the **using** statement, another **using** statement is added,
    but this time, for the creation of a **SqlCommand** object. This **SqlCommand**
    object represents the query we wish to execute, targeting the connection we now
    have open:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 **using** 语句内部，添加另一个 **using** 语句，但这次是为了创建一个 **SqlCommand** 对象。这个 **SqlCommand**
    对象代表了我们要执行的查询，针对我们现在打开的连接：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Following this, we nest another **using** statement inside this one. This creates
    **SqlDataReader** , reading any returned rows from the query in **SqlCommand**
    , creating a new **Employee** instance for each record, and adding it to the list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在这个语句内部嵌套另一个 **using** 语句。这创建了 **SqlDataReader**，读取 **SqlCommand** 中返回的任何行，为每条记录创建一个新的
    **Employee** 实例，并将其添加到列表中：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can finish the function by returning the list of type **Employee**
    , meaning the finished function looks like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过返回类型为 **Employee** 的列表来结束这个函数，这意味着最终的函数看起来如下所示：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take a look at the **SqlCommand** usage in the previous code. Notice how we
    don’t build the SQL command string using concatenation, passing in the values
    from **Employee** as part of the string being put together. Instead, the best
    practice is to use SQL parameters. Parameterized queries allow us to guard against
    a security vulnerability called SQL injection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前一段代码中**SqlCommand**的使用。注意我们不是通过连接来构建SQL命令字符串，而是将**Employee**的值作为字符串的一部分传递。相反，最佳实践是使用SQL参数。参数化查询使我们能够防止一种称为SQL注入的安全漏洞。
- en: In a SQL injection attack, a malicious value is passed in as a value, which
    can alter the originally intended behavior of a command. By passing in parameters,
    we avoid this, with parameters represented by the **@** character in the command
    string and added to the **SqlCommand** after the string is formed (we see this
    in the next section).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL注入攻击中，一个恶意值作为值传递，可能会改变命令的原始预期行为。通过传递参数，我们可以避免这种情况，参数在命令字符串中以**@**字符表示，并在字符串形成后添加到**SqlCommand**中（我们将在下一节中看到这一点）。
- en: Inserting Employee records
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入员工记录
- en: 'We have now completed our first connection to SQL with a transaction. Armed
    with this knowledge, we can also create the **AddEmployeeAsync()** function. The
    connection method is the same but the command is different, with **INSERT** being
    used instead of **SELECT** :'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了与SQL的第一个连接，并使用事务。有了这些知识，我们也可以创建**AddEmployeeAsync()**函数。连接方法相同，但命令不同，使用**INSERT**而不是**SELECT**：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let us now turn our attention to the minimal API endpoints.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将注意力转向最小的API端点。
- en: Executing database transactions from API endpoints
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从API端点执行数据库事务
- en: These endpoints will need to have the SQL service injected into them in order
    for them to be used in the endpoint body.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点需要注入SQL服务，以便在端点体中使用。
- en: 'Go back to **Program.cs** and register the service as a singleton:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**Program.cs**，将服务注册为单例：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because we have created a service for managing interaction with the SQL server
    and we have made it easily available through dependency injection, getting and
    creating employees from minimal API endpoints is very easy. Simply add a **GET**
    endpoint for retrieval and a **POST** endpoint for creation, adding calls to the
    appropriate functions we created in **SqlService** :'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经创建了一个用于管理与SQL服务器交互的服务，并且我们已经通过依赖注入使其易于使用，所以从最小的API端点获取和创建员工非常容易。只需为检索添加一个**GET**端点，为创建添加一个**POST**端点，并添加对我们在**SqlService**中创建的适当函数的调用：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Give the new endpoints a try. If successful, you should be able to retrieve
    the employees in the data source as a list or add new employees via the API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试新的端点。如果成功，你应该能够以列表形式检索数据源中的员工或通过API添加新员工。
- en: As alluded to earlier in the chapter, because we have created an interface,
    we should be able to swap out the service for one that uses a different data source
    without having to change the endpoint. This leads us nicely to an example of a
    database connection to a NoSQL database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，因为我们创建了一个接口，所以我们应该能够替换为使用不同数据源的服务，而无需更改端点。这很自然地引出了到NoSQL数据库的数据库连接示例。
- en: Connecting to MongoDB
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MongoDB
- en: For demonstrative purposes, we will connect to **MongoDB** , a widely used NoSQL
    database platform.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将连接到广泛使用的NoSQL数据库平台**MongoDB**。
- en: Before we create the service, we should first add some data to a MongoDB database.
    As per the technical requirements, you should have installed a MongoDB server,
    along with **MongoDB Compass** , a **graphical user interface** ( **GUI** ) for
    MongoDB.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建服务之前，我们应该首先向MongoDB数据库中添加一些数据。根据技术要求，你应该已经安装了MongoDB服务器，以及**MongoDB Compass**，它是MongoDB的**图形用户界面**（**GUI**）。
- en: 'Start by opening MongoDB Compass and creating a connection to your installed
    MongoDB server instance. If you’ve installed MongoDB locally without modifying
    the installation, you should be able to just click **Connect** :'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开MongoDB Compass，并创建与已安装的MongoDB服务器实例的连接。如果你没有修改安装就本地安装了MongoDB，你应该可以直接点击**连接**：
- en: '![Figure 8.1: Creating a new MongoDB connection](img/B20968_08_01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：创建新的MongoDB连接](img/B20968_08_01.jpg)'
- en: 'Figure 8.1: Creating a new MongoDB connection'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：创建新的MongoDB连接
- en: 'Once connected, you will be able to see the existing databases on your server:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 连接成功后，你将能够看到服务器上现有的数据库：
- en: '![Figure 8.2: View of existing MongoDB connections](img/B20968_08_02.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：现有MongoDB连接视图](img/B20968_08_02.jpg)'
- en: 'Figure 8.2: View of existing MongoDB connections'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：查看现有的MongoDB连接
- en: 'In the navigation bar on the left-hand side, click the plus icon to add a new
    database. Once again, we will call the database **MyCompany** . Compass will also
    require you to create a collection. Just as we created an **Employees** table
    in our SQL database, we will create an **Employees** collection in MongoDB:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧导航栏中，点击加号图标以添加一个新的数据库。再次，我们将数据库命名为**MyCompany**。Compass还会要求你创建一个集合。正如我们在SQL数据库中创建了一个**Employees**表一样，我们将在MongoDB中创建一个**Employees**集合：
- en: '![Figure 8.3: MongoDB Database creation in Compass](img/B20968_08_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：在Compass中创建MongoDB数据库](img/B20968_08_03.jpg)'
- en: 'Figure 8.3: MongoDB Database creation in Compass'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：在Compass中创建MongoDB数据库
- en: Notice how we haven’t been specified a schema for the **Employees** collection.
    This is because the collection is document-based. We can import data in JSON format,
    which mirrors the **Employee** class in our API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们并没有为**Employees**集合指定一个模式。这是因为该集合是文档型的。我们可以导入JSON格式的数据，这与我们的API中的**Employee**类相对应。
- en: 'Create a couple of fake employees and save them to a local JSON file. Here
    is some example JSON to get you started:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建几个模拟的员工并将它们保存到本地JSON文件中。以下是一些示例JSON以供你开始：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you’ve saved the JSON file, you can import it into the **Employees** collection
    in MongoDB Compass:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 保存JSON文件后，你可以将其导入MongoDB Compass中的**Employees**集合：
- en: '![Figure 8.4: Importing data into a MongoDB database in Compass](img/B20968_08_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：在Compass中导入MongoDB数据库的数据](img/B20968_08_04.jpg)'
- en: 'Figure 8.4: Importing data into a MongoDB database in Compass'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：在Compass中导入MongoDB数据库的数据
- en: Our MongoDB collection is now set up with example data. Let us turn our attention
    back to the minimal API, where we will write a new service to interact with this
    NoSQL database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用示例数据设置了MongoDB集合。让我们将注意力转回到最小API，我们将编写一个新的服务来与这个NoSQL数据库交互。
- en: 'First, we’ll need to install the MongoDB driver in order to support interactions
    with a MongoDB database. You can do this via the **Package Manager Console** in
    Visual Studio:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装MongoDB驱动程序以支持与MongoDB数据库的交互。你可以在Visual Studio的**包管理器控制台**中这样做：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new class called **MongoDbService** , implementing the **IDatabaseService**
    interface. Make sure you reference **MongoDB.Bson** and **MongoDB.Driver** :'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**MongoDbService**的新类，实现**IDatabaseService**接口。确保你引用了**MongoDB.Bson**和**MongoDB.Driver**：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will create a constructor that, as before, receives an injected **IConfiguration**
    object containing the database connection string, before initiating the connection
    with an instance of **MongoClient** .
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个构造函数，它像之前一样接收一个包含数据库连接字符串的注入的**IConfiguration**对象，然后使用**MongoClient**实例初始化连接。
- en: 'Following this, a reference to the collection of type, **Employee** can be
    retrieved and stored in a **private** field:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，可以检索并存储类型为**Employee**的集合引用到一个**private**字段中：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, complete the implementation of the **IDatabaseService** interface by
    adding the required functions. These functions can simply utilize the **Employee**
    collection for querying and inserting records:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过添加所需的函数来完成**IDatabaseService**接口的实现。这些函数可以简单地利用**Employee**集合进行查询和插入记录：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The connection string needs to be changed to point to the MongoDB server and
    database. MongoDB connection strings are fairly simple in format. By default,
    the server should be running on port **27017** . Here is how a default connection
    string would look for this configuration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将连接字符串更改为指向MongoDB服务器和数据库。MongoDB的连接字符串格式相对简单。默认情况下，服务器应该在**27017**端口上运行。以下是此配置的默认连接字符串示例：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This connection string can then be added to the **ConnectionStrings** object
    in **appsettings.json** . We should also add a Boolean flag to the JSON that allows
    us to specify whether MongoDB should be used, or whether the default SQL connection
    should be adopted.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将此连接字符串添加到**appsettings.json**中的**ConnectionStrings**对象。我们还应该在JSON中添加一个布尔标志，以便我们可以指定是否使用MongoDB，或者是否采用默认的SQL连接。
- en: 'Once complete, the **ConnectionStrings** section of **appsettings.json** should
    look like the example shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，**appsettings.json**中的**ConnectionStrings**部分应该看起来像这里所示的示例：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Having added a new data source connection string and an option to switch from
    the default source to MongoDB, we must register the new **MongoDbService** class
    for dependency injection. We will, however, also need to specify a new rule for
    how the dependency is resolved depending on whether the **UseMongoDB** flag is
    enabled or not.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新的数据源连接字符串和从默认源切换到MongoDB的选项后，我们必须为依赖注入注册新的**MongoDbService**类。然而，我们还需要根据是否启用了**UseMongoDB**标志来指定新的依赖项解析规则。
- en: Back in **Program.cs** , register the new **MongoDbService** class
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Program.cs**中，注册新的**MongoDbService**类
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the following singleton registration for **IDatabaseService** , along
    with logic that checks the MongoDB flag in **appsettings.json** before resolving
    the correct database service to be used:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下**IDatabaseService**的单例注册，以及逻辑，在解析要使用的正确数据库服务之前检查**appsettings.json**中的MongoDB标志：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might not have realized it yet if you haven’t run the code, but we have
    a problem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有运行代码，你可能还没有意识到，但我们遇到了一个问题。
- en: The aim of using an interface for **IDatabaseService** was to ensure that we
    could easily switch between data sources by modifying a Boolean flag in **appsettings.json**
    .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**IDatabaseService**接口的目的是确保我们可以通过修改**appsettings.json**中的布尔标志轻松地在数据源之间切换。
- en: This would be fine if the data structures in the two data sources had identical
    schemas. Unfortunately, they don’t because, in SQL Server, **Id** is an **int**
    type, whereas, in MongoDB, the equivilent identifier is called **_id** and its
    data type is a string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个数据源中的数据结构具有相同模式，这将很好。不幸的是，它们并不相同，因为在SQL Server中，**Id**是**int**类型，而在MongoDB中，等效的标识符称为**_id**，其数据类型是字符串。
- en: This means that as it exists currently, **Employee** is interchangeable between
    the two sources. This means that if we switch to MongoDB and try to deserialize
    data to **Employee** , it will fail with **FormatException** due to the differing
    data type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，按照目前的状况，**Employee**可以在两个源之间互换。这意味着如果我们切换到MongoDB并尝试将数据反序列化为**Employee**，由于数据类型不同，它将因**FormatException**而失败。
- en: To fix this, we should create separate models for different data sources. This
    sounds like it goes against the idea of having a flexible system, but we can still
    ensure that we don’t have to modify existing endpoints for different data sources
    by using another interface.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该为不同的数据源创建单独的模型。这听起来似乎与灵活系统的理念相悖，但我们可以通过使用另一个接口来确保我们不必为不同的数据源修改现有的端点。
- en: 'Create a new interface called **IEmployee** . It does not require any fields
    at the moment:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的接口称为**IEmployee**。目前它不需要任何字段：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can use this interface to represent an employee model generically, regardless
    of whether it is a SQL Server model or a MongoDB model.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个接口来泛型地表示员工模型，无论它是SQL Server模型还是MongoDB模型。
- en: 'Create a new model called **EmployeeMongoDb** and set it up as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的模型称为**EmployeeMongoDb**，并按以下方式设置它：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By adding the attributes shown in the previous code to the **Id** field, we
    are mapping **Id** to the string-based **_id** field in the MongoDB collection.
    We have also implemented **IEmployee** .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将之前代码中显示的属性添加到**Id**字段，我们将**Id**映射到MongoDB集合中基于字符串的**_id**字段。我们同样实现了**IEmployee**接口。
- en: We will treat **Employee** as the default model, seeing as SQL Server is the
    default connection string in **appsettings.json** . Ensure that it also implements
    **IEmployee** .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQL Server是**appsettings.json**中的默认连接字符串，我们将**Employee**视为默认模型。确保它也实现了**IEmployee**接口。
- en: Now, we must change any area in the MongoDB service or SQL service that returns
    a concrete class to instead return **IEmployee** . You’ll also need to change
    any code that receives **Employee** as an argument. This then requires the service
    to cast **IEmployee** to a compatible concrete implementation, such as **EmployeeMongoDb**
    for the **MongoDb** service.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须更改MongoDB服务或SQL服务中返回具体类的任何区域，使其返回**IEmployee**。你还需要更改任何接收**Employee**作为参数的代码。这要求服务将**IEmployee**转换为兼容的具体实现，例如**MongoDb**服务的**EmployeeMongoDb**。
- en: 'Changes to both **SqlServerService** and **MongoDbService** can be seen in
    the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**SqlServerService**和**MongoDbService**的更改可以在以下代码中看到：'
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Continuing the previous code, we add the **GetEmployeesAsync()** and **AddEmployeeAsync()**
    methods using MongoDB. Notice how, in the **AddEmployeeAsync()** method, we can
    still take in **IEmployee** but then simply convert it to an **EmployeeMongoDb**
    object so that MongoDB can take care of generating a **string** ID, unlike the
    **int** ID used in SQL Server:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 继续之前的代码，我们添加了**GetEmployeesAsync()**和**AddEmployeeAsync()**方法，使用MongoDB。注意，在**AddEmployeeAsync()**方法中，我们仍然可以接受**IEmployee**，但只需将其转换为**EmployeeMongoDb**对象，这样MongoDB就可以负责生成一个**string**
    ID，而不是SQL Server中使用的**int** ID：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following method shows the same code using SQL Server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法展示了使用SQL Server的相同代码：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because **Employee** and **EmployeeMongoDb** both implement **IEmployee** ,
    the endpoint logic no longer has to change. We are preserving genericness at the
    highest level of abstraction, while dealing with more concrete classes lower down
    the abstraction layer within the services.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Employee**和**EmployeeMongoDb**都实现了**IEmployee**，端点逻辑不再需要更改。我们在最高抽象级别上保留了通用性，同时在服务中处理抽象层较低的更具体类。
- en: Open-closed principle
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: The changes we have made using interfaces help us adhere to the open-closed
    principle, where we aim to allow new data sources to be added in the future without
    having to alter the original code base invasively. We will discuss this principle
    in more detail in [*Chapter 13*](B20968_13.xhtml#_idTextAnchor183) .
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用接口所做的更改帮助我们遵循开放封闭原则，我们的目标是允许将来在不侵入性地修改原始代码库的情况下添加新的数据源。我们将在[*第13章*](B20968_13.xhtml#_idTextAnchor183)中更详细地讨论这一原则。
- en: This was quite an intense chapter, so let’s review what we’ve covered before
    moving on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节内容相当密集，所以在继续之前，让我们回顾一下我们已经覆盖的内容。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered some basic examples of direct communication
    with a database from minimal API endpoints.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些从最小API端点直接与数据库通信的基本示例。
- en: We started by defining the different kinds of databases, with examples of various
    SQL- and NoSQL-based database platforms.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了不同类型的数据库，并提供了各种基于SQL和NoSQL数据库平台的示例。
- en: Following this, we talked about how using services with dependency injection
    can allow minimal API projects to seamlessly provide minimal API endpoints with
    interoperability with our chosen data source.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们讨论了使用具有依赖注入的服务如何允许最小API项目无缝提供具有与所选数据源互操作性的最小API端点。
- en: We created a service that interacts with a SQL Server database, using **appsettings.json**
    to define the specific properties of our data source for use in the service. We
    leveraged the functionality of **SqlConnection** and **SqlCommand** to execute
    commands and queries against the SQL Server database containing relational employee
    data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个与SQL Server数据库交互的服务，使用**appsettings.json**来定义数据源的具体属性，以便在服务中使用。我们利用**SqlConnection**和**SqlCommand**的功能来执行针对包含关系型员工数据的SQL
    Server数据库的命令和查询。
- en: Next, we created a counterpart service that interacts with MongoDB, demonstrating
    the differences between **SqlCommand** and the MongoDB driver.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个与之对应的服务，该服务与MongoDB交互，展示了**SqlCommand**与MongoDB驱动程序之间的差异。
- en: Finally, we modified the project using interfaces to make differing data source
    models interchangeable, while preserving the generic style of the API endpoint
    code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用接口修改了项目，使得不同的数据源模型可以互换，同时保留了API端点代码的通用风格。
- en: In the next chapter, we will take our exploration of data sources further by
    implementing two ORMs within the **Employee** API – Dapper and Entity Framework
    Core.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过在**Employee** API中实现两个ORM（对象关系映射）来进一步探索数据源，这两个ORM是Dapper和Entity Framework
    Core。
