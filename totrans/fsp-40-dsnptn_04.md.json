["```cs\nmatch comparison-expression with \n  | pattern-expression1 -> result-expression1 \n  ......................................... \n  | pattern-expressionN -> result-expressionN \n\n```", "```cs\n[<Literal>] \nlet THREE = 3 \n\nlet transformA v = \n  match v with \n  | 1 ->\"1\" \n  | 2 ->\"2\" \n  | THREE ->\"3\" \n\ntransformA <| (1 + 2) \n\n```", "```cs\ntype Multiples = \n  | Zero = 0 \n  | Five = 5 \n\nlet transformB ``compare me`` = \n  match ``compare me`` with \n  | Multiples.Zero ->\"0\" \n  | Multiples.Five ->\"5\" \nMultiples.Five |> transformB \n\n```", "```cs ``compare me`` ```", "```cs ``compare me`` ```", "```cs ``compare me`` ```", "```cs\nlet transformB' m = \n  match m with \n  | Multiples.Zero -> Some \"0\" \n  | Multiples.Five -> Some \"5\" \n  | _ -> None \n\n```", "```cs\nlet transformA' v = \n  match v with \n  | 1 -> \"1\" \n  | 2 -> \"2\" \n  | THREE -> \"3\" \n\n```", "```cs\nlet verifyGuid g = \n  match System.Guid.TryParse g with \n  | (true,_ as r) -> sprintf \"%s is a genuine GUID %A\" g (snd r) \n  | (_,_ as r) -> sprintf \"%s is a garbage GUID, defaults to %A\" \n                        g (snd r);; \n\n```", "```cs\nopen System \n\nlet validate keyA keyB = \n  match (keyA,keyB) with \n  | (\"\",\"\") -> \"both keys are empty\" \n  | (x,y) & ((\"\",_) | (_,\"\")) -> \n    sprintf \"one key is empty: keyA = %s; keyB = %s\" x y \n  | _ & (x,y) -> \n    sprintf \"both keys aren't empty: keyA = %s; keyB = %s\" x y \n\n```", "```cs\n| (x,y) when x = y -> sprintf \"both keys are not empty: keyA =    keyB = %s\" x\n```", "```cs\nopen System \n\nlet validate key1 key2 = (key1,key2) |> function \n  | (\"\",\"\") -> \"both keys are empty\" \n  | (x,y) & ((\"\",_) | (_,\"\")) -> \n    sprintf \"one key is empty: keyA = %s; keyB = %s\" x y \n  | (x,y) when x = y -> \n    sprintf \"both keys are not empty: keyA = keyB = %s\" x \n  | (x,y) -> \n    sprintf \"both keys aren't empty: keyA = %s; keyB = %s\" x y \n\n```"]