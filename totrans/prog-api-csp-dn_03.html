<html><head></head><body>
  <div id="_idContainer017">
   <h1 class="chapter-number" id="_idParaDest-38">
    <a id="_idTextAnchor038">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     3
    </span>
   </h1>
   <h1 id="_idParaDest-39">
    <a id="_idTextAnchor039">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Implementing with REST
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In the previous chapter, we created a simple database and object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.4.1">
      Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     ) to interact with.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     In this chapter, we’ll look
    </span>
    <a id="_idIndexMarker034">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     at the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      Representation State Transfer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      REST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     ) protocol and how it is used in APIs.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     REST is the most popular protocol for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      creating APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     We will see how REST contributes to creating a client/server architecture, and with it, desirable separation of concerns.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     We will cover the following topics in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      this chapter:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Understanding what
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       REST is
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      Looking at standard
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       web protocols
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      The first implementation of a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       REST API
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      What
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.21.1">
       Data Transfer Objects
      </span>
     </strong>
     <span class="koboSpan" id="kobo.22.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.23.1">
       DTOs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.24.1">
      ) are and how to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       use them
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Using Postman as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       our frontend
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     By the time you finish this chapter, you will understand the fundamentals of creating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      simple APIs.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-40">
    <a id="_idTextAnchor040">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     For this chapter, you will need
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.32.1">
      Visual Studio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.34.1">
      AutoMapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.35.1">
     , and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.36.1">
      Dapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.37.1">
     .
    </span>
    <span class="koboSpan" id="kobo.37.2">
     Please see
    </span>
    <a href="B21998_01.xhtml#_idTextAnchor013">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.38.1">
        Chapter 1
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.39.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.40.1">
      Getting Started
     </span>
    </em>
    <span class="koboSpan" id="kobo.41.1">
     , for how to obtain these.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     The code files for this chapter can be found in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      here:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.43.1">
       https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter03
      </span>
     </span>
    </a>
   </p>
   <h1 id="_idParaDest-41">
    <a id="_idTextAnchor041">
    </a>
    <span class="koboSpan" id="kobo.44.1">
     REST
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     One of
    </span>
    <a id="_idIndexMarker035">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     the key concepts in REST is the separation of concerns.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     This idea will be familiar to you as a C# programmer.
    </span>
    <span class="koboSpan" id="kobo.46.3">
     Here, we are separating the concerns of the server and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     The API can only respond to calls from the client, and cannot generate calls of its own.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     Note that within the logic of the API implementation, it is possible to call other APIs, but not back to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     The server is in no way dependent on the design or implementation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.51.1">
      the client.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-42">
    <a id="_idTextAnchor042">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     Client/server
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.53.1">
     The key to a
    </span>
    <a id="_idIndexMarker036">
    </a>
    <span class="koboSpan" id="kobo.54.1">
     REST application is that the API can be called by any type of client: web application, phone application, and so on.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     Further, the client can be located anywhere and there are no constraints on the architecture of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.56.1">
     The same is true for the backend, behind the API.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     Typically, this will be a database, but it can be any type of data storage: relational, object, in memory, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     One way to accomplish this, is to use the standard web protocols such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.59.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.60.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.61.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.62.1">
     , and so forth.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     This approach is essential to REST.
    </span>
    <span class="koboSpan" id="kobo.62.3">
     In fact, for many people this is the virtual definition
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      of REST.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-43">
    <a id="_idTextAnchor043">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     Using web protocols
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     In REST, we
    </span>
    <a id="_idIndexMarker037">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     use the same verbs as we do in HTTP:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.67.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.68.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.69.1">
      PUT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.73.1">
      DELETE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.74.1">
     .
    </span>
    <span class="koboSpan" id="kobo.74.2">
     In addition, the API returns standard web values to the client, for example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.75.1">
      404 (not found)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.76.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.77.1">
      200 (success)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.79.1">
      201 (created)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     , and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     Each
    </span>
    <a id="_idIndexMarker038">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     request from the client to the API will consist of an HTTP header, body, and meta-data.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     The client expresses which API is wanted by calling a URL, and passes needed data (e.g., the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.84.1">
      id value for the requested entity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     either in the URL or, if passing too much data for a URL, in the body of the request.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     For example, here is a POST to add a car to the backend database.
    </span>
    <span class="koboSpan" id="kobo.85.3">
     Don’t worry about the syntax for now; rather, take a look at the URL and the body of the request in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.86.1">
       Figure 3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.87.1">
       .1
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.88.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer012">
     <span class="koboSpan" id="kobo.89.1">
      <img alt="Figure 3.1 – Sending data for insertion" src="image/B21988_03_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.90.1">
     Figure 3.1 – Sending data for insertion
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     At the
    </span>
    <a id="_idIndexMarker039">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     top of the figure, we see the URL (https://localhost:7025/Car).
    </span>
    <span class="koboSpan" id="kobo.92.2">
     This is the “address” of the API.
    </span>
    <span class="koboSpan" id="kobo.92.3">
     Notice that the last part of the URL is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.93.1">
      Car
     </span>
    </em>
    <span class="koboSpan" id="kobo.94.1">
     .
    </span>
    <span class="koboSpan" id="kobo.94.2">
     This is the name of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.95.1">
      the controller.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.96.1">
     Below the URL is
    </span>
    <a id="_idIndexMarker040">
    </a>
    <span class="koboSpan" id="kobo.97.1">
     a menu allowing you to see the parameters being sent, the Authorization any headers that go along as meta-data (see
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.98.1">
       Figure 3
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.99.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.100.1">
     ), the body that we see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.101.1">
       Figure 3
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.102.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.103.1">
     , any scripts to run before sending the request, tests to ensure we are getting back the right data (see
    </span>
    <a href="B21998_08.xhtml#_idTextAnchor105">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.104.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.105.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.106.1">
      Advanced Topics
     </span>
    </em>
    <span class="koboSpan" id="kobo.107.1">
     ), and any settings we need for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      the request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     The numbered lines 1-12 in the preceding figure are the body of this request.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     We are inserting a car into the database and so all the data for the insertion is here in JSON format.
    </span>
    <span class="koboSpan" id="kobo.109.3">
     Notice that there is no ID; that will be assigned on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      the backend.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer013">
     <span class="koboSpan" id="kobo.111.1">
      <img alt="Figure 3.2 – Headers" src="image/B21988_03_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.112.1">
     Figure 3.2 – Headers
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     These
    </span>
    <a id="_idIndexMarker041">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     headers
    </span>
    <a id="_idIndexMarker042">
    </a>
    <span class="koboSpan" id="kobo.115.1">
     provide vital information to the server.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     They must be sent for each interaction because REST is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      inherently stateless.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor044">
    </a>
    <span class="koboSpan" id="kobo.117.1">
     Statelessness and caching
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.118.1">
     REST APIs are
    </span>
    <a id="_idIndexMarker043">
    </a>
    <span class="koboSpan" id="kobo.119.1">
     stateless, so you must treat each call to the API as independent from all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      other calls.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     Note that if you need state and you are on Azure, you’ll want a durable function, which is covered in
    </span>
    <a href="B21998_07.xhtml#_idTextAnchor094">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.122.1">
        Chapter 7
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.123.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.124.1">
      Azure
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.125.1">
       Durable Functions
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     While you
    </span>
    <a id="_idIndexMarker044">
    </a>
    <span class="koboSpan" id="kobo.128.1">
     cannot maintain state between calls, the server can cache data for faster retrieval.
    </span>
    <span class="koboSpan" id="kobo.128.2">
     This can significantly improve performance There are a number of platforms that can support REST APIs; the one we will focus on for this book, and the platform of choice for .NET, is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      ASP.NET Core.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     An alternative to REST is GraphQL.
    </span>
    <span class="koboSpan" id="kobo.130.2">
     There are two problems this designed to solve: overfetching and underfetching.
    </span>
    <span class="koboSpan" id="kobo.130.3">
     The user wants to send a single API call to the server.
    </span>
    <span class="koboSpan" id="kobo.130.4">
     In order to do this, they must designate what data is needed.
    </span>
    <span class="koboSpan" id="kobo.130.5">
     If a Car entity is requested, it may be that they don’t care at all about some of the features of the car but they get the entire car as part of the API.
    </span>
    <span class="koboSpan" id="kobo.130.6">
     This is called overfetching.
    </span>
    <span class="koboSpan" id="kobo.130.7">
     On the other hand, if they designate an API that
    </span>
    <a id="_idIndexMarker045">
    </a>
    <span class="koboSpan" id="kobo.131.1">
     only gets the type of car, this may be under fetching (they have to make a second
    </span>
    <a id="_idIndexMarker046">
    </a>
    <span class="koboSpan" id="kobo.132.1">
     call for the rest of what they need).
    </span>
    <span class="koboSpan" id="kobo.132.2">
     GraphQL is designed to solve this problem, allowing the client to specify exactly which properties
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.133.1">
      are requested.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.134.1">
     That said, the downside of GraphQL is that each API query must be hand-crafted to designate what
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.135.1">
      is wanted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Because of this, and other technical constraints, not the least of which is inertia, REST is by far the most popular way to write APIs and we will not cover GraphQL in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      this book.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-45">
    <a id="_idTextAnchor045">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     Implementing REST in ASP.NET Core
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.139.1">
     An API created
    </span>
    <a id="_idIndexMarker047">
    </a>
    <span class="koboSpan" id="kobo.140.1">
     in ASP.NET Core will typically have three
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      major components:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.142.1">
       Controllers
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.143.1">
       Services
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.144.1">
       Repositories
      </span>
     </span>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.145.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.146.1">
     There is an alternative to controller-based APIs known as Minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     We discuss this in brief towards the end of this chapter (refer to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.147.1">
      Minimal APIs
     </span>
    </em>
    <span class="koboSpan" id="kobo.148.1">
     box).
    </span>
    <span class="koboSpan" id="kobo.148.2">
     We do not cover Minimal APIs for the rest of the book as they have too
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.149.1">
      many limitations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.150.1">
     When you
    </span>
    <a id="_idIndexMarker048">
    </a>
    <span class="koboSpan" id="kobo.151.1">
     invoke an API with a URL, that address is resolved to a controller.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     For example, using the URL we saw earlier, if you call https://localhost:7025/Car, you will invoke the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      CarController
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     at that address.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     Note that ASP.NET uses “convention over configuration,” by which we mean that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.154.1">
      by convention
     </span>
    </em>
    <span class="koboSpan" id="kobo.155.1">
     , the part of the word Controller is left off the address but is implied.
    </span>
    <span class="koboSpan" id="kobo.155.2">
     So in this case,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      CarController
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     , the address just uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     (leaving
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      off Controller).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     The job of the controller is to ensure that the user has been authenticated (it’s really them) and authorized (they have permission to take whatever action is invoked).
    </span>
    <span class="koboSpan" id="kobo.161.2">
     The controller then assembles any needed data and passes it along to the Service.
    </span>
    <span class="koboSpan" id="kobo.161.3">
     Typically, but not necessarily, this will be called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      CarService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     and will sit in a folder with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.164.1">
      other services.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.165.1">
     The job of the Service is to handle any business logic and prepare the data to go into the database.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     It then passes the data to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      the repository.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     Similar to the Service, the repository would typically be called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      CarRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     and would be located in a folder along with other repositories.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     The job of the repository is to interact with the
    </span>
    <a id="_idIndexMarker049">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     underlying data storage (for example,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      a database).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.172.1">
     Often, you will want to separate the properties of the database from the properties of an object to be sent through the API.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     For that, we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.173.1">
      use DTOs.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor046">
    </a>
    <span class="koboSpan" id="kobo.174.1">
     DTOs
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.175.1">
     It is
    </span>
    <a id="_idIndexMarker050">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     common to use DTOs to separate the representation of the structure of the database from a
    </span>
    <a id="_idIndexMarker051">
    </a>
    <span class="koboSpan" id="kobo.177.1">
     supporting
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.178.1">
      Plain Old C#
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.179.1">
       Object
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.181.1">
       POCO
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      )
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     Let’s take an example from a relational database.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     Each row may have twelve columns but for a specific API request, only seven are needed.
    </span>
    <span class="koboSpan" id="kobo.183.3">
     The DTO will be a class with seven properties, and we’ll use a tool (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.184.1">
      AutoMapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     ) to map the values in the seven columns to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.186.1">
      seven properties.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.187.1">
     Installing AutoMapper
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     The easiest
    </span>
    <a id="_idIndexMarker052">
    </a>
    <span class="koboSpan" id="kobo.189.1">
     way to install
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      AutoMapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     is to
    </span>
    <a id="_idIndexMarker053">
    </a>
    <span class="koboSpan" id="kobo.192.1">
     download the NuGet packages, as shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.193.1">
       Figure 3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.194.1">
       .3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.195.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer014">
     <span class="koboSpan" id="kobo.196.1">
      <img alt="Figure 3.3 – Installing AutoMapper" src="image/B21988_03_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.197.1">
     Figure 3.3 – Installing AutoMapper
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     There
    </span>
    <a id="_idIndexMarker054">
    </a>
    <span class="koboSpan" id="kobo.199.1">
     is a bit of configuration
    </span>
    <a id="_idIndexMarker055">
    </a>
    <span class="koboSpan" id="kobo.200.1">
     for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.201.1">
      AutoMapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     , but it is only done once.
    </span>
    <span class="koboSpan" id="kobo.202.2">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     , add
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.206.1">
builder.Services.AddAutoMapper(typeof(Program));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.207.1">
     The next step is to create the DTO
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      class itself.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.209.1">
     Creating the DTO class
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     The POCO classes
    </span>
    <a id="_idIndexMarker056">
    </a>
    <span class="koboSpan" id="kobo.211.1">
     we’ve created directly track the columns in the database, as described earlier.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     The DTO class tracks some or all of these columns
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      as properties:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.213.1">
namespace Cars.Data.DTOs
{
    public class CarDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Mpg { get; set; }
        public string Cylinders { get; set; }
        public string Displacement { get; set; }
        public string Horsepower { get; set; }
        public string Weight { get; set; }
        public string Acceleration { get; set; }
        public string ModelYear { get; set; }
        public string Origin { get; set; }
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     Once your
    </span>
    <a id="_idIndexMarker057">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     DTO is in place, you need a way to map the properties in the DTO to the properties in the database (POCO) class.
    </span>
    <span class="koboSpan" id="kobo.215.2">
     We can do that in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.216.1">
      a profile.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.217.1">
     Setting up the profile
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.218.1">
     While
    </span>
    <a id="_idIndexMarker058">
    </a>
    <span class="koboSpan" id="kobo.219.1">
     we are here, let’s set up the profile file for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.220.1">
      Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.221.1">
     entity.
    </span>
    <span class="koboSpan" id="kobo.221.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      AutoMapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     tool (no pun intended) provides a base class,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.224.1">
      Profile
     </span>
    </strong>
    <span class="koboSpan" id="kobo.225.1">
     , that we will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.226.1">
      derive from.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     Create a file called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      CarProfile.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     and put this code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      in it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.231.1">
Public class CarProfile : Profile
{
   Public CarProfile()
   {
      CreateMap&lt;CarDto, Car&gt;()
        .ForMember(car =&gt; car.id, opt=&gt;opt.MapFrom(carDto =&gt; carDto.
</span><span class="koboSpan" id="kobo.231.2">        Id))
        .ForMember(car =&gt; car.name, opt=&gt;opt.MapFrom(carDto =&gt; carDto.
</span><span class="koboSpan" id="kobo.231.3">        Name))
        .ForMember(car =&gt; car.mpg, opt=&gt;opt.MapFrom(carDto =&gt; carDto.
</span><span class="koboSpan" id="kobo.231.4">        Mpg))
        .ForMember(car =&gt; car.cylinders, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Cylinders))
        .ForMember(car =&gt; car.displacement, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Displacement))
        .ForMember(car =&gt; car.horsepower, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Horsepower))
        .ForMember(car =&gt; car.weight, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Weight))
        .ForMember(car =&gt; car.acceleration, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Acceleration))
        .ForMember(car =&gt; car.model_year, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.ModelYear))
        .ForMember(car =&gt; car.origin, opt=&gt;opt.MapFrom(carDto =&gt; 
        carDto.Origin))
        .ReverseMap();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     Notice that for
    </span>
    <a id="_idIndexMarker059">
    </a>
    <span class="koboSpan" id="kobo.233.1">
     every member that we want to share between the DTO and the POCO class, there is an entry.
    </span>
    <span class="koboSpan" id="kobo.233.2">
     At the bottom is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      ReverseMap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     , which, as you may have guessed, reverses the mapping (for example, it causes the map to go from
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.236.1">
      DTO &gt; Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.238.1">
      Car &gt;
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.239.1">
       DTO
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     We have taken care of the DTO; now we need to connect our POCO to the database.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     We’ll do that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.242.1">
      with Dapper.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-47">
    <a id="_idTextAnchor047">
    </a>
    <span class="koboSpan" id="kobo.243.1">
     Dapper
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.244.1">
     As noted
    </span>
    <a id="_idIndexMarker060">
    </a>
    <span class="koboSpan" id="kobo.245.1">
     earlier, we will use Dapper as our
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.246.1">
      Object Relational Model
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.248.1">
      ORM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.249.2">
     This will greatly simplify our interaction between the repository and the database.
    </span>
    <span class="koboSpan" id="kobo.249.3">
     Dapper has its own syntax but it is very (very) close to SQL and the points of departure will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.250.1">
      be obvious.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.251.1">
     Installing Dapper
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.252.1">
     To install and
    </span>
    <a id="_idIndexMarker061">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     use Dapper, please see their very straightforward and comprehensive instructions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      at
     </span>
    </span>
    <a href="https://www.learndapper.com/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.255.1">
       https://www.learndapper.com/
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     Here, for
    </span>
    <a id="_idIndexMarker062">
    </a>
    <span class="koboSpan" id="kobo.257.1">
     example, is the Dapper code to get a car
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      by ID:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.259.1">
Public async Task&lt;Car?&gt; GetCarById(int carId)
{
var sql =
    $@"SELECT *
       FROM
            Cars C
       WHERE
            C.id = @{nameof(carId)}
            AND C.is_deleted = 0";
var param = new
{
    carId
};
var car = await QueryFirstOrDefaultAsync&lt;Car&gt;(sql, param);
return car;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.260.1">
     We can create
    </span>
    <a id="_idIndexMarker063">
    </a>
    <span class="koboSpan" id="kobo.261.1">
     more complex statements with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      conditional logic.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.263.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.264.1">
     Dapper uses C# rather than SQL syntax except for the query itself.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     This makes interacting with the database much easier for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.265.1">
      C# programmers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.266.1">
     That is really all you need to know to get started creating your API.
    </span>
    <span class="koboSpan" id="kobo.266.2">
     Let’s try inserting a car into the database using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      the API.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor048">
    </a>
    <span class="koboSpan" id="kobo.268.1">
     Examining the SQL
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     The
    </span>
    <a id="_idIndexMarker064">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     SQL (pronounced See-Quill) in the above example can almost be read as an English sentence.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     First, we use the keyword SELECT to indicate that we want to pick out and return a subset of the data in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      the Database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.272.1">
     Next comes the asterisk (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     ) which indicates that we want all the columns.
    </span>
    <span class="koboSpan" id="kobo.274.2">
     The alternative is to list the columns
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      we want.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.276.1">
      From Cars C
     </span>
    </strong>
    <span class="koboSpan" id="kobo.277.1">
     indicates that we want the data to come from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      Cars
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     table, and that we will be using the alias
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.280.1">
      C
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     to refer to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      that table.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      Where
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     statement constrains the search to the criteria that follows it, in this case where the id of the car (using the alias C) matches the id we’re looking for.
    </span>
    <span class="koboSpan" id="kobo.285.2">
     We then tack on “
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      where is_deleted = 0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     ” indicating that we only want entries that are not marked
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      as deleted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     Here is where Dapper comes in.
    </span>
    <span class="koboSpan" id="kobo.289.2">
     We set up an array of parameters,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      and then
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     call:
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.292.1">
       QueryFirstOrDefaultAsync&lt;Car&gt;(sql, param);
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     This invokes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      QueryFirstOrDefault
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     method in dapper.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     We pass in the type of object we are looking for (Car) and then two parameters.
    </span>
    <span class="koboSpan" id="kobo.295.3">
     For our purposes, the first will always be SQL, and the second will always be the name of the collection we created
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      above (param).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     We assign the result (in this case one car) to a variable, and return
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      that value.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.299.1">
     Please note that the constructor for this class will have interfaces passed in through Dependency Injection, and those parameters will be assigned to member variables (for example, _
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.300.1">
      carService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.301.2">
     If you are not familiar with Dependency Injection, please refer to the code in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      the repository.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor049">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     Putting it all together (inserting a car)
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     Let’s put this
    </span>
    <a id="_idIndexMarker065">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     together using controller, service, and repository to insert a car with Dapper
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      and AutoMapper:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.307.1">
//Controller
[HttpPost]
 public async Task&lt;ActionResult&lt;Car&gt;&gt; Insert([FromBody] CarDto 
 carAsDto)
 {
     try
     {
         if (carAsDto == null)
         {
             return BadRequest("No car was provided");
         }
         var carToInsert = _mapper.Map&lt;Car&gt;(carAsDto);
         var insertedCar = await _carService.Insert(carToInsert);
         var insertedCarDto = _mapper.Map&lt;CarDto&gt;(insertedCar);
         var location = $"https://localhost:5001/car/{insertedCarDto.
</span><span class="koboSpan" id="kobo.307.2">         Id}";
         return Created(location, insertedCarDto);
     }
     catch (Exception e)
     {
         return StatusCode(StatusCodes.Status500InternalServerError);
     }
 }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     Notice that
    </span>
    <a id="_idIndexMarker066">
    </a>
    <span class="koboSpan" id="kobo.309.1">
     we’ve transformed the DTO to a database object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     ), which we then pass to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      the service:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.313.1">
 // car service
  public async Task&lt;Car&gt; Insert(Car)
 {
     var newId = await _carRepository.UpsertAsync(car);
     if (newId &gt; 0)
     {
         car.id = newId;
     }
     else
     {
         throw new Exception("Failed to insert car");
     }
     return car;
 }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     We are now ready to pass this car to the repository for storage in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      our database:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.316.1">
public async Task&lt;int&gt; UpsertAsync(Car car)
 {
     using var db = databaseConnectionFactory.GetConnection();
     var sql = @"
     DECLARE @InsertedRows AS TABLE (Id int);
     MERGE INTO Car AS target
     USING (SELECT @Id AS Id, @Name AS Name, @MPG as MPG, @
     Cylinders as Cylinders, @Displacement as Displacement, @
     Horsepower as Horsepower, @Weight as Weight, @Acceleration as 
     Acceleration, @Model_Year AS Model_Year, @Origin AS origin, @
     Is_Deleted AS Is_Deleted ) AS source
     ON target.Id = source.Id
     WHEN MATCHED THEN
         UPDATE SET
             Name = source.Name,
             MPG = source.MPG,
             Cylinders = source.Cylinders,
             Displacement = source.Displacement,
             Horsepower = source.Horsepower,
             Weight = source.Weight,
             Acceleration = source.Acceleration,
             Model_Year = source.Model_Year,
             Origin = source.Origin,
             Is_Deleted = source.Is_Deleted
     WHEN NOT MATCHED THEN
         INSERT (Name, Mpg, Cylinders, Displacement, Horsepower, 
         Weight, Acceleration, Model_Year, Origin, Is_deleted)
         VALUES (source.Name, source.MPG, source.Cylinders, source.
</span><span class="koboSpan" id="kobo.316.2">         Displacement, source.Horsepower, source.Weight, source.
</span><span class="koboSpan" id="kobo.316.3">         Acceleration, source.Model_Year, source.Origin, source.Is_
         Deleted)
         OUTPUT inserted.Id INTO @InsertedRows
     ;
     SELECT Id FROM @InsertedRows;
 ";
     var newId = await db.QuerySingleOrDefaultAsync&lt;int&gt;(sql, car);
     return newId == 0 ? </span><span class="koboSpan" id="kobo.316.4">car.id : newId;
 }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     If we get a
    </span>
    <a id="_idIndexMarker067">
    </a>
    <span class="koboSpan" id="kobo.318.1">
     valid new car, we pass back the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.319.1">
      newId value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     , which we check for in the service.
    </span>
    <span class="koboSpan" id="kobo.320.2">
     However, that is a lot of data we are passing to the API.
    </span>
    <span class="koboSpan" id="kobo.320.3">
     We’ll look at solving that problem in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.321.1">
      next section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     A note on dependency injection: as you know, we pass in interfaces to our methods so that we can support dependency injection.
    </span>
    <span class="koboSpan" id="kobo.322.2">
     This is set up in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.323.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.324.1">
     , and the injection itself
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      is automatic.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-50">
    <a id="_idTextAnchor050">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     Creating the body in Postman
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     As you can see, the
    </span>
    <a id="_idIndexMarker068">
    </a>
    <span class="koboSpan" id="kobo.328.1">
     data that we want to pass into the API will be too much for the query string, and so we will pass it into the body.
    </span>
    <span class="koboSpan" id="kobo.328.2">
     We can signal this in the definition of the API by writing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.330.1">
public async Task&lt;ActionResult&lt;Car&gt;&gt; Insert([</span><strong class="bold"><span class="koboSpan" id="kobo.331.1">FromBody</span></strong><span class="koboSpan" id="kobo.332.1">] CarDto carAsDto)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     Every API call will have zero or more
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      FromQuery
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      FromUrl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.338.1">
      FromBody
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     attributes.
    </span>
    <span class="koboSpan" id="kobo.339.2">
     In this case, we
    </span>
    <a id="_idIndexMarker069">
    </a>
    <span class="koboSpan" id="kobo.340.1">
     are just using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.341.1">
      FromBody
     </span>
    </strong>
    <span class="koboSpan" id="kobo.342.1">
     .
    </span>
    <span class="koboSpan" id="kobo.342.2">
     Our call through Postman is seen in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.343.1">
       Figure 3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.344.1">
       .4
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer015">
     <span class="koboSpan" id="kobo.346.1">
      <img alt="Figure 3.4 – Inserting a car" src="image/B21988_03_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.347.1">
     Figure 3.4 – Inserting a car
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Here, we are inserting all the properties of the car (except the ID value) as seen in the top window.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     To do
    </span>
    <a id="_idIndexMarker070">
    </a>
    <span class="koboSpan" id="kobo.349.1">
     this, we would adjust the SQL statement to take all the properties.
    </span>
    <span class="koboSpan" id="kobo.349.2">
     Notice that the API returns the properties of the inserted car, including its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     (bottom window).
    </span>
    <span class="koboSpan" id="kobo.351.2">
     The return code will be
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.352.1">
       201
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.353.1">
      (created).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.354.1">
     Since we are looking for the data in the body of the request, the URL is just the address of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.355.1">
      the controller.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     We have inserted a single car, but I have pre-seeded the database with many more.
    </span>
    <span class="koboSpan" id="kobo.356.2">
     Let’s use the API to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      see them.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-51">
    <a id="_idTextAnchor051">
    </a>
    <span class="koboSpan" id="kobo.358.1">
     Get all
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.359.1">
     To get a list of all the cars in the database, we begin in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      the controller:
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.361.1">
     Warning: the following example shows calling the repository directly for illustration purposes.
    </span>
    <span class="koboSpan" id="kobo.361.2">
     Shortly afterwards we will discuss the correct way to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.362.1">
      do this.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.363.1">
public async Task&lt;IEnumerable&lt;Car&gt;&gt; GetAll(bool returnDeletedRecords = false)
{
    return await _carRepository.GetAll(returnDeletedRecords);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.364.1">
     Here, we call the repository directly.
    </span>
    <span class="koboSpan" id="kobo.364.2">
     This is an alternative to calling the service, and is generally a bad practice, but I wanted to show how it is done.
    </span>
    <span class="koboSpan" id="kobo.364.3">
     Notice that we include a Boolean parameter as to whether to return the deleted records
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      as well.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     Normally, we would use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.367.1">
      Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.368.1">
     class for separation of concerns.
    </span>
    <span class="koboSpan" id="kobo.368.2">
     The service class would contain the program logic and would sit between the controller and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.369.1">
      the repository.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     In the repository, we build our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      SqlBuilder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     (as we saw earlier in the section on
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.373.1">
      Dapper
     </span>
    </em>
    <span class="koboSpan" id="kobo.374.1">
     ) and obtain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      the records:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.376.1">
public async Task&lt;IEnumerable&lt;Car&gt;&gt; GetAll(bool returnDeletedRecords = false)
{
    var builder = new SqlBuilder();
    var sqlTemplate = builder.AddTemplate("SELECT * FROM car " + 
    "/**where**/ ");
    if (!returnDeletedRecords)
    {
        builder.Where("is_deleted=0");
    }
    using var db = databaseConnectionFactory.GetConnection();
    return await db.QueryAsync&lt;Car&gt;(sqlTemplate.RawSql,sqlTemplate.
</span><span class="koboSpan" id="kobo.376.2">    Parameters)
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     Let’s take that one line at a time.
    </span>
    <span class="koboSpan" id="kobo.377.2">
     The first line indicates that we will return a list of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     objects and the decision as to whether or not to return deleted records defaults
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.380.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.381.1">
       false
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.382.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.383.1">
     We next create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.384.1">
      SqlBuilder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     object and then set the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      SqlTemplate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     object to select everything from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      the car.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     Notice the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      /**where**/
     </span>
    </strong>
    <span class="koboSpan" id="kobo.391.1">
     statement.
    </span>
    <span class="koboSpan" id="kobo.391.2">
     This is a Dapper convention indicating that a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      where
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     clause may be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      placed here.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     We will now check to see whether the deleted records are to be included, and if not, we add a where clause using the builder we created on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      first line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.397.1">
     We are ready to get the Database from the factory we created and then query the database, passing in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      RawSql
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     code created for use in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.400.1">
      SqlTemplate object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.401.1">
     and the parameters.
    </span>
    <span class="koboSpan" id="kobo.401.2">
     In this case, there are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      no parameters.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     What we get back is an array of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.404.1">
      Car
     </span>
    </strong>
    <span class="koboSpan" id="kobo.405.1">
     objects, which we return to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      calling method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     To test this, we set Postman to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      Get
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     and the URL to https://localhost:7025/Car.
    </span>
    <span class="koboSpan" id="kobo.409.2">
     Since no ID is provided, our code will get them all, as shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.410.1">
       Figure 3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.411.1">
       .5
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer016">
     <span class="koboSpan" id="kobo.413.1">
      <img alt="Figure 3.5 – Getting all the cars in the database" src="image/B21988_03_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.414.1">
     Figure 3.5 – Getting all the cars in the database
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     Having inserted records, we may want to change one or another.
    </span>
    <span class="koboSpan" id="kobo.415.2">
     To do that, we’ll want to use the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.416.1">
       Put
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      verb.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-52">
    <a id="_idTextAnchor052">
    </a>
    <span class="koboSpan" id="kobo.418.1">
     Update
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.419.1">
     Updating
    </span>
    <a id="_idIndexMarker071">
    </a>
    <span class="koboSpan" id="kobo.420.1">
     uses the HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      Put
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     verb.
    </span>
    <span class="koboSpan" id="kobo.422.2">
     Let’s trace through how it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.423.1">
      is done.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.424.1">
     We return to the controller and add an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.425.1">
      HttpPut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     attribute.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     We then indicate that the contents will be in the body of the request (rather than the query) as we saw in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      the insert:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.428.1">
[HttpPut]
public async Task&lt;IActionResult&gt; Put([FromBody] Car car)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     Since we can’t be certain that the record we want to update is still in the database, we put the call in a try block, and if we get an exception, we call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.430.1">
      BadRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.431.1">
     .
    </span>
    <span class="koboSpan" id="kobo.431.2">
     Interestingly, if we succeed, we call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      NoContent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     as we are not adding anything to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      the database:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.435.1">
[HttpPut]
public async Task&lt;IActionResult&gt; Put([FromBody] Car car)
{
    try
    {
        await _carService.Update(car);
    }
    catch (Exception e)
    {
        return BadRequest(e);
    }
    return NoContent();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.436.1">
     As shown, from here we call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      carService
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     ’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      Update
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     method, passing in the car we want to update.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     Note that some programmers use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      OK
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     rather
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      than
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.444.1">
       NoContent
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.445.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.446.1">
     In the service, we’ll
    </span>
    <a id="_idIndexMarker072">
    </a>
    <span class="koboSpan" id="kobo.447.1">
     make sure we got a valid car
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.448.1">
      id value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.449.1">
     and then call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.450.1">
      UpsertAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.451.1">
     , passing in the car.
    </span>
    <span class="koboSpan" id="kobo.451.2">
     If we get back any
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.452.1">
      id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.453.1">
     value except the original, we throw an exception; otherwise, we return the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.454.1">
       Car
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.456.1">
public async Task&lt;Car&gt; Update(Car car)
{
    if (car.id == 0)
    {
        throw new Exception("Id must be set");
    }
    var oldId = car.id;
    var newId = await _carRepository.UpsertAsync(car);
    if (newId != oldId)
    {
        throw new Exception("Failed to update car");
    }
    return car;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.457.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.458.1">
      Upsert
     </span>
    </strong>
    <span class="koboSpan" id="kobo.459.1">
     method, we check to see whether this is a new car (insert) or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.460.1">
      an update:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.461.1">
public async Task&lt;int&gt; UpsertAsync(Car car)
{
    using var db = databaseConnectionFactory.GetConnection();
    var sql = @"
    DECLARE @InsertedRows AS TABLE (Id int);
    MERGE INTO Car AS target
    USING (SELECT @Id AS Id, @Name AS Name, @MPG as MPG, @Cylinders as 
    Cylinders, @Displacement as Displacement, @Horsepower as 
    Horsepower, @Weight as Weight, @Acceleration as Acceleration, @
    Model_Year AS Model_Year, @Origin AS origin, @Is_Deleted AS Is_
    Deleted ) AS source
    ON target.Id = source.Id
    WHEN MATCHED THEN
        UPDATE SET
            Name = source.Name,
            MPG = source.MPG,
            Cylinders = source.Cylinders,
            Displacement = source.Displacement,
            Horsepower = source.Horsepower,
            Weight = source.Weight,
            Acceleration = source.Acceleration,
            Model_Year = source.Model_Year,
            Origin = source.Origin,
            Is_Deleted = source.Is_Deleted
    WHEN NOT MATCHED THEN
        INSERT (Name, Mpg, Cylinders, Displacement, Horsepower,
        Weight, Acceleration, Model_Year, Origin, Is_deleted)
        VALUES (source.Name, source.MPG, source.Cylinders, source.
</span><span class="koboSpan" id="kobo.461.2">        Displacement, source.Horsepower, source.Weight, source.
</span><span class="koboSpan" id="kobo.461.3">        Acceleration,source.Model_Year, source.Origin, source.Is_
        Deleted)
        OUTPUT inserted.Id INTO @InsertedRows
    ;
    SELECT Id FROM @InsertedRows;
";
    var newId = await db.QuerySingleOrDefaultAsync&lt;int&gt;(sql, car);
    return newId == 0 ? </span><span class="koboSpan" id="kobo.461.4">car.id : newId;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     Notice, in the final
    </span>
    <a id="_idIndexMarker073">
    </a>
    <span class="koboSpan" id="kobo.463.1">
     two lines, that we obtain the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      newId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     value from the query and if it is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.466.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.467.1">
     , we return the original car ID.
    </span>
    <span class="koboSpan" id="kobo.467.2">
     Otherwise, we return the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.468.1">
      newid
     </span>
    </strong>
    <span class="koboSpan" id="kobo.469.1">
     value from the car
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.470.1">
      we inserted.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-53">
    <a id="_idTextAnchor053">
    </a>
    <span class="koboSpan" id="kobo.471.1">
     Soft delete
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.472.1">
     For the
    </span>
    <a id="_idIndexMarker074">
    </a>
    <span class="koboSpan" id="kobo.473.1">
     sake of completeness, let’s take a quick look at soft delete.
    </span>
    <span class="koboSpan" id="kobo.473.2">
     You’ll remember that when the user asks to delete a record, rather than actually removing it from the database, we mark it as deleted (in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.474.1">
      is_deleted
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     column) so that we can obtain those records
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.476.1">
      as needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.477.1">
     We start back in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.478.1">
      the controller:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.479.1">
[HttpDelete("{id}")]
public async Task&lt;IActionResult&gt; Delete(int id)
{
    try
    {
        await _carService.Delete(id);
    }
    catch (Exception e)
    {
        return BadRequest(e);
    }
    return NoContent();
}</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.480.1">
      Delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.481.1">
     takes the
    </span>
    <a id="_idIndexMarker075">
    </a>
    <span class="koboSpan" id="kobo.482.1">
     ID of the car to mark as deleted and then calls the service.
    </span>
    <span class="koboSpan" id="kobo.482.2">
     All the service does is make sure that the ID is valid and then call the repository to do the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      actual deletion:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.484.1">
public async Task Delete(int id)
{
    var car = await _carRepository.Get(id);
    if (car == null)
    {
        throw new Exception("Car not found");
    }
    await _carRepository.DeleteAsync(id);
    return;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     The code in the repo is dead simple.
    </span>
    <span class="koboSpan" id="kobo.485.2">
     It gets the connection to the database and creates the query to set
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.486.1">
      is_deleted
     </span>
    </strong>
    <span class="koboSpan" id="kobo.487.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     .
    </span>
    <span class="koboSpan" id="kobo.489.2">
     It then
    </span>
    <a id="_idIndexMarker076">
    </a>
    <span class="koboSpan" id="kobo.490.1">
     executes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.491.1">
      that query:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.492.1">
public async Task&lt;int&gt; DeleteAsync(int id)
{
    using var db = databaseConnectionFactory.GetConnection();
    var query = "UPDATE car SET Is_Deleted = 1 WHERE Id = @Id";
    return await db.ExecuteAsync(query, new { Id = id });
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     At this point, you have a complete API for
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.494.1">
      Create, Read, Update, Delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     (
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.496.1">
       CRUD
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.497.1">
      ) operations.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor054">
    </a>
    <span class="koboSpan" id="kobo.498.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     In this chapter, you were introduced to using Dapper and AutoMapper, the latter for DTO objects.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     You also dove into the workings of the CRUD operations, using the typical three classes: controller, service,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      and repository.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     You saw that for simple operations, you can bypass the Service, but this is considered
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.502.1">
      bad practice.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     In an enterprise application, you will want to use DTOs to separate the layout of the database from the layout of the object being passed around.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     As we delve into the realm of enhancing API usability and understanding, the next chapter will highlight the significance of documenting your project
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      with Swagger.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor055">
    </a>
    <span class="koboSpan" id="kobo.505.1">
     You try it
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.506.1">
     Create a simple database to track your music collection.
    </span>
    <span class="koboSpan" id="kobo.506.2">
     Put this in a database and use Dapper and AutoMapper to implement the four CRUD operations.
    </span>
    <span class="koboSpan" id="kobo.506.3">
     For this exercise, create DTOs that provide only a subset of the columns in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.507.1">
      the database.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.508.1">
     Minimal APIs
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.509.1">
     Minimal APIs offer an alternative way to create APIs without using Controllers.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     While they still allow for the injection of required services, they are primarily intended for smaller endpoints with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      minimal dependencies.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.511.1">
     In contrast, Controllers come with a larger hierarchy of endpoint components to consider.
    </span>
    <span class="koboSpan" id="kobo.511.2">
     This includes features such as versioning, controller naming, and manual route attributes, which can introduce extra boilerplate that may not always be necessary.
    </span>
    <span class="koboSpan" id="kobo.511.3">
     Minimal APIs simplify this process by allowing you to declare and handle requests in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.512.1">
      single expression.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.513.1">
     To illustrate, let’s reimplement the call to get all cars.
    </span>
    <span class="koboSpan" id="kobo.513.2">
     Start with the code from
    </span>
    <a href="B21998_03.xhtml#_idTextAnchor038">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.514.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.515.1">
     , then use the app variable to add calls to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.516.1">
      MapGet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.517.1">
     .
    </span>
    <span class="koboSpan" id="kobo.517.2">
     The route will be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.518.1">
      /car-minimal
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     , and the handler can remain the same as the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.520.1">
      GetAll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     method: a call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.522.1">
      ICarRepository.GetAll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     .
    </span>
    <span class="koboSpan" id="kobo.523.2">
     But how will we access the service interface without a constructor?
    </span>
    <span class="koboSpan" id="kobo.523.3">
     Minimal APIs solve this by using parameter injection.
    </span>
    <span class="koboSpan" id="kobo.523.4">
     Simply pass
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.524.1">
      ICarRepository carRepository
     </span>
    </strong>
    <span class="koboSpan" id="kobo.525.1">
     as an argument to the delegate for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.526.1">
      MapGet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.527.1">
     parameter, and use it to call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.528.1">
      .
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.529.1">
       GetAll
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.530.1">
      method.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.531.1">
     Many different types can be injected into the handlers for Minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.531.2">
     Model-bound types are differentiated by applying attributes to individual parameters.
    </span>
    <span class="koboSpan" id="kobo.531.3">
     Commonly used ones include
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      [FromRoute]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      [FromBody]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      [FromServices]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     .
    </span>
    <span class="koboSpan" id="kobo.537.2">
     Additional special types include
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      HttpRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      HttpResponse
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      IFormFile
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     , and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      Stream
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     of the request body.
    </span>
    <span class="koboSpan" id="kobo.547.2">
     The full list is available in the official
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      Microsoft documentation.
     </span>
    </span>
   </p>
  </div>
 </body></html>