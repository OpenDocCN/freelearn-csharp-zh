<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer096" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor116" class="pcalibre1 pcalibre calibre6"/>6</h1>
<h1 id="_idParaDest-115" class="calibre5"><a id="_idTextAnchor117" class="pcalibre1 pcalibre calibre6"/>Introduction to Object Pooling in Unity 2022</h1>
<p class="calibre3">In <a href="B18347_05.xhtml#_idTextAnchor096" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 5</em></span></a>, we imported and prepped artwork for use with additional 2D animation tooling, which is bringing the game to life. We also processed player input using an input action map – instead of reading device input directly – with the new Input System, and we made a <strong class="source-inline">PlayerController</strong> script to move <span>the player.</span></p>
<p class="calibre3">We dove deeper into Mecanim as we learned how to transition between animations and drive animation state changes <span>from code.</span></p>
<p class="calibre3">In this chapter, you will be introduced to object pooling while we use this optimization pattern for the player’s shooting mechanic, and we’ll accomplish that using Unity’s object pooling API. The object pooling software design will be based on a pooled player shooting model <span>UML diagram.</span></p>
<p class="calibre3">In this chapter, we’re going to cover the following <span>main topics:</span></p>
<ul class="calibre17">
<li class="calibre15">The object <span>pooling pattern</span></li>
<li class="calibre15">A pooled player <span>shooting model</span></li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to create an optimized shooting mechanic for a <span>ranged weapon.</span></p>
<h1 id="_idParaDest-116" class="calibre5"><a id="_idTextAnchor118" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter with the same artwork created for the project in the book, download the assets from the following GitHub <span>link: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6</span></a><span>.</span></p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop, or a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and <span>Affinity Photo).</span></p>
<p class="calibre3">You can download the complete project on GitHub <span>at </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example</span></a><span>.</span></p>
<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor119" class="pcalibre1 pcalibre calibre6"/>The object pooling pattern</h1>
<p class="calibre3">The <strong class="bold">object pooling</strong> design<a id="_idIndexMarker618" class="pcalibre1 pcalibre calibre6"/> pattern is a type of <strong class="bold">creational</strong> or <strong class="bold">abstract factory</strong> design<a id="_idIndexMarker619" class="pcalibre1 pcalibre calibre6"/> pattern that uses a stack to <a id="_idIndexMarker620" class="pcalibre1 pcalibre calibre6"/>hold a collection of initialized object instances. It is excellent for use in situations when you will have either a large number of objects that need to be spawned or objects that will be created and <span>destroyed rapidly.</span></p>
<p class="calibre3">Since we will be shooting projectile objects from a weapon – which can be performed at a high rate by the player – this is a great place to apply object pooling because repeatedly instantiating and destroying objects comes with a high cost. In this case, object pooling provides a way to optimize <a id="_idIndexMarker621" class="pcalibre1 pcalibre calibre6"/>CPU, memory, and <strong class="bold">garbage </strong><span><strong class="bold">collection</strong></span><span> (</span><span><strong class="bold">GC</strong></span><span>).</span></p>
<p class="calibre3">Rather than creating a new projectile object directly every time the player needs to shoot, we’ll instead reuse an already instantiated projectile object by requesting it from the objects in the pool. As such, the Object Pool provides methods for requesting (getting) and returning (releasing) objects. So, for example, for a pool of 10 projectile objects, we’ll get one at a time from the pool when the player shoots and return the projectile that was shot when it expires (e.g., <span>hit something).</span></p>
<p class="calibre3">If you recall from <a id="_idIndexMarker622" class="pcalibre1 pcalibre calibre6"/>our <strong class="bold">Game Design Document</strong> (<strong class="bold">GDD</strong>) in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 4</em></span></a>, specifically <em class="italic">Table 4.1</em>, we defined shooting capabilities, so we’ll use object pooling to implement this mechanic in a performant and optimized way, using Unity’s <a id="_idIndexMarker623" class="pcalibre1 pcalibre calibre6"/>new <strong class="bold">object </strong><span><strong class="bold">pooling</strong></span><span><strong class="bold"> API</strong></span><span>.</span></p>
<h2 id="_idParaDest-118" class="calibre8"><a id="_idTextAnchor120" class="pcalibre1 pcalibre calibre6"/>The Unity object pooling API</h2>
<p class="calibre3">Unity has added <a id="_idIndexMarker624" class="pcalibre1 pcalibre calibre6"/>a new namespace to the <a id="_idIndexMarker625" class="pcalibre1 pcalibre calibre6"/>engine – <strong class="source-inline">UnityEngine.Pool</strong> – that includes several new classes to implement the object pooling pattern. For our requirement of a weapon to shoot bullets, we’ll use the <span><strong class="source-inline">ObjectPool&lt;T0&gt;</strong></span><span> class.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">ObjectPool&lt;T0&gt;</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml</span></a></p>
<p class="calibre3">The following is a list of required actions we’ll need when working with the <span>object pool:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">Creating</strong> (instantiating): Making a new object instance in the <span>pool available.</span></li>
<li class="calibre15"><strong class="source-inline">Getting</strong> (requesting): Retrieving an available object instance from the pool (or creating and returning a new one if more <span>are needed).</span></li>
<li class="calibre15"><strong class="source-inline">Releasing</strong> (returning): Putting an active object instance back into the pool for reuse when it’s <span>finished with.</span></li>
<li class="calibre15"><strong class="source-inline">Destroying</strong> (removing): Removing an instantiated object from the pool completely if it grows over its <span>size limit.</span></li>
</ul>
<p class="calibre3">Thankfully, or by design, the <strong class="source-inline">ObjectPool&lt;T0&gt;</strong> class provides everything we need, such as creating a<a id="_idIndexMarker626" class="pcalibre1 pcalibre calibre6"/> pool and taking and returning<a id="_idIndexMarker627" class="pcalibre1 pcalibre calibre6"/> items to the pool. Now, let’s create a new object pool for <span>our projectiles.</span></p>
<h2 id="_idParaDest-119" class="calibre8"><a id="_idTextAnchor121" class="pcalibre1 pcalibre calibre6"/>Creating a new object pool</h2>
<p class="calibre3">Let’s have a look <a id="_idIndexMarker628" class="pcalibre1 pcalibre calibre6"/>at the following code that creates a new object pool of <strong class="source-inline">BulletPrefab</strong> projectiles (of type <strong class="source-inline">ProjectileBase</strong>; there’ll be more on this shortly in the <em class="italic">Creating the pooled player shooting </em><span><em class="italic">model</em></span><span> section):</span></p>
<pre class="source-code">
private void Start()
{
    _poolProjectiles = new ObjectPool&lt;ProjectileBase&gt;(
        CreatePooledItem, OnGetFromPool,
        OnReturnToPool, OnDestroyPoolItem,
        collectionCheck: false,
        defaultCapacity: 10,
        maxSize: 25);
    ProjectileBase CreatePooledItem() =&gt;
        Instantiate(_weapon1.BulletPrefab);
    void OnGetFromPool(ProjectileBase projectile) =&gt;
        projectile.gameObject.SetActive(true);
    void OnReturnToPool (ProjectileBase projectile) =&gt;
        projectile.gameObject.SetActive(false);
    void OnDestroyPoolItem(ProjectileBase projectile) =&gt;
        Destroy(projectile.gameObject);
}</pre> <p class="calibre3">In the preceding<a id="_idIndexMarker629" class="pcalibre1 pcalibre calibre6"/> code, we can see a method (a local function in this case) declared for each of the required <strong class="source-inline">ObjectPool</strong> parameters, corresponding to the actions we <span>listed previously.</span></p>
<p class="callout-heading">A local function (C#)</p>
<p class="callout">The new <strong class="source-inline1">ObjectPool</strong> creation code uses local functions instead of a common approach, using lambdas (anonymous delegates), so that we, for one, avoid unnecessary memory allocations. We create a local function by declaring a method inside the body of an already existing method; this also limits the scope of a local function to only being able to be called from within the method, which promotes encapsulation over using private member methods (we don’t need these methods outside the scope of setting up the object pool, and they only need to be <span>called once).</span></p>
<p class="callout">A delegate has to be created when using a lambda, which is an unnecessary allocation if a local function is used. Allocations to capture local variables are also avoided, as local functions are really just functions; no delegates are necessary. In addition, calling a local function is also cheaper, and performance can be increased even further if in-lined by the compiler (eliminating <span>call-linkage overhead).</span></p>
<p class="callout">Also, local functions just look better! They provide better code readability and verbose parameter names – a lambda anonymous delegate would obscure each parameter type! (Can you tell I’m just a bit <span>biased here?)</span></p>
<p class="callout">Here’s some additional reading on the <span>subject: </span><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions" class="pcalibre1 pcalibre calibre6"><span>https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions</span></a><span>.</span></p>
<p class="callout">Here are some interesting design notes from when local functions were added to C# <span>7: </span><a href="https://github.com/dotnet/roslyn/issues/3911" class="pcalibre1 pcalibre calibre6"><span>https://github.com/dotnet/roslyn/issues/3911</span></a><span>.</span></p>
<p class="calibre3">I’ve declared the<a id="_idIndexMarker630" class="pcalibre1 pcalibre calibre6"/> following local functions within the <span><strong class="source-inline">Start()</strong></span><span> method:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">CreatePooledItem</strong>: This will instantiate an object of type <strong class="source-inline">ProjectileBase</strong> when a new item is needed. This is a bullet Prefab we have a reference to on the <span>player’s weapon.</span></li>
<li class="calibre15"><strong class="source-inline">OnGetFromPool</strong>: We’ll use <strong class="source-inline">_poolProjectiles.Get()</strong> to return a <strong class="source-inline">ProjectileBase</strong> object instance, while this method calls <strong class="source-inline">gameObject.SetActive(true)</strong> to enable the object <span>for use.</span></li>
<li class="calibre15"><strong class="source-inline">OnReturnToPool</strong>: Calling <strong class="source-inline">_poolProjectiles.Release(projectile)</strong> will execute <strong class="source-inline">projectile.gameObject.SetActive(false)</strong> on the object instance passed in, making sure it’s inactive (disabled) while sitting in the pool waiting to <span>be retrieved.</span></li>
<li class="calibre15"><strong class="source-inline">OnDestroyPoolItem</strong>: Calling <strong class="source-inline">Destroy(projectile.gameObject)</strong> when an item is removed from the pool means the object will no longer exist in <span>the scene.</span></li>
</ul>
<p class="calibre3">To clarify some of the preceding actions, <em class="italic">instantiate</em> means an object is created and exists in the Scene. When the instantiated object’s active state is <strong class="source-inline">SetActive(true)</strong>, it is visible in the Scene, and code <span>is executed.</span></p>
<p class="calibre3">Setting the<a id="_idIndexMarker631" class="pcalibre1 pcalibre calibre6"/> GameObject as <strong class="source-inline">SetActive(false)</strong> will ensure that it doesn’t display in the Scene, and for each component, the <strong class="source-inline">Update()</strong> method will no longer <span>be called.</span></p>
<h2 id="_idParaDest-120" class="calibre8"><a id="_idTextAnchor122" class="pcalibre1 pcalibre calibre6"/>Additional parameters affecting the object pool</h2>
<p class="calibre3">Beyond the<a id="_idIndexMarker632" class="pcalibre1 pcalibre calibre6"/> preceding action methods, we have three additional parameters that affect how the pool functions. They are <span>as follows:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">collectionCheck</strong>: We can save some CPU cycles if we set this parameter to <strong class="source-inline">false</strong>, as it won’t check whether an object was returned to the pool already (be cautious with this value, since it will throw errors if you try to release an item already in <span>the pool).</span></li>
<li class="calibre15"><strong class="source-inline">defaultCapacity</strong>: You should set this value to the number of projectiles we’ll generally need to have available on screen simultaneously (you can best determine this number by playtesting the rate <span>of fire).</span></li>
<li class="calibre15"><strong class="source-inline">maxSize</strong>: This value will prevent the pool from growing too large and getting out of hand. Any instances above this number will be destroyed instead of being returned to the pool (exceeding the maximum size often will trigger unwanted garbage collection, and resizing is an expensive operation – more CPU cycles – so you’ll want to fine-tune this value by <span>playtesting too).</span></li>
</ul>
<p class="calibre3">Let’s put our new Object Pool to good use now by implementing the shooting mechanic, using a pool of <span>bullet projectiles.</span></p>
<h1 id="_idParaDest-121" class="calibre5"><a id="_idTextAnchor123" class="pcalibre1 pcalibre calibre6"/>A pooled player shooting model</h1>
<p class="calibre3">We will use<a id="_idIndexMarker633" class="pcalibre1 pcalibre calibre6"/> an <strong class="bold">OOP</strong> (<strong class="bold">object-oriented programming</strong>) design <a id="_idIndexMarker634" class="pcalibre1 pcalibre calibre6"/>approach to the player shooting setup, allowing <a id="_idIndexMarker635" class="pcalibre1 pcalibre calibre6"/>for easy future extensibility of new types of weapons <span>and projectiles.</span></p>
<h2 id="_idParaDest-122" class="calibre8"><a id="_idTextAnchor124" class="pcalibre1 pcalibre calibre6"/>Creating the pooled player shooting model</h2>
<p class="calibre3">Let’s consider <a id="_idIndexMarker636" class="pcalibre1 pcalibre calibre6"/>the following <span>class diagram:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer091">
<img alt="Figure 6.1 – A pooled player shooting UML class diagram" src="image/B18347_06_1.jpg" class="calibre78"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A pooled player shooting UML class diagram</p>
<p class="calibre3"><span><em class="italic">Figure 6</em></span><em class="italic">.1</em> presents a UML<a id="_idIndexMarker637" class="pcalibre1 pcalibre calibre6"/> diagram. <strong class="bold">UML</strong> stands for <strong class="bold">Unified Modeling Language</strong>, and it’s a standardized approach to specifying and visualizing the relationships of artifacts within software projects. There are several types of UML diagrams, each serving a specific purpose. The class diagram we’re using displays the static structure of a system, including classes, attributes, methods, and their relationships. It’s one of the most widely used diagrams in <span>software architecture.</span></p>
<p class="callout-heading">Additional reading | UML diagram</p>
<p class="callout"><span>UML: </span><a href="https://www.uml.org/what-is-uml.htm" class="pcalibre1 pcalibre calibre6"><span>https://www.uml.org/what-is-uml.htm</span></a></p>
<p class="callout">PlantUML Language Reference <span>Guide: </span><a href="https://plantuml.com/guide" class="pcalibre1 pcalibre calibre6"><span>https://plantuml.com/guide</span></a></p>
<p class="callout">PlantText UML <span>Editor: </span><a href="https://www.planttext.com/" class="pcalibre1 pcalibre calibre6"><span>https://www.planttext.com/</span></a></p>
<p class="calibre3">Okay, we’ve modeled the system for the pooled player shooting part of our game’s code, but what does it mean? Referring to the diagram in <span><em class="italic">Figure 6</em></span><em class="italic">.1</em>, let’s break down the structure with <span>these points:</span></p>
<ul class="calibre17">
<li class="calibre15">The <strong class="source-inline">PlayerShootingPooled</strong> class (<em class="italic">C</em>) – responds to <strong class="source-inline">SendMessage()</strong> of player input’s <strong class="source-inline">OnFire()</strong> event to shoot the <span>weapon’s projectile:</span><ul class="calibre22"><li class="calibre15">This uses the <strong class="source-inline">_poolProjectiles</strong> object, which represents the stack of instantiated <strong class="source-inline">ProjectileBase</strong> objects (that <span>is, </span><span><strong class="source-inline">Bullet</strong></span><span>)</span></li><li class="calibre15">It gets the <strong class="source-inline">Bullet</strong> (<em class="italic">C</em>) object Prefab (derived from the <strong class="source-inline">ProjectileBase</strong> (<em class="italic">A</em>) class type) for use in the <strong class="source-inline">_poolProjectiles</strong> (the <strong class="source-inline">ObjectPool&lt;ProjectileBase&gt;</strong> <span>type) stack</span></li><li class="calibre15">It has a reference to the current ranged weapon (the <strong class="source-inline">WeaponRanged</strong> (<em class="italic">C</em>) class type) equipped to <span>the player</span></li></ul></li>
<li class="calibre15">The <strong class="source-inline">WeaponRanged</strong> class (<em class="italic">C</em>) – represents any number of ranged weapon types we<a id="_idIndexMarker638" class="pcalibre1 pcalibre calibre6"/> can equip the <span>player with:</span><ul class="calibre22"><li class="calibre15">It implements the <strong class="source-inline">IWeapon</strong> (<em class="italic">I</em>) interface, meaning that we must declare the same members (like a contract). Therefore, any classes that implement the interface will have the same members available (this allows us to swap out object types without having to change code that consumes the <span>interface members).</span></li></ul></li>
<li class="calibre15">The <strong class="source-inline">Bullet</strong> class (<em class="italic">C</em>) is a component added to our bullet Prefab and assigned in the Inspector to the <strong class="source-inline">WeaponRanged</strong>-serialized <strong class="source-inline">_bulletPrefab</strong> field. The bullet Prefab is retrieved via the public <strong class="source-inline">BulletPrefab</strong> property (encapsulating the private variable) for consumption in the <span><strong class="source-inline">PlayerShootingPooled</strong></span><span> class:</span><ul class="calibre22"><li class="calibre15">This extends the inherited abstract class, <strong class="source-inline">ProjectileBase</strong> (making <strong class="source-inline">Bullet</strong> a subclass); we cannot instantiate a class-declared <strong class="source-inline">abstract</strong> and must instead use the derived class. However, members declared in the <strong class="source-inline">base</strong> class are available in the <span>derived class.</span></li></ul></li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">When we say <em class="italic">serializable</em>, we’re indicating that we’ll be able to make an assignment in the Inspector – a private field in most cases (in a C# script, the private field is decorated with the <strong class="source-inline1">[</strong><span><strong class="source-inline1">SerializeField]</strong></span><span> attribute).</span></p>
<p class="calibre3">After reading through the preceding details and reviewing the class diagram, you may have started<a id="_idIndexMarker639" class="pcalibre1 pcalibre calibre6"/> visualizing what our code should look like <strong class="source-inline">… … …</strong></p>
<p class="calibre3">Well, you can stop daydreaming about it now because the <span>code follows.</span></p>
<p class="calibre3">Create a new C# script in <strong class="source-inline">Assets/Scripts</strong>, <span>named </span><span><strong class="source-inline">PlayerShootingPooled.cs</strong></span><span>:</span></p>
<pre class="source-code">
using UnityEngine.Pool;
public class PlayerShootingPooled : MonoBehaviour
{
    [SerializeField] private WeaponRanged _weapon1;
    public int PoolDefaultCapacity = 10;
    public int PoolMaxSize = 25;
    private ObjectPool&lt;ProjectileBase&gt; _poolProjectiles;
    private void Start() {}    // new ObjectPool&lt;&gt;();
    private void OnFire() =&gt;
        _weapon1.Shoot(_poolProjectiles.Get(),
            ReturnProjectile);
    private void ReturnProjectile(
        ProjectileBase projectile) =&gt;
            _poolProjectiles.Release(projectile);
}</pre> <p class="calibre3">We’ve declared the <strong class="source-inline">_weapon1</strong> variable to assign the reference to the <strong class="source-inline">WeaponRanged</strong> Prefab object attached to the player’s hand in the Editor (at design time). We also declared public variables <strong class="source-inline">PoolDefaultCapacity</strong> and <strong class="source-inline">PoolMaxSize</strong>, with default values of <strong class="source-inline">10</strong> and <strong class="source-inline">25</strong>, respectively, for the default and maximum sizes of our private <strong class="source-inline">ObjectPool</strong>, declared <span>as </span><span><strong class="source-inline">_poolProjectiles</strong></span><span>.</span></p>
<p class="calibre3">We’ll then use the <strong class="source-inline">Start()</strong> code from the previous <em class="italic">The Unity object pooling API</em> section (excluded <a id="_idIndexMarker640" class="pcalibre1 pcalibre calibre6"/>from the preceding code) and declare an <strong class="source-inline">OnFire()</strong> method, to be called via <strong class="source-inline">PlayerInput SendMessage()</strong> when the player presses the <em class="italic">fire</em> button. Within <strong class="source-inline">OnFire()</strong>, we will provide a <strong class="source-inline">Bullet</strong> instance, returned from calling <strong class="source-inline">_poolProjectiles.Get()</strong>, to <span>shoot with.</span></p>
<p class="calibre3">Lastly, we will declare the <strong class="source-inline">ReturnProjectile()</strong> method, since it will be invoked by the <strong class="source-inline">_weapon1.Shoot()</strong> callback when the bullet is finished… doing what <span>bullets do.</span></p>
<p class="callout-heading">A note on code architecture</p>
<p class="callout">When we create the pool item, we could pass a reference to <strong class="source-inline1">_poolProjectiles</strong> and call <strong class="source-inline1">Release()</strong> on it directly, but if we make this an <strong class="source-inline1">event</strong>, we can provide <strong class="source-inline1">ReturnProjectile()</strong> as a callback. Plus, we have the option of adding any additional callbacks. I don’t have any immediate plans for it. Still, it’s nice to consider the options to create a flexible approach, without having to refactor the code later to introduce the ability and possibly break functioning/tested code in <span>the process.</span></p>
<p class="calibre3">Now, we will create a new C# script in <strong class="source-inline">Assets/Scripts</strong> <span>named </span><span><strong class="source-inline">WeaponRanged.cs</strong></span><span>:</span></p>
<pre class="source-code">
using UnityEngine.Events;
public class WeaponRanged : MonoBehaviour, IWeapon
{
    [SerializeField] private ProjectileBase _bulletPrefab;
    public ProjectileBase BulletPrefab =&gt; _bulletPrefab;
    [SerializeField] private Transform _projectileSpawn;
    public void Shoot(ProjectileBase projectile,
        UnityAction&lt;ProjectileBase&gt; poolingReturnCallback)
    {
        projectile.transform.position =
            _projectileSpawn.position;
       projectile.Init(_projectileSpawn.right
            * transform.root.localScale.x,
                poolingReturnCallback);
    }
}</pre> <p class="calibre3">The <strong class="source-inline">WeaponRanged</strong> script is <a id="_idIndexMarker641" class="pcalibre1 pcalibre calibre6"/>where we’ll assign a reference to our bullet Prefab in the Inspector, using the serialized private field, <strong class="source-inline">_bulletPrefab</strong> – a weapon that shoots will require something to shoot, <span>after all.</span></p>
<p class="calibre3">We’ve kept <strong class="source-inline">_bulletPrefab</strong> encapsulated and then allowed only read (getter) access to the reference via the <strong class="source-inline">BulletPrefab</strong> public property. So, <em class="italic">encapsulation</em> here means we don’t want any other classes to have access to set a bullet reference. The weapon will manage its own projectiles (although we could still add functionality later to assign a new bullet Prefab via a public setter method, such as <strong class="source-inline">WeaponRanged.SetBulletPrefab(GameObject)</strong> <span>or similar).</span></p>
<p class="calibre3">The <strong class="source-inline">Transform</strong> variable, <strong class="source-inline">_projectileSpawn</strong>, provides a location where we’ll spawn the bullet Prefab that is shot from the weapon – we will set this up in the <strong class="source-inline">WeaponRanged 1</strong> <span>Prefab later.</span></p>
<p class="calibre3">Lastly, the <strong class="source-inline">Shoot()</strong> method sets the position of the projectile that the pool provided to the projectile spawn position, and then it calls the <strong class="source-inline">Init()</strong> method on it (presumably to fire it off in the correct direction by applying some force <span>to it).</span></p>
<p class="calibre3">We will also provide a reference to <strong class="source-inline">poolingReturnCallback</strong> so that the bullet Prefab can be released back to the pool when it collides with another object, or its <span>lifespan expires.</span></p>
<p class="calibre3">Now, we will create a <a id="_idIndexMarker642" class="pcalibre1 pcalibre calibre6"/>new C# script in <strong class="source-inline">Assets/Scripts/Interfaces</strong> <span>named </span><span><strong class="source-inline">IWeapon.cs</strong></span><span>:</span></p>
<pre class="source-code">
using UnityEngine.Events;
internal interface IWeapon
{
    ProjectileBase BulletPrefab { get; }
    void Shoot(ProjectileBase projectile,
        UnityAction&lt;ProjectileBase&gt;
            poolingReleaseCallback);
}</pre> <p class="calibre3">The <strong class="source-inline">WeaponRanged</strong> class implements the <strong class="source-inline">IWeapon</strong> interface to satisfy the contract, which means <strong class="source-inline">WeaponRanged</strong> must implement the <strong class="source-inline">BulletPrefab</strong> property and the <strong class="source-inline">Shoot()</strong> method declared in the <strong class="source-inline">IWeapon</strong> interface. Note that interface members in C# are public <span>by default!</span></p>
<p class="calibre3">The weapon and object pooling portions of the class diagram in <span><em class="italic">Figure 6</em></span><em class="italic">.1</em> are now satisfied. Let’s finish up the class diagram implementation with the projectile that will be shot from <span>the weapon.</span></p>
<p class="calibre3">Create a new C# script in <strong class="source-inline">Assets/Scripts</strong> named <strong class="source-inline">Bullet.cs</strong>, <span>as follows:</span></p>
<pre class="source-code">
public class Bullet : ProjectileBase
{
    [SerializeField] private LayerMask CollideWith;
    protected override void
        OnTriggerEnter2D(Collider2D collision)
    {
        if ((CollideWith
            &amp; (1 &lt;&lt; collision.gameObject.layer)) != 0)
                base.Collided();
    }
    protected override void LifetimeExpired()
        =&gt; base.Collided();
}</pre> <p class="calibre3">The <strong class="source-inline">Bullet</strong> class extends the <strong class="source-inline">ProjectileBase</strong> class, meaning that it will inherit all the members and/or be required to <strong class="bold">override</strong> members. You can declare unique properties for a derived class that differentiate it from other derived classes (a tenet of <strong class="bold">inheritance</strong> in <a id="_idIndexMarker643" class="pcalibre1 pcalibre calibre6"/><span>OOP design).</span></p>
<p class="calibre3">We’re overriding the <strong class="source-inline">OnTriggerEnter2D()</strong> method – we’re required to, since it’s declared as <strong class="source-inline">abstract</strong> in the inherited <strong class="source-inline">ProjectileBase</strong> class – to perform the specific Bullet<a id="_idIndexMarker644" class="pcalibre1 pcalibre calibre6"/> <span>collision action.</span></p>
<p class="calibre3">Note that we’re also calling the <strong class="source-inline">Collided()</strong> method in the inherited class by using the <strong class="source-inline">base</strong> keyword. <strong class="source-inline">Collided()</strong> is declared as <strong class="source-inline">virtual</strong>, which means we can redefine it in a derived class while also using it for the same <span>basic/default functionality.</span></p>
<p class="calibre3">This bit of code – <strong class="source-inline">((CollideWith &amp; (1 &lt;&lt; collision.gameObject.layer)) != 0)</strong> – in the <strong class="source-inline">OnTriggerEnter2D()</strong> method evaluates whether the GameObject the <strong class="source-inline">Bullet</strong> collided with is included in the layers selected in <strong class="source-inline">CollideWith LayerMask</strong>. For example, we’ll select <em class="italic">Environment</em>, <em class="italic">Wall</em>, <em class="italic">Ground</em>, <em class="italic">Enemy</em>, and so on, but not <em class="italic">Player</em> for <strong class="source-inline">Bullet</strong> to <span>collide with.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span>LayerMask: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml</span></a></p>
<p class="callout">Bitwise and shift <span>operators: </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-" class="pcalibre1 pcalibre calibre6"><span>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-</span></a><span>.</span></p>
<p class="calibre3">We’ve seen how <strong class="source-inline">Bullet</strong> extends the <strong class="source-inline">ProjectileBase</strong> class (via OOP inheritance), so let’s have a look at the <strong class="source-inline">ProjectileBase</strong> <span>class now.</span></p>
<p class="calibre3">Create a new <a id="_idIndexMarker645" class="pcalibre1 pcalibre calibre6"/>C# script in <strong class="source-inline">Assets/Scripts</strong> <span>named </span><span><strong class="source-inline">ProjectileBase.cs</strong></span><span>:</span></p>
<pre class="source-code">
using UnityEngine.Events;
public abstract class ProjectileBase : MonoBehaviour
{
    [SerializeField] private Rigidbody2D _rb;
    [SerializeField] private float _velocity = 30f;
    [SerializeField] private float _lifetime = 2f;
    private event
        UnityAction&lt;ProjectileBase&gt; _onCollisionAction;
    public virtual void Init(Vector2 direction,
        UnityAction&lt;ProjectileBase&gt; collisionCallback)
    {
        _onCollisionAction = collisionCallback;
        _rb.velocity = direction * _velocity;
        Invoke(nameof(LifetimeExpired), _lifetime);
    }
    protected abstract void
        OnTriggerEnter2D(Collider2D collision);
    protected abstract void LifetimeExpired();
    protected virtual void Collided()
    {
        CancelInvoke();
        _onCollisionAction?.Invoke(this);
    }
}</pre> <p class="calibre3">Here, we can see our bullet projectile’s default properties and behavior. By declaring <strong class="source-inline">ProjectileBase</strong> as an abstract base class, it cannot be instantiated (made a new instance of) directly, so we must declare a new class that extends or inherits <span>from it.</span></p>
<p class="calibre3">Note that any derived classes can still be referenced by the base class it extends (in OOP, this is <a id="_idIndexMarker646" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">polymorphism</strong> principle). The derived class must override any members declared as<a id="_idIndexMarker647" class="pcalibre1 pcalibre calibre6"/> abstract but can optionally override members declared as virtual (while also being able to call base virtual methods for <span>default behavior).</span></p>
<p class="calibre3">Let’s break down the code’s <span>relevant items:</span></p>
<ul class="calibre17">
<li class="calibre15">Variable declarations for <strong class="source-inline">_rb</strong>, <strong class="source-inline">_velocity</strong>, and <strong class="source-inline">_lifetime</strong> provide a reference to the <strong class="source-inline">RigidBody2D</strong> component of the projectile Prefab, as well as configurable values for the rate of velocity and lifetime of <span>the object</span></li>
<li class="calibre15">When <strong class="source-inline">Init()</strong> is called, the passed-in callback action is assigned to <strong class="source-inline">_onCollisionAction</strong> to be invoked later, and then <strong class="source-inline">_rg.velocity</strong> is set for <strong class="source-inline">direction</strong> and rate of <strong class="source-inline">_velocity</strong>, firing it off in the direction the weapon <span>is pointing</span></li>
<li class="calibre15">Then, we have two abstract methods that must be overridden in the derived class(es) (for <span>example, </span><span><strong class="source-inline">Bullet</strong></span><span>):</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">OnTriggerEnter2D()</strong>: This Unity message event is called when another object collides with <span>the object.</span></li><li class="calibre15"><strong class="source-inline">LifetimeExpired()</strong>: In <strong class="source-inline">Init()</strong>, we invoke this method with a delay so that the projectile object only exists active in the Scene for a certain amount of time (releasing it back to the pool to be reused). The <strong class="source-inline">_lifetime</strong> value should be adjusted during playtesting so that the weapon’s range works <span>well in-game.</span></li></ul></li>
<li class="calibre15">Finally, we have the <strong class="source-inline">Collided()</strong> method, which first cancels calling the <strong class="source-inline">LifetimeExpired()</strong> method at the <strong class="source-inline">_lifetime</strong> value (for example, as we don’t want to call <strong class="source-inline">LifetimeExpired()</strong> if <strong class="source-inline">Collided()</strong> was already called by a collision event) and then invokes the <strong class="source-inline">_onCollisionAction</strong> callback (releasing the object back to <span>the pool).</span></li>
</ul>
<p class="callout-heading">Pooled player shooting model code</p>
<p class="callout">The complete aforementioned pooled Player shooting code can be downloaded from the GitHub repo <span>here: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts</span></a><span>.</span></p>
<p class="calibre3">Following the design<a id="_idIndexMarker648" class="pcalibre1 pcalibre calibre6"/> model from the UML class diagram in <span><em class="italic">Figure 6</em></span><em class="italic">.1</em>, we have now finished writing the code portion and are ready to move on to implementing it with <span>the player.</span></p>
<h2 id="_idParaDest-123" class="calibre8"><a id="_idTextAnchor125" class="pcalibre1 pcalibre calibre6"/>Implementing the pooled shooting model</h2>
<p class="calibre3">Now, let’s see <a id="_idIndexMarker649" class="pcalibre1 pcalibre calibre6"/>how we implement the pooled player shooting model by creating the required Prefabs – a weapon and a projectile – for integration with the player. The Prefabs we’ll need, along with the steps to create them, are <span>as follows:</span></p>
<ol class="calibre14">
<li class="calibre15"><strong class="source-inline">Bullet 1</strong>: The first projectile Prefab asset we’ll shoot from a <span>ranged weapon:</span><ol class="calibre42"><li class="upper-roman">Import the <strong class="source-inline">bullet1</strong> artwork from the project files to the <strong class="source-inline">Assets/Sprites</strong> folder and set the PPU to <strong class="source-inline">1280</strong> (to set our larger bullet sprite to a good in-game size, which will be possibly adjusted later in relation to the size of the weapon firing the bullet). Also, set <strong class="bold">Max Size</strong> to <strong class="source-inline">64</strong> for optimization, since it is a relatively small and <span>fast-moving sprite.</span></li><li class="upper-roman">Create an empty GameObject in <span>the </span><span><strong class="bold">Hierarchy</strong></span><span>.</span></li><li class="upper-roman">Drag the bullet sprite from the <strong class="bold">Project</strong> window onto the new empty object to make it a child object (graphics should be parented to a base object), and then rename the parent <strong class="source-inline">Bullet 1</strong>. Remember that you can easily parent a GameObject in the <strong class="bold">Hierarchy</strong> by right-clicking on it and selecting <strong class="bold">Create </strong><span><strong class="bold">Empty Parent</strong></span><span>.</span></li><li class="upper-roman">Add <strong class="source-inline">Rigidbody2D</strong> and <strong class="source-inline">CircleCollider2D</strong> components to the parent object to <a id="_idIndexMarker650" class="pcalibre1 pcalibre calibre6"/>enable <strong class="bold">Physics</strong> (i.e., for <span>collision detection).</span><ol class="calibre42"><li class="lower-roman">For the <strong class="source-inline">Rigidbody2D</strong> component, set <strong class="bold">Mass</strong>, <strong class="bold">Angular Drag</strong>, and <strong class="bold">Gravity Scale</strong> to <strong class="source-inline">0</strong>, and enable <strong class="bold">Constraints</strong> | <strong class="bold">Freeze Rotation Z</strong> (we don’t want the bullet to rotate; for a 2D game, this is the <span><em class="italic">Z</em></span><span> axis).</span></li><li class="lower-roman">For the <strong class="source-inline">CircleCollider2D</strong> component, set <strong class="bold">Radius</strong> to a value that surrounds the core part of the bullet sprite (for example, <strong class="source-inline">0.13</strong>), as shown in <span><em class="italic">Figure 6</em></span><span><em class="italic">.2</em></span><span>:</span></li></ol></li></ol></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer092">
<img alt="Figure 6.2 – the bullet Prefab setup" src="image/B18347_06_2.jpg" class="calibre79"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2 – the bullet Prefab setup</p>
<ol class="calibre14">
<li class="upper-roman" value="5">Now, add the <strong class="source-inline">Bullet</strong> script to the parent object, and assign the <strong class="source-inline">Rigidbody2D</strong> field by clicking and dragging the <strong class="source-inline">Rigidbody2D</strong> section title to <span>the field.</span></li>
<li class="upper-roman">Set <strong class="bold">Velocity</strong> and <strong class="bold">Lifetime</strong> to some initial starting values, and then assign the layers that the bullet should collide with, using the <strong class="bold">CollideWith</strong> field (note that you may need to add a new layer before you can <span>assign it).</span></li>
<li class="upper-roman">Lastly, drag the<a id="_idIndexMarker651" class="pcalibre1 pcalibre calibre6"/> parent <strong class="source-inline">Bullet 1</strong> object from the <strong class="bold">Hierarchy</strong> to the <strong class="bold">Project</strong> window to create a Prefab asset in the <strong class="source-inline">Assets/Prefabs</strong> folder. Our bullet Prefab is now ready to be used with the weapon Prefab we’ll <span>create next.</span></li>
</ol>
<ol class="calibre14">
<li value="2" class="calibre15"><strong class="source-inline">WeaponRanged 1</strong>: A ranged weapon that the player will hold and shoot a bullet <span>projectile from:</span><ol class="calibre42"><li class="upper-roman">Import the <strong class="source-inline">gun1</strong> weapon artwork, and in the Sprite Editor, set a custom pivot (see <em class="italic">A</em> in <span><em class="italic">Figure 6</em></span><em class="italic">.3</em>) on the handle so that when it is attached (or spawned) to the player, it is in the correct position and can rotate on a pivot point (as you might expect it <span>to behave).</span></li></ol></li>
</ol>
<p class="callout-heading">Pivot | Unity documentation</p>
<p class="callout">When working with a GameObject, the pivot serves as the reference point to position, rotate, and scale it. In Unity, when using the Transform tools, you can switch between the pivot or center of a GameObject in the Tool <span>Settings overlay.</span></p>
<p class="callout">Position GameObjects | Gizmo handle position <span>toggles: </span><a href="https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml</span></a></p>
<ol class="calibre14">
<li class="upper-roman" value="2">Drag the gun sprite into the <strong class="bold">Hierarchy</strong> and parent to an empty GameObject (making the gun sprite a child object of the empty object), and then name the parent <span><strong class="source-inline">WeaponRanged 1</strong></span><span>.</span></li>
<li class="upper-roman">Now, add a new empty GameObject, named <strong class="source-inline">ProjectileSpawnPoint</strong>, as a sibling to <a id="_idIndexMarker652" class="pcalibre1 pcalibre calibre6"/>the gun sprite object that we’ll use as the <strong class="bold">Transform</strong> position to spawn the projectile. Position this GameObject at the front of the gun’s muzzle (see <em class="italic">B</em> in <span><em class="italic">Figure 6</em></span><span><em class="italic">.3</em></span><span>):</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer093">
<img alt="Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup" src="image/B18347_06_3.jpg" class="calibre80"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup</p>
<ol class="calibre14">
<li class="upper-roman" value="4">Now, add <strong class="source-inline">WeaponRanged</strong> as a component to the <span>parent GameObject.</span></li>
<li class="upper-roman">The only two assignments we need to make on the <strong class="source-inline">WeaponRanged</strong> component are the <strong class="bold">Bullet Prefab</strong> and <strong class="bold">Projectile </strong><span><strong class="bold">Spawn</strong></span><span> fields:</span><ol class="calibre42"><li class="lower-roman">Assign the bullet Prefab asset – the projectile the weapon will shoot – by dragging <strong class="source-inline">Bullet 1</strong> from the <strong class="bold">Project</strong> window to the <strong class="bold">Bullet </strong><span><strong class="bold">Prefab</strong></span><span> field.</span></li><li class="lower-roman">Assign the <strong class="source-inline">ProjectileSpawnPoint</strong> object to the <strong class="bold">Projectile Spawn</strong> field by dragging it from <span>the </span><span><strong class="bold">Hierarchy</strong></span><span>.</span></li><li class="lower-roman">Lastly, drag the parent <strong class="source-inline">WeaponRanged 1</strong> object from the <strong class="bold">Hierarchy</strong> to the <strong class="bold">Project</strong> window, creating a Prefab asset in the <span><strong class="source-inline">Assets/Prefabs</strong></span><span> folder.</span></li></ol></li>
</ol>
<p class="calibre3">Our pooled player <a id="_idIndexMarker653" class="pcalibre1 pcalibre calibre6"/>shooting model is ready to be used with the player <span>character. Yay!</span></p>
<h2 id="_idParaDest-124" class="calibre8"><a id="_idTextAnchor126" class="pcalibre1 pcalibre calibre6"/>Adding pooled shooting to the player character</h2>
<p class="calibre3">We’ll dig right<a id="_idIndexMarker654" class="pcalibre1 pcalibre calibre6"/> into adding the weapon to our player. You can either make sure the player is in the current Scene or double-click on the <strong class="source-inline">Player</strong> Prefab in the <strong class="bold">Project</strong> window to open it up in <span><strong class="bold">Prefab</strong></span><span> Mode.</span></p>
<p class="calibre3">We’ll use the player’s (actor’s) bones to ensure the weapon follows the character’s hand while animating. Perform the following steps to anchor the weapon to the <span>player’s hand:</span></p>
<ol class="calibre14">
<li class="calibre15">Find the hand bone under the <strong class="source-inline">root_bone</strong> hierarchy. In our case, it’s <strong class="source-inline">bone_8</strong> as shown in <span><em class="italic">Figure 6</em></span><span><em class="italic">.4</em></span><span>.</span></li>
<li class="calibre15">Add an empty GameObject as a child of <strong class="source-inline">bone_8</strong>, and name it <strong class="source-inline">Weapon_Attachment</strong>; this will serve as the attachment point for the weapon. Making it separate from the bone provides additional options for positioning/rotating. Also, naming it with an <strong class="source-inline">_Attachment</strong> suffix means we can easily search for any/all objects in the <strong class="bold">Hierarchy</strong> that serve as <span>attachment points.</span></li>
<li class="calibre15">You can now go ahead and drag the <strong class="source-inline">WeaponRanged 1</strong> Prefab from the <strong class="bold">Project</strong> window, dropping it directly on the <strong class="source-inline">Weapon_Attachment</strong> object (this becomes a nested Prefab, which means we can configure its properties at any time, independent of the <span><strong class="source-inline">Player</strong></span><span> Prefab).</span></li>
</ol>
<p class="calibre3">The following screenshot shows our player setup with the weapon in hand. In the following <span><em class="italic">Figure 6</em></span><em class="italic">.4</em>, you can see that I have also temporarily dragged in a <strong class="source-inline">Bullet 1</strong> Prefab to check its <a id="_idIndexMarker655" class="pcalibre1 pcalibre calibre6"/>scale in relation to the weapon (seen in context with the <span>player character):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer094">
<img alt="Figure 6.4 – The weapon Prefab added to the player" src="image/B18347_06_4.jpg" class="calibre81"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The weapon Prefab added to the player</p>
<p class="calibre3">As a final step, we need to add the <strong class="source-inline">PlayerShootingPooled</strong> script as a component to the root object of our <strong class="source-inline">Player</strong> Prefab. Then, we will drag the <strong class="source-inline">WeaponRanged 1</strong> object from the <strong class="bold">Hierarchy</strong> to the <strong class="bold">Weapon 1</strong> field on the component (as shown in <span><em class="italic">Figure 6</em></span><span><em class="italic">.4</em></span><span>).</span></p>
<p class="calibre3">Here’s what our Prefab components – based on the classes in our UML diagram – look like in the Inspector with all their respective <span>field assignments:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer095">
<img alt="Figure 6.5 – Prefab configuration for the pooled player shooting setup" src="image/B18347_06_5.jpg" class="calibre82"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Prefab configuration for the pooled player shooting setup</p>
<p class="callout-heading">New to Unity 2022</p>
<p class="callout">This may not be new specifically to the 2022 tech stream, but I believe it’s a workflow improvement worth mentioning. You can simultaneously open up a focused <strong class="bold">Inspector</strong> window for different assets or GameObjects, without constantly changing your selection and using the Inspector. First, select the object, and then either right-click and choose <strong class="bold">Properties…</strong> (at the bottom) or press <em class="italic">Alt/Cmd + </em><span><em class="italic">P</em></span><span>.</span></p>
<p class="calibre3">Let’s go ahead and<a id="_idIndexMarker656" class="pcalibre1 pcalibre calibre6"/> playtest the results of <span>our efforts!</span></p>
<p class="calibre3">Referring to <span><em class="italic">Figure 6</em></span><em class="italic">.4</em>, enter <strong class="bold">Play</strong> mode, and then disable the <strong class="bold">Animator</strong> component on the <strong class="source-inline">PlayerCharacter1</strong> object to pose the actor’s arm with the weapon attachment in a shooting position – using the IK <strong class="source-inline">LimbSolver2D</strong> target makes <span>this easy-peasy.</span></p>
<p class="calibre3">We’ll give the player a proper shooting animation that points the weapon in a direction in <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 8</em></span></a> so that we can target those pesky robot enem<a id="_idTextAnchor127" class="pcalibre1 pcalibre calibre6"/>ies (not that it’s <span>their fault!).</span></p>
<p class="calibre3">This section taught us how to add a ranged weapon to the player by attaching it to a character’s limb, all <a id="_idIndexMarker657" class="pcalibre1 pcalibre calibre6"/>while using previously created Prefabs. I can’t stress how important it is to understand and use a good Prefab workflow in <span>your projects!</span></p>
<h1 id="_idParaDest-125" class="calibre5"><a id="_idTextAnchor128" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter introduced object pooling and implemented it for the player’s shooting mechanic, using Unity’s object pooling API, while basing the software design on our pooled player shooting model <span>UML diagram.</span></p>
<p class="calibre3">We finished by attaching the ranged weapon to the player, using<a id="_idTextAnchor129" class="pcalibre1 pcalibre calibre6"/> our configured <span>Prefab components.</span></p>
<p class="calibre3">In the following chapter, we’ll add some juice to the player character with some visual effects, create some enemy NPCs (non-player characters), and finish by introducing enemy behavior through a <span>state pattern.</span></p>
</div>
</div></body></html>