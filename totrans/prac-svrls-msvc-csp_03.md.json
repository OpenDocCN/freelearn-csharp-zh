["```cs\n...\nbuilder.Services.AddScoped<IMyFunctionalityInterface1, MyFunctionalityImplementation1>();\nbuilder.Services.AddScoped<IMyFunctionalityInterface2, MyFunctionalityImplementation2>();\n... \n```", "```cs\n public class PurchaseOrder\n    {\n      …\n      #region private members\n      private IList<PurchaseOrderItem> items;\n      private DateTime _deliveryTime;\n      #endregion\n      public PurchaseOrder(DateTime creationTime, DateTime deliveryTime)\n        {\n          CreationTime = creationTime;\n          _deliveryTime = deliveryTime;\n          items=new List<PurchaseOrderItem>();\n        }\n      public DateTime CreationTime {get; init;}\n      public DateTime DeliveryTime => _deliveryTime;\n      public IEnumerable<PurchaseOrderItem> Items => items;\n      public bool DelayDelyveryTime(DateTime newDeliveryTime)\n        {\n          if(_deliveryTime< newDeliveryTime)\n            {\n              _deliveryTime = newDeliveryTime;\n              return true;\n            }\n          else return false;\n        }\n      public void AddItem (PurchaseOrderItem x)\n        { items.Add(x); }\n      public void RemoveItem(PurchaseOrderItem x)\n        { items.Remove(x); }\n       …\n  } \n```", "```cs\npublic record Address\n{\n  public string Country {get; init;}\n  public string Town {get; init;}\n  public string Street {get; init;}\n} \n```", "```cs\nvar modifiedAddress = myAddress with {Street = \"new street\"}; \n```", "```cs\npublic record Address(string Country, string Town, string Street) ; \n```", "```cs\n public interface IPurchaseOrderRepository\n    {\n      PurchaseOrder New(DateTime creationTime, DateTime deliveryTime);\n      Task<PurchaseOrder> GetAsync(long id);\n      Task DeleteAsync(long id);\n      Task DeleteAsync(PurchaseOrder order);\n      Task<IEnumerable<OrderBasicInfoDTO>> GetMany(DateTime? startPeriod,\n            DateTime? endPeriod, int? customerId\n            );\n         ...\n    } \n```", "```cs\npublic interface IPurchaseOrderByStartDateQuery: IQuery\n{\n  Task<IEnumerable<OrderBasicInfoDTO>> Execute(DateTime startDate);\n}\npublic class PurchaseOrderByStartDateQuery(IPurchaseOrderRepository repo):\n  IPurchaseOrderByStartDateQuery\n{\n  public async Task<IEnumerable<OrderBasicInfoDTO>> Execute(DateTime startDate)\n  {\n    return await repo.GetMany(startDate, null, null);\n  }\n} \n```", "```cs\npublic record ApplyDiscountCommand(decimal discount, long orderId): ICommand; \n```", "```cs\n public interface ICommandHandler {}\n    public interface ICommandHandler<T>: ICommandHandler\n        where T: ICommand\n    {\n      Task HandleAsync(T command);\n    } \n```", "```cs\npublic class ApplyDiscountCommandHandler(\nIPackageRepository repo):ICommandHandler<ApplyDiscountCommand>\n  {\n    public async Task HandleAsync(ApplyDiscountCommand command)\n      {\n        var purchaseOrder = await repo.GetAsync(command.OrderId);\n //call adequate aggregate methods to apply the required update\n//possibly modify other aggregates by getting them with other\n        //injected repositories\n        ...\n      }\n    } \n```", "```cs\nbuilder.Services.AddScoped<ICommandHandler<ApplyDiscountCommand>,\n ApplyDiscountCommandHandler>(); \n```", "```cs\npublic interface IUnitOfWork\n  {\n    Task<bool> SaveEntitiesAsync();\n    Task StartAsync();\n    Task CommitAsync();\n    Task RollbackAsync();\n  } \n```", "```cs\nawait unitOfWork.StartAsync();\nvar flight = await repo.GetFlightAsync(flightId);\nflight.Seats--;\nif(flight.Seats < 0)\n{\n  await unitOfWork.RollBackAsync();\n  return;\n}\n...\nawait unitOfWork.SaveEntitiesAsync();\nawait unitOfWork.CommitAsync(); \n```", "```cs\npublic interface IEventHandler\n{\n}\npublic interface IEventHandler<T>: IEventHandler\n    where T: IEventNotification\n  {\n    Task HandleAsync(T ev);\n  } \n```", "```cs\npublic class EventTrigger<T>\n        where T: IEventNotification\n  {\n    private readonly IEnumerable<IEventHandler<T>> _handlers;\n    public EventTrigger(IEnumerable<IEventHandler<T>> handlers)\n      {\n        _handlers = handlers;\n      }\n      public async Task Trigger(T ev)\n      {\n        foreach (var handler in _handlers)\n          await handler.HandleAsync(ev);\n      }\n  } \n```", "```cs\npublic class MyCommandHandler(EventTrigger<MyEvent> myEventHandlers): …\n{\n  public async Task HandleAsync(MytCommand command)\n  {\n    …\n    await myEventHandlers.Trigger(myEvent)\n    …\n   }\n} \n```", "```cs\npublic static IServiceCollection AddApplicationServices\n  (this IServiceCollection services, Assembly assembly)\n{\n  AddAllQueries(services, assembly);\n  AddAllCommandHandlers(services, assembly);\n  AddAllEventHandlers(services, assembly);\n  services.AddScoped<EventMediator>();\n  return services;\n}\npublic static IServiceCollection AddApplicationServices\n  (this IServiceCollection services)\n{\n  return AddApplicationServices(services,\n    typeof(HandlersDIExtensions).Assembly);\n} \n```", "```cs\nprivate static IServiceCollection AddAllCommandHandlers\n  (this IServiceCollection services, Assembly assembly)\n{\n  var handlers = assembly.GetTypes()\n    .Where(x => !x.IsAbstract && x.IsClass\n      && typeof(ICommandHandler).IsAssignableFrom(x));\n  … \n```", "```cs\nforeach (var handler in handlers)\n{\n  var handlerInterface = handler.GetInterfaces()\n    .Where(i => i.IsGenericType &&typeof(\n      ICommandHandler).IsAssignableFrom(i))\n    .SingleOrDefault(); \n```", "```cs\nforeach (var handler in handlers)\n{\n  …\n  if (handlerInterface != null)\n  {\n    services.AddScoped(handlerInterface, handler);\n  }\n} \n```", "```cs\nawait eventMediator.TriggerEvents(L); \n```", "```cs\npublic class EventMediator\n{\n  readonly IServiceProvider services;\n  public EventMediator(IServiceProvider services)\n  {\n    this.services = services;\n  }\n  ... \n```", "```cs\npublic async Task TriggerEvents(IEnumerable<IEventNotification> events)\n  {\n    if (events == null) return;\n    foreach(var ev in events)\n    {\n      var triggerType = typeof(EventTrigger<>).MakeGenericType(\n        ev.GetType());\n      var trigger = services.GetService(triggerType); \n```", "```cs\nvar task = (Task)triggerType.GetMethod(nameof(\n  EventTrigger<IEventNotification>.Trigger))\n  .Invoke(trigger, new object[] { ev });\nawait task.ConfigureAwait(false); \n```", "```cs\npublic class EventMediator\n{\n  readonly IServiceProvider services;\n  public EventMediator(IServiceProvider services)\n  {\n    this.services = services;\n  }\n  public async Task TriggerEvents(IEnumerable<IEventNotification> events)\n  {\n    if (events == null) return;\n    foreach(var ev in events)\n    {\n      var triggerType = typeof(EventTrigger<>).MakeGenericType(\n        ev.GetType());\n      var trigger = services.GetService(triggerType);\n      var task = (Task)triggerType.GetMethod(nameof(\n        EventTrigger<IEventNotification>.Trigger))\n        .Invoke(trigger, new object[] { ev });\n      await task;\n    }\n  }\n} \n```", "```cs\npublic abstract class Entity<K>\n    where K: IEquatable<K>\n{\n  public virtual K Id {get; protected set; } = default!;\n  public bool IsTransient()\n  {\n    return Object.Equals(Id, default(K));\n  }\n  >Domain events handling region\n  >Override Equal region\n} \n```", "```cs\n#region domain events handling\npublic List<IEventNotification> DomainEvents { get; private set; } = null!;\npublic void AddDomainEvent(IEventNotification evt)\n{\n  DomainEvents ??= new List<IEventNotification>();\n  DomainEvents.Add(evt);\n}\npublic void RemoveDomainEvent(IEventNotification evt)\n{\n  DomainEvents?.Remove(evt);\n}\n#endregion \n```", "```cs\npublic interface IPurchaseOrderState\n{\n  public DateTime CreationTime { get; set; }\n  public DateTime DeliveryTime { get; set; }\n  public ICollection<PurchaseOrderItem> Items { get; set; }\n  …\n} \n```", "```cs\npublic class PurchaseOrder\n{\n  private readonly IPurchaseOrderState _state;\n  public PurchaseOrder(IPurchaseOrderState state)\n  {\n    _state = state;\n  }\n  public DateTime CreationTime => _state.CreationTime;\n  public DateTime DeliveryTime => _state.DeliveryTime;\n  public IEnumerable<PurchaseOrderItem> Items => _state.Items;\n  public bool DelayDelyveryTime(DateTime newDeliveryTime)\n  {\n    if(_state.DeliveryTime < newDeliveryTime)\n    {\n      _state.DeliveryTime = newDeliveryTime;\n      return true;\n    }\n    else return false;\n    }\n    public void AddItem (PurchaseOrderItem x)\n    { _state.Items.Add(x); }\n    public void RemoveItem(PurchaseOrderItem x)\n    { _state.Items.Remove(x); }\n} \n```", "```cs\npublic static IServiceCollection AddDbDriver(\n  this IServiceCollection services,\n  string connectionString)\n{\n  services.AddDbContext<IUnitOfWork, MainDbContext>(options =>\n    options.UseSqlServer(connectionString,\n      b => b.MigrationsAssembly(\"DBDriver\")));\n  services.AddAllRepositories(typeof(DBExtensions).Assembly);\n  return services;\n} \n```", "```cs\ninternal class MainDbContext : DbContext, IUnitOfWork\n{\n  public MainDbContext(DbContextOptions options)\n    : base(options)\n    {\n    }\n  protected override void OnModelCreating(ModelBuilder builder)\n   {\n  }\n  region IUnitOfWork Implementation\n} \n```", "```cs\n#region IUnitOfWork Implementation\npublic async Task<bool> SaveEntitiesAsync()\n{\n  return await SaveChangesAsync() > 0; ;\n}\npublic async Task StartAsync()\n{\n  await Database.BeginTransactionAsync();\n}\npublic Task CommitAsync()\n{\n  return Database.CommitTransactionAsync();\n}\npublic Task RollbackAsync()\n{\n  return Database.RollbackTransactionAsync();\n}\n#endregion \n```", "```cs\n..\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nbuilder.Services.AddApplicationServices();\nbuilder.Services.AddDbDriver(\n  builder.Configuration?.GetConnectionString(\n    \"DefaultConnection\") ?? string.Empty);\n.. \n```", "```cs\n<registry domain>/<namespace>/<repository name>:<tag> \n```", "```cs\nmcr.microsoft.com/dotnet/aspnet:9.0 \n```", "```cs\nFROM mcr.microsoft.com/dotnet/aspnet:9.0\n... \n```", "```cs\n    ENTRYPOINT [<command>, <arg1>, <arg2>, ...] \n    ```", "```cs\nclass Hello{\n  public static void main(String[] args){\n    System.out.println(\"This program runs in a  Docker container\");\n  }\n} \n```", "```cs\nFROM eclipse-temurin:11\nCOPY . /var/www/java\nWORKDIR /var/www/java\nRUN javac Hello.java\nCMD [\"java\", \"Hello\"] \n```", "```cs\ndocker build ./ -t simpleexample \n```", "```cs\ndocker run --name myfirstcontainer simpleexample \n```", "```cs\ndocker ps --all \n```", "```cs\ndocker restart myfirstcontainer \n```", "```cs\ndocker stop myfirstcontainer \n```", "```cs\ndocker rm myfirstcontainer \n```", "```cs\ndocker rmi simpleexample \n```", "```cs\ndocker run -v <host machine path>:<container path> ... \n```", "```cs\ndocker run -p <host machine port>:<container port> ... \n```", "```cs\ndocker run -e mayvariable1=mayvalue1  -e mayvariable2=mayvalue2\\. .. \n```", "```cs\ndocker run -d ... \n```", "```cs\ndocker tag <image name> <tag> \n```", "```cs\ndocker tag myimage myregistry.azurecr.io/mypath/mymage \n```", "```cs\ndocker push myregistry.azurecr.io/mypath/mymage:<version> \n```", "```cs\ndocker pull myregistry.azurecr.io/mypath/myotherimage:<version> \n```", "```cs\naz login \n```", "```cs\naz acr login --name <registryname> \n```", "```cs\nFROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base\nWORKDIR /app\nEXPOSE 8080\nEXPOSE 8081 \n```", "```cs\nFROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\nARG BUILD_CONFIGURATION=Release\nWORKDIR /src\nCOPY [\"DockerTest/DockerTest.csproj\", \"DockerTest/\"]\nRUN dotnet restore \"./DockerTest/DockerTest.csproj\"\nCOPY . .\nWORKDIR \"/src/DockerTest\"\nRUN dotnet build \"./DockerTest.csproj\" -c $BUILD_CONFIGURATION -o /app/build \n```", "```cs\nFROM build AS publish\nARG BUILD_CONFIGURATION=Release\nRUN dotnet publish \"./DockerTest.csproj\" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false \n```", "```cs\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\nENTRYPOINT [\"dotnet\", \"DockerTest.dll\"] \n```", "```cs\ndocker exec -it <container-name-or-id> /bin/bash \n```", "```cs\nCONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS                                              NAMES\nf6ca4537e060   dockertest   \"dotnet --roll-forwa…\"   17 minutes ago   Up 17 minutes   0.0.0.0:49154->8080/tcp, 0.0.0.0:49153->8081/tcp   DockerTest \n```", "```cs\ndocker exec -it DockerTest /bin/bash \n```"]