<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-44">
    <a id="_idTextAnchor044">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-45">
    <a id="_idTextAnchor045">
    </a>
    
     Crafting Web APIs for Service Delivery
    
   </h1>
   <p>
    
     As part of ASP.NET Core 9, web APIs can be used to build HTTP services, which can be made available for both web page consumption and mobile applications.
    
    
     The structure provided by the .NET Core platform enables the development of APIs with high quality and performance.
    
    
     In this chapter, we will learn more about web APIs and the standards, conventions, and best practices for delivering solutions
    
    
     
      using them.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Delivering business as
     
     
      
       a service
      
     
    </li>
    <li>
     
      Exploring
     
     
      
       minimal APIs
      
     
    </li>
    <li>
     
      Implementing APIs using the
     
     
      
       controller-based approach
      
     
    </li>
    <li>
     
      Working
     
     
      
       with documentation
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-46">
    <a id="_idTextAnchor046">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter uses the Postman tool, which will be used as a client for consuming APIs.
    
    
     This tool will also be used in other chapters of the book and its installation and use
    
    
     
      are free.
     
    
   </p>
   <p>
    
     You can download Postman on your operating system through the following
    
    
     
      link:
     
    
    <a href="https://www.postman.com/downloads/">
     
      
       https://www.postman.com/downloads/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The code examples used in this chapter can be found in the book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-47">
    <a id="_idTextAnchor047">
    </a>
    
     Delivering business as a service
    
   </h1>
   <p>
    
     As we have learned in the last chapters, ASP.NET Core 9 offers different frameworks for the development of rich web-based applications.
    
    
     Regardless of the chosen model, whether client-side or server-side, we must implement negotiation flows that are responsible for the operation of
    
    
     
      the applications.
     
    
   </p>
   <p>
    
     Imagine a system for a digital bank where users can perform different types of operations in their checking account, such as transfers, analyzing extracts, checking the account balance, and even purchasing a new service package.
    
    
     Each of these operations has business requirements and rules.
    
    
     For example, it should not be possible to transfer 200 euros if the user’s account balance is
    
    
     
      100 euros.
     
    
   </p>
   <p>
    
     This negotiation flow can be implemented perfectly using Razor Pages, MVC, or a hybrid model, as we have learned.
    
    
     We can easily have a web-based application being performed on
    
    
     
      a server.
     
    
   </p>
   <p>
    
     However, imagine that users have requested a mobile application.
    
    
     It should offer the same features as the
    
    
     
      web version.
     
    
   </p>
   <p>
    
     In this case, any technologies could be used for this purpose, either for native or hybrid development.
    
    
     But how would the business logic of the application be developed?
    
    
     What if there was a change to an application rule?
    
    
     Would it be necessary to update two distinct types of code to make the applications
    
    
     
      run correctly?
     
    
   </p>
   <p>
    
     The best practice, in this case, is to centrally manage all the code that concerns the business rules.
    
    
     This would allow different types of application interfaces, whether browsers, mobile applications, or even other applications, to interact with a
    
    
     
      business
     
    
    
     
      context.
     
    
   </p>
   <p>
    
     This centralized application is made available in web API format, which is actually an application that is distributed through the internet.
    
    
     The
    
    <strong class="bold">
     
      Representational State Transfer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      REST
     
    </strong>
    
     ) protocol, which
    
    <a id="_idIndexMarker146">
    </a>
    
     is based on the HTTP protocol commonly used in web application interactions, allows clients (browsers, mobile apps, and other applications) to consume resources independently in a controlled and
    
    
     
      centralized way.
     
    
   </p>
   <p>
    
     The model for providing
    
    <a id="_idIndexMarker147">
    </a>
    
     business contexts over the internet is called
    
    <strong class="bold">
     
      business as a service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      BaaS
     
    </strong>
    
     ), allowing organizations to offer specific features or resources such as services that can be consumed by other companies
    
    
     
      or applications.
     
    
   </p>
   <div><div><img alt="Figure 3.1 – BaaS" src="img/B21788_03_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1 – BaaS
    
   </p>
   <p>
    
     Fortunately, ASP.NET Core 9 offers
    
    <a id="_idIndexMarker148">
    </a>
    
     us a powerful model for creating web APIs; however, we must understand some foundations before learning how to create BaaS resources.
    
    
     In the rest of this section, we look at some of the important
    
    
     
      foundational concepts.
     
    
   </p>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor048">
    </a>
    
     HTTP verbs and conventions
    
   </h2>
   <p>
    
     Communication with an API is done through
    
    <a id="_idIndexMarker149">
    </a>
    
     the
    
    <strong class="bold">
     
      HTTP
     
    </strong>
    
     protocol, which has some operations
    
    <a id="_idIndexMarker150">
    </a>
    
     called
    
    
     <strong class="bold">
      
       HTTP verbs
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     These verbs determine the type of intention in a given resource.
    
    
     The most common HTTP verbs
    
    
     
      are these:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       GET
      
     </strong>
     
      : This method is used to
     
     <a id="_idIndexMarker151">
     </a>
     
      request data in a feature, such as a read-only operation; when we type a URL in the browser, as a response, we receive an HTML page.
     
     
      GET
     
     <a id="_idIndexMarker152">
     </a>
     
      can also be used to determine the intention to obtain a list of registered users,
     
     
      
       for example.
      
     
    </li>
    <li>
     <strong class="bold">
      
       POST
      
     </strong>
     
      : When you send a POST
     
     <a id="_idIndexMarker153">
     </a>
     
      request, you are usually creating a new feature on the server.
     
     
      This
     
     <a id="_idIndexMarker154">
     </a>
     
      method includes data in the body of
     
     
      
       the request.
      
     
    </li>
    <li>
     <strong class="bold">
      
       PUT
      
     </strong>
     
      : PUT
     
     <a id="_idIndexMarker155">
     </a>
     
      requests are
     
     <a id="_idIndexMarker156">
     </a>
     
      used to update a feature.
     
     
      In this case, any changes made to a resource’s attributes must be sent in the request body, and the server replaces the resource with the
     
     
      
       sent data.
      
     
    </li>
    <li>
     <strong class="bold">
      
       DELETE
      
     </strong>
     
      : DELETE
     
     <a id="_idIndexMarker157">
     </a>
     
      requests are used to request the removal of a
     
     
      
       specified
      
     
     
      <a id="_idIndexMarker158">
      </a>
     
     
      
       feature.
      
     
    </li>
    <li>
     <strong class="bold">
      
       PATCH
      
     </strong>
     
      : PATCH
     
     <a id="_idIndexMarker159">
     </a>
     
      requests are used to apply partial modifications to a feature.
     
     
      Unlike the PUT verb, which replaces the entire feature, PATCH
     
     <a id="_idIndexMarker160">
     </a>
     
      updates only the specified parts of
     
     
      
       the feature.
      
     
    </li>
    <li>
     <strong class="bold">
      
       HEAD
      
     </strong>
     
      : This is
     
     <a id="_idIndexMarker161">
     </a>
     
      often used to verify the availability and metadata of a
     
     <a id="_idIndexMarker162">
     </a>
     
      feature without downloading
     
     
      
       its content.
      
     
    </li>
    <li>
     <strong class="bold">
      
       OPTIONS
      
     </strong>
     
      : An OPTION
     
     <a id="_idIndexMarker163">
     </a>
     
      requirement is used to describe
     
     <a id="_idIndexMarker164">
     </a>
     
      communication options for the destination feature.
     
     
      It can be used to consult the server about the supported methods and other information about
     
     
      
       the feature.
      
     
    </li>
   </ul>
   <p>
    
     Verbs are
    
    <a id="_idIndexMarker165">
    </a>
    
     very important to determine which type of operation will be performed by an API.
    
    
     As we can see from the preceding list, there are some verbs that are similar to each other, such as POST and PUT.
    
    
     Both can be used to create and update resources.
    
    
     However, using the right verb means the integration process can always be easily understood.
    
    
     There is no strict rule for the use of certain verbs, but it is a good practice to use the
    
    
     
      right ones.
     
    
   </p>
   <h2 id="_idParaDest-49">
    <a id="_idTextAnchor049">
    </a>
    
     REST
    
   </h2>
   <p>
    
     REST
    
    <a id="_idIndexMarker166">
    </a>
    
     is an architectural style, a set of constraints and principles that encourage stateless, scalable, and easily maintainable web
    
    
     
      service design.
     
    
   </p>
   <p>
    
     One of the characteristics of REST services is stateless communication, where each request from a client to a server must contain all the information necessary to understand and process the request.
    
    
     The server must not store any information about the client’s state between requests.
    
    
     This ensures that requests can be handled independently, making the system scalable and easy
    
    
     
      to maintain.
     
    
   </p>
   <p>
    
     There is also the concept of resources, be it a physical object, a conceptual entity, or a piece of data.
    
    
     Each resource is identified by a
    
    
     
      unique URL.
     
    
   </p>
   <p>
    
     REST services use standard HTTP methods to perform
    
    <strong class="bold">
     
      Create
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Read
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Update
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Delete
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CRUD
     
    </strong>
    
     ) operations
    
    <a id="_idIndexMarker167">
    </a>
    
     on resources.
    
    
     Each HTTP method corresponds to a specific action on the resource.
    
    
     For example, GET is used to retrieve data, POST to create a new resource, PUT to update a resource, and DELETE to remove a resource.
    
    
     This approach provides a uniform and consistent interface for interacting with resources.
    
    
     This means that the same HTTP verbs and methods are used consistently across
    
    
     
      different resources.
     
    
   </p>
   <p>
    
     HTTP codes are important and enable easy integrations and use of APIs.
    
    
     HTTP status codes, in the same way, make API responses standardized and allow applications to handle different
    
    
     
      scenarios appropriately.
     
    
   </p>
   <h2 id="_idParaDest-50">
    <a id="_idTextAnchor050">
    </a>
    
     HTTP status codes
    
   </h2>
   <p>
    
     HTTP status codes
    
    <a id="_idIndexMarker168">
    </a>
    
     indicate the result of an HTTP request and help clients understand the result of their actions.
    
    
     These status codes are essential for effective communication between clients
    
    
     
      and servers.
     
    
   </p>
   <p>
    
     HTTP status codes are grouped into
    
    
     
      five classes:
     
    
   </p>
   <ul>
    <li>
     
      Information
     
     
      
       responses (100-199)
      
     
    </li>
    <li>
     
      Successful
     
     
      
       responses (200-299)
      
     
    </li>
    <li>
     
      Redirection
     
     
      
       responses (300-399)
      
     
    </li>
    <li>
     
      Client error
     
     
      
       responses (400-499)
      
     
    </li>
    <li>
     
      Server error
     
     <a id="_idIndexMarker169">
     </a>
     
      
       responses (500-599)
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     HTTP status code references
    
   </p>
   <p class="callout">
    
     You can learn more about status
    
    <a id="_idIndexMarker170">
    </a>
    
     codes
    
    
     
      here:
     
    
    <a href="https://httpwg.org/specs/rfc9110.html#overview.of.status.codes">
     
      
       https://httpwg.org/specs/rfc9110.html#overview.of.status.codes
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Each status code has a return type that can be used by the client application or even the browser.
    
    
     When making an HTTP request, the response has a header, where the HTTP status code is located, and there may even be a body providing further details about the
    
    
     
      request response.
     
    
   </p>
   <p>
    
     In general, the main HTTP status codes used
    
    
     
      are these:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       200 OK
      
     </strong>
     
      : Indicates a
     
     
      
       successful request
      
     
    </li>
    <li>
     <strong class="bold">
      
       201 Created
      
     </strong>
     
      : Indicates that a resource was
     
     
      
       created successfully
      
     
    </li>
    <li>
     <strong class="bold">
      
       400 Bad Request
      
     </strong>
     
      : Indicates an error in the
     
     
      
       client request
      
     
    </li>
    <li>
     <strong class="bold">
      
       401 Unauthorized
      
     </strong>
     
      : Indicates that the client does not have
     
     
      
       proper authentication
      
     
    </li>
    <li>
     <strong class="bold">
      
       404 Not Found
      
     </strong>
     
      : Indicates that the requested resource does
     
     
      
       not exist
      
     
    </li>
    <li>
     <strong class="bold">
      
       500 Internal Server Error
      
     </strong>
     
      : Indicates a
     
     
      
       server-side problem
      
     
    </li>
   </ul>
   <p>
    
     The following code represents an example of a successful response to an
    
    
     
      API request:
     
    
   </p>
   <pre class="source-code">
HTTP/1.1 200 OK
Content-Type: application/json
{
    "status": "success",
    "message": "Data retrieved successfully",
    "data": {
        "id": 123,
        "name": "Example Resource",
        "description": "This is an example resource
          for the API.",
        "created_at": "2023-10-26T10:00:00Z"
    }
}</pre>
   <p>
    
     In this example, the status code (in the first line of code) is
    
    <strong class="source-inline">
     
      200
     
    </strong>
    
     , indicating that the request was successful.
    
    
     Furthermore, there is a body in the response containing
    
    
     
      more information.
     
    
   </p>
   <p>
    
     Using HTTP status codes
    
    <a id="_idIndexMarker171">
    </a>
    
     appropriately allows APIs to be easily integrated into different types of systems.
    
    
     As we create our APIs using them, this will
    
    
     
      become clearer.
     
    
   </p>
   <p>
    
     BaaS delivery offers several benefits for teams to segregate the responsibilities of each context into applications that can be easily integrated into different scenarios.
    
    
     We’ve learned enough about the fundamentals of APIs; it’s time to start creating APIs using the ASP.NET Core 9
    
    
     
      minimal APIs.
     
    
   </p>
   <h2 id="_idParaDest-51">
    <a id="_idTextAnchor051">
    </a>
    
     Exploring minimal APIs
    
   </h2>
   <p>
    
     One of the ways to create web services in ASP.NET Core 9 is to use the minimal APIs approach, which offers a simple way to make APIs available and add features and configurations
    
    
     
      as needed.
     
    
   </p>
   <p>
    
     The simple structure of
    
    <a id="_idIndexMarker172">
    </a>
    
     minimal APIs allows developers and teams to provide REST-based functionalities in an
    
    
     
      agile manner.
     
    
   </p>
   <p>
    
     There are many applicable scenarios for using this approach, and the one you choose will depend on the size of the project and the teams involved.
    
    
     The fact is that minimal APIs offer, in general, the same functionalities as the controller-based model, which we will discuss in the
    
    
     
      next section.
     
    
   </p>
   <p>
    
     To create a
    
    <a id="_idIndexMarker173">
    </a>
    
     minimal API project, we will base ourselves on a product management model.
    
    
     To do this, we will provide an API according to the
    
    
     
      following table:
     
    
   </p>
   <table class="No-Table-Style" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Route
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Request Body
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Response Body
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          GET /Product
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Get
        
        
         
          all products
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          None
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Array
        
        
         
          of products
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          GET /Product/{id}
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Get a product
        
        
         
          by ID
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          None
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A
        
        
         
          product object
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          POST /Product
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Add a
        
        
         
          new product
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Product object
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         A
        
        
         
          product object
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          PUT /Product/{id}
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Update an
        
        
         
          existing product
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Product Item
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          None
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          DELETE /Product/{id}
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Delete an existing product
        
        
         
          by ID
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          None
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          None
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 3.1 - Product management actions
    
   </p>
   <p>
    
     The Table 3.1 basically maps the routes that will be used in the product API, mapping the corresponding
    
    
     
      HTTP verbs.
     
    
   </p>
   <p>
    
     We can also see in the table that some routes are similar, differing only by the HTTP verbs used.
    
    
     This is a convention used by the REST model, where HTTP verbs indicate the intention for a
    
    
     
      given resource.
     
    
   </p>
   <p>
    
     In this case, the resource is the product, defined by the
    
    <strong class="source-inline">
     
      /Product
     
    </strong>
    
     route.
    
    
     In some cases, the
    
    <strong class="source-inline">
     
      /Product/{id}
     
    </strong>
    
     route indicates that there will be a parameter added to the resource route.
    
    
     This parameter will be part of the resource URL and will be mapped as a parameter of the method to be executed in
    
    
     
      the API.
     
    
   </p>
   <p>
    
     Now let’s create a minimal API project
    
    <a id="_idIndexMarker174">
    </a>
    
     and implement
    
    
     
      product registration:
     
    
   </p>
   <ol>
    <li>
     
      Open your
     
     <a id="_idIndexMarker175">
     </a>
     
      operating system’s command prompt, in a directory of your choice, and run the following line
     
     
      
       of code:
      
     
     <pre class="source-code">
<strong class="bold">dotnet new web --name ProductAPI</strong></pre>
    </li>
    <li>
     
      The web project template is a shortcut for creating an empty ASP.NET Core project, which will be used as the
     
     
      
       minimal API.
      
     
     <p class="list-inset">
      
       A folder called
      
      <strong class="source-inline">
       
        ProductAPI
       
      </strong>
      
       will be created containing all the files needed for the project.
      
      
       The main file
      
      
       
        is
       
      
      
       <strong class="source-inline">
        
         Program.cs
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       ProductAPI
      
     </strong>
     
      directory and then type the following command and
     
     
      
       press
      
     
     
      <em class="italic">
       
        Enter
       
      </em>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">Code.</strong></pre>
     <p class="list-inset">
      
       The Visual Studio Code editor
      
      
       
        will appear.
       
      
     </p>
    </li>
    <li>
     
      Then, open the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file, which will have the
     
     
      
       following structure:
      
     
     <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();</pre>
     <p class="list-inset">
      
       As we can see, there is no definition of a class.
      
      
       This is the main application file, the entry point that will be used to execute
      
      
       
        the API.
       
      
     </p>
     <p class="list-inset">
      
       In the first two lines of the file, we have the app definition, through the
      
      <strong class="source-inline">
       
        web application
       
      </strong>
      
       builder class.
      
      
       This definition was presented in
      
      <a href="B21788_02.xhtml#_idTextAnchor031">
       
        <em class="italic">
         
          Chapter 2
         
        </em>
       
      </a>
      
       , where we discussed the structure of a project in ASP.NET Core 9.
      
      
       However, it is important to note that the app will be created with some basic configurations, abstracted by the framework, such as filters and settings, among
      
      
       
        other aspects.
       
      
     </p>
     <p class="list-inset">
      
       Another important aspect of this file is the
      
      <strong class="source-inline">
       
        MapGet
       
      </strong>
      
       method of the
      
      <strong class="source-inline">
       
        app
       
      </strong>
      
       variable.
      
      
       This is a method that extends the previously created app, allowing the creation of a route that will be accessed via URL using the HTTP
      
      
       
        GET verb.
       
      
     </p>
     <p class="list-inset">
      
       This method has a parameter that defines the route pattern; in this case,
      
      <strong class="source-inline">
       
        /
       
      </strong>
      
       is used, which means the root of the application.
      
      
       The second parameter is an action, which uses one of C#’s features.
      
      
       This action will be executed when this route
      
      
       
        is
       
      
      
       <a id="_idIndexMarker176">
       </a>
      
      
       
        requested.
       
      
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    
     Actions and methods
    
   </p>
   <p class="callout">
    
     Actions can be seen as methods defined inline and are composed of two main parts, just
    
    
     
      like methods:
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      - Setting parameters
     
    </strong>
    
     : Setting parameters
    
    
     
      if necessary
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      - Action body
     
    </strong>
    
     : The code that will
    
    
     
      be executed
     
    
   </p>
   <p class="callout">
    
     Actions can be replaced by methods, instead of being
    
    
     
      defined inline.
     
    
   </p>
   <ol>
    <li value="5">
     
      To perform a test, just run the application by typing the following command at
     
     
      
       the prompt:
      
     
     <pre class="source-code">
<strong class="bold">dotnet run</strong></pre>
    </li>
    <li>
     
      Logs containing the API URL will be displayed.
     
     
      Now, open
     
     <strong class="bold">
      
       Postman
      
     </strong>
     
      , select
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New Tab
      
     </strong>
     
      , enter the application address, and then
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Send
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 3.2 – Getting an API resource using a minimal API" src="img/B21788_03_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.2 – Getting an API resource using a minimal API
    
   </p>
   <p class="list-inset">
    
     As we can see, in
    
    <a id="_idIndexMarker177">
    </a>
    
     just a few lines of code, it was possible to execute an API, even returning a simple
    
    <strong class="source-inline">
     
      Hello
     
    </strong>
    
     <strong class="source-inline">
      
       World
      
     </strong>
    
    
     
      string.
     
    
   </p>
   <p>
    
     The minimal API offers the ability to quickly make APIs available in a simple way and allow other features and configurations to be added according to a project’s needs.
    
    
     This brings great agility
    
    
     
      to teams.
     
    
   </p>
   <p>
    
     Let’s add some features to the
    
    <strong class="source-inline">
     
      ProductAPI
     
    </strong>
    
     project.
    
    
     To do this, create a class called
    
    <strong class="source-inline">
     
      Product.cs
     
    </strong>
    
     in the root of the project.
    
    
     The class will be defined according to the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
public class Product
{
     public int Id {get; set;}
     public string Name { get; set; }
     public decimal Price { get; set; }
}</pre>
   <p>
    
     We are just defining an
    
    <a id="_idIndexMarker178">
    </a>
    
     object that will represent a product.
    
    
     Now you will need to change the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file; we will include the methods listed in the preceding table, mapping the API routes and adding functionality to the
    
    
     
      API methods.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file will contain some methods as shown in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
<code>List&lt;Product&gt; products = new List&lt;Product&gt;();</code>
app.MapGet("/Product", () =&gt; Results.Ok(products));
app.MapGet("/Product/{id}", (int id) =&gt; {
    var product = products.FirstOrDefault(p =&gt; p.Id == id);
    return <code>Results.Ok</code>(product);
});
app.MapPost("/Product", (Product product) =&gt; {
    if (product != null)
    {
        product.Id = products.Count() + 1;
        products.Add(product);
    }
    return Results.Ok(product);
});
app.MapPut("/Product/{id}", (int id,
  Product updatedProduct) =&gt; {
    if (updatedProduct != null)
    {
        var oldProduct = products.FirstOrDefault
          (p =&gt; p.Id == id);
        if (oldProduct == null) return Results.NotFound();
        oldProduct.Name = updatedProduct.Name;
        oldProduct.Price = updatedProduct.Price;
    }
    return Results.NoContent();
});
app.MapDelete("/Product/{id}", (int id) =&gt; {
    var product = products.FirstOrDefault(p =&gt; p.Id == id);
    if (product == null) return Results.NotFound();
     products.Remove(product);
    return Results.NoContent();
});
app.Run();</pre>
   <p>
    
     As we can see, the APIs
    
    <a id="_idIndexMarker179">
    </a>
    
     were created similarly to the previously defined route table, respecting the HTTP verbs defined through the
    
    <strong class="source-inline">
     
      MapGet
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      MapPost
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      MapPut
     
    </strong>
    
     , and
    
    
     <strong class="source-inline">
      
       MapDelete
      
     </strong>
    
    
     
      methods.
     
    
   </p>
   <p>
    
     The code in question is very simple, creating a simulation of a product register.
    
    
     To do this, a variable was defined using the code
    
    <strong class="source-inline">
     
      List&lt;Product&gt; products = new List&lt;Product&gt;()
     
    </strong>
    
     , which will contain the products available in the API
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     Another important functionality described in the preceding code is the use of the utility class called
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     .
    
    
     This class is used in all methods, encapsulating important functionalities for returning the request, such as defining the status code related to the request in the
    
    
     
      response header.
     
    
   </p>
   <p>
    
     Let’s look at the API for the POST verb in
    
    
     
      more detail.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      MapPost
     
    </strong>
    
     method defines the
    
    <strong class="source-inline">
     
      /Products
     
    </strong>
    
     string as a route and as an action; it expects a product as a parameter, adds it to the list, and returns
    
    <strong class="source-inline">
     
      OK
     
    </strong>
    
     (status
    
    
     
      code 200).
     
    
   </p>
   <p>
    
     But how do we submit a product to the API?
    
    
     ASP.NET Core 9 has the concept
    
    <a id="_idIndexMarker180">
    </a>
    
     of a
    
    <strong class="bold">
     
      bind
     
    </strong>
    
     , which processes the request and creates and maps an object according to the request’s needs.
    
    
     In this case, an object in JSON format must be sent, which will be mapped to a product object when the POST method
    
    
     
      is executed.
     
    
   </p>
   <p>
    
     This is an excellent feature of ASP.NET Core 9, which abstracts all the complexity and, during the execution of a route, resolves the parameters expected by
    
    
     
      the action.
     
    
   </p>
   <p>
    
     Let’s add a product using the API with the
    
    
     
      following commands:
     
    
   </p>
   <ol>
    <li>
     
      Run the
     
     <a id="_idIndexMarker181">
     </a>
     
      application with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">dotnet run</strong></pre>
    </li>
    <li>
     
      Then open Postman and go to
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        New Tab
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the method to
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      and add the API address with the
     
     <strong class="source-inline">
      
       /
      
     </strong>
     
      <strong class="source-inline">
       
        Product
       
      </strong>
     
     
      
       suffix.
      
     
    </li>
    <li>
     
      Then select the
     
     <strong class="bold">
      
       Body
      
     </strong>
     
      tab, as shown in
     
     
      <em class="italic">
       
        Figure 3
       
      </em>
     
     
      <em class="italic">
       
        .3
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 3.3 – Configuring a POST request" src="img/B21788_03_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.3 – Configuring a POST request
    
   </p>
   <ol>
    <li value="5">
     
      Select the
     
     <strong class="bold">
      
       raw
      
     </strong>
     
      option and then set the type to
     
     <strong class="bold">
      
       JSON
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 3
       
      </em>
     
     
      <em class="italic">
       
        .4
       
      </em>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 3.4 – Defining the request body" src="img/B21788_03_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.4 – Defining the request body
    
   </p>
   <ol>
    <li value="6">
     
      Add the
     
     
      
       following JSON:
      
     
     <pre class="source-code">
{
    "id": 0,
    "Name": "Smartphone",
    "Price": 100
}</pre>
     <p class="list-inset">
      
       The preceding code just represents a JSON object that has the properties of a product.
      
      
       These properties were defined in the
      
      <strong class="source-inline">
       
        Product.cs
       
      </strong>
      
       class that was added to the project.
      
      
       You can see the full code through the book’s source code link, provided
      
      <a id="_idIndexMarker182">
      </a>
      
       in the
      
      <em class="italic">
       
        Technical
       
      </em>
      
       <em class="italic">
        
         requirements
        
       </em>
      
      
       
        section.
       
      
     </p>
    </li>
    <li>
     
      Click on the
     
     
      <strong class="bold">
       
        Send
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 3.5 – POST request result" src="img/B21788_03_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.5 – POST request result
    
   </p>
   <p>
    
     As a result, the registered product object was returned.
    
    
     Note the HTTP status code highlighted in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .5
     
    </em>
    
     , with the value
    
    <strong class="source-inline">
     
      200
     
    </strong>
    
     and the
    
    
     
      description
     
    
    
     <strong class="source-inline">
      
       OK
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     When executing a POST call to the API, ASP.NET Core identified a route mapped to the HTTP verb.
    
    
     Then, it binds the JSON object, sent as the request body, to the product object, defined as the POST request parameter.
    
    
     After that, the action request is made, which finally registers a product in the memory list and returns it, again serialized
    
    
     
      in JSON.
     
    
   </p>
   <p>
    
     As we learned, it is very simple to create an API using a minimal API.
    
    
     With just a few lines of code, it was possible to create a complete product register.
    
    
     Of course, as it is a .NET platform project, it is possible to define different classes to better structure your projects, since as the complexity increases, along with the number of APIs, it will become very difficult to manage all the routes in just
    
    
     
      one file.
     
    
   </p>
   <p>
    
     However, even though a minimal API supports most ASP.NET Core 9 functionality for creating web APIs, using a more structured and prepared approach for large projects can be a great option, and this is the case for controller-based projects, which we will discuss in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-52">
    <a id="_idTextAnchor052">
    </a>
    
     Implementing APIs using the controller-based approach
    
   </h1>
   <p>
    
     Controller-based projects are another way to deliver APIs using ASP.NET Core 9.
    
    
     This project type also implements
    
    <a id="_idIndexMarker183">
    </a>
    
     the
    
    <strong class="bold">
     
      Model-View-Controller
     
    </strong>
    
     (
    
    <strong class="bold">
     
      MVC
     
    </strong>
    
     ) pattern, which we learned about in
    
    <a href="B21788_02.xhtml#_idTextAnchor031">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The controller-based approach has a more complete and robust structure to deliver any type of API, so it supports different business contexts.
    
    
     In the same way as minimal APIs, it is possible to extend API functionalities by adding different types of configurations
    
    
     
      and customizations.
     
    
   </p>
   <h2 id="_idParaDest-53">
    <a id="_idTextAnchor053">
    </a>
    
     Creating a controller-based API
    
   </h2>
   <p>
    
     To create a
    
    <a id="_idIndexMarker184">
    </a>
    
     controller-based API, you just need to type the following code in the terminal, in a directory of
    
    
     
      your choice:
     
    
   </p>
   <pre class="console">
dotnet new webapi -n ProductMVC -controllers true</pre>
   <p>
    
     This command uses the
    
    <strong class="source-inline">
     
      webapi
     
    </strong>
    
     template, which by default creates a minimal API project.
    
    
     In this case, we are adding a
    
    <strong class="source-inline">
     
      -controllers
     
    </strong>
    
     argument to state that a web API should be created using the
    
    
     
      controller-based approach.
     
    
   </p>
   <p>
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     , the structure of the controller-based API project is very similar to MVC, which we learned about in
    
    <a href="B21788_02.xhtml#_idTextAnchor031">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.6 – Controller-based project structure" src="img/B21788_03_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.6 – Controller-based project structure
    
   </p>
   <p>
    
     The difference
    
    <a id="_idIndexMarker185">
    </a>
    
     between this project and minimal APIs is the segregation of responsibilities and organization of the project.
    
    
     Since each controller is related to a specific resource, there is no need to implement all the API code in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file, in addition to bringing greater possibilities, especially in
    
    
     
      larger projects.
     
    
   </p>
   <p>
    
     However, the approach to configurations and extensions is similar to what we learned about in regard to minimal APIs; it is all done through the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     The default project has some settings already defined, which can be easily modified.
    
    
     The following code is from the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file, which is
    
    
     
      created automatically:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
<code>builder.Services.AddEndpointsApiExplorer();</code>
builder.Services.AddSwaggerGen();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
<code>app.MapControllers();</code>
app.Run();</pre>
   <p>
    
     At this point, we
    
    <a id="_idIndexMarker186">
    </a>
    
     will focus on two main configurations added in the file, which concern the
    
    <strong class="source-inline">
     
      AddEndpointsApiExplorer
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      MapControllers
     
    </strong>
    
     methods.
    
    
     The rest of the methods will be
    
    
     
      discussed later:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       AddEndpointsApiExplorer
      
     </strong>
     
      : This is an extension method that aims to register services that are used to expose information about the application’s endpoints.
     
     
      This
     
     <a id="_idIndexMarker187">
     </a>
     
      information is used by API documentation generation services, such as
     
     <strong class="bold">
      
       Swagger
      
     </strong>
     
      , which we will discuss in the
     
     
      
       next section.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       MapControllers
      
     </strong>
     
      : This is an application configuration responsible for mapping added attributes into controller classes and, therefore, automatically defining APIs
     
     
      
       and routes.
      
     
    </li>
   </ul>
   <p>
    
     These methods allow the application to adapt more easily to the need to expose services as APIs and enable the implementation of good practices, making any additions and modifications
    
    
     
      more dynamic.
     
    
   </p>
   <p>
    
     Using the same example of a product service previously created in the minimal API approach, let’s understand this implementation adapted for the
    
    
     
      controller model.
     
    
   </p>
   <h2 id="_idParaDest-54">
    <a id="_idTextAnchor054">
    </a>
    
     Understanding the product controller
    
   </h2>
   <p>
    
     The implementation of the
    
    <a id="_idIndexMarker188">
    </a>
    
     product API using the controller-based approach follows the class definition model.
    
    
     Therefore, each API must have a controller, which will be responsible for processing requests for
    
    
     
      each resource.
     
    
   </p>
   <p>
    
     Based on the previous example, the product API will have the
    
    
     
      following definition:
     
    
   </p>
   <pre class="source-code">
<code>[ApiController]</code>
<code>[Route("[controller]")]</code>
public class <code>ProductController</code> : <code>ControllerBase</code>
{
    <code>[HttpGet]</code>
    public <code>IActionResult</code> Get()
    {
      // ..
    }
    <code>[HttpGet("{id}")]</code>
    public IActionResult Get(int id)
    {
      // ..
    }
    [HttpPost]
    public IActionResult Post(Product product)
    {
         //..
    }
    [HttpPut]
    public IActionResult Put(int id,
      Product updatedProduct)
    {
//..
    }
    [HttpDelete]
    public IActionResult Delete(int id)
    {
     //..
    }
}</pre>
   <p>
    
     Some code blocks have been omitted to make it easier to read and understand the most important points in this
    
    
     
      class definition.
     
    
   </p>
   <p>
    
     The class represents a
    
    <a id="_idIndexMarker189">
    </a>
    
     controller that will handle requests to the
    
    
     
      product API.
     
    
   </p>
   <p>
    
     Let’s analyze some details of
    
    
     
      the code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       ApiController
      
     </strong>
     
      : This is an attribute that is added to a class, causing it to be mapped as an API controller.
     
     
      This way, when adding the
     
     <strong class="source-inline">
      
       MapController
      
     </strong>
     
      configuration to the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file, all classes marked as attributes will be responsible for processing requests from the
     
     
      
       respective APIs.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Route
      
     </strong>
     
      : This attribute can be used either in a controller, represented by a class, or in an action, represented by a method.
     
     
      Its function is to define a URL pattern for the route.
     
     
      The
     
     <strong class="source-inline">
      
       [controller]
      
     </strong>
     
      parameter is a token that is automatically replaced, at runtime, by the class name, without the
     
     <strong class="source-inline">
      
       controller
      
     </strong>
     
      suffix.
     
     
      For the route to take the method name into account, in the case of annotating an action with the route attribute, the
     
     <strong class="source-inline">
      
       [action]
      
     </strong>
     
      token must
     
     
      
       be used.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       ProductController
      
     </strong>
     
      : This is the name of the class following the MVC convention.
     
     
      There is no obligation to use this suffix, but it is a good practice, as controllers do not need to be in the
     
     <strong class="source-inline">
      
       Controllers
      
     </strong>
     
      folder, making it easier for other members of a development team
     
     
      
       to read.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       ControllerBase
      
     </strong>
     
      : All controller classes should inherit from the
     
     <strong class="source-inline">
      
       ControllerBase
      
     </strong>
     
      class, which is appropriate for APIs.
     
     
      This class provides many properties and methods that are useful for handling
     
     
      
       HTTP requests.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       HttpGet
      
     </strong>
     
      : This attribute determines the HTTP verb that an action should respond to processing.
     
     
      For each verb, there is a different attribute.
     
     
      In the preceding example, there are two GET methods, but one is an overload, with one parameter.
     
     
      For the controller to know which GET method should be requested, a different route must be defined for methods with the same name.
     
     
      In this case, the second GET method has an
     
     <strong class="source-inline">
      
       {id}
      
     </strong>
     
      parameter, which will be included in the route, differentiating the actions.
     
     
      The ASP.NET Core 9 framework
     
     <a id="_idIndexMarker190">
     </a>
     
      will take care of binding the method’s
     
     
      <strong class="source-inline">
       
        id
       
      </strong>
     
     
      
       parameter.
      
     
    </li>
   </ul>
   <p>
    
     As we can see, a big difference in relation to the innovative approach of the minimal API is the ability to segregate responsibility into different controllers.
    
    
     Furthermore, the controller-based approach brings other features that are important in large projects, such as various types of utilities, both through the framework and other resources available in
    
    <strong class="source-inline">
     
      ControllerBase
     
    </strong>
    
     , such as bind resources and
    
    
     
      model validations.
     
    
   </p>
   <h2 id="_idParaDest-55">
    <a id="_idTextAnchor055">
    </a>
    
     ControllerBase utilities
    
   </h2>
   <p>
    
     As mentioned
    
    <a id="_idIndexMarker191">
    </a>
    
     previously, the
    
    <strong class="source-inline">
     
      ControllerBase
     
    </strong>
    
     class has several properties and methods that are useful for handling HTTP requests, making the APIs capable of handling requests using REST API best practices
    
    
     
      and conventions.
     
    
   </p>
   <p>
    
     The standard for communication between applications through HTTP is extensive, and a book entirely dedicated to this subject would be needed in order to cover it properly.
    
    
     However, let’s address some patterns used in the
    
    
     <strong class="source-inline">
      
       ProductController
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     As we learned at the beginning of the chapter, requests in APIs are made to a specific resource, and for each request, there is an intention associated with a verb.
    
    
     Each request has a set of information that is sent to the API, such as a body and headers.
    
    
     Likewise, after being processed, this request returns headers and, in addition, may contain a body.
    
    
     An HTTP status code is also defined in
    
    
     
      the response.
     
    
   </p>
   <p>
    
     This entire pattern is abstracted by the methods available in
    
    <strong class="source-inline">
     
      ControllerBase
     
    </strong>
    
     , which takes care of the return definitions for
    
    
     
      each request.
     
    
   </p>
   <p>
    
     Let’s analyze the GET method for retrieving a product
    
    
     
      by
     
    
    
     <strong class="source-inline">
      
       id
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
 public IActionResult Get(int id)
    {
        var product = ProductService.Get(id);
        if (product is null) return <code>NotFound</code>();
        return <code>Ok</code>(product);
    }</pre>
   <p>
    
     The purpose of this method is to return a product according to the ID, passed as a parameter to the method.
    
    
     This API could be used, for example, in a frontend, where the user clicks on a product link to see its details.
    
    
     Since the API consumer does not have access to the implementation details, the API needs to be consistent in returning
    
    
     
      appropriate responses.
     
    
   </p>
   <p>
    
     In the case of the preceding method, if the product is not found, a
    
    <strong class="source-inline">
     
      NotFound
     
    </strong>
    
     response is returned, using the HTTP status code 404.
    
    
     This is the same approach as when trying to access a non-existent URL through the browser, which generally displays a 404 message, stating that a resource was
    
    
     
      not found.
     
    
   </p>
   <p>
    
     On the other hand, if
    
    <a id="_idIndexMarker192">
    </a>
    
     the product is found, an
    
    <strong class="source-inline">
     
      Ok
     
    </strong>
    
     response is returned, using the HTTP status code 200.
    
    
     Note that the
    
    <strong class="source-inline">
     
      Ok
     
    </strong>
    
     method has one parameter, which is exactly the product found.
    
    
     In this case, this object will be serialized in JSON format and returned to the client.
    
    
     The
    
    <strong class="source-inline">
     
      Ok
     
    </strong>
    
     method is responsible for serializing the object and creating the response taking into account the body, the serialized product object, and the headers, including stating that
    
    <strong class="source-inline">
     
      Content-Type
     
    </strong>
    
     is
    
    <strong class="source-inline">
     
      application/json
     
    </strong>
    
     .
    
    
     This way, the client can process the message
    
    
     
      return correctly.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ControllerBase
     
    </strong>
    
     class has several other methods that abstract the complexity of interacting with the HTTP protocol in addition to implementing REST standards
    
    
     
      and conventions.
     
    
   </p>
   <p>
    
     It is important to note that APIs serve different types of clients, whether they are web-ready frontends, operating systems, or mobile applications, and they even allow integration between systems.
    
    
     Each of these consumers does not have any details about the API implementations, having access only to the signatures of the required methods and parameters, as well as the
    
    
     
      possible returns.
     
    
   </p>
   <p>
    
     Therefore, it is necessary to use standards and conventions correctly, making the API consistent and interoperable
    
    
     
      between consumers.
     
    
   </p>
   <p class="callout-heading">
    
     More details
    
   </p>
   <p class="callout">
    
     If you want to know more
    
    <a id="_idIndexMarker193">
    </a>
    
     about the
    
    <strong class="source-inline">
     
      ControllerBase
     
    </strong>
    
     class, see the documentation at the following
    
    
     
      link:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The ASP.NET Core 9 abstracts most of the complexity involved in this service delivery model by using APIs, in addition to providing other types of functionality such as a consistent validation model and
    
    
     
      object binding.
     
    
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor056">
    </a>
    
     Working with binding
    
   </h2>
   <p>
    
     Binds are
    
    <a id="_idIndexMarker194">
    </a>
    
     important features available in ASP.NET Core.
    
    
     Their main function is to translate or adapt the API request model to the actions that are performed in
    
    
     
      the controller.
     
    
   </p>
   <p>
    
     As we observed in our examples of the
    
    <strong class="source-inline">
     
      ProductController
     
    </strong>
    
     call, the methods receive as parameters these primitive types, such as
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     , or even complex types, such as objects of
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       product
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Each method or action has a signature or interface, which describes the attributes required, if any, for the method or action to be processed.
    
    
     When you make a request for action and enter the attributes according to the action signature, these will be mapped by the ASP.NET Core pipeline execution flow, which will bind the information for each attribute entered, taking into account its type, attribute name,
    
    
     
      and value.
     
    
   </p>
   <p>
    
     For example, the
    
    <strong class="source-inline">
     
      product
     
    </strong>
    
     object has the
    
    
     
      following attributes:
     
    
   </p>
   <pre class="source-code">
public int Id {get; set;}
public string Name { get; set; }
public decimal Price { get; set; }</pre>
   <p>
    
     This object represented in JSON format would be defined
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
{
  "id": 1,
  "name": "Smartphone",
  "price": 1000.0
}</pre>
   <p>
    
     As we can see, the objects are identical but represented differently.
    
    
     ASP.NET Core does the work of transforming the JSON
    
    <strong class="source-inline">
     
      product
     
    </strong>
    
     object into a C#
    
    <strong class="source-inline">
     
      product
     
    </strong>
    
     object, mapping the properties according to
    
    
     
      the name.
     
    
   </p>
   <p>
    
     This is a standard behavior of the framework, but there is the possibility of customizing and even binding different aspects of
    
    
     
      a request.
     
    
   </p>
   <p>
    
     As we know, a request has a body, URL, query string parameters, and also parameters that are sent through forms.
    
    
     A request has an abstraction in a C# object called
    
    <strong class="source-inline">
     
      HttpRequest
     
    </strong>
    
     .
    
    
     You can easily access all the properties of a request through the
    
    <strong class="source-inline">
     
      Request
     
    </strong>
    
     property of the previously mentioned
    
    
     <strong class="source-inline">
      
       ControllerBase
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     If it is necessary, for example, to obtain a value in a query string, the following code can
    
    
     
      be used:
     
    
   </p>
   <pre class="source-code">
string fullname1 = Request.QueryString["fullname"];
string fullname2 = Request["fullname"];</pre>
   <p>
    
     However, this
    
    <a id="_idIndexMarker195">
    </a>
    
     same value could be obtained from the query string, using the bind model provided by the
    
    
     <strong class="source-inline">
      
       FromQuery
      
     </strong>
    
    
     
      attribute:
     
    
   </p>
   <pre class="source-code">
[HttpGet]
public IActionResult GetTasks([FromQuery]bool
  isCompleted = false)
    {
// ..
    }</pre>
   <p>
    
     As we can see in the preceding code,
    
    <strong class="source-inline">
     
      isCompleted
     
    </strong>
    
     was annotated with the
    
    <strong class="source-inline">
     
      FromQuery
     
    </strong>
    
     attribute.
    
    
     This way, ASP.NET will be responsible for binding the query string to the action parameter.
    
    
     In this case, it is expected that the query string has the same name as the method parameter.
    
    
     But if this is not the case, just use an attribute overload and define the parameter name,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
public IActionResult GetTasks<code>([FromQuery("completed")]</code>bool
  isCompleted = false) { /**/ }</pre>
   <p>
    
     There are other types of attributes that can be used to
    
    
     
      perform binding:
     
    
   </p>
   <table class="No-Table-Style" id="table002">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Attribute
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           HTTP verb
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         
          When
         
        </strong>
        
         <strong class="bold">
          
           to use
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Data format
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         
          Example
         
        </strong>
        
         <strong class="bold">
          
           of use
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           FromBody
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         POST,
        
        
         
          PUT, PATH
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Use to bind parameter data from the request body.
        
        
         It can only be used once per action method, as it assumes the entire request body is used to bind to the
        
        
         
          action’s parameter.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          JSON, XML
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          [
         
        </strong>
        
         <strong class="source-inline">
          
           HttpPost]
          
         </strong>
        
       </p>
       <p>
        <strong class="source-inline">
         
          public IActionResult Create([FromBody] Product product) { ...
         
         
          }
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           FromForm
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          POST
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Use to bind parameter data from
        
        
         
          form fields.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Form data (
        
        
         
          key-value pairs)
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          [
         
        </strong>
        
         <strong class="source-inline">
          
           HttpPost]
          
         </strong>
        
       </p>
       <p>
        <strong class="source-inline">
         
          public IActionResult Update([FromForm] ProductUpdateDto dto) { ...
         
         
          }
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           FromService
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Any
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Use to inject services directly into action methods.
        
        
         This is useful for obtaining services without using
        
        
         
          constructor injection.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Depends on the service
        
        
         
          being injected
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          public IActionResult Get([FromServices] IProductService productService) { ...
         
         
          }
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           FromHeader
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Any
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Use when you need to retrieve data from HTTP headers.
        
        
         Useful for tokens or
        
        
         
          API versioning.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Simple string or comma-separated values in a
        
        
         
          single header
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          public IActionResult Get([FromHeader(Name = "X-Custom-Header")] string value) { ...
         
         
          }
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           FromQuery
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          GET
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Use to bind parameters from the query string of the URL.
        
        
         Ideal for filtering or pagination parameters in a
        
        
         
          RESTful API.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Simple types such as strings, integers, or custom string-convertible
        
        
         
          types
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          public IActionResult Search([FromQuery] string keyword) { ...
         
         
          }
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           FromRoute
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Any
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Use when parameter values are embedded in the URL path.
        
        
         Typically used with REST URLs that include
        
        
         
          resource IDs.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Simple types compatible with
        
        
         
          URL segments
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          [HttpGet("{id}")] public IActionResult GetById([FromRoute] int id) { ...
         
         
          }
         
        </strong>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    
     Each of these
    
    <a id="_idIndexMarker196">
    </a>
    
     parameters can be used as a means of customizing the bind model in each action of
    
    
     
      a controller.
     
    
   </p>
   <p class="callout-heading">
    
     Custom binds
    
   </p>
   <p class="callout">
    
     In some cases, the default
    
    <a id="_idIndexMarker197">
    </a>
    
     bind model available in ASP.NET Core may be limited in relation to the needs of an application, which can often have other, more complex types.
    
    
     With this, it is possible to implement customized binds.
    
    
     This implementation is outside the scope of this book, but you can learn more
    
    
     
      here:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The binds model available in ASP.NET Core abstracts much of the implementation complexity by taking care of filling in the values that each action requires.
    
    
     However, there is no guarantee that the parameters were filled in correctly in accordance with the application’s business rules.
    
    
     To do this, you need to perform validations, and ASP.NET Core offers a powerful
    
    
     
      validation model.
     
    
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor057">
    </a>
    
     Performing validations
    
   </h2>
   <p>
    
     When it comes to
    
    <a id="_idIndexMarker198">
    </a>
    
     creating robust APIs, model validation is one of the fundamental pillars.
    
    
     ASP.NET Core 9 makes this process easier and more powerful than ever, thanks to
    
    <strong class="bold">
     
      ModelState
     
    </strong>
    
     .
    
    
     Think of it as a border guard that checks and validates data before it enters the core of
    
    
     
      your application.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      ModelState
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker199">
    </a>
    
     framework in ASP.NET Core that acts to verify that data complies with the rules defined in your models.
    
    
     If a piece of data does not meet the validation criteria,
    
    <strong class="source-inline">
     
      ModelState
     
    </strong>
    
     marks it
    
    
     
      as invalid.
     
    
   </p>
   <p>
    
     Let’s take a look at the product
    
    
     
      registration API:
     
    
   </p>
   <pre class="source-code">
[HttpPost]
    public IActionResult Post(Product product)
    {
        if (product == null) return BadRequest();
        <strong class="bold">if (!ModelState.IsValid)</strong>
<strong class="bold">          return BadRequest(ModelState);</strong>
         // ..
    }</pre>
   <p>
    
     As we can see, there is a condition that evaluates the
    
    <strong class="source-inline">
     
      ModelState.IsValid
     
    </strong>
    
     property.
    
    
     If false, then an HTTP status code of 400 (for a bad request) is returned, containing a body that will represent the
    
    
     <strong class="source-inline">
      
       ModelState
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
{
    "Name": [
        "The field Name is required"
    ]
}</pre>
   <p>
    <strong class="source-inline">
     
      ModelState
     
    </strong>
    
     is
    
    <a id="_idIndexMarker200">
    </a>
    
     actually a dictionary, which, when serialized in JSON format, is represented by an object.
    
    
     Each object property represents a validated property.
    
    
     The value of each object property is represented by an array of strings that contains the
    
    <a id="_idIndexMarker201">
    </a>
    
     
      validation results.
     
    
   </p>
   <p>
    
     In order for
    
    <strong class="source-inline">
     
      ModelState
     
    </strong>
    
     to consider the model valid or not, it is necessary to annotate the properties of the objects with validation attributes; otherwise, the validations will
    
    
     
      be disregarded.
     
    
   </p>
   <p>
    
     The product class was changed by adding validation to the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     attribute, as in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
public class Product
{
    public int Id {get; set;}
    <strong class="bold">[Required(ErrorMessage ="The field Name is required")]</strong>
<strong class="bold">    [MinLength(3, ErrorMessage = "The Name field must have</strong>
<strong class="bold">at least 3 characters.")]</strong>
    public string Name { get; set; }
    public decimal Price { get; set; }
}</pre>
   <p>
    
     As we can see, the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property is considered mandatory and, in addition, must have at least three characters.
    
    
     This way, it is possible to combine validation attributes in the same property, and this is
    
    <a id="_idIndexMarker202">
    </a>
    
     managed by
    
    <strong class="source-inline">
     
      ModelState
     
    </strong>
    
     through the execution flow of an action, provided by ASP.NET
    
    
     
      Core 9.
     
    
   </p>
   <p>
    
     Validations are
    
    <a id="_idIndexMarker203">
    </a>
    
     part of an API, whether through attributes added to models or even manually, in the body of an action, using the
    
    <strong class="source-inline">
     
      ModelState.AddModelError
     
    </strong>
    
     method, as shown in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
if (product.Price &lt; 0) ModelState.AddModelError("Price",
  "The Price field cannot have a value less than zero.");
        if (!ModelState.IsValid)
          return BadRequest(ModelState);</pre>
   <p class="callout-heading">
    
     Other attributes
    
   </p>
   <p class="callout">
    
     ASP.NET Core also offers several other attributes that
    
    <a id="_idIndexMarker204">
    </a>
    
     can be used as model
    
    
     
      validation:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     As we can see, ASP.NET Core 9 provides a great feature for managing the states of models used by APIs, with parameters or even objects, allowing us to have the ability to carry out validations in a rich way on the application’s endpoints, in addition to giving us a simple way to maintain the integrity
    
    
     
      of information.
     
    
   </p>
   <p>
    
     These features become even more powerful with the use of approaches such as documentation, response formatting, and error management.
    
    
     Therefore, in the next section, we will see how to make APIs even more consistent
    
    
     
      for consumers.
     
    
   </p>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor058">
    </a>
    
     Working with documentation
    
   </h1>
   <p>
    
     APIs
    
    <a id="_idIndexMarker205">
    </a>
    
     are a powerful
    
    <a id="_idIndexMarker206">
    </a>
    
     resource for delivering an application’s business model through services, and for an API project to be made available properly, it is important to add features that standardize the interaction model
    
    
     
      with customers.
     
    
   </p>
   <p>
    
     To achieve this, every API must be documented, allowing customers to know which resources are available and how this documentation
    
    
     
      is done.
     
    
   </p>
   <p>
    
     So, let’s learn how we can benefit from API feature documentation automatically using Swagger’s NuGet package, which implements the
    
    
     
      OpenAPI specification.
     
    
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor059">
    </a>
    
     Documenting APIs with Swagger
    
   </h2>
   <p>
    
     APIs
    
    <a id="_idIndexMarker207">
    </a>
    
     are consumed by clients and other applications
    
    <a id="_idIndexMarker208">
    </a>
    
     through the HTTP protocol, where there is a request and a response.
    
    
     For this communication to happen, it is necessary to have knowledge about what is provided by the API, in this case, which methods are available and which contracts are used to
    
    
     
      establish connections.
     
    
   </p>
   <p>
    
     To do this, we have to establish a source of knowledge about the resources made available by APIs, such as methods, HTTP verbs, parameters, and bodies.
    
    
     To achieve this objective, it is necessary to
    
    
     
      have documentation.
     
    
   </p>
   <p>
    
     However, this documentation needs to be dynamic, since, especially during the development process, APIs can constantly change, adding functionalities or new features.
    
    
     It would be laborious to make changes to each bit of documentation and send it to all
    
    
     
      API consumers.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 still supports Swagger for providing API documentation.
    
    
     However, Swagger is no longer part of the project template by default as it was in previous releases.
    
    
     New projects can now support OpenAPI document generation in controller-based and minimal API applications.
    
    
     The OpenAI specification provides a programming language-agnostic approach to API documentation.
    
    
     As such, ASP.NET Core 9 provides built-in support for generating endpoint
    
    <a id="_idIndexMarker209">
    </a>
    
     information in an application through the
    
    <strong class="bold">
     
      Microsoft.AspNetCore.OpenAI
     
    </strong>
    
     package, avoiding dependencies on
    
    
     
      external libraries.
     
    
   </p>
   <p>
    
     Therefore, in
    
    <a id="_idIndexMarker210">
    </a>
    
     order to have documentation, as well as an experience of
    
    <a id="_idIndexMarker211">
    </a>
    
     using a UI to test the APIs, we will integrate the API project with Swagger, which is easy-to-use suite of API developer tools, in addition to implementing the OpenAPI
    
    
     
      specification standards.
     
    
   </p>
   <p class="callout-heading">
    
     OpenAPI Specification
    
   </p>
   <p class="callout">
    
     The OpenAPI Specification
    
    <a id="_idIndexMarker212">
    </a>
    
     is part of the Linux Foundation and aims to specify RESTFul interfaces to provide ease in the development and consumption of APIs.
    
    
     You can learn more about OpenAPI
    
    
     
      at
     
    
    <a href="https://spec.openapis.org/oas/latest.html">
     
      
       https://spec.openapis.org/oas/latest.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout">
    
     To learn more about ASP.NET Core 9 OpenAPI, visit the
    
    <a id="_idIndexMarker213">
    </a>
    
     following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0
      
     
    </a>
   </p>
   <p>
    
     When integrating it into your API solution, Swagger acts as a specification generator in the OpenAPI format, which is based on a JSON file, where all the APIs available in your application
    
    
     
      are described:
     
    
   </p>
   <pre class="source-code">
{
  "openapi": "3.0.1",
  "info": {
    "title": "API V1",
    "version": "v1"
  },
  "paths": {
    "/api/Todo": {
      "get": {
        "tags": [
          "Todo"
        ],
        "operationId": "ApiTodoGet",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ToDoItem"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ToDoItem"
                  }
                }
              },
              "text/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ToDoItem"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        …
      }
    },
    "/api/Todo/{id}": {
      "get": {
        …
      },
      "put": {
        …
      },
      "delete": {
        …
      }
    }
  },
  "components": {
    "schemas": {
      "ToDoItem": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "isCompleted": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      }
    }
  }
}</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker214">
    </a>
    
     preceding JSON describes the resources available for an API, the
    
    <a id="_idIndexMarker215">
    </a>
    
     response schema, and the available verbs, in addition to the prediction of objects used in
    
    
     
      the API.
     
    
   </p>
   <p>
    
     To integrate Swagger into a project, we must add the Nuget package by running the following command on the command line, in the
    
    
     
      project directory:
     
    
   </p>
   <pre class="console">
dotnet add package Swashbuckle.AspNetCore</pre>
   <p>
    
     Next, we must change the Program.cs file.
    
    
     We will perform this configuration for the Product MVC project, and you can analyze the changed code, adding Swagger, in the
    
    
     
      code below:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();</pre>
   <p>
    
     The implementation consists of
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Line 4 adds the Swagger generation services through the
     
     
      <strong class="source-inline">
       
        builder.Services.AddSwaggerGen()
       
      </strong>
     
     
      
       method.
      
     
    </li>
    <li>
     
      Between lines 6 and 10, we have the addition of Swagger to the ASP.NET execution pipeline, through the
     
     <strong class="source-inline">
      
       app.UseSwagger()
      
     </strong>
     
      method, and also the provision of the UI through the
     
     <strong class="source-inline">
      
       app.UseSwaggerUI()
      
     </strong>
     
      method.
     
     
      These methods are only executed if the application is running in development mode,
     
     
      <strong class="source-inline">
       
        if (app.Environment.IsDevelopment)
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     When running the
    
    <a id="_idIndexMarker216">
    </a>
    
     application, simply access the API link with the
    
    <a id="_idIndexMarker217">
    </a>
    
     swagger suffix, as shown in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .7
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.7 – Swagger UI for the Product MVC API" src="img/B21788_03_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.7 – Swagger UI for the Product MVC API
    
   </p>
   <p>
    
     Looking at
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .7
     
    </em>
    
     , we can see that the methods available in the product API were listed in the UI, in addition to the specification of the objects worked on the API.
    
    
     No changes were required to the
    
    
     
      source code.
     
    
   </p>
   <p>
    
     Swagger identifies the controllers and actions available in the source code, generates the specification, and consequently generates the UI.
    
    
     However, more details can be added to the documentation in order to enrich the API usage model.
    
    
     Let’s take a closer look at how to improve documentation using the features available in the
    
    
     
      Swagger package.
     
    
   </p>
   <h3>
    
     Improving the documentation
    
   </h3>
   <p>
    
     As we learned previously, Swagger is
    
    <a id="_idIndexMarker218">
    </a>
    
     added by default in ASP.NET Core 9 API projects and automatically generates a UI containing a minimum version of the usage details of the API, inferring the data by reading the controllers
    
    
     
      and actions.
     
    
   </p>
   <p>
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .8
     
    </em>
    
     , to add a product, it is necessary to provide JSON as the body of the request; in addition, we have a description of the response, containing the HTTP status code 200, which represents
    
    
     
      the success.
     
    
   </p>
   <div><div><img alt="Figure 3.8 – Documentation details for an API" src="img/B21788_03_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.8 – Documentation details for an API
    
   </p>
   <p>
    
     However, if we look at the
    
    <a id="_idIndexMarker219">
    </a>
    
     POST method code (made available through the
    
    <strong class="source-inline">
     
      ProductController
     
    </strong>
    
     class available in the book repository mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section), which registers a product, there is no explicit definition of the HTTP status
    
    
     
      code 200:
     
    
   </p>
   <pre class="source-code">
[HttpPost]
    public IActionResult Post(Product product)
    {
        if (product == null) return <code>BadRequest();</code>
        if (product.Price &lt; 0)
          ModelState.AddModelError("Price",
          "The Price field cannot have a value less
          than zero.");
        if (!ModelState.IsValid)
          return BadRequest(ModelState);
        product.Id = ProductService.Products.Count() + 1;
        ProductService.Add(product);
        return <code>CreatedAtAction</code>(nameof(Get),
           new {id = product.Id}, product);
    }</pre>
   <p>
    
     The method returns two possible HTTP status codes, which are 400, represented by calling the
    
    <strong class="source-inline">
     
      BadRequest
     
    </strong>
    
     method, and 201, which is represented by the
    
    
     <strong class="source-inline">
      
       CreatedAtAction
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .8
     
    </em>
    
     , there is a button labeled
    
    <strong class="bold">
     
      Try it out
     
    </strong>
    
     .
    
    
     Upon clicking this button, the UI will be prepared so that it is possible to add the request body, which in this case will be some JSON that represents a product and its respective properties.
    
    
     Modify the JSON to add a new
    
    <a id="_idIndexMarker220">
    </a>
    
     product, defining the properties as in the example proposed in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .9
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.9 – Running an API request from the Swagger UI" src="img/B21788_03_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.9 – Running an API request from the Swagger UI
    
   </p>
   <p>
    
     After defining the body of the request, click the
    
    <strong class="bold">
     
      Execute
     
    </strong>
    
     button.
    
    
     Just make sure your application
    
    
     
      is running.
     
    
   </p>
   <p>
    
     At the end of the execution, the Swagger UI displays the API response, and as we can clearly see in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     , we have an HTTP status code of 201, in addition to the JSON of the newly registered product and some information in
    
    
     
      the header.
     
    
   </p>
   <div><div><img alt="Figure 3.10 – Swagger API Response screen" src="img/B21788_03_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.10 – Swagger API Response screen
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      CreatedAtAction
     
    </strong>
    
     method creates a response with HTTP status code 201 and adds a link to the header to access the resource created using the GET method, as highlighted in the preceding figure using the address
    
    <strong class="source-inline">
     
      http://localhost:5037/Product/1
     
    </strong>
    
     .
    
    
     This address may vary depending on the execution address in
    
    
     
      your environment.
     
    
   </p>
   <p>
    
     This type of return is good practice and follows the standards defined in the REST protocol.
    
    
     However, although it is not a major problem in the context in which we are presenting the examples, API consumers must be clear about how to consume and what to expect in return to properly deal with each response.
    
    
     In the case of the product registration method, there being no information means that this method would also return an error status, which could cause some non-compliance for the
    
    
     
      API consumer.
     
    
   </p>
   <p>
    
     To adjust this behavior, we
    
    <a id="_idIndexMarker221">
    </a>
    
     must add more information to the API methods using attributes provided by ASP.NET Core 9 such as
    
    <strong class="source-inline">
     
      ProducesResponseType
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       Consumes
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ProducesResponseType
     
    </strong>
    
     attribute is used to determine the type of HTTP status code that will be returned as a response and also the type of content that will be returned.
    
    
     This attribute can also be used in the generic version, typing
    
    
     
      the return.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Consumes
     
    </strong>
    
     attribute determines the type of content expected by the API.
    
    
     The content is defined as a media type and the complete list can be obtained through the
    
    <strong class="source-inline">
     
      MediaTypeNames
     
    </strong>
    
     class available in the
    
    
     <strong class="source-inline">
      
       System.Net.Mime
      
     </strong>
    
    
     
      namespace.
     
    
   </p>
   <p>
    
     Let’s analyze the new implementation of the POST method with the addition
    
    
     
      of attributes:
     
    
   </p>
   <pre class="source-code">
[HttpPost]
[Consumes(MediaTypeNames.Application.Json)]
[ProducesResponseType&lt;Product&gt;(StatusCodes
  .Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
    public IActionResult Post(Product product)
    {
        // code omitted for readability
    }</pre>
   <p>
    
     As we can see in the preceding code, the
    
    <strong class="source-inline">
     
      ProducesResponseType
     
    </strong>
    
     attribute can be added as many times as necessary to represent different return types.
    
    
     In this example, the HTTP status code 201 is being reported, for created items, and one type of return with the HTTP status
    
    
     
      code 400.
     
    
   </p>
   <p>
    
     When running the
    
    <a id="_idIndexMarker222">
    </a>
    
     application again, we can observe the changes made to the code and automatically generated in the Swagger UI, according to
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .11
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.11 – API response documentation" src="img/B21788_03_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.11 – API response documentation
    
   </p>
   <p>
    
     We now have the correct documentation on the aspects involved in the product controller’s POST method, which enables the API to be consumed appropriately by taking into account alternative
    
    
     
      response flows.
     
    
   </p>
   <p class="callout-heading">
    
     XML comments
    
   </p>
   <p class="callout">
    
     In addition to the attributes added to the API methods, it is also possible to use XML comments for each method as part of the Swagger UI documentation.
    
    
     To do this, it will be necessary to configure the project so that the documentation XML is generated during the compilation process and is
    
    <a id="_idIndexMarker223">
    </a>
    
     obtained from the Swagger UI.
    
    
     You can find a complete explanation of this configuration at the
    
    <a id="_idIndexMarker224">
    </a>
    
     following
    
    
     
      address:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&amp;tabs=visual-studio#xml-comments">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&amp;tabs=visual-studio#xml-comments
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In addition to having the ability to create quality APIs with ASP.NET Core 9, we also have the support of a rich API documentation interface, in addition to the option to execute requests and get more details about the request parameters
    
    
     
      and response.
     
    
   </p>
   <p>
    
     Understanding this documentation approach will greatly help you to generate quality services that can be integrated into different systems and contexts.
    
    
     As we progress through the next few chapters, we will further study the use of APIs, documentation, and other technologies such as
    
    
     
      database connections.
     
    
   </p>
   <h1 id="_idParaDest-60">
    <a id="_idTextAnchor060">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we dove deep into the world of HTTP-delivered APIs, discovering the power they have to provide services to a variety of clients.
    
    
     With the robust support of ASP.NET Core, we learned how to make the most of this potential, learning about approaches such as using minimal APIs to create HTTP APIs quickly and efficiently.
    
    
     We also explored the creation of robust APIs using controller-based projects.
    
    
     We looked at other aspects that involve APIs, such as documentation.
    
    
     In the next chapter, we will continue to explore the characteristics of ASP.NET Core 9, understanding how to develop real-time applications
    
    
     
      using SignalR.
     
    
   </p>
  </div>
 </body></html>