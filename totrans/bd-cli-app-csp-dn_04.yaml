- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Command-Line Parsing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行解析
- en: In the previous chapter, we created a console application and learned how to
    pass parameters to it, converting these parameters to their expected data type
    when needed (remember that parameters passed to a console application are of the
    `String` type).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个控制台应用程序，并学习了如何向它传递参数，并在需要时将这些参数转换为预期的数据类型（记住，传递给控制台应用程序的参数是 `String`
    类型）。
- en: However, even though a console application is at the heart of a CLI application,
    a CLI application is more than just a console application. A CLI application contains
    named parameters, switches, and subcommands to achieve the intended goal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管控制台应用程序是CLI应用程序的核心，但CLI应用程序不仅仅是控制台应用程序。CLI应用程序包含命名参数、开关和子命令，以实现预期的目标。
- en: Armed with our knowledge of creating console applications, we’ll build on top
    of that to learn how to create a CLI application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 借助我们创建控制台应用程序的知识，我们将在其基础上学习如何创建CLI应用程序。
- en: 'To do so, in this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，在本章中，我们将涵盖以下主题：
- en: Creating the console application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建控制台应用程序
- en: Parsing the arguments of a console application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析控制台应用程序的参数
- en: 'From console to CLI: parsing the arguments using an existing library'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从控制台到CLI：使用现有库解析参数
- en: By the end of the chapter, you will learn how to start with a simple console
    application and convert it to a powerful CLI application that handles commands,
    subcommands, and options.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学习如何从一个简单的控制台应用程序开始，将其转换为处理命令、子命令和选项的强大CLI应用程序。
- en: Introducing Bookmarkr
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Bookmarkr
- en: '**Bookmarkr** is the name of the CLI application we will be building throughout
    this book.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bookmarkr** 是我们将在这本书中构建的CLI应用程序的名称。'
- en: It is a command-line application for managing bookmarks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于管理书签的命令行应用程序。
- en: Throughout the pages of this book, we will bring *Bookmarkr* to life and add
    more and more features to it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的每一页，我们将让 *Bookmarkr* 生动起来，并为其添加更多功能。
- en: '*Why a* *bookmark manager?*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么需要一个* *书签管理器？*'
- en: Because everyone has used one, so they are familiar with how such a tool works
    and what functionalities it provides.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个人都使用过，所以他们熟悉这种工具的工作方式和它提供的功能。
- en: By removing the burden of understanding the business context of *what* we are
    building, we can then focus all of our attention on *how* we are building it.
    And that is precisely why I chose this application. Plus, it could still be super
    useful 😉.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除理解我们正在构建的“什么”业务背景的负担，我们就可以将全部注意力集中在“如何”构建它上。这正是我选择这个应用程序的原因。此外，它仍然非常有用 😉。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的GitHub仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04)。
- en: Creating the console application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制台应用程序
- en: Let’s start by creating the console application. For this, in Visual Studio
    Code, display the **Terminal** window by going to **View**|**Terminal**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建控制台应用程序。为此，在Visual Studio Code中，通过转到 **视图**|**终端** 来显示 **终端** 窗口。
- en: Then, position yourself where you want the code folder to be created (I mentioned
    in the previous chapter that I always create a `C:\Code` folder that will contain
    all of my code projects).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将您定位到您想要创建代码文件夹的位置（我在上一章提到，我总是创建一个 `C:\Code` 文件夹，它将包含我所有的代码项目）。
- en: 'From there, type the following command to create the console application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，键入以下命令以创建控制台应用程序：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The .NET project currently looks like this when loaded in Visual Studio Code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Visual Studio Code中加载时，.NET项目看起来如下：
- en: '![Figure 4.1 – The bookmarkr project opened in Visual Studio Code](img/B22400_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 在Visual Studio Code中打开的bookmarkr项目](img/B22400_04_01.jpg)'
- en: Figure 4.1 – The bookmarkr project opened in Visual Studio Code
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 在Visual Studio Code中打开的bookmarkr项目
- en: Let’s add some code to the `Program.cs` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Program.cs` 文件中添加一些代码。
- en: The first feature we will implement is the ability to add a new bookmark to
    the list of bookmarks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的第一项功能是能够将新的书签添加到书签列表中。
- en: 'To do so, we need to create a `BookmarkService` class that will contain all
    the logic for the bookmarking operations. By following the best practices of development,
    we will create that class in its own code file, named `BookmarkService.cs`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要创建一个包含所有书签操作逻辑的 `BookmarkService` 类。通过遵循开发的最佳实践，我们将在这个名为 `BookmarkService.cs`
    的单独代码文件中创建这个类：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will need to add a list of `Bookmark` objects to that `BookmarkService`
    class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向那个 `BookmarkService` 类添加一个 `Bookmark` 对象的列表：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will also need to define the `Bookmark` class. Here, again, we will follow
    the best practices of development, and we will create that class in its own code
    file, smartly named `Bookmark.cs` 😊. This class looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义 `Bookmark` 类。在这里，我们再次遵循开发的最佳实践，并将创建这个类在其自己的代码文件中，聪明地命名为 `Bookmark.cs`
    😊。这个类看起来是这样的：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the two properties of the `Bookmark` object cannot be `null`, we declare
    them with the `required` modifier.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Bookmark` 对象的两个属性不能为 `null`，我们使用 `required` 修饰符来声明它们。
- en: 'The updated .NET project now looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 .NET 项目现在看起来是这样的：
- en: '![Figure 4.2 – The updated bookmarkr project opened in Visual Studio Code](img/B22400_04_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 在 Visual Studio Code 中打开的更新后的 bookmarkr 项目](img/B22400_04_02.jpg)'
- en: Figure 4.2 – The updated bookmarkr project opened in Visual Studio Code
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 在 Visual Studio Code 中打开的更新后的 bookmarkr 项目
- en: Now that we have all the pieces in place, let’s see how we can process user
    requests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有部件，让我们看看我们如何处理用户请求。
- en: Parsing the arguments of a console application
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析控制台应用程序的参数
- en: A request to a CLI application usually contains the name of the command (and
    an optional subcommand) along with arguments that provide values to the parameters
    needed by the command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向 CLI 应用程序发出的请求通常包含命令的名称（以及可选的子命令）以及为命令所需的参数提供值的参数。
- en: The first command we will be adding is the ability to add a new bookmark to
    the list of bookmarks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的第一个命令是能够将新的书签添加到书签列表中。
- en: 'The syntax of the expected command is the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 预期命令的语法如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, let’s modify the code to handle such a command!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们修改代码以处理这样的命令！
- en: We will start with the `Main` method of the `Program` class (located in the
    `Program.cs` file). Why? Because this is the method that receives the input parameters
    from the user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `Program` 类的 `Main` 方法（位于 `Program.cs` 文件中）开始。为什么？因为这个方法是接收用户输入参数的方法。
- en: 'Since we may have multiple commands in the future, we will add a `switch` statement
    to handle each one of these. Hence, the code will look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能在未来有多个命令，我们将添加一个 `switch` 语句来处理每一个。因此，代码将看起来像这样：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s explain this code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这段代码：
- en: The `Main` method dispatches the processing of each command to a specific method
    within the `Program` class. Since, for now, we only have one command (`link`),
    we have only one processing method (`ManageLinks`).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main` 方法将每个命令的处理调度到 `Program` 类中的特定方法。由于现在我们只有一个命令（`link`），我们只有一个处理方法（`ManageLinks`）。'
- en: The `ManageLinks` method handles the subcommands related to links. For now,
    we only have one subcommand (`add`) but we can easily imagine having more subcommands,
    such as `update` (to update the URL of an existing link), `remove` (to remove
    an existing link), and `list` (to list all existing links).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManageLinks` 方法处理与链接相关的子命令。目前，我们只有一个子命令（`add`），但我们可以很容易地想象会有更多子命令，例如 `update`（更新现有链接的
    URL）、`remove`（删除现有链接）和 `list`（列出所有现有链接）。'
- en: Finally, the `ShowErrorMessage` method is a utility method used to display error
    messages in red-colored text. Its code can be found in the `Helper` class and
    is omitted here because it does not provide value to the topic we are discussing.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ShowErrorMessage` 方法是一个用于在红色文本中显示错误消息的实用方法。它的代码可以在 `Helper` 类中找到，这里省略因为它对我们讨论的主题没有提供价值。
- en: If you write (or copy) this code, you’ll notice that it does not compile. This
    is due to the `AddLink` method not yet being available in the `BookmarkService`
    class. Let’s add it!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写（或复制）这段代码，你会注意到它无法编译。这是因为 `AddLink` 方法在 `BookmarkService` 类中尚未可用。让我们添加它！
- en: 'The code of the `AddLink` method is the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddLink` 方法的代码如下：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code is pretty simple and straightforward, but let’s explain it briefly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单直接，但让我们简要解释一下：
- en: We first ensure that both the `name` and `url` parameters are provided. If not,
    we return an error message to the user with the expected syntax for the command.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先确保提供了 `name` 和 `url` 参数。如果没有，我们将向用户返回一个错误消息，其中包含命令的预期语法。
- en: We ensure that the link to be added is not already present in the list of bookmarks.
    If it is present, we inform the user with a warning message and invite them to
    use the `update` subcommand if they intend to update an existing link.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确保要添加的链接尚未存在于书签列表中。如果已存在，我们将通过警告消息通知用户，并邀请他们使用 `update` 子命令来更新现有链接。
- en: If the link does not already exist, we add it to the list of bookmarks and inform
    the user with a success message.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果链接尚不存在，我们将它添加到书签列表中，并通过成功消息通知用户。
- en: Pretty easy, isn’t it? 😊
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？😊
- en: However, there is a problem with this approach to building CLI applications.
    Can you guess what it is?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法构建 CLI 应用程序存在一个问题。你能猜到是什么吗？
- en: It is based on positional parameters. In other words, we expect the first parameter
    to be the name of the command, the second parameter to be the name of the subcommand,
    the third parameter to be the value of the `name` parameter, and the fourth parameter
    to be the value of the `url` parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于位置参数。换句话说，我们期望第一个参数是命令的名称，第二个参数是子命令的名称，第三个参数是 `name` 参数的值，第四个参数是 `url` 参数的值。
- en: 'But there are a couple of issues:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但存在一些问题：
- en: How could the user be aware of that order?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户如何知道这个顺序呢？
- en: What if the user provided the `url` value as the third parameter and the `name`
    value as the fourth parameter?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户将 `url` 值作为第三个参数，将 `name` 值作为第四个参数提供怎么办？
- en: 'If you’re familiar with using CLI applications, you will know that the usual
    syntax for a CLI command looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉使用 CLI 应用程序，你会知道 CLI 命令的常用语法看起来像这样：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It can also look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以看起来像这样：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This helps the user to know what is expected as parameters and to provide the
    parameters in the appropriate manner.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于用户了解预期的参数是什么，以及如何以适当的方式提供参数。
- en: We can, of course, rely on the `args` list of parameters and compare each one
    to what is expected (for example, checking whether the third parameter’s value
    is `--name` or `-n` so we know that the fourth parameter represents the value
    of the name of the link, and so on), but this will complexify our code too much.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以依赖参数的 `args` 列表，并将每个参数与预期值进行比较（例如，检查第三个参数的值是否为 `--name` 或 `-n`，这样我们就可以知道第四个参数代表链接的名称，依此类推），但这会使我们的代码过于复杂。
- en: I know what you’re thinking. You’re smart and you’ve already figured out that
    the best approach to solve this problem is to develop a library to parse these
    parameters and figure out what they represent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么。你很聪明，你已经想出了解决这个问题的最佳方法，那就是开发一个库来解析这些参数并找出它们代表什么。
- en: But, because I know you’re smart, I know that you’ve already searched for an
    existing library that does just that. After all, you do not want to reinvent the
    wheel, do you?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，因为我知道你很聪明，我知道你已经搜索过这样一个库。毕竟，你不想重新发明轮子，对吧？
- en: From console to CLI – parsing the arguments using an existing library
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从控制台到 CLI - 使用现有库解析参数
- en: Although many libraries exist for the different programming languages, including
    .NET, we will focus on `System.CommandLine` throughout this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在许多针对不同编程语言的库，包括 .NET，但本书将专注于 `System.CommandLine`。
- en: You may be wondering why we chose this library, especially if you are familiar
    with (or have heard about) `CommandLineParser`, which is another common library
    for that matter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们为什么选择这个库，尤其是如果你熟悉（或者听说过）`CommandLineParser`，这是一个针对该领域的另一个常见库。
- en: There are multiple reasons for that. In essence, `System.CommandLine` is a more
    modern, feature-rich, and performant library, whereas `CommandLineParser` is a
    simpler and more lightweight alternative.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多个原因。本质上，`System.CommandLine` 是一个更现代、功能更丰富、性能更好的库，而 `CommandLineParser` 则是一个更简单、更轻量级的替代方案。
- en: 'Additionally, there are a few other reasons why I prefer `System.CommandLine`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些其他原因让我更喜欢 `System.CommandLine`：
- en: '`System.CommandLine` is a .NET Foundation project developed by Microsoft and
    the community, while `CommandLineParser` is a third-party library'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.CommandLine` 是由微软和社区开发的 .NET 基金会项目，而 `CommandLineParser` 是一个第三方库'
- en: '`System.CommandLine` uses a builder pattern and a more declarative approach
    to define commands and options, while `CommandLineParser` uses attributes and
    a more imperative approach'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.CommandLine` 使用构建器模式和更声明性的方法来定义命令和选项，而 `CommandLineParser` 使用属性和更命令式的方法'
- en: '`System.CommandLine` provides more advanced features out of the box, such as
    command hierarchies, response files, auto-completion, and parsing directives,
    whereas `CommandLineParser` is more lightweight and focused on basic command-line
    parsing'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.CommandLine` 提供了更多开箱即用的高级功能，例如命令层次结构、响应文件、自动完成和解析指令，而 `CommandLineParser`
    则更轻量级，专注于基本的命令行解析'
- en: '`System.CommandLine` is known to be faster and more efficient, especially for
    large command-line structures'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.CommandLine` 被认为是更快、更高效的，尤其是在处理大型命令行结构时'
- en: Even though both libraries are cross-platform, `System.CommandLine` has better
    support for platform-specific conventions, such as case-insensitivity on Windows
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这两个库都是跨平台的，但 `System.CommandLine` 对平台特定约定的支持更好，例如在 Windows 上的不区分大小写
- en: Now, let’s rewrite our application to benefit from the `System.CommandLine`
    library!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重写我们的应用程序以利用 `System.CommandLine` 库！
- en: 'Important note #1'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '重要提示 #1'
- en: The previous code of the `Program.cs` file has been moved into a `Program.Console.txt`
    file for further reference.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs` 文件的上一版代码已被移至 `Program.Console.txt` 文件以供进一步参考。'
- en: 'Important note #2'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '重要提示 #2'
- en: While you can execute the application by its executable name (located in `bin\Debug\net8.0\bookmarkr.exe`),
    it’s more convenient, during the development phase, to use the `dotnet` `run`
    command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以通过其可执行文件名（位于 `bin\Debug\net8.0\bookmarkr.exe`）执行应用程序，但在开发阶段，使用 `dotnet`
    `run` 命令会更方便。
- en: I prefer to rely on the executable name because it matches how we will use the
    application in production. If you prefer to use the `dotnet run` command, simply
    replace `bookmarkr` with `dotnet run` in the following execution syntaxes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢依赖于可执行文件名，因为它与我们将在生产中使用应用程序的方式相匹配。如果您更喜欢使用 `dotnet run` 命令，只需在以下执行语法中将 `bookmarkr`
    替换为 `dotnet run`。
- en: 'The first thing we need to do is to add the `System.CommandLine` NuGet package
    library to our project. To do this, open the Visual Studio Code terminal and type
    the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将 `System.CommandLine` NuGet 包库添加到我们的项目中。为此，打开 Visual Studio Code
    终端并输入以下命令：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the time of the writing of this chapter, this library is still in Beta. When
    it makes it to `--prerelease` switch anymore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章时，这个库仍然处于测试版。当它不再需要 `--prerelease` 开关时。
- en: The way `System.CommandLine` works is to have a `RootCommand` object that will
    act as the root command for all other commands of the CLI application. This means
    that every command in the application has, as a parent, either the `root` command
    or another command whose parent is ultimately the root command.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.CommandLine` 的工作方式是拥有一个 `RootCommand` 对象，它将作为 CLI 应用程序中所有其他命令的根命令。这意味着应用程序中的每个命令都有一个父命令，要么是
    `root` 命令，要么是最终父命令是根命令的其他命令。'
- en: Adding the root command
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加根命令
- en: The root command is the one that gets called when the user invokes the CLI application
    with no parameters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根命令是在用户不带参数调用 CLI 应用程序时被调用的命令。
- en: 'The root command is an instance of the `RootCommand` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根命令是 `RootCommand` 类的一个实例：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A command has a handler, which is a method that is called as the result of
    the user invoking that command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命令有一个处理程序，这是一个在用户调用该命令时被调用的方法：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `SetHandler` method takes a delegate to the actual method that does the
    job:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetHandler` 方法接受一个指向实际执行工作的方法的委托：'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, and since the `System.CommandLine` library follows the `Builder` pattern,
    we need to build and invoke a parser to kick things in:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 `System.CommandLine` 库遵循 `Builder` 模式，我们需要构建和调用解析器来启动操作：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Last but not least, let’s add the required `using` statements at the top of
    the file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们在文件顶部添加所需的 `using` 语句：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are now ready to execute our application! Type the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以执行我们的应用程序了！输入以下内容：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When executed, the application will invoke the appropriate command (here, the
    root command since no argument was passed to the executing application), which,
    in turn, will invoke its handler method (`OnHandleRootCommand`), and the result
    of its execution will be returned to the user. In this example, the command will
    display the message `"Hello from the` `root command!"`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，应用程序将调用适当的命令（在这里，由于没有向执行应用程序传递任何参数，所以是根命令），然后它将调用其处理方法（`OnHandleRootCommand`），并且其执行结果将返回给用户。在这个例子中，命令将显示消息
    `"Hello from the"` `root command!"`。
- en: '![Figure 4.3 – Invoking the root command](img/B22400_04_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 调用根命令](img/B22400_04_03.jpg)'
- en: Figure 4.3 – Invoking the root command
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 调用根命令
- en: Isn’t that exciting? No? You’re right… This is not (yet) looking like a CLI
    application. Let’s add another command!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是令人兴奋吗？不？您是对的…这（目前）看起来不是一个CLI应用程序。让我们添加另一个命令！
- en: Adding the link command
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加链接命令
- en: 'The syntax for adding bookmarks using our CLI application is supposed to be
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的CLI应用程序添加书签的语法应该是这样的：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, we need to create a `link` command. This command will have the root command
    as a parent:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个`link`命令。此命令将以根命令作为父命令：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need an `add` command, whose parent will be the `link` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`add`命令，其父命令将是`link`命令：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s execute this application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行这个应用程序：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pretty close, huh?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 很接近，对吧？
- en: The only elements that are missing are the `<name>` and `<url>` parts. These
    are called **options**, and we will look into them in a moment. But first, let’s
    focus on commands.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的唯一元素是`<name>`和`<url>`部分。这些被称为**选项**，我们将在稍后探讨它们。但首先，让我们专注于命令。
- en: About commands
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于命令
- en: Commands are like a tree where the root command is… well, the root of that tree.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 命令就像一棵树，其中根命令是…嗯，那棵树的根。
- en: Each command has a parent, which is either another command (for example, `add`
    has `link` as a parent), or the root command itself (as for the `link` command).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都有一个父命令，它可以是另一个命令（例如，`add`的父命令是`link`），或者根命令本身（例如，`link`命令）。
- en: 'The command tree dictates the syntax of the CLI application. For example, we
    cannot perform the following call:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 命令树决定了CLI应用程序的语法。例如，我们无法执行以下调用：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because no `add` command has the root command as a parent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为没有`add`命令以根命令作为父命令。
- en: Do all commands need to have a handler method?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有命令都需要有处理方法吗？
- en: The answer is, no, they don’t. Only commands that actually do some processing
    need to have a handler method. In our case, neither the root command nor the `link`
    command require a handler.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，不，它们不需要。只有实际执行一些处理的命令才需要处理方法。在我们的例子中，根命令和`link`命令都不需要处理方法。
- en: Adding options to the link command
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向链接命令添加选项
- en: 'Since the `add` command requires two parameters (`name` and `url`), we will
    add two options to it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`add`命令需要两个参数（`name`和`url`），我们将向其中添加两个选项：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, an `Option` is defined by the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个`Option`是通过以下方式定义的：
- en: The data type of its value (here, a string)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其值的类型（这里是一个字符串）
- en: Its aliases (for `urlOption`, these are `--url` and `-u`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的别名（对于`urlOption`，这些是`--url`和`-u`）
- en: Its description, which will be useful when requesting the help menu for that
    command (for `urlOption`, it is `"The URL of` `the bookmark"`)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的描述，当请求该命令的帮助菜单时将很有用（对于`urlOption`，它是`"The URL of the bookmark"`）
- en: 'Next, we need to assign these options to the command, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这些选项分配给命令，如下所示：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then need to pass these options to the `Handler` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将这些选项传递给`Handler`方法：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And, finally, we use the values of these options in the `Handler` method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`Handler`方法中使用这些选项的值：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if we execute the application, we get the expected result. This time,
    we saved about half of the code by not having to parse the arguments of the console
    application and delegating this to the `System.CommandLine` library:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行应用程序，我们会得到预期的结果。这次，我们没有解析控制台应用程序的参数并将此委托给`System.CommandLine`库，因此节省了大约一半的代码：
- en: '![Figure 4.4 – We successfully added a bookmark](img/B22400_04_04.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 我们成功添加了一个书签](img/B22400_04_04.jpg)'
- en: Figure 4.4 – We successfully added a bookmark
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 我们成功添加了一个书签
- en: 'Note that, using the aliases, we can execute the CLI application using this
    syntax:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用别名，我们可以使用以下语法执行CLI应用程序：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use this syntax:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下语法：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The result will be the same as the one shown in *Figure 4**.4*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将与*图4**.4*中显示的相同。
- en: What other types of options can we use?
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以使用哪些其他类型的选项？
- en: '`System.CommandLine` doesn’t only support `string` options. `Option<T>` is
    a generic type, so you can create an `Option<T>` for any data type. This, for
    example, could be the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.CommandLine`不仅支持`string`选项。`Option<T>`是一个泛型类型，因此您可以为任何数据类型创建一个`Option<T>`。例如，以下可以是以下内容：'
- en: '`int`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`double`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`bool`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`'
- en: '`DateTime`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`'
- en: '`Uri`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uri`'
- en: '`TimeSpan`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeSpan`'
- en: '`Regex`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Regex`'
- en: '`Enum`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enum`'
- en: '`IPAddress`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPAddress`'
- en: '`FileInfo`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInfo`'
- en: It could even be your own custom class if you prefer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，甚至可以是您自己的自定义类。
- en: Depending on the data type we use, the provided value for the option will be
    parsed into that data type. If parsing fails, an exception will be raised, and
    an error message will be displayed to the console.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们使用的数据类型，提供的选项值将被解析为该数据类型。如果解析失败，将引发异常，并在控制台显示错误信息。
- en: 'Here is an illustrative example. The root command has been updated to accept
    an integer option. When the program is executed and a value that cannot be parsed
    into an integer is provided for that option, we get the following error message:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个说明性的例子。根命令已被更新以接受一个整数选项。当程序执行时，如果为该选项提供了一个无法解析为整数的值，我们将得到以下错误信息：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hmm… Although the name of the option indicates that it is expecting a number,
    it is not clear what that number is all about. What is its purpose? Is there a
    range of valid values for that number? A little help would be… well, helpful here
    😊.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……虽然选项的名称表明它期望一个数字，但并不清楚这个数字是什么。它的目的是什么？这个数字的有效值范围是什么？一点帮助在这里……嗯，很有帮助 😊。
- en: Getting help
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取帮助
- en: The good news is that when using `System.CommandLine`, we get the help menu
    automatically built for us. All we need to do is to provide meaningful names and
    descriptions to our commands and options and the library will do the rest.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，当使用`System.CommandLine`时，我们自动获得为我们构建的帮助菜单。我们只需要为我们自己的命令和选项提供有意义的名称和描述，库就会完成其余的工作。
- en: 'We can get help by using either one of these options:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下任一选项来获取帮助：
- en: '`--``help`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--help`'
- en: '`-h`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`'
- en: '`-?`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-?`'
- en: 'The result will look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![Figure 4.5 – Help!](img/B22400_04_05.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 帮助！](img/B22400_04_05.jpg)'
- en: Figure 4.5 – Help!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 帮助！
- en: 'This also works for subcommands. For example, if we want to get help regarding
    the `link` command, we can type the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于子命令。例如，如果我们想获取有关`link`命令的帮助，我们可以输入以下内容：
- en: '![Figure 4.6 – Getting help for the link command](img/B22400_04_06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 获取链接命令的帮助](img/B22400_04_06.jpg)'
- en: Figure 4.6 – Getting help for the link command
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 获取链接命令的帮助
- en: 'We can do this for one subcommand at a time, such as the `link add` command,
    for example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一次为一个子命令做这件事，例如`link add`命令，例如：
- en: '![Figure 4.7 – Getting help for the link add command](img/B22400_04_07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 获取链接添加命令的帮助](img/B22400_04_07.jpg)'
- en: Figure 4.7 – Getting help for the link add command
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 获取链接添加命令的帮助
- en: Important note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You have probably noticed that the `dotnet run` syntax for getting help requires
    an extra `--`. This is not a typo. It is required because, otherwise, the .NET
    CLI tool will *think* that you are requesting help with the `dotnet` tool.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，获取帮助的`dotnet run`语法需要额外的`--`。这不是一个打字错误。这是必需的，因为否则，.NET CLI 工具会认为你正在请求`dotnet`工具的帮助。
- en: The extra `--` is used to separate the arguments that are passed to `dotnet
    run` from the arguments that are passed to the application being run. Everything
    after `--` is considered an argument to the application, not to `dotnet run`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的`--`用于将传递给`dotnet run`的参数与传递给正在运行的应用程序的参数分开。`--`之后的所有内容都被认为是应用程序的参数，而不是`dotnet
    run`的参数。
- en: However, one thing we should keep in mind is that the usage of a CLI application
    (and hence, its help) depends on the current version of the application. But how
    do we get that information?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该记住的是，CLI 应用程序的使用（及其帮助）取决于应用程序的当前版本。但我们如何获取这些信息呢？
- en: Getting the application’s version number
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取应用程序的版本号
- en: There is a built-in option (`--version`) that displays the version number of
    the CLI application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个内置选项（`--version`）可以显示 CLI 应用的版本号。
- en: 'To display it, execute the command as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示它，请按以下方式执行命令：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: But where does this value come from?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个值是从哪里来的？
- en: 'Well, it can be found in the `.csproj` file, within the `<PropertyGroup>` element
    at the beginning of the file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它可以在`.csproj`文件的开始处的`<PropertyGroup>`元素中找到：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that if no `<version>` element is provided, the default value to be returned
    will be `1.0.0`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有提供`<version>`元素，则默认返回的值将是`1.0.0`。
- en: Important note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Here, too, if you want to use the `dotnet run` syntax to query the version
    number of the application, you’ll need to use the extra `--`, as follows: `dotnet
    run -- --``version`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果你想使用`dotnet run`语法查询应用程序的版本号，你将需要使用额外的`--`，如下所示：`dotnet run -- --version`。
- en: And that’s it! You’re now all set and ready to create your first CLI application!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在已经准备好创建你的第一个 CLI 应用程序了！
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to build our very own CLI application, *Bookmarkr*,
    which is a bookmark manager provided as a CLI application, so it can be used within
    a Terminal window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始构建我们自己的CLI应用程序，*Bookmarkr*，这是一个作为CLI应用程序提供的书签管理器，因此它可以在终端窗口中使用。
- en: We started with a console application (because remember, “At the core of every
    CLI application is a console application”), and then we introduced a library for
    parsing its command-line arguments including commands, subcommands, and options
    so we don’t need to reinvent the wheel.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个控制台应用程序开始（因为记住，“每个CLI应用程序的核心都是一个控制台应用程序”），然后我们引入了一个用于解析其命令行参数的库，包括命令、子命令和选项，这样我们就不需要重新发明轮子。
- en: In the upcoming chapter, we will see how to control inputs and outputs and how
    to read data from and write data to a file so we can perform backup and restore
    operations for our bookmarks. This will prove especially useful to import and
    export bookmarks into and out of our bookmark manager application
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何控制输入和输出，以及如何从文件读取数据并将数据写入文件，这样我们就可以为我们的书签执行备份和恢复操作。这将对将书签导入和导出我们的书签管理器应用程序特别有用
- en: Your turn!
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码是一种通过实践学习的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下功能来改进*Bookmarkr*应用程序。
- en: 'Task #1 – Delete an existing bookmark'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 删除现有书签'
- en: 'The syntax is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It can also be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以是这样的：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the requested link name does not exist, the application should display a
    warning message to the user. Otherwise, the application should delete that bookmark
    and display a success message to the user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的链接名称不存在，应用程序应向用户显示警告消息。否则，应用程序应删除该书签并向用户显示成功消息。
- en: 'Task #2 – Update an existing bookmark'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 更新现有书签'
- en: 'The syntax is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It can also be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以是这样的：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the requested link name does not exist, the application should display an
    error message to the user and invite them to use the `add` command to add a new
    bookmark. Otherwise, the application should update the existing bookmark with
    the newly provided URL and display a success message to the user.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的链接名称不存在，应用程序应向用户显示错误消息，并邀请他们使用`add`命令添加新的书签。否则，应用程序应使用新提供的URL更新现有书签，并向用户显示成功消息。
- en: 'Task #3 – List all existing bookmarks'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #3 – 列出所有现有书签'
- en: 'The syntax is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It can also be as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以是这样的：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the list of bookmarks contains no items, the application should display
    a warning message saying that the list of bookmarks is empty and, therefore, there
    is nothing to display. Otherwise, the application should present the list of bookmarks
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果书签列表中没有项目，应用程序应显示警告消息，说明书签列表为空，因此没有内容可显示。否则，应用程序应按以下方式呈现书签列表：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
