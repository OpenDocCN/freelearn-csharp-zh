- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Lighting Using the Universal Render Pipeline
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用渲染管线进行照明
- en: '**Lighting** is a complex topic and there are several possible ways to handle
    it, with each one having its pros and cons. In order to get the best possible
    quality and performance, you need to know exactly how your renderer handles lighting,
    and that is exactly what we are going to do in this chapter. We will discuss how
    lighting is handled in Unity’s **Universal Render Pipeline** (**URP**), as well
    as how to properly configure it to adapt our scene’s mood with proper lighting
    effects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**照明**是一个复杂的话题，处理它有几种可能的方法，每种方法都有其优缺点。为了获得最佳的质量和性能，你需要确切地知道你的渲染器如何处理照明，这正是我们将在本章中要做的。我们将讨论在Unity的**通用渲染管线**（**URP**）中如何处理照明，以及如何正确配置它以适应场景的氛围，并使用适当的照明效果。'
- en: 'In this chapter, we will examine the following lighting concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查以下照明概念：
- en: Applying lighting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用照明
- en: Applying shadows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用阴影
- en: Optimizing lighting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化照明
- en: At the end of the chapter, we will have properly used the different Unity Illumination
    systems like Direct Lights and Lightmapping to reflect a cloudy and rainy night.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将正确使用不同的Unity照明系统，如直接光照和光照贴图，以反映多云和雨夜的景象。
- en: Applying lighting
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用照明
- en: When discussing ways to process lighting in a game, there are two main ways
    we can do so, known as **Forward Rendering** and **Deferred Rendering**. Both
    handle lighting in a different order, with different techniques, requirements,
    pros, and cons. Forward Rendering is usually recommended for performance, while
    Deferred Rendering is usually recommended for quality. The latter is used by the
    **High Definition Render Pipeline** of Unity, the renderer used for high-quality
    graphics in high-end devices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论在游戏中处理照明的方法时，有两种主要的方法，称为**前向渲染**和**延迟渲染**。它们以不同的顺序、不同的技术、不同的要求、优点和缺点来处理照明。前向渲染通常推荐用于性能，而延迟渲染通常推荐用于质量。后者是Unity的**高清渲染管线**（**HDRP**）所使用的，用于高端设备中的高质量图形。
- en: 'At the time of writing this book, Unity is developing a performant version
    for URP. Also, in Unity, the Forward Renderer comes with two modes: **Multi-Pass
    Forward**, which is used in the Built-In Renderer (the old Unity Renderer), and
    **Single Pass Forward,** which is used in URP. Again, both have their pros and
    cons.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Unity正在为URP开发一个性能版本。此外，在Unity中，前向渲染器有两种模式：**多遍历前向**，用于内置渲染器（旧的Unity渲染器），以及**单遍历前向**，用于URP。同样，两者都有其优缺点。
- en: Choosing between them depends on the kind of game you are creating and the platform
    you need to run the game on. Your chosen option will change a lot due to the way
    you apply lighting to your scene, so it’s crucial you understand which system
    you are dealing with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪种方法取决于你正在创建的游戏类型以及你需要将游戏运行在哪个平台上。你选择的选项将因你如何将照明应用于场景而大量变化，因此了解你正在处理哪个系统至关重要。
- en: 'In the next section, we will discuss the following real-time lighting concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论以下实时照明概念：
- en: Discussing lighting methods
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论照明方法
- en: Configuring ambient lighting with skyboxes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用天空盒配置环境照明
- en: Configuring lighting in URP
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URP中配置照明
- en: Let’s start by comparing the previously mentioned lighting methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从比较之前提到的照明方法开始。
- en: Discussing lighting methods
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论照明方法
- en: 'To recap, we mentioned three main ways of processing lighting at the beginning
    of this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们在本章开头提到了三种处理照明的最主要方式：
- en: Forward Rendering (Single Pass)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染（单次遍历）
- en: Forward Rendering (Multi-Pass)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染（多遍历）
- en: Deferred Rendering
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟渲染
- en: 'Before we look at the differences between each, let’s talk about the things
    they have in common. Those three renderers start drawing the scene by determining
    which objects can be seen by the camera—that is, the ones that fall inside the
    camera’s frustum, and provide a giant pyramid that can be seen when you select
    the camera:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看每种方法之间的差异之前，让我们谈谈它们共有的特点。这三个渲染器开始绘制场景，通过确定哪些物体可以被相机看到——即那些落在相机视锥体内的物体，并提供一个当你选择相机时可以看到的巨大金字塔：
- en: '![Image result for unity occlusion culling](img/B18585_12_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for unity occlusion culling](img/B18585_12_01.png)'
- en: 'Figure 12.1: Camera’s frustum showing only the objects that can be seen by
    it'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：显示仅由相机看到的物体的相机视锥体
- en: After that, Unity will order them from the nearest to the camera to the farthest
    (transparent objects are handled a little bit differently, but let’s ignore that
    for now). It’s done like this because it’s more probable that objects nearer to
    the camera will cover most of the camera, so they will occlude others (will block
    other objects from being seen), preventing us from wasting resources calculating
    pixels for the occluded ones.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Unity 将按照从相机最近到最远的顺序排列它们（透明对象的处理方式略有不同，但在此我们先忽略这一点）。这样做的原因是因为靠近相机的对象更有可能覆盖大部分相机视野，因此它们会遮挡其他对象（会阻止其他对象被看到），从而防止我们浪费资源计算被遮挡对象的像素。
- en: Finally, Unity will try to render the objects in that order. This is where differences
    start to arise between lighting methods, so let’s start comparing the two Forward
    Rendering variants. For each object, Single Pass Forward Rendering will calculate
    the object’s appearance, including all the lights that are affecting the object,
    in one shot, or what we call a draw call.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Unity 将按照这个顺序尝试渲染这些对象。这就是不同光照方法开始出现差异的地方，因此让我们开始比较两种前向渲染变体。对于每个对象，单次遍历前向渲染将在一次操作中计算对象的外观，包括所有影响该对象的光源，或者我们称之为绘制调用。
- en: 'A **draw call** is the exact moment when Unity asks the video card to actually
    render the specified object. All the previous work was just preparation for this
    moment. In the case of the Multi-Pass Forward Renderer, by simplifying a little
    bit of the actual logic, Unity will render the object once per light that affects
    the object; so, if the object is being lit by three lights, Unity will render
    the object three times, meaning that three draw calls will be issued, and three
    calls to the GPU will be made to execute the rendering process:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制调用**是 Unity 要求显卡实际渲染指定对象的精确时刻。所有之前的工作都是为了这一刻做准备。在多遍历前向渲染器的情况下，通过稍微简化实际逻辑，Unity
    将针对影响该对象的光源渲染该对象一次；因此，如果对象被三个光源照亮，Unity 将渲染该对象三次，这意味着将发出三个绘制调用，并且将向 GPU 发出三个调用以执行渲染过程：'
- en: '![](img/B18585_12_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_02.png)'
- en: 'Figure 12.2: Left image, first draw call of a sphere affected by two lights
    in Multi-Pass; middle image, second draw call of the sphere; and right image,
    the combination of both draw calls'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：左图，多遍历中受两个光源影响球体的第一次绘制调用；中图，球体的第二次绘制调用；右图，两次绘制调用的组合
- en: Now is when you are probably thinking, *“Why should I use Multi-Pass? Single
    Pass is more performant!”* And yes, you are right! Single Pass is much more performant
    than Multi-Pass, meaning our game will run at higher frames per second, and here
    comes the great but. A draw call in a GPU has a limited amount of operations that
    can be executed, so you have a limit to the complexity of the draw call. Calculating
    the appearance of an object and all the lights that affect it is very complex,
    and in order to make it fit in just one draw call, Single Pass executes simplified
    versions of lighting calculations, meaning less lighting quality and fewer features.
    They also have a limit on how many lights can be handled in one shot, which, at
    the time of writing this book, is eight per object, although you can configure
    fewer if you want, but the default value is good for us. This sounds like a small
    number, but it’s usually just enough.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能正在想，“为什么我要使用多遍历？单遍历性能更好！”是的，你是对的！单遍历比多遍历性能更好，这意味着我们的游戏将以更高的帧率运行，但是有一个大问题。GPU
    中的绘制调用有一个可以执行的操作数量限制，因此绘制调用的复杂度有限。计算对象的外观以及所有影响它的光源非常复杂，为了使其适应仅一次绘制调用，单遍历执行了光照计算的简化版本，这意味着光照质量较低，功能较少。它们还对一次可以处理的光源数量有限制，截至本书编写时，每个对象为八个，尽管你可以根据需要配置更少，但默认值对我们来说已经足够好了。这听起来像是一个小数字，但通常已经足够了。
- en: On the other side, Multi-Pass can apply any number of lights you want and can
    execute different logic for each light. Let’s say our object has four lights that
    are affecting it, but there are two lights that are affecting it drastically because
    they are nearer or have higher intensity, while the remaining ones affecting the
    object are just enough to be noticeable. In this scenario, we can render the first
    two lights with higher quality and the remaining ones with cheap calculations—no
    one will be able to tell the difference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，多遍历可以应用你想要的任意数量的灯光，并且可以为每个灯光执行不同的逻辑。假设我们的对象有四个影响它的灯光，但有两个灯光影响它非常严重，因为它们更近或强度更高，而其余的只是足够明显地影响对象。在这种情况下，我们可以用高质量渲染前两个灯光，而用低价计算渲染剩余的灯光——没有人会注意到差异。
- en: 'In this case, Multi-Pass can calculate the first two lights using **Pixel Lighting**
    and the remaining ones using **Vertex Lighting**. The difference is in their names;
    Pixel calculates light per object’s pixel, while Vertex calculates lighting per
    object vertex and fills the pixels between these vertexes, thereby interpolating
    information between vertexes. You can clearly see the difference in the following
    images:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，多遍历可以使用**像素光照**计算前两个灯光，其余的则使用**顶点光照**。区别在于它们的名称；像素是按对象像素计算光照，而顶点是按对象顶点计算光照，并填充这些顶点之间的像素，从而在顶点之间插值信息。你可以在以下图像中清楚地看到差异：
- en: '![](img/B18585_12_03.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_03.png)'
- en: 'Figure 12.3: Left image, a sphere being rendered with Vertex Lighting; right
    image, a sphere being rendered with Pixel Lighting'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：左图，使用顶点光照渲染的球体；右图，使用像素光照渲染的球体
- en: In Single Pass, calculating everything in a single draw call forces you to use
    Vertex Lighting or Pixel Lighting; you cannot combine them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次遍历中，在一个绘制调用中计算所有内容迫使你必须使用顶点光照或像素光照；你不能将它们结合起来。
- en: So, to summarize the differences between Single and Multi-Pass, in Single, you
    have better performance because each object is just drawn once, but you are limited
    to the number of lights that can be applied, while in Multi-Pass, you need to
    render the object several times, but with no limits on the number of lights, and
    you can specify the exact quality you want for each light. There are other things
    to consider, such as the actual cost of a draw call (one draw call can be more
    expensive than two simple ones), and special lighting effects such as toon shading,
    but let’s keep things simple.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了总结单次遍历和多遍历之间的区别，在单次遍历中，由于每个对象只绘制一次，所以性能更好，但你受到可应用灯光数量的限制，而在多遍历中，你需要渲染对象多次，但灯光数量没有限制，你可以为每个灯光指定你想要的确切质量。还有其他一些事情需要考虑，比如绘制调用的实际成本（一个绘制调用可能比两个简单的调用更昂贵），以及像卡通着色这样的特殊光照效果，但让我们保持简单。
- en: Finally, let’s briefly discuss Deferred. Even though we are not going to use
    it, it’s interesting to know why we are not doing that. After determining which
    objects fall inside the frustum and ordering them, Deferred will render the objects
    without any lighting, generating what is called a **G-Buffer**. A G-Buffer is
    a set of several images that contain different information about the objects of
    the scene, such as the colors of their pixels (without lighting), the direction
    of each pixel (known as **Normals**), and how far from the camera the pixels are.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要讨论一下延迟渲染。即使我们不会使用它，了解为什么我们不这样做也是很有趣的。在确定哪些对象位于视锥体内并对它们进行排序后，延迟渲染将不进行任何光照渲染对象，生成所谓的**G-Buffer**。G-Buffer是一组包含有关场景中对象不同信息的图像，例如像素的颜色（无光照）、每个像素的方向（称为**法线**）以及像素与摄像机的距离。
- en: 'You can see a typical example of a G-Buffer in the following image:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图像中看到G-Buffer的典型示例：
- en: '![](img/B18585_12_04.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_04.png)'
- en: 'Figure 12.4: Left image, plain colors of the object; middle image, depths of
    each pixel; and right image, normals of the pixels'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：左图，对象的单调颜色；中图，每个像素的深度；右图，像素的法线
- en: Normals are directions, and the *x*, *y*, and *z* components of the directions
    are encoded in the RGB components of the colors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 法线是方向，方向的*x*、*y*和*z*分量编码在颜色的RGB分量中。
- en: 'After rendering all the objects in the scene, Unity will iterate over all lights
    that can be seen in the camera, thus applying a layer of lighting over the G-Buffer,
    taking information from it to calculate that specific light. After all the lights
    have been processed, you will get the following result:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染场景中的所有对象之后，Unity将遍历相机中可以看到的所有光源，从而在G-Buffer上应用一层光照，并从中获取信息来计算特定的光照。处理完所有光源后，你会得到以下结果：
- en: '![](img/B18585_12_05.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_05.png)'
- en: 'Figure 12.5: Combination of the three lights that were applied to the G-Buffer
    shown in the previous image'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：前一张图片中应用于G-Buffer的三个光源的组合
- en: As you can see, the Deferred part of this method comes from the idea of calculating
    lighting as the last stage of the rendering process. This is better because you
    won’t waste resources calculating lighting from objects that can potentially be
    occluded. If the floor of the image is being rendered first in **Forward** mode,
    the pixels that the rest of the objects are going to occlude were calculated in
    vain. Also, there’s the pro that Deferred just calculates lighting in the exact
    pixels that the light can reach. As an example, if you are using a flashlight,
    Unity will calculate lighting only in the pixels that fall inside the cone of
    the flashlight. The con here is that Deferred is not supported by some relatively
    old video cards and that you can’t calculate lighting with Vertex Lighting quality,
    so you will need to pay the price of Pixel Lighting, which is not recommended
    on low-end devices (or even necessary in simple graphics games).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这种方法中的“延迟”部分来源于将光照计算作为渲染过程的最后阶段的想法。这样做更好，因为你不会浪费资源去计算那些可能被遮挡的对象的光照。如果在**前向**模式下首先渲染图像的地面，那么其他对象将要遮挡的像素就会被无用地计算。此外，延迟渲染只计算光线能够到达的确切像素的光照。例如，如果你使用手电筒，Unity只会计算手电筒锥形范围内的像素的光照。这里的缺点是延迟渲染不支持一些相对较旧的显卡，并且你不能使用顶点光照质量进行光照计算，因此你需要付出像素光照的代价，这在低端设备上（甚至在简单的图形游戏中）是不推荐的。
- en: So, why are we using URP with Single Pass Forward? Because it offers the best
    balance between performance, quality, and simplicity. In this game, we won’t be
    using too many lights, so we won’t worry about the light number limitations of
    Single Pass. If you need more lights, you can use Deferred, but consider the extra
    hardware requirements and the performance cost of not having per-vertex lighting
    options. Now that we have a very basic notion of how URP handles lighting, let’s
    start using it!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么使用单次遍历前向渲染（URP）呢？因为它在性能、质量和简单性之间提供了最佳平衡。在这个游戏中，我们不会使用太多光源，所以不会担心单次遍历的光源数量限制。如果你需要更多光源，可以使用延迟渲染，但请考虑额外的硬件要求以及没有顶点光照选项的性能成本。现在我们已经对URP如何处理光照有了非常基本的了解，让我们开始使用它吧！
- en: Configuring ambient lighting with skyboxes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用天空盒配置环境光照
- en: There are different light sources that can affect a scene, such as the sun,
    flashlights, light bulbs, and more. Those are known as **Direct Lights**—that
    is, objects that emit light rays. Then, we have **Indirect Light**, which represents
    how the Direct Light bounces on other objects, like walls. However, calculating
    all the bounces of all the rays emitted by all the lights is extremely costly
    in terms of performance and requires special hardware that supports ray tracing.
    The problem is that not having Indirect Light will generate unrealistic results,
    where you can observe places where the sunlight doesn’t reach being completely
    dark because no light is bouncing from other places where light hits.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的光源可以影响场景，例如太阳、手电筒、灯泡等等。这些被称为**直接光源**——即发出光线的对象。然后，我们有**间接光源**，它表示直接光源如何在其他对象上反射，比如墙壁。然而，计算所有光源发出的所有光线的所有反射是非常昂贵的，从性能角度来看，并且需要支持光线追踪的特殊硬件。问题是，如果没有间接光源，将会产生不真实的结果，你可以观察到阳光无法到达的地方会变得完全黑暗，因为没有来自光线击中其他地方的光线反射。
- en: 'In the next image you can see an example of how this could look in a wrongly
    configured scene:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图片中，你可以看到一个错误配置的场景中可能的样子：
- en: '![](img/B18585_12_06.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_06.png)'
- en: 'Figure 12.6: Shadows projected on a mountain without ambient lighting'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：没有环境光照的山上投射的阴影
- en: If you ever experience this problem, the way to solve it performantly is using
    approximations of those bounces. These are what we call **Ambient Light**. This
    represents a base layer of lighting that usually applies a little bit of light
    based on the color of the sky, but you can choose whatever color you want. As
    an example, on a clear night, we can pick a dark blue color to represent the tint
    from the moonlight.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到这个问题，解决它的有效方法是使用那些反弹的近似值。这些就是我们所说的**环境光**。这代表了一层基础光照，通常根据天空的颜色应用一点光，但您可以选择任何您想要的颜色。例如，在晴朗的夜晚，我们可以选择深蓝色来代表月光带来的色调。
- en: 'If you create a new scene in Unity 2022, usually this is done automatically,
    but in cases where it isn’t, or the scene was created through other methods, it
    is convenient to know how to manually trigger this process by doing the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Unity 2022中创建新场景，通常这是自动完成的，但在没有自动完成或场景是通过其他方法创建的情况下，了解如何通过以下方式手动触发此过程是有用的：
- en: 'Click on **Window** | **Rendering | Lighting**. This will open the **Scene
    Lighting Settings** window:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**窗口** | **渲染** | **光照**。这将打开**场景光照设置**窗口：
- en: '![](img/B18585_12_07.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_07.png)'
- en: 'Figure 12.7: Lighting Settings location'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：光照设置位置
- en: 'Click the **Generate Lighting** button at the bottom of the window. If you
    haven’t saved the scene so far, a prompt will ask you to save it, which is necessary:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口底部的**生成光照**按钮。如果您到目前为止还没有保存场景，将弹出一个提示要求您保存它，这是必要的：
- en: '![](img/B18585_12_08.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_08.png)'
- en: 'Figure 12.8: Generate Lighting button'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：生成光照按钮
- en: 'See the bottom-right part of the Unity window to check the progress calculation
    bar to check when the process has finished:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Unity窗口的右下角，检查进度计算条，以查看何时完成进程：
- en: '![](img/B18585_11_091.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_11_091.png)'
- en: 'Figure 12.9: Lighting generation progress bar'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：光照生成进度条
- en: 'You can now see how completely dark areas are now lit by the light being emitted
    by the sky:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以看到完全黑暗的区域现在被天空发出的光照亮：
- en: '![](img/B18585_12_10.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_10.png)'
- en: 'Figure 12.10: Shadows with ambient lighting'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：带有环境光照的阴影
- en: 'Now, by doing this, we have better lighting, but it still looks like a sunny
    day. Remember, we want to have rainy weather. In order to do that, we need to
    change the default sky too so that it’s cloudy. You can do that by downloading
    a **skybox**. The current sky you can see around the scene is just a big cube
    containing textures on each side, and those textures have a special projection
    to prevent us from detecting the edges of the cube. We can download six images
    for each side of the cube and apply them to have whatever sky you want, so let’s
    do that:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这样做，我们有了更好的光照，但它仍然看起来像晴天。记住，我们想要的是雨天。为了做到这一点，我们需要更改默认的天空，使其多云。您可以通过下载**天空盒**来实现这一点。您现在在场景周围看到的当前天空只是一个包含每个面的纹理的大立方体，这些纹理具有特殊的投影，以防止我们检测到立方体的边缘。我们可以为立方体的每个面下载六张图片，并将它们应用到您想要的任何天空，所以让我们这样做：
- en: You can download skybox textures from wherever you want, but here, I will choose
    the Asset Store. Open it by going to **Window | Asset Store** and going to the
    Asset Store website.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从任何地方下载天空盒纹理，但在这里，我将选择资产商店。通过前往**窗口 | 资产商店**并访问资产商店网站来打开它。
- en: 'Look for **Categories | 2D | Textures & Materials | Sky** in the category list
    on the right. Remember that you need to make that window wider if you can’t see
    the category list:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的分类列表中查找**分类 | 2D | 纹理与材质 | 天空**。记住，如果您看不到分类列表，需要将窗口变宽：
- en: '![](img/B18585_12_11.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_11.png)'
- en: 'Figure 12.11: Textures & Materials'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：纹理与材质
- en: Remember to check the **Free Assets** checkbox in the **Price** options.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在**价格**选项中勾选**免费资源**复选框。
- en: 'Pick any skybox you like for a rainy day. Take into account that there are
    different formats for skyboxes. We are using the six-image format, so check that
    before downloading one. There’s another format called **Cubemap**, which is essentially
    the same, but we will stick with the six-image format as it is the simplest one
    to use and modify. In my case, I have chosen the skybox pack shown in *Figure
    12.12*. Download and import it, as we did in *Chapter 5*, *Introduction to C#
    and Visual Scripting*:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您喜欢的雨天天空盒。请注意，天空盒有不同的格式。我们使用的是六图像格式，所以在下载之前请检查这一点。还有一种格式叫做**立方体贴图**，它与六图像格式基本相同，但我们将继续使用六图像格式，因为它是最简单且易于使用和修改的。在我的情况下，我选择了*图12.12*中显示的天空盒包。下载并导入它，就像我们在*第5章，C#和视觉脚本简介*中做的那样：
- en: '![](img/B18585_12_12.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_12.png)'
- en: 'Figure 12.12: Selected skybox set for this book'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：为此书选择的选定的天空盒
- en: Create a new material by using the **+** icon in the **Project** window and
    selecting **Material**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**项目**窗口中使用**+**图标并选择**材质**来创建一个新的材质。
- en: Set the **Shader** option of that material to **Skybox/6 sided**. Remember that
    the skybox is just a cube, so we can apply a material to change how it looks.
    The skybox shader is prepared to apply the six textures.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该材质的**着色器**选项设置为**天空盒/6面**。记住，天空盒只是一个立方体，因此我们可以应用材质来改变其外观。天空盒着色器已准备好应用六个纹理。
- en: 'Drag the six textures to the **Front**, **Back**, **Left**, **Right**, **Up**,
    and **Down** properties of the material. The six downloaded textures will have
    descriptive names so that you know which textures go where:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将六个纹理拖动到材质的**前**、**后**、**左**、**右**、**上**和**下**属性。六个下载的纹理将具有描述性的名称，以便您知道哪些纹理放在哪里：
- en: '![](img/B18585_12_13.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_13.png)'
- en: 'Figure 12.13: Skybox material settings'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：天空盒材质设置
- en: Drag the material directly into the sky in the Scene view. Be sure you don’t
    drag the material into an object because the material will be applied to it.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质直接拖动到场景视图中的天空。确保您不要将材质拖动到对象上，因为材质将被应用到它上面。
- en: 'Repeat *steps 1* to *4* of the ambient light calculation steps (**Lighting
    Settings** | **Generate Lighting**) to recalculate it based on the new skybox.
    In the following image, you can see the result of my project so far:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复环境光计算步骤的1到4步（**光照设置** | **生成光照**）以根据新的天空盒重新计算它。在以下图像中，您可以看到我到目前为止的项目结果：
- en: '![](img/B18585_12_14.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_14.png)'
- en: 'Figure 12.14: Applied skybox'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：应用的天空盒
- en: Now that we have a good base layer of lighting, we can start adding light objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了良好的基础光照层，我们可以开始添加灯光对象。
- en: Configuring lighting in URP
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在URP中配置光照
- en: 'We have three main types of Direct Lights we can add to our scene:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在场景中添加三种主要的直接灯光类型：
- en: '**Directional Light**: This is a light that represents the sun. This object
    emits light rays in the direction it is facing, regardless of its position; the
    sun moving 100 meters to the right won’t make a big difference. As an example,
    if you slowly rotate this object, you can generate a day/night cycle:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向性灯光**：这是一种代表太阳的灯光。该对象以它面对的方向发射光线，而不管它的位置如何；太阳向右移动100米不会产生太大影响。例如，如果您慢慢旋转这个对象，您可以生成昼夜循环：'
- en: '![](img/B18585_12_15.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_15.png)'
- en: 'Figure 12.15: Directional Light results'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：方向性灯光结果
- en: '**Point Light**: This light represents a light bulb, which emits rays in an
    omnidirectional way. The difference it has compared to Directional Lights is that
    its position matters because it’s closer to our objects. Also, because it’s a
    weaker light, the intensity of this light varies according to the distance, so
    its effect has a range—the further the object from the light, the weaker the received
    intensity:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：这种灯光代表一个灯泡，以全向方式发射光线。与方向性灯光相比，它的位置很重要，因为它更接近我们的物体。此外，由于它是一种较弱的灯光，其强度会根据距离变化，因此其效果有一个范围——物体离灯光越远，接收到的强度越弱：'
- en: '![](img/B18585_12_16.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_16.png)'
- en: 'Figure 12.16: Point Light results'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：点光源结果
- en: '**Spotlight**: This kind of light represents a light cone, such as the one
    emitted by a flashlight. It behaves similarly to point lights in that its position
    matters and the light intensity decays over a certain distance. But here the direction
    it points to (hence its rotation) is also important, given it will specify where
    to project the light:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**：这种灯光代表一个光锥，例如手电筒发出的光。它在位置很重要且光强度随距离衰减方面与点光源类似。但在这里，它指向的方向（因此其旋转）也很重要，因为它将指定光线投射的位置：'
- en: '![](img/B18585_12_17.png)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_17.png)'
- en: 'Figure 12.17: Spotlight results'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.17：聚光灯结果
- en: 'So far, we have nice, rainy, ambient lighting, but the only Direct Light we
    have in the scene, the Directional Light, won’t look like this, so let’s change
    that:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了很好的雨天环境光照，但场景中唯一的直接灯光——方向性灯光，看起来不会是这样，所以让我们改变一下：
- en: Select the **Directional Light** object in the **Hierarchy** window and then
    look at the **Inspector** window.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中选择**方向性灯光**对象，然后查看**检查器**窗口。
- en: Click the **Color** property in the **Emission** section to open the Color Picker.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发射**部分的**颜色**属性以打开颜色选择器。
- en: Select a dark gray color to achieve sun rays partially occluded by clouds.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择深灰色以实现部分被云层遮挡的太阳光线。
- en: 'Set **Shadow Type** to **No Shadows**. Now that we have a cloudy day, the sun
    does not project clear shadows, but we will talk more about shadows in a moment:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**阴影类型**设置为**无阴影**。现在我们有了多云的一天，太阳不会投射出清晰的阴影，但我们稍后会更多地讨论阴影：
- en: '![](img/B18585_12_18.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_18.png)'
- en: 'Figure 12.18: Soft directional light with no shadows'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：无阴影的柔和方向光
- en: 'Now that the scene is darker, we can add some lights to light up the scene,
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景变暗了，我们可以添加一些灯光来照亮场景，如下所示：
- en: Create a Spotlight by going to **GameObject | Light | Spotlight**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**GameObject | Light | Spotlight**创建一个聚光灯。
- en: Select it. Then, in the Inspector window, set **Inner/Output Spot Angle** of
    the **Shape** section to 90 and 120, which will increase the angle of the cone.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它。然后，在检查器窗口中，将**形状**部分的**内/输出聚光灯角度**设置为90和120，这将增加锥体的角度。
- en: Set **Range** in the **Emission** section to `50`, meaning that the light can
    reach up to 50 meters, decaying along the way.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发射**部分将**范围**设置为`50`，这意味着灯光可以延伸到50米，并在途中衰减。
- en: 'Set **Intensity** in the **Emission** section to `1000`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发射**部分将**强度**设置为`1000`：
- en: '![](img/B18585_12_19.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_19.png)'
- en: 'Figure 12.19: Spotlight settings'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：聚光灯设置
- en: 'Position the light at one corner of your game’s base, pointing it at the center:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将灯光放置在游戏基地的一个角落，指向中心：
- en: '![](img/B18585_12_20.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_20.png)'
- en: 'Figure 12.20: Spotlight placement'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：聚光灯位置
- en: Duplicate that light by selecting it and pressing *Ctrl+D* (*Command+D* on a
    Mac).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择它并按*Ctrl+D*（在Mac上为*Command+D*）来复制该灯光。
- en: 'Put it in the opposite corner of the base:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在底座的对面角落：
- en: '![](img/B18585_12_21.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_21.png)'
- en: 'Figure 12.21: Two Spotlight results'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：两个聚光灯结果
- en: You can keep adding lights to the scene but take care that you don’t go too
    far—remember the light’s limits. Also, you can download some light posts to put
    in where the lights are located to visually justify the origin of the light. Now
    that we have achieved proper lighting, we can talk about shadows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续向场景中添加灯光，但要注意不要走得太远——记住灯光的限制。此外，你可以在灯光所在的位置下载一些灯光柱来从视觉上证明灯光的来源。现在我们已经实现了适当的照明，我们可以谈谈阴影了。
- en: Applying shadows
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用阴影
- en: 'Maybe you are thinking that we already have shadows in the scene, but actually,
    we don’t. The darker areas of the object, the ones that are not facing the lights,
    don’t have shadows—they are not being lit, and that’s quite different from a shadow.
    In this case, we are referring to the shadows that are projected from one object
    to another—for example, the shadow of the player being projected on the floor,
    or from the mountains to other objects. Shadows can increase the quality of our
    scene, but they also cost a lot to calculate, so we have two options: not using
    shadows (recommended for low-end devices such as mobiles) or finding a balance
    between performance and quality according to our game and the target device.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为场景中已经有了阴影，但实际上并没有。物体的较暗区域，即不面向灯光的区域，没有阴影——它们没有被照亮，这与阴影有很大的不同。在这种情况下，我们指的是从一个物体投射到另一个物体的阴影——例如，玩家投射到地板上的阴影，或者从山脉投射到其他物体上。阴影可以增加场景的质量，但它们在计算上也很昂贵，因此我们有两种选择：不使用阴影（推荐用于低端设备，如手机）或根据我们的游戏和目标设备在性能和质量之间找到平衡。
- en: 'In this section, we are going to discuss the following topics about shadows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下关于阴影的主题：
- en: Understanding shadow calculations
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解阴影计算
- en: Configuring performant shadows
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: Let’s start by discussing how Unity calculates shadows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论Unity如何计算阴影。
- en: Understanding shadow calculations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解阴影计算
- en: In game development, it is well-known that shadows are costly in terms of performance,
    but why? An object has a shadow when a light ray hits another object before reaching
    it. In that case, no lighting is applied to that pixel from that light. The problem
    here is the same problem we have with the light that ambient lighting simulates—it
    would be too costly to calculate all possible rays and its collisions. So, again,
    we need an approximation, and here is where Shadow Maps kick in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，众所周知，阴影在性能方面是昂贵的，但为什么呢？当一个光束在到达目标物体之前击中另一个物体时，就会产生一个阴影。在这种情况下，该像素点不会从该光源获得任何光照。这里的问题与我们在环境光照模拟中所遇到的问题相同——计算所有可能的光束及其碰撞将过于昂贵。因此，我们再次需要近似，这就是阴影贴图发挥作用的地方。
- en: A **Shadow Map** is an image that’s rendered from the point of view of the light,
    but instead of drawing the full scene with all the color and lighting calculations,
    it will render all the objects in grayscale, where black means that the pixel
    is very far from the camera and whiter means that the pixel is nearer to the camera.
    If you think about it, each pixel contains information about where a **ray** of
    light hits. By knowing the position and orientation of the light, you can calculate
    the position where each “ray” hit using the Shadow Map.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**阴影图**是从光源视角渲染的图像，但它不会绘制带有所有颜色和光照计算的完整场景，而是将所有对象以灰度形式渲染，其中黑色表示像素非常远离相机，而更白则表示像素更靠近相机。如果你这么想，每个像素都包含了关于光线**射线**击中位置的信息。通过知道光源的位置和方向，你可以使用阴影图计算出每个“射线”击中的位置。'
- en: 'In the following image, you can see the shadow map of our Directional Light:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，你可以看到我们方向光的阴影图：
- en: '![](img/B18585_12_22.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_22.png)'
- en: 'Figure 12.22: Shadow Map generated by the Directional Light of our scene'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：由场景中的方向光生成的阴影图
- en: Each type of light calculates shadow maps slightly differently, especially the
    Point Light. Since it’s omnidirectional, it needs to render the scene several
    times in all its directions (Front, Back, Left, Right, Up, and Down) in order
    to gather information about all the rays it emits. We won’t talk about this in
    detail here, though, as we could talk about it all day.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的光照类型计算阴影图的方式略有不同，尤其是点光源。由于它是全方向的，它需要从所有方向（前、后、左、右、上、下）渲染场景多次，以便收集所有射出的光线信息。不过，我们在这里不会详细讨论这个问题，因为我们可以整天都在讨论它。
- en: 'Now, something important to highlight here is that shadow maps are textures,
    and as such, they have a resolution. The higher the resolution, the more “rays”
    our shadow map calculates. You are probably wondering what a low-resolution shadow
    map looks like when it has only a few rays in it. Take a look at the following
    image to see one:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里需要强调的一个重要问题是，阴影图是纹理，因此它们具有分辨率。分辨率越高，我们的阴影图计算的“射线”就越多。你可能想知道低分辨率阴影图在只有少数射线时看起来是什么样子。请看以下图像以查看一个例子：
- en: '![](img/B18585_12_23.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_23.png)'
- en: 'Figure 12.23: Hard Shadows rendered with a low-resolution Shadow Map'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：使用低分辨率阴影图渲染的硬阴影
- en: 'The problem here is that having fewer rays generates bigger shadow pixels,
    resulting in a pixelated shadow. Here, we have our first configuration to consider:
    what is the ideal resolution for our shadows? You will be tempted to just increase
    it until the shadows look smooth, but of course, that will increase how long it
    will take to calculate it, so it will impact the performance considerably unless
    your target platform can handle it (mobiles definitely can’t). Here, we can use
    the **Soft Shadows** trick, where we can apply a blurring effect over the shadows
    to hide the pixelated edges, as shown in the following image:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，射线越少，阴影像素就越大，导致阴影出现像素化。在这里，我们首先需要考虑的配置是：阴影的理想分辨率是多少？你可能会想直接增加分辨率，直到阴影看起来平滑，但当然，这会增加计算所需的时间，因此会显著影响性能，除非你的目标平台能够处理它（移动设备肯定不能）。在这里，我们可以使用**软阴影**技巧，即在阴影上应用模糊效果以隐藏像素化的边缘，如图下所示：
- en: '![](img/B18585_12_24.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_24.png)'
- en: 'Figure 12.24: Soft Shadows rendered with a low-resolution Shadow Map'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：使用低分辨率阴影图渲染的软阴影
- en: Of course, the blurry effect is not free, but combining it with low-resolution
    shadow maps, if you accept its blurry result, can generate a nice balance between
    quality and performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模糊效果不是免费的，但如果你接受其模糊的结果，将其与低分辨率阴影图结合，可以在质量和性能之间产生良好的平衡。
- en: 'Now, low-resolution shadow maps have another problem, which is called **Shadow
    Acne**. This is the lighting error you can see in the following image:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，低分辨率阴影图还有一个问题，称为**阴影痤疮**。这是你在以下图像中可以看到的光照错误：
- en: '![](img/B18585_12_25.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_25.png)'
- en: 'Figure 12.25: Shadow Acne from a low-resolution Shadow Map'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：由低分辨率阴影图产生的阴影痤疮
- en: 'A low-resolution shadow map generates false positives because it has fewer
    “rays” calculated. The pixels to be shaded between the rays need to interpolate
    information from the nearest ones. The lower the Shadow Map’s resolution, the
    larger the gap between the rays, which means less precision and more false positives.
    One solution would be to increase the resolution, but again, there will be performance
    issues (as always). We have some clever solutions to this, such as using **depth
    bias**. An example of this can be seen in the following image:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 低分辨率的阴影图产生误报，因为它计算的“射线”较少。需要在射线之间着色的像素需要从最近的像素中插值信息。阴影图的分辨率越低，射线之间的间隙就越大，这意味着精度更低，误报更多。一个解决方案是提高分辨率，但同样，也会有性能问题（就像总是那样）。我们有一些巧妙的解决方案，比如使用**深度偏差**。以下图像就是一个例子：
- en: '![](img/B18585_12_26.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图](img/B18585_12_26.png)'
- en: 'Figure 12.26: A false positive between two far “rays.” The highlighted area
    thinks the ray hit an object before reaching it.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：两个远“射线”之间的误报。高亮区域认为射线在到达之前已经击中了物体。
- en: 'The concept of **depth bias** is simple—so simple that it seems like a big
    cheat, and actually, it is, but game development is full of them! To prevent false
    positives, we “push” the rays a little bit further, just enough to make the interpolated
    rays reach the surface being lit:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度偏差**的概念很简单——简单到似乎是一种很大的作弊，实际上也是，但游戏开发充满了这样的东西！为了防止误报，我们“推动”射线稍微远一点，刚好足够使插值射线达到被照亮的表面：'
- en: '![](img/B18585_12_27.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图](img/B18585_12_27.png)'
- en: 'Figure 12.27: Rays with a depth bias to eliminate false positives'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27：具有深度偏差的射线以消除误报
- en: 'Of course, as you are probably expecting, they don’t solve this problem easily
    without having a caveat. Pushing depth generates false negatives in other areas,
    as shown in the following image. It looks like the cube is floating, but actually,
    it is touching the ground—the false negatives generate the illusion that it is
    floating:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如你可能预料的那样，他们没有轻易解决这个问题，而是有一个警告。推动深度会在其他区域产生误报，如下面的图像所示。看起来立方体在空中漂浮，但实际上，它是在接触地面——误报产生了它漂浮的错觉：
- en: '![](img/B18585_12_28.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图](img/B18585_12_28.png)'
- en: 'Figure 12.28: False negatives due to a high depth bias'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28：由于高深度偏差产生的误报
- en: 'Of course, we have a counter trick to this situation known as **normal bias**.
    This pushes the object’s mesh along the direction they are facing, not the rays.
    This one is a little bit tricky, so we won’t go into too much detail here, but
    the idea is that combining a little bit of depth bias and another bit of normal
    bias will reduce the false positives, but not completely eliminate them. Therefore,
    we need to learn how to live with that and hide these shadow discrepancies by
    cleverly positioning objects:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一种对抗这种情况的技巧，称为**法线偏差**。它将物体的网格沿着它们面对的方向推动，而不是射线。这个有点棘手，所以我们不会在这里详细介绍，但想法是结合一点深度偏差和一点法线偏差可以减少误报，但不会完全消除它们。因此，我们需要学会如何与之共存，并通过巧妙地定位物体来隐藏这些阴影差异：
- en: '![](img/B18585_12_29.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图](img/B18585_12_29.png)'
- en: 'Figure 12.29: Reduced false positives, which is the result of combining depth
    and normal bias'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29：减少了误报，这是结合深度和法线偏差的结果
- en: There are several other aspects that affect how shadow maps work, with one of
    them being the light range. The smaller the light range, the less area the shadows
    will cover. The same shadow map resolution can add more detail to that area, so
    try to reduce the light ranges as much as you can, as we will do in the next section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 影响阴影图工作方式的其他几个方面中，有一个是光程。光程越小，阴影覆盖的区域就越小。相同的阴影图分辨率可以增加该区域的更多细节，所以尽量减少光程，就像我们将在下一节中做的那样。
- en: I can imagine your face right now, and yes, lighting is complicated, and we’ve
    only just scratched the surface! But keep your spirits up! After a little trial
    and error fiddling with the settings, you will understand it better. We’ll do
    that in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在能想象你的表情，是的，光照很复杂，我们只是刚刚触及表面！但保持你的士气！经过一点试验和错误的设置调整后，你会更好地理解它。我们将在下一节中这样做。
- en: If you are really interested in learning more about the internals of the shadow
    system, I recommend that you look at the concept of **Shadow Cascades**, an advanced
    topic about Directional Lights and shadow map generation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的对了解阴影系统的内部结构感兴趣，我建议你看看**阴影级联**的概念，这是一个关于方向光和阴影图生成的先进主题。
- en: Configuring performant shadows
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: 'Because we are targeting mid-end devices, we will try to achieve a good balance
    of quality and performance here, so let’s start enabling shadows just for the
    spotlights. The Directional Light shadow won’t be that noticeable, and actually,
    a rainy sky doesn’t generate clear shadows, so we will use that as an excuse to
    not calculate those shadows. In order to do this, do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们针对的是中端设备，我们将尝试在质量和性能之间取得良好的平衡，所以让我们开始只为聚光灯启用阴影。方向光的阴影不会那么明显，实际上，雨天不会生成清晰的阴影，所以我们将以此为借口不计算这些阴影。为了做到这一点，请执行以下操作：
- en: 'Select both spotlights by clicking them in the Hierarchy while pressing *Ctrl*
    (*Command* on Mac). This will ensure that any changes made in the Inspector window
    will be applied to both:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中按住*Ctrl*（Mac上的*Command*）的同时点击两个聚光灯。这将确保在检查器窗口中进行的任何更改都将应用于两者：
- en: '![](img/B18585_12_30.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_30.png)'
- en: 'Figure 12.30: Selecting multiple objects'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30：选择多个对象
- en: 'In the Inspector window, set **Shadow Type** in the **Shadows** section to
    **Soft Shadows**. We will be using low-resolution shadow maps here and the soft
    mode can help to hide the pixelated resolution:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中，在**阴影**部分将**阴影类型**设置为**软阴影**。在这里我们将使用低分辨率阴影贴图，软模式可以帮助隐藏像素化的分辨率：
- en: '![](img/B18585_12_31.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_31.png)'
- en: 'Figure 12.31: Soft Shadows setting'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31：软阴影设置
- en: 'Select **Directional light** and set **Shadow Type** to **No Shadows** to prevent
    it from casting shadows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**方向光**，并将**阴影类型**设置为**无阴影**以防止其投射阴影：
- en: '![](img/B18585_12_32.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_32.png)'
- en: 'Figure 12.32: No Shadows setting'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32：无阴影设置
- en: Create a cube (**GameObject** | **3D Object** | **Cube**) and place it near
    one of the lights, just to have an object that we can cast shadows on for testing
    purposes.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体（**GameObject** | **3D Object** | **Cube**），并将其放置在灯光附近，以便在测试时有一个可以投射阴影的对象。
- en: 'Now that we have a base test scenario, let’s fiddle with the shadow maps resolution
    settings, preventing shadow acne in the process:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基本的测试场景，让我们调整阴影贴图的分辨率设置，以防止阴影噪点：
- en: Go to **Edit** | **Project Settings**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑** | **项目设置**。
- en: 'In the left-hand side list, look for **Graphics** and click it:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中，查找**图形**并点击它：
- en: '![](img/B18585_12_33.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_33.png)'
- en: 'Figure 12.33: Graphics settings'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33：图形设置
- en: 'In the properties that appear after selecting this option, click in the box
    below **Scriptable Render Pipeline Settings**—the one that contains a name. In
    my case, this is **URP-HighFidelity**, but yours may be different if you have
    a different version of Unity:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择此选项后出现的属性中，点击**可脚本渲染管线设置**下面的框——包含一个名称的那个。在我的情况下，这是**URP-HighFidelity**，但如果你有不同版本的Unity，它可能不同：
- en: '![](img/B18585_12_34.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_34.png)'
- en: 'Figure 12.34: Current Render Pipeline setting'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34：当前渲染管线设置
- en: 'Doing that will highlight an asset in the Project window, so be sure that the
    window is visible before selecting it. Select the highlighted asset:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做将在项目窗口中突出显示一个资产，所以在选择它之前请确保窗口是可见的。选择突出显示的资产：
- en: '![](img/B18585_12_35.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_35.png)'
- en: 'Figure 12.35: Current pipeline highlighted'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35：当前管线高亮显示
- en: 'This asset has several graphics settings related to how URP will handle its
    rendering, including lighting and shadows. Expand the **Lighting** section to
    reveal its settings:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此资产有几个与URP如何处理其渲染相关的图形设置，包括照明和阴影。展开**照明**部分以显示其设置：
- en: '![](img/B18585_12_36.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_36.png)'
- en: 'Figure 12.36: Pipeline lighting settings'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36：管线照明设置
- en: The **Shadow Resolution** setting under the **Additional Lights** subsection
    represents the shadow map resolution for all the lights that aren’t the Directional
    Light (since it’s the Main Light). Set it to `1024` if it’s not already at that
    value.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加灯光**子部分下的**阴影分辨率**设置表示所有非方向光的阴影贴图分辨率（因为它是主光）。如果它还没有设置为`1024`，请将其设置为`1024`。
- en: 'Under the **Shadows** section, you can see the **Depth** and **Normal Bias**
    settings, but those will affect all lights. Even if right now our Directional
    Light doesn’t have shadows, we want only to affect Additional Lights bias values
    as they have a different Atlas Resolution compared to the Main one (Directional
    Light), so instead, select out spotlights and set **Bias** to **Custom** and **Depth**
    and **Normal Bias** to `0.25` in order to reduce them as much as we can before
    we remove the shadow acne:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**阴影**部分下，你可以看到**深度**和**法线偏差**设置，但那些将影响所有灯光。即使现在我们的方向光没有阴影，我们只想影响额外的灯光偏差值，因为它们的图集分辨率与主图（方向光）不同，所以，选择聚光灯并将**偏差**设置为**自定义**，将**深度**和**法线偏差**设置为`0.25`，以便在我们移除阴影痤疮之前尽可能减少它们：
- en: '![](img/B18585_12_37.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_12_37.png)'
- en: 'Figure 12.37: Bias settings'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37：偏差设置
- en: This isn’t entirely related to shadows, but in the Univeral RP settings asset,
    you can change the **Per Object Light** limit to increase or reduce the number
    of lights that can affect the object (no more than eight). For now, the default
    is good as is.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这并不完全与阴影相关，但在通用RP设置资产中，你可以更改**每个对象的灯光**限制来增加或减少可以影响对象的光的数量（不超过八个）。目前，默认设置就很好。
- en: In case you followed the shadow cascades tip presented earlier, you can play
    with the **Cascades** value a little bit to enable shadows for Directional Light
    to note the effect. Remember that those shadow settings only work for Directional
    Light.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前遵循了前面提到的阴影级联提示，你可以稍微调整一下**级联**值，以启用方向光阴影并观察效果。记住，那些阴影设置仅适用于方向光。
- en: We don’t have shadows in **Directional Light**, but in any other case, consider
    reducing the **Max Distance** value in the **Shadows** section, which will affect
    the Directional Light shadows range.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方向光中没有阴影，但在任何其他情况下，考虑在**阴影**部分中减少**最大距离**值，这将影响方向光阴影的范围。
- en: Select both lights in the Hierarchy and set them so that they have a 40-meter
    **Range**. See how the shadows improve in quality before and after this change.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择两个灯光，并将它们的**范围**设置为40米。看看在这次更改前后阴影的质量如何改善。
- en: Remember that those values only work in my case, so try to fiddle with the values
    a little bit to see how that changes the result—you may find a better setup for
    your scene if it was designed differently from mine. Also, remember that not having
    shadows is always an option, so consider that if your game is running low on frames
    per second, also known as FPS (and there isn’t another performance problem lurking).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，那些值只适用于我的情况，所以试着调整一下值，看看它如何改变结果——你可能会为你的场景找到一个更好的设置，如果它与我的设计不同的话。此外，记住没有阴影始终是一个选项，所以如果你的游戏每秒帧数较低，也就是FPS（且没有其他性能问题），也请考虑这一点。
- en: You probably think that that is all we can do about performance in terms of
    lighting, but luckily, that’s not the case! We have another resource we can use
    to improve it further known as static lighting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这就是我们在光照方面能做的所有关于性能的事情了，但幸运的是，情况并非如此！我们还有另一个资源可以利用来进一步改进它，这就是静态光照。
- en: Optimizing lighting
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化光照
- en: We mentioned previously that not calculating lighting is good for performance,
    but what about not calculating lights, but still having them? Yes, it sounds too
    good to be true, but it is actually possible (and, of course, tricky). We can
    use a technique called static lighting or baking, which allows us to calculate
    lighting once and use the cached result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到不计算光照对性能有好处，但如果不计算灯光，却仍然有灯光呢？是的，听起来好得令人难以置信，但实际上是可能的（当然，也很棘手）。我们可以使用一种称为静态光照或烘焙的技术，它允许我们一次性计算光照并使用缓存的成果。
- en: 'In this section, we will cover the following concepts related to static lighting:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与静态光照相关的以下概念：
- en: Understanding static lighting
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态光照
- en: Baking lightmaps
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烘焙光照贴图
- en: Applying static lighting to dynamic objects
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将静态光照应用于动态对象
- en: Understanding static lighting
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解静态光照
- en: 'The idea is pretty simple: just do the lighting calculations once, save the
    results, and then use those instead of calculating lighting all the time.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：只需进行一次光照计算，保存结果，然后使用这些结果而不是一直计算光照。
- en: You may be wondering why this isn’t the default technique to use. This is because
    it has some limitations, with the big one being dynamic objects. **Precalculating
    shadows** means that they can’t change once they’ve been calculated, but if an
    object that is casting a shadow is moved, the shadow will still be there, so the
    main thing to take into account here is that you can’t use this technique with
    moving objects. Instead, you will need to mix **static** or **baked lighting**
    for static objects and **real-time lighting** for dynamic (moving) objects. Also,
    consider that aside from this technique being only valid for static objects, it
    is also only valid for static lights. Again, if a light moves, the precalculated
    data becomes invalid.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么这不是默认的技术。这是因为它有一些限制，其中最大的限制是动态对象。**预先计算阴影**意味着一旦计算完成，它们就无法改变，但如果一个投射阴影的对象被移动，阴影仍然会存在，所以这里需要考虑的主要问题是你不能使用这种技术来处理移动对象。相反，你需要为静态对象混合**静态**或**烘焙光照**，为动态（移动）对象使用**实时光照**。此外，考虑到这种技术仅适用于静态对象，它也仅适用于静态光源。再次强调，如果光源移动，预先计算的数据就变得无效了。
- en: 'Another limitation you need to take into account is that precalculated data
    can have a huge impact on memory. That data occupies space in RAM, maybe hundreds
    of MB, so you need to consider if your target platform has enough space. Of course,
    you can reduce the precalculated lighting quality to reduce the size of that data,
    but you need to consider if the loss of quality deteriorates the look and feel
    of your game too much. As with all options regarding optimization, you need to
    balance two factors: performance and quality.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你需要考虑的限制是预先计算的数据可能会对内存产生巨大影响。这些数据占据了RAM中的空间，可能达到数百MB，因此你需要考虑你的目标平台是否有足够的空间。当然，你可以降低预先计算的照明质量以减小该数据的大小，但你需要考虑这种质量损失是否过多地影响了你游戏的外观和感觉。与所有关于优化的选项一样，你需要平衡两个因素：性能和质量。
- en: We have several kinds of precalculated data in our process, but the most important
    one is what we call **lightmaps**. A lightmap is a texture that contains all the
    shadows and lighting for all the objects in the scene, so when Unity applies the
    precalculated or baked data, it will look at this texture to know which parts
    of the static objects are lit and which aren’t.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的流程中，我们有几种预先计算的数据，但最重要的一个是被称为**光照贴图**的数据。光照贴图是一种包含场景中所有对象的所有阴影和光照的纹理，因此当Unity应用预先计算或烘焙的数据时，它会查看这个纹理以确定静态对象的哪些部分被照亮，哪些没有被照亮。
- en: 'You can see an example of a lightmap in the following image:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图像中看到一个光照贴图的例子：
- en: '![Image result for lightmap unity](img/B18585_12_38.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for lightmap unity](img/B18585_12_38.png)'
- en: 'Figure 12.38: Left, a scene with no lighting; middle, a lightmap holding precalculated
    data from that scene; and right, the lightmap being applied to the scene'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38：左，没有光照的场景；中，包含该场景预先计算数据的光照贴图；右，光照贴图应用于场景
- en: Having lightmaps has its own benefits. The baking process is executed in Unity,
    before the game is shipped to users, so you can spend plenty of time calculating
    stuff that you can’t do in runtime, such as improved accuracy, light bounces,
    light occlusion in corners, and light from emissive objects. However, that can
    also be a problem. Remember, dynamic objects still need to rely on real-time lighting,
    and that lighting will look very different compared to static lighting, so we
    need to tweak them a lot for the user to not notice the difference.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有光照贴图有其自身的优势。烘焙过程在Unity中进行，在游戏发布给用户之前，这样你可以花费大量时间计算在运行时无法完成的事情，比如提高精度、光线反弹、角落的光线遮挡以及发射物体的光线。然而，这也可能成为一个问题。记住，动态对象仍然需要依赖于实时光照，而且与静态光照相比，这种光照看起来会非常不同，因此我们需要对其进行大量调整，以便用户不会注意到差异。
- en: Now that we have a basic notion of what static lighting is, let’s dive into
    how to use it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对静态光照有了基本的概念，让我们深入了解如何使用它。
- en: Baking lightmaps
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙光照贴图
- en: To use lightmaps, we need to make some preparations regarding the 3D models.
    Remember that meshes have **UVs**, which contain information about which part
    of the texture needs to be applied to each part of the model. Sometimes, to save
    texture memory you can apply the same piece of texture to different parts. For
    example, in a car’s texture, you wouldn’t have four wheels; you’d just have one,
    and you can apply that same piece of texture to all the wheels. The problem here
    is that static lighting uses textures the same way, but here, it will apply the
    lightmaps to light the object. In the wheel scenario, the problem would be that
    if one wheel receives shadows, all of them will have it, because all the wheels
    are sharing the same texture space. The usual solution is to have a second set
    of UVs in the model with no texture space being shared, just for use with lightmapping.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用光照贴图，我们需要对 3D 模型做一些准备工作。记住，网格有**UV**，它包含有关纹理的哪些部分需要应用到模型各部分的信息。有时，为了节省纹理内存，您可以将同一块纹理应用到不同的部分。例如，在汽车的纹理中，您不会看到四个轮子；只有一个轮子，您可以将相同的纹理块应用到所有轮子上。这里的问题是，静态光照以相同的方式使用纹理，但在这里，它将应用光照贴图来照亮对象。在轮子的情况下，问题会是一个轮子接收到阴影，所有轮子都会有，因为所有轮子都在共享相同的纹理空间。通常的解决方案是在模型中有一组没有共享纹理空间的
    UV，专门用于光照贴图。
- en: 'Sometimes, downloaded models are already prepared for lightmapping, and sometimes,
    they aren’t, but luckily, Unity has us covered in those scenarios. To be sure
    a model will calculate lightmapping properly, let’s make Unity automatically generate
    the **Lightmapping UVs** by doing the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，下载的模型已经为光照贴图做好了准备，有时则没有，但幸运的是，Unity 在这些情况下为我们提供了支持。为了确保模型能够正确计算光照贴图，让我们通过以下步骤让
    Unity 自动生成**光照贴图 UV**：
- en: Select the mesh asset (FBX) in the **Project** window.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择网格资产（FBX）。
- en: In the **Model** tab, look for the **Generate Lightmap UVs** checkbox at the
    bottom and check it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**模型**选项卡中，找到底部的**生成光照贴图 UV**复选框并勾选它。
- en: 'Click the **Apply** button at the bottom:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底部点击**应用**按钮：
- en: '![](img/B18585_12_39.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_39.png)'
- en: 'Figure 12.39: Generate Lightmap setting'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.39：生成光照贴图设置
- en: Repeat this process for every model. Technically, you can only do this in the
    models where you get artifacts and weird results after baking lightmaps, but for
    now, let’s do this in all the models just in case.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个模型重复此过程。技术上，您只能在烘焙光照贴图后出现伪影和奇怪结果的模型中这样做，但为了以防万一，我们现在就在所有模型中这样做。
- en: 'After preparing the models for being lightmapped, the next step is to tell
    Unity which objects are not going to move. To do so, do the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在为光照贴图准备模型之后，下一步是告诉 Unity 哪些对象不会移动。为此，请执行以下操作：
- en: Select the object that won’t move.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不会移动的对象。
- en: 'Check the **Static** checkbox in the top-right of the Inspector window:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口的右上角勾选**静态**复选框：
- en: '![](img/B18585_12_40.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_40.png)'
- en: 'Figure 12.40: Static checkbox'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.40：静态复选框
- en: Repeat this for every static object (this isn’t necessary for lights; we will
    deal with those later).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对每个静态对象重复此操作（对于灯光来说这不是必要的；我们稍后会处理这些）。 '
- en: You can also select a container of several objects, check the **Static** checkbox,
    and click the **Yes, All Children** button in the prompt to apply the checkbox
    to all child objects.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以选择多个对象的容器，勾选**静态**复选框，并在提示中点击**是，所有子对象**按钮，将复选框应用到所有子对象。
- en: 'Consider that you may not want every object, even if it’s static, to be lightmapped,
    because the more objects you lightmap, the more texture size you will require.
    As an example, the terrain could be too large and would consume most of the lightmapping’s
    size. Usually, this is necessary, but in our case, the spotlights are barely touching
    the terrain. Here, we have two options: leave the terrain as dynamic, or better,
    directly tell the spotlights to not affect the terrain since one is only lit by
    ambient lighting and the Directional Light (which is not casting shadows). Remember
    that this is something we can do because of our type of scene; however, you may
    need to use other settings in other scenarios. You can exclude an object from
    both real-time and static lighting calculations by doing the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你可能不希望每个对象，即使它是静态的，都进行光照贴图，因为光照贴图的对象越多，你需要的纹理大小就越大。例如，地形可能太大，会消耗大部分光照贴图的大小。通常，这是必要的，但在这个案例中，聚光灯几乎不接触地形。在这里，我们有两个选择：将地形保留为动态，或者更好的是，直接告诉聚光灯不要影响地形，因为其中一个只受到环境光照和方向光（不会产生阴影）的照射。记住，我们之所以能这样做，是因为我们的场景类型；然而，在其他场景中，你可能需要使用其他设置。你可以通过以下方式从实时和静态光照计算中排除一个对象：
- en: Select the object to exclude.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要排除的对象。
- en: 'In the Inspector window, click the **Layer** dropdown and click on **Add Layer…**:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中，点击**图层**下拉菜单，然后点击**添加图层…**：
- en: '![](img/B18585_12_41.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_41.png)'
- en: 'Figure 12.41: Layer creation button'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.41：创建图层按钮
- en: 'Here, you can create a layer, which is a group of objects that are used to
    identify which objects are not going to be affected by lighting. In the **Layers**
    list, look for an empty space and type in any name for those kinds of objects.
    In my case, I will only exclude the terrain, so I have just named it **Terrain**:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以创建一个图层，这是一个用于识别哪些对象不会受到光照影响的对象组。在**图层**列表中，寻找一个空白区域，为这类对象输入任何名称。以我的情况为例，我只将地形排除在外，所以我将其命名为**地形**：
- en: '![](img/B18585_12_42.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_42.png)'
- en: 'Figure 12.42: Layers list'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.42：图层列表
- en: 'Once again, select the terrain, go to the **Layer** dropdown, and select the
    layer you created in the previous step. This way, you can specify that this object
    belongs to that group of objects:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择地形，转到**图层**下拉菜单，并选择上一步创建的图层。这样，你可以指定这个对象属于那个对象组：
- en: '![](img/B18585_12_43.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_43.png)'
- en: 'Figure 12.43: Changing a GameObject’s layer'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.43：更改GameObject的图层
- en: 'Select all the spotlights lights, look for the **Culling Mask** in the **Rendering**
    section in the Inspector window, click it, and uncheck the layer you created previously.
    This way, you can specify that those lights won’t affect that group of objects:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有聚光灯，在检查器窗口的**渲染**部分查找**剔除遮罩**，点击它，取消勾选之前创建的图层。这样，你可以指定这些灯光不会影响那个对象组：
- en: '![](img/B18585_12_44.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_44.png)'
- en: 'Figure 12.44: Light Culling Mask'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.44：光照剔除遮罩
- en: Now, you can see how those selected lights are not illuminating or applying
    shadows to the terrain.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以看到那些选定的灯光没有照亮或向地形应用阴影。
- en: 'Now, it’s time for the lights since the **Static** checkbox won’t work for
    them. For them, we have the following three modes:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理灯光了，因为**静态**复选框对它们不起作用。对于它们，我们有以下三种模式：
- en: '**Realtime**: A light in Realtime mode will affect all objects, both static
    and dynamic, using real-time lighting, meaning there’s no pre-calculation. This
    is useful for lights that are not static, such as the player’s flashlight, a lamp
    that is moving due to the wind, and so on.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时**：在实时模式下，灯光将影响所有对象，无论是静态的还是动态的，使用实时光照，这意味着没有预先计算。这对于不静止的灯光很有用，例如玩家的手电筒、因风而移动的灯等。'
- en: '**Baked**: The opposite of Realtime, this kind of light will only affect static
    objects with lightmaps. This means that if the player (dynamic) moves under a
    baked light on the street (static), the street will look lit, but the player will
    still be dark and won’t cast any shadows on the street. The idea is to use this
    on lights that won’t affect any dynamic object, or on lights that are barely noticeable
    on them, so that we can increase performance by not calculating them.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙**：与实时相反，这种灯光只会影响具有光照贴图的静态对象。这意味着如果玩家（动态）在街道上的烘焙灯光（静态）下移动，街道看起来会被照亮，但玩家仍然保持黑暗，不会在街道上产生任何阴影。这种想法是用于不会影响任何动态对象的灯光，或者用于几乎不影响它们的灯光，这样我们就可以通过不计算它们来提高性能。'
- en: '**Mixed**: This is the preferred mode in case you are not sure which one to
    use. This kind of light will calculate lightmaps for static objects, but will
    also affect dynamic objects, combining its Realtime lighting with the baked one
    (like Realtime lights also do).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：如果你不确定使用哪个模式，这是首选模式。这种光照将计算静态对象的光照贴图，但也会影响动态对象，结合其实时光照和烘焙光照（就像实时灯光一样）。'
- en: In our case, our Directional Light will only affect the terrain, and because
    we don’t have shadows, applying lighting to it is relatively cheap in URP, so
    we can leave the Directional Light in Realtime so that it won’t take up any lightmap
    texture area.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的方向光只会影响地形，而且由于我们没有阴影，在URP中应用光照相对便宜，因此我们可以将方向光保持在实时模式，这样就不会占用任何光照贴图纹理区域。
- en: 'Our spotlights are affecting the base, but actually, they are only applying
    lighting to them—we have no shadows because our base is empty. In this case, it
    is preferable to not calculate lightmapping whatsoever, but for learning purposes,
    I will add a few objects as obstacles to the base to cast some shadows and justify
    the use of lightmapping, as shown in the following image:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聚光灯正在影响基础，但实际上，它们只是在应用光照到它们上——我们没有阴影，因为我们的基础是空的。在这种情况下，最好根本不计算光照贴图，但为了学习目的，我将在基础周围添加一些障碍物以投射一些阴影，从而证明使用光照贴图的合理性，如下面的图片所示：
- en: '![](img/B18585_12_45.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_45.png)'
- en: 'Figure 12.45: Adding objects to project light'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.45：添加对象以投射光照
- en: 'Here, you can see how the original design of our level changes constantly during
    the development of the game, and that’s something you can’t avoid—bigger parts
    of the game will change over time. Now, we are ready to set up the Light Modes
    and execute the baking process, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们关卡的原设计在游戏开发过程中不断变化，这是你无法避免的——游戏的大部分内容会随着时间的推移而改变。现在，我们准备设置光照模式并执行烘焙过程，如下所示：
- en: Select the **Directional Light** in the **Hierarchy**.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**中选择**方向光**。
- en: Set the **Mode** property of the **General** section in the Inspector window
    to **Realtime** (if it’s not already in that mode).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将检查器窗口中**通用**部分的**模式**属性设置为**实时**（如果它还没有在这个模式下）。
- en: Select both Spotlights.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个聚光灯。
- en: 'Set their **Render Mode** to **Mixed**:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们的**渲染模式**设置为**混合**：
- en: '![](img/B18585_12_46.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_46.png)'
- en: 'Figure 12.46: Mixed lighting setting for Spotlights, the mode will be Realtime
    for the Directional Light'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.46：聚光灯的混合光照设置，方向光将处于实时模式
- en: Open the **Lighting Settings** window (**Window** | **Rendering** | **Lighting**).
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**光照设置**窗口（**窗口** | **渲染** | **光照**）。
- en: 'We want to change some of the settings of the baking process. In order to enable
    the controls for this, click the **New Lighting Settings** button. This will create
    an asset with lightmapping settings that can be applied to several scenes in case
    we want to share the same settings multiple times:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想更改烘焙过程的某些设置。为了启用这些控制，点击**新建光照设置**按钮。这将创建一个具有光照贴图设置的资产，可以在我们想要多次使用相同设置的情况下应用于多个场景：
- en: '![](img/B18585_12_47.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_47.png)'
- en: 'Figure 12.47: Creating lighting settings'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.47：创建光照设置
- en: 'Reduce the quality of lightmapping, just to make the process go faster. Just
    to iterate, the lighting can easily be reduced by using settings such as **Lightmap
    Resolution**, **Direct Samples**, **Indirect Samples**, and **Environment Samples**,
    all of them located under the **Lightmapping Settings** category. In my case,
    I have those settings applied, as shown in the following image. Note that even
    reducing those will take time; we have too many objects in the scene due to the
    modular level design:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 降低光照贴图的质量，只是为了使过程更快。只需迭代，就可以通过使用如**光照贴图分辨率**、**直接采样**、**间接采样**和**环境采样**等设置轻松降低光照，所有这些设置都位于**光照贴图设置**类别下。在我的情况下，我已经应用了这些设置，如下面的图片所示。请注意，即使降低这些设置也需要时间；由于模块化关卡设计，场景中物体太多：
- en: '![](img/B18585_12_48.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_48.png)'
- en: 'Figure 12.48: Scene lighting settings'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.48：场景光照设置
- en: Click **Generate Lighting**, which is the same button we used previously to
    generate ambient lighting.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成光照**，这是我们之前用来生成环境光照的同一个按钮。
- en: 'Wait for the process to complete. You can do this by checking the progress
    bar at the bottom-right of the Unity editor. Note that this process could take
    even hours in large scenes, so be patient:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待过程完成。你可以通过检查Unity编辑器右下角的进度条来完成此操作。请注意，这个过程在大场景中可能需要数小时，所以请耐心等待：
- en: '![](img/B18585_12_49.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_49.png)'
- en: 'Figure 12.49: Baking progress bar'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.49：烘焙进度条
- en: 'After the process has completed, you can check the bottom part of the **Lighting
    settings** window, where you can see how many lightmaps need to be generated.
    We have a maximum lightmap resolution, so we probably need several of them to
    cover the entire scene. Also, it informs us of their size so that we can consider
    their impact in terms of RAM. Finally, you can check out the **Baked Lightmaps**
    section to see them:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过程完成后，你可以检查**光照设置**窗口的底部部分，在那里你可以看到需要生成多少光照贴图。我们有最大光照贴图分辨率，所以我们可能需要几个来覆盖整个场景。此外，它还告诉我们它们的大小，以便我们可以考虑它们对内存的影响。最后，你可以查看**烘焙光照贴图**部分来查看它们：
- en: '![](img/B18585_12_50.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_50.png)'
- en: 'Figure 12.50: Generated lightmaps'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.50：生成的光照贴图
- en: 'Now, based on the results, you can move objects, modify light intensities,
    or make whatever correction you would need in order to make the scene look the
    way you want and recalculate the lighting every time you need to. In my case,
    those settings gave me good enough results, which you can see in the following
    image:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，基于结果，你可以移动对象，修改光照强度，或者进行任何必要的校正，以使场景看起来符合你的要求，并在每次需要时重新计算光照。在我的情况下，这些设置给了我足够好的结果，如图所示：
- en: '![](img/B18585_12_51.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_51.png)'
- en: 'Figure 12.51: Lightmap result'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.51：光照贴图结果
- en: 'We still have plenty of small settings to touch on, but I will leave you to
    discover those through trial and error or by reading the Unity documentation about
    lightmapping over at: [https://docs.unity3d.com/Manual/Lightmappers.html](https://docs.unity3d.com/Manual/Lightmappers.html).
    Reading the Unity manual is a good source of knowledge and I recommend that you
    start using it—any good developer, no matter how experienced, should read the
    manual.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有很多小的设置可以探讨，但我将留给你通过试错或阅读 Unity 关于光照贴图的文档来发现这些设置：[https://docs.unity3d.com/Manual/Lightmappers.html](https://docs.unity3d.com/Manual/Lightmappers.html)。阅读
    Unity 手册是获取知识的好来源，我建议你开始使用它——任何优秀的开发者，无论经验如何丰富，都应该阅读手册。
- en: Applying static lighting to static objects
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将静态光照应用于静态对象
- en: 'When marking objects as static in your scene, you probably figured out that
    all the objects in the scene won’t move, so you probably checked the static checkbox
    for everyone. That’s ok, but you should always put a dynamic object into the scene
    to really be sure that everything works ok—no games have totally static scenes.
    Try adding a capsule and moving it around to simulate our player, as shown in
    the following image. If you pay attention to it, you will notice something odd—the
    shadows being generated by the lightmapping process are not being applied to our
    dynamic object:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景中将对象标记为静态时，你可能已经想到场景中的所有对象都不会移动，所以你可能为每个人检查了静态复选框。这是可以的，但你应该始终在场景中放入一个动态对象，以确保一切正常工作——没有任何游戏有完全静态的场景。尝试添加一个胶囊并将其移动，如图所示，以模拟我们的玩家。如果你注意观察，你会注意到一些奇怪的地方——由光照贴图过程生成的阴影没有被应用到我们的动态对象上：
- en: '![](img/B18585_12_52.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_52.png)'
- en: 'Figure 12.52: Dynamic object under a lightmap’s precalculated shadow'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.52：光照贴图预计算阴影下的动态对象
- en: You may be thinking that Mixed Light Mode was supposed to affect both dynamic
    and static objects, and that is exactly what it’s doing. The problem here is that
    everything related to static objects is pre-calculated into those lightmap textures,
    including the shadows they cast, and because our capsule is dynamic, it wasn’t
    there when the pre-calculation process was executed. So, in this case, because
    the object that cast the shadow was static, its shadow won’t affect any dynamic
    object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为混合光照模式应该影响动态和静态对象，这正是它所做的事情。问题在于与静态对象相关的一切，包括它们投射的阴影，都被预先计算到那些光照贴图纹理中，而我们的胶囊是动态的，在预计算过程中它并不在那里。所以，在这种情况下，因为投射阴影的对象是静态的，它的阴影不会影响任何动态对象。
- en: Here, we have several solutions. The first would be to change the Static and
    Realtime mixing algorithm to make everything near the camera use Realtime lighting
    and prevent this problem (at least near the focus of attention of the player),
    which will have a big impact on performance. The alternative is to use **Light
    Probes**. When we baked information, we only did that on lightmaps, meaning that
    we have information on lighting just over surfaces, not in empty spaces. Because
    our player is traversing the empty spaces between those surfaces, we don’t know
    exactly how the lighting would look in those spaces, such as the middle of a corridor.
    Light Probes are a set of points in those empty spaces where Unity also pre-calculates
    information, so when some dynamic object passes through the Light Probes, it will
    sample information from them. In the following image, you can see some Light Probes
    that have been applied to our scene. You will notice that the ones that are inside
    shadows are going to be dark, while the ones exposed to light will have a greater
    intensity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有几种解决方案。第一种是将静态和实时混合算法更改为使靠近摄像机的所有内容使用实时照明并防止这个问题（至少在玩家的注意力焦点附近），这将大大影响性能。另一种选择是使用
    **光探针**。当我们烘焙信息时，我们只在光照贴图上这样做，这意味着我们只在表面上有关光照的信息，而不是在空旷的空间中。因为我们的玩家正在穿越这些表面之间的空旷空间，我们不知道这些空间中的光照会是什么样子，比如走廊的中间。光探针是一组位于这些空旷空间中的点，Unity
    也预先计算了这些信息，所以当一些动态对象通过光探针时，它将从它们那里采样信息。在下面的图像中，你可以看到一些已经应用于我们场景的光探针。你会注意到，那些处于阴影中的将会变暗，而那些暴露在光线下将会具有更大的强度。
- en: 'This effect will be applied to our dynamic objects:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果将应用于我们的动态对象：
- en: '![](img/B18585_12_53.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_53.png)'
- en: 'Figure 12.53: Spheres representing Light Probes'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.53：代表光探针的球体
- en: 'If you move your object through the scene now, it will react to the shadows,
    as shown in the following two images, where you can see a dynamic object being
    lit outside a baked shadow and being dark inside:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在将你的对象通过场景移动，它将对阴影做出反应，如下两个图像所示，你可以看到动态对象在烘焙阴影外被照亮，而在阴影内则是暗的：
- en: '![](img/B18585_12_54.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_54.png)'
- en: 'Figure 12.54: Dynamic object receiving baked lighting from Light Probes'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.54：从光探针接收烘焙照明的动态对象
- en: 'In order to create Light Probes, do the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建光探针，请执行以下操作：
- en: Create a group of **Light** **Probes** by going to **GameObject | Light | Light
    Probe Group**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **GameObject | 光 | 光探针组** 创建一个 **光探针** 组。
- en: 'Fortunately, we have some guidelines on how to locate them. It is recommended
    to place them where the lighting changes, such as inside and outside shadow borders.
    However, that is complicated. The simplest and recommended approach is to just
    drop a grid of Light Probes all over your playable area. To do that, you can simply
    copy and paste the Light Grid Group several times to cover the entire base:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一些关于如何定位它们的指导方针。建议将它们放置在光照变化的地方，比如在阴影内外。然而，这很复杂。最简单且推荐的方法是将光探针网格整个覆盖在你的可玩区域。为此，你可以简单地多次复制粘贴光网格组来覆盖整个基础：
- en: '![](img/B18585_12_55.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_55.png)'
- en: 'Figure 12.55: Light Probe grid'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.55：光探针网格
- en: 'Another approach would be to select one group and click the **Edit Light Probes**
    button to enter Light Probe edit mode:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法就是选择一个组，点击 **编辑光探针** 按钮进入光探针编辑模式：
- en: '![](img/B18585_12_56.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_12_56.png)'
- en: 'Figure 12.56: Light Probe Group edit button'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.56：光探针组编辑按钮
- en: Click the **Select All** button and then **Duplicate Selected** to duplicate
    all the previously existing probes.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **全选** 按钮然后 **复制所选** 以复制所有之前存在的探针。
- en: Using the translate gizmo, move them next to the previous ones, extending the
    grid in the process. Consider that the nearer the probes are, you more you will
    need to cover the terrain, which will generate more data. However, Light Probes
    data is relatively cheap in terms of performance, so you can have lots of them,
    as seen in *Figure 12.55*.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用翻译工具，将它们移动到前一个旁边，在这个过程中扩展网格。考虑一下，探针越靠近，你需要覆盖的地形就越多，这将生成更多的数据。然而，从性能角度来看，Light
    Probes 数据相对便宜，所以你可以有很多，如图 *图12.55* 所示。
- en: Repeat *steps 4* and *5* until you’ve covered the entire area.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤4* 和 *步骤5*，直到你覆盖了整个区域。
- en: Regenerate lighting with the **Generate Lighting** button in **Lighting Settings**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **光照设置** 中的 **生成光照** 按钮重新生成光照。
- en: With that, you have pre-calculated lighting on the Light Probes affecting our
    dynamic objects, combining both worlds to get cohesive lighting.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就已经预先计算了光照探针对动态物体的影响，将两个世界结合起来以获得一致的光照。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed several lighting topics, such as how Unity calculates
    lights and shadows, how to deal with different light sources such as direct and
    indirect lighting, how to configure shadows, how to bake lighting to optimize
    performance, and how to combine dynamic and static lighting so that the lights
    aren’t disconnected from the world they affect. This was a long chapter, but lighting
    deserves that. It is a complex subject that can improve the look and feel of your
    scene drastically, as well as reduce your performance dramatically. It requires
    a lot of practice and here, we tried to summarize all the important knowledge
    you will need to start experimenting with it. Be patient with this topic; it is
    easy to get incorrect results, but you are probably just one checkbox away from
    solving it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几个光照主题，例如 Unity 如何计算光照和阴影，如何处理不同的光源，如直射光和间接光，如何配置阴影，如何烘焙光照以优化性能，以及如何结合动态光照和静态光照，以确保光照不会与它们影响的世界脱节。这是一个内容丰富的章节，但光照确实值得这样的关注。它是一个复杂的主题，可以极大地改善场景的外观和感觉，同时也能显著降低性能。这需要大量的实践，在这里，我们尝试总结所有你需要开始实验的重要知识。对这个主题要有耐心；很容易得到错误的结果，但你可能只需勾选一个复选框就能解决问题。
- en: Now that we have improved all we can in the scene settings, in the next chapter,
    we will apply a final layer of graphic effects using the Unity Post-Processing
    Stack, which will apply full-screen image effects—the ones that will give us that
    cinematic look and feel that all games have nowadays.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尽可能优化了场景设置，在下一章中，我们将使用 Unity 后处理堆栈应用最终的一层图形效果，这将应用全屏图像效果——那些能给我们带来如今所有游戏都有的电影般外观和感觉的效果。
- en: Join us on Discord!
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社群！
- en: Read this book alongside other users, Unity game development experts, and the
    author himself.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天，等等。
- en: Scan the QR code or visit the link to join the community.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接加入社群。
- en: '![](img/Nicolas_QR_Code.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/Nicolas_QR_Code.png)'
- en: '[https://packt.link/handsonunity22](Chapter_12.xhtml)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/handsonunity22](Chapter_12.xhtml)'
