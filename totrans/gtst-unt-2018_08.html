<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Our Non-Player Characters</h1>
                
            
            
                
<p class="mce-root">In the previous chapter, we focused on our game's player character, the Cucumber Man. We imported the character, reviewed the controls, examined the animations, and made the necessary configuration changes to fully use our character in the game. We reviewed the player character's animations and the character's animation controller. We also identified scripts relevant to the player character and reviewed several of them. In addition, we made modifications to our game's terrain to better accommodate the player character during gameplay.</p>
<p class="mce-root">In this chapter, we will focus on the non-player characters. Our Cucumber Beetles will serve as our game's non-player characters and will be the Cucumber Man's enemies. We will incorporate Cucumber Beetles in our game through direct placement. We will review the beetles' 11 animations and make changes to the non-player character's animation controller. In addition, we will write scripts to control the non-player characters. We will also add cucumber patches, cucumbers, and cherries to our game world.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the non-player characters</li>
<li>Importing the non-player characters into our game</li>
<li>Animating our non-player characters</li>
<li>Incorporating the non-player characters into our game</li>
<li>Terraforming the terrain for our Cucumber Beetles</li>
<li>Adding cucumber patches to our terrain</li>
<li>Adding cucumbers to our terrain</li>
<li>Scripting our non-player characters</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the non-player characters</h1>
                
            
            
                
<p>Non-player characters, commonly referred to as NPCs, are simply game characters that are not controlled by a human player. These characters are controlled through scripts, and their behaviors are usually responsive to in-game conditions.</p>
<p>Our game's non-player characters are the Cucumber Beetles. These beetles, as depicted in the following screenshot, have six legs that they can walk on; under special circumstances, they can also walk on their hind legs:</p>
<div><img height="239" width="239" src="img/7e44d123-493a-4125-b5b9-9d3f0264198c.png"/></div>
<p>Cucumber Beetles are real insects, and are a threat to cucumbers. They cannot really walk on their hind legs, but they can in our game. </p>
<p>In the next section, you will import a Cucumber Beetle asset package prepared specifically for this game. There will only be one beetle in that asset package. We will, through scripting, make multiple copies of the beetle. </p>
<p>Before you move on to the next section, you should open your Unity game project. Alternatively, you can download the <kbd>Starting-Chapter-08</kbd> Unity project available from the publisher's companion site.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing the non-player characters into our game</h1>
                
            
            
                
<p>You are now ready to import the asset package for our game's non-player character, the Cucumber Beetle. Go through the following steps to import the package:</p>
<ol start="1">
<li>Download the <kbd>Cucumber_Beetle.unitypackage</kbd> file from the publisher's companion website</li>
<li>In Unity, with your game project open, select Assets | Import Package | Custom Package from the top menu</li>
<li>Navigate to the location of the asset package you downloaded in step 1 and click the Open button</li>
<li>When presented with the Import Asset Package dialog window, click the Import button</li>
</ol>
<p>As you will notice, the <kbd>Cucumber_Beetle</kbd> asset package contains several assets related to the Cucumber Beetles, including a controller, scripts, a prefab, animations, and other assets: </p>
<div><img height="317" width="241" src="img/137a9770-5573-4f7d-9cf8-92f3a2e0dbd6.png"/></div>
<p>Now that the <kbd>Cucumber_Beetle</kbd> asset package has been imported into our game project, we should save our project. Use the File | Save Project menu option.</p>
<p>Next, let's review what was imported.</p>
<p>In the Project panel, under Assets | Prefabs, you will see a new <kbd>Beetle.Prefab</kbd>. Also in the Project panel, under Assets, you will see a <kbd>Beetle</kbd> folder. It is important that you understand what each component in the folder is for. Please refer to the following screenshot for an overview of the assets that you will be using in this chapter in regards to the Cucumber Beetle:</p>
<div><img height="191" width="548" src="img/ab7937dc-ce30-4b44-851a-dee280891c64.png"/></div>
<p>The other assets in the previous screenshot that were not called out include a <kbd>readme.txt</kbd> file, the texture and materials for the Cucumber Beetle, and the source files. We will review the Cucumber Beetle's animations in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating our non-player characters </h1>
                
            
            
                
<p>Several Cucumber Beetle animations have been prepared for use in our game. Here is a list of the animation names as they appear in our project, along with brief descriptions of how we will incorporate the animation into our game. The animations are listed in alphabetical order by name:</p>
<table>
<tbody>
<tr>
<td><strong>Animation Name</strong></td>
<td><strong>Usage Details</strong></td>
</tr>
<tr>
<td><kbd>Attack_Ground</kbd></td>
<td>The beetle attacks the Cucumber Man's feet from the ground</td>
</tr>
<tr>
<td><kbd>Attack_Standing</kbd></td>
<td>The beetle attacks the Cucumber Man from a standing position</td>
</tr>
<tr>
<td><kbd>Die_Ground</kbd></td>
<td>The beetle dies from the starting position of on the ground</td>
</tr>
<tr>
<td><kbd>Die_Standing</kbd></td>
<td>The beetle dies from the starting position of standing on its hind legs</td>
</tr>
<tr>
<td><kbd>Eat_Ground</kbd></td>
<td>The beetle eats cucumbers while on the ground</td>
</tr>
<tr>
<td><kbd>Idle_Ground</kbd></td>
<td>The beetle is not eating, walking, fighting, or standing</td>
</tr>
<tr>
<td><kbd>Idle_Standing</kbd></td>
<td>The beetle is standing, but not walking, running, or attacking</td>
</tr>
<tr>
<td><kbd>Run_Standing</kbd></td>
<td>The beetle runs on its hind legs</td>
</tr>
<tr>
<td><kbd>Stand</kbd></td>
<td>The beetle goes from an on-the-ground position to standing (it stands up)</td>
</tr>
<tr>
<td><kbd>Walk_Ground</kbd></td>
<td>The beetle walks using its six legs</td>
</tr>
<tr>
<td><kbd>Walk_Standing</kbd></td>
<td>The beetle walks on its hind legs</td>
</tr>
</tbody>
</table>
<p> </p>
<p>You can preview these animations by clicking on an animation file, such as <kbd>Eat_Ground.fbx</kbd>, in the Project panel. Then, in the Inspector panel, click the play button to watch the animation. </p>
<p>There are 11 animations for our Cucumber Beetle, and we will use scripting, later in this chapter, to determine when an animation is played.</p>
<p>In the next section, we will add the Cucumber Beetle to our game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Incorporating the non-player characters into our game</h1>
                
            
            
                
<p>First, let's simply drag the <kbd>Beetle.Prefab</kbd> from the <kbd>Assets</kbd>/<kbd>Prefab</kbd> folder in the Project panel to our game in Scene view. Place the beetle somewhere in front of the Cucumber Man so that the beetle can be seen as soon as you put the game into game mode.</p>
<p>A suggested placement is illustrated in the following screenshot:</p>
<div><img height="160" width="286" src="img/9bde2f10-3845-464e-a9fc-0a0672712618.png"/></div>
<p>When you put the game into game mode, you will notice that the beetle cycles through its animations. If you double-click the <kbd>Beetle.controller</kbd> in the <kbd>Assets</kbd> | <kbd>Beetle</kbd> folder in the Project panel, you will see, as shown in the following screenshot, that we currently have several animations set to play successively and repeatedly:</p>
<div><img height="336" width="506" src="img/83e5d469-c8f4-405e-8d86-546f0067edc0.png"/></div>
<p>This initial setup is intended to give you a first, quick way of previewing the various animations. In the next section, we will modify the animation controller.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with the Animation Controller</h1>
                
            
            
                
<p>We will use an Animation Controller to organize our NPCs' animations. The Animation Controller will also be used to manage the transitions between animations.</p>
<p>Before we start making changes to our Animation Controller, we need to identify what states our beetle has and then determine what transitions each state can have in relation to other states.</p>
<p>Animation states can be referred to as the character's state of animation. For example, walking is a state, as are running and jumping.</p>
<p>Here are the states that the beetle can have, each tied to an animation:</p>
<ul>
<li>Idle on Ground</li>
<li>Walking on Ground</li>
<li>Eating on Ground</li>
<li>Attacking on Ground</li>
<li>Die on Ground</li>
<li>Stand</li>
<li>Standing Idle</li>
<li>Standing Walk</li>
<li>Standing Run</li>
<li>Standing Attack</li>
<li>Die Standing</li>
</ul>
<p>With the preceding list of states, we can assign the following transitions:</p>
<ul>
<li>From Idle on Ground to:
<ul>
<li>Walking on Ground</li>
<li>Running on Ground</li>
<li>Eating on Ground</li>
<li>Attacking on Ground</li>
<li>Stand</li>
</ul>
</li>
<li>From Stand to:
<ul>
<li>Standing Idle</li>
<li>Standing Walk</li>
<li>Standing Run</li>
<li>Standing Attack</li>
</ul>
</li>
</ul>
<p>Reviewing the transitions from Idle on Ground to Stand demonstrates the type of state-to-state transition decisions you need to make for your game. </p>
<p>Let's turn our attention back to the Animation Controller window. You will notice that there are two tabs in the left panel of that window: Layers and Parameters. The Layers tab shows a Base Layer. While we can create additional layers, we do not need to do this for our game. The Parameters tab is empty, and that is fine. We will make our changes using the Layout area of the Animation Controller window. That is the area with the grid background.</p>
<p>Let's start by making the following changes. For all 11 New State buttons, do the following:</p>
<ol>
<li>Left-click the state button</li>
<li>Look in the Inspector panel to determine which animation is associated with the state button</li>
<li>Rename the state name in the Inspector panel to reflect the animation.</li>
<li>Click the return button</li>
<li>Double-check the state button to ensure your change was made</li>
</ol>
<p>When you have completed the preceding five steps for all 11 states, your Animation Controller window should match the following screenshot:</p>
<div><img height="376" width="588" src="img/388a048e-5c23-47fa-96ee-ac427307fa31.png"/></div>
<p>If you were to put the game into game mode, you would see that nothing has changed. We only changed the state names so they made more sense to us. So, we have some more work to do with the Animation Controller.</p>
<p>Currently, the Attacking on Ground state is the default. That is not what we want. It makes more sense to have the <strong>Idle on Ground</strong> state to be our default. To make that change, right-click the <strong>Idle on Ground</strong> state and select Set as Layer Default State:</p>
<div><img height="144" width="381" src="img/5413c304-8755-4e37-9eed-ce5bcfb859b4.png"/></div>
<p class="mce-root">Next, we need to make a series of changes to the state transitions. There are a lot of states and there will be a lot of transitions. In order to make things easier, we will start by deleting all the default transitions. To accomplish this, left-click each white line with an arrow and press your keyboard's <em>Delete</em> key. Do not delete the orange line that goes from <strong>Entry</strong> to <strong>Idle on Ground</strong>.</p>
<p>After all transitions have been deleted, you can drag your states around so you have more working room. You might temporarily reorganize them in a manner similar to what is shown in the following screenshot:</p>
<div><img src="img/e452d19e-f83f-4527-9c08-76e32790acf4.png"/></div>
<p>Our next task is to create all of our state transitions. Follow these steps for each state transition you want to add:</p>
<ol>
<li>Right-click the originating state.</li>
<li>Select Create Transition.</li>
<li>Click on the destination state.</li>
</ol>
<p>Once you have made all your transitions, you can reorganize your states to declutter the Animation Controller's layout area. A suggested final organization is provided in the following screenshot:</p>
<div><img src="img/69fae59c-6c5b-4110-8b79-c41251f458da.png"/></div>
<p>As you can see in our final arrangement, we have 11 states and over two dozen transitions. You will also note that the <strong>Die on Ground</strong> and <strong>Die Standing</strong> states do not have any transitions. In order for us to use these animations in our game, they must be placed into an Animation Controller. </p>
<p>Let's run a quick experiment:</p>
<ol>
<li>Select the Beetle character in the Hierarchy panel. </li>
<li>In the Inspector panel, click the Add Component button.</li>
<li>Select Physics | Box Collider.</li>
<li>Click the Edit Collider button.</li>
</ol>
<p> </p>
<ol start="5">
<li>Modify the size and position of the box collider so that it encases the entire beetle body.</li>
<li>Click the Edit Collider button again to get out of edit mode.</li>
</ol>
<p>Your box collider should look similar to what is depicted in the following screenshot:</p>
<div><img height="219" width="263" src="img/8b398df8-efde-4b50-a2c1-0427b115102e.png"/></div>
<p>Next, let's create a script that invokes the Die on Ground animation when the Cucumber Man character collides with the beetle. This will simulate the Cucumber Man stepping on the beetle. Follow these steps:</p>
<ol>
<li>Select the Beetle character in the Hierarchy panel. </li>
<li>In the Inspector panel, click the Add Component button.</li>
<li>Select New Script.</li>
<li>Name the script <kbd>BeetleNPC</kbd>.</li>
<li>Click the Create and Add button.</li>
<li>In the project view, select Favorites | All Scripts | BeetleNPC.</li>
<li>Double-click the <kbd>BeetleNPC</kbd> script file.</li>
<li>Edit the script so that it matches the following code block:</li>
</ol>
<pre> using System.Collections;<br/> using System.Collections.Generic;<br/> using UnityEngine;<br/> <br/> public class BeetleNPC : MonoBehaviour {<br/> <br/>     Animator animator;<br/> <br/>     // Use this for initialization<br/>     void Start () {<br/>         animator = GetComponent&amp;lt;Animator&gt;();    <br/>     }<br/> <br/>     // Collision Detection Test<br/>     void OnCollisionEnter(Collision col) <br/>     {<br/>         if (col.gameObject.CompareTag("Player"))<br/>         {<br/>             animator.Play("Die on Ground");<br/>         }<br/>     }<br/> } </pre>
<p>This code detects a collision between the Cucumber Man and the beetle. If a collision is detected, the <kbd>Die on Ground</kbd> animation is played.  As you can see in the following screenshot, the Cucumber Man defeated the Cucumber Beetle:</p>
<div><img height="347" width="237" src="img/c6028313-bd1c-455f-bef2-11b8411b6eba.png"/></div>
<p>This short test demonstrated two important things that will help us further develop this game:</p>
<ul>
<li>Earlier in this section, you renamed all the states in the Animation Controller window. The names you gave the states are the ones you will reference in code. </li>
<li>Since the animation we used did not have any transitions to other states, the Cucumber Beetle will remain in the final position of the animation unless we script it otherwise. So, if we had 100 beetles and defeated them all, all 100 would remain on their backs in the game world.</li>
</ul>
<p>This was a simple and successful scripting test for our Cucumber Beetle. We will need to write several more scripts to manage the beetles in our game. First, there are some game world modifications we will make. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Terraforming the terrain for our Cucumber Beetles </h1>
                
            
            
                
<p>Our game world is currently very large and appropriate for the game we envisioned. In order to efficiently demonstrate how to script the Cucumber Beetles, we will designate a sandbox area of our game and confine the Cucumber Beetles to that area. We will also need to move some cherry trees there. </p>
<p>We will make the following sequential modifications to our game's terrain:</p>
<ul>
<li>Designate a sandbox area</li>
<li>Plant additional cherry trees</li>
<li>Create spawning sites</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Designating a sandbox area</h1>
                
            
            
                
<p>We do not necessarily want to make major modifications to our game's terrain. We previously spent considerable time planning, creating, and fine-tuning the terrain. Instead, we will select one of the large, flat areas to act as a sandbox. If you do not have any large, flat areas, you can select one of your flat areas and make it a bit bigger.</p>
<p>The following image suggests a size relative to our current game world. The white box towards the bottom center of the image represents an ideal size:</p>
<div><img src="img/8806b183-af16-4efa-ba32-ac4147fc9066.png"/></div>
<p>Now that we know where our sandbox will be, let's prepare the Hierarchy panel for any new items we create for the sandbox. Simply right-click in an empty area of the Hierarchy panel and select Create Empty. With that new <kbd>GameObject</kbd> selected, rename it in the Inspector panel as <kbd>Sandbox</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Planting additional cherry trees</h1>
                
            
            
                
<p>Since our sandbox is a smaller representation of our larger game environment, we will need one or more cherry trees. As you will recall, the Cucumber Man will collect cherries from the cherry trees and use them to launch ranged attacks on the Cucumber Beetles.</p>
<p>In <a href="04be4d7b-8c85-4d9e-baf2-43965183f99f.xhtml" target="_blank">Chapter 6</a>, <em>Creating and Importing 3D Objects for Our Game</em>, we imported our <kbd>Cherry Tree</kbd> object and modified it for our game. Now, we can simply add additional cherry trees to our sandbox area. You can drag the CherryTreeCollider from Projects | Assets | Prefabs directly into your sandbox area in the Scene view.</p>
<p>Next, you will want to zoom into the sandbox area, using the Scene view, to ensure that your trees are not above the ground or in need of additional adjustments.</p>
<p>Once your additional cherry trees are in place, each new cherry tree will be accessible in the Hierarchy panel. Click each newly created cherry tree and drag it to the <kbd>Sandbox</kbd> object you previously created. We are using the <kbd>Sandbox</kbd> object for organizational purposes only. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating spawning sites</h1>
                
            
            
                
<p>Within the sandbox area, select three areas to serve as spawn points. Where you create them is up to you. Placing them at equal distances from one another would be a good approach. To make these spawn points obvious, let's create a spawn pad and then copy it and place it at various points in the sandbox.</p>
<p>Here are the steps to create the spawn pad:</p>
<ol>
<li>In the Hierarchy panel, right-click Sandbox and select 3D Object | Cylinder.</li>
<li>In the Inspector panel, rename the Cylinder to <kbd>SpawnPad1</kbd>.</li>
<li>Click Transform | Scale and change the scale of <kbd>SpawnPad1</kbd> as follows:
<ul>
<li>x = <kbd>3</kbd></li>
<li>y = <kbd>0.05</kbd></li>
<li>z =<kbd>3</kbd></li>
</ul>
</li>
<li>Test the scale of the pad by placing it under the Cucumber Man. It should look similar to what is shown in the following screenshot. Make adjustments so that your pad matches what you see here:</li>
</ol>
<div><img height="198" width="287" src="img/f515e789-5b3d-42c1-984d-4a52462f5e5b.png"/></div>
<ol start="5">
<li>With <kbd>SpawnPad1</kbd> selected, deselect the Mesh Renderer | Receive Shadows checkbox in the Inspector view. This will prevent shadows from being cast onto our spawn pad. This step is not terribly important, but helps make our spawn pad seem nonorganic, and since we will be spawning the Cucumber Man on this pad, it adds a nice visual element.</li>
<li>Using the transform tools, adjust the position of the pad so that it is under the bottom of the Cucumber Man's feet, just at or above the grass level.</li>
<li>With <kbd>SpawnPad1</kbd> selected, click the small circle to the right of the Materials | Element 0 | Missing (Material) input box in the Inspector panel:</li>
</ol>
<div><img height="57" width="343" src="img/567a2e3f-0f71-4dd2-9d0d-0d1bca9125f5.png"/></div>
<ol start="8">
<li>Select a material of your choice from the Select Material dialog window.</li>
<li>Finally, deselect the Capsule Collider component in the Inspector panel. We will not need this.</li>
</ol>
<p>You now have your first spawn pad. Make two further copies, ensuring that they are named <kbd>SpawnPad1</kbd>, <kbd>SpawnPad2</kbd>, and <kbd>SpawnPad3</kbd>. In the Hierarchy panel, ensure that they are all in your <kbd>Sandbox</kbd> object.</p>
<p>Our last task is to put the three spawn pad instances where we want them in the <kbd>Sandbox</kbd> area in Scene view.</p>
<p>This is a good time to save your scene and your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding cucumber patches to our terrain </h1>
                
            
            
                
<p>In <a href="04be4d7b-8c85-4d9e-baf2-43965183f99f.xhtml" target="_blank">Chapter 6</a>, <em>Creating and Importing 3D Objects for Our Game</em>, we used planes to designate six cucumber patch areas. In this section, we will make a seventh cucumber patch and use it in our sandbox area. We will also plant cucumber patches inside the new cucumber patch area.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a cucumber patch area in the sandbox</h1>
                
            
            
                
<p>This section guides you through the steps necessary to create a cucumber patch area in the sandbox. In the Hierarchy panel, you should have a <kbd>Cucumber Patch Areas</kbd> game object that contains every size of cucumber patch, each one a 3D object of the <kbd>plane </kbd>type. If you do not have these objects, which are shown in the following screenshot, either revisit <a href="04be4d7b-8c85-4d9e-baf2-43965183f99f.xhtml" target="_blank">Chapter 6</a>, <em>Creating and Importing 3D Objects for Our Game</em>, or download the <kbd>Starting-Chapter-08</kbd> Unity project available from the publisher's companion site:</p>
<div><img height="105" width="148" src="img/b3fcc4a9-2c3d-4f56-a10f-2164a8c2d156.png"/> </div>
<p>Here are the steps to create a sandbox area in our game:</p>
<ol>
<li>In the Hierarchy panel, expand the <kbd>Cucumber Patch Areas</kbd> game object to expose the six planes. Remember, we created the <kbd>Cucumber Patch Areas</kbd> game object to serve as a visual organizing folder for our convenience.</li>
<li>Double-click each plane (<kbd>CucumberPatchArea1</kbd>, <kbd>CucumberPatchArea2</kbd>, <kbd>CucumberPatchArea3</kbd>, <kbd>CucumberPatchArea4</kbd>, <kbd>CucumberPatchArea5</kbd>, and <kbd>CucumberPatchArea6</kbd>). When you double-click an object in the Hierarchy panel, the Scene view will be focused on it. </li>
<li>Identify which cucumber patch area is already in your sandbox.</li>
<li>In the Hierarchy panel, right-click the identified cucumber patch and select Duplicate.</li>
<li>Rename the duplicated cucumber patch as <kbd>CucumberPatchAreaSandbox</kbd>.</li>
<li>In the Hierarchy panel, drag the <kbd>CucumberPatchAreaSandbox</kbd> to subordinate it under the <kbd>Sandbox</kbd> game object.</li>
<li>With the <kbd>CucumberPatchAreaSandbox</kbd> plane selected, modify the shape to fit the sandbox area. Use the transform tools for this.</li>
<li>Modify the terrain section of the sandbox, if necessary, so that the terrain inside the confines of the <kbd>CucumberPatchAreaSandbox</kbd> is flat and can receive cucumber patches.</li>
</ol>
<p>You may have to use the Raise / Lower Terrain and Smooth Height terrain tools to ensure the area with the <kbd>CucumberPatchAreaSandbox</kbd> is flat. The following screenshot shows the orange-outlined <kbd>CucumberPatchAreaSandbox</kbd> area, two cherry trees, and the three spawn pads indicated in red. Smaller and more difficult to see are the Cucumber Man and one Cucumber Beetle. Your sandbox does not need to look exactly like this, but should have the same components as shown in the following screenshot:</p>
<div><img height="288" width="344" src="img/df148726-9e49-4441-9393-cc7de1c6d0a4.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Planting cucumber patches</h1>
                
            
            
                
<p>We will use our cucumber patches, the <kbd>CucumberPatch1</kbd> and <kbd>CucumberPatch2</kbd> prefabs, to create cucumber patch areas in the sandbox. These areas will serve as cover for our cucumbers. In this section, we will create an empty game object to encapsulate a series of cucumber patches. Let's get started:</p>
<ol>
<li>Right-click the Sandbox in the Hierarchy panel and select Create Empty.</li>
<li>Rename the new GameObject as <kbd>cucumberPatches</kbd>.</li>
<li>Drag several <kbd>CucumberPatch1</kbd> prefabs onto the scene, in your sandbox.</li>
</ol>
<p> </p>
<ol start="4">
<li>Drag several <kbd>CucumberPatch2</kbd> prefabs onto the scene, in your sandbox.</li>
<li>In the Hierarchy panel, move all the newly created cucumber patches to the <kbd>cucumberPatches</kbd> game object under Sandbox. This is merely to keep the Hierarchy panel organized.</li>
<li>Expand the <kbd>cucumberPatches</kbd> game object in the Hierarchy panel.</li>
<li>Select all of the cucumber patches you added and use <em>Ctrl</em> + <em>C</em> and <em>Ctrl</em> + <em>V</em> to copy and paste them, respectively. The copied results will be highlighted in the Hierarchy panel and accessible in the Scene view.</li>
<li>In the Scene view, use the transform tools to relocate the copied group of cucumber patches.</li>
<li>Repeat steps 7 and 8 until you are satisfied with your sandbox. </li>
</ol>
<p>An example of what your sandbox might look like with the newly created cucumber patches is provided in the following screenshot. Your sandbox will be different, and that is okay:</p>
<div><img height="274" width="593" src="img/1dfa14be-b881-442c-868c-3c0b16d800fd.png"/></div>
<p>Our sandbox now has sufficient cucumber patches. In the next section, we will focus on cucumbers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding cucumbers to our terrain</h1>
                
            
            
                
<p>Cucumbers will be used in our game to give the beetles something to search for and to eat. We will place several cucumbers in the sandbox area and, in <a href="fdacd7a8-63fe-454d-9d50-f9f40070e484.xhtml" target="_blank">Chapter 10</a>, <em>Scripting Our Points System</em>, keep track of how many there are during gameplay. In this section, we will prepare the cucumbers for our use and populate them in our game.</p>
<p>You previously downloaded the necessary assets for the cucumber. As you can see in the following screenshot, <kbd>Cucumber</kbd> is accessible in the <kbd>Assets/Cucumber</kbd> folder. You will note that when we select <kbd>Cucumber</kbd>, the bottom of the Project panel identifies the <kbd>Cucumber</kbd> file as a <kbd>.fbx</kbd> file:</p>
<div><img height="361" width="318" src="img/0313ce77-b146-4e54-8762-bb62c3425dec.png"/></div>
<p>The <kbd>.fbx</kbd> file was exported from the 3D modeling software so we can use it in our game. When that asset is selected, the inspector view shows Import Settings. We want access to the transform, mesh renderer, and other components, so we will turn it into a prefab and make some changes. Here are some initial steps:</p>
<ol>
<li>Drag the <kbd>Cucumber.fbx</kbd> file from Assets | Cucumber to the Hierarchy panel</li>
<li>With the <kbd>Cucumber</kbd> selected in the Hierarchy panel, drag it to the <kbd>Assets</kbd>/<kbd>Prefabs</kbd> folder in the Project panel</li>
<li>Delete the <kbd>Cucumber</kbd> from the Hierarchy panel</li>
<li>In the Project panel, select Assets | Prefabs | Cucumber</li>
</ol>
<p>When we select the <kbd>Cucumber</kbd> file we just moved from the Hierarchy panel to the <kbd>Prefabs</kbd> folder, the bottom of the Project panel, shown in the following screenshot, identifies <kbd>Cucumber</kbd> as a prefab:</p>
<div><img height="357" width="319" src="img/dbdf2d49-aabc-43a1-9346-a5bf0e5494c8.png"/></div>
<p>Now, when we look in the Inspector panel, we have access to the components we need to further prepare the cucumber for use in our game. Let's make a few changes to the prefab:</p>
<ol>
<li>In the Inspector panel, select Tag | Add Tag.</li>
<li>In the Tags &amp; Layers interface, click the plus icon to the right of the view. As shown in the following screenshot, beneath the plus icon is the CherryTree tag and to the right:</li>
</ol>
<div><img height="104" width="275" src="img/1e6da26c-2888-40ca-a56d-da287af4e472.png"/></div>
<ol start="3">
<li>Enter the name Cucumber.</li>
<li>Click the Save button.</li>
<li>Select the Assets | Prefabs | Cucumber prefab in the Project panel.</li>
<li>In the Inspector panel, select Tag | Cucumber. </li>
</ol>
<p>Now that our <kbd>cucumber</kbd> prefab has a tag, all copies of it will have that same tag. This tag will facilitate the following for us regarding gameplay:</p>
<ul>
<li>Easily count how many cucumbers are left in the game</li>
<li>Identify when a beetle has found a cucumber</li>
</ul>
<p>We have one more modification to make for our <kbd>cucumber</kbd> prefab—add a collider:</p>
<ol>
<li>Select the Assets | Prefabs | Cucumber prefab in the Project panel</li>
<li>In the Inspector panel, click the Add Component button</li>
<li>Select Physics | Box Collider</li>
</ol>
<p>Next, we can add cucumbers to our sandbox area. First, let's take the same approach as we did for the cucumber patches in regards to organization:</p>
<ol>
<li>Right-click the Sandbox in the Hierarchy panel and select Create Empty.</li>
<li>Rename the new <kbd>GameObject</kbd> to <kbd>cucumbers</kbd>.</li>
</ol>
<p> </p>
<ol start="3">
<li>Drag several <kbd>Cucumber</kbd> prefabs onto the scene, in your sandbox. You can also drag a single prefab into the Scene view and make copies of it using the shortcut <em>Ctrl</em> + <em>D</em>, which will duplicate all currently selected objects.</li>
<li>Using the transform tools, rotate, resize, and relocate the cucumbers.</li>
<li>Ensure you have at least 10 cucumbers in your sandbox area.</li>
<li>In the Hierarchy panel, move all the newly created cucumbers to the <kbd>cucumbers</kbd> game object under Sandbox. This is merely to keep the Hierarchy panel organized.</li>
</ol>
<p>Once you have your cucumbers dispersed throughout the sandbox area of your game world, you are ready to start scripting the Cucumber Beetles. We will take care of this in the next section.</p>
<p>This is a good time to save your scene and your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scripting our non-player characters</h1>
                
            
            
                
<p>In this section, we will write the necessary scripts to manage the Cucumber Beetles in our game. Specifically, we will write scripts to accomplish the following:</p>
<ul>
<li>Beetle patrol</li>
<li>Beetle finds and eats cucumber</li>
<li>Beetle attacks player on the ground</li>
<li>Beetle stands to attack</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting organized</h1>
                
            
            
                
<p>Since we are writing several scripts, we should stay organized. We can click Favorites | All Scripts in the Project panel to get a list of all the scripts in our project, but there are a lot of them, most of which we will not edit for our game. So, let's create a folder in the Project panel to organize our custom scripts. Here are the steps: </p>
<ol>
<li>In the Project panel, right-click the <kbd>Assets</kbd> folder</li>
<li>Select Create | Folder</li>
<li>Name the new folder <kbd>Custom Scripts</kbd></li>
</ol>
<p>Now that we have a folder for our custom scripts, let's move a few: </p>
<ol>
<li>In the Project panel, click Favorites | All Scripts. </li>
<li>Scroll until you find the <kbd>BeetleNPC</kbd> script we created earlier in this chapter.</li>
<li>Drag the <kbd>BeetleNPC</kbd> script to our <kbd>Custom Scripts</kbd> folder. This moves the <kbd>BeetleNPC</kbd> script to the designated folder. You will still see it in Favorites | All Scripts because this feature shows all scripts regardless of their location.</li>
<li>Move the <kbd>CameraFollower</kbd> script to the <kbd>Custom Scripts</kbd> folder.</li>
<li>Move the <kbd>PlayerController</kbd> script to the <kbd>Custom Scripts</kbd> folder.</li>
<li>Move the <kbd>PlayerMotor</kbd> script to the <kbd>Custom Scripts</kbd> folder.</li>
</ol>
<p>When you are done moving scripts, your <kbd>Cucumber Scripts</kbd> folder should be the same as the following screenshot:</p>
<div><img height="85" width="155" src="img/75bddd97-870c-4906-ad89-b0d3d3774135.png"/></div>
<p>Our beetles will have the following behaviors in our game:</p>
<ul>
<li>Search for cucumbers (patrol)</li>
<li>Eat cucumbers when found</li>
<li>Defend itself from the Cucumber Man on the ground</li>
<li>Stand to defend itself from the Cucumber Man</li>
</ul>
<p>The next sections will show you how to script these behaviors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beetle patrol</h1>
                
            
            
                
<p>Beetles in our game will search for cucumbers within the sandbox area. In this section, we will write a script to manage their patrol. Let's take some preparatory steps.</p>
<p>We will get started by creating a character controller for our <kbd>Beetle</kbd> prefab. Here are the steps:</p>
<ol>
<li>In the Project panel, select Assets | Prefabs and click on the <kbd>Beetle</kbd> prefab</li>
<li>In the Inspector panel, click the Add Component button</li>
<li>Select Physics | Character Controller</li>
</ol>
<p>Be sure that you add the character controller to the <kbd>Beetle</kbd> prefab, not a beetle that you have in your scene.</p>
<p>We do not need to make any changes to the default character controller, but we do need to have one. </p>
<p>Next, let's make things easy on us and create some temporary containing walls for the beetles. You can simply add 3D cube game objects and, using the transform tools, orientate them so that they border the sandbox, or a part of the sandbox.  You can put your walls inside an empty game object called <kbd>Walls</kbd> and, in the Hierarchy panel, organize them inside the <kbd>Sandbox</kbd> game object. A representative example is shown in the following screenshot:</p>
<div><img height="257" width="241" src="img/dea4e9b1-e644-4930-aaaf-aba9e0563c7c.png"/></div>
<p>Okay, now we are ready to start scripting our beetle's patrol. To get started, right-click the Assets | Custom Scripts folder in the Project panel. Select Create | C# Script, then name the script <kbd>BeetlePatrol</kbd>. This creates a C# script for us in our <kbd>Custom Scripts</kbd> folder. We will walk through this script from top to bottom in small chunks.</p>
<p>This first section of code simply imports <kbd>System.Collections</kbd>, <kbd>System.Collections.Generic</kbd>, and the <kbd>UnityEngine</kbd>. The section also has our <kbd>BeetlePatrol</kbd> class header:</p>
<pre> using System.Collections;<br/> using System.Collections.Generic;<br/> using UnityEngine;<br/> <br/> public class BeetlePatrol : MonoBehaviour { </pre>
<p>Our variables are provided in the next section. The first variable, <kbd>isDie</kbd>, is a global variable the we will use to determine whether the Cucumber Beetle should stop patrolling. The remaining variables are local. Their use will be self-evident after reviewing subsequent code sections:</p>
<pre>// Variables<br/>public static bool isDie = false;<br/> <br/>public float speed = 5;<br/>public float directionChangeInterval = 1;<br/>public float maxHeadingChange = 30;<br/> <br/>Animator beetleAnim;<br/> <br/>CharacterController controller;<br/>float heading;<br/>Vector3 targetRotation;<br/>  </pre>
<p>The next section of code is our <kbd>Start()</kbd> method, which only runs at the beginning of the game. This code sets the initial rotation for the beetle's patrol:</p>
<pre>void Start () {<br/> <br/>     controller = GetComponent&amp;lt;CharacterController&gt;();<br/>     beetleAnim = GetComponent&amp;lt;Animator&gt; ();<br/>  <br/>     // Set random initial rotation<br/>     heading = Random.Range(0, 360);<br/>     transform.eulerAngles = new Vector3(0, heading, 0);<br/> <br/>     StartCoroutine(NewHeading()); <br/>} </pre>
<p>Our <kbd>Update()</kbd> method, shown in the following code, is our next section. This code will be executed once per game frame. Here, you can see that if condition <kbd>isDie</kbd> is <kbd>false</kbd> (or not <kbd>true</kbd>), then the code will be executed:</p>
<pre>void Update () {<br/> <br/>     if (!isDie) {<br/>          transform.eulerAngles = Vector3.Slerp (transform.eulerAngles, targetRotation, <br/>               Time.deltaTime * directionChangeInterval);<br/>          var forward = transform.TransformDirection (Vector3.forward);<br/>          controller.SimpleMove (forward * speed);<br/>     }<br/> <br/>} </pre>
<p>This last section of code provides two methods. The <kbd>NewHeading()</kbd> and <kbd>NewHeadingRoutine()</kbd> methods calculate a new direction for the beetle to move towards:</p>
<pre>IEnumerator NewHeading () {<br/><br/>     while (true) {<br/>          NewHeadingRoutine();<br/>          yield return new WaitForSeconds(directionChangeInterval);<br/>     }<br/>}<br/> <br/>void NewHeadingRoutine () {<br/><br/>     var floor = transform.eulerAngles.y - maxHeadingChange;<br/>     var ceil  = transform.eulerAngles.y + maxHeadingChange;<br/>     heading = Random.Range(floor, ceil);<br/>     targetRotation = new Vector3(0, heading, 0);<br/> }<br/><br/>} // this is the end of the Beetle Patrol class</pre>
<p>Save your script. Next, we need to associate it with the <kbd>Beetle</kbd> prefab. With the prefab selected, click the Add Component button in the Inspector panel. Then, select Scripts | Beetle Patrol. </p>
<p>You can drag multiple beetles into your scene and test the game. You should see them wandering around your sandbox, remaining confined by the walls you built. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beetle finds and eats cucumber</h1>
                
            
            
                
<p>Earlier in this chapter, we created a <kbd>BeetleNPC</kbd> script file and attached it to our <kbd>Beetle</kbd> prefab. That script detected collisions with the Cucumber Man. In this section, we will modify that script so that it can also detect when it collides with a cucumber.</p>
<p>Let's first ensure that the cucumbers are properly set up. Check that the is selected (checked) in the cucumber's Box Collider component in the Inspector panel. Next, make several copies of your cucumber throughout the sandbox area of your scene. You can place them in close proximity to your beetles for easier testing. See the following screenshot for an optimal test configuration:</p>
<div><img height="306" width="392" src="img/fac4c46f-b637-49e8-8b8d-e2363b3a3c52.png"/></div>
<p>The <kbd>BeetleNPC</kbd> script needs a new variable and two methods, one of which will be used as a coroutine. Let's get started with the new variable. As you can see in the following code snippet, we now have a second variable, <kbd>cucumberToDestroy</kbd>. We will use that to reference the cucumber that the beetle ate:</p>
<pre>Animator animator;<br/>public GameObject cucumberToDestroy; </pre>
<p>Next, we will add an <kbd>OnTriggerEvent()</kbd> method that is similar to the <kbd>OnCollissionEnter</kbd> that we previously created in this chapter. As you can see, we are testing to see whether the beetle collided with a cucumber. When that is detected, we have four lines of code that are executed. The first line points the <kbd>cucumberToDestroy</kbd> variable to the specific cucumber the beetle collided with. The next line sets the <kbd>isEating</kbd> value to <kbd>true</kbd>. We will update the <kbd>BeetlePatrol</kbd> script to accommodate that change. The third statement plays the eating animation. The final statement calls the <kbd>DestroyCucumber</kbd> function, which we will look at next:</p>
<pre>void OnTriggerEnter(Collider theObject) {<br/>     if (theObject.gameObject.CompareTag ("Cucumber")) {<br/>         cucumberToDestroy = theObject.gameObject;<br/>         BeetlePatrol.isEating = true;<br/>         animator.Play ("Eating on Ground");<br/>         StartCoroutine ("DestroyCucumber");<br/>     }<br/>} </pre>
<p>The last change to the <kbd>BeetleNPC</kbd> script is the <kbd>DestroyCucumber()</kbd> function. We are using this function to delay the destruction of the cucumber. This simulates the amount of time it takes for the beetle to eat the cucumber. You can change the parameter of <kbd>WaitForSecondsRealTime</kbd> to your liking. That parameter represents real-world seconds. Once the delay is over, the object is destroyed and the <kbd>isEating</kbd> variable is set to <kbd>false</kbd>:</p>
<pre>IEnumerator DestroyCucumber() {<br/>         <br/>     yield return new WaitForSecondsRealtime (4);<br/>     Destroy (cucumberToDestroy.gameObject);<br/>     BeetlePatrol.isEating = false;<br/>} </pre>
<p>We have two changes to make to our <kbd>BeetlePatrol</kbd> script. First, as you can see in the following code, we will add the new <kbd>isEating</kbd> variable:</p>
<pre> public static bool isDie, isEating = false; </pre>
<p>Our final change to the <kbd>BeetlePatrol</kbd> script is to update the conditional statement, as shown in the following code. Now, we will stop the patrol if the beetle is dying or eating:</p>
<pre>void Update () {<br/> <br/>     if (!isDie &amp;&amp; !isEating) {<br/>          transform.eulerAngles = Vector3.Slerp (transform.eulerAngles, targetRotation, <br/>               Time.deltaTime * directionChangeInterval);<br/>          var forward = transform.TransformDirection (Vector3.forward);<br/>          controller.SimpleMove (forward * speed);<br/>     }<br/>} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Beetle attacks player on the ground</h1>
                
            
            
                
<p>Currently, when our Cucumber Man collides with a Cucumber Beetle, the Die animation is played, but no other behaviors are implemented. In this section, we will modify the necessary scripts for the following to occur each time the Cucumber Man collides with a Cucumber Beetle:</p>
<ul>
<li>Beetle faces Cucumber Man</li>
<li>Beetle attacks Cucumber Man for specified time</li>
<li>Beetle's die animation plays</li>
<li>Beetle is removed from game</li>
</ul>
<p>We will use the following three lines of code inside our <kbd>OnCollisionEnter()</kbd> method to force the beetle to face the Cucumber Man when there is a collision. As you can see from the following code, we create a variable to make it easy to reference the Cucumber Man and then a second variable for the Cucumber Man's current transform. The third line of code tells the current Cucumber Beetle to face the Cucumber Man:</p>
<pre>var cm = GameObject.Find ("CucumberMan");<br/>var tf = cm.transform;<br/>this.gameObject.transform.LookAt (tf); </pre>
<p>Now, we just need to edit the <kbd>OnCollisionEnter</kbd> method to include two statements. The first statement plays the Attacking on Ground animation. The second statement makes a call to the function that will destroy the current Cucumber Beetle. Here are those two lines of code:</p>
<pre>animator.Play ("Attacking on Ground");<br/>StartCoroutine ("DestroySelf"); </pre>
<p>The last change to the <kbd>BeetleNPC</kbd> script is the <kbd>DestroySelf()</kbd> function. We are using this function to simulate the battle and end of life for the current Cucumber Beetle. There are three statements inside the function. The first statement simulates the attack time. The second statement plays the <kbd>Die on Ground</kbd> animation. The final line destroys the game object, which is the current Cucumber Beetle:</p>
<pre>IEnumerator DestroySelf() {<br/> <br/>     yield return new WaitForSecondsRealtime (4);<br/>     animator.Play ("Die on Ground");<br/>     Destroy (this.gameObject, 4);<br/>} </pre>
<p>We have two changes to make to our <kbd>BeetlePatrol</kbd> script. First, as you can see in the following code, we will add the new <kbd>isAttacking</kbd> variable:</p>
<pre> public static bool isDie, isEating, isAttacking =&lt;/span&gt; false; </pre>
<p>Our final change to the <kbd>BeetlePatrol</kbd> script is to update the conditional statement, as shown in the following code. Now, we will stop the patrol if the beetle is dying, eating, or attacking:</p>
<pre>void Update () {<br/> <br/>     if (!isDie &amp;&amp; !isEating &amp;&amp; !isAttacking)) {<br/>          transform.eulerAngles = Vector3.Slerp (transform.eulerAngles, <br/>               targetRotation, Time.deltaTime * directionChangeInterval);<br/>          var forward = transform.TransformDirection (Vector3.forward);<br/>          controller.SimpleMove (forward * speed);<br/>     }<br/>} </pre>
<p>We will make additional modifications to the scripts and behaviors in <a href="fdacd7a8-63fe-454d-9d50-f9f40070e484.xhtml" target="_blank">Chapter 10</a>, <em>Scripting Our Points System</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beetle stands to attack</h1>
                
            
            
                
<p>You will recall that the Cucumber Man has the ability to throw cherries at the Cucumber Beetles. This is a ranged attack, and if the Cucumber Beetle were to start walking or running on the ground toward the Cucumber Man to attack, it is likely the beetle would die before reaching the Cucumber Man.</p>
<p>So, if a beetle is hit by a cherry, we want the following to occur:</p>
<ul>
<li>Beetle faces Cucumber Man</li>
<li>Beetle stands</li>
<li>Beetle runs, while standing, towards the Cucumber Man</li>
<li>Beetle attacks Cucumber Man while standing</li>
</ul>
<p>You can review the animations if you need a refresher on what they look like. </p>
<p>We will make some significant changes to our <kbd>BeetleNPC</kbd> script. The updated script is presented in the following code in its entirety, divided by sequential sections with explanations.</p>
<p>This section shows the imports and class-level variables. You will notice that the last three variables (<kbd>cherryHit</kbd>, <kbd>smoothTime</kbd>, and <kbd>smoothVelocity</kbd>) are new. We will use <kbd>cherryHit</kbd> to keep track of the sequence leading up to the beetle's death. The remaining two variables will be used to control how fast and smooth the beetle travels to the Cucumber Man:</p>
<pre> using System.Collections;<br/> using System.Collections.Generic;<br/> using UnityEngine;<br/> <br/> public class BeetleNPC : MonoBehaviour {<br/> <br/>     Animator animator;<br/>     public GameObject cucumberToDestroy;<br/>     public bool cherryHit = false;<br/>     public float smoothTime = 3.0f; <br/>     public Vector3 smoothVelocity = Vector3.zero;</pre>
<p>No change was made to the <kbd>Start()</kbd> method:</p>
<pre> void Start () {<br/>      animator = GetComponent&amp;lt;Animator&gt;();<br/> }</pre>
<p>We are now using the <kbd>Update()</kbd> method for the first time. This is necessary so that every frame in which the beetle can travel toward the Cucumber Man is shown. You can also see that we are using the <kbd>cherryHit</kbd> variable in our conditional statement:</p>
<pre>void Update () {<br/>     if (cherryHit) {<br/>          var cm = GameObject.Find ("CucumberMan");<br/>          var tf = cm.transform;<br/>          this.gameObject.transform.LookAt (tf);<br/> <br/>          animator.Play ("Standing Run");<br/> <br/>          transform.position = Vector3.SmoothDamp (transform.position, tf.position,<br/>               ref smoothVelocity, smoothTime);<br/>     }<br/>}<br/></pre>
<p>The next section of our script is the <kbd>OnCollisionEnter()</kbd> method. We moved the statements we previously had in this method so that they are encapsulated in an <kbd>if</kbd> statement. If the <kbd>cheeryHit</kbd> is <kbd>false</kbd>, then the original code will be executed, otherwise the two lines of code after the <kbd>else</kbd> statement will be executed. We see there that we caused two animations to play:</p>
<pre><br/> void OnCollisionEnter(Collision col) {<br/>      if (col.gameObject.CompareTag ("Player")) {<br/><br/>           if (!cherryHit) {<br/>                BeetlePatrol.isAttacking = true;<br/> <br/>                var cm = GameObject.Find ("CucumberMan");<br/>                var tf = cm.transform;<br/>                this.gameObject.transform.LookAt (tf);<br/> <br/>                animator.Play ("Attacking on Ground");<br/>                StartCoroutine ("DestroySelfOnGround");<br/>           } else {<br/>                animator.Play ("Standing Attack");<br/>                StartCoroutine ("DestroySelfStanding");<br/>           }<br/>     }<br/>}</pre>
<p>The next section of code is the <kbd>OnTriggerEnter()</kbd> method that we previously created for handling collisions with cucumbers.  As you can see from the following code, we added an <kbd>else if</kbd> statement to check whether we collided with a <kbd>gameObject</kbd> with a tag of <kbd>Cherry</kbd>. When that condition is <kbd>true</kbd>, we set the <kbd>isAttacking</kbd> Boolean variable to <kbd>true</kbd> so that the forward motion driven by the <kbd>BeetlePatrol</kbd> script will stop. We also set the <kbd>cherryHit</kbd> value to <kbd>true</kbd> and play the animation that shows the beetle standing:</p>
<pre>void OnTriggerEnter(Collider theObject) {<br/>     if (theObject.gameObject.CompareTag ("Cucumber")) {<br/> <br/>          cucumberToDestroy = theObject.gameObject;<br/>          BeetlePatrol.isEating = true;<br/>          animator.Play ("Eating on Ground");<br/>          StartCoroutine ("DestroyCucumber");<br/> } else if (theObject.gameObject.CompareTag ("Cherry")) {<br/>          BeetlePatrol.isAttacking = true;<br/>          cherryHit = true;<br/>          animator.Play ("Stand");<br/> }<br/>}</pre>
<p>The last section of our <kbd>BeetleNPC</kbd> script contains three <kbd>Destroy</kbd>-related functions. You are already familiar with <kbd>DestroyCucumber()</kbd>. We renamed the <kbd>DestroySelf()</kbd> function as <kbd>DestroySelfOnGround()</kbd> and added the new <kbd>DestroySelfStanding()</kbd>:</p>
<pre>IEnumerator DestroyCucumber() {<br/>     yield return new WaitForSecondsRealtime (4);<br/>     Destroy (cucumberToDestroy.gameObject);<br/>     BeetlePatrol.isEating = false;<br/>}<br/> <br/>IEnumerator DestroySelfOnGround() {<br/> <br/>     yield return new WaitForSecondsRealtime (4);<br/>     animator.Play ("Die on Ground");<br/>     Destroy (this.gameObject, 4);<br/>}<br/> <br/>IEnumerator DestroySelfStanding() {<br/> <br/>     yield return new WaitForSecondsRealtime (4);<br/>     animator.Play ("Die Standing");<br/>
     Destroy (this.gameObject, 4);<br/>     cherryHit = false;<br/>}<br/> <br/>} // End of BeetleNPC.cs</pre>
<p>In order to test this functionality, we will need to have some cherries in our scene. Start by downloading the <kbd>Cherries.unitypackage</kbd> asset package from the publisher's site. This package includes a <kbd>Cherry.prefab</kbd> file that is already set up to work in our game. It has a <kbd>Cherry</kbd> tag and a <kbd>Box Collider</kbd> with <kbd>Is Trigger</kbd> checked.</p>
<p>In <a href="fdacd7a8-63fe-454d-9d50-f9f40070e484.xhtml" target="_blank">Chapter 10</a>, <em>Scripting Our Points System</em>, we will add the ability for the Cucumber Man to throw cherries. For now, let's place a bunch of them in our sandbox for testing. One approach, as illustrated in the following screenshot, is to surround a beetle with cherries. This will make our testing easier and faster:</p>
<div><img height="276" width="427" src="img/8837ae96-dafb-4c65-bb23-9d27fe991f24.png"/></div>
<p>This is a good time to save your scene and your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we focused on the Cucumber Beetles, our game's non-player characters. We reviewed the beetles' 11 animations and made changes to the non-player characters' animation controller. In addition, we wrote scripts to control the non-player characters. Our scripts resulted in several beetle behaviors: patrolling, cucumber consumption, fighting on the ground, and, when hit by a cherry, standing, running, and attacking on hind legs. We also added cucumber patches, cucumbers, and cherries to our game world.</p>
<p>In <a href="6e2e628c-4c81-4ec3-bd4f-2ae0f2a29aab.xhtml">Chapter 9</a>, <em>Adding a Heads-Up Display</em>, we will design, develop, and incorporate a <strong>Heads-Up Display</strong> (<strong>HUD</strong>) in our game. We will create text and graphics that provide visual indicators of points, health, and additional information to help the player maintain situational awareness during gameplay.</p>


            

            
        
    </body></html>