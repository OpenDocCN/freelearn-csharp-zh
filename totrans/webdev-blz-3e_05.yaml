- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Advanced Blazor Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned all the basics of creating a component. This
    chapter will teach us how to take our components to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on some of the features that will make our components
    reusable, which will enable us to save time and also give us an understanding
    of how to use reusable components made by others.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at some built-in components that will help you by adding additional
    functionality (compared to using HTML tags) when you build your Blazor app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions and EventCallback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RenderFragment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the new built-in components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start building our components. For this, you’ll need
    the code we developed in *Chapter 4*, *Understanding Basic Blazor Components*.
    You are good to go if you have followed the instructions in the previous chapters.
    If not, then make sure you clone/download the repository. The starting point for
    this chapter can be found in the `chapter04` folder, and the finished `chapter`
    is in `chapter05`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building applications, data is important, and we can use binding to show
    or change data. By using binding, you can connect variables within a component
    (so that it updates automatically) or by setting a component attribute. Perhaps
    the most fantastic thing is that by using binding, Blazor understands when it
    should update the UI and the variable (if the data changes in the UI).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Blazor, there are two different ways that we can bind values to components,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One-way binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-way binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using binding, we can send information between components and make sure we
    can update a value when we want to.
  prefs: []
  type: TYPE_NORMAL
- en: One-way binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already discussed one-way binding in *Chapter 4*, *Creating Basic Blazor
    Components*. Let’s look at the component again and continue building on it in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will combine parameters and binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Counter.razor` example looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The component will show the current count and a button that will increment the
    current count. This is one-way binding. Even though the button can change the
    value of `currentCount`, it only flows in one direction to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Since this part is designed to demonstrate the functionality and theory and
    is not part of the finished project we are building, you don’t have to write or
    run this code. The source code for these components is available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a parameter to the `Counter` component. The code will then look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code sample has two parameters, one for `CurrentCount` and one for `IncrementAmount`.
    By adding parameters to the components, we can change their behavior. This sample
    is, of course, a bit silly. The chances are that you won’t have any use for a
    component like this that just counts up when pressing a button. But it illustrates
    the idea very well.
  prefs: []
  type: TYPE_NORMAL
- en: We can now take the component and add it to another component. This is how we
    can create a reusable component and change its behavior by changing the value
    of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change its behavior like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, we have two variables, `incrementamount` and `currentcount`,
    that we pass into our `CounterWithParameter` component.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to run this, we would see a `Counter` component that counts in increments
    of `10`. However, the `currentcount` variable will not be updated since it is
    only a one-way binding (one direction).
  prefs: []
  type: TYPE_NORMAL
- en: To help us with that, we can implement two-way binding so that our parent component
    will be notified of any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Two-way binding** binds values in both directions, and our `Counter` component
    will be able to notify our parent component of any changes. In the next chapter,
    *Chapter 6*, *Building Forms with Validation*, we will talk even more about two-way
    binding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `CounterWithParameter` component bind in two directions, we need
    to add an `EventCallback`. The name must consist of the parameter’s name followed
    by `Changed`. This way, Blazor will update the value if it changes. In our case,
    we would need to name it `CurrentCountChanged`. The code would then look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By merely using that naming convention, Blazor knows that `CurrentCountChanged`
    is the event that will get triggered when a change to `CurrentCount` occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '`EventCallback` cannot be `null`, so there is no reason to do a null check
    (more on that in the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change how we listen for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add `@bind-` before the `CurrentCount` binding. You can also use
    the following syntax to set the name of the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By using `:event`, we can tell Blazor exactly what event we want to use; in
    this case, the `CurrentCountChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 6*, *Building Forms with Validation*, we will
    continue to look at binding with input/form components.
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, also create events using **EventCallback**.
  prefs: []
  type: TYPE_NORMAL
- en: Actions and EventCallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To communicate changes, we can use **EventCallback**, as shown in the *Two-way
    binding* section. `EventCallback<T>` differs a bit from what we might be used
    to in .NET. `EventCallback<T>` is a class that is specially made for Blazor to
    be able to have the event callback exposed as a parameter for the component.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, in general, you can add multiple listeners to an event (multi-cast),
    but with `EventCallback<T>`, you will only be able to add one listener (single-cast).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that you can use events the way you are used to from
    .NET in Blazor. However, you probably want to use `EventCallback<T>` because there
    are many upsides to using `EventCallback` over traditional .NET events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET events use classes, and `EventCallback` uses structs. This means that in
    Blazor, we don’t have to perform a null check before calling `EventCallback` because
    a struct cannot be null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventCallback` is asynchronous and can be awaited. When `EventCallback` has
    been called, Blazor will automatically execute `StateHasChanged` on the consuming
    component to ensure the component updates (if it needs to be updated).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if you require multiple listeners, you can use `Action<T>`. Otherwise, it
    would be best if you used `EventCallback<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Some event types have event arguments that we can access. They are optional,
    so you don’t need to add them in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add them by specifying them in a method, or you can use a lambda expression
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the `button` is clicked, it will set a variable called `message` to a string
    containing the mouse coordinates. The lambda has one parameter, `e`, of the `MouseArgs`
    type. However, you don’t have to specify the type, and the compiler understands
    what type the parameter is.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added actions and used **EventCallback** to communicate changes,
    we will see how we can execute **RenderFragment** in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using RenderFragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our components even more reusable, we can supply them with a piece of
    Razor syntax. In Blazor, you can specify **RenderFragment**, which is a fragment
    of Razor syntax that you can execute and show.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of render elements, `RenderFragment` and `RenderFragment<T>`.
    `RenderFragment` is simply a Razor fragment without any input parameters, and
    `RenderFragment<T>` has an input parameter that you can use inside the Razor fragment
    code by using the `context` keyword. We won’t go into depth about how to use this
    now, but later in this chapter, we will talk about a component (**Virtualize**)
    that uses `RenderFragment<T>`, and in the next chapter, *Chapter 6*, *Building
    Forms with Validation*, we will implement a component using `RenderFragment<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: We can make `RenderFragment` the default content inside of the component tags
    as well as giving it a default value. We will explore this next and build a component
    using these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using components in a list, it can add some overhead. It needs to execute
    the whole lifetime cycle for each component. Here is where render fragments come
    to the rescue. We can create a method that returns a render fragment without the
    overhead of a component. Take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have a component with a method that returns a render fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The method could be static if we needed to use it in other components as well.
    When doing a loop like this, it will boost performance and will have a lower impact
    on memory consumption compared to having a component reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**GRID COMPONENT**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dig deeper into render fragments, please check out **Blazm.Components**,
    which have a grid component that heavily uses `RenderFragment<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it on GitHub here: [https://github.com/EngstromJimmy/Blazm.Components](https://github.com/EngstromJimmy/Blazm.Components).'
  prefs: []
  type: TYPE_NORMAL
- en: ChildContent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By naming the render fragment `ChildContent`, Blazor will automatically use
    whatever is between the component tags as content. This only works, however, if
    you are using a single render fragment; if you are using more than one, you will
    have to specify the `ChildComponent` tag as well. We will build a component using
    a `childcontent` render fragment in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Default value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can supply `RenderFragment` with a default value or set it in code by using
    an `@` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Building an alert component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand how to use render fragments, let’s build an alert component
    that will use render fragments. The built-in templates use Bootstrap, so we will
    do the same for this component. Bootstrap has many components that are easy to
    import to Blazor. When working on big projects with multiple developers, building
    components is an easy way to ensure that everyone in a team is writing code the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build a simple alert component based on Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder by right-clicking on `SharedComponents project`| **Add** | **New
    folder** and name the folder `ReusableComponents`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Razor component and name it `Alert.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content with the following code in the `Alert.razor` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code is taken from Bootstrap’s web page, [http://getbootstrap.com](http://getbootstrap.com),
    and it shows an alert that looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The default look of a Bootstrap alert component ](img/B21849_05_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.1: The default look of a Bootstrap alert component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are two ways in which we could customize this `alert` component. We could
    add a `string` parameter for the message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, since this is a section on render fragments, we will explore the second
    option – yes, you guessed it, *render fragments*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a code section with a `RenderFragment` property called `ChildContent` and
    replace the alert text with the new property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have a `RenderFragment` and set a default value, displaying the fragment
    between the `div` tags. We also want to add an `enum` for the different ways you
    can style the alert box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `code` section, add an `enum` containing the different styles available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a parameter/property for the `enum` style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to update the `class` attribute for `div`. Change the `class`
    attribute to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `SharedComponents` project, in the `Pages` folder, create a new razor
    component and name it `AlertTest.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code with the following snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The page shows three alert components:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first one has the `Danger` style, and we are not specifying what property
    to set for the `This is a test` text, but by convention, it will use the property
    called `ChildContent`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the second one, we have specified the `ChildContent` property. If you use
    more render fragments in your component, you must set them like this, with full
    names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the last one, we didn’t specify anything that will give the property the
    default render fragment we specified in the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the `BlazorServer` project and navigate to `/AlertTest` to see the test
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Screenshot of the test page'
  prefs: []
  type: TYPE_NORMAL
- en: We have finished our first reusable component!
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable components is how I prefer to make my Blazor sites because
    I don’t have to write the same code twice. This becomes even more apparent if
    you are working in a larger team. It makes it easier for all developers to produce
    the same code and end result, and with that, they can get a higher code quality
    and require fewer tests.
  prefs: []
  type: TYPE_NORMAL
- en: When we upgraded to the latest Bootstrap version, a few CSS classes were deprecated
    and replaced by others. Thankfully, we followed this approach by making reusable
    components, so we only had to change a handful of places. There were a couple
    of places where we still had some old code base (not using components), and it
    became very apparent that creating components was worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor has a bunch of built-in components. In the next section, we will dig
    deeper into what they are and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to reusable components, we really invest some time in that. If
    you find yourself writing the same code twice, you might want to add that into
    a component. At my old job, we started using `Radzen`, an open-source component
    library (among other things). At my current job, we use `MudBlazor`. We use `Progress
    Telerik` on our stream. Using third-party components can speed up the development,
    but often, these components are built for many different users. They can do a
    lot of things. This means that every single developer on our team now has access
    to all that power. With great power comes great responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: In one of my presentations, I had that quote with a picture of Batman and text
    saying “Superman.” I didn’t get a single reaction. I have never failed with a
    joke like that. But joking aside, this means that all developers need to keep
    in mind how to use the components. Otherwise, the UI might look different depending
    on which developer uses the components. I put a lot of time into designing reusable
    components that help the team to be productive. Hiding the parameters we don’t
    use, giving the components reasonable default values. So, even if you use third-party
    components, try to figure out what you are using and perhaps create an abstraction
    on top of the third-party components. If you don’t know, the quote is from Spiderman,
    or Uncle Ben, to be precise. But it did remind me of one of my favorite puns.
    Do you know why Spiderman always has such witty comebacks? Because with great
    power comes great response-ability. I will show myself out.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the new built-in components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Blazor first came out, there were a couple of things that were hard to
    do, and, in some cases, we needed to involve JavaScript to solve the challenge.
    In this section, we will look at some of the new components we got in .NET 5,
    all the way to .NET 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at the following new components or functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the focus of the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Influencing the HTML head
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the focus of the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of my first Blazor blog posts was about how to set the focus on a UI element,
    but now this is built into the framework. The previous solution involved JavaScript
    calls to change the focus on a UI element.
  prefs: []
  type: TYPE_NORMAL
- en: By using `ElementReference`, you can now set the focus on the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build a component to test the behavior of this new feature:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `Pages` folder, add a new Razor component,
    and name it `SetFocus.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `SetFocus.razor` and add a `page` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an element reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ElementReference` is precisely what it sounds like, a reference to an element.
    In this case, it is an input textbox.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `_Imports` file, add the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the textbox and a button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `@ref`, we specify a reference to any type of component or tag that we
    can use to access the input box. The `button onclick` method will execute the
    `FocusAsync()` method and set the focus on the textbox.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *F5* to run the project and then navigate to `/setfocus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Set focus** button and notice how the textbox gets its focus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It could seem like a silly example since this only sets the focus, but it is
    a handy feature, and the `autofocus` HTML attribute won’t work for Blazor. It
    would make more sense to call `FocusAsync` in the `OnAfterRender` method to get
    the focus change when we load the page, but that wouldn’t make it as cool a demo.
  prefs: []
  type: TYPE_NORMAL
- en: In my blog post, I had another approach. My goal was to set the focus of an
    element without having to use code. In the upcoming chapter, *Chapter 6*, *Building
    Forms with Validation*, we will implement the `autofocus` feature from my blog
    post but use the new .NET features instead.
  prefs: []
  type: TYPE_NORMAL
- en: The release of .NET 5 solves many things we previously had to write with JavaScript;
    setting the focus is one example. In .NET 6, we have a way to influence the HTML
    head.
  prefs: []
  type: TYPE_NORMAL
- en: Influencing the HTML head
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we want to set our page’s title or change the social network meta
    tags. The `head` tag is located in the `App` component, and that part of the page
    isn’t reloaded/rerendered (only the components within the routes component are
    rerendered). In previous versions of Blazor, you had to write code for that yourself
    using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: But .NET has a new component called `HeadOutlet` that can solve that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these components, we will create a page to view one of our blog posts.
    And we will use many of the techniques we have learned:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, open `Home.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `foreach` loop to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a link to the title to look at one blog post. Notice how we can use
    the `@` symbol inside the `href` attribute to get the ID of the post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the Pages folder, add a Razor component, and name it `Post.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `code` section, add a parameter that will hold the ID of the post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will hold the ID of the blog post that comes from the URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `page` directive to get the set, the URL, and the ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `page` directive will set the URL for our blog post to `/post/`, followed
    by the ID of the post. We don’t have to add a `using` statement to all our components.
    Instead, open `_Imports.razor` and add the following namespaces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will ensure that all our components will have these namespaces by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `Post.razor` again and, just beneath the `page` directive, inject the
    API (the namespace is now supplied from `_Imports.razor`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our API will now be injected into the component, and we can retrieve our blog
    post. We also have access to a navigation manager.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `code` section, add a property for our blog post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will contain the blog post we want to show on the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To load the blog post, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we are using the `OnParametersSetAsync()` method. This is to make
    sure that the parameter is set when we get data from the database and that the
    content updates when the parameter changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must also show the post and add the necessary `meta` tags. To do that, add
    the following code just above the `code` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the page is first loaded, the `BlogPost` parameter can be null, so we first
    need to check whether we should show the content at all.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By adding the `Title` component, Blazor will set the title of our site to, in
    this instance, the title of our blog post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: According to the information I gathered on **Search Engine Optimization** (**SEO**),
    the meta tags we have added are the bare minimum to use with Facebook and X (formerly
    known as Twitter). We don’t have an image for each blog post, but we can have
    one that is site-wide (for all blog posts) if we would like. Just change `Pathtoanimage.png`
    to the name of the image and put the image in the `wwwroot` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the blog post is loaded, then show an `H3` tag with the title and the text
    beneath that. You might remember `MarkupString` from *Chapter 4*, *Understanding
    Basic Blazor Components*. This will output the string from our blog post without
    changing the HTML (not escaping the HTML).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the project by pressing *F5* and navigate to a blog post to see the title
    change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Blog post screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: Our blog is starting to take form. We have a list of blog posts, and can view
    a single post; we are far from done but we’re well on our way.
  prefs: []
  type: TYPE_NORMAL
- en: Component virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Virtualize** is a component in Blazor that will make sure that it only renders
    the components or rows that can fit the screen. If you have a large list of items,
    rendering all of them will have a big impact on memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Many third-party component vendors offer grid components with the same virtualization
    function. The `Virtualize` component was, in my opinion, the most exciting thing
    in the .NET 5 release.
  prefs: []
  type: TYPE_NORMAL
- en: The `Virtualize` component will calculate how many items can fit on the screen
    (based on the size of the window and the height of an item). Blazor will add a
    `div` tag before and after the content list if you scroll the page, ensuring that
    the scrollbar is showing the correct position and scale (even though there are
    no items rendered).
  prefs: []
  type: TYPE_NORMAL
- en: The `Virtualize` component works just like a `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code we currently have in our `Home.razor` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Right now, it will show all our blog posts in our database in a long list. Granted,
    we only have a few right now, but we might have many posts one day.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the code (don’t change the code just yet) to use the new `Virtualize`
    component by changing it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the `foreach` loop, we use the `Virtualize` component and add a render
    fragment that shows how each item should be rendered. The `Virtualize` component
    uses `RenderFragment<T>`, which, by default, will send in an item of type `T`
    to the render fragment. In the case of the `Virtualize` component, the object
    will be one blog post (since items are `List<T>` of blog posts). We access each
    post with the variable named `context`. However, we can use the `Context` property
    on the `Virtualize` component to specify another name, so instead of `context`,
    we are now using `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Virtualize` component is even more powerful than this, as we will see
    in the next feature that we implement:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, open `Home.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `OnInitializedAsync` method and `protected List<BlogPost> posts =
    new List<BlogPost>()`; we don’t need them anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the loading of the post to `Virtualize`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we are using the `ItemsProvider` delegate, which will take care
    of getting posts from our API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We pass in a method called `LoadPosts`, which we also need to add to the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s add the `LoadPosts` method by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will add a `totalBlogposts` property where we store how many posts we currently
    have in our database. The `LoadPost` method returns `ValueTask` with `ItemsProviderResult<Blogpost>`.
    The method has `ItemsProviderRequest` as a parameter, which contains the number
    of posts the `Virtualize` component wants and how many it wants to skip.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t know how many total posts we have, we need to retrieve that information
    from our API by calling the `GetBlogPostCountAsync` method. Then, we need to figure
    out how many posts we should get; either we get as many posts as we need, or we
    get all the remaining posts (whatever value is the smallest).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call our API to get the actual posts by calling `GetBlogPostsAsync`
    and returning `ItemsProviderResult`.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented a `Virtualize`component that will load and render only the
    number of blog posts needed to fill the screen. But this is an interactive component
    that needs interactivity to work. If you try to run the project now, you will
    notice that the screen is blank. If we add `@rendermode InteractiveServer` to
    the `Home` component, it starts to work again. Right now, `InteractiveServer`
    is the only thing we can use. This is the only scenario we have everything set
    up for when it comes to DI.
  prefs: []
  type: TYPE_NORMAL
- en: Error boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET 6, we have a very handy component to handle errors called **ErrorBoundary**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can surround the component with an `ErrorBoundary` component; if an error
    occurs, it will show an error message instead of the whole page failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This component takes two render fragments. By specifying it as in the previous
    example, we only set the `ChildContent` render fragment. This is the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also supply a custom error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this sample, we specify `ChildContent`, which makes it possible for us to
    specify more than one property, as is the case with `ErrorContent`. This is a
    great component to extend and create your own functionality. You can get access
    to the exception by using the `context` parameter (as we did with `virtualize`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is a great way to handle errors in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 8 gives us the ability to add sections. You might remember a similar feature
    of `WebForms`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `SectionOutlet` component to define an area in a layout component
    where we want to insert content. Then, inside our components, we can add a `SectionContent`
    where we add the content we want to appear in the outlet.
  prefs: []
  type: TYPE_NORMAL
- en: If we have more than one `SectionContent` referencing the `SectionOutlet`, it
    will render the latest `SectionContent`. We can refer to a `SectionOutlet` by
    using a section name or a section ID. A section name is simply a string that we
    can use. The ID is an object, so we can get a nicer syntax to keep track of our
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: We can add a section to the layout file and add content to that section from
    our components. It’s a layout thing. Let’s say we want to add contextual menus.
    For example, that way, we could change a menu that is in a completely different
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we might need to add this namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Preferably in the _imports.razor file (since this is one of the build-in components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a layout component, we add an outlet like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our component, we can add a `SectionContent` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we instead want to use the section ID, we can do it like this: In the layout
    file, let’s assume it is called `MainLayout`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code section of `MainLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the component, we change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is a great way to change the layout files. By doing this, we can create
    more advanced layouts that work with every page/component. We can move more of
    the layout to the layout file instead of putting it in each component. I love
    this feature. This will clean up so much code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at more advanced scenarios for building components.
    Building components is what Blazor is all about. Components also make it easy
    to make changes along the way because there is only one point where you must implement
    the change. We also implemented our first reusable component, which will help
    maintain the same standard across the team and reduce duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: We also used some Blazor features to load and display data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at forms and validation to start building
    the administration part of our blog.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2668029180838459906.png)'
  prefs: []
  type: TYPE_IMG
