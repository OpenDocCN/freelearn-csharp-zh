["```cs\npublic class Application\n{\n    static void Main(string[] args)\n    {\n        UIApplication.Main(args, null, \"AppDelegate\");\n    }\n}\n\n[Register(\"AppDelegate\")]\npublic partial class AppDelegate : UIApplicationDelegate\n{\n    //Implement required methods\n}\n```", "```cs\npublic class DisposableFinalizableClass : IDisposable\n{\n\n    private ManagedResource m_Resource; // reference to a resource\n\n    public DisposableFinalizableClass()\n    {\n        m_Resource = new ManagedResource(); // allocates the resource\n    }\n\n    /// <summary>\n    /// Destructor for the DisposableFinalizableClass\n    /// <remarks>\n    /// Note that we are not overriding the object.Finalize method\n    /// but providing a destructor for the Finalize method to call\n    /// </remarks>\n    /// </summary>\n    ~DisposableFinalizableClass()\n    {\n        Dispose(false);\n    }\n\n    /// <summary>\n    /// Implementing the Dispose method\n    /// </summary>\n    public void Dispose()\n    {\n        Dispose(true);\n\n        // Letting the GC know that there is no more need for\n        // Finalization, the resources are already cleaned-up\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (disposing)\n        {\n            if (m_Resource != null) m_Resource.Dispose();\n        }\n        else\n        {\n            // Called from Finalize\n            // Clean-up any unmanaged resources\n        }\n    }\n}\n```", "```cs\npublic event EventHandler<int> CalculationCompleted;\n\npublic event EventHandler<List<int>> RangeCalculationCompleted;\n\n/// <summary>\n/// Calculates n-th number in Fibonacci sequence\n/// </summary>\n/// <param name=\"ordinal\">Ordinal of the number to calculate</param>\npublic void GetFibonacciNumberAsync(int ordinal)\n{\n    var task = Task.Run(() =>\n    {\n        var result = GetFibonacciNumberInternal(ordinal);\n        if (CalculationCompleted != null) CalculationCompleted(this, result);\n    });\n\n    // Avoiding Deadlocks on the UI thread\n    task.ConfigureAwait(false);\n}\n\n/// <summary>\n/// Calculates a range of numbers in Fibonnaci sequence\n/// </summary>\n/// <param name=\"firstOrdinal\">Ordinal of the first number</param>\n/// <param name=\"lastOrdinal\">Ordinal of the last number</param>\npublic void GetFibonacciRangeAsync(int firstOrdinal, int lastOrdinal)\n{\n    var task = Task.Run(() =>\n    {\n        var result = GetFibonacciRangeInternal(firstOrdinal, lastOrdinal);\n        if (RangeCalculationCompleted != null) RangeCalculationCompleted(this, result);\n    });\n\n    task.ConfigureAwait(false);\n}\n\npublic static FibonacciSource Instance\n{\n    get \n    { \n        return m_Instance ?? (m_Instance = new FibonacciSource()); \n    }\n}\n```", "```cs\nprivate MvxCommand m_CloseCommand;\n\npublic ICommand CloseCommand\n{\n    get\n    {\n        m_CloseCommand = m_CloseCommand ?? new MvxCommand(DoClose);\n        return m_CloseCommand;\n    }\n}\n\nprivate void DoClose()\n{\n    // FibonacciSource.Instance.RangeCalculationCompleted -= OnCalculationCompleted;\n    Close(this);\n}\n```", "```cs\nprivate Task<List<int>> CalculateFibonacciRangeAsync(int firstOrdinal, int secondOrdinal)\n{\n    TaskCompletionSource<List<int>> taskCompletionSource = new TaskCompletionSource<List<int>>();\n\n    EventHandler<List<int>> calcCompletedEventHandler = null;\n\n    calcCompletedEventHandler =\n        (sender, e) =>\n        {\n            FibonacciSource.Instance.RangeCalculationCompleted -= calcCompletedEventHandler;\n            taskCompletionSource.SetResult(e);\n        };\n\n    FibonacciSource.Instance.RangeCalculationCompleted += calcCompletedEventHandler;\n\n    FibonacciSource.Instance.GetFibonacciRangeAsync(firstOrdinal, secondOrdinal);\n\n    return taskCompletionSource.Task;\n}\n```", "```cs\nprivate void DoCalculate()\n{\n    if (!string.IsNullOrWhiteSpace(Input1) && !string.IsNullOrWhiteSpace(Input2))\n    {\n        int numberOrdinal1, numberOrdinal2;\n\n        if (int.TryParse(Input1, out numberOrdinal1) && int.TryParse(Input2, out numberOrdinal2))\n        {\n            InfoText = \"Calculating\";\n\n            var fibonacciTask = CalculateFibonacciRangeAsync(numberOrdinal1, numberOrdinal2)\n                .ContinueWith(task =>\n                {\n                    Result = string.Join(\",\", task.Result);\n                    InfoText = \"\";\n                });\n\n            fibonacciTask.ConfigureAwait(false);\n\n            return;\n        }\n    }\n\n    InfoText = \"Invalid Input\";\n}\n```", "```cs\npublic class FibonacciItem\n{\n    public int Value { get; private set; }\n\n    private readonly DateTime m_Calculated;\n\n    public FibonacciItem(int value, DateTime calculatedTime)\n    {\n        Value = value;\n\n        m_Calculated = calculatedTime;\n    }\n}\n```", "```cs\npublic class FibonacciCache\n{\n    // Dictionary to contain the cache. \n    private static Dictionary<int, WeakReference> _cache;\n\n    public FibonacciCache()\n    {\n        _cache = new Dictionary<int, WeakReference>();\n    }\n\n    /// <summary>\n    /// Accessor to FibonacciItem references\n    /// </summary>\n    /// <param name=\"ordinal\"></param>\n    /// <returns>FibonacciItem if it is still alive</returns>\n    public FibonacciItem this[int ordinal]\n    {\n        get\n        {\n            if (!_cache.ContainsKey(ordinal)) return null;\n\n            if (_cache[ordinal].IsAlive)\n            {\n                // Object was obtained with the weak reference.\n                FibonacciItem cachedItem = _cache[ordinal].Target as FibonacciItem;\n                return cachedItem;\n            }\n            else\n            {\n                // Object reference is already disposed of   \n                return null;\n            }\n        }\n        set\n        {\n            _cache[ordinal] = new WeakReference(value);\n        }\n    }\n} \n```", "```cs\nprivate void OnFibonacciCalculationCompleted(object sender, List<FibonacciItem> result)\n{\n    RunOnUiThread(() =>\n    {\n        var listView = FindViewById<ListView>(Resource.Id.lstResult);\n\n        listView.Adapter = new ArrayAdapter<string>(this, Resource.Layout.ListViewItem, \n            result.Select(val => val.Value.ToString()).ToArray());\n\n    });\n}\n```", "```cs\npublic class FibonacciResultsAdapter : BaseAdapter<FibonacciItem>\n{\n    List<FibonacciItem> m_ResultItems;\n\n    Activity m_Context;\n\n    public FibonacciResultsAdapter(Activity context, List<FibonacciItem> items)\n    {\n        m_Context = context;\n        m_ResultItems = items;\n    }\n\n    public override long GetItemId(int position) { return position; }\n\n    public override FibonacciItem this[int position]\n    {\n        get { return m_ResultItems[position]; }\n    }\n\n    public override int Count\n    {\n        get { return m_ResultItems.Count; }\n    }\n\n    public override View GetView(int position, View convertView, ViewGroup parent)\n    {\n        View view = convertView;\n\n        if (view == null)\n            view = m_Context.LayoutInflater.Inflate(Resource.Layout.ListViewItem, null);\n\n        view.FindViewById<TextView>(Android.Resource.Id.txtOutput).Text = m_ResultItems[position].Value.ToString();\n\n        return view;\n    }\n}\n```", "```cs\npublic class RetainingParentClass : UIView\n{\n    public RetainingParentClass()\n    {\n\n    }\n}\n\npublic class RetainingChildClass : UIView\n{\n    private RetainingParentClass m_Parent;\n\n    public RetainingChildClass(RetainingParentClass parent)\n    {\n        m_Parent = parent;\n    }\n}\n```", "```cs\nvar parent = new RetainingParentClass();\n\nparent.Add(new RetainingChildClass(parent));\n```", "```cs\npublic class RetainingChildClass : UIView\n{\n    private WeakReference<RetainingParentClass> m_Parent;\n\n    public RetainingChildClass(RetainingParentClass parent)\n    {\n        m_Parent = new WeakReference<RetainingParentClass>(parent);\n    }\n}\n```"]