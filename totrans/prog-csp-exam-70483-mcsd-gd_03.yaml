- en: Understanding Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: 'When we are writing any program, apart from making sure that it serves the
    required purpose, we must make sure that we also take the following aspects into
    consideration:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写任何程序时，除了确保它满足所需的目的外，我们还必须确保考虑以下方面：
- en: '**Code reuse**: We must try to implement the program flow in such a way that
    common functionalities can be used across multiple modules.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用**：我们必须尝试以这种方式实现程序流程，以便可以在多个模块中使用常见的功能。'
- en: '**Code maintenance**: We must accept that any program code that''s written
    is bound to have a few bugs. However, we must ensure that the code that''s written
    is clear and structured enough that it''s understandable and easy to maintain.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码维护**：我们必须接受任何编写的程序代码都难免会有一些错误。然而，我们必须确保编写的代码清晰且结构化，以便易于理解和维护。'
- en: '**Design patterns**: Design patterns allow us to write programs in such a manner
    that there is a common template/structure/functionality that can be used across
    multiple modules. This ensures that the performance of the application is not
    compromised, which is a key aspect of any program application.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模式**：设计模式允许我们以这样的方式编写程序，即存在一个通用的模板/结构/功能，可以在多个模块中使用。这确保了应用程序的性能不会受到影响，这是任何程序应用的关键方面。'
- en: All of these aspects are difficult to achieve in a procedural language. However,
    using object-oriented programming, which is the main essence of any high-level
    programming language, we can achieve the aforementioned objectives.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程语言中实现所有这些方面都是困难的。然而，使用面向对象编程，这是任何高级编程语言的主要本质，我们可以实现上述目标。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding object-oriented programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Understanding encapsulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解封装
- en: Understanding abstraction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象
- en: Understanding inheritance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承
- en: Understanding polymorphism
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多态
- en: We will also go through code examples to understand how these features are implemented
    in a C# application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过代码示例来了解这些特性如何在C#应用程序中实现。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like in the previous chapters in this book, the programs that we will cover
    will be developed in Visual Studio 2017.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书前面的章节，我们将要涵盖的程序将在Visual Studio 2017中开发。
- en: The sample code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples)。
- en: Understanding object-oriented programming
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Object-oriented programming is a programming concept that is based on objects.
    An object is a collection of related data such as fields and procedures, that
    is, methods. For example, an object could be anything right from a very simple
    object such as a pencil to a very complex type such as a car. Each object will
    have its own set of attributes, that is, properties and functions or the methods
    that are implemented in that object. For example, for a car object, the possible
    attributes could be color, registration number, model, and so on. The possible
    functions could be start, stop, and accelerate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种基于对象的编程概念。对象是一组相关数据，如字段和过程，即方法。例如，一个对象可以是任何东西，从非常简单的对象，如铅笔，到非常复杂类型，如汽车。每个对象都将有其自己的属性集，即属性和在该对象中实现的方法或函数。例如，对于汽车对象，可能的属性可以是颜色、注册号、型号等。可能的功能可以是启动、停止和加速。
- en: Before object-oriented programming came into the picture, we did our programming
    under the principles of procedural programming. In a procedural language, an application
    was divided into a set of functions. The data that was used in the program was
    stored in a bunch of local variables that were used by the functions. It formed
    the basis of legacy programming languages such as COBOL and BASIC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程出现之前，我们根据过程编程的原则进行编程。在过程语言中，应用程序被划分为一系列函数。程序中使用的数据存储在一组局部变量中，这些变量被函数使用。这构成了像COBOL和BASIC这样的传统编程语言的基础。
- en: 'The main disadvantages of this programming concept were as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程概念的主要缺点如下：
- en: '**No code reuse**: As the entire application was divided into a set of sequential
    functions, there was no code reuse in this programming concept.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有代码重用**：由于整个应用程序被划分为一系列顺序函数，在这个编程概念中没有代码重用。'
- en: '**Maintenance and scalability**: The following diagram is just an indicative
    flow of how a typical program written in a procedural language will run. In the
    program, the blocks indicate the different code functions, which are interlinked
    and interacting with each other to complete a task:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护和可扩展性**：以下图表只是展示了用过程式语言编写的典型程序运行方式的示意流程。在程序中，块表示不同的代码函数，它们相互连接并相互作用以完成任务：'
- en: '![](img/1b84d311-0fdd-43df-b4df-6905b35c7bfd.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b84d311-0fdd-43df-b4df-6905b35c7bfd.png)'
- en: Here, as in any typical program written on procedural language, there would
    be a bunch of functions, passing around parameters and executing them in a conceptual
    manner. So, any change or upgrade that's made to any one of these functions will
    have a good chance of causing issues in the execution of another function. Therefore,
    from both the standpoint of maintenance and scalability, an application that's
    written in a procedural language will have its challenges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像在用过程式语言编写的任何典型程序中一样，会有许多函数，它们传递参数并以概念方式执行。因此，对其中任何一个函数所做的任何更改或升级都有很大可能导致另一个函数的执行出现问题。因此，从维护和可扩展性的角度来看，用过程式语言编写的应用程序将面临挑战。
- en: 'In object-oriented programming, each application can be divided into a bunch
    of objects that have their own properties and procedures. For example, let''s
    consider the same car scenario we explored in the previous chapter. A car can
    have the following properties and methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，每个应用程序都可以划分为具有自己属性和过程的多个对象。例如，让我们考虑我们在上一章中探讨的相同汽车场景。一辆车可以有以下属性和方法：
- en: '![](img/221913d4-2396-466f-94d7-4e171a6659fc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/221913d4-2396-466f-94d7-4e171a6659fc.png)'
- en: Now, what we can do in an object-oriented programming language is directly declare
    a `car` object, set the values related to the properties, and call the corresponding
    properties, such as start.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在面向对象编程语言中，我们可以直接声明一个`car`对象，设置与属性相关的值，并调用相应的属性，例如启动。
- en: Since the object is grouped with the corresponding properties, we don't need
    to pass any data for the respective properties. Instead, while executing the respective
    functions such as `start`, `stop`, or `accelerate`, we can then pass data against
    these properties as a function parameter list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象与相应的属性分组，我们不需要为相应的属性传递任何数据。相反，在执行`start`、`stop`或`accelerate`等相应函数时，我们可以将这些属性作为函数参数列表传递数据。
- en: Thus, in this case, if, in the future, we change the `start()` function of the
    `car` class, we won't need to bother all the other places that it's getting called
    from.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，如果我们未来更改`car`类的`start()`函数，我们就不需要麻烦所有其他调用它的地方。
- en: This is a major upgrade in terms of the maintainability and scalability of the
    application compared to the standard way of doing things in a procedural language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与在过程式语言中按标准方式做事相比，这在应用的可维护性和可扩展性方面是一个重大升级。
- en: Now, let's deep dive into each of the four pillars of an object-oriented language
    and understand how we can use them in our C# applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨面向对象语言的四个支柱，并了解我们如何在C#应用程序中使用它们。
- en: Understanding encapsulation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解封装
- en: Encapsulation basically involves grouping all the related properties and methods
    that access them in an object. Whenever an application is being designed, we need
    to decide how many objects should be defined in it, along with the associated
    attributes and methods available in it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 封装基本上涉及将所有相关的属性和方法以及访问它们的方式组合在一个对象中。在应用程序设计时，我们需要决定在其中定义多少个对象，以及它所拥有的相关属性和方法。
- en: 'For instance, in the car example, we have the following associated attributes
    and methods:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在汽车示例中，我们有以下相关属性和方法：
- en: '`car` is an object.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car`是一个对象。'
- en: The `make`, `model`, and `color` are the different attributes that are present
    in the object.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make`、`model`和`color`是对象中存在的不同属性。'
- en: '`start`, `stop`, and `accelerate` are the different methods that are present
    in the object.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`、`stop`和`accelerate`是对象中存在的不同方法。'
- en: 'Encapsulation allows us to achieve the following functionality in any application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 封装使我们能够在任何应用程序中实现以下功能：
- en: '**Security**: Using encapsulation, we can define our attributes in such a way
    that not all of the attributes of an object are exposed to the entire application.
    In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding Classes,
    Structures, and Interfaces,* we used access modifiers to control the security
    access of any property/method in the class/in the namespace/in the assembly, as
    well as in the entire application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：使用封装，我们可以以这种方式定义我们的属性，即不是所有对象的属性都暴露给整个应用程序。在[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)《理解类、结构和接口》中，我们使用了访问修饰符来控制类/命名空间/程序集以及整个应用程序中任何属性/方法的访问安全性。'
- en: '**Code maintenance**: From a maintenance perspective of a function, it''s always
    desirable that the function has as few attributes as possible.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码维护**：从函数的维护角度来看，总是希望函数具有尽可能少的属性。'
- en: Using encapsulation, we can organize the required parameters of a function as
    an attribute of the class and thus we are not passing them explicitly in every
    call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用封装，我们可以将函数所需的参数组织为类的属性，因此我们不需要在每次调用中明确传递它们。
- en: In the following code example, we will go through a code sample in C# and understand
    how this can be achieved.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将通过C#代码示例来了解如何实现这一点。
- en: Code example
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Let's consider an example of a banking application. In this banking application,
    we need to implement a scenario related to opening an account.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个银行应用程序的例子。在这个银行应用程序中，我们需要实现一个与开户相关的场景。
- en: 'From a class implementation perspective, the following are the possible attributes
    that should be in the `Account` class. Please also note that there will be an
    additional class, `Customer`, to signify the person who is opening the account:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从类实现的角度来看，以下是在`Account`类中应该存在的可能属性。请注意，还将有一个额外的类`Customer`，以表示开设账户的人：
- en: '`openingDate`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openingDate`'
- en: '`customer`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer`'
- en: '`float currentBalance`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float currentBalance`'
- en: 'The following are some of the methods that could be present in the `Account`
    class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Account`类中可能存在的一些方法：
- en: '`bool OpenAccount();`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool OpenAccount();`'
- en: '`bool depositMoney(float deposit);`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool depositMoney(float deposit);`'
- en: '`bool withdrawMoney(float withdrawalAmt);`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool withdrawMoney(float withdrawalAmt);`'
- en: 'In regard to the `Customer` class, we will just go simple now and define the
    following attributes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Customer`类，我们现在将保持简单，并定义以下属性：
- en: '`string name`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string name`'
- en: '`string customerId`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string customerId`'
- en: Please refer to the following code for the declaration of the `Customer` class
    in a C# program. Here, we have created a `Customer` class and defined two attributes
    in it, that is, the name of the customer and a field of `CustomerID`, which will
    be a unique field for that customer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下代码，了解C#程序中`Customer`类的声明。在这里，我们创建了一个`Customer`类，并在其中定义了两个属性，即客户的姓名和一个`CustomerID`字段，这将为客户提供一个唯一的字段。
- en: 'In the following code, we will declare two variables and use them to showcase
    examples for the operators we mentioned previously:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将声明两个变量，并使用它们来展示我们之前提到的运算符的示例：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Please refer to the following code for the declaration of the `Account` class
    in a C# program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下代码，了解C#程序中`Account`类的声明：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are some of the key items in the implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现中的关键项目：
- en: In the `Account` class, note that `currentBalance` is marked as private, as
    a customer may not want their balance to be exposed to the entire application.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Account`类中，请注意`currentBalance`被标记为私有，因为客户可能不希望他们的余额暴露给整个应用程序。
- en: In the `Account` class, in the methods of `OpenAccount`, `DepositMoney`, and
    `WithdrawMoney`, we are not passing all of the attributes related to the customer,
    current balance, or opening date. This is because the required attributes are
    already grouped together in the `Account` class.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Account`类中，在`OpenAccount`、`DepositMoney`和`WithdrawMoney`这些方法中，我们没有传递与客户、当前余额或开户日期相关的所有属性。这是因为所需的属性已经在`Account`类中分组在一起。
- en: 'Now, let''s look at how we will invoke these classes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们将如何调用这些类：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you look at the function calling part, you will understand that because the
    properties are linked to the `Account` class, we are not passing them explicitly
    to the functions. Therefore, if the implementation of the functions is changed,
    from a maintenance perspective, there will be minimal impact.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看函数调用部分，你会理解，因为属性与`Account`类相关联，所以我们没有明确地将它们传递给函数。因此，如果函数的实现发生变化，从维护的角度来看，影响将会最小。
- en: Therefore, it's always beneficial to use the principles of encapsulation and
    divide the application into chunks of classes with the related information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，始终使用封装原则并将应用程序划分为包含相关信息的类块是有益的。
- en: Understanding abstraction
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象
- en: Abstraction is also a concept in object-oriented programming and implies that,
    when we write code, we should hide the complexity and details of the implementation
    from the outside world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象也是面向对象编程中的一个概念，意味着当我们编写代码时，我们应该隐藏实现的外部复杂性和细节。
- en: In other words, when we write a program that, on receiving an input, does a
    bunch of complex operations and returns an output, we should hide the inner complexity
    of the operations that are done inside the program so that the outer applications
    can just focus on the input they are sending to the application and the output
    that they are getting from it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们编写一个程序，在接收输入后执行一系列复杂操作并返回输出时，我们应该隐藏程序内部操作的内层复杂性，以便外部应用程序只需关注它们发送给应用程序的输入以及从应用程序获得的输出。
- en: 'For example, let''s consider the same example of `Account` that we worked on
    in the previous example. If we consider the example of the `OpenAccount` function,
    you will understand that opening an account for the customer will not be that
    simple. There will be several subtasks that need to be executed before we can
    finally open the account for the customer. For example, some of the steps could
    be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑我们在上一个示例中处理过的相同的`Account`示例。如果我们考虑`OpenAccount`函数的示例，你会理解为客户开设账户不会那么简单。在我们最终为客户开设账户之前，需要执行几个子任务。例如，以下是一些可能的步骤：
- en: Verifying the identification documents of the customer
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核实客户的身份证明文件
- en: Linking and opening different bank accounts, which could be `Salary`, `Current`,
    and `Savings`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接和开设不同的银行账户，这些可能是`Salary`、`Current`和`Savings`
- en: Fetching, that is, counting the initial amount deposit of the customer
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取，即计算客户的初始存款金额
- en: 'Basically, in real life, the function that we have written above will look
    more similar to the following code snippet. In `OpenAccount`, we are passing a
    `Customer` object. Before creating the bank account of the customer, we are doing
    three distinct tasks:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在现实生活中，我们上面所写的函数将看起来更接近以下代码片段。在`OpenAccount`函数中，我们传递了一个`Customer`对象。在为客户创建银行账户之前，我们执行了三个不同的任务：
- en: '`VerifyCustomerIdentity()`: In this function, the idea is to verify the identity
    of the customer, which is a common practice before an account is opened.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VerifyCustomerIdentity()`: 在这个函数中，我们的想法是验证客户的身份，这是在开设账户之前的一个常见做法。'
- en: '`OpenAndLinkRelatedAccounts()`: In this function, the idea is to open different
    accounts for the same customer, that is, `Savings`, `Current`, and `Salaried`.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OpenAndLinkRelatedAccounts()`: 在这个函数中，我们的想法是为同一客户开设不同的账户，即`Savings`、`Current`和`Salaried`。'
- en: '`RetrieveAndCountDeposit()`: In this function, the idea is to retrieve the
    money the customer intends to save, count it, and finally deposit it in the customer''s
    account:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RetrieveAndCountDeposit()`: 在这个函数中，我们的想法是检索客户打算存入的金额，对其进行计数，并将其最终存入客户的账户：'
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Please note the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下事项：
- en: The three functions, that is, `VerifyCustomerIdentity()`, `OpenAndLinkRelatedAccounts()`,
    and `RetrieveAndCountDeposit()`, all of which have `Private` as the access modifier.
    This will ensure that the complexities in these three functions are not exposed
    to the outside.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个函数，即`VerifyCustomerIdentity()`、`OpenAndLinkRelatedAccounts()`和`RetrieveAndCountDeposit()`，都具有`Private`作为访问修饰符。这将确保这三个函数中的复杂性不会被暴露在外。
- en: These three functions are being internally called in the `OpenAccount` function,
    so the calling application doesn't need to worry about calling these functions
    explicitly.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个函数在`OpenAccount`函数内部被调用，因此调用应用程序不需要担心显式调用这些函数。
- en: Let's say we discover some issues in the internal private function. In this
    case, we can easily make changes in these internal functions without needing to
    worry about the external implementation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们在内部私有函数中发现了某些问题。在这种情况下，我们可以轻松地对这些内部函数进行更改，而无需担心外部实现。
- en: Understanding inheritance
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: If you went through [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, you will already know how
    inheritance helps us in code reuse and reduced maintenance, and that it gives
    us more control of the entire application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)，*理解类、结构和接口*，你将已经知道继承如何帮助我们实现代码重用和减少维护，以及它如何让我们对整个应用程序拥有更多的控制。
- en: We also looked at a few code examples and saw how inheritance works and how
    it's implemented in C#. Now, we will look at some advanced features in inheritance,
    their use, and how they are implemented in C#.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了一些代码示例，了解了继承的工作原理以及它在C#中的实现方式。现在，我们将探讨继承的一些高级特性，它们的使用方法以及如何在C#中实现。
- en: Method overriding
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重写
- en: 'Method overriding is a technique in C# that we can use to invoke the methods
    that are defined in the base class from the classes that are deriving from that
    base class. In method overriding, a derived class implements a function that''s
    declared in the base class with the same signature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重写是C#中的一种技术，我们可以用它来调用从基类派生出来的类中定义的方法。在方法重写中，派生类实现了一个在基类中声明且具有相同签名的函数：
- en: The same name as the function that's declared in the base class
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与基类中声明的函数相同的名称
- en: The same number and type of parameters in the function
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中相同数量和类型的参数
- en: The same return type as the function declared in the base class
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与基类中声明的函数相同的返回类型
- en: 'In C#, method overriding is implemented using the following two methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，方法重写是通过以下两种方法实现的：
- en: '**Virtual methods**: A virtual method is a method in the base class that can
    also be defined or overridden in the derived class as well. Please note that,
    when a method is declared as virtual, it''s optional to define the implementation
    of the method in the base class. In case it''s defined, it becomes even more optional
    for the derived class to override it further. A method is declared as virtual
    using the *virtual* keyword.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚方法**：虚方法是在基类中定义的，也可以在派生类中定义或重写的方法。请注意，当一个方法被声明为虚方法时，在基类中定义该方法的实现是可选的。如果已经定义了，那么派生类进一步重写它的可能性就更加可选了。一个方法通过使用`*virtual*`关键字被声明为虚方法。'
- en: '**Override**: Once a method has been declared as `virtual` or `abstract` in
    the base class, then by using the *override* keyword, the derived class can redefine
    the implementation of the method for its own use. In this section, we will be
    looking at *virtual methods*. In the next section, *Abstract and sealed classes*,
    we will do a deep dive into `abstract` methods.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写**：一旦在基类中将方法声明为`virtual`或`abstract`，那么通过使用`*override*`关键字，派生类可以重新定义方法以供自身使用。在本节中，我们将探讨`*virtual
    methods*`。在下一节`*抽象和密封类*`中，我们将深入探讨`*abstract*`方法。'
- en: 'Let''s look at a code example to understand how method overriding is implemented
    in C#. Let''s assume that we have a base class, `Car`, and two classes, `Ferrari`
    and `Suzuki`, that are inheriting from the `Car` class. For the sake of explanation,
    we will keep things simple by just specifying a default constructor and a common
    `Accelerate` method across the three classes. The following would be the code
    implementation for the same:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来了解方法重写是如何在C#中实现的。假设我们有一个基类`Car`和两个从`Car`类继承的类`Ferrari`和`Suzuki`。为了解释方便，我们将保持简单，只为这三个类指定一个默认构造函数和一个共同的`Accelerate`方法。以下将是相同的代码实现：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s create some objects for these classes by using the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码为这些类创建一些对象：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that in the preceding code, we have created a new object of the `Ferrari`
    class and have assigned it to a variable, `ferrari`, which is of the `Car` type.
    Similarly, we have also created a new object of the `Suzuki` class and have assigned
    it to a variable, `suzuki`, which is also of the `Car` type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述代码中，我们创建了一个`Ferrari`类的新对象，并将其分配给一个类型为`Car`的变量`ferrari`。同样，我们也创建了一个`Suzuki`类的新对象，并将其分配给一个类型为`Car`的变量`suzuki`。
- en: 'When we execute the code, we get the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们得到以下输出：
- en: '![](img/f4182fda-7d40-4c9a-ba21-32094fa5784e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4182fda-7d40-4c9a-ba21-32094fa5784e.png)'
- en: Note that, even though we have the `Accelerate` method in both the parent `Car`
    class and the derived `Ferrari` and `Suzuki` classes, when we are calling the
    `Accelerate` method from the `ferrari` object, it's calling the `Accelerate` method
    that's present in the parent `Car` class. This is due to the fact that the type
    of the variable is `Car` and that, even though it's instantiated with the objects
    of the `Ferrari` and `Suzuki` child classes, the method in the base class has
    not been overridden.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们在父`Car`类和派生的`Ferrari`和`Suzuki`类中都有`Accelerate`方法，但当我们从`ferrari`对象调用`Accelerate`方法时，它调用的是父`Car`类中存在的`Accelerate`方法。这是由于变量的类型是`Car`，尽管它被实例化为`Ferrari`和`Suzuki`子类的对象，但基类中的方法尚未被重写。
- en: 'Now let''s make a slight change to the implementation and declare the method
    in the base class as `virtual` and the methods in the classes deriving from this
    class as `override`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对实现进行轻微的修改，并在基类中将方法声明为`virtual`，将派生自该类的类中的方法声明为`override`：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, execute the same code again and review that we receive the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次执行相同的代码，并回顾我们收到了以下输出：
- en: '![](img/614daa81-9315-476d-9b50-fbbca7659856.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/614daa81-9315-476d-9b50-fbbca7659856.png)'
- en: Note that now, the `Accelerate` method executes the code mentioned in the derived
    classes of `Ferrari` and `Suzuki` and not the code specified in the parent class
    of `Car`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在，`Accelerate`方法执行的是`Ferrari`和`Suzuki`派生类中提到的代码，而不是`Car`父类中指定的代码。
- en: 'Later in this chapter, we will also do a deep dive into polymorphism. There
    are two types of polymorphism: runtime polymorphism and compile-time polymorphism.
    Runtime polymorphism is implemented using method overriding.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们还将深入研究多态。有两种类型的多态：运行时多态和编译时多态。运行时多态是通过方法重写实现的。
- en: In the next section, we will look at `abstract` classes and also explore the
    use of `virtual` methods in `abstract` classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨`abstract`类，并探索在`abstract`类中使用`virtual`方法。
- en: Abstract classes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: An `abstract` class in C# is a class that cannot be instantiated, that is, the
    program execution cannot create an object of this class. Instead, these classes
    can only act as base classes from which other classes can inherit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`abstract`类是一个不能实例化的类，也就是说，程序执行不能创建此类对象。相反，这些类只能作为其他类继承的基类。
- en: 'We use the `abstract` class in scenarios where we specifically want all the
    deriving classes to implement the specific implementation of a particular function
    that''s declared in the base class. The following are some of the properties of
    an `abstract` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在需要所有派生类都实现基类中声明的特定函数的具体实现的情况下使用`abstract`类。以下是一些`abstract`类的属性：
- en: Just like all the other classes, an `abstract` class can have both functions
    and properties.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像所有其他类一样，一个`abstract`类可以同时拥有函数和属性。
- en: An `abstract` class can have both abstract and non-abstract functions.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract`类可以同时拥有抽象和非抽象函数。'
- en: 'Let''s take a look at a program to analyze how `abstract` classes work. We
    will define an `Animal` class using the `abstract` keyword. Now, let''s assume
    that each animal type, such as dog, speaks differently, so they must implement
    the function in their own way. To implement this, we will declare our base `Animal`
    class as `abstract` and have an `abstract` method `Speak` in it. Review that if
    we try to implement the `Speak` method, the compiler throws an error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个程序来分析`abstract`类是如何工作的。我们将使用`abstract`关键字定义一个`Animal`类。现在，假设每种动物类型，如狗，说话的方式都不同，因此它们必须以自己的方式实现该函数。为了实现这一点，我们将我们的基`Animal`类声明为`abstract`，并在其中有一个`abstract`方法`Speak`。回顾一下，如果我们尝试实现`Speak`方法，编译器会抛出一个错误：
- en: '![](img/d648af81-c47b-4e58-8504-52ba481fb632.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d648af81-c47b-4e58-8504-52ba481fb632.png)'
- en: 'To remove this error, we can simply remove the declaration of the `abstract`
    method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除这个错误，我们可以简单地移除`abstract`方法的声明：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s create a `Dog` class that inherits from this base class of `Animal`.
    Note that the compiler will throw an error if the `Speak` method is not implemented:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个继承自这个`Animal`基类的`Dog`类。注意，如果未实现`Speak`方法，编译器将抛出一个错误：
- en: '![](img/33b389c9-5891-4cf7-86af-a23c5d1e2519.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33b389c9-5891-4cf7-86af-a23c5d1e2519.png)'
- en: 'We can get over this error by creating an implementation of the `Speak` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个`Speak`函数的实现来克服这个错误：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Please note that we use the `override` keyword to let the compiler know that
    we are overriding the implementation of the `abstract` function called `Speak`
    in the derived class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`override`关键字让编译器知道我们在派生类中重写了名为`Speak`的`abstract`函数的实现。
- en: In the next section, we will look at the same example and understand how `abstract`
    methods differ from `virtual` methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨相同的例子，并了解`abstract`方法与`virtual`方法的区别。
- en: Abstract versus virtual methods
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象方法与虚拟方法
- en: In the preceding example, we declared the `Speak` method as `abstract`. This
    forced our `Dog` class to provide an implementation of the method because, otherwise,
    we would get a compile-time error. Now, what if we don't want to have that particular
    restriction in our code?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`Speak`方法声明为`abstract`。这迫使我们的`Dog`类提供该方法的一个实现，否则我们会得到一个编译时错误。现在，如果我们不希望在代码中设置这种特定的限制，会怎样呢？
- en: 'We can do this by replacing the `abstract` method with the `virtual` method.
    The following is the changed implementation of the preceding code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`abstract`方法替换为`virtual`方法来实现这一点。以下是前面代码的更改实现：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that when you compile the code, there are no errors. Also, just for the
    sake of experimenting, comment out the `Speak` method in the `Dog` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你编译代码时，没有错误。此外，仅为了实验，请在`Dog`类中注释掉`Speak`方法。
- en: 'Now, compile the program. Note that, unlike the previous case, when we use
    `abstract` methods, no compile-time errors occur:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译程序。请注意，与前面的情况不同，当我们使用`abstract`方法时，不会出现编译时错误：
- en: '![](img/0f314e04-d673-4fd9-8045-82f76c321da4.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f314e04-d673-4fd9-8045-82f76c321da4.png)'
- en: In the next section, we will look at `sealed` classes and how they are implemented
    in C# applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨`sealed`类以及它们如何在C#应用程序中实现。
- en: Sealed classes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密封类
- en: 'A `sealed` class in C# is a class that we do not want to be inherited by any
    derived class. Once we insert the keyword `sealed`, a compiler will give a compile-time
    error if a derived class tries to inherit from the `sealed` class. The following
    is the screenshot of the same. For explanation purposes, we will use the same
    two classes we used in the preceding example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`sealed`类是一个我们不希望任何派生类继承的类。一旦我们插入关键字`sealed`，如果派生类尝试从`sealed`类继承，编译器将给出一个编译时错误。以下是这个截图。为了解释的目的，我们将使用前面例子中使用的相同两个类：
- en: '![](img/dc089c73-eadd-46f1-b15f-ba19c1353c83.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc089c73-eadd-46f1-b15f-ba19c1353c83.png)'
- en: 'Note that `abstract` and `sealed` do not go hand in hand. `abstract` means
    that the class must never be instantiated, whereas the `sealed` class indicates
    that the class must never be inherited. Therefore, in hindsight, if we declare
    a `sealed` class as `abstract`, this will not make any sense. Thus, if we do try
    to declare an `abstract` class as `sealed`, we will get a compile-time error,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`abstract`和`sealed`并不总是相辅相成的。`abstract`意味着该类永远不能被实例化，而`sealed`类表示该类永远不能被继承。因此，从后视镜来看，如果我们将`sealed`类声明为`abstract`，这就没有任何意义了。因此，如果我们尝试将`abstract`类声明为`sealed`，我们将得到一个编译时错误，如下所示：
- en: '![](img/e6492e94-c777-4aa6-8993-c146065b80be.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6492e94-c777-4aa6-8993-c146065b80be.png)'
- en: In the next section, we will look at another pillar of OOP programming, that
    is, *polymorphism*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨面向对象编程的另一个支柱，即*多态性*。
- en: Understanding polymorphism
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多态性
- en: 'Polymorphism is a Greek word whose literal translation to English is *many-shaped*.
    In programming terms, it''s referred to as one interface with multiple functions.
    Let''s try to understand polymorphism by looking at the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是一个希腊词，其字面翻译为*多形态*。在编程术语中，它指的是一个接口具有多个功能。让我们通过以下图表来尝试理解多态性：
- en: '![](img/539317c7-f54a-4233-9dec-c8b89f7cd982.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/539317c7-f54a-4233-9dec-c8b89f7cd982.png)'
- en: 'In the preceding diagram, we have some program code that runs on **Input 1**
    and gives **Output 1**. Now, let''s say we make a mistake and send an incorrect
    input of **Input 2** instead. In this case, unfortunately, the program code may
    error out and send an error message. In such a scenario, we can use polymorphism.
    With polymorphism, the same example will be represented as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们有一些在**输入1**上运行的程序代码，并给出**输出1**。现在，假设我们犯了一个错误，发送了错误的输入**输入2**。在这种情况下，不幸的是，程序代码可能会出错并发送错误消息。在这种情况下，我们可以使用多态性。使用多态性，相同的例子将表示如下：
- en: '![](img/1f794080-5921-49d2-8dbe-d6a8ee4d55b9.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f794080-5921-49d2-8dbe-d6a8ee4d55b9.png)'
- en: As we can see, by using polymorphism, we will maintain three copies of the code
    in memory and depending on the type of input received, the appropriate copy of
    the program code will be loaded and executed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用多态，我们将在内存中维护三份代码副本，并且根据接收到的输入类型，将加载和执行适当的程序代码副本。
- en: 'There are two types of polymorphism possible in C#:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中可能存在两种多态类型：
- en: Static/compile-time polymorphism, that is, method overloading or function overloading
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态/编译时多态，即方法重载或函数重载
- en: Execution time polymorphism, that is, method overriding or virtual functions
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行时间多态，即方法重写或虚函数
- en: Let's go through each of these types and use code examples to understand how
    they work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍这些类型，并使用代码示例来了解它们是如何工作的。
- en: Static/compile-time polymorphism
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态/编译时多态
- en: Static polymorphism, also known as function overloading, involves creating functions
    with the same name but with different numbers or types of parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 静态多态，也称为函数重载，涉及创建具有相同名称但参数数量或类型不同的函数。
- en: 'The compiler loads the appropriate function based on the input that''s passed.
    Let''s go through the following code example to see how it works. Here, we will
    create two copies of a function called `ADD` that will differ in terms of the
    number of parameters accepted by the function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据传入的输入加载适当的函数。让我们通过以下代码示例来了解它是如何工作的。在这里，我们将创建两个名为 `ADD` 的函数副本，这些副本在函数接受的参数数量方面有所不同：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when the call is made to the function, based on the number of parameters
    passed, the respective function will be loaded:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当调用函数时，根据传递的参数数量，将加载相应的函数：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After the program is executed, we will get the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行后，我们将得到以下输出：
- en: '![](img/8f624dda-0863-4caf-acd1-4fb2fddcef50.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f624dda-0863-4caf-acd1-4fb2fddcef50.png)'
- en: 'Now, let''s consider another example. In the preceding example, we implemented
    polymorphism based on the number of parameters. In this example, we will implement
    polymorphism based on the type of parameter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个例子。在前面的例子中，我们根据参数数量实现了多态。在这个例子中，我们将根据参数类型实现多态。
- en: 'Create two classes, one each for `Dog` and `Cat`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个类，一个用于 `Dog`，另一个用于 `Cat`：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create two functions with the same name but one accepting the input of a `Dog`
    object and another accepting the input of a `Cat` object:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个具有相同名称的函数，一个接受 `Dog` 对象的输入，另一个接受 `Cat` 对象的输入：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, when a call is made to the function, based on the type of parameter, the
    appropriate function will be loaded:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当调用函数时，根据参数类型，将加载适当的函数：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the program is executed, it will show the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，它将显示以下输出：
- en: '![](img/c5be0bc9-f734-4255-bb9e-5a05a4fe6bb9.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5be0bc9-f734-4255-bb9e-5a05a4fe6bb9.png)'
- en: Runtime polymorphism
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时多态
- en: Runtime polymorphism in C# is executed via virtual methods. In this type of
    polymorphism, the compiler executes the code by identifying its form at runtime.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的运行时多态通过虚方法执行。在这种多态中，编译器通过在运行时识别其形式来执行代码。
- en: In the *Method overriding* section, we learned about virtual methods and saw
    how they allow the derived class to override the implementation of a function
    in the base class. In runtime polymorphism, the object of the base class holds
    the reference to objects of the base and derived classes. Now, based on the object
    that the base object is pointing to, the appropriate function will be loaded.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *方法重写* 部分中，我们学习了虚方法，并看到了它们如何允许派生类覆盖基类中函数的实现。在运行时多态中，基类对象持有基类和派生类对象的引用。现在，根据基对象指向的对象，将加载适当的函数。
- en: To recap our understanding of this, let's go through another code example. In
    this example, we will create a base class called `Animal` that will be inherited
    by two classes, `Man` and `Dog`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们对这一点的理解，让我们通过另一个代码示例。在这个例子中，我们将创建一个名为 `Animal` 的基类，它将被两个类 `Man` 和 `Dog`
    继承。
- en: 'The following is the implementation in the `Animal` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `Animal` 类中的实现：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `Animal` class, we have declared two attributes to represent `numOfHands`
    and `numOfLegs` of the `Animal`. We have also declared a function called `Speak`
    and have marked it as `Virtual` so that any class that inherits from this class
    can give its own implementation of the `Speak` functionality.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Animal` 类中，我们声明了两个属性来表示 `Animal` 的 `numOfHands` 和 `numOfLegs`。我们还声明了一个名为
    `Speak` 的函数，并将其标记为 `Virtual`，以便任何继承此类的类都可以提供自己的 `Speak` 功能实现。
- en: We have declared the `Speak` function as virtual, which means that this function
    can be overridden in the derived class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Speak` 函数声明为虚拟的，这意味着这个函数可以在派生类中被重写。
- en: 'The following is the implementation in the `Dog` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `Dog` 类中的实现：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this implementation, we have created a `Dog` class that is inheriting from
    the `Animal` class. The `Dog` class has an attribute called `Breed` and a constructor
    that takes three parameters of `breed`, `hands`, and `legs`, respectively. We
    also have a `Speak` function to provide an impression of how a dog object will
    implement the `Speak` functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们创建了一个从 `Animal` 类继承的 `Dog` 类。`Dog` 类有一个名为 `Breed` 的属性和一个构造函数，该构造函数分别接受
    `breed`、`hands` 和 `legs` 三个参数。我们还有一个 `Speak` 函数，以提供狗对象如何实现 `Speak` 功能的印象。
- en: 'The following code is for another class, `Human`, which will also inherit from
    the base class of `Animal`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是另一个类 `Human` 的实现，它也将从 `Animal` 的基类继承：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We are inheriting the `Dog` class from the base class of `Animal`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从 `Animal` 的基类继承了 `Dog` 类。
- en: We are overriding the `Speak` function in the derived class.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在派生类中重写了 `Speak` 函数。
- en: We are also using the attributes that were declared in the base class.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在使用基类中声明的属性。
- en: 'Now, let''s see how runtime polymorphism works. In the following code, we are
    declaring an object of the base `Animal` class and pointing it to an object of
    the derived class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看运行时多态是如何工作的。在下面的代码中，我们声明了一个基类 `Animal` 的对象，并将其指向派生类的对象：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we execute this code, we will notice that, based on the class object reference
    that the base object `animal` is pointing to, the appropriate implementation of
    the `Speak` method will be loaded. This loading is decided at runtime, which is
    why this is called **runtime polymorphism**:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行这段代码，我们会注意到，根据基对象 `animal` 指向的类对象引用，将加载适当的 `Speak` 方法实现。这种加载是在运行时决定的，这就是为什么这被称为
    **运行时多态**：
- en: '![](img/cabfb529-154a-4e4d-9014-790e2f078430.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cabfb529-154a-4e4d-9014-790e2f078430.png)'
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about object-oriented programming, which is the
    main essence of any high-level programming language, including C#. We learned
    about the four pillars of OOP, that is, encapsulation, abstraction, polymorphism,
    and inheritance, and understood how they help us write applications that are easy
    to maintain, are scalable, and have a good amount of reuse.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了面向对象编程，这是任何高级编程语言（包括 C#）的主要精髓。我们学习了 OOP 的四个支柱，即封装、抽象、多态和继承，并理解了它们如何帮助我们编写易于维护、可扩展且具有大量重用性的应用程序。
- en: We learned how encapsulation helps us in keeping our code structured by grouping
    together all the related properties and methods in one class. Then, we learned
    how abstraction helps us reduce the complexity of a module that is exposed to
    the entire application. Using abstraction, we can make sure that all the complexities
    of a class are not exposed to outside classes, which also helps us maintain the
    application better. We also learned how we can use both runtime and static polymorphism
    to implement similar functionalities that can be reused across different inputs,
    thus helping us reuse our code throughout the application. Finally, we learned
    how inheritance helps us have more control over the application's implementation.
    Using inheritance, we can make sure that similar classes implement a set of properties
    and methods that are common across them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了封装如何通过将所有相关的属性和方法组合在一个类中来帮助我们保持代码的结构化。然后，我们学习了抽象如何帮助我们简化整个应用程序暴露的模块的复杂性。通过使用抽象，我们可以确保类的所有复杂性都不会暴露给外部类，这也帮助我们更好地维护应用程序。我们还学习了如何使用运行时和静态多态来实现可跨不同输入重用的相似功能，从而帮助我们在整个应用程序中重用代码。最后，我们学习了继承如何帮助我们更好地控制应用程序的实现。使用继承，我们可以确保相似的类实现一套它们共有的属性和方法。
- en: While writing any program in C#, it's highly important that we keep these principles
    in mind. The biggest mistake that some C# programmers make these days is they
    don't utilize these core principles of OOP programming and, instead, the program
    that's written resembles more of a procedural language program. From a maintenance
    perspective, it helps us a lot as, to some extent, it ensures that the bug fixes
    in one module do not impact the complete application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何C#程序时，我们高度重要的是要记住这些原则。一些C#程序员现在犯的最大错误是他们没有利用面向对象编程的核心原则，相反，编写的程序更像是过程性语言程序。从维护的角度来看，这对我们非常有帮助，因为在某种程度上，它确保了一个模块中的错误修复不会影响整个应用程序。
- en: In the next chapter, we will look at the different operators that are used across
    C# programming. We will look at how we can manage program flow using operators
    and different conditional selection statements. We will also look at different
    iteration statements such as for and while loop, which help us control the program's
    flow.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在C#编程中使用的不同运算符。我们将探讨如何使用运算符和不同的条件选择语句来管理程序流程。我们还将探讨不同的迭代语句，如for循环和while循环，这些语句有助于我们控制程序的流程。
- en: Questions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following best describes a program in which we have multiple functions
    with the same name but they differ in terms of the number of parameters and types
    of parameters accepted by them?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项最好地描述了一个具有相同名称但参数数量和类型不同的多个函数的程序？
- en: Method overloading
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法重载
- en: Method overriding
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法覆盖
- en: Encapsulation
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装
- en: Abstraction
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象
- en: Which keyword must be used when a derived class is defining the implementation
    of a function that's present in the base class?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当派生类定义在基类中存在的函数的实现时，必须使用哪个关键字？
- en: New
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新
- en: Abstract
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摘要
- en: Virtual
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟
- en: Override
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖
- en: Which keyword can we use to prevent the inheritance of a particular class?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个关键字来防止特定类的继承？
- en: Abstract
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摘要
- en: Private
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有的
- en: Sealed
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密封
- en: Protected
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受保护的
- en: Answers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Method overloading or function overloading is the concept in which different
    implementations of a function with same name is made. Depending upon the number
    of arguments or type of argument, appropriate implementation of the function is
    loaded.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法重载或函数重载是这样一个概念，即具有相同名称的不同函数实现被创建。根据参数的数量或参数的类型，加载适当的函数实现。
- en: The override keyword allows a derived class to implement the abstract method
    declared in the base class.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖关键字允许派生类实现基类中声明的抽象方法。
- en: Sealed. If a class is declared as sealed, it will prevent the inheritance of
    the base class throughout the application.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密封。如果一个类被声明为密封的，它将防止在整个应用程序中继承基类。
