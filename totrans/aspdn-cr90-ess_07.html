<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-116">
    <a id="_idTextAnchor117">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-117">
    <a id="_idTextAnchor118">
    </a>
    
     Adding Capabilities to Applications
    
   </h1>
   <p>
    
     ASP.NET Core 9 provides different features and tools that enable us to develop powerful web-based solutions.
    
    
     However, we often need more specialized features in order to provide a better end-to-end experience.
    
    
     In this chapter, we will learn good practices related to web applications such as adding caching, using asynchronous mechanisms, resilience mechanisms, and logging.
    
    
     We will explore essential best practices for developing applications with ASP.NET Core 9, covering the correct use of asynchronous mechanisms, HTTP requests, and application instrumentation
    
    
     
      through logs.
     
    
   </p>
   <p>
    
     We will focus on the following topics in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Working with ASP.NET Core 9
     
     
      
       best practices
      
     
    </li>
    <li>
     
      Improving performance with a cache strategy and making the
     
     
      
       application resilient
      
     
    </li>
    <li>
     
      Understanding and implementing logging
     
     
      
       and monitoring
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-118">
    <a id="_idTextAnchor119">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To support the learning of this chapter, the following tools must be present in your
    
    
     
      development environment:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Docker
      
     </strong>
     
      : Docker Engine must be installed on your operating system and have a SQL Server container running.
     
     
      You can find more details about Docker and the SQL Server container in
     
     <a href="B21788_05.xhtml#_idTextAnchor078">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Postman
      
     </strong>
     
      : This tool will be used to execute requests to APIs of the
     
     
      
       developed application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Redis Insight
      
     </strong>
     
      : This tool is used to connect to a Redis Server
     
     
      
       database (
      
     
     <a href="https://redis.io/insight/">
      
       
        https://redis.io/insight/
       
      
     </a>
     
      
       ).
      
     
    </li>
   </ul>
   <p>
    
     The code examples used in this chapter can be found in the book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter07
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-119">
    <a id="_idTextAnchor120">
    </a>
    
     Working with ASP.NET Core 9 best practices
    
   </h1>
   <p>
    
     So far, we have already learned about several features and benefits of ASP.NET Core 9 in creating quality web systems.
    
    
     Of course, just like any other software development technology, there is no restriction on the way we will handle our code.
    
    
     In this way, we have the freedom to create solutions and new standards with the aim of meeting a
    
    
     
      specific need.
     
    
   </p>
   <p>
    
     However, relying on good practices can not only expand our capacity to develop quality applications but also avoid wasting several hours to achieve
    
    
     
      a goal.
     
    
   </p>
   <p>
    
     In this case, we will address some good practices necessary to bring greater quality to our applications, starting with the correct use of
    
    
     <strong class="bold">
      
       HTTP requests
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-120">
    <a id="_idTextAnchor121">
    </a>
    
     HTTP request best practices
    
   </h2>
   <p>
    
     The HTTP request
    
    <a id="_idIndexMarker535">
    </a>
    
     is a fundamental component when working with web
    
    <a id="_idIndexMarker536">
    </a>
    
     applications.
    
    
     Proper handling of HTTP requests can significantly impact the performance and reliability of
    
    
     
      your application.
     
    
   </p>
   <p>
    
     We have already learned about the types of HTTP verbs and status codes in
    
    <a href="B21788_03.xhtml#_idTextAnchor044">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     .
    
    
     However, each HTTP method provided by the application must be treated appropriately, to avoid inconsistencies in the application and
    
    
     
      avoid vulnerabilities.
     
    
   </p>
   <p>
    
     Furthermore, the way HTTP requests are made directly impacts the experience of users or consumers of
    
    
     
      your solution.
     
    
   </p>
   <p>
    
     Let’s understand some good practices related to
    
    
     
      HTTP requests.
     
    
   </p>
   <h3>
    
     Validate and sanitize input
    
   </h3>
   <p>
    
     Always validate and
    
    <a id="_idIndexMarker537">
    </a>
    
     sanitize input to prevent
    
    <a id="_idIndexMarker538">
    </a>
    
     security vulnerabilities such as
    
    <a id="_idIndexMarker539">
    </a>
    
     SQL injection and
    
    <strong class="bold">
     
      cross-site
     
    </strong>
    
     <strong class="bold">
      
       scripting
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       XSS
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p class="callout-heading">
    
     XSS
    
   </p>
   <p class="callout">
    
     XSS is a
    
    <a id="_idIndexMarker540">
    </a>
    
     security vulnerability where the attacker injects scripts into web pages.
    
    
     To know
    
    <a id="_idIndexMarker541">
    </a>
    
     more, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Consider
    
    <a id="_idIndexMarker542">
    </a>
    
     a scenario where a user submits a form with a username.
    
    
     To prevent
    
    <a id="_idIndexMarker543">
    </a>
    
     harmful data from being processed, you
    
    <a id="_idIndexMarker544">
    </a>
    
     should validate the input to ensure it meets the expected criteria and sanitize it to remove any
    
    
     
      malicious content:
     
    
   </p>
   <pre class="source-code">
public IActionResult Submit(string username)
{
    <strong class="bold">if (string.IsNullOrEmpty(username))</strong>
    {
        return BadRequest("Username is required.");
    }
    username = <strong class="bold">HttpUtility.HtmlEncode(username);</strong>
    // Proceed with processing the username
    return Ok();
}</pre>
   <p>
    
     The preceding code demonstrates a simple validation of the username parameter,
    
    <strong class="source-inline">
     
      if(string.IsNullOrEmpty)
     
    </strong>
    
     , avoiding using it incorrectly.
    
    
     The
    
    <strong class="source-inline">
     
      HttpUtility.HtmlEncode(username)
     
    </strong>
    
     method is used to convert characters such as
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      &gt;
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      &amp;
     
    </strong>
    
     , and so on into an
    
    
     
      HTML-encoded format.
     
    
   </p>
   <h3>
    
     Use asynchronous methods
    
   </h3>
   <p>
    
     During the execution flow
    
    <a id="_idIndexMarker545">
    </a>
    
     of an HTTP request, we must avoid making the processing actions synchronous.
    
    
     Otherwise, this could degrade the user experience and cause some problems for the application, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Thread blocking
      
     </strong>
     
      : Synchronous
     
     <a id="_idIndexMarker546">
     </a>
     
      methods block the thread while waiting for I/O operations (such as database queries, file access, or network requests) to complete.
     
     
      In an ASP.NET Core application, the thread pool is a
     
     
      
       limited resource.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Thread pool exhaustion
      
     </strong>
     
      : When an
     
     <a id="_idIndexMarker547">
     </a>
     
      application heavily relies on synchronous methods, the thread pool can become exhausted, especially under high load, which occurs when all available threads are blocked and no new threads are available to handle
     
     
      
       incoming requests.
      
     
    </li>
   </ul>
   <p>
    
     It is a recommendation and good practice to use asynchronous methods to improve performance and scalability.
    
    
     For example, when using the
    
    <strong class="source-inline">
     
      HttpClient
     
    </strong>
    
     object to make a request in an API, use the
    
    <strong class="source-inline">
     
      HttpClient.SendAsync
     
    </strong>
    
     method instead
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       HttpClient.Send
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Asynchronous programming
    
    <a id="_idIndexMarker548">
    </a>
    
     allows your application to handle multiple tasks simultaneously without waiting for each task to complete before starting the next one.
    
    
     This is similar to how a chef in a busy kitchen might prepare multiple dishes at once, rather than finishing one dish before
    
    
     
      starting another.
     
    
   </p>
   <p>
    
     We will cover the use of asynchronous programming in more detail in the
    
    <em class="italic">
     
      Asynchronous requests and I/O optimization
     
    </em>
    
     section.
    
    
     Now, let’s understand another good practice in relation to HTTP requests, regarding caching
    
    
     
      and compression.
     
    
   </p>
   <h3>
    
     Caching and compression
    
   </h3>
   <p>
    
     Requests via
    
    <a id="_idIndexMarker549">
    </a>
    
     the HTTP protocol have some attributes, including headers and body.
    
    
     During communication between an application and the backend, this information is transmitted, and the headers are used both by the client (in this case, the browser) and by
    
    
     
      the backend.
     
    
   </p>
   <p>
    
     There are several types of
    
    <a id="_idIndexMarker550">
    </a>
    
     HTTP headers, including those associated with caching
    
    
     
      and
     
    
    
     <a id="_idIndexMarker551">
     </a>
    
    
     
      compression.
     
    
   </p>
   <p>
    
     By utilizing caching and response compression, we can reduce bandwidth usage and improve load times.
    
    
     Browsers also identify these headers, avoiding unnecessary requests to
    
    
     
      the server.
     
    
   </p>
   <p>
    
     Caching and dating
    
    <a id="_idIndexMarker552">
    </a>
    
     compression
    
    <a id="_idIndexMarker553">
    </a>
    
     work similarly to how a library
    
    <a id="_idIndexMarker554">
    </a>
    
     might
    
    <a id="_idIndexMarker555">
    </a>
    
     keep frequently borrowed books readily accessible or how a vacuum-sealed package takes up less space.
    
    
     These practices reduce the load on your server and speed up responses to
    
    
     
      user requests.
     
    
   </p>
   <p>
    
     Let’s analyze the following code snippet extracted from a
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
// Add services to the container. builder.Services.AddResponseCaching();
<strong class="bold">app.UseResponseCaching();</strong>
<strong class="bold">app.Use(async (context, next)</strong> =&gt; {
  context.Response.GetTypedHeaders().CacheControl =
    new Microsoft.Net.Http.Headers.CacheControlHeaderValue
    {
      Public = true, MaxAge = TimeSpan.FromMinutes(10)
    };
    await next();
});</pre>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker556">
    </a>
    
     understand the preceding code.
    
    
     When you add
    
    <strong class="source-inline">
     
      app.UseResponseCaching
     
    </strong>
    
     to the application’s
    
    <strong class="bold">
     
      middleware
     
    </strong>
    
     pipeline, it performs the
    
    
     
      following functions:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Checks for
      
     </strong>
     
      <strong class="bold">
       
        Cache-Control headers
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        The middleware
       
       <a id="_idIndexMarker557">
       </a>
       
        checks whether the incoming request can be cached based on the presence of
       
       
        
         Cache-Control headers
        
       
      </li>
      <li>
       
        If a valid Cache-Control header is found and it allows caching, the middleware proceeds to handle
       
       
        
         the request
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Stores responses in
      
     </strong>
     
      <strong class="bold">
       
        the cache
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        If the response to the request can be cached, the middleware stores the response in
       
       
        
         the cache
        
       
      </li>
      <li>
       
        Subsequent requests that match the cache criteria will be served directly from the cache, bypassing the need to generate the
       
       
        
         response again
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Serves
      
     </strong>
     
      <strong class="bold">
       
        cached responses
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        For requests that match previously cached responses, the middleware serves the
       
       
        
         cached response
        
       
      </li>
      <li>
       
        This reduces the processing time and load on the server, as the response is retrieved directly from
       
       
        
         the cache
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      app.Use(async (context, next)
     
    </strong>
    
     method adds the necessary parameters for the Cache-Control header
    
    <a id="_idIndexMarker558">
    </a>
    
     to the middleware pipeline, such as the cache duration time.
    
    
     This is necessary so that the client can know how the response should
    
    
     
      be cached.
     
    
   </p>
   <p>
    
     The cache is
    
    <a id="_idIndexMarker559">
    </a>
    
     managed in the application’s memory and, therefore, it is not
    
    <a id="_idIndexMarker560">
    </a>
    
     interesting to keep the cache for a large
    
    <a id="_idIndexMarker561">
    </a>
    
     amount of time in memory, which could cause problems.
    
    
     However, it is good practice to use it.
    
    
     We will go into more detail about cache usage in the next section,
    
    <em class="italic">
     
      Improving performance with a cache strategy and making the
     
    </em>
    
     <em class="italic">
      
       application resilient
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     To further improve response performance, we can perform compression automatically with a few lines
    
    
     
      of code.
     
    
   </p>
   <p>
    
     For this purpose, we must add the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.ResponseCompression
     
    </strong>
    
     NuGet package to the project.
    
    
     You can do this by typing the following command in your application’s
    
    
     
      project directory:
     
    
   </p>
   <pre class="console">
dotnet add package Microsoft.AspNetCore.ResponseCompression</pre>
   <p>
    
     In any case, it is important that you understand how to use this functionality in
    
    
     
      your applications.
     
    
   </p>
   <p>
    
     After adding the
    
    <a id="_idIndexMarker562">
    </a>
    
     NuGet package, we must add the compression
    
    <a id="_idIndexMarker563">
    </a>
    
     services to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file.
    
    
     When doing so, we have the following modified file taking into account caching
    
    
     
      and compression:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
<strong class="bold">builder.Services.AddResponseCompression(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">    options.EnableForHttps = true;</strong>
<strong class="bold">    // Enable compression for HTTPS requests</strong>
<strong class="bold">    options.Providers.Add&lt;GzipCompressionProvider&gt;();</strong>
<strong class="bold">    // Add Gzip compression</strong>
<strong class="bold">    options.Providers.Add&lt;BrotliCompressionProvider&gt;();</strong>
<strong class="bold">    // Add Brotli compression</strong>
<strong class="bold">});</strong>
<strong class="bold">builder.Services.Configure&lt;</strong>
<strong class="bold">  GzipCompressionProviderOptions&gt;(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">    options.Level = System.IO.Compression</strong>
<strong class="bold">      .CompressionLevel.Fastest;</strong>
<strong class="bold">    // Set compression level for Gzip</strong>
<strong class="bold">});</strong>
builder.Services.AddResponseCaching();
var app = builder.Build();
// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
<strong class="bold">app.UseResponseCompression(); </strong>// Use response compression middleware
app.UseResponseCaching(); // Use response caching middleware
app.Use(async (context, next) =&gt;
{
  context.Response.GetTypedHeaders().CacheControl =
    new Microsoft.Net.Http.Headers.CacheControlHeaderValue
  {
    Public = true,
    MaxAge = TimeSpan.FromMinutes(10)
  };
  await next();
});
app.UseAuthorization();
app.MapRazorPages();
app.MapControllers();
app.Run();</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker564">
    </a>
    
     preceding code
    
    <a id="_idIndexMarker565">
    </a>
    
     can be explained
    
    
     
      as
     
    
    
     <a id="_idIndexMarker566">
     </a>
    
    
     
      follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Add response
      
     </strong>
     
      <strong class="bold">
       
        compression middleware
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        The
       
       <strong class="source-inline">
        
         builder.Services.AddResponseCompression
        
       </strong>
       
        method is used to add response
       
       <a id="_idIndexMarker567">
       </a>
       
        compression services to the
       
       <strong class="bold">
        
         Dependency Injection
        
       </strong>
       
        (
       
       
        <strong class="bold">
         
          DI
         
        </strong>
       
       
        
         ) container.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         options.EnableForHttps
        
       </strong>
       
        is set to
       
       <strong class="source-inline">
        
         true
        
       </strong>
       
        to enable compression for
       
       
        
         HTTPS responses.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         options.Providers.Add&lt;GzipCompressionProvider&gt;()
        
       </strong>
       
        and
       
       <strong class="source-inline">
        
         options.Providers.Add&lt;BrotliCompressionProvider&gt;()
        
       </strong>
       
        are used to add support
       
       <a id="_idIndexMarker568">
       </a>
       
        for
       
       <strong class="bold">
        
         Gzip
        
       </strong>
       
        and
       
       <strong class="bold">
        
         Brotli
        
       </strong>
       
        
         compression
        
       
       
        <a id="_idIndexMarker569">
        </a>
       
       
        
         providers.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Configure
      
     </strong>
     
      <strong class="bold">
       
        compression options
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          builder.Services.Configure&lt;GzipCompressionProvider
         
        </strong>
       
       <strong class="source-inline">
        
         Options&gt;(options =&gt; options.Level = System.IO.Compression.CompressionLevel.Fastest)
        
       </strong>
       
        is used to configure the compression level for Gzip.
       
       
        You can adjust the compression level based on your needs (
       
       <strong class="source-inline">
        
         Optimal
        
       </strong>
       
        ,
       
       <strong class="source-inline">
        
         Fastest
        
       </strong>
       
        ,
       
       
        
         or
        
       
       
        <strong class="source-inline">
         
          NoCompression
         
        </strong>
       
       
        
         ).
        
       
      </li>
     </ul>
    </li>
    <li>
     
      <strong class="bold">
       
        Use middleware
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       <strong class="source-inline">
        
         app.UseResponseCompression()
        
       </strong>
       
        adds the response compression middleware
       
       <a id="_idIndexMarker570">
       </a>
       
        to the
       
       <a id="_idIndexMarker571">
       </a>
       
        
         request pipeline.
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p class="callout-heading">
    
     The order of middleware is important
    
   </p>
   <p class="callout">
    
     When combining response caching and compression, the order of the middleware is important.
    
    
     Make sure compression middleware is included before caching middleware.
    
    
     This way, responses are compressed before being cached, ensuring that cached responses are already compressed and ready to be
    
    
     
      served efficiently.
     
    
   </p>
   <p>
    
     With these practices, you can reduce the size of responses, leading to better performance and faster loading times
    
    
     
      for users.
     
    
   </p>
   <p>
    
     The time has come to understand asynchronous requests in
    
    
     
      more detail.
     
    
   </p>
   <h2 id="_idParaDest-121">
    <a id="_idTextAnchor122">
    </a>
    
     Asynchronous requests and I/O optimization
    
   </h2>
   <p>
    
     Asynchronous programming
    
    <a id="_idIndexMarker572">
    </a>
    
     is a fundamental aspect of modern web development, enabling non-blocking operations that improve application responsiveness
    
    
     
      and scalability.
     
    
   </p>
   <p>
    
     The great complexity of asynchronous programming is abstracted by the resources available in C#, making applications and functionalities even more powerful.
    
    
     But to better understand the importance of this asynchronous process, let’s analyze the
    
    
     
      following example.
     
    
   </p>
   <p>
    
     Imagine you are waiting in line at a coffee shop.
    
    
     If the barista had to wait for each cup of coffee to finish brewing before starting the next one, the line would move very slowly.
    
    
     Instead, the barista starts preparing the next drink while the previous one is being prepared.
    
    
     Similarly, asynchronous programming allows your application to start other tasks while waiting for a previous task
    
    
     
      to complete.
     
    
   </p>
   <p>
    
     Web applications can respond to a large number of requests from users at a given time.
    
    
     ASP.NET Core 9 is optimized enough to manage requests and memory efficiently.
    
    
     However, if you choose to use a synchronous approach, which is also possible, some problems may be caused.
    
    
     Let’s see how we can develop
    
    
     
      asynchronous methods.
     
    
   </p>
   <h3>
    
     Use async and await keywords
    
   </h3>
   <p>
    
     In C#, the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     keywords let you
    
    <a id="_idIndexMarker573">
    </a>
    
     write asynchronous code that is
    
    <a id="_idIndexMarker574">
    </a>
    
     easier to read
    
    
     
      and maintain.
     
    
   </p>
   <p>
    
     For example, in the context of an ASP.NET Core application, using
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     allows your server to handle more requests simultaneously by not blocking threads during I/O operations, as demonstrated in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
public <strong class="bold">async Task&lt;IActionResult&gt;</strong> GetDataAsync()
{
    var data = <strong class="bold">await</strong> _dataService.<strong class="bold">GetDataAsync()</strong>;
    return Ok(data);
}</pre>
   <p>
    
     Let’s look at the details highlighted in
    
    
     
      the code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       async
      
     </strong>
     
      : This is the keyword used to indicate that the method is asynchronous.
     
     
      When declaring an asynchronous method, it is mandatory to use at least one
     
     <strong class="source-inline">
      
       await
      
     </strong>
     
      keyword to perform asynchronous operations in the
     
     
      
       method body.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Task&lt;IActionResult&gt;
      
     </strong>
     
      : This specifies that the method returns a task that will eventually be completed with
     
     <strong class="source-inline">
      
       IActionResult
      
     </strong>
     
      .
     
     
      The
     
     <strong class="source-inline">
      
       Task
      
     </strong>
     
      type represents an asynchronous operation in C#.
     
     <strong class="source-inline">
      
       IActionResult
      
     </strong>
     
      is a common return type in ASP.NET Core MVC that represents the result of an action method.
     
     
      The return type could be any type of class or structure, for example, returning an integer such
     
     
      
       as
      
     
     
      <strong class="source-inline">
       
        Task&lt;int&gt;
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       await
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       await
      
     </strong>
     
      keyword is used to asynchronously wait for the
     
     <strong class="source-inline">
      
       GetDataAsync
      
     </strong>
     
      method to complete.
     
     
      This means that the method will return a task and execution will be paused until the task is completed, without blocking
     
     
      
       the thread.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       _dataService.GetDataAsync()
      
     </strong>
     
      : This line calls an asynchronous
     
     <strong class="source-inline">
      
       GetDataAsync
      
     </strong>
     
      method on the
     
     <strong class="source-inline">
      
       _dataService
      
     </strong>
     
      object.
     
     <strong class="source-inline">
      
       _dataService
      
     </strong>
     
      is presumably an instance of a service class that handles
     
     
      
       data retrieval.
      
     
    </li>
   </ul>
   <p>
    
     C# has several asynchronous methods and you can identify them by using the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     suffix, added to the name of the methods as
    
    
     
      a convention.
     
    
   </p>
   <p class="callout-heading">
    
     Asynchronous programming
    
   </p>
   <p class="callout">
    
     Asynchronous programming in C# has several other details and ways of application, and it is not possible to consider them as part of this book.
    
    
     However, to continue your learning, I suggest
    
    <a id="_idIndexMarker575">
    </a>
    
     this great content from Microsoft
    
    
     
      Learn:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/">
     
      
       https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     With some simple changes, using the features available in ASP.NET Core 9, we have the ability to implement asynchronous requests with
    
    
     
      some keywords.
     
    
   </p>
   <p>
    
     These resources can be used in conjunction, for example, with Entity
    
    
     
      Framework Core.
     
    
   </p>
   <p>
    
     We can implement asynchronous data access using Entity Framework Core with methods such as
    
    <strong class="source-inline">
     
      ToListAsync()
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       SaveChangesAsync()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The asynchronous data access lets your application perform other operations while waiting for data from the database, as exemplified in the following code, where an asynchronous query is made to obtain all records from the
    
    <strong class="source-inline">
     
      Customers
     
    </strong>
    
     table through
    
    
     
      Entity Framework:
     
    
   </p>
   <pre class="source-code">
public async Task&lt;List&lt;Customer&gt;&gt; GetCustomersAsync()
{
    return await _dbContext.Customers.ToListAsync();
}</pre>
   <p>
    
     Consider the use of asynchronous programming in the design of
    
    
     
      your applications.
     
    
   </p>
   <p>
    
     Although the ASP.NET Core 9 platform provides us with several mechanisms to create robust applications, it is important to keep in mind that the use of best practices for HTTP requests, compression, and information caching, in addition to the asynchronous programming model, must be taken into consideration in all applications developed.
    
    
     This guarantees the best experience for users and integrated systems, in addition to ensuring that applications can be optimized enough to support large
    
    
     
      demands correctly.
     
    
   </p>
   <p>
    
     In the next section, we will see in more detail the use of caching strategies and how to make
    
    
     
      applications resilient.
     
    
   </p>
   <h1 id="_idParaDest-122">
    <a id="_idTextAnchor123">
    </a>
    
     Improving performance with a cache strategy and making the application resilient
    
   </h1>
   <p>
    
     In the
    
    <em class="italic">
     
      HTTP request best practices
     
    </em>
    
     subsection of the
    
    <em class="italic">
     
      Working with ASP.NET Core 9 best practices
     
    </em>
    
     section, we learned about some mechanisms capable of bringing several improvements to our applications.
    
    
     Some approaches were discussed, including a brief introduction to the use
    
    
     
      of caching.
     
    
   </p>
   <p>
    
     To expand our knowledge and add techniques to our robust application development model, we will explore the use of caching strategies and how to make our applications resilient, a fundamental requirement for
    
    
     
      modern solutions.
     
    
   </p>
   <p>
    
     Let’s start with first understanding the different types of
    
    
     
      caching strategies.
     
    
   </p>
   <h2 id="_idParaDest-123">
    <a id="_idTextAnchor124">
    </a>
    
     Caching strategies
    
   </h2>
   <p>
    
     Caching
    
    <a id="_idIndexMarker576">
    </a>
    
     is a powerful technique to improve application performance by storing frequently accessed data in a temporary storage location.
    
    
     This reduces the need to retrieve data from the original
    
    
     
      source repeatedly.
     
    
   </p>
   <p>
    
     In the
    
    <em class="italic">
     
      Caching and compression
     
    </em>
    
     subsection, a code was demonstrated that enabled the application to manage a cache, adding functionality to ASP.NET Core 9 middleware, used during request processing.
    
    
     For this case, the
    
    <strong class="bold">
     
      in-memory
     
    </strong>
    
     cache strategy
    
    <a id="_idIndexMarker577">
    </a>
    
     was used, which stores data in memory for quick access.
    
    
     This is suitable for small to medium-sized datasets that are
    
    
     
      frequently accessed.
     
    
   </p>
   <p>
    
     However, for more robust applications, another strategy called
    
    <a id="_idIndexMarker578">
    </a>
    
     the
    
    <strong class="bold">
     
      distributed cache
     
    </strong>
    
     
      is necessary.
     
    
   </p>
   <p>
    
     A distributed cache
    
    <a id="_idIndexMarker579">
    </a>
    
     uses some type of resource specialized in distributed caching, such
    
    
     
      as Redis.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Redis
     
    </strong>
    
     is a powerful technology for large datasets or when running in a
    
    
     
      distributed environment.
     
    
   </p>
   <p class="callout-heading">
    
     What is Redis?
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      Remote DIctionary Server
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Redis
     
    </strong>
    
     ) is an
    
    <a id="_idIndexMarker580">
    </a>
    
     open source, in-memory data structure store.
    
    
     It is known for its high performance, flexibility, and support for diverse
    
    
     
      data structures.
     
    
   </p>
   <p class="callout">
    
     Redis stores data in memory, which makes it extremely fast compared to disk-based databases, and also supports data persistence on
    
    
     
      disk periodically.
     
    
   </p>
   <p class="callout">
    
     Redis’ persistence model is key/value, supporting data structures such as strings, hashes, lists, sets, sorted sets, bitmaps, HyperLogLogs, and geospatial indexes.
    
    
     This flexibility allows for diverse
    
    
     
      use cases.
     
    
   </p>
   <p class="callout">
    
     Redis is a resource widely used
    
    <a id="_idIndexMarker581">
    </a>
    
     by several applications; if you want to know more, go to this
    
    
     
      link:
     
    
    <a href="https://redis.io/">
     
      
       https://redis.io/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Several modern applications, hosted mainly in cloud environments, use Redis as a solution for distributed caching, in addition to being fully integrated with ASP.NET
    
    
     
      Core 9.
     
    
   </p>
   <p>
    
     So that we can better understand how Redis works when integrated with ASP.NET Core 9, let’s implement
    
    
     
      an application.
     
    
   </p>
   <p>
    
     It is important to take into account the requirements mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section.
    
    
     Let’s learn how to integrate Redis into
    
    
     
      our application.
     
    
   </p>
   <h2 id="_idParaDest-124">
    <a id="_idTextAnchor125">
    </a>
    
     Integrating Redis in our application
    
   </h2>
   <p>
    
     We will start by creating
    
    <a id="_idIndexMarker582">
    </a>
    
     an application.
    
    
     Therefore, open the terminal in a directory of your choice and perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new ASP.NET Core 9 project by running the
     
     
      
       following commands:
      
     
     <pre class="source-code">
<strong class="bold">dotnet new webapi -n DistributedCacheExample</strong>
<strong class="bold">cd DistributedCacheExample</strong></pre>
    </li>
    <li>
     
      Add the Redis
     
     
      
       cache package:
      
     
     <pre class="source-code">
<strong class="bold">dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis</strong></pre>
    </li>
    <li>
     
      Now, run the following command to open Visual Studio Code in the
     
     
      
       application directory:
      
     
     <pre class="source-code">
<strong class="bold">Code .</strong></pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
     
      file and
     
     <a id="_idIndexMarker583">
     </a>
     
      change the content to the
     
     
      
       following code:
      
     
     <pre class="source-code">
{
  "ConnectionStrings": {
    "Redis": "localhost:6379"
  }
}</pre>
     <p class="list-inset">
      
       The preceding JSON defines a connection string for the Redis server that we will
      
      
       
        create later.
       
      
     </p>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file and change all its contents with the
     
     
      
       following code:
      
     
     <pre class="source-code">
using Microsoft.Extensions.Caching.Distributed;
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
// Configure Redis distributed cache
<strong class="bold">builder.Services.AddStackExchangeRedisCache(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">  options.Configuration = builder</strong>
<strong class="bold">    .Configuration.GetConnectionString("Redis");</strong>
<strong class="bold">  options.InstanceName = "myPrefix_";</strong>
<strong class="bold">});</strong>
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseAuthorization();
app.MapControllers();
app.Run();</pre>
     <p class="list-inset">
      
       You should already
      
      <a id="_idIndexMarker584">
      </a>
      
       be used to most of the code described previously.
      
      
       The
      
      <strong class="source-inline">
       
        builder.Services.AddStackExchangeRedisCache
       
      </strong>
      
       method adds the default required objects, as part of the added library
      
      <strong class="bold">
       
        Microsoft.Extensions.Caching.StackExchangeRedis
       
      </strong>
      
       , to manage the cache when configuring the
      
      
       
        DI container.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     We have two
    
    
     
      main configurations:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       options.Configuration
      
     </strong>
     
      : This is where the connection address to the Redis server
     
     
      
       is provided
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       options.InstanceName
      
     </strong>
     
      : This is an optional parameter that defines a prefix for the
     
     
      
       cache keys
      
     
    </li>
   </ul>
   <p>
    
     The foundation of
    
    <a id="_idIndexMarker585">
    </a>
    
     the application has been configured, and now it’s time to implement a controller that will interact
    
    
     
      with Redis.
     
    
   </p>
   <h2 id="_idParaDest-125">
    <a id="_idTextAnchor126">
    </a>
    
     Working with cache in the controller class
    
   </h2>
   <p>
    
     To do this, still in Visual Studio Code, follow the following steps
    
    <a id="_idIndexMarker586">
    </a>
    
     to create
    
    
     
      the controller:
     
    
   </p>
   <ol>
    <li>
     
      If it does not exist, in the root of the project, create a folder
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        Controllers
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a class called
     
     <strong class="source-inline">
      
       CacheController
      
     </strong>
     
      in the
     
     
      <strong class="source-inline">
       
        Controller
       
      </strong>
     
     
      
       folder
      
     
    </li>
    <li>
     
      Modify all content of the previously created class with the
     
     
      
       following code:
      
     
     <pre class="source-code">
using Microsoft.AspNetCore.Mvc;
using <strong class="bold">Microsoft.Extensions.Caching.Distributed;</strong>
using System.Text.Json;
using System.Text;
namespace DistributedCacheExample.Controllers;
    [ApiController]
    [Route("api/[controller]")]
    public class CacheController : ControllerBase
    {
       <strong class="bold"> private readonly IDistributedCache _cache;</strong>
<strong class="bold">        public CacheController(IDistributedCache</strong>
<strong class="bold">          cache)</strong>
        {
            _cache = cache;
        }
        [HttpGet("{key}")]
        public async Task&lt;IActionResult&gt;
          Get(string key)
        {
            <strong class="bold">var cachedData = await _cache</strong>
<strong class="bold">              .GetStringAsync(key);</strong>
            if (string.IsNullOrEmpty(cachedData))
            {
                return NotFound();
            }
            var data = JsonSerializer
              .Deserialize&lt;MyData&gt;(cachedData);
            return Ok(data);
        }
        [HttpPost]
        public async Task&lt;IActionResult&gt;
          Post([FromBody] MyData data)
        {
            var cacheKey = data.Key;
            var serializedData = JsonSerializer
              .Serialize(data);
            <strong class="bold">var options = new</strong>
<strong class="bold">              DistributedCacheEntryOptions()</strong>
<strong class="bold">              .SetSlidingExpiration(TimeSpan</strong>
<strong class="bold">              .FromMinutes(5))</strong>
<strong class="bold">              .SetAbsoluteExpiration(TimeSpan</strong>
<strong class="bold">              .FromHours(1));</strong>
<strong class="bold">            await _cache.SetStringAsync(cacheKey,</strong>
<strong class="bold">              serializedData, options);</strong>
            return CreatedAtAction(nameof(Get),
             new { key = cacheKey }, data);
        }
    }
    <strong class="bold">public class MyData</strong>
<strong class="bold">    {</strong>
<strong class="bold">        public string Key { get; set; }</strong>
<strong class="bold">        public string Value { get; set; }</strong>
<strong class="bold">    }</strong></pre>
     <p class="list-inset">
      
       The preceding
      
      <a id="_idIndexMarker587">
      </a>
      
       code creates an API called
      
      <strong class="source-inline">
       
        Cache
       
      </strong>
      
       containing
      
      <strong class="bold">
       
        GET
       
      </strong>
      
       and
      
      <strong class="bold">
       
        POST
       
      </strong>
      
       methods.
      
      
       Let’s
      
      <a id="_idIndexMarker588">
      </a>
      
       analyze the important points of the code
      
      <a id="_idIndexMarker589">
      </a>
      
       in
      
      
       
        more detail:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         Microsoft.Extensions.Caching.Distributed
        
       </strong>
       
        : This is a namespace that references the NuGet package containing the dependencies necessary for handling the cache in the
       
       
        <strong class="source-inline">
         
          CacheController
         
        </strong>
       
       
        
         class.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         private readonly IDistributedCache _cache
        
       </strong>
       
        : This is a private property of the class that abstracts a cache
       
       
        
         handling object.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         public CacheController(IDistributedCache cache)
        
       </strong>
       
        : As a dependency, the class constructor has the
       
       <strong class="source-inline">
        
         IDistributedCache
        
       </strong>
       
        interface that will be injected by DI and assigns the instance to the class’s
       
       
        <strong class="source-inline">
         
          _cache
         
        </strong>
       
       
        
         property.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         var cachedData = await _cache.GetStringAsync(key)
        
       </strong>
       
        : During the execution of the
       
       <strong class="source-inline">
        
         Get
        
       </strong>
       
        method, the _
       
       <strong class="source-inline">
        
         cache
        
       </strong>
       
        object, which abstracts a connection to the Redis server, will search for a string using the key and return it in the request; otherwise, it will return a
       
       
        <strong class="source-inline">
         
          NotFound()
         
        </strong>
       
       
        
         status.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         Post
        
       </strong>
       
        method: The
       
       <strong class="source-inline">
        
         Post
        
       </strong>
       
        method receives as a parameter an object of the
       
       <strong class="source-inline">
        
         MyData
        
       </strong>
       
        type, a class created at the end of the file.
       
       
        When obtaining the
       
       <strong class="source-inline">
        
         MyData
        
       </strong>
       
        object, the
       
       <strong class="source-inline">
        
         Key
        
       </strong>
       
        property will be used as the cache key,
       
       <strong class="source-inline">
        
         var cacheKey = data.Key
        
       </strong>
       
        .
       
       
        Then, the
       
       <strong class="source-inline">
        
         MyData
        
       </strong>
       
        object is serialized into JSON,
       
       <strong class="source-inline">
        
         JsonSerializer.Serialize(data)
        
       </strong>
       
        .
       
       
        Subsequently, an object of the
       
       <strong class="source-inline">
        
         DistributedCacheEntryOptions
        
       </strong>
       
        type is created, where expiration parameters for information in the cache are specified.
       
       
        Finally, the cache persisted in Redis by running
       
       <strong class="source-inline">
        
         await_cache.SetStringAsync(cacheKey,
        
       </strong>
       
        <strong class="source-inline">
         
          serializedData, options)
         
        </strong>
       
       
        
         .
        
       
      </li>
     </ul>
    </li>
   </ol>
   <p class="callout-heading">
    
     SetSlidingExpiration and SetAbsoluteExpiration
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      .SetSlidingExpiration(TimeSpan.FromMinutes(5))
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      .SetAbsoluteExpiration(TimeSpan.FromHours(1))
     
    </strong>
    
     methods are used to configure cache entry expiration options in
    
    <strong class="source-inline">
     
      DistributedCacheEntryOptions
     
    </strong>
    
     .
    
    
     These methods help manage how long the cached data should be kept in
    
    
     
      the cache.
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      SlidingExpiration
     
    </strong>
    
     specifies the amount of time a cache entry can be inactive (not accessed) before it is removed from the cache.
    
    
     The expiration time is reset every time the cache entry
    
    
     
      is accessed.
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      AbsoluteExpiration
     
    </strong>
    
     specifies the maximum time a cache entry should be kept in the cache, regardless of how often it is accessed.
    
    
     The cache entry will be removed from the cache after the specified time has elapsed, no matter how many times it has
    
    
     
      been accessed.
     
    
   </p>
   <p>
    
     With the application
    
    <a id="_idIndexMarker590">
    </a>
    
     developed, we must create a Redis server, and for this, we will use Docker to
    
    
     
      run it:
     
    
   </p>
   <ol>
    <li>
     
      In the application directory, open the terminal and run the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">docker run --name redis -d -p 6379:6379 redis</strong></pre>
     <p class="list-inset">
      
       If this is your first time running Redis on your machine, wait for it to download and then the server
      
      
       
        will start.
       
      
     </p>
    </li>
    <li>
     
      Still in the application terminal, use the following command to
     
     
      
       run it:
      
     
     <pre class="source-code">
<strong class="bold">dotnet run</strong></pre>
    </li>
    <li>
     
      After running the application, open Postman and create a new request by accessing the
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New
      
     </strong>
     
      <strong class="bold">
       
        Tab
       
      </strong>
     
     
      
       menu.
      
     
    </li>
    <li>
     
      Then, define the request type as
     
     <strong class="bold">
      
       GET
      
     </strong>
     
      , and in the URL field, enter the URL made available in the terminal after executing the application with the suffix
     
     <strong class="source-inline">
      
       /api/Cache/DataInCache
      
     </strong>
     
      .
     
     
      <em class="italic">
       
        Figure 7
       
      </em>
     
     <em class="italic">
      
       .1
      
     </em>
     
      demonstrates an example of the
     
     
      
       request configuration:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 7.1 – Configuring the API request on Postman" src="img/B21788_07_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.1 – Configuring the API request on Postman
    
   </p>
   <p class="callout-heading">
    
     API URL port
    
   </p>
   <p class="callout">
    
     The number
    
    <strong class="source-inline">
     
      5277
     
    </strong>
    
     added to the URL shown in
    
    
     <em class="italic">
      
       Figure 7
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     represents the API execution port.
    
    
     This value may vary from environment to environment.
    
    
     Make sure to enter the execution port available in your terminal after executing the
    
    <strong class="source-inline">
     
      docker
     
    </strong>
    
     <strong class="source-inline">
      
       run
      
     </strong>
    
    
     
      command.
     
    
   </p>
   <ol>
    <li value="5">
     
      The
     
     <strong class="source-inline">
      
       DataInCache
      
     </strong>
     
      value
     
     <a id="_idIndexMarker591">
     </a>
     
      represents the key we want to get the cached value from.
     
     
      However, when clicking on the
     
     <strong class="bold">
      
       Send
      
     </strong>
     
      button in Postman, we have the following return (
     
     
      <em class="italic">
       
        Figure 7
       
      </em>
     
     
      <em class="italic">
       
        .2
       
      </em>
     
     
      
       ):
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 7.2 – Requesting data in cache" src="img/B21788_07_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.2 – Requesting data in cache
    
   </p>
   <p class="list-inset">
    
     As shown in
    
    
     <em class="italic">
      
       Figure 7
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     , the HTTP status and JSON return in the response body represent the
    
    <strong class="source-inline">
     
      404
     
    </strong>
    
     not
    
    
     
      found state.
     
    
   </p>
   <p class="list-inset">
    
     The API return is correct, as the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method tries to obtain a value from the cache, and if not found, an HTTP status of
    
    <strong class="source-inline">
     
      404
     
    </strong>
    
     
      is returned.
     
    
   </p>
   <ol>
    <li value="6">
     
      Still in Postman, open a new tab (
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New Tab
      
     </strong>
     
      ), set the request type as
     
     <strong class="bold">
      
       POST
      
     </strong>
     
      , and define the API URL with the following
     
     
      
       suffix:
      
     
     
      <strong class="source-inline">
       
        /api/Cache
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Then, click
     
     <strong class="bold">
      
       Body
      
     </strong>
     
      , select
     
     <a id="_idIndexMarker592">
     </a>
     
      the
     
     <strong class="bold">
      
       raw
      
     </strong>
     
      option, and add the
     
     
      
       following JSON:
      
     
     <pre class="source-code">
{
  "key": "DataInCache",
  "value": "Value in cache"
}</pre>
     <p class="list-inset">
      
       The entire configuration of this request is demonstrated in
      
      
       <em class="italic">
        
         Figure 7
        
       </em>
      
      
       <em class="italic">
        
         .3
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 7.3 – Post request configuration" src="img/B21788_07_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.3 – Post request configuration
    
   </p>
   <p class="list-inset">
    
     The
    
    <strong class="bold">
     
      POST
     
    </strong>
    
     request, demonstrated in
    
    
     <em class="italic">
      
       Figure 7
      
     </em>
    
    <em class="italic">
     
      .3
     
    </em>
    
     , will make a call to the API’s
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method, which will add the value defined in the request body to the
    
    
     
      Redis cache.
     
    
   </p>
   <ol>
    <li value="8">
     
      Click the
     
     <strong class="bold">
      
       Send
      
     </strong>
     
      button to make the request and you should receive the HTTP
     
     <strong class="source-inline">
      
       201
      
     </strong>
     
      status code in return, indicating that the information was created in
     
     
      
       the cache.
      
     
    </li>
    <li>
     
      If you want to confirm the cached value, in Postman, open the previous tab containing the
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request and you should receive the HTTP
     
     <strong class="source-inline">
      
       200
      
     </strong>
     
      status code in return, along with the
     
     <a id="_idIndexMarker593">
     </a>
     
      JSON object that represents the
     
     
      
       cached data.
      
     
    </li>
   </ol>
   <p>
    
     Another way to check the values available in the Redis cache is to use a UI tool such as Redis Insight, mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section, which we’ll
    
    
     
      configure now.
     
    
   </p>
   <h2 id="_idParaDest-126">
    <a id="_idTextAnchor127">
    </a>
    
     Configuring Redis Insight
    
   </h2>
   <p>
    
     Let’s configure
    
    <a id="_idIndexMarker594">
    </a>
    
     Redis Insight to connect to the Redis server running on Docker by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      On the application’s main screen, click on the
     
     <strong class="bold">
      
       Add connection details manually
      
     </strong>
     
      option, as shown in
     
     
      <em class="italic">
       
        Figure 7
       
      </em>
     
     
      <em class="italic">
       
        .4
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 7.4 – Configuring the Redis connection" src="img/B21788_07_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.4 – Configuring the Redis connection
    
   </p>
   <ol>
    <li value="2">
     
      On the next screen, we must add the connection parameters to the Redis server.
     
     
      As this server is running through Docker, the default parameters will be used, already available on
     
     
      
       the screen:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Host
        
       </strong>
       
        : This defines the Redis
       
       
        
         server address.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Port
        
       </strong>
       
        : This defines the server
       
       
        
         execution port.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Other parameters
        
       </strong>
       
        : Not important at this time.
       
       
        However, in productive environments, the host address, port, user, and password may be different
       
       
        
         and necessary.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      For our example, just keep the default values and click the
     
     <strong class="bold">
      
       + Add Redis
      
     </strong>
     
      <strong class="bold">
       
        database
       
      </strong>
     
     
      
       button.
      
     
     <p class="list-inset">
      
       Once the connection
      
      <a id="_idIndexMarker595">
      </a>
      
       is created, the list of servers connected to Redis Insights will be displayed, as shown in
      
      
       <em class="italic">
        
         Figure 7
        
       </em>
      
      
       <em class="italic">
        
         .5
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 7.5 – Connected Redis cache in the Redis Insight tool" src="img/B21788_07_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.5 – Connected Redis cache in the Redis Insight tool
    
   </p>
   <ol>
    <li value="4">
     
      Click on the created connection displayed in the list of connections.
     
     
      Then, click on the magnifying glass icon, as highlighted in
     
     
      <em class="italic">
       
        Figure 7
       
      </em>
     
     <em class="italic">
      
       .6
      
     </em>
     
      , to view the data available in
     
     
      
       the cache:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 7.6 – List of data in the cache" src="img/B21788_07_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.6 – List of data in the cache
    
   </p>
   <p class="list-inset">
    
     If you cannot view any information when clicking the magnifying glass icon, it means that the previously added key has expired.
    
    
     In this case, just make another
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request to add another key and view it in
    
    
     
      Redis Insight.
     
    
   </p>
   <p>
    
     This is a simple example created so that we can learn how to communicate with the cache and add information to memory.
    
    
     In this case, we are using Redis, a powerful distributed data management resource, as a server for the information that will be kept
    
    
     
      in memory.
     
    
   </p>
   <p>
    
     In real scenarios, this approach can be used in conjunction with a database.
    
    
     This way, before executing a request to the database, the existence of information in the cache will be checked.
    
    
     If it exists, it will not be necessary to make a call to the database,
    
    
     
      optimizing processes.
     
    
   </p>
   <p>
    
     As we learned, caching is a powerful solution for making our applications more performant
    
    
     
      and available.
     
    
   </p>
   <p>
    
     Now that we have learned how to quickly retrieve information from a cache server, we will understand how to make our applications more resilient in the
    
    
     
      next topic.
     
    
   </p>
   <h2 id="_idParaDest-127">
    <a id="_idTextAnchor128">
    </a>
    
     Resilience mechanisms
    
   </h2>
   <p>
    
     To build robust applications, it is essential to implement resilience mechanisms that deal with transient failures and ensure
    
    
     
      continuous availability.
     
    
   </p>
   <p>
    
     Think of resilience mechanisms
    
    <a id="_idIndexMarker596">
    </a>
    
     as safety nets that catch us if something goes wrong.
    
    
     They help your application recover from unexpected crashes and maintain a smooth
    
    
     
      user experience.
     
    
   </p>
   <p>
    
     The most common resilience strategies are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Retry pattern
      
     </strong>
     
      : Automatically retries
     
     <a id="_idIndexMarker597">
     </a>
     
      a failed operation a specified number of times before giving up.
     
     
      This is useful for dealing with
     
     
      
       transient faults.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Circuit breaker pattern
      
     </strong>
     
      : Prevents an
     
     <a id="_idIndexMarker598">
     </a>
     
      application from performing an operation that is likely to fail.
     
     
      It stops the flow of requests to a service when a failure is detected, allowing the system
     
     
      
       to recover.
      
     
    </li>
   </ul>
   <p>
    
     In order to have
    
    <a id="_idIndexMarker599">
    </a>
    
     the ability to implement these patterns in our applications, we will use a library
    
    
     
      called
     
    
    
     <strong class="bold">
      
       Polly
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Polly
    
   </p>
   <p class="callout">
    
     Polly is a
    
    <a id="_idIndexMarker600">
    </a>
    
     library that is part of the .NET Foundation used to add various resilience features to applications.
    
    
     It is constantly updated by the open source community and used in various applications in production environments.
    
    
     To learn
    
    <a id="_idIndexMarker601">
    </a>
    
     more about Polly, go
    
    
     
      to
     
    
    <a href="https://github.com/App-vNext/Polly">
     
      
       https://github.com/App-vNext/Polly
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To use Polly in our applications, we just need to add it to the project through the following command executed in the application’s
    
    
     
      project directory:
     
    
   </p>
   <pre class="console">
dotnet add package Polly.Core</pre>
   <p>
    
     Let’s analyze the
    
    <a id="_idIndexMarker602">
    </a>
    
     implementation of the
    
    <a id="_idIndexMarker603">
    </a>
    
     retry strategy in the following
    
    
     
      code example:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">var retryPolicy = Policy.Handle&lt;Exception&gt;().RetryAsync(3);</strong>
public async Task&lt;IActionResult&gt; GetDataWithRetryAsync()
{
    return await <strong class="bold">retryPolicy.ExecuteAsync</strong>(async () =&gt;
    {
        var data = await _dataService.GetDataAsync();
        return Ok(data);
    });
}</pre>
   <p>
    
     As we can see in the preceding code, the implementation process is quite simple and integrates with the ASP.NET Core 9 development model.
    
    
     In this example, the objective is to obtain data from a service in a resilient way.
    
    
     Let’s analyze the main points of
    
    
     
      the implementation:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       var retryPolicy = Policy.Handle&lt;Exception&gt;().RetryAsync(3)
      
     </strong>
     
      aims to create a retry policy.
     
     
      In this case, the policy is related to an exception.
     
     
      During execution, if an exception is identified, the request will be made again.
     
     
      Trials were configured to run a maximum of
     
     
      
       three times.
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       return await retryPolicy.ExecuteAsync
      
     </strong>
     
      command is a method that executes an action using the previously configured retry policy.
     
     
      All code executing the
     
     <strong class="source-inline">
      
       GetDataAsync
      
     </strong>
     
      method request is defined within the scope of the policy that automatically manages the
     
     
      
       retry mechanism.
      
     
    </li>
   </ul>
   <p>
    
     It is very common to use the retry strategy when consuming external APIs.
    
    
     There may be intermittences or momentary unavailability and, in this case,
    
    <strong class="source-inline">
     
      retry
     
    </strong>
    
     helps to guarantee greater resilience in cases of
    
    
     
      momentary unavailability.
     
    
   </p>
   <p>
    
     Let’s look at an
    
    <a id="_idIndexMarker604">
    </a>
    
     example of
    
    <a id="_idIndexMarker605">
    </a>
    
     implementing the circuit
    
    
     
      breaker strategy:
     
    
   </p>
   <pre class="source-code">
var circuitBreakerPolicy = Policy.Handle&lt;Exception&gt;()
  .<strong class="bold">CircuitBreakerAsync</strong>(
    3, // Number of consecutive faults before breaking the circuit
    TimeSpan.FromMinutes(1) // Duration of the circuit break
);
public async Task&lt;IActionResult&gt;
  GetDataWithCircuitBreakerAsync()
{
    return await <strong class="bold">circuitBreakerPolicy</strong>
<strong class="bold">      </strong>.ExecuteAsync(async () =&gt;
    {
        var data = await _dataService.GetDataAsync();
        return Ok(data);
    });
}</pre>
   <p>
    
     Let’s look at the details of the
    
    
     
      preceding code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       CircuitBreakerAsync
      
     </strong>
     
      : This method creates an asynchronous circuit
     
     
      
       breaker policy.
      
     
    </li>
    <li>
     
      The circuit
     
     <a id="_idIndexMarker606">
     </a>
     
      breaker will open (break the circuit) after three consecutive
     
     
      
       exceptions (faults).
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       TimeSpan.FromMinutes(1)
      
     </strong>
     
      : Once the circuit is open, it will remain open for one minute.
     
     
      During this time, any attempt to perform the action will immediately throw
     
     <strong class="source-inline">
      
       BrokenCircuitException
      
     </strong>
     
      without performing
     
     
      
       the action.
      
     
     <p class="list-inset">
      
       The circuit breaker has the
      
      
       
        following states:
       
      
     </p>
     <ul>
      <li>
       <strong class="bold">
        
         Closed
        
       </strong>
       
        : The normal
       
       <a id="_idIndexMarker607">
       </a>
       
        state where all calls
       
       
        
         are allowed.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Open
        
       </strong>
       
        : The
       
       <a id="_idIndexMarker608">
       </a>
       
        state in which calls are blocked after a specified number of
       
       
        
         consecutive failures.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Half-open
        
       </strong>
       
        : After the
       
       <a id="_idIndexMarker609">
       </a>
       
        open period, the circuit breaker allows a limited number of test calls to verify that the underlying problem has been resolved.
       
       
        If these calls are successful, the circuit returns to the closed state.
       
       
        If they fail, the circuit returns to the
       
       
        
         open state.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         circuitBreakerPolicy.ExecuteAsync
        
       </strong>
       
        : This method executes the given asynchronous delegate (the code block inside) under the control of the circuit
       
       
        
         breaker policy.
        
       
      </li>
      <li>
       
        If the
       
       <strong class="source-inline">
        
         _dataService.GetDataAsync()
        
       </strong>
       
        call succeeds, the method returns the data wrapped in an
       
       <strong class="source-inline">
        
         OkObjectResult
        
       </strong>
       
        (HTTP
       
       
        <strong class="source-inline">
         
          200
         
        </strong>
       
       
        
         response).
        
       
      </li>
      <li>
       
        If the
       
       <strong class="source-inline">
        
         _dataService.GetDataAsync()
        
       </strong>
       
        call throws an exception, the circuit breaker policy
       
       
        
         handles it:
        
       
       <ul>
        <li>
         
          If
         
         <a id="_idIndexMarker610">
         </a>
         
          fewer than three exceptions have occurred consecutively, the circuit breaker remains closed, and the exception
         
         
          
           is propagated.
          
         
        </li>
        <li>
         
          After three consecutive exceptions, the circuit breaker opens for one minute.
         
         
          Any further calls within this period will immediately
         
         
          
           throw
          
         
         
          <strong class="source-inline">
           
            BrokenCircuitException
           
          </strong>
         
         
          
           .
          
         
        </li>
       </ul>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     The circuit breaker
    
    <a id="_idIndexMarker611">
    </a>
    
     policy helps prevent repeated failures from overloading the system by interrupting the circuit after three consecutive failures and keeping it open for one minute.
    
    
     During this period, any attempt to call the data service will result in an immediate exception without attempting to execute the service call.
    
    
     This allows the system to recover and prevents cascading failures in
    
    
     
      dependent systems.
     
    
   </p>
   <p>
    
     The circuit breaker
    
    <a id="_idIndexMarker612">
    </a>
    
     and retry strategies are powerful resilience strategies that, despite
    
    <a id="_idIndexMarker613">
    </a>
    
     appearing similar, have different objectives, as
    
    <a id="_idIndexMarker614">
    </a>
    
     shown in
    
    
     <em class="italic">
      
       Table 7.1
      
     </em>
    
    
     
      :
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-3">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Aspect
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Circuit Breaker
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Retry
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Purpose
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Prevent overwhelming a
        
        
         
          failing service
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Handle transient faults
        
        
         
          by retrying
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Behavior
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Stops requests after a certain number of failures and opens the circuit for a
        
        
         
          specified time
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Retries the operation a specified number of times with a delay
        
        
         
          between retries
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          States
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Closed,
        
        
         
          open, half-open
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         No states,
        
        
         
          just retries
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Failure Handling
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Fails fast once the circuit
        
        
         
          is open
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Retries multiple times
        
        
         
          before failing
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         When
        
        
         
          to Use
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         When repeated failures need to be avoided to protect
        
        
         
          a system
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         When temporary faults are expected to be resolved
        
        
         
          with retries
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         
          Complexity
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Higher, with state transitions
        
        
         
          and monitoring
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Lower, with simple
        
        
         
          retry logic
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Feedback
        
        
         
          to Users
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Immediate failure feedback when the circuit
        
        
         
          is open
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Delayed feedback after all
        
        
         
          retries fail
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 7.1 –The circuit breaker and retry objectives
    
   </p>
   <p>
    
     In practice, these patterns are often used together to provide a robust fault-handling mechanism.
    
    
     For example, you can use a retry policy to handle transient failures, and if the attempts consistently fail, the circuit breaker can be used to prevent retries and allow the system
    
    
     
      to recover.
     
    
   </p>
   <p>
    
     Polly offers several other
    
    <a id="_idIndexMarker615">
    </a>
    
     resilience mechanisms that can be combined to make applications even
    
    
     
      more powerful.
     
    
   </p>
   <p>
    
     The use of these strategies greatly contributes to the creation of robust solutions prepared for large-scale execution models, especially in
    
    
     
      cloud environments.
     
    
   </p>
   <p>
    
     In any case, even by adding several mechanisms to avoid failures, they may arise.
    
    
     In this case, we must be able to obtain sufficient information to make corrections and keep applications free from non-conformities.
    
    
     For this, it is important to add logs in applications, and ASP.NET Core 9 provides a powerful mechanism for this, which we will learn about in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-128">
    <a id="_idTextAnchor129">
    </a>
    
     Understanding and implementing logging and monitoring
    
   </h1>
   <p>
    
     Having optimized performance and resilience, we now turn to logging and monitoring, essential practices for maintaining and troubleshooting your ASP.NET Core
    
    
     
      9 applications.
     
    
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor130">
    </a>
    
     Introduction to logging and monitoring
    
   </h2>
   <p>
    
     Logging
    
    <a id="_idIndexMarker616">
    </a>
    
     and monitoring are
    
    <a id="_idIndexMarker617">
    </a>
    
     crucial to understanding your application’s behavior, diagnosing problems, and ensuring it runs smoothly.
    
    
     Logs provide visibility into application processes and help detect
    
    
     
      anomalies early.
     
    
   </p>
   <p>
    
     Think of logging like keeping a diary and monitoring like installing surveillance cameras in your home.
    
    
     The diary helps you remember past events, while the cameras let you see what’s happening in real time, maintaining safety
    
    
     
      and order.
     
    
   </p>
   <h3>
    
     Logging with ILogger
    
   </h3>
   <p>
    
     .NET provides abstractions that allow ASP.NET Core 9 applications to handle different logging
    
    <a id="_idIndexMarker618">
    </a>
    
     strategies.
    
    
     The
    
    <strong class="bold">
     
      ILogger
     
    </strong>
    
     and
    
    <strong class="bold">
     
      ILoggerFactory
     
    </strong>
    
     interfaces, provided
    
    <a id="_idIndexMarker619">
    </a>
    
     by the
    
    <strong class="bold">
     
      Microsoft.Extensions.Logging
     
    </strong>
    
     namespace, are
    
    <a id="_idIndexMarker620">
    </a>
    
     essential for implementing logging in your applications, allowing you to capture and record information about the operation of
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Logging provides insights into the behavior of your application and is essential for debugging
    
    
     
      and monitoring.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     interface
    
    <a id="_idIndexMarker621">
    </a>
    
     in ASP.NET Core allows you to log information at various levels of details as described in the
    
    
     
      following points:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Trace
      
     </strong>
     
      : Detailed information, typically of interest only when
     
     
      
       diagnosing problems
      
     
    </li>
    <li>
     <strong class="bold">
      
       Debug
      
     </strong>
     
      : Information useful for debugging
     
     
      
       the application
      
     
    </li>
    <li>
     <strong class="bold">
      
       Information
      
     </strong>
     
      : Informational messages that highlight the progress of
     
     
      
       the application
      
     
    </li>
    <li>
     <strong class="bold">
      
       Warning
      
     </strong>
     
      : Potentially harmful situations that are
     
     
      
       not errors
      
     
    </li>
    <li>
     <strong class="bold">
      
       Error
      
     </strong>
     
      : Errors that prevent the application from performing
     
     
      
       a function
      
     
    </li>
    <li>
     <strong class="bold">
      
       Critical
      
     </strong>
     
      : Critical errors causing complete failure of
     
     
      
       the application
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     interface provides some
    
    
     
      useful methods:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Log methods
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       <strong class="source-inline">
        
         Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&lt;TState, Exception, string&gt; formatter)
        
       </strong>
       
        : The core
       
       <a id="_idIndexMarker622">
       </a>
       
        method to log messages.
       
       
        It allows you to specify the log level, event ID, state, exception, and a
       
       
        
         formatter function.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      <strong class="bold">
       
        Convenience methods
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       <strong class="source-inline">
        
         LogTrace(string message, params object[] args)
        
       </strong>
       
        : Logs a
       
       
        
         trace
        
       
       
        <a id="_idIndexMarker623">
        </a>
       
       
        
         message.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         LogDebug(string message, params object[] args)
        
       </strong>
       
        : Logs a
       
       
        
         debug message.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         LogInformation(string message, params object[] args)
        
       </strong>
       
        : Logs an
       
       
        
         informational message.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         LogWarning(string message, params object[] args)
        
       </strong>
       
        : Logs a
       
       
        
         warning message.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         LogError(string message, params object[] args)
        
       </strong>
       
        : Logs an
       
       
        
         error message.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         LogCritical(string message, params object[] args)
        
       </strong>
       
        : Logs a
       
       <a id="_idIndexMarker624">
       </a>
       
        critical
       
       
        
         error message.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      <strong class="bold">
       
        Scope Method
       
      </strong>
     
     
      
       :
      
     
     <ul>
      <li>
       <strong class="source-inline">
        
         BeginScope&lt;TState&gt;(TState state)
        
       </strong>
       
        : This method starts a logical operation
       
       <a id="_idIndexMarker625">
       </a>
       
        scope.
       
       
        It returns an
       
       <strong class="source-inline">
        
         IDisposable
        
       </strong>
       
        interface that ends the scope on disposal.
       
       
        Scopes are useful for correlating a set of operations with a
       
       
        
         common context.
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     The following is an
    
    <a id="_idIndexMarker626">
    </a>
    
     example of using the
    
    
     <strong class="source-inline">
      
       ILogger
      
     </strong>
    
    
     
      interface:
     
    
   </p>
   <pre class="source-code">
public class MyService
{
    private <strong class="bold">readonly ILogger&lt;MyService&gt; _logger;</strong>
    public <strong class="bold">MyService(ILogger&lt;MyService&gt; logger)</strong>
    {
        _logger = logger;
    }
    public void DoWork()
    {
        <strong class="bold">_logger.LogInformation("Starting work.");</strong>
        try
        {
            // Perform some work here
        }
        catch (Exception ex)
        {
            <strong class="bold">_logger.LogError(ex, "An error occurred while doing work.");</strong>
        }
        _logger.LogInformation("Finished work.");
    }
}</pre>
   <p>
    
     The previous code uses several
    
    <a id="_idIndexMarker627">
    </a>
    
     methods provided by the
    
    
     <strong class="source-inline">
      
       ILogger
      
     </strong>
    
    
     
      interface:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       ILogger&lt;MyService&gt; _logger
      
     </strong>
     
      : This declares a private
     
     <strong class="source-inline">
      
       readonly
      
     </strong>
     
      field,
     
     <strong class="source-inline">
      
       _logger
      
     </strong>
     
      , of the
     
     <strong class="source-inline">
      
       ILogger&lt;MyService&gt;
      
     </strong>
     
      type.
     
     
      The
     
     <strong class="source-inline">
      
       ILogger&lt;T&gt;
      
     </strong>
     
      interface is part of the .NET logging infrastructure, where
     
     <strong class="source-inline">
      
       T
      
     </strong>
     
      is the type that is being logged.
     
     
      By specifying
     
     <strong class="source-inline">
      
       MyService
      
     </strong>
     
      , the logger is associated with this class, which helps in identifying where the log messages are
     
     
      
       coming from.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       MyService(ILogger&lt;MyService&gt; logger)
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       ILogger&lt;MyService&gt;
      
     </strong>
     
      instance is typically provided via dependency injection.
     
     
      This allows the logging infrastructure to be configured and
     
     
      
       managed centrally.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       _logger.LogInformation("Starting work.")
      
     </strong>
     
      : Log the information type with the string
     
     
      <strong class="source-inline">
       
        Starting work
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       _logger.LogError(ex, "An error occurred while doing work.")
      
     </strong>
     
      : Log the information type
     
     <a id="_idIndexMarker628">
     </a>
     
      with the string
     
     <strong class="source-inline">
      
       An error occurred while
      
     </strong>
     
      <strong class="source-inline">
       
        doing work
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     interface offers a powerful abstraction for logging your application’s execution data in a technology-agnostic manner, facilitating maintenance
    
    
     
      and extensibility.
     
    
   </p>
   <p>
    
     Another powerful abstraction mechanism available in .NET
    
    
     
      is
     
    
    
     <strong class="bold">
      
       ILoggerFactory
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     interface
    
    <a id="_idIndexMarker629">
    </a>
    
     is responsible for creating
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     instances.
    
    
     It is generally used to create loggers for specific categories or to configure logging providers
    
    
     
      and settings.
     
    
   </p>
   <p>
    
     The main methods
    
    <a id="_idIndexMarker630">
    </a>
    
     are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       CreateLogger(string categoryname)
      
     </strong>
     
      : Creates an
     
     <strong class="source-inline">
      
       ILogger
      
     </strong>
     
      instance for the specified category.
     
     
      The category is usually the name of the class or component that the logger is
     
     
      
       associated with.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       AddProvider (ILoggerProvider provider)
      
     </strong>
     
      : Adds
     
     <strong class="source-inline">
      
       ILoggerProvider
      
     </strong>
     
      to the factory.
     
     
      This method is used to configure where and how log messages are sent, such as to the console, a file, or a remote
     
     
      
       log service.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       To discard()
      
     </strong>
     
      : Discards the logger factory and all loggers it created.
     
     
      Typically used to release any resources held by
     
     
      
       log providers.
      
     
    </li>
   </ul>
   <p>
    
     We can use the
    
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     interface as in the following example
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
public class MyService
{
    private readonly ILogger _logger;
    <strong class="bold">public MyService(ILoggerFactory loggerFactory)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        _logger = loggerFactory.CreateLogger&lt;MyService&gt;();</strong>
<strong class="bold">    }</strong>
    public void DoWork()
    {
        _logger.LogInformation("Starting work.");
        try
        {
            // Perform some work here
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while doing work.");
        }
        _logger.LogInformation("Finished work.");
    }
}</pre>
   <p>
    
     The big difference between using the
    
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     interface
    
    <a id="_idIndexMarker631">
    </a>
    
     and the
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     interface
    
    <a id="_idIndexMarker632">
    </a>
    
     is the creation of a new category of logs that will be used to group the application’s log messages.
    
    
     The constructor receives an
    
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     instance via dependency injection and then an
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     instance is created for the
    
    <strong class="source-inline">
     
      MyService
     
    </strong>
    
     class.
    
    
     In this case, all log messages of this class will be grouped by the
    
    
     <strong class="source-inline">
      
       MyService
      
     </strong>
    
    
     
      category.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     allows for centralized configuration of logging settings.
    
    
     This means you can set up logging providers, filters, and other settings in one place, typically during application startup, and apply these configurations across all loggers created by the factory.
    
    
     You can also dynamically create loggers for different categories or components within your application.
    
    
     This is useful for associating log messages with specific parts of the application, making it easier to filter and
    
    
     
      analyze logs.
     
    
   </p>
   <p>
    
     Logs work with providers, which are different sources where the logs will be made available.
    
    
     An application may contain different types of providers for
    
    
     
      each purpose.
     
    
   </p>
   <p>
    
     Each provider is centrally configured during application startup.
    
    
     This way, the
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     abstractions will use
    
    <a id="_idIndexMarker633">
    </a>
    
     the configured providers for submitting
    
    
     
      the
     
    
    
     <a id="_idIndexMarker634">
     </a>
    
    
     
      logs.
     
    
   </p>
   <p>
    
     There are several types of providers that can be used in ASP.NET Core 9, such as providers for writing to the console, adding debug information, and even providers for writing logs to external services such as Azure Application Insights and Elasticsearch,
    
    
     
      among others.
     
    
   </p>
   <p>
    
     Let’s look at an example of log settings in the following code from a
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     <strong class="bold">
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
<strong class="bold">// Configure logging</strong>
<strong class="bold">builder.Logging.ClearProviders();</strong>
<strong class="bold">// Optional: clear default providers</strong>
<strong class="bold">builder.Logging.AddConsole(); // Add console logging</strong>
<strong class="bold">builder.Logging.AddDebug(); // Add debug logging</strong>
<strong class="bold">builder.Logging.AddEventSourceLogger();</strong>
<strong class="bold">// Add event source logging</strong>
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapControllers();
app.Run();</pre>
   <p>
    
     As we can see in the preceding code example, different providers were added for writing logs.
    
    
     This means that when using a method such as
    
    <strong class="source-inline">
     
      _logger.LogInformation
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      _logger.LogError
     
    </strong>
    
     , these logs will be distributed to the
    
    
     
      configured providers.
     
    
   </p>
   <p>
    
     Logs
    
    <a id="_idIndexMarker635">
    </a>
    
     are a powerful tool, essential in any application, helping to detect failures and even
    
    
     
      optimize systems.
     
    
   </p>
   <p>
    
     In
    
    <a href="B21788_08.xhtml#_idTextAnchor132">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     , we will explore the use of logs in conjunction
    
    
     
      with middleware.
     
    
   </p>
   <h1 id="_idParaDest-130">
    <a id="_idTextAnchor131">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     During this chapter, we learned about implementing best practices in ASP.NET Core 9, working correctly with HTTP requests, adding comprehension to responses, and understanding the use of caching to bring better performance and resilience to applications.
    
    
     We also understood the concepts related to asynchronous requests and how we can use this approach in ASP.NET Core applications through the use of the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     keywords.
    
    
     Finally, we learned about the importance of using application monitoring, taking advantage of internal mechanisms that abstract writing and logs, such as the use of the
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      ILoggerFactory
     
    </strong>
    
     classes, allowing us to have enough inputs to fix inconsistencies in applications and
    
    
     
      optimize them.
     
    
   </p>
   <p>
    
     In the next chapter, we will learn how to expand the request pipeline of ASP.NET Core 9 applications through the use
    
    
     
      of middleware.
     
    
   </p>
  </div>
 </body></html>