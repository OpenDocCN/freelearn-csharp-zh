<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer132">
			<h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor159"/>Chapter 11</em>: Quest Tracking and Branching Narratives</h1>
			<p>In this chapter, we will review how to create an ink template for quests, track multiple quests based on this template, and show the player the values of variables across quests. In the first section, we will create an ink template and its required sections. Next, we will improve the ink template and create a <strong class="source-inline">Quest</strong> class to track multiple quests progressing independently from each other. Finally, we will show the player the results of progressing quests and view the values of change during this progression.</p>
			<p>Many larger or narrative-focused video games are composed of separate quests for the player to complete. This chapter will provide a template for creating quests in ink and will also show you how to access and manipulate this template in Unity. Using multiple quests, a branching narrative approach is possible by allowing a player to progress through each quest separately, as explained in this chapter. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Making a quest count</li>
				<li>Tracking progress across multiple quests</li>
				<li>Displaying and awarding player progression<p class="callout-heading">Important </p><p class="callout">Each topic in this chapter has a separate, completed Unity project. Each topic includes instructions that state the name of the project and where to find it.</p></li>
			</ul>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Technical requirements</h1>
			<p>The examples in this chapter have been divided into folders per project and can be found online on GitHub: <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11</a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Making a quest count</h1>
			<p>In narrative<a id="_idIndexMarker405"/> terms, a <strong class="bold">quest</strong> is a series of events connected to a character within a story. In video games, quests are a sequence of connected events experienced by the <em class="italic">player</em>. In role-playing games, a quest might include unlocking a weapon, rescuing a prince, or defeating some great evil. Each point along the way is a <em class="italic">step</em> of the quest. Translated in terms of story and code, a quest can be thought of as a series of steps where the resolution of each step unlocks the next.</p>
			<p>ink supports this pattern of smaller parts within a larger whole as stitches within a knot. Thought of in this way, each step of the quest can become its own stitch within the code, with the outcome of each stitch being able to move to the next within the larger structure. Using <strong class="source-inline">LIST</strong> in ink also allows us to define the steps we want by name, with a special knot progressing the player from one stitch to the next within the quest structure.</p>
			<p>In this section, we will learn how to design a quest template in ink and access its values in Unity across one single project, with each section building on the previous one:</p>
			<ul>
				<li>In the first section, <em class="italic">Creating a quest template in ink</em>, we will review how to use this pattern and the built-in automation available by using existing Ink functions. </li>
				<li>In the second section, <em class="italic">Choosing specific knots in Unity</em>, we will move away from ink and look at Unity. Here, we will examine how to run the template in ink, as well as some potential issues to be aware of when using certain Story API methods.<p class="callout-heading">Reminder</p><p class="callout">The completed project for this section can be found in the <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a>, examples on GitHub folder, under the name <strong class="source-inline">Chapter11,QuestProgression</strong>. Only select parts of the code will be shown as they relate to the concepts examined in the sections of this topic.</p></li>
			</ul>
			<p>Now let us<a id="_idIndexMarker406"/> understand the next topic where we will create a quest template.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Creating a quest template in ink</h2>
			<p>ink<a id="_idIndexMarker407"/> stories are<a id="_idIndexMarker408"/> composed of different sections. In <a href="B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Text Flow, Choices, and Weaves</em>, we learned how ink breaks code<a id="_idIndexMarker409"/> into different sections called <strong class="bold">knots</strong>. Inside these, subsections can be<a id="_idIndexMarker410"/> defined called <strong class="bold">stitches</strong>. In <a href="B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Knots, Diverts, and Looping Patterns</em>, the <a id="_idIndexMarker411"/>concept of <strong class="bold">diverts</strong> was introduced, which are used to move between knots and their stitches. By putting these ideas together while using variables that use the <strong class="source-inline">VAR</strong> and <strong class="source-inline">LIST</strong> keywords in ink, which we did in <a href="B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Variables, Lists, and Functions</em>, we can create a quest that's composed of a series of steps:</p>
			<p class="source-code"><strong class="bold">LIST stages = (one), (two), (three)</strong></p>
			<p class="source-code"><strong class="bold">VAR stage = one</strong></p>
			<p class="source-code"><strong class="bold">VAR end = false</strong></p>
			<p>This code creates a list named <strong class="source-inline">steps</strong>, a variable named <strong class="source-inline">step</strong>, and a variable named <strong class="source-inline">end</strong> in ink. These three values keep track of the <em class="italic">quest's progression</em>. The name of each step in the quest is added as an entry to the list, with the first used as the value of the <strong class="source-inline">stage</strong> variable:</p>
			<p class="source-code">You meet an old man by the side of a dusty road with a wide hat set out in front of him. "Got any change?"</p>
			<p class="source-code">* [Sure]</p>
			<p class="source-code">    -&gt; quest</p>
			<p class="source-code">* [Not today]</p>
			<p class="source-code">    -&gt; quest.stop</p>
			<p>The player is presented with their first options: <strong class="source-inline">Sure</strong> and <strong class="source-inline">Not today</strong>. If the first is selected, the flow moves into the <strong class="source-inline">quest</strong> knot. If the second is selected, the flow moves to a stitch inside of the <strong class="source-inline">quest</strong> knot named <strong class="source-inline">stop</strong>:</p>
			<p class="source-code">== quest</p>
			<p class="source-code">{step:</p>
			<p class="source-code">    - one: -&gt; first</p>
			<p class="source-code">    - two: -&gt; second</p>
			<p class="source-code">    - three: -&gt; third</p>
			<p class="source-code">}</p>
			<p class="source-code">-&gt; DONE</p>
			<p>The <a id="_idIndexMarker412"/>names <em class="italic">quest</em> and <em class="italic">stop</em> were chosen specifically. The use<a id="_idIndexMarker413"/> of the word <em class="italic">quest</em> helps in understanding the code as part of a template for other quests. As will be outlined in the next section, <em class="italic">Tracking progress across multiple quests</em>, multiple <strong class="source-inline">Story</strong> objects can exist at the same time in Unity. In this case, the word is used to show the pattern.</p>
			<p>The <strong class="source-inline">quest</strong> knot contains the central logic of this pattern. Because the entries in a <strong class="source-inline">LIST</strong> in ink are Boolean values (either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>), a multi-line comparison is used, where the order is important. The list named <strong class="source-inline">steps</strong> contains three entries, each of which are initially set to <strong class="source-inline">true</strong>. When the <strong class="source-inline">quest</strong> knot is first encountered, it will move the flow to the stitch named <strong class="source-inline">first</strong>:</p>
			<p class="source-code">= first</p>
			<p class="source-code">You empty some coins from your pocket and the old man nods. "Thanks, stranger! May the gods bless you!"</p>
			<p class="source-code">-&gt; DONE</p>
			<p>The <strong class="source-inline">first</strong> stitch contains an unusual ending. The use of the <strong class="source-inline">DONE</strong> keyword usually signals that the story is over in ink. However, in this case, the <strong class="source-inline">DONE</strong> keyword is used to signal that the <em class="italic">step</em> is done. Instead of diverting to the <strong class="source-inline">quest</strong> knot or another section, the story seemingly stops. Progression happens using a combination of the <strong class="source-inline">LIST_MIN()</strong> function and the subtraction (<strong class="source-inline">-</strong>) operation for lists in Ink:</p>
			<p class="source-code">== progress</p>
			<p class="source-code">~ steps -= LIST_MIN(steps)</p>
			<p class="source-code">~ step = LIST_MIN(steps)</p>
			<p class="source-code">-&gt; quest</p>
			<p>Within the <strong class="source-inline">progress</strong> knot, each entry is removed (subtracted) and the top (minimum) value is used as part of the <strong class="source-inline">step</strong> variable. Each use of this knot <em class="italic">progresses</em> the quest by removing a step from the list and then using the top remaining one each time. However, the knot itself is not accessed directly. Instead, it is used externally by Unity.</p>
			<p>In this section, we learned how each step can be divided into stitches as part of a knot named <strong class="source-inline">quest</strong>. By using a <strong class="source-inline">LIST</strong> and different variables in ink, progress can be tracked across the <a id="_idIndexMarker414"/>quest. In the next section, we will learn how an ink <a id="_idIndexMarker415"/>template can be used as a series of steps to access the <strong class="source-inline">progress</strong> knot externally in Unity.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Choosing specific knots in Unity</h2>
			<p>Different <a id="_idIndexMarker416"/>methods <a id="_idIndexMarker417"/>and properties of the Story API provided by the ink-Unity Integration plugin were covered in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, and <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>. However, what was not covered in those chapters was a useful but potentially very dangerous method named <strong class="source-inline">ChoosePathString()</strong>. In this section, we will look at an example of how this method can be used safely.</p>
			<p>Internally, the ink runtime uses the term "path string" to describe any knot that is part of a story. When loaded, these can be accessed by using the <strong class="source-inline">ChoosePathString()</strong> method, which forcibly moves the story to that section. In most cases, this is unwanted behavior, as its use will disregard any existing tunnels or threads. It can be thought of as <em class="italic">ripping</em> the flow away from wherever it was and dropping it into a new location.</p>
			<p>As part of the ink runtime, variables are global. This means that while their values might be changed as part of the flow of a story, they exist outside of it. The values of variables are maintained despite any uses of the <strong class="source-inline">ChoosePathString()</strong> method. In other words, by carefully avoiding any structures that might be disrupted by its use, the <strong class="source-inline">ChoosePathString()</strong> method can be carefully used in projects.</p>
			<p>In the previous section, the ink <strong class="source-inline">progress</strong> knot was introduced. To choose this path string in Unity using the <strong class="source-inline">ChoosePathString()</strong> method, only its name is needed:</p>
			<p class="source-code">public void Progress()</p>
			<p class="source-code">{</p>
			<p class="source-code">     <strong class="bold">InkStory.ChoosePathString("progress");</strong></p>
			<p class="source-code">     FlipProgress();</p>
			<p class="source-code">    UpdateContent();</p>
			<p class="source-code">}</p>
			<p>When the <strong class="source-inline">ChoosePathString()</strong> method is used with the <strong class="source-inline">progress</strong> ink knot, it <em class="italic">does</em> disrupt the <a id="_idIndexMarker418"/>flow of the story that's kept within the <strong class="source-inline">InkStory</strong> C# variable. However, as <a id="_idIndexMarker419"/>we learned, the values of variables are maintained throughout the story because of their global nature. The use of the <strong class="source-inline">progress</strong> ink knot <em class="italic">progresses</em> the quest to its next step by updating the variables each time.</p>
			<p>The code also includes calls to two other methods: <strong class="source-inline">FlipProgress()</strong> and <strong class="source-inline">UpdateContent()</strong>. The first method sets a <strong class="source-inline">Button</strong> game object in Unity to inactive by using the <strong class="source-inline">SetActive()</strong> method in Unity. When a game object is turned off (set to inactive) in Unity, it does not appear on the screen. This code effectively sets the game object to appear as needed and to disappear when the player is selecting dialogue options:</p>
			<p class="source-code">void FlipProgress() {</p>
			<p class="source-code"><strong class="bold">ProgressButton.gameObject.SetActive(!ProgressButton.gameObject.activeSelf);</strong></p>
			<p class="source-code">}</p>
			<p>The second method, <strong class="source-inline">UpdateContent()</strong>, follows the pattern we first introduced in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, where a <strong class="source-inline">Prefab</strong> is used to dynamically create <strong class="source-inline">Button</strong> game objects as needed:</p>
			<p class="source-code">void UpdateContent()</p>
			<p class="source-code">{</p>
			<p class="source-code">     DestroyChildren(OptionsPanel.transform);</p>
			<p class="source-code">     DialogueText.text = InkStory.ContinueMaximally();</p>
			<p class="source-code">     foreach (Choice in InkStory.currentChoices)</p>
			<p class="source-code">     {</p>
			<p class="source-code">          <strong class="bold">Button choiceButton = Instantiate(ButtonPrefab,</strong></p>
			<p class="source-code"><strong class="bold">             OptionsPanel.transform);</strong></p>
			<p class="source-code">           choiceButton.onClick.AddListener(delegate</p>
			<p class="source-code">           {</p>
			<p class="source-code">                InkStory.ChooseChoiceIndex(choice.index);</p>
			<p class="source-code">                FlipProgress();</p>
			<p class="source-code">                UpdateContent();</p>
			<p class="source-code">           });</p>
			<p class="source-code">             Text choiceText =</p>
			<p class="source-code">             choiceButton.GetComponentInChildren&lt;Text&gt;();</p>
			<p class="source-code">           choiceText.text = choice.text;</p>
			<p class="source-code">      }</p>
			<p class="source-code">}</p>
			<p>In this section, we <a id="_idIndexMarker420"/>learned how to create a template for quests in ink. Using a<a id="_idIndexMarker421"/> knot and then individual stitches for each step, the parts were divided into different sections. Next, we looked at the <strong class="source-inline">progress</strong> ink knot. After that, we looked at Unity and using the <strong class="source-inline">ChoosePathString()</strong> method. While it can be potentially dangerous with larger projects using more advanced techniques, using variables in the ink quest template helped maintain their values. Finally, at the end of this section, the <strong class="source-inline">ChoosePathString()</strong> method in Unity was paired with the <strong class="source-inline">progress</strong> knot in ink. By using this knot, the Unity code could <em class="italic">progress</em> the quest, with ink updating its internal variables.</p>
			<p>In the next section, we will continue with the pattern we looked at in this section by extending part of the quest template in ink and creating <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes in C#. These <a id="_idIndexMarker422"/>will <a id="_idIndexMarker423"/>allow us to track multiple quests at the same time.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Tracking progress across multiple quests</h1>
			<p>In the <a id="_idIndexMarker424"/>previous section, we created an ink template for a quest and then moved into Unity to create the user interface to progress the quest using the <strong class="source-inline">ChoosePathString()</strong> method. This forced the flow within ink to move to a specific location. In this section, we move beyond a single quest and start tracking multiple quests at the same time. To do this, the ink template needs additional variables. For this, we will need the <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes in C#. We also will depart from using a single ink file and start using multiple files. For every quest, we will create a separate file and use the <strong class="source-inline">Quest</strong> class to track the progress of each in Unity with the <strong class="source-inline">Dialogue</strong> class, which handles creating options for a player to choose from during each step in the quest.</p>
			<p>First, we will update the ink template with a new variable we will access later in Unity. Then, we will create the <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes in Unity. After that, we will access multiple ink files in Unity to present an interface containing multiple quests. Finally, we will allow a user to toggle between quests and progress them independently of each other.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a><em class="italic"> examples on GitHub</em> folder, under the name <em class="italic">Chapter11-MultipleQuests</em>. Only select parts of the code will be shown as they relate to the concepts examined in the sections of this topic.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Building on the ink quest template</h2>
			<p>As we<a id="_idIndexMarker425"/> saw in <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, we can access ink variables that have been created with the <strong class="source-inline">VAR</strong> keyword using the <strong class="source-inline">variablesState</strong> property in Unity. This allows us to retrieve the value of a variable based on its name. With that in mind, the existing ink template can be expanded to include a new variable for each quest – its <strong class="source-inline">name</strong>.</p>
			<p>By understanding that the compiled ink files will be operated from Unity, we can anticipate certain needs we will have with quests. For example, a quest usually has a <em class="italic">name</em>. We can then define this variable alongside our existing values in Ink:</p>
			<p class="source-code">LIST steps = (one), (two), (three)</p>
			<p class="source-code">VAR step = one</p>
			<p class="source-code">VAR end = false</p>
			<p class="source-code"><strong class="bold">VAR name = "Old Man's Change"</strong></p>
			<p>Once we know <a id="_idIndexMarker426"/>that the <strong class="source-inline">name</strong> variable exists in ink, we can read it in Unity. However, unlike what was shown in the previously section, we will need to observe the <strong class="source-inline">end</strong> ink variable as well: </p>
			<p class="source-code">InkStory = new Story(text);</p>
			<p class="source-code">Name = (string)InkStory.variablesState["name"];</p>
			<p class="source-code"><strong class="bold">End = (bool)InkStory.variablesState["end"];</strong></p>
			<p class="source-code"><strong class="bold">InkStory.ObserveVariable("end", delegate</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code">      <strong class="bold">End = (bool)InkStory.variablesState["end"];</strong></p>
			<p class="source-code"><strong class="bold">});</strong></p>
			<p>These small changes may not seem important, but by establishing a pattern where certain variables exist (<strong class="source-inline">name</strong> and <strong class="source-inline">end</strong>) and all files containing quests will also have a knot named <strong class="source-inline">progress</strong> (as defined in the previous section), we can write any quests we want if those parts remain the same.</p>
			<p>Once these variables have been prepared, we can start creating the <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes, which will hold the values we defined in ink and read them in Unity.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Making Quest and Dialogue classes in Unity</h2>
			<p>In <a id="_idIndexMarker427"/>the<a id="_idIndexMarker428"/> previous <a id="_idIndexMarker429"/>section, we<a id="_idIndexMarker430"/> combined a simple presentation of dialogue options with the values and methods to progress the single quest presented. In this section, we will break that functionality into two new classes in Unity: <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong>.</p>
			<p>Most of the <strong class="source-inline">Quest</strong> class was shown in the previous section. However, its purpose is to hold a <strong class="source-inline">Story</strong> object <a id="_idIndexMarker431"/>and to <a id="_idIndexMarker432"/>expose a <a id="_idIndexMarker433"/>method named <strong class="source-inline">Progress()</strong> that<a id="_idIndexMarker434"/> internally calls the <strong class="source-inline">ChoosePathString()</strong> method:</p>
			<p class="source-code">using Ink.Runtime;</p>
			<p class="source-code">public class Quest</p>
			<p class="source-code">{</p>
			<p class="source-code">    public Story InkStory;</p>
			<p class="source-code">    public string Name;</p>
			<p class="source-code">    public string Description;</p>
			<p class="source-code">    public bool End;</p>
			<p class="source-code">    public Quest(string text)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        InkStory = new Story(text);</p>
			<p class="source-code">        Name = (string)InkStory.variablesState["name"];</p>
			<p class="source-code">        End = (bool)InkStory.variablesState["end"];</p>
			<p class="source-code">        InkStory.ObserveVariable("end", delegate</p>
			<p class="source-code">        {</p>
			<p class="source-code">            End = (bool)InkStory.variablesState["end"];</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">    <strong class="bold">public void Progress()</strong></p>
			<p class="source-code">    <strong class="bold">{</strong></p>
			<p class="source-code">        <strong class="bold">InkStory.ChoosePathString("progress");</strong></p>
			<p class="source-code">    <strong class="bold">}</strong></p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Quest</strong> class is small because it is used by other classes. Its sole purpose is to contain the quest (ink story) and provide a way to progress the quest (via the <strong class="source-inline">Progress()</strong> method). </p>
			<p>The new<a id="_idIndexMarker435"/> class, <strong class="source-inline">Dialogue</strong>, performs<a id="_idIndexMarker436"/> most <a id="_idIndexMarker437"/>of the work to create<a id="_idIndexMarker438"/> the <strong class="source-inline">Button</strong> game objects needed and to remember what the last line of dialogue was as a reminder for the player. Its <strong class="source-inline">UpdateContent()</strong> method looks like the example code that was first shown in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, except for using the new <strong class="source-inline">Quest</strong> class:</p>
			<p class="source-code">public void UpdateContent()</p>
			<p class="source-code">{</p>
			<p class="source-code">     DestroyChildren();</p>
			<p class="source-code">        </p>
			<p class="source-code">     <strong class="bold">if(quest.InkStory.canContinue)</strong></p>
			<p class="source-code">     {</p>
			<p class="source-code">           <strong class="bold">DialogueText.text =</strong></p>
			<p class="source-code"><strong class="bold">             quest.InkStory.ContinueMaximally();</strong></p>
			<p class="source-code">           lastDialogue = DialogueText.text;</p>
			<p class="source-code">      }</p>
			<p class="source-code">      else</p>
			<p class="source-code">     {</p>
			<p class="source-code">            DialogueText.text = lastDialogue;</p>
			<p class="source-code">     }</p>
			<p>With the updated ink template from the first section and the introduction of the <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes in this section, two more parts are needed:</p>
			<ul>
				<li>Quests need to be based on compiled JSON files</li>
				<li>Players need to be able to toggle which quest they are progressing</li>
			</ul>
			<p>In the<a id="_idIndexMarker439"/> next <a id="_idIndexMarker440"/>section, we <a id="_idIndexMarker441"/>will <a id="_idIndexMarker442"/>start with the first part by learning how to read files and creating a new <strong class="source-inline">Quest</strong> class per file found. </p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Organizing multiple quest files</h2>
			<p>In the <a id="_idIndexMarker443"/>previous examples in this book, a single ink file was used per project. This section will break away from that pattern. To track multiple quests, we will define each quest in its own file and then read the compiled JSON files. The <strong class="source-inline">Quest</strong> class, which we looked at in the previous section, will hold the contents and expose some of the values in each file. The <strong class="source-inline">Dialogue</strong> class will create the options the player will see based on the <strong class="source-inline">Quest</strong> class's values. First, however, we will need to read the files.</p>
			<p>This book follows the recommended naming convention of Unity folders and has placed all the Ink files in a folder named <strong class="source-inline">Ink</strong>. Using the <strong class="bold">Compile All Ink Automatically</strong> option in the <strong class="bold">Project Settings</strong> window, each created ink file will also contain a JSON file:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="Images/Figure_11.1_B17597.jpg" alt="Figure 11.1 – Compiled JSON files in the Ink folder&#13;&#10;" width="457" height="175"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Compiled JSON files in the Ink folder</p>
			<p>Because Unity can run on many different operating systems, it exposes the <strong class="source-inline">Assets</strong> folder (shown in the <strong class="bold">Project</strong> window) as part of a global property named <strong class="source-inline">Application.dataPath</strong>. This is the <em class="italic">path</em> to the data, as part of the currently running application. Based on this value, any additional folders can be found, and their files can be<a id="_idIndexMarker444"/> accessed:</p>
			<p class="source-code">void GetFiles()</p>
			<p class="source-code">{</p>
			<p class="source-code">     <strong class="bold">string inkPath = Application.dataPath + "/Ink/";</strong></p>
			<p class="source-code">     foreach(string file in Directory.GetFiles(inkPath,</p>
			<p class="source-code">       "*.json"))</p>
			<p class="source-code">     {</p>
			<p class="source-code">           <strong class="bold">string contents = File.ReadAllText(file);</strong></p>
			<p class="source-code">           <strong class="bold">quests.Add(new Quest(contents));</strong></p>
			<p class="source-code">     }  </p>
			<p class="source-code">}</p>
			<p>By using the <strong class="source-inline">Application.dataPath</strong> property, each compiled ink file (JSON file) can be read, and a new object based on the <strong class="source-inline">Quest</strong> class is created. This not only allows each quest to operate independently of each other via their quest progression, but it also exposes values that the <strong class="source-inline">Dialogue</strong> class can use to present different options to the player.</p>
			<p>In the next and final section, we will write some code that will allow a player to toggle between which quest is active for them and see the <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes in action.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Toggling quests</h2>
			<p>In Unity, the <strong class="source-inline">Toggle</strong> game <a id="_idIndexMarker445"/>object allows a user to select a single item among a group of items. For its usage in the project that's part of this section, a <strong class="source-inline">Toggle</strong> prefab must be created. Like the usage of <strong class="source-inline">Button</strong> game objects, these are created as needed. As each <strong class="source-inline">Toggle</strong> game object is based on an object using the <strong class="source-inline">Quest</strong> class, this means the <strong class="source-inline">GetFiles()</strong> method (shown in the previous section, <em class="italic">Organizing multiple quest files</em>) is run first, and the resulting quests are used to make the <strong class="source-inline">Toggle</strong> game<a id="_idIndexMarker446"/> objects:</p>
			<p class="source-code">void CreateQuestToggles()</p>
			<p class="source-code">{</p>
			<p class="source-code">      foreach(Quest q in quests)</p>
			<p class="source-code">      {</p>
			<p class="source-code">     <strong class="bold">Toggle questToggle = Instantiate(QuestTogglePrefab, </strong></p>
			<p class="source-code"><strong class="bold">       QuestPanel.transform);</strong></p>
			<p class="source-code">     <strong class="bold">questToggle.group =QuestPanel.GetComponent</strong></p>
			<p class="source-code"><strong class="bold">       &lt;ToggleGroup&gt;();</strong></p>
			<p class="source-code">            </p>
			<p class="source-code">     Text questToggleText = questToggle</p>
			<p class="source-code">       .GetComponentInChildren&lt;Text&gt;();</p>
			<p class="source-code">     questToggleText.text = q.Name;</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">CreateQuestToggles()</strong> method references a component named <strong class="source-inline">ToggleScript</strong>. This is a <strong class="source-inline">Script</strong> component that is part of each <strong class="source-inline">Toggle</strong> prefab. Each time one is created, its values are set:</p>
			<p class="source-code">ToggleScript ts = questToggle.GetComponent&lt;ToggleScript&gt;();</p>
			<p class="source-code"><strong class="bold">ts.quest = q;</strong></p>
			<p class="source-code"><strong class="bold">ts.DialogueText = DialogueText;</strong></p>
			<p class="source-code"><strong class="bold">ts.ButtonPrefab = ButtonPrefab;</strong></p>
			<p class="source-code"><strong class="bold">ts.OptionsPanel = OptionsPanel;</strong></p>
			<p class="source-code"><strong class="bold">ts.ProgressPanel = ProgressPanel;</strong></p>
			<p class="source-code"><strong class="bold">ts.ProgressButtonPrefab = ProgressButtonPrefab;</strong></p>
			<p>This process, starting with the <strong class="source-inline">GetFiles()</strong> method, creates objects based on the <strong class="source-inline">Quest</strong> class first. Next, <strong class="source-inline">Toggle</strong> prefabs are created, and values are passed to its <strong class="source-inline">Script</strong> component. Internally, the <strong class="source-inline">Toggle</strong> prefab creates an additional <strong class="source-inline">Script</strong> component based on the <strong class="source-inline">Dialogue</strong> class:</p>
			<p class="source-code"><strong class="bold">dialogue = gameObject.AddComponent&lt;Dialogue&gt;();</strong></p>
			<p class="source-code">dialogue.quest = quest;</p>
			<p class="source-code">dialogue.DialogueText = DialogueText;</p>
			<p class="source-code">dialogue.ButtonPrefab = ButtonPrefab;</p>
			<p class="source-code">dialogue.OptionsPanel = OptionsPanel;</p>
			<p>The reason for<a id="_idIndexMarker447"/> this multiple-step process of creating objects based on the <strong class="source-inline">Quest</strong> class, and then leading to the <strong class="source-inline">Dialogue</strong> class, is to allow each <strong class="source-inline">Toggle</strong> prefab to control what is shown to the player:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="Images/Figure_11.2_B17597.jpg" alt="Figure 11.2 – Quest selection and options shown to the player&#13;&#10;" width="629" height="485"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Quest selection and options shown to the player</p>
			<p>Upon clicking on a <strong class="source-inline">Toggle</strong> prefab, its object is enabled based on the <strong class="source-inline">Dialogue</strong> class, showing the current text and options to the player. These, in turn, are based on the <strong class="source-inline">Quest</strong> class's values, as passed to the <strong class="source-inline">Dialogue</strong> class.</p>
			<p>The combined effect of the code is to create separate quests. Depending on which is active, as determined by each <strong class="source-inline">Toggle</strong> prefab selected by the player, they will see different dialogue options and be presented with the ability to progress each quest independently of each other at the end of each step. This combines the ink template that we created in the first section with a multiple-quest approach, as shown in this section, which uses multiple files and adds the ability to progress across individual quests, independent of each other.</p>
			<p>In the next section, we will examine how to award player progression by passing information <a id="_idIndexMarker448"/>between quests. This will build on the project we created for this section and the concepts from the first section.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Displaying and awarding player progression</h1>
			<p>In <a id="_idIndexMarker449"/>programming, there<a id="_idIndexMarker450"/> are two approaches to accessing values in one system from another: <strong class="bold">polling</strong> and <strong class="bold">events-based</strong>. Either <a id="_idIndexMarker451"/>a value can be checked if it has changed (<em class="italic">polling</em>) or<a id="_idIndexMarker452"/> one system can wait for a message (<em class="italic">event</em>) from the other to signal that a value has changed. Because the second system must wait for an event to happen, this is <a id="_idIndexMarker453"/>often known as the <strong class="bold">observer pattern</strong> because the second system is <em class="italic">observing</em> events.</p>
			<p>In the first section, we saw an example of polling in action. Each time a step of the quest came to its end, the Unity code checked (<em class="italic">polled</em>) the ink values to see if it should show a <strong class="source-inline">Button</strong> game object and allow the player to progress the quest. The second section moved us closer to an events-based approach, where the <strong class="source-inline">ObserveVariable()</strong> method was used within the <strong class="source-inline">Quest</strong> class. In the second project, whenever the <strong class="source-inline">end</strong> ink variable changed, it updated the <strong class="source-inline">End</strong> property of the <strong class="source-inline">Quest</strong> class in Unity. As this value (the <strong class="source-inline">End</strong> property) was used as part of determining whether the quest could progress, this made the second project more dynamic than the one that was used in the first project.</p>
			<p>To award a player for completing a quest or achieving some outcome as part of one quest in another, information needs to be passed between them. Because the ink runtime already supports an events-based approach via its <strong class="source-inline">ObserveVariable()</strong> and <strong class="source-inline">ObserveVariables()</strong> named methods, this makes the process slightly easier. However, as we introduced in the previous section, using a <strong class="source-inline">Quest</strong> class means each ink story is now independent of each other.</p>
			<p>In this section, we will start by creating a way for each <strong class="source-inline">Quest</strong> class to share changes as they happen while a player is progressing them. We will end by learning how to show the player this information as they complete different quests.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The<a id="_idIndexMarker454"/> completed <a id="_idIndexMarker455"/>project for this section can be found in the <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a><em class="italic"> examples on GitHub</em> folder, under the name <em class="italic">Chapter11-TrackingQuests</em>. Only select parts of the code will be shown as they relate to the concepts examined in the sections of this topic.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Tracking quest values</h2>
			<p>The <strong class="source-inline">Story</strong> class <a id="_idIndexMarker456"/>method, <strong class="source-inline">ObserveVariables()</strong>, can track different <a id="_idIndexMarker457"/>variables based on their names. However, the existing ink template contains the variables it uses to track progression. This means that the first step of tracking quest values is to make a list of variables to exclude from tracking as part of an expanded <strong class="source-inline">Quest</strong> class:</p>
			<p class="source-code">public Story InkStory;</p>
			<p class="source-code">public string Name;</p>
			<p class="source-code">public string Description;</p>
			<p class="source-code">public bool End;</p>
			<p class="source-code"><strong class="bold">public List&lt;string&gt; excludeVariables = new List&lt;string&gt;(){ "step", "steps", "name", "end" };</strong></p>
			<p>Next, all the variables contained in the <strong class="source-inline">variablesState</strong> property, excluding those in the created list used to track quest progression, need to be tracked. This means that for each variable, it can be added to a separate list to be passed to the <strong class="source-inline">Story</strong> method known as <strong class="source-inline">ObserveVariables()</strong>. This can be part of the <strong class="source-inline">ObserveVariables()</strong> method, as part of the <strong class="source-inline">Quest</strong> method, so that it matches the one on the <strong class="source-inline">Story</strong> class:</p>
			<p class="source-code"><strong class="bold">public void ObserveVariables(Story.VariableObserver callback)</strong></p>
			<p class="source-code">{</p>
			<p class="source-code">      List&lt;string&gt; variables = new List&lt;string&gt;();</p>
			<p class="source-code">      foreach(string n in InkStory.variablesState)</p>
			<p class="source-code">     {</p>
			<p class="source-code">           if(!excludeVariables.Contains(n))</p>
			<p class="source-code">           {</p>
			<p class="source-code">                variables.Add(n);</p>
			<p class="source-code">           }</p>
			<p class="source-code">     }</p>
			<p class="source-code">     <strong class="bold">InkStory.ObserveVariables(variables, callback);</strong></p>
			<p class="source-code">}</p>
			<p>The <a id="_idIndexMarker458"/>new <strong class="source-inline">ObserveVariables()</strong> method that was added<a id="_idIndexMarker459"/> to the <strong class="source-inline">Quest</strong> class accepts a single parameter, <strong class="source-inline">Story.VariableObserver</strong>. Internally, the <strong class="source-inline">Story</strong> class defines a <strong class="source-inline">delegate</strong> method called <strong class="source-inline">VariableObserver</strong>. Using the same type for the new method allows other methods to be passed through the <strong class="source-inline">Quest</strong> method to the <strong class="source-inline">Story</strong> method of the same name. In other words, the new method works the same as the existing one, but it will exclude a specific list of variable names.</p>
			<p>While observing variables, there also needs to be a way to update the values of variables across all quests whenever a value changes in one. Using the existing <strong class="source-inline">variablesState</strong> property, a new method can be added to the <strong class="source-inline">Quest</strong> class named <strong class="source-inline">UpdateVariable()</strong>:</p>
			<p class="source-code">public void UpdateVariable(string name, object value)</p>
			<p class="source-code">{</p>
			<p class="source-code">        <strong class="bold">if(InkStory.variablesState.GlobalVariableExistsWith</strong></p>
			<p class="source-code"><strong class="bold">          Name(name))</strong></p>
			<p class="source-code">     {</p>
			<p class="source-code"><strong class="bold">          if (!InkStory.variablesState[name].Equals(value))</strong></p>
			<p class="source-code">           {</p>
			<p class="source-code">                InkStory.variablesState[name] = value;</p>
			<p class="source-code">           }</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>Inside the <strong class="source-inline">UpdateVariable()</strong> method<a id="_idIndexMarker460"/> are two important <a id="_idIndexMarker461"/>checks. The first uses the <strong class="source-inline">GlobalVariableExistsWithName()</strong> method. This method checks if a variable exists. Without this check, if one quest added a variable another did not have, the entire project could crash. The second check verifies whether the variable to be updated does not already have the same value. Without this second check, updating a variable would trigger a variable change in any other quests, which would trigger another update. This would eventually cause a crash as quests would be trying to update each other in an endless loop.</p>
			<p>Between the two new methods, <strong class="source-inline">ObserveVariables()</strong> and <strong class="source-inline">UpdateVariable()</strong>, one more part is needed: the two methods must be combined. Based on the project from the second section, <em class="italic">Tracking progress across multiple quests</em>, the <strong class="source-inline">InkStoryScript</strong> code is the best place to add this combination. The reason for this placement is because this will allow each quest to be configured as part of the existing loop:</p>
			<p class="source-code">foreach(Quest q in quests)</p>
			<p class="source-code">{</p>
			<p class="source-code">     <strong class="bold">q.ObserveVariables((name, value) =&gt;</strong></p>
			<p class="source-code">     <strong class="bold">{</strong></p>
			<p class="source-code">          <strong class="bold">UpdateAllQuests(name, value);</strong></p>
			<p class="source-code">     <strong class="bold">});</strong></p>
			<p class="source-code">}</p>
			<p>This new code references an additional method, <strong class="source-inline">UpdateAllQuests()</strong>. When passed the name of a variable and its value, this new method works through the existing quests and updates their values by calling <strong class="source-inline">UpdateVariable()</strong> per quest:</p>
			<p class="source-code">void UpdateAllQuests(string name, object value)</p>
			<p class="source-code">{</p>
			<p class="source-code">     foreach (Quest q in quests)</p>
			<p class="source-code">     {</p>
			<p class="source-code">            <strong class="bold">q.UpdateVariable(name, value);</strong></p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>In this<a id="_idIndexMarker462"/> section, we <a id="_idIndexMarker463"/>have defined multiple new methods. We added two to the <strong class="source-inline">Quest</strong> class called <strong class="source-inline">ObserveVariables()</strong> and <strong class="source-inline">UpdateVariable()</strong>. These detect changes using the event approach. ink will signal to Unity when a variable in one of the quests changes. We also added code to <strong class="source-inline">InkStoryScript</strong> by using a new method called <strong class="source-inline">UpdateAllQuests()</strong>, which will update the same variable in other quests.</p>
			<p>In the next section, we will finalize this project. Detecting changes and updating other quests help keep all of them updated as changes happen. Next, we need to show data to the player as changes happen.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Showing player progress</h2>
			<p>In the <a id="_idIndexMarker464"/>previous section, we created the necessary code to keep all the variables used across quests updated. To show the player this data, we must add a new game object named <strong class="source-inline">StatisticsText</strong>. Next, we need to use a special keyword in C#: <strong class="source-inline">static</strong>.</p>
			<p>Any method or property using the <strong class="source-inline">static</strong> keyword in C# exists outside of any instances of the class. This means that the property can be accessed or the method can be called anywhere in the project. However, this comes with a major caveat: any <strong class="source-inline">static</strong> method can only access <strong class="source-inline">static</strong> properties. To allow another class (<strong class="source-inline">Dialogue</strong>) to be able to call a <strong class="source-inline">static</strong> method in <strong class="source-inline">InkStoryScript</strong> (which holds all the quests), the existing <strong class="source-inline">quests</strong> and new <strong class="source-inline">StatisticsText</strong> variable must both use the <strong class="source-inline">static</strong> keyword:</p>
			<p class="source-code">public GameObject QuestPanel;</p>
			<p class="source-code">public Toggle QuestTogglePrefab;</p>
			<p class="source-code">public Text DialogueText;</p>
			<p class="source-code">public Button ButtonPrefab;</p>
			<p class="source-code">public GameObject OptionsPanel;</p>
			<p class="source-code">public GameObject ProgressPanel;</p>
			<p class="source-code">public Button ProgressButtonPrefab;</p>
			<p class="source-code"><strong class="bold">public static GameObject StatisticsText;</strong></p>
			<p class="source-code"><strong class="bold">static List&lt;Quest&gt; quests;</strong></p>
			<p>With the <strong class="source-inline">quests</strong> and <strong class="source-inline">StatisticsText</strong> properties, they can be<a id="_idIndexMarker465"/> accessed by a new method named <strong class="source-inline">ShowStatistics()</strong>:</p>
			<p class="source-code">public static void ShowStatistics()</p>
			<p class="source-code">{</p>
			<p class="source-code">     StatisticsText = </p>
			<p class="source-code">       GameObject.Find("/Canvas/Right/StatisticsText");</p>
			<p class="source-code">     Dictionary&lt;string, object&gt; vars = new</p>
			<p class="source-code">       Dictionary&lt;string, object&gt;();</p>
			<p class="source-code">     foreach (Quest q in quests)</p>
			<p class="source-code">     {</p>
			<p class="source-code">           foreach(string s in q.InkStory.variablesState)</p>
			<p class="source-code">           {</p>
			<p class="source-code">                if(!vars.ContainsKey(s) &amp;&amp;</p>
			<p class="source-code">                  !q.excludeVariables.Contains(s))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                      vars.Add(s,</p>
			<p class="source-code">                        q.InkStory.variablesState[s]);</p>
			<p class="source-code">                }</p>
			<p class="source-code">           }</p>
			<p class="source-code">     }</p>
			<p class="source-code">     Text stats = StatisticsText.GetComponent&lt;Text&gt;();</p>
			<p class="source-code">     stats.text = "";</p>
			<p class="source-code">      foreach (KeyValuePair&lt;string, object&gt; entry in vars)</p>
			<p class="source-code">      {</p>
			<p class="source-code">           stats.text += entry.Key + ": " + entry.Value +</p>
			<p class="source-code">             "\n";</p>
			<p class="source-code">      }</p>
			<p class="source-code">}</p>
			<p>The new <strong class="source-inline">ShowStatistics()</strong> method uses a <strong class="source-inline">Dictionary&lt;string, object&gt;</strong>. This<a id="_idIndexMarker466"/> combines the name of the variable (<strong class="source-inline">string</strong>) with its value (<strong class="source-inline">object</strong>). However, a <strong class="source-inline">Dictionary</strong> in C# comes with an obstacle: it can only contain unique keys. In the <strong class="source-inline">ShowStatistics()</strong> method, the use of the <strong class="source-inline">ContainsKey()</strong> method prevents this issue.</p>
			<p>To set up a method that can be called by another class, the new <strong class="source-inline">ShowStatistics()</strong>code must be placed within the <strong class="source-inline">Dialogue</strong> class as part of its <strong class="source-inline">UpdateContent()</strong> method, after the creation of the <strong class="source-inline">Button</strong> game objects based on the current choices:</p>
			<p class="source-code">foreach (Choice in quest.InkStory.currentChoices)</p>
			<p class="source-code">{</p>
			<p class="source-code">     Button choiceButton = Instantiate(ButtonPrefab,</p>
			<p class="source-code">       OptionsPanel.transform);</p>
			<p class="source-code">     choiceButton.onClick.AddListener(delegate</p>
			<p class="source-code">     {</p>
			<p class="source-code">           quest.InkStory.ChooseChoiceIndex(choice.index);</p>
			<p class="source-code">           UpdateContent();</p>
			<p class="source-code">     });</p>
			<p class="source-code">     Text choiceText =       choiceButton.GetComponentInChildren&lt;Text&gt;();</p>
			<p class="source-code">       choiceText.text = choice.text;</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">InkStoryScript.ShowStatistics();</strong></p>
			<p>The new code will <a id="_idIndexMarker467"/>always show the latest values of the variables as the values are updated. Because each quest handles updating its variables based on an event-based approach, any user action for making choices or selecting a quest will update all the values being tracked by the project and constantly show player progression.</p>
			<p>In this section, we awarded player progression by showing the player's the updated values. We started by adding some code from the previous section to constantly update the variables with the same names across all quests. This keeps all the quests connected. Then, we created a <strong class="source-inline">ShowStatistics()</strong> method to show these values and updated a <strong class="source-inline">Text</strong> game object with their names and values.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Summary</h1>
			<p>We started this chapter by creating an ink template. By defining variables and a <strong class="source-inline">progress</strong> knot in ink, we can move through the various sections of a quest as individual stitches within a larger knot. Next, we looked at the <strong class="source-inline">ChoosePathString()</strong> method, which can forcibly move a story to a new section.</p>
			<p>In the second section, we broke away from single files and developed a <strong class="source-inline">Quest</strong> class. Each object based on the <strong class="source-inline">Quest</strong> class contained an ink <strong class="source-inline">Story</strong> object based on different files and a method named <strong class="source-inline">Progress()</strong>, which calls the <strong class="source-inline">ChoosePathString()</strong> method internally. As part of this section, we learned how the <strong class="source-inline">Quest</strong> and <strong class="source-inline">Dialogue</strong> classes can help organize functionality into different classes.</p>
			<p>Finally, we displayed the name and values of variables. First, we added new methods to detect variable changes in any quest using an events-based approach. This triggered other variables with the same name in other quests to have their values updated. Then, we added the <strong class="source-inline">ShowStatistics()</strong> method to display these updating values.</p>
			<p>In the next chapter, <a href="B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a>, <em class="italic">Procedural Storytelling with ink</em>, we will review the basics of procedurally organizing different story sections and content. While looking at two approaches, either coding values in ink or loading data into ink dynamically, we will examine when one approach might be better, depending on the context.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Q&amp;A</h1>
			<ol>
				<li>What is a quest?</li>
				<li>What is the name of the knot that's used to progress a quest based on the ink template shown in this chapter?</li>
				<li>How does the <strong class="source-inline">ChoosePathString()</strong> method work?</li>
				<li>What is the name of the global property where Unity records the path for the data of the application?</li>
				<li>What is the difference between polling and events-based approaches?</li>
			</ol>
		</div>
	</div></body></html>