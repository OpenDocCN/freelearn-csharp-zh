- en: Performing Symmetric and Asymmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on distributed applications, it is very important to keep information
    secure, in particular, in the case of eCommerce applications, where user data,
    such as your personal and credit card-related information, is collected and transmitted
    over the internet. Cryptography enables us to encrypt and decrypt plain text.
    To understand it in simple terms, let's suppose that there is plain text in our
    application that can be transformed by adding a static value to each character
    in the text, thereby rendering it non-readable. This process is called **encryption**.
    Conversely, decryption is the process of transforming this unreadable text back
    into readable text.
  prefs: []
  type: TYPE_NORMAL
- en: When you encrypt text, it looks like random bytes, and is called **cipher-text**.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to understand how to encrypt and
    decrypt text, the different algorithms that are available to perform these encrypt
    and decrypt operations, and the options that .NET Framework affords us in terms
    of their application to actual projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asymmetric encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and
    above require Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of the products, you can download the community
    version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with public networks involved with creating and managing web applications
    that are accessible over the internet, your application is at high risk of being
    intercepted and modified by unauthorized parties. Cryptography allows us to protect
    data from such unauthorized parties from being viewed or modified. Cryptography
    also provides ways to protect our data and assists in the transfer of data securely
    over the network. To perform such operations, we can use encryption algorithms
    to create cipher data prior to transmission. When intercepted by unauthorized
    parties, it will be difficult for them to decrypt this in order to read or modify
    this data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform such operations, .NET framework is shipped with the `System.Secure.Cryptography`
    namespace, which comes with many algorithms, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Secret key encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public key encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's jump into an example regarding where cryptography can be used. Suppose,
    as a customer, that I am trying to place an order for a laptop over the internet.
    For this, I am chatting with the company's representative. Once I am sufficiently
    satisfied with the quote, the discount offered, and the terms and conditions to
    place an order, I then need to provide personal and credit card information via
    this channel.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we ensure the following in this regard?
  prefs: []
  type: TYPE_NORMAL
- en: That this information is unclear for anyone listening in on our conversation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That there was no unauthorized access to the information transferred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the information received is from the company's representative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this can be achieved with the implementation of cryptographic algorithms.
    These algorithms facilitate confidentiality, data integrity, authentication, and
    non-repudiation.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality protects the identity of users, data integrity protects data
    from being changed, authentication ensures that data is from an authenticated
    party, and non-repudiation prevents any party from denying that a message was
    sent.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework provides different algorithms, as mentioned earlier. Although
    these are numerous, we will limit our discussion to four major ones in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Secret-key encryption, which is also referred to as symmetric encryption, uses
    a single shared key to encrypt and decrypt data. In this regard, however, it is
    important to keep the secret information safe from unauthorized access because
    anyone in possession of this key can then access the data and misuse it. Because
    it uses the same key for both encryption and decryption, this works faster and
    is suitable for large amounts of data. There are different types of algorithm
    available, such as **DES** (short for **Data Encryption Standard**), triple DES,
    and **AES** (short for **Advanced Encryption Standard**). These algorithms encrypt
    blocks of data simultaneously, so they are also referred to as block ciphers.
    DES and Triple DES use 8 bytes as a block, while AES uses 16 bytes as a block,
    but also supports 24 and 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Public-key encryption, also referred to as asymmetric encryption, uses public/private
    keys to encrypt and decrypt data. Of these two keys, the private key must be kept
    secret from unauthorized access, as anyone with the private key can access your
    data. Public and private keys in this encryption technique are mathematically
    linked and use a fixed buffer size. These are slow compared to secret key encryption,
    and are useful for encrypting small amounts of data. Any data encrypted using
    a public key can only be decrypted using a private key. Also, if you sign data
    using a private key, it can only be verified using a public key.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signing uses digital signatures that are unique to that party. As mentioned
    in public key encryption, a party can sign the data using a private key and, when
    the other party receives information and when the public key of the sending party
    is trusted, you can identify who sent the message and, in turn, maintain the integrity
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Since the public key of the sending party is public, anyone in possession of
    the public key can process the message, meaning that your message is not secret.
    To keep it secret, you also need to encrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: Hash values map data of any length to a fixed-length byte sequence. When you
    have a block of text and change it prior to rehashing, it will produce a new hash.
    This way, we can maintain data integrity during transfer.
  prefs: []
  type: TYPE_NORMAL
- en: However, as has been discussed in relation to other cryptographic methods, this
    method does not authenticate the sender of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symmetric encryption uses a single key and works on blocks of text. This method
    works quicker than others. While using this method, it is important to maintain
    the confidentiality of the secret key, and both the sender and receiver should
    use the same key, which is a disadvantage of this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example and understand how we can encrypt a message or block
    of text:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use the encrypt method, where we read a block of text from a file,
    encrypt it using a symmetric algorithm, and write the encrypted content to a different
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The encrypt method accepts an instance of `SymmetricAlgorithm`, which is used
    to create an instance of `ICryptoTransform` by passing a key and initial vector.
    The system allows you to generate your own key or use the one it generates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we create a memory stream to store the buffer at runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A cryptostream is created using the memory stream, `ICryptoTransform`, along
    with the write mode. A cryptostream is used to write to memory, which can then
    be converted into an array and written to an output file.
  prefs: []
  type: TYPE_NORMAL
- en: Once you execute the encrypt method, you can now open the output file from the
    solution and check the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will read the data from the output file and decrypt it to plain text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The decrypt method uses the same signature as the encrypt method. However, instead
    of creating an `encryptor` class, we create a `decryptor` class, which implements
    the `ICryptoTransform` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the main program, where we create `SymmetricAlgorithm` of
    the `AESManaged` instance type, and then pass it to the encrypt and decrypt methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before executing the program, check the input file in the solution where you
    can change the content and execute it. Following encryption, the output file in
    the solution can be verified for the encrypted content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e6106fb-9c05-4d06-8682-c8aff8eb3d9e.png)'
  prefs: []
  type: TYPE_IMG
- en: When you practice this example, make sure that you have all the helper methods
    in one class, and the main method in another class, as specified in the sample
    code on GitHub. Now that you have all the methods, when you execute them, you
    see the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: Your encryption method uses the AES algorithm. It reads data from the input
    file, encrypts data using the AES algorithm, and then writes a message on the
    screen. Once you press any key, your decrypt method is initiated, decrypts the
    message, and writes to the output file. The same message is displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-time scenario, when you want to perform secure transactions using
    file transfers, this is one way to do so. Because you will be using symmetric
    algorithms, it will be easy to encrypt or decrypt the content.
  prefs: []
  type: TYPE_NORMAL
- en: A sender encrypts the content of the file and sends it to the receiver. The
    receiver decrypts the file content and processes it. In this method, both the
    sender and receiver should be aware of the key used.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asymmetric encryption uses two keysâ€”a public key and a private key. Because
    of this, it runs bit slowly. Also, it is necessary to keep the private key safe
    at all times. Unless you have the private key, you cannot decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s jump into an example and try to understand how this is done. In
    this scenario, we will be using `RSACryptoServiceProvider`. This algorithm provides
    us with public and private keys that can be used to encrypt and decrypt messages.
    The encrypt method accepts a public key and text to encrypt, and we then convert
    the text to a byte array since the encrypt method accepts byte arrays. Then, we
    set the public key for the algorithm and invoke the encrypt method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the decrypt method, we pass the byte array that needs to be decrypted along
    with a private key. Once a message is encrypted using a public key, it can only
    be decrypted using its corresponding private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the main method, where we create the `RSACryptoproviderservice`
    class to get public and private keys. `rsa.ToXmlString(false)` provides a public
    key, and setting it to `true` will give us a private key. We will use these keys
    to encrypt and decrypt messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program by changing the input text, or you can try changing the
    algorithm. However, when you change the algorithm, you may need to apply any syntactical
    changes that are required in order for the program to run and work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/133e0fd4-14f3-414a-8909-1289f9e6d1db.png)'
  prefs: []
  type: TYPE_IMG
- en: When you execute the program, you see the preceding output. In the sample, you
    are using an asymmetric algorithm to encrypt content. As the control flows through
    the code, it display messages. Once the message is encrypted, it will ask you
    to press any key. Upon pressing any key, the program decrypts the message and
    displays it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario that we discussed under symmetric algorithms, where you want
    to perform secure transactions between two parties, you can use public-private
    key combinations.
  prefs: []
  type: TYPE_NORMAL
- en: A receiver performs encryption using a private key and sends the file or block
    of text to the receiver, where a public key is used to decrypt the content. In
    the event the public-private keys do not match, you cannot read or validate the
    data. This is one way to validate input data.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital signatures can be used to sign the message that will authenticate the
    sender. However, signing a message doesn't prevent a third party from reading
    the message. To achieve this, we need to encrypt the message and sign it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are using a public key and a private key (asymmetric
    algorithm). We use the sender's private key to sign the message and the receiver's
    public key to encrypt the message. If you observe the code, we also use hash computing
    in this example. After encrypting the message, we hash the message.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use `RSACryptoServiceProvider`, along with `RSAPKCS1SignatureFormatter`,
    which will be used to create a signature.
  prefs: []
  type: TYPE_NORMAL
- en: In the following program, we convert text to a byte array using `UnicodeEncoding`
    classes, encrypt the message using the receiver's public key and the symmetric
    or asymmetric algorithms we learned in previous sections, compute the hash of
    the content, and then digitally sign the message. Once all of these processes
    have been implemented, we transmit the data across, where we recompute the hash,
    verify the signature, and then decrypt the message using the keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are using public-private keys to perform encryption.
    As mentioned previously, simply signing the message doesn''t secure the content
    of the message. Instead, it will allow you to authenticate the sender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The following is the main program, where we create an instance of the `RSACryptoServiceProvider`
    class and collect public and private keys. However, as we are encrypting and decrypting
    the message in the same method, a single set of public and private keys was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this example, we perform both encryption and decryption. We can
    create multiple RSA providers and use their public-private keys for senders and
    receivers. You can create different console applications, one as a sender and
    the other as a receiver, and simulate a real-world scenario. For simplicity''s
    sake, I have used one pair of public-private keys to perform operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the output by changing the input message and algorithms. However, as
    said earlier, you may need to take care of any syntactical changes before executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c7417d1-6458-4e10-96b3-5291bbeba425.png)'
  prefs: []
  type: TYPE_IMG
- en: In a real-world scenario, suppose two entities are communicating via web services
    where such digital signatures are implemented. The sender will have a set of public
    and private keys, and the receiver will have public and private keys. Both parties
    should exchange their respective public keys to facilitate application communication.
  prefs: []
  type: TYPE_NORMAL
- en: Hash values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computing a hash creates a fixed-length numeric value from a byte array. A hash
    maps a variable-length binary string to a fixed-length binary string. A hash cannot
    be used for two-way conversion. When you apply a hash algorithm, each character
    gets hashed into a different binary string.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we use the `SHA1Managed` algorithm to compute the
    hash. We compute the hash twice to check whether the result is the same. As mentioned
    earlier, this method is used to maintain data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are using the `UnicodeEncoding` class to convert
    the text to a byte array, and the `SHA1Managed` algorithm to compute the hash
    for the byte array. Once converted, we display each and every hashed byte on the
    screen. To validate the hash, we recompute the hash on the string and compare
    the hash values. This is one way to validate input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main method for invoking the hash value example is as follows. Here, we
    just call the helper method that performs the hash compute on the text provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compute the hash, we display the result and then we undertake a comparison
    to see whether the result from both calls is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e9da11f-81c9-4994-8f5c-cd99d45b3573.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the program where you compute the hash and display
    the hashed array. Also, when the program recomputes the hash and effects a comparison,
    you see the same hash value message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on understanding cryptography and how we can use
    symmetric and asymmetric algorithms. We also focused on how we can use these to
    validate senders, receivers, and the content of messages. We can use the techniques
    learned in the chapter to validate input data and perform similar operations when
    working with secure transactions. We also looked at how we can sign messages using
    digital signatures, and how can we maintain data integrity using hash values.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on .NET assemblies, how we can manage them,
    and how we can debug C# applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the four methods discussed in this chapter, which two can be used to
    authenticate the sender?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Symmetric algorithm
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Asymmetric algorithm
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash values
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Digital signatures
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When two parties need to communicate using an asymmetric algorithm, which key
    do they need to share?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Private key
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Public key
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type of algorithm is used to encrypt large amounts of data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Symmetric
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Asymmetric
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Digital signatures**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Public key**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Symmetric**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
