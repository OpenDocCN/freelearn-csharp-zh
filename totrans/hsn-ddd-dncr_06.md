# 使用命令执行操作

在上一章中，我们讨论了一个简单领域模型的实现过程。该模型有一个实体，以及几个值对象和领域服务。该模型仅代表我们系统的一个领域，我们故意将其他所有内容排除在范围之外。我们讨论了领域模型项目需要如何与其他内容隔离，以及领域服务虽然可以在应用层实现，但也可以成为模型的一部分。现在，我们将学习如何将我们的领域模型付诸实践。到目前为止，我们还没有在任何地方引用领域模型，这使得它相当无用。为了开始在应用中使用模型，我们需要能够调用模型。此外，我们还需要能够持久化模型中发生的所有更改，以防止我们丢失系统状态。

本章将涵盖以下主题：

+   应用层——洋葱架构的外层边缘

+   从Web API调用领域模型

+   持久化领域模型更改

# 技术要求

除了[第5章](034423e8-8080-4073-bd08-b98a129384a4.xhtml)中关于*实现模型*的技术要求之外，您还需要安装Docker，因为我们将使用容器来运行必要的基础设施组件，例如数据库。Docker支持所有流行的平台，包括Windows、macOS和Linux。如果您需要了解更多关于如何安装Docker的信息，请参阅Docker安装文档([https://docs.docker.com/install/](https://docs.docker.com/install/))。

# 领域模型之外

我们努力保持领域模型不受与基础设施、持久化、执行和通信相关内容的干扰。这使得领域模型纯净，并使其专注于业务。然而，我们仍然需要创建围绕它的整个系统，保持领域模型作为系统核心。

运行时环境的整个世界围绕着我们的领域模型，在本节中，我们将剖析构建一个适当系统所需的所有必要组件，并查看这些组件需要如何相互绑定，以及如何与领域模型绑定在一起。

# 公开Web API

我们的系统需要向用户提供一些可见性，因此，在某个时候，我们将需要构建一个用户界面。这个主题将在我们继续前进时进行讨论，但现在是时候能够以某种方式公开我们的应用，以便未来的UI可以建立在它之上。我们预计我们的系统将拥有多个UI。考虑一个**单页Web应用**（SPA）和移动应用。作为这两种类型前端的后端，我们需要构建一个Web API。我会避免使用REST API这个术语，因为它远不止是一个简单的Web API，我们也不会深入探讨这个主题。相反，我们将专注于通过HTTP调用我们的领域模型，以执行一些有用的操作。

首先，让我们创建一个 ASP.NET Web API 控制器，我们将在这里放置一些 HTTP 端点处理器。为了做到这一点，我们需要在我们的 `Marketplace` 项目中添加一个类，因为现在我们不会在领域模型内部工作，而是在模型外部工作。

在我们添加控制器之前，让我们创建一个名为 `Api` 的项目文件夹，将所有控制器和相关服务放在一个地方。稍后我们将在应用程序项目中添加不同类型的组件，因此最好从一开始就保持整洁。

# 公共 API 契约

要服务 HTTP 请求，我们需要的不仅仅是控制器。控制器需要接受强类型请求，这些请求的集合将是我们公共 API 以及这些请求的模型。让我们准备一个放置这些模型的地方，并在应用程序项目中创建一个名为 `Contracts` 的文件夹。

契约是 **数据传输对象**（**DTOs**）和 **普通的** **C# 对象**（**POCOs**）。这意味着它们没有逻辑，它们只包含原始类型，并且不需要任何技巧来进行序列化和反序列化。实际上，你可以在你的 DTO 中添加复杂类型，仅仅是因为某些复杂类型在许多契约中使用。这种类型的例子可以是 `Address` 类型。

假设我们有一个以下契约类的示例：

[PRE0]

使用复杂类型而不是分别列出两个地址的所有属性，非常方便。在我们添加一个名为 `Address` 的新类型之后，我们的契约将变得更加紧凑：

[PRE1]

请注意，复杂类型会增加兼容性问题，因为当你更改类型时，所有使用该类型的契约也将更改，并且这种更改将是隐式的。由于你没有内部消费者使用此契约，你将无法看到使用此契约的客户端是否会受到影响。此类信息只能通过测试获得。

说到更改，请记住，你发布在开发机器之外的所有内容都被认为是公共的。公共 API 是任何具有适当权限的人都可以使用的东西。实际上，这意味着你不再控制谁在使用你的 API。因此，发布 API 的任何更改都可能潜在地破坏系统或其他系统的其他部分。公共契约的更改需要谨慎处理，因为既有非破坏性更改，也有破坏性更改。

POCO 类型的一些更改被认为是非破坏性的，例如以下更改：

+   改变属性类型，以便任何之前使用的类型值都可以序列化到新类型。例如，我们可以将属性从整数更改为字符串，并且它将是兼容的。

+   添加一个新属性也被视为一种非破坏性更改。这是因为当我们尝试反序列化一个没有这个新属性的 XML 或 JSON 对象时（因为发送者尚未更新他们的合约），大多数流行的序列化器都会接受它，并且如果未提供值，将使用默认值。

我们软件在不断发展，当然，我们并不总是能够做出非破坏性更改。这意味着我们应该准备好做出破坏性更改。我们已经讨论了公共 API 是一旦公开就默认共享的东西。因此，我们需要确保当我们做出破坏性更改时，所有使用旧 API 的人都不会遇到异常，并且能够像以前一样工作，至少在一段时间内。这是通过**API 版本控制**来实现的。你可能已经遇到了像 GitHub 或 Twitter 这样的流行服务的不同 API 版本。例如，当我写这篇文章的时候，Twitter API 文档告诉我使用这个调用来获取推文的时序：`GET https://api.twitter.com/1.1/statuses/home_timeline.json`。正如你所看到的，它们在 URI 中有`1.1`，这是它们当前的稳定 API 版本。我们可以假设它们还有其他版本，其中一些较旧的版本可能仍在运行和使用。因此，在我们的 API 中，我们也将使用版本化的合约，尽管我们最初并不期望有很多变化。

我们已经知道我们可以对我们的领域执行哪些操作，因此我们可以添加一些合约来从外部世界调用这些操作。让我们创建一个文件，我们将在这里放置我们的第一个合约。我们已经有了一个`Contracts`文件夹，所以我们可以在这个文件夹中创建一个新的 C# 类文件，命名为`ClassifiedAds.cs`。文件就位后，我们可以在那里添加我们的第一个合约：

[PRE2]

在这里，我们使用嵌套的静态类`ClassifiedAds`和`V1`作为命名空间的替代，这样在必要时我们可以在一个文件中拥有更多版本。这种方法允许我们使用静态成员导入来使代码更加简洁。

我们在这里有一个**命令**。我第一次在[第 1 章](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml)，“为什么是领域驱动设计？”，当我们讨论 CQRS 时提到了**命令**。命令允许用户和其他系统在我们的领域模型中执行操作。当一个命令成功处理时，领域模型状态会发生变化，并发出新的领域事件。现在，当我们有一个命令在代码中实现时，我们需要接受来自外部世界的这个命令，我们将使用 HTTP 端点来实现这一点。

# HTTP 端点

由于现在API最明显的通信方法是使用同步HTTP调用，我们将从这里开始。我们将使用ASP.NET Web API。因此，我们需要添加一个控制器来接受我们的命令。让我们在可执行项目的`Api`文件夹中添加一个名为`ClassifiedAdsCommandsApi.cs`的文件，让这个类继承自`Controller`，并添加一个`Post`方法来处理我们在上一节中添加的命令：

[PRE3]

我们目前还没有做任何事情。相反，我们正在创建一个可以接受外部世界命令的web API。我们稍后会添加处理这些命令的代码。记住，这是我们针对HTTP基础设施的适配器，它在洋葱架构的最外层找到其位置。这就是我们称这个层为**边缘**的原因，因为它的外面没有任何我们可以认为是应用一部分的东西。应用可以通过多种方式与外部世界通信，所以如果我们添加了其他边缘，比如消息传递，我们期望这个新的通信适配器能够处理相同的命令。

现在，我们需要向应用程序启动代码中添加更多代码以使web API工作。我们需要对`Program`类做一些事情：

1.  +   构建配置。

    +   配置web宿主。

    +   执行web宿主。

要执行这些操作，我们需要让`Program`类看起来像这样：

[PRE4]

这里目前没有太多的事情发生。我们确保当前目录是可执行文件所在的位置，因为这也是我们可以找到配置文件的地方。然后我们读取配置，从配置中创建并启动web宿主。目前我们没有配置文件，因此没有配置，但稍后我们会添加一些。

现在，我们正在使用`Startup`类来配置服务，它也需要一些关注。在`Startup`类中，我们需要配置web API以便它可以使用我们的控制器。此外，我们需要一种简单的方法来与API交互，而无需任何用户界面。一种既好又简单的方法是使用与Web API集成的Swagger ([https://swagger.io/](https://swagger.io/))。在我们开始使用它之前，我们需要添加一个Swagger Web API集成NuGet包，`Swashbuckle.AspNetCore`。使用新的`.csproj`文件格式，添加集成的最简单方法可能是直接将包引用添加到项目文件中。在这里，您可以看到`Marketplace.csproj`文件的新内容，并且更改被突出显示：

[PRE5]

`Swashbuckle.AspNetCore` 包在您阅读这本书的时候可能版本不同。请使用最新可用的版本。

当您保存项目文件时，您的IDE将安装包并将引用添加到您的项目中。

现在，我们可以更改`Startup`类，以便它注册Web API内部组件、我们的控制器以及所有必要的Swagger生成。我们还添加了一个嵌入式的Swagger UI，这样我们就可以直接从浏览器测试我们的API，而无需任何额外的软件：

[PRE6]

现在一切就绪，我们准备第一次启动应用程序。按下*F5*后，您应该在控制台看到以下内容：

![图片](img/3323e3c0-cb60-4cda-8bb5-71846121e722.png)

应用程序最终运行

现在，让我们在浏览器中打开Swagger UI，访问`http://localhost:5000/swagger`。我们应该看到一个操作（POST），当我们展开它时，以下内容应该出现：

![图片](img/0cb25b4e-48ce-4930-9a4d-8d82bcfcd8ff.png)

Swagger用户界面用于测试API

您可以点击“尝试一下”按钮并向API发送一些请求，但它不会做任何事情，因为我们总是返回`200 OK`响应。

我们已经完成了所有必要的步骤来暴露一个原始的Web API端点，并提供了支持它的引导代码。我们还创建了一个API合约，它代表创建分类广告的命令。现在是时候让这个命令生效了。

# 应用层

边缘部分——在我们的案例中，是一个简单的Web API——接受来自外部世界的请求。我们边缘组件的主要任务是接受一些请求，这些请求以JSON文档、XML文档、通过RabbitMQ的消息或任何其他通信渠道和序列化类型发送；将其转换为命令；然后确保这个命令得到处理。

边缘部分当然可以直接与领域模型工作，但这意味着我们接受这样一个事实，我们总是只与一种边缘类型一起工作，使用一种通信协议。此外，边缘组件通常对通信基础设施有很强的依赖性——虽然这对于集成测试来说是可行的，但为这样的组件编写单元测试可能会具有挑战性。

为了将通信基础设施与实际请求处理隔离开来，我们可以引入应用层。在这个层中，我们需要一个组件来接受来自边缘的命令并使用我们的领域模型来处理这些命令。这样的组件被称为**应用服务**。

如果您参考[第4章](bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml)，*设计模型*，并查看洋葱架构的图片，您将在基础设施和领域模型之间找到应用服务。应用服务对用于从外部发送命令的传输没有依赖性。

然而，服务需要有一种方式来加载和存储实体，因为应用程序服务的典型操作将执行如下命令：

![图片](img/b62dfcda-7863-4220-bcbc-248f4aa5ff68.png)

典型交互流程

在这个流程中存在一些异常。当应用程序服务接收到需要创建新实体的命令时，它不会从实体存储中加载任何内容，因为还没有可以加载的内容。它将创建实体并将其保存到实体存储中。同样，当处理命令需要删除实体时，应用程序服务将加载实体，但不一定将其保存回去。它可能只是从存储中删除这个实体，但这在很大程度上取决于模型。例如，如果业务要求保留所有数据，我们可能只是将实体标记为已删除，然后将更改持久化到实体存储中。

让我们在项目中添加一个新的应用程序服务类并编写一些代码。首先，我们需要在我们的可执行Web API项目的`Api`文件夹中创建一个新的文件。有些人可能会争论应用程序服务不是API的一部分，但到目前为止，我们只有一个边缘，并且没有真正的原因将它们分开。新文件的名称将是`ClassifiedAdApplicationService.cs`，它具有以下代码：

[PRE7]

现在，我们需要从我们的API中调用应用程序服务。我们需要将应用程序服务作为依赖项添加到我们的控制器中，并在启动时，我们将依赖项注册到ASP.NET Core服务定位器中。首先，我们进行注册。由于我们的应用程序服务类还没有依赖项，我们可以使用单例，因此我们在`Startup`类的`ConfigureServices`方法中添加一行：

[PRE8]

当这一切完成之后，我们可以将`ClassifiedAdsApplicationService`类作为依赖项添加到`ClassifiedAdsCommandsApi`控制器中，并从我们的`Post`方法中调用`Handle`方法：

[PRE9]

在下一节中，我们将深入探讨命令处理，包括将实体保存到实体存储和检索它们。我们还将为这些命令添加更多的命令和处理器。

# 处理命令

在上一节中，我们创建了一个简单的Web API并了解到API是应用程序的*边缘*。边缘与外部世界进行通信，并通过HTTP或其他通信协议接受请求。为了执行这些请求，我们需要一个作为边缘组件和领域模型之间中介的*应用程序服务*。应用程序服务还负责持久化实体。

今后，我们将学习更多关于处理命令和持久化的知识。我们还将讨论处理异常和检查传入请求是否有效。

# 命令处理器模式

在CQRS中处理命令有几种方法。一个已建立的模式是使用命令处理器。这并不特定于CQRS，但它被广泛使用，因为它非常合适。命令处理器是一个类，它有一个方法来处理单个命令类型。例如，我们可能有一个这样的命令处理器：

[PRE10]

命令处理器之前使用了两个接口。接口看起来像这样：

[PRE11]

请记住，`IEntityStore`接口是简化的，并不是所有持久化方法都可以通过这样的接口表示。

请不要误解，我并不是试图在你的脑海中播种通用仓库的想法。实际上，实体存储并不是仓库模式的精确数学。当仓库的目的是模拟一组对象并隐藏持久性时，实体存储是完全相反的。它不表示一个集合。它确实做了它告诉你的——持久化一个单一的对象并检索它。而且，尽管通用仓库通常被认为是一个反模式，但我不会对实体存储接口应用同样的规则。

然后，我们可以在API中使用这个命令处理程序：

[PRE12]

你可以看到这里我们通过`IHandleCommand`接口引用了命令处理程序。这给了我们一些选择我们想要使用的实现方式的自由。首先，我们可以注册我们已有的实现：

[PRE13]

在这里，我们注册了`RavenDbEntityStore`类，它实现了`IEntityStore`。我们不会在这里查看实际的实现，但既然`RavenDb`是文档数据库，这样的类可能很容易实现。

我们到目前为止所做的是非常直接的，但由于我们在API中使用`IHandleCommand<T>`接口，我们可以做一些更有趣的事情。例如，我们可以创建一个通用的命令处理程序，它会重试失败：

[PRE14]

我们只需要将服务注册更改如下：

[PRE15]

在这里，我们将实际的命令处理程序包裹在通用的重试处理程序中。由于它们都实现了相同的接口，我们可以通过这些类的组合来构建一个管道。我们可以继续向链中添加更多元素，例如使用断路器或记录器。

我们可以向命令类添加更多属性（记住弱模式），但可能需要更改的唯一处理程序就是实际的命令处理程序。所有瞬态处理程序都将保持不变，因为我们使用的是命令类型，这是一个复杂类型，作为参数，所以接口定义本身并没有改变。

命令处理器模式很有吸引力，并且遵循 **单一职责原则**（**SRP**）。同时，我们 API 中的每个 HTTP 方法都需要一个单独的命令处理器作为依赖项。如果我们有两个或三个方法，这并不是什么大问题，但我们可能会有更多。仅通过查看我们的 EventStorming 会话的结果，我们可能预测我们的分类广告 Web API 将会有超过 10 个方法，以及足够的命令处理器。命令处理器需要实体存储作为依赖项，并且由于所有 Web API 控制器都是按范围实例化的，因此所有命令处理器也将被实例化和注入，包括它们的所有依赖项。通过使用工厂委托而不是每个请求的依赖项来减轻庞大依赖树的实例化，这样每个方法就能实例化其处理器：

[PRE16]

这种方法需要更高级的注册，因为我们不是使用实际类型，而是一个委托。另一个解决方案可能是使用 `Lazy<IHandleCommand<T>>` 作为依赖项。同样，这也需要更复杂的注册。注册挑战可能通过使用另一个依赖注入容器来解决，例如支持自动工厂委托和 `Lazy<T>` 的 Autofac。

在这本书中，我们不会使用命令处理器模式，而是将使用应用服务来实现命令处理。我们已经在本节中开始实现一个简单的服务，将在下一节中继续。命令处理器绕行存在是为了更好地概述有用的模式，因为没有任何模式适合所有用例。

# 应用服务

事实上，我们的应用服务将看起来和表现得很像一组命令处理器。一个 *经典* 的应用服务会公开一些带有多个参数的方法，如下所示：

[PRE17]

使用这种声明方式是完全可以接受的，但它与组合不太兼容。将此类应用服务添加到具有日志记录、重试策略等的管道中并不容易。要构建管道，我们需要所有处理器具有兼容的参数，但 `IPaymentApplicationService` 的这些方法根本不允许我们这样做。管道中的每个其他调用都必须具有相同的参数集，而且一旦我们想要向任何方法添加一个参数，我们就注定要在构成管道的多个类中进行大量更改。这不是我们愿意做的事情。

或者，我们可以有一个实现多个 `IHandle<T>` 接口的应用服务类。这可以工作，但每个命令将需要单独的引导代码，尽管我们在管道中添加的是相同的元素：

[PRE18]

或者，我们可以将我们的应用程序服务泛化以处理任何类型的命令，并再次使用C# 7的高级模式匹配功能（就像我们在事件处理中做的那样）。在这种情况下，应用程序服务的签名将如下所示：

[PRE19]

我们之前用于管道的所有过滤器，如重试过滤器或日志过滤器，都可以实现这个简单的接口。由于那些类不需要获取命令的内容，所以一切都会正常工作。我们的分类广告服务将看起来像这样：

[PRE20]

通过以这种方式实现我们的应用程序服务，我们将有一个单一的依赖关系来处理所有的API调用，并且我们保持开放的大门来构建一个更复杂的命令处理管道，就像我们能够对单个命令处理器做到的那样。

当然，这里的权衡是我们有一个处理多个命令的类，有些人可能会认为它违反了SRP原则。同时，这个类的内聚度很高，我们将在本章的后面看到更多关于它如何适当地处理多个命令并从边缘调用我们的应用程序服务的内容。

让我们现在添加更多命令并相应地扩展我们的应用程序服务和HTTP边缘。

首先，我们需要回到我们的实体并检查我们可以命令它执行哪些操作。这些操作如下：

1.  设置标题。

1.  更新文本。

1.  更新价格。

1.  请求发布。

我们可以添加四个命令来执行这些操作，因为我们根据我们的EventStorming会议可以预期，这是我们用户想要做的。

扩展后的命令列表将如下所示：

[PRE21]

每个命令都需要有它将要操作的实体的ID。其他属性是命令特定的。

第二，我们可以扩展我们的边缘以接受这些命令作为HTTP请求。新API版本的代码如下：

[PRE22]

你可能已经看到了一些创建有用抽象或例程的候选者。你也许也可以预测一些当这段代码在生产环境中运行时可能出现的问题。前面的边缘代码也违反了一个重要的原则，即API客户端需要只向命令处理器发送有效的命令。在我们的代码中，没有任何东西进行这样的检查。不用担心；我们将回到API代码并解决这些问题。现在，让我们集中精力在关键部分。

如你所见，我们的应用程序服务预计将处理五个命令。我们需要确保它这样做。我们应用程序服务的新代码如下：

[PRE23]

这里，我们再次使用`IEntityStore`抽象。这个接口非常简单：

[PRE24]

我们将为不同的持久化类型实现这个接口。

如您所见，处理`Create`命令与处理所有其他命令看起来不同。这是自然的，因为当我们创建一个新的实体时，我们需要确保它尚未存在。当我们处理现有实体的操作时，情况正好相反。在这种情况下，我们需要确保实体存在，否则，我们无法执行操作并必须抛出异常。

另一个值得提及的是，应用服务负责将原始类型，如字符串或十进制数，转换为值对象。边缘始终使用可序列化的类型，这些类型不依赖于领域模型。然而，应用服务操作与领域相关；它需要告诉我们的领域模型要做什么，由于我们的领域模型更喜欢以值对象的形式接收数据，因此应用服务负责转换。

处理现有实体命令的代码看起来与处理现有实体更新非常相似。实际上，只有调用实体方法的行有所不同。因此，我们可以通过直接的一般化来显著简化`Handle`方法，并用switch表达式替换`switch`模式匹配运算符：

[PRE25]

从应用服务代码中可以看出，应用服务本身在应用边缘和领域模型之间扮演着至关重要的中介角色。边缘可以是任何与外界通信的东西。我们以HTTP API为例，但它也可以是消息接口或完全不同的东西。对于边缘来说，重要的要求是能够接受命令、检查它们并让应用服务处理这些命令。

当我们处理一个命令时，无论我们使用多个命令处理器还是单个应用服务，操作序列通常非常相似。命令处理器需要从实体存储中检索持久化的实体，调用领域模型来完成工作，然后持久化更改。在我们的例子中，我们只调用了一个实体方法，但这种情况并不总是如此。我们将在下一章讨论一致性和事务边界时进一步探讨这一点。

# 摘要

在本章中，我们探讨了如何将用户的意图表示为用户发送给我们的系统的命令。我们学习了如何处理这些命令，查看了一些命令处理器模式的示例，然后转向应用服务。

我们探讨了API版本控制；尽管它与本书的主题没有直接关系，但这一实践的重要性不容忽视。我们将在第10章[事件溯源](75bc64ae-a642-42b2-a44a-05ae0cb2b750.xhtml)中简要提及版本控制话题。

在本章中，我们的应用程序服务得到了扩展，我们使用了C#的最新特性之一，来自函数式世界的礼物，称为**高级模式匹配**。我们利用这个特性简化了应用程序服务接口，最终只保留了一个方法。通过这种方式，我们还启用了使用组合，另一种函数式风格的途径，将命令处理与操作关注点（如日志记录和重试）链式连接。我们还将探讨这如何帮助我们检查命令的有效性。

在下一章中，我们将更深入地探讨实体持久化。我们将学习需要处理哪些类型的致性以及理解致性边界的重要性。
