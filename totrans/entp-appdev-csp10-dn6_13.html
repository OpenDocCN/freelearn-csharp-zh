<html><head></head><body>
		<div id="_idContainer148">
			<h1 id="_idParaDest-181"><em class="italic"><a id="_idTextAnchor1040"/>Chapter 10</em>: Creating an ASP.NET Core 6 Web API</h1>
			<p>In recent times, web services have become an important part of web application development. With ever-changing requirements and increased business complexity, it is very important to loosely couple various components/layers involved in web application development, and there is nothing better than decoupling the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) part of the application with the core business logic. This is where the simplicity of web services using a RESTful approach (where <strong class="bold">REST</strong> stands for <strong class="bold">REpresentational State Transfer</strong>) helps us to develop scalable web applications.</p>
			<p>In this chapter, we will learn how to build RESTful services using an ASP.NET Core web <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>), and along the way, we will build all the required APIs for our e-commerce application.</p>
			<p>We'll be covering the following topics in detail:</p>
			<ul>
				<li>Introduction to REST </li>
				<li>Understanding the internals of an ASP.NET Core 6 web API</li>
				<li>Handling requests using controllers and actions</li>
				<li>Integration with the data layer</li>
				<li>Understanding <strong class="bold">Google Remote Procedure Call</strong> (<strong class="bold">gRPC</strong>)</li>
			</ul>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor1041"/><a id="_idTextAnchor1042"/>Technical requirements</h1>
			<p>For this chapter, you will require a basic knowledge of C#, .NET Core, web APIs, <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), Azure, <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>), Postman, and the .NET <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>).</p>
			<p>The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi</a>.</p>
			<p>For more code examples, refer to the following link: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application</a>.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor1043"/><a id="_idTextAnchor1044"/>Introduction to REST</h1>
			<p>REST is an <a id="_idTextAnchor1045"/><a id="_idIndexMarker839"/>architectural guideline for building a web service. Primarily, it defines a set of constraints that can be followed while designing a web service. One of the key principal REST approaches recommends that APIs should be designed around resources and should be media- and protocol-agnostic. The underlying implementation of the API is independent of the client consuming the API.</p>
			<p>Considering an example of our e-commerce application, let's say we are searching for a product on the UI using a product's search field. There should be an API that is created for products, and here, products are nothing but a resource in the context of an e-commerce<a id="_idIndexMarker840"/> application. The <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>) for tha<a id="_idTextAnchor1046"/>t API could be something like this, which clearly states that we are trying to perform a <strong class="source-inline">GET</strong> operation on product entities:</p>
			<pre class="source-code">GET http://ecommerce.packt.com/products</pre>
			<p>The response of the API should be independent of the client that is calling the API—that is, in this case, we are using a browser to load a list of products on the product search page. However, the same API can be consumed in a mobile application as well without any changes. Secondly, in this case, in order to retrieve product information internally, an application may be using one or more physical data stores; however, that complexity is hidden from the client application, and the API is exposed to the client as a single business entity—products. Although REST principles do not dictate the protocol to be HTTP, the majority of RESTful services are built over HTTP. Some key design principles/constraints/rul<a id="_idTextAnchor1047"/>es of HTTP-based RESTful APIs are outlined here:</p>
			<ul>
				<li>Identify the business entities of the system and design APIs around those resources. In the case of our e-commerce application, all our APIs would be around resources such as products, orders, payments, and users.</li>
				<li>REST APIs should have a uniform interface that assists in making them independent of the client. As all the APIs need to be resource-oriented, each resource is uniquely identified by a URI; additionally, various operations on resources are uniquely identified by HTTP verbs such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">DELETE</strong>. For example, <strong class="source-inline">GET</strong> (<strong class="source-inline">http://ecommerce.packt.com/products/1</strong>) should be used to retrieve a product with an<strong class="bold"> identifier</strong> (<strong class="bold">ID</strong>) of <strong class="source-inline">1</strong>. Similarly, <strong class="source-inline">DELETE</strong> (<strong class="source-inline">http://ecommerce.packt.com/products/1</strong>) should be used to delete a product.</li>
				<li>As HTTP is stateless, REST dictates a number of things for RESTful APIs. What this means is that APIs should be atomic and conclude the processing of a request within<a id="_idIndexMarker841"/> the same call. Any subsequent request, even from the same client (same <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address), is treated as a new request. For example, if an API accepts an authentication token, it should accept authentication for each request. One major advantage of statelessness is the scalability that servers can eventually achieve, as a client can make an API call to any of the available servers and still receive the same response.</li>
				<li>Apart from sendi<a id="_idTextAnchor1048"/>ng back a response, APIs should make use of HTTP status codes and response <a id="_idIndexMarker842"/>headers to send any additional information to the client. For example, if a response can be cached, an API should send the relevant response headers to the client so that it can<a id="_idTextAnchor1049"/> be <a id="_idIndexMarker843"/>cached. <strong class="bold">Response caching</strong>, discussed in <a href="B18507_08_Epub.xhtml#_idTextAnchor714"><em class="italic">Chapter 8</em></a>, <em class="italic">All You Need to Know about</em><em class="italic"> Caching</em>, is based on these headers. Another example is where an API should return the relevant HTTP status codes in the event of both success and failure scenarios—that is, <strong class="source-inline">1xx</strong> for information, <strong class="source-inline">2xx</strong> for success, <strong class="source-inline">3xx</strong> for redirection, <strong class="source-inline">4xx</strong> for client errors, and <strong class="source-inline">5xx</strong> for server errors.</li>
				<li>APIs should give information about<a id="_idTextAnchor1050"/> the resource such that clients should be easily able to discover it without any prior information relating to the resource—that is, there <a id="_idIndexMarker844"/>should follow the principle of <strong class="bold">Hypermedia as the Engine of Application State</strong> (<strong class="bold">HATEOAS</strong>). For example, if there is an API to create a product, once a product is created, the API should respond with the URI of that resource so that the client can use that to retrieve the product later.</li>
			</ul>
			<p>Refer to the following response for an API that retrieves a list of all products (<strong class="source-inline">GET /products</strong>) and has information to retrieve further details regarding each product:</p>
			<p class="source-code">{</p>
			<p class="source-code">"Products": [</p>
			<p class="source-code">{</p>
			<p class="source-code">"Id": "1",</p>
			<p class="source-code">"Name": "Men's T-Shirt",</p>
			<p class="source-code">"Category": "Clothing"</p>
			<p class="source-code">"Uri": "http://ecommerce.packt.com/products/1"</p>
			<p class="source-code">}</p>
			<p class="source-code">{</p>
			<p class="source-code">"Id": "2",</p>
			<p class="source-code">"Name": "Mastering enterprise application development Book",</p>
			<p class="source-code">"Category": "books"</p>
			<p class="source-code">"Uri": "http://ecommerce.packt.com/products/2"</p>
			<p class="source-code">}</p>
			<p class="source-code">]</p>
			<p class="source-code">}</p>
			<p>The preceding example is one way to impl<a id="_idTextAnchor1051"/>ement the <em class="italic">HATEOAS</em> principle, but it can be designed in <a id="_idIndexMarker845"/>a more descriptive way, such as a response containing information about accepted HTTP verbs and relationships.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor1052"/>The REST maturity model</h2>
			<p>These are v<a id="_idTextAnchor1053"/>arious<a id="_idIndexMarker846"/> guidelines that an API should follow in order for it to be RESTful. However, not all the principles need to be followed to make it perfectly RESTFUL; it's more important that an API should fulfill the business goal rather than being 100% REST-compliant. Leonard Richardson, an expert on RESTful API design, came up with the following model to categorize the maturity of an API:</p>
			<ul>
				<li><strong class="bold">Level 0—The Swamp of Plain Old XML (POX)</strong>: Any API that has a single <strong class="source-inline">POST</strong> URI to <a id="_idIndexMarker847"/>perform all operations will fall under this category. An example would be a <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>)-based web service that has a single URI, and all operations are segregated based on the SOAP envelope.</li>
				<li><strong class="bold">Level 1—Resources</strong>: All resources are URI-driven, and APIs that have a dedicated URI pattern per resource fall under this maturity model.</li>
				<li><strong class="bold">Level 2—HTTP verbs</strong>: Apart from a separate URI for each resource, each URI has a separate action based on the HTTP verb. As discussed earlier, a product API that supports <strong class="source-inline">GET</strong> and <strong class="source-inline">DELETE</strong> using the same URI with different HTTP verbs falls under this maturity model. Most enterprise application RESTful APIs fall under this category.</li>
				<li><strong class="bold">Level 3—HATEO<a id="_idTextAnchor1054"/>AS</strong>: APIs that are designed with all additional discovery information (the URI for the resources; various operations that the resource supports) fall under this maturity model. Very few APIs are compliant with this maturity level; however, as discussed earlier, it's important that our APIs fulfill the business objective and are as compliant as possible with RESTful principles, rather than 100% compliant but not fulfilling the business objective.</li>
			</ul>
			<p>The following diagram illustrates Richardson's maturity<a id="_idTextAnchor1055"/> model:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_10.1_B18507.jpg" alt="Figure 10.1 – Richardson's maturity model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Richardson's maturity model</p>
			<p>Up to now, we have di<a id="_idTextAnchor1056"/>scussed various principles of REST architecture. In the next section, let's get into using an ASP.NET Core web API for which we will create various RESTful services in <a id="_idIndexMarker848"/>our e-commerce appl<a id="_idTextAnchor1057"/><a id="_idTextAnchor1058"/>ication.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor1059"/>Understanding the internals of an ASP.NET Core 6 web API</h1>
			<p><strong class="bold">ASP.NET C<a id="_idTextAnchor1060"/>ore</strong> is a unified<a id="_idIndexMarker849"/> framework that runs on top of .NET Core and is used to develop web applications (MVC/Razor), RESTful services (web API), and—most recently—web assembly-based client applications (Blazor apps). The fundamental design of ASP.NET Core applications is<a id="_idIndexMarker850"/> based on the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) patt<a id="_idTextAnchor1061"/>ern, which divides code into three primary categories, as follows:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This is a <strong class="bold">plain old CLR object</strong> (<a id="_idTextAnchor1062"/><strong class="bold">POCO</strong>)<a id="_idTextAnchor1063"/> class <a id="_idIndexMarker851"/>that holds the data and is used to pass data between various layers of the application. Layers include passing data between the <em class="italic">repository</em> class and the <em class="italic">service</em> class or passing information back and forth between the <em class="italic">client</em> and <em class="italic">server</em>. The model primarily represents the resource state or the domain model of the application and contains information that you have requested. </li>
			</ul>
			<p>For example, if we wanted to store user profile information, this can be represented by the <strong class="source-inline">UserInformation</strong> POCO class and can contain all the profile information. This will be further used to pass between repositories and service classes and can also be serialized into <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>)/<strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) <a id="_idTextAnchor1064"/>before being sent back to the client. In enterprise applications, we will encounter different types of models while creating models for our e-commerce application in the <em class="italic">Integration with the data layer</em> section.</p>
			<ul>
				<li><strong class="bold">View</strong>: These are the pages that represent UIs. All our models retrieved from controllers are bound to various <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) controls on views and are presented to users. Views are usually common in MVC/Razor applications; for web API applications, the process ends with serializing models as a response.</li>
				<li><strong class="bold">Controller</strong>: These a<a id="_idTextAnchor1065"/>re a set of classes that receive all requests, perform all the required processing, populate the model, and then send it back to the client. In enterprise applications, they typically make use of service classes to handle the business logic, and repositories to communicate with the underlying data store. With the unified approach in ASP.NET core, both MVC/Razor applications and web API applications use the same <strong class="source-inline">Microsoft.AspNetCore.Mvc.ControllerBase</strong> class to define controllers.</li>
			</ul>
			<p>So, in a web<a id="_idIndexMarker852"/> application developed using ASP.NET Core, whenever a request comes from a client (browser, mobile apps, and similar sources), it goes through the ASP.NET Core request pipeline and reaches a controller that interacts with the data store to populate models/view-models and send them back either as a response in the form of JSON/XML or to a view to further bind the response and present it to the user. </p>
			<p>As you can see, there is a clear <strong class="bold">separation of concerns</strong> (<strong class="bold">SOC</strong>) where a controller is not aware of any UI aspect and performs the business logic in the current context and responds via models; views, on the other hand, receive models and use them to present them to the user in HTML pages. This SOC easily helps to unit test the application, as well as maintain and scale it as needed. MVC patterns are not only applicable to web applications and can be used for any application that requires an SOC.</p>
			<p>As the focus of this chapter is to build RESTful services, we will focus on an ASP.NET Core web API in this chapter and discuss ASP.NET MVC and Razor Pages in <a href="B18507_11_Epub.xhtml#_idTextAnchor1228"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web Application</em>.</p>
			<p>To develop RESTful services, many frameworks are available, but here are a few <a id="_idTextAnchor1066"/>advantages<a id="_idIndexMarker853"/> of going with ASP.NET Core on .NET 6:</p>
			<ul>
				<li><strong class="bold">Cross-platform support</strong>: Unlike ASP.NET, which used to be part of the .NET Framework (which is coupled with the Windows operating system), ASP.NET Core is now part of the application, thereby eliminating platform dependency and making it compatible with all platforms.</li>
				<li><strong class="bold">Highly customizable request pipelines</strong>: Use middlewares and support to inject various out-of-the-box modules, such as logging and configuration.</li>
				<li><strong class="bold">Out-of-the-box HTTP server implementation</strong>: This can listen to HTTP requests and forward them to controllers. The server implementation includes cross-platform servers such as Kestrel and platform-specific servers such as <strong class="source-inline">IIS</strong> and <strong class="source-inline">HTTP.sys</strong>.<p class="callout-heading">Note</p><p class="callout">By default, Kestrel is the HTTP server used in ASP.NET Core templates; however, that can be overridden as required.</p></li>
				<li><strong class="bold">Strong tooling support</strong>: This comes in the form of <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), Visual Studio, and the DOTNET CLI, along with project templates, which means developers can start working on implementing the business logic with very little setup.</li>
				<li><strong class="bold">Open sourced</strong>: Finally, the entire framework is open sourced and is available at <a href="https://github.com/aspnet/AspNetCore">https://github.com/aspnet/AspNetCore</a>.</li>
			</ul>
			<p>So, we now know why we picked ASP.NET Core as our framework to develop RESTful services. Let's now look into some key components that assist in the execution of the request and create a sample web API by using the following command:</p>
			<pre class="source-code">dotnet new webapi -o TestApi</pre>
			<p>Once the preceding command is successfully executed, let's navigate to the <strong class="source-inline">TestApi</strong> folder and open it in VS Code to see the various files that are generated, as shown in the following<a id="_idTextAnchor1067"/> screenshot:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_10.2_B18507.jpg" alt="Figure 10.2 – Test web API project in VS Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Test web API project in VS Code</p>
			<p>Here, you can<a id="_idIndexMarker854"/> see a <strong class="source-inline">Program</strong> class used to bootstrap the application, and settings files, such as <strong class="source-inline">appsettings.json</strong>, that are used to run a web API project, and there is also <strong class="source-inline">WeatherForecast</strong>, which is a model class used in the controller class. Let's examine each of the components of <strong class="source-inline">TESTAPI</strong> in the follow<a id="_idTextAnchor1068"/><a id="_idTextAnchor1069"/>ing sections.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor1070"/>The Program class</h2>
			<p>The <strong class="source-inline">Program</strong> class <a id="_idIndexMarker855"/>is used to bootstrap web API<a id="_idIndexMarker856"/> projects in ASP.NET Core 6. Let's look at the activities perform<a id="_idTextAnchor1071"/>ed by this class in the following steps:</p>
			<ol>
				<li>The <strong class="source-inline">Program</strong> class is the entry point for our web API, and it tells ASP.NET Core to begin execution whenever someone executes the web API project. Primarily, this is the class that is used to bootstrap the application. Unlike earlier versions of ASP.NET Core applications, by default we don't have a <strong class="source-inline">Startup</strong> class—that is, the <strong class="source-inline">Program</strong> class has everything that we need—and to keep the code minimal, we further rely on C# 10's top-level statements and global using statements.</li>
				<li>Since this is the entry point, we need to ensure all components such as the web server, routing, and configuration, get initialized and loaded, and that is what the <strong class="source-inline">CreateBuilder</strong> method of the <strong class="source-inline">WebApplication</strong> class helps with. It primarily creates an object of <strong class="source-inline">WebApplicationBuilder</strong>, which can be used to configure the HTTP request pipeline.</li>
				<li><strong class="source-inline">WebApplicationBuilder</strong> is inherited from the <strong class="source-inline">IApplicationBuilder</strong> interface, which is nothing but t<a id="_idTextAnchor1072"/>he <strong class="bold">host</strong> for our application. Earlier, we discussed the fact that ASP.NET Core comes with an inbuilt HTTP server implementation and various middlewares to plug in, and that <strong class="source-inline">Host</strong> is nothing more than an object that encapsulates these components, such as the HTTP server defaulted to Kestrel, all the middleware components, and any additional services—such as logging—that are injected. Finally, the <strong class="source-inline">B<a id="_idTextAnchor1073"/>uild()</strong> method is called to run actions and initialize the <strong class="source-inline">Host</strong> object. The <strong class="source-inline">Run()</strong> method is called to keep the <strong class="source-inline">Host</strong> object running.</li>
			</ol>
			<p>Now that we <a id="_idIndexMarker857"/>have<a id="_idIndexMarker858"/> the <strong class="source-inline">Host</strong> object loaded with all the default components and it is up and running, let's examine whether we can inject additional ASP.NET Core classes/application-specific classes (repositories, services, options) and middlewares. Consider the follow<a id="_idTextAnchor1074"/>ing points: </p>
			<ul>
				<li>This <strong class="source-inline">WebApplicationBuilder</strong> object is used to inject any ASP.NET Core-provided services so that applications can use those services. A few common services that enterprise applications can inject are shown in the following code snippet:<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">builder.Services.AddAuthentication() // To enable </p><p class="source-code">//authentication.</p><p class="source-code">builder.Services.AddControllers(); // To enable </p><p class="source-code">//controllers like web API.</p><p class="source-code">builder.Services.AddControllersWithViews(); // To </p><p class="source-code">//enable controller with views.</p><p class="source-code">builder.Services.AddDistributedMemoryCache(); // To enable distributed caching.</p><p class="source-code">// App insights.</p><p class="source-code">string appinsightsInstrumentationKey = builder.Configuration.GetValue&lt;string&gt;("ApplicationSettings:InstrumentationKey");</p><p class="source-code">builder.Services.AddApplicationInsightsTelemetry(appInsightInstrumentKey); // To enable application insights </p><p class="source-code">//telemetry.</p></li>
			</ul>
			<p>Apart<a id="_idIndexMarker859"/> from <a id="_idIndexMarker860"/>services provided by ASP.NET Core, we can also inject any custom services specific to our application—for example, <strong class="source-inline">ProductService</strong> can be mapped to <strong class="source-inline">IProductService</strong> and can be made available for the entire application. Primarily, this <a id="_idTextAnchor1075"/>is the place we can use to plumb anything into the DI container, as explained in <a href="B18507_05_Epub.xhtml#_idTextAnchor445"><em class="italic">Chapter 5</em></a>, <em class="italic">Dependency Injection in .NET 6</em>.</p>
			<p>Additionally, all services, including ASP.NET Core services and custom services, can be plumbed into the application and are available as extension methods of <strong class="source-inline">IServiceCollection</strong>.</p>
			<ul>
				<li>Next, we ha<a id="_idTextAnchor1076"/>ve an object of the <strong class="source-inline">WebApplication</strong> class that can be used to integrate all the middlewares required to be applied to the request pipeline. This object primarily controls how applications respond to HTTP requests—that is, how applications should respond to exceptions, how they should respond to static files, or how URI routing should happen. All can be configured using this object. </li>
			</ul>
			<p>Additionally, any specific handling on a request pipeline—such as calling a custom middleware or adding specific response headers, or even defining a specific endpoint—can be injected using the <strong class="source-inline">WebApplication</strong> object. So, apart from what we saw earlier, the following code snippet shows a few common additional <a id="_idIndexMarker861"/>configurations <a id="_idIndexMarker862"/>that can be integrated using the <strong class="source-inline">WebApplication</strong> object:</p>
			<p class="source-code">var app = builder.Build();</p>
			<p class="source-code">// Endpoint that responds to /subscribe route.</p>
			<p class="source-code">app.UseEndpoints(endpoints =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">endpoints.MapGet("/subscribe", async context =&gt;</p>
			<p class="source-code">{   </p>
			<p class="source-code">  await context.Response.WriteAsync("subscribed");</p>
			<p class="source-code">});</p>
			<p class="source-code">});</p>
			<p class="source-code">// removing any unwanted headers.</p>
			<p class="source-code">app.Use(async (context, next) =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">context.Response.Headers.Remove("X-Powered-By");</p>
			<p class="source-code">context.Response.Headers.Remove("Server");</p>
			<p class="source-code">await next().ConfigureAwait(false);</p>
			<p class="source-code">});</p>
			<p>Here, <strong class="source-inline">app.UseEndpoints</strong> is configuring a response for a URI that matches <strong class="source-inline">/subscribe</strong>. <strong class="source-inline">app.UseEndPoints</strong> works alongside routing rules and is explained in the <em class="italic">Handling requests using controllers and actions</em> section, while <strong class="source-inline">app.Use</strong>, on the other hand, is used to add an inline middleware. In this case, we are removing <strong class="source-inline">X-Powered-By</strong> and <strong class="source-inline">Server</strong> response headers from the response.</p>
			<p>Since ASP.NET Core 6 supports something<a id="_idIndexMarker863"/> called <strong class="bold">Minimal API</strong>, the <strong class="source-inline">Program</strong> class alone can be used to build a fully working API; however, for enterprise applications, it is good to segregate APIs for easier maintenance and better readability, hence in our enterprise applications, we will be using APIs with the controller, which is supported by <strong class="source-inline">MapControllers</strong> middleware and is configured by calling <strong class="source-inline">app.</strong> <strong class="source-inline">MapControllers()</strong>.</p>
			<p>To sum up, the <strong class="source-inline">Program</strong> class plays a vital role in bootstrapping the application and then customizing application services and HTTP request/response pipelines as needed.</p>
			<p>Let's now see<a id="_idIndexMarker864"/> how middlewares help in customizing the<a id="_idIndexMarker865"/> HTTP request/response pipeline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">ASP.NET Core 6 still supports using the <strong class="source-inline">Startup</strong> class, and the <strong class="source-inline">Configure</strong> and <strong class="source-inline">ConfigureServices</strong> me<a id="_idTextAnchor1077"/><a id="_idTextAnchor1078"/>thods can be used as-is.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor1079"/>Understanding middleware</h2>
			<p>W<a id="_idTextAnchor1080"/>e have been<a id="_idIndexMarker866"/> referring to middleware for a while now, so <a id="_idIndexMarker867"/>let's understand what middlewares are and how we can we build one and use it in our enterprise application. Middlewares are classes that intercept incoming requests, perform some processing on the requests, and then hand them over to the next middleware or skip them as required. Middlewares are bidirectional, hence all middlewares intercept both requests and responses. Let's assume that an API retrieves product information and, in the process, it goes through various middlewares. Representing them in pictorial form would<a id="_idTextAnchor1081"/> look something like this:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_10.3_B18507.jpg" alt="Figure 10.3 – Middleware processing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – M<a id="_idTextAnchor1082"/>iddleware processing</p>
			<p>Each middleware has an instance of <strong class="source-inline">Microsoft.AspNetCore.Http.RequestDelegate</strong>. As a result of using this, the middleware invokes the next middleware. So, flows would typically process the request as per some processing logic that you want the middleware to perform on the request and then invoke <strong class="source-inline">RequestDelegate</strong> to hand the request over to the next middleware in the pipeline.</p>
			<p>If we take<a id="_idIndexMarker868"/> an <a id="_idIndexMarker869"/>analogy from manufacturing, it would be like an assembly line in a manufacturing process, where parts are added/modified from workstation to workstation until a final product is produced. In the previous diagram, let's consider each middleware as a workstation, so it will be going through the following steps: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The following explanation of each middleware is just a hypothetical explanation for our understanding; the internal workings of these middlewares differ slightly from what is explained here. More details can be found here: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6<span id="_idTextAnchor1083"/>.0</a>.</p>
			<ol>
				<li value="1"><strong class="source-inline">UseHttpsRedirection</strong>: An HTTP request arrives for <strong class="source-inline">GET/Products</strong> and is inspected for the protocol. If the request is via HTTP, a redirect is sent back through the HTTP status code; if the request is on HTTPS, it's handed over to the next middle<a id="_idTextAnchor1084"/>ware.</li>
				<li><strong class="source-inline">UseStaticFiles</strong>: If the request is for a static file (usually detected based on the <a id="_idIndexMarker870"/>extension—the <strong class="bold">Multipurpose Media Extensions</strong> (<strong class="bold">MIME</strong>) type), this middleware processes the request and sends the response back, or else hands the request on to the next middleware. Here, as you can see, if the request is for a static file, the rest of the pipeline is not even executed as this middleware can process the complete request, thereby reducing the load on the server for any unwanted processing and also reducing the response time. This process is also known as <strong class="bold">short-circuiting</strong>, which <a id="_idIndexMarker871"/>every middlewar<a id="_idTextAnchor1085"/>e can support.</li>
				<li><strong class="source-inline">UseRouting</strong>: The request is inspected further, and the controller/action that can process the<a id="_idIndexMarker872"/> request is identified. If there<a id="_idIndexMarker873"/> isn't any match, this middleware usually responds with a <strong class="source-inline">404</strong> HTTP status <a id="_idTextAnchor1086"/>code.</li>
				<li><strong class="source-inline">UseAuthorization</strong>: Here, if the controller/action needs to be available for authenticated users, then this middleware will look for any valid token in the header and respond accordingly.</li>
			</ol>
			<p>Once the controller gets the data from services/repositories, the response goes through the same middlewares in reverse order—that is, <strong class="source-inline">UseAuthorization</strong> first, followed by <strong class="source-inline">UseHttpsRedirection</strong>—and the response is processed as needed.</p>
			<p>As mentioned earlier, all middlewares are installed using the <strong class="source-inline">Program</strong> class and are configured using the object of the <strong class="source-inline">WebApplication</strong> class. The order of middleware execution would precisely follow the way it is configured in the <strong class="source-inline">Program</strong> class.</p>
			<p>Armed with this understanding, let's create a middleware that will be used to handle exceptions across the RESTful services of our e-commerce application, so instead of adding <strong class="source-inline">try…catch</strong> blocks in the code, we will create a middleware that gets installed at the <a id="_idIndexMarker874"/>beginning of the request pipeline and then ca<a id="_idTextAnchor1087"/><a id="_idTextAnchor1088"/>tches any<a id="_idIndexMarker875"/> exceptions throughout.</p>
			<h3>Building a cust<a id="_idTextAnchor1089"/>om middleware</h3>
			<p>As the <a id="_idIndexMarker876"/>middleware is going to be<a id="_idIndexMarker877"/> reused across all RESTful services, we will add the middleware to the <strong class="source-inline">Packt.Ecommerce.Common</strong> project inside the <strong class="source-inline">Middlewares</strong> folder.</p>
			<p>Let's first create a POCO class that represents the response in case of errors. This model will typically hold an error message, a <strong class="bold">unique ID</strong> (<strong class="bold">UID</strong>) to search in our log store application insights, and an inner exception (if needed). In production environments, an inner exception should not be exposed; however, for development environments, we can send the inner exception for debugging purposes, and we will control this behavior inside our middleware logic using a configuration flag. So, on this basis, add a class file named <strong class="source-inline">ExceptionResponse</strong> inside the <strong class="source-inline">Models</strong> folder of the <strong class="source-inline">Packt.Ecommerce.Common</strong> project and add the following code to it:</p>
			<pre class="source-code">public class ExceptionResponse</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public string ErrorMessage { get; set; }</pre>
			<pre class="source-code">    public string CorrelationIdentifier { get; set; }</pre>
			<pre class="source-code">    public string InnerException { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>Now, create another POCO class that can hold the configuration to toggle the behavior of sending an inner exception in our response. This class will be populated using the <strong class="source-inline">Options</strong> pattern, which was discussed in <a href="B18507_06_Epub.xhtml#_idTextAnchor473"><em class="italic">Chapter 6</em></a>, <em class="italic">Configuration in .NET  6</em>. Since it needs to hold only one setting, it will have one property. Add a class file named <strong class="source-inline">ApplicationSettings</strong> in the <strong class="source-inline">Options</strong> folder and then add the following code to it:</p>
			<pre class="source-code">public class ApplicationSettings</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public bool IncludeExceptionStackInResponse { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>This class will be extended further for any configuration that will be common across all our APIs<a id="_idTextAnchor1090"/>.</p>
			<p>Navigate to the <strong class="source-inline">Middlewares</strong> folder and create a class named <strong class="source-inline">ErrorHandlingMiddleware</strong>. As we discussed, one of the key properties in any middleware is a property of the <strong class="source-inline">RequestDelegate</strong> type. Additionally, we will add a property for <strong class="source-inline">ILogger</strong> to log the exception to our logging provider, and finally, we will add a property of the <strong class="source-inline">bool</strong> <strong class="source-inline">includeExceptionDetailsInResponse</strong> type to hold a flag that<a id="_idIndexMarker878"/> controls masking the inner<a id="_idIndexMarker879"/> exception. With this, here's what the <strong class="source-inline">ErrorHandlingMiddleware</strong> class will look like:</p>
			<pre class="source-code">public class ErrorHandlingMiddleware</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">private readonly RequestDelegate requestDelegate;</pre>
			<pre class="source-code">private readonly ILogger logger;</pre>
			<pre class="source-code">private readonly bool includeExceptionDetailsInResponse;</pre>
			<pre class="source-code">}</pre>
			<p>Add a <a id="_idIndexMarker880"/>parameterized constructor where we inject <strong class="source-inline">RequestDelegate</strong> and <strong class="source-inline">ILogger</strong> for our logging provider and <strong class="source-inline">IOptions&lt;ApplicationSettings&gt;</strong> for configuration and assign them to the properties created earlier. Here, again, we are relying on the constructor injection of ASP.NET Core to instantiate the respective objects. With this, here's what the constructor of <strong class="source-inline">ErrorHandlingMiddleWare</strong> will look like:</p>
			<pre class="source-code">public ErrorHandlingMiddleware(RequestDelegate, ILogger&lt;ErrorHandlingMiddleware&gt; logger, IOptions&lt;ApplicationSettings&gt; applicationSettings)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    NotNullValidator.ThrowIfNull(applicationSettings, </pre>
			<pre class="source-code">      nameof(applicationSettings));</pre>
			<pre class="source-code">    this.requestDelegate = requestDelegate;</pre>
			<pre class="source-code">    this.logger = logger;</pre>
			<pre class="source-code">    this.includeExceptionDetailsInResponse = applicationSettings.Value.IncludeExceptionStackInResponse;</pre>
			<pre class="source-code">}</pre>
			<p>Finally, add an <strong class="source-inline">InvokeAsync</strong> method that will have the logic to process the request and then call the next middleware using <strong class="source-inline">RequestDelegate</strong>. Since t<a id="_idTextAnchor1091"/>his is an exception-handling middleware as part of our logic, all we are going to do is wrap the request in a <strong class="source-inline">try…catch</strong> block. In the <strong class="source-inline">catch</strong> block, we will log it to the respective logging provider using <strong class="source-inline">ILogger</strong>, and finally send an object, <strong class="source-inline">ExceptionResponse</strong>, back as the<a id="_idIndexMarker881"/> response. With this, here's <a id="_idIndexMarker882"/>what <strong class="source-inline">InvokeAsync</strong> will look like:</p>
			<pre class="source-code">public async Task InvokeAsync(HttpContext context)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    try</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        if (this.requestDelegate != null)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            // invoking next middleware.</pre>
			<pre class="source-code">           this.requestDelegate.Invoke(context)</pre>
			<pre class="source-code">             .ConfigureAwait(false);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    catch (Exception innerException)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        this.logger.LogCritical(1001, innerException, </pre>
			<pre class="source-code">          "Exception captured in error handling </pre>
			<pre class="source-code">           middleware"); // logging.</pre>
			<pre class="source-code">        ExceptionResponse currentException = new </pre>
			<pre class="source-code">          ExceptionResponse()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            ErrorMessage = Constants.ErrorMiddlewareLog, </pre>
			<pre class="source-code">         // Exception captured in error handling middleware</pre>
			<pre class="source-code">            CorrelationIdentifier = </pre>
			<pre class="source-code">              System.Diagnostics.Activity.Current?.RootId,</pre>
			<pre class="source-code">        };</pre>
			<pre class="source-code">        if (this.includeExceptionDetailsInResponse)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            currentException.InnerException = </pre>
			<pre class="source-code">              $"{innerException.Message} </pre>
			<pre class="source-code">                {innerException.StackTrace}";</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        context.Response.StatusCode = </pre>
			<pre class="source-code">          StatusCodes.Status500InternalServerError;</pre>
			<pre class="source-code">        context.Response.ContentType = "application/json";</pre>
			<pre class="source-code">  await context.Response.WriteAsync(JsonSerializer.Serialize(innerException)).ConfigureAwai<a id="_idTextAnchor1092"/>t(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Now, we can<a id="_idIndexMarker883"/> inject this middleware into the <strong class="source-inline">Program</strong> class with the following code:</p>
			<pre class="source-code">app.UseMiddleware&lt;GlobalExceptionHandlingMiddleware&gt;();</pre>
			<p>Since this is an exception handler, it is recommended to configure it as early as possible in the <strong class="source-inline">Program</strong> class so that any exceptions in all subsequent middlewares are caught. Additionally, we need to ensure that we map the <strong class="source-inline">ApplicationSettings</strong> class to a configuration, so add the following code to the <strong class="source-inline">Program</strong> class:</p>
			<pre class="source-code">Builder.Services.Configure&lt;ApplicationSettings&gt;(this.Configuration.GetSection("ApplicationSettings"));</pre>
			<p>Add the relevant section to <strong class="source-inline">appsettings.json</strong>, as follows:</p>
			<pre class="source-code">"ApplicationSettings": {</pre>
			<pre class="source-code">    "IncludeExceptionStack<a id="_idTextAnchor1093"/>InResponse": true</pre>
			<pre class="source-code">  }</pre>
			<p>Now, if <a id="_idIndexMarker884"/>there is an error in any of our APIs, the<a id="_idIndexMarker885"/> response will look like the one shown in the following code snippet:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">"ErrorMessage": "Exception captured in error handling middleware",</pre>
			<pre class="source-code">"CorrelationIdentifier": "03410a51b0475843936943d3ae04240c ",</pre>
			<pre class="source-code">"InnerException": "No connection could be made because the target machine actively refused it.    at System.Net.Http.ConnectHelper.ConnectAsync(String host, Int32 port, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean allowHttp2, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.GetHttpConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.DiagnosticsHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at Microsoft.Extensions.Http.Logging.LoggingHttpMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at Microsoft.Extensions.Http.Logging.LoggingScopeHttpMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts, CancellationToken callerToken, Int64 timeoutTime)\r\n   at Packt.Ecommerce.Product.Services.ProductsService.GetProductsAsync(String filterCriteria) in src\\platform-apis\\services\\Packt.Ecommerce.Product\\Services\\ProductsService.cs:line 82\r\n   at Packt.Ecommerce.Product.Controllers.ProductsController.GetProductsAsync(String filterCriteria) in src\\platform-apis\\services\\Packt.Ecommerce.Product\\Controllers\\ProductsController.cs:line 46\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.TaskOfIActionResultExecutor.Execute(IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeActionMethodAsync&gt;g__Logged|12_1(ControllerActionInvoker invoker)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeNextActionFilterAsync&gt;g__Awaited|10_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeInnerFilterAsync&gt;g__Awaited|13_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeFilterPipelineAsync&gt;g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Logged|17_1(ResourceInvoker invoker)\r\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\r\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\r\n   at Packt.Ecommerce.Common.Middlewares.ErrorHandlingMiddleware.InvokeAsync(HttpContext context) in src\\platform-apis\\core\\Packt.Ecommerce.Common\\Middlewares\\Err<a id="_idTextAnchor1094"/>orHandlingMiddleware.cs:line 65"</pre>
			<pre class="source-code">}</pre>
			<p>From the <a id="_idIndexMarker886"/>preceding code snippet, we<a id="_idIndexMarker887"/> can take <strong class="source-inline">CorrelationIdentifier</strong>, which is <strong class="source-inline">03410a51b0475843936943d3ae04240c</strong>, search the value in our logging provider, <strong class="bold">Application Insights</strong>, and we can ascertain additional information regarding the exce<a id="_idTextAnchor1095"/>ption, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_10.4_B18507.jpg" alt="Figure 10.4 – Tracing CorrelationIdentifier in Application Insights&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Tracing CorrelationIdentifier in Application Insights</p>
			<p><strong class="source-inline">CorrelationIdentifier</strong> is extremely helpful in production environments where there is no inner exception.</p>
			<p>This concludes<a id="_idIndexMarker888"/> our discussion <a id="_idIndexMarker889"/>regarding middleware. In the next section, let's look at what <strong class="bold">controllers</strong> and <strong class="bold">actio<a id="_idTextAnchor1096"/><a id="_idTextAnchor1097"/>ns</strong> are and how they help in handling requests.</p>
			<h1 id="_idParaDest-188">Handling request<a id="_idTextAnchor1098"/>s using controllers and actions</h1>
			<p><strong class="bold">Controllers</strong> are <a id="_idIndexMarker890"/>the <a id="_idIndexMarker891"/>fundamental<a id="_idIndexMarker892"/> blocks <a id="_idIndexMarker893"/>for handling requests for designing RESTful servicers using an ASP.NET Core web API. These are the primary classes that hold the logic to process requests, which includes retrievi<a id="_idTextAnchor1099"/>ng data from a database, inserting a record into a database, and so on. Controllers are cl<a id="_idTextAnchor1100"/>asses where we define methods to process requests. These methods usually include validating the input, talking to a data store, applying busin<a id="_idTextAnchor1101"/>ess logic (in enterprise applications, controllers will also call service classes), and—finally—serializing the response and sending it back to the client using HTTP protocols in JSON/XML form. </p>
			<p>All these methods that hold the l<a id="_idTextAnchor1102"/>ogic to process requests are known as <strong class="bold">actions</strong>. All requests received by the HTTP server are handed over to action methods using a routing engine. However, a routing engine transfers requests to actions based on certain rules that can be defined in a request pipeline. These rules are what we define in routing. Let's see <a id="_idIndexMarker894"/>how<a id="_idIndexMarker895"/> a URI<a id="_idIndexMarker896"/> for handling request<a id="_idTextAnchor1103"/><a id="_idTextAnchor1104"/>s is<a id="_idIndexMarker897"/> mapped to a particular action in a controller.</p>
			<h2 id="_idParaDest-189">Understanding<a id="_idTextAnchor1105"/> ASP.NET Core routing</h2>
			<p>Up to now, we<a id="_idIndexMarker898"/> have seen that any HTTP request goes through the middleware and is finally handed over to the controller or an endpoint defined in the <strong class="source-inline">configure</strong> method, but who is responsible for this handover to a controller/endpoint, and how does ASP.NET Core know which controller and method inside the controller to trigger? That is what the routing engine is for, and this was injected when adding the following middlewares:</p>
			<pre class="source-code">app.UseRouting();</pre>
			<pre class="source-code">app.UseEndpoints(endpoints =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">     endpoints.MapControllers();</pre>
			<pre class="source-code">});</pre>
			<p>Here, <strong class="source-inline">app.UseRouting()</strong> injects <strong class="source-inline">Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware</strong>, which is used to make all routing decisions based on the URI. The primary job of this middleware is to set the instance of the <strong class="source-inline">Microsoft.AspNetCore.Http.Endpoint</strong> method with the value of the action that needs to be executed for a particular URI.</p>
			<p>For example, if we are trying to get the details of a product according to its ID and have a product controller that has the <strong class="source-inline">GetProductById</strong> method to fulfill this request, when we make an API call to the <strong class="source-inline">api/products/1</strong> URI, putting a breakpoint in a middleware after <strong class="source-inline">EndpointRoutingMiddleware</strong> shows you that an instance of the <strong class="source-inline">Endpoint</strong> class is available with information regarding the act<a id="_idTextAnchor1106"/>ion that matches the URI and should be <a id="_idTextAnchor1107"/>executed. We can see this in the following screenshot:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_10.5_B18507.jpg" alt="Figure 10.5 – Routing middlewares&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Routing middlewares</p>
			<p>This object would be null if there wasn't any matching controller/action. Internally, <strong class="source-inline">EndpointRoutingMiddleware</strong> uses the URI, query string parameters, and HTTP verbs and request headers to find the correct match.</p>
			<p>Once the correct action method is identified, it's the job of <strong class="source-inline">app.UseEndPoints</strong> to hand over control to the action method identified by the <strong class="source-inline">Endpoint</strong> object and execute it. <strong class="source-inline">UseEndPoints</strong> injects <strong class="source-inline">Microsoft.AspNetCore.Routing.EndpointMiddleware</strong> to execute the appropriate method to fulfill a request. One important aspect of populating an appropriate <strong class="source-inline">EndPoint</strong> object is the various URIs that are configured inside <strong class="source-inline">UseEndPoints</strong> that can be achieved through the static extension methods available in ASP.NET Core. For <a id="_idIndexMarker899"/>example, if we want to configure just controllers, we can use <strong class="source-inline">MapControllers</strong> extension methods, which add endpoints for all actions in controllers for <strong class="source-inline">UseRouting</strong> to match further. If we are building RESTful APIs, it is recommended to use <strong class="source-inline">MapControllers</strong> extensions. However, there are many such extension methods for the following exten<a id="_idTextAnchor1108"/>sions that are commonly used:</p>
			<ul>
				<li><strong class="source-inline">MapGet</strong>/<strong class="source-inline">MapP<a id="_idTextAnchor1109"/>ost</strong>: These are extension methods that can match specific patterns for <strong class="source-inline">GET</strong>/<strong class="source-inline">POST</strong> verbs and execute the request. They accept two parameters, one being the pattern of the URI and the second being the request delegate that can be used to execute when the pattern is matched. For example, the following code can be used to match the <strong class="source-inline">/aboutus</strong> route and respond with the text <strong class="source-inline">Welcome to default products route</strong>:<p class="source-code">endpoints.MapGet("/aboutus", async context =&gt;</p><p class="source-code">{</p><p class="source-code">await context.Response.WriteAsync("Welc<a id="_idTextAnchor1110"/>ome to default products route");</p><p class="source-code">});</p></li>
				<li><strong class="source-inline">MapRazorPages</strong>: This extension method is used if we are using Razor Pages and need to route to app<a id="_idTextAnchor1111"/>ropriate pages based on routes.</li>
				<li><strong class="source-inline">MapControllerRoute</strong>: This extension method can be used to match controllers with a specific pattern; for example, the following code can be seen in the ASP.NET Core MVC template, which matches methods based on a pattern:<p class="source-code">endpoints.MapControllerRoute(</p><p class="source-code">name: "default",</p><p class="source-code">pattern: "{controller=Home}/{action=Index}/{id?}");</p></li>
			</ul>
			<p>The request URI is split based on the forward slash (<strong class="source-inline">/</strong>) and is matched to the controller, action method, and ID. So, if you wanted to match a method in a controller, you need to pass the controller name (ASP.NET Core automatically suffixes the <strong class="source-inline">controller</strong> keyword) and<a id="_idIndexMarker900"/> method name in the URI. </p>
			<p>Optionally, the ID can be passed as a parameter to that method. For example, if I have <strong class="source-inline">GetProducts</strong> in <strong class="source-inline">ProductsController</strong>, you would be calling it using the absolute URI, <strong class="source-inline">products/GetProducts</strong>. This kind <a id="_idTextAnchor1112"/>of routing is known as <strong class="bold">conventional routing</strong> and is a<a id="_idIndexMarker901"/> good fit for UI-based web applications, and so can be seen in the ASP.NET Core MVC template.</p>
			<p>This concludes our discussion of the basics of routing; there are many such extension methods available in ASP.NET Core that can be plumbed into the request pipeline based on application requirements. Now, let's look at attribute-based routing, a routing technique recommended for RESTful services built using ASP.NET Core.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another<a id="_idIndexMarker902"/> important aspect of routing, as with any other middleware sequence, is that injection is very impor<a id="_idTextAnchor1113"/><a id="_idTextAnchor1114"/>tant, and <strong class="source-inline">UseRouting</strong> should be called before <strong class="source-inline">UseEndpoints</strong>.<a id="_idTextAnchor1115"/></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor1116"/>Attribute-based routing</h2>
			<p>For RESTful <a id="_idIndexMarker903"/>services, conventional routing contravenes a few REST principles, especially the principle that states that the operation on entities performed by the action method should be based on HTTP verbs; so, ideally, in order to get products, the URI should be <strong class="source-inline">GET api/products</strong>. </p>
			<p>This is where attribute-based routing comes into play, in which routes are defined using attributes either at the controller level or at the action method level, or both. This is achieved using the <strong class="source-inline">Microsoft.AspNetCore.Mvc.Route</strong> attribute, which takes a string value as an input parameter and is used to map the controller and action. Let's take an example of <strong class="source-inline">ProductsController</strong>, which has the following code:</p>
			<pre class="source-code">[Route("api/[controller]")]</pre>
			<pre class="source-code">[ApiController]</pre>
			<pre class="source-code">public class ProductsController : ControllerBase</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    [HttpGet]</pre>
			<pre class="source-code">    [Route("{id}")]</pre>
			<pre class="source-code">    public IActionResult GetProductById(int id)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return Ok($"Product {id}");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    [HttpGet]</pre>
			<pre class="source-code">    public IActionResult GetProducts()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return Ok("Products");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here, in the <strong class="source-inline">Route</strong> attribute at the controller level, we are passing the value <strong class="source-inline">api/[controller]</strong>, which means that any URI matching <strong class="source-inline">api/products</strong> is mapped to this controller, where <strong class="source-inline">products</strong> is the name of the controller. Using the <strong class="source-inline">controller</strong> keyword inside square brackets is a specific way of telling ASP.NET Core to map the controller name automatically to the route. </p>
			<p>However, if you want to stick to a specific name irrespective of the controller name, this ca<a id="_idTextAnchor1117"/>n be used without square brackets. As a best practice, it is recommended to decouple controller names with routes. Hence, for our e-commerce application, we will go with exact values in routes—that is, <strong class="source-inline">ProductsController</strong> will have a route prefix of <strong class="source-inline">[Route("api/products")]</strong>.</p>
			<p>The <strong class="source-inline">Route</strong> attribute can also be added to action methods and can be used to additionally identify specific methods uniquely. Here, we are also passing a string that can be used to<a id="_idIndexMarker904"/> identify the method. For example, <strong class="source-inline">[Route("GetProductById/{id}")]</strong> would be matched to the <strong class="source-inline">api/products/GetProductById/1</strong> URI, and the value inside the curly brackets is a dynamic value that can be passed as a parameter to the action method and matched with the parameter name. </p>
			<p>What this means is that in the preceding code, there is an ID parameter, and the value inside the curly brackets should also be named <strong class="source-inline">ID</strong> so that ASP.NET Core can map values from the URI to the <strong class="source-inline">method</strong> parameter. Hence, for the <strong class="source-inline">api/products/1</strong> URI, the ID parameter in the <strong class="source-inline">GetProductById</strong> method will have a value of <strong class="source-inline">1</strong> if the route attribute looks like this: <strong class="source-inline">[Route("{id}")]</strong>.</p>
			<p>Finally, the HTTP verb is represented by attributes such as <strong class="source-inline">[HttpG<a id="_idTextAnchor1118"/>et]</strong>, which will be used to map the HTTP verb from the URI to the method. The following table shows various examples and possible matches, as<a id="_idTextAnchor1119"/>suming that <strong class="source-inline">ProductsController</strong> has <strong class="source-inline">[Route("api/products")]</strong>:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Table_10.1.jpg" alt="Table 10.1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.1</p>
			<p>As you can see, the <a id="_idIndexMarker905"/>name of the method is immaterial here and so is not part of the URI matching unless it is specified in the <strong class="source-inline">Route</strong> attribute.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One important aspect is that the web API supports the reading of parameters from various locations within a request, be it in the request body, header, query string, or URI. The following documentation covers the various options available: <a href="https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference">https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspne<span id="_idTextAnchor1120"/>tcore-6.0#binding-source-parameter-inference</a>.</p>
			<p>A summary of an entire A<a id="_idTextAnchor1121"/>PI routing in ASP.NET Core could be represented as follows:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_10.6_B18507.jpg" alt="Figure 10.6 – ASP.NET Core API routing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure<a id="_idTextAnchor1122"/> 10.6 – ASP.NET Core API routing</p>
			<p>Attribute-based routing is more RESTful, and we will follow this kind of routing in our e-commerce services. Now, let's look at the various helper classes available in ASP.NET Core that can <a id="_idIndexMarker906"/>be used to simplify the building of RESTful services.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">{id}</strong> expression in routing is <a id="_idIndexMarker907"/>known as a <strong class="bold">routing constraint</strong>, and ASP.NET Core comes with a varied set of such routing constraints that can also be found here: <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference">https://docs.microsoft.com/en-us/aspnet/core/fundame<span id="_idTextAnchor1123"/><span id="_idTextAnchor1124"/>ntals/routing?view=aspnetcore-6.0#route-constraint-reference</a>.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor1125"/>The ControllerBase class, the ApiController attribute, and the ActionResult class</h2>
			<p>If we go <a id="_idIndexMarker908"/>back<a id="_idIndexMarker909"/> to any of the controllers created <a id="_idIndexMarker910"/><a id="_idTextAnchor1126"/>hitherto, you can see that all the controllers are inherited from the <strong class="source-inline">ControllerBase</strong> class. In ASP.NET Core, <strong class="source-inline">ControllerBase</strong> is an abstract class that provides various helper methods that assist in handling requests and responses. For example, if I wanted to send an HTTP status code <strong class="source-inline">400</strong> (bad request), there is a <strong class="source-inline">BadRequest</strong> helper method in <strong class="source-inline">ControllerBase</strong> that can be used to send an HTTP status code of <strong class="source-inline">400</strong>; otherwise, we have to manually create an object and populate it with the HTTP status code <strong class="source-inline">400</strong>. There are many such helper methods in <strong class="source-inline">ControllerBase</strong> that are available out of the box; however, not every API controller needs to be inherited from the <strong class="source-inline">ControllerBase</strong> class. All helper methods from the <strong class="source-inline">ControllerBase</strong> class are mentioned here: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&amp;viewFallbackFrom=aspnetcore-6.0</a>.</p>
			<p>This brings us to a discussion as to what the return type of our controller methods should be because there could be at least two possible responses for any API in general, as follows:</p>
			<ul>
				<li>A successful response with a 2xx status code that possibly responds with a resource or a list of resources</li>
				<li>A validation failure case with a 4xx status code</li>
			</ul>
			<p>To <a id="_idIndexMarker911"/>handle<a id="_idIndexMarker912"/> such scenarios, we need to<a id="_idIndexMarker913"/> create a generic type that can be used to send different response types, and this is where ASP.NET Core's <strong class="source-inline">IActionResult</strong> and <strong class="source-inline">ActionResult</strong> types come into play, providing us<a id="_idTextAnchor1127"/> with derived response types for various scenarios. A few important response types that <strong class="source-inline">IActionResult</strong> supports are listed here:</p>
			<ul>
				<li><strong class="source-inline">OkObjectResult</strong>: This is a response type that sets the HTTP status code to <strong class="source-inline">200</strong> and adds the resource to the body of the response containing the details of the resource. This type is ideal for all APIs that respond with a resource or a list of resources—for example, get products.</li>
				<li><strong class="source-inline">NotFoundResult</strong>: This is a response type that sets the HTTP status code to <strong class="source-inline">404</strong> and has an empty body. This can be used if a particular resource is not found. However, in the case of a resource not found, we will use <strong class="source-inline">NoContentResult</strong> (<strong class="source-inline">204</strong>), as <strong class="source-inline">404</strong> will also be used for an API not found.</li>
				<li><strong class="source-inline">BadRequestResult</strong>: This is a response type that sets the HTTP status code to <strong class="source-inline">400</strong> and contains an error message in the response body. This is ideal for any validation failures.</li>
				<li><strong class="source-inline">CreatedAtActionResult</strong>: This is a response type that sets the HTTP status code to <strong class="source-inline">201</strong> and can add the newly created resource URI to the respons<a id="_idTextAnchor1128"/>e. This is ideal for APIs that create resources.</li>
			</ul>
			<p>All these response types are inherited from <strong class="source-inline">IActionResult</strong>, and there are methods available in the <strong class="source-inline">ControllerBase</strong> class that can create these objects; so, <strong class="source-inline">IActionResult</strong>, along with <strong class="source-inline">ControllerBase</strong>, would solve most of the business requirements, and this is what we will have as the return type for all our API controller methods.</p>
			<p>The final important class available in ASP<a id="_idTextAnchor1129"/>.NET Core that comes in handy is the <strong class="source-inline">ApiController</strong> class, which <a id="_idIndexMarker914"/>can be added as an attribute <a id="_idIndexMarker915"/>to the <a id="_idIndexMarker916"/>controller class or to an assembly, and adds the following behaviors to our controllers:</p>
			<ul>
				<li>It disables conventional routing and makes attribute-based routing mandatory.</li>
				<li>It validates models automatically, so we don't need to explicitly call <strong class="source-inline">ModelState.IsValid</strong> in every method. This behavior is very useful in the case of insert/update methods.</li>
				<li>It facilitates automatic parameter mapping from the body/route/header/query strings. What this means is that we don't specify whether a parameter of an API is going to be part of the body or route. For example, in the following code snippet, we don't need to explicitly say that the ID par<a id="_idTextAnchor1130"/>ameter is going<a id="_idTextAnchor1131"/> to be part of the route as <strong class="source-inline">ApiController</strong> automatically uses something known as <strong class="bold">inference rules</strong> and <a id="_idIndexMarker917"/>a prefix in the ID with <strong class="source-inline">[FromRoute]</strong>:<p class="source-code">[Route("{id}")]</p><p class="source-code">public IActionResult GetProductById(int id)</p><p class="source-code">{</p><p class="source-code">  return Ok($"Product {id}");</p><p class="source-code">}</p></li>
				<li>Similarly, in the following code snippet, <strong class="source-inline">ApiController</strong> will automatically add <strong class="source-inline">[FromBody]</strong> based on the inference rules:<p class="source-code">public IActionResult CreateProduct(Product product)</p><p class="source-code">{</p><p class="source-code">//</p><p class="source-code">}</p></li>
				<li>A couple of other behaviors that <strong class="source-inline">ApiController</strong> adds are inferring request content to multipart/form data and more detailed error responses, as per <a href="https://tools.ietf.org/html/rfc7807.">https://tools.ietf.org/html/rfc7807.</a></li>
			</ul>
			<p>So, all in all, <strong class="source-inline">ControllerBase</strong>, <strong class="source-inline">ApiController</strong>, and <strong class="source-inline">ActionResult</strong> provide various helper methods and behaviors, thereby providing developers with all the tools needed to <a id="_idIndexMarker918"/>write <a id="_idIndexMarker919"/>RESTful APIs and allowing them to <a id="_idIndexMarker920"/>focus on business logic while writing APIs using ASP.NET Core.</p>
			<p>With this foundation, let<a id="_idTextAnchor1132"/><a id="_idTextAnchor1133"/>'s design various APIs for our e-commerce application in the ne<a id="_idTextAnchor1134"/>xt section.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor1135"/>Integration with the data layer</h1>
			<p>The response <a id="_idIndexMarker921"/>from our APIs may or may not look like our domain models. Instead, their structure can resemble the fields that the UI or Views need to bind; hence, it is recommended to create<a id="_idTextAnchor1136"/> a separate set of POCO classes that integrate with our UI. These POCOs are<a id="_idIndexMarker922"/> known as <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>).</p>
			<p>In this section, we will implement our DTOs' domain logic integrating with the data layer and integrate the cache services discussed in <a href="B18507_08_Epub.xhtml#_idTextAnchor714"><em class="italic">Chapter 8</em></a>, <em class="italic">All You Need to Know about Caching</em>, using the Cache-Aside pattern, and then—finally—implement th<a id="_idTextAnchor1137"/>e required RESTful APIs using controllers and actions. Along the way, we will use the <strong class="source-inline">HTTPClient</strong> factory for our service-to-service communication, and the <strong class="source-inline">AutoMapper</strong> library for mapping domain models to DTOs.</p>
			<p>We will pick a product service that is part of <strong class="source-inline">Packt.Ecommerce.Product</strong>, a web API project<a id="_idIndexMarker923"/> using .NET 6, and discuss its implementation in detail. By the end of this section, we<a id="_idTextAnchor1138"/> will have implemented the projects highlighted in the following scr<a id="_idTextAnchor1139"/>eenshot:</p>
			<p class="figure-caption"><img src="image/Figure_10.7_B18507.png" alt="Figure 10.7 – Product service and DTOs&#13;&#10;"/></p>
			<p class="figure-caption">Figure 10.7 – Product service and DTOs</p>
			<p>A similar implementation is replicated across all RESTful services with slight modifications in business logic, as required, but the high-level implementation remains the same across the following various services:</p>
			<ul>
				<li><strong class="source-inline">Packt.Ecommerce.DataAccess</strong></li>
				<li><strong class="source-inline">Packt.Ecommerce.Invoice</strong></li>
				<li><strong class="source-inline">Packt.Ecommerce.Order</strong></li>
				<li><strong class="source-inline">Packt.Ecommerce.Payment</strong></li>
				<li><strong class="source-inline">Packt.Ecommerce.UserManagement</strong></li>
			</ul>
			<p>To start with, we<a id="_idIndexMarker924"/> will have the corresponding section in <strong class="source-inline">appsettings.json</strong>, which is shown as follows:</p>
			<pre class="source-code">    "ApplicationSettings": {</pre>
			<pre class="source-code">    "UseRedisCache": false, // For in-memory</pre>
			<pre class="source-code">    "IncludeExceptionStackInResponse": true,</pre>
			<pre class="source-code">    "DataStoreEndpoint": "",</pre>
			<pre class="source-code">    "InstrumentationKey": <a id="_idTextAnchor1140"/>""</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">  "ConnectionStrings": {</pre>
			<pre class="source-code">    "Redis": ""</pre>
			<pre class="source-code">  }</pre>
			<p>For the local development environment, we will use <strong class="bold">Manage User Secrets</strong> (as explained at <a href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&amp;tabs=windows">https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&amp;tabs=windows</a>) and set the following values. However, once the service is deployed, it will make use of Azure Key Vault, as explained in <a href="B18507_06_Epub.xhtml#_idTextAnchor473"><em class="italic">Chapter 6</em></a>, <em class="italic">Configuration in .NET 6</em>:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "ApplicationSettings:InstrumentationKey": "", //relevant </pre>
			<pre class="source-code">                                                //key</pre>
			<pre class="source-code">  "ConnectionStrings:Redis"<a id="_idTextAnchor1141"/><a id="_idTextAnchor1142"/>: "" //connection string</pre>
			<pre class="source-code">}</pre>
			<p>Let's b<a id="_idTextAnchor1143"/>egin<a id="_idIndexMarker925"/> by creating DTOs for the Products API.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor1144"/>Creating DTOs</h2>
			<p>The key <a id="_idIndexMarker926"/>requirements in terms of product services are to provide the ability to search for products, view additional details relating to the products, and then proceed with the purchase. Since a listing of products can have limited details, let's create a POCO (all DTOs are created in the <strong class="source-inline">Packt.Ecommerce.DTO.Models</strong> project) and name it <strong class="source-inline">ProductListViewModel</strong>. This class will have all the properties that we want to show on the product's list page, and it should look like this:</p>
			<pre class="source-code">public class ProductListViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        [JsonProperty(PropertyName = "id")]</pre>
			<pre class="source-code">        public string Id { get; set; }</pre>
			<pre class="source-code">        public string Name { get; set; }</pre>
			<pre class="source-code">        public int Price { get; set; }</pre>
			<pre class="source-code">        public Uri ImageUrl { get; set; }</pre>
			<pre class="source-code">        public double AverageRating { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, these are minimum fields that are usually displayed on any e-commerce application. Hence, we will go with these fields, but the idea is to extend as the application evolves. Here, the <strong class="source-inline">Id</strong> and <strong class="source-inline">Name</strong> properties are important properties as those will be used to query the database once the user wants to retrieve all further details regarding the product. We are annotating the <strong class="source-inline">Id</strong> property with the <strong class="source-inline">JsonProperty(PropertyName = "id")</strong> attribute to ensure that the property name remains as <strong class="source-inline">Id</strong> during serialization and deserialization. This is important because, in our Cosmos DB instance, we are using <strong class="source-inline">Id</strong> as the key for most of the containers. Let's now create another POCO that represents the details of a product, as shown in the following<a id="_idIndexMarker927"/> code snippet:</p>
			<pre class="source-code">public class ProductDetailsViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        public string Id { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        public string Name { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        public string Category { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        [Range(0, 9999)]</pre>
			<pre class="source-code">        public int Price { get; set; }</pre>
			<pre class="source-code">        [Required]</pre>
			<pre class="source-code">        [Range(0, 999, ErrorMessage = "Large quantity, </pre>
			<pre class="source-code">         please reach out to support to process request.")]</pre>
			<pre class="source-code">        public int Quantity { get; set; }</pre>
			<pre class="source-code">        public DateTime CreatedDate { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; ImageUrls { get; set; }</pre>
			<pre class="source-code">        public List&lt;RatingViewModel&gt; Rating { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; Format { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; Authors { get; set; }</pre>
			<pre class="source-code">        public List&lt;int&gt; Size { get; set; }</pre>
			<pre class="source-code">        public List&lt;string&gt; Color { get; set; }</pre>
			<pre class="source-code">        public string Etag { get; set; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class RatingViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        public int Stars { get; set; }</pre>
			<pre class="source-code">        public int Percentage { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>So, in this DTO, apart from <strong class="source-inline">Id</strong> and <strong class="source-inline">Name</strong>, one of the important properties is <strong class="source-inline">Etag</strong>, which will be used for entity tracking to avoid concurren<a id="_idTextAnchor1145"/>t overwrites on an entity. For example, if two users access a product and user A updates it before user B, using <strong class="source-inline">Etag</strong>, we can stop user B from overwriting user A's changes and force user B to take the latest copy of the product prior to updating. The <strong class="source-inline">AddProductAsync(ProductDetailsViewModel product)</strong> method in <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers</a> follows this pattern.</p>
			<p>Another<a id="_idIndexMarker928"/> important aspect is that we are using ASP.NET Core's built-in validation attributes on our model to define all constraints on the models. Primarily, we will be using the <strong class="source-inline">[Required]</strong> attribute and any relevant attributes, as per <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes</a>.</p>
			<p>All the DTOs would be part of the <strong class="source-inline">Packt.Ecommerce.DTO.Models</strong> project as they will be<a id="_idIndexMarker929"/> reused in our ASP.NET MVC application, which will be used to build the UI of our e-comme<a id="_idTextAnchor1146"/><a id="_idTextAnchor1147"/>rce application. Now, let's look at the contracts needed for the <strong class="source-inline">Products</strong> service.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor1148"/>Service-class contracts</h2>
			<p>Add <a id="_idTextAnchor1149"/>a <strong class="source-inline">Contracts</strong> folder <a id="_idIndexMarker930"/>to <strong class="source-inline">Packt.Ecommerce.Product</strong> and create a contract/interface of a product's service class, for which we will refer to our requirements and define methods as needed. To start with, it will have all the methods to <a id="_idIndexMarker931"/>perform <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations on products based on that interface, and these will look like this:</p>
			<pre class="source-code">public interface IProductService</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; </pre>
			<pre class="source-code">          GetProductsAsync(string filterCriteria = null);</pre>
			<pre class="source-code">        Task&lt;ProductDetailsViewModel&gt; </pre>
			<pre class="source-code">          GetProductByIdAsync(string productId, </pre>
			<pre class="source-code">            string productName);</pre>
			<pre class="source-code">        Task&lt;ProductDetailsViewModel&gt; </pre>
			<pre class="source-code">          AddProductAsync(ProductDetailsViewModel product);</pre>
			<pre class="source-code">        Task&lt;HttpResponseMessage&gt; </pre>
			<pre class="source-code">          UpdateProductAsync(ProductDetailsViewModel </pre>
			<pre class="source-code">            product);</pre>
			<pre class="source-code">        Task&lt;HttpResponseMessage&gt; DeleteProduct<a id="_idTextAnchor1150"/>Async(</pre>
			<pre class="source-code">          string productId, string productName);</pre>
			<pre class="source-code">    }</pre>
			<p>Here, you can<a id="_idIndexMarker932"/> see that we are returning <strong class="source-inline">Task</strong> in all methods, thereby sticking to our<a id="_idTextAnchor1151"/><a id="_idTextAnchor1152"/> asynchronous approach discussed in <a href="B18507_04_Epub.xhtml#_idTextAnchor205"><em class="italic">Chapter 4</em></a>, <em class="italic">Threading and Asynchronous Operations</em>.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor1153"/>The mapper class using AutoMapper</h2>
			<p>The next thing <a id="_idIndexMarker933"/>that we will need is a <a id="_idTextAnchor1154"/>way to transform our <a id="_idIndexMarker934"/>domain models to DTOs, and here, we will use a well-known library called <strong class="source-inline">AutoMapper</strong> (please refer to <a href="https://docs.automapper.org/en/stable/Getting-started.html">https://docs.automapper.org/en/stable/Getting-started.html</a> for more details) to configure and add the following packages:</p>
			<ul>
				<li><strong class="source-inline">Automapper</strong></li>
				<li><strong class="source-inline">AutoMapper.Extensions.Microsoft.DependencyInjection</strong></li>
			</ul>
			<p>To configure <strong class="source-inline">AutoMapper</strong>, we need to define a class that inherits from <strong class="source-inline">AutoMapper.Profile</strong> and then defines the mapping between various domain models and DTOs. Let's add an <strong class="source-inline">AutoMapperProfile</strong> class to the <strong class="source-inline">Packt.Ecommerce.Product</strong> project, as follows:</p>
			<pre class="source-code">    public class AutoMapperProfile : Profile</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        public AutoMapperProfile()</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<p><strong class="source-inline">AutoMapper</strong> comes with many inbuilt methods for mapping, one of these being <strong class="source-inline">CreateMap</strong>, which accepts source and destination classes and maps them based on the same property <a id="_idIndexMarker935"/>names. Any property that does not have the same<a id="_idIndexMarker936"/> name can be manually mapped using the <strong class="source-inline">ForMember</strong> method. Since <strong class="source-inline">ProductDetailsViewModel</strong> has a one-to-one mapping with our domain model, <strong class="source-inline">CreateMap</strong> should be good enough for their mapping. For <strong class="source-inline">ProductListV<a id="_idTextAnchor1155"/>iewModel</strong>, we have an additional field, <strong class="source-inline">AverageRating</strong>, for which we wanted to calculate the average of all the ratings given for a particular product. To keep it simple, we will use the <strong class="source-inline">Average</strong> method from <strong class="source-inline">Linq</strong> and then map it to the average rating. For modularization, we will have this in a separate method, <strong class="source-inline">MapEntity</strong>, which looks like this:</p>
			<pre class="source-code">private void MapEntity()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">            this.CreateMap&lt;Data.Models.Product, </pre>
			<pre class="source-code">              DTO.Models.ProductDetailsViewModel&gt;();</pre>
			<pre class="source-code">            this.CreateMap&lt;Data.Models.Rating, </pre>
			<pre class="source-code">              DTO.Models.RatingViewModel&gt;();</pre>
			<pre class="source-code">            this.CreateMap&lt;Data.Models.Product, </pre>
			<pre class="source-code">              DTO.Models.ProductListViewModel&gt;()</pre>
			<pre class="source-code">                .ForMember(x =&gt; x.AverageRating, o =&gt; </pre>
			<pre class="source-code">                  o.MapFrom(a =&gt; a.Rating != null ? </pre>
			<pre class="source-code">                  a.Rating.Average(y =&gt; y.Stars) : 0));</pre>
			<pre class="source-code">}</pre>
			<p>Now, modify the constructor to call this method. Refer to <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs</a> for the complete implementation.</p>
			<p>The final step involved in setting up <strong class="source-inline">AutoMapper</strong> is to inject it as one of the services, for which we will use the <strong class="source-inline">WebApplicationBuilder</strong> object of the <strong class="source-inline">Program</strong> class, using the following line of code:</p>
			<pre class="source-code">Builder.Services.AddAutoMapper(typeof(AutoMapperProfile));</pre>
			<p>As explained earlier, this will inject the <strong class="source-inline">AutoMapper</strong> library into our API, and this will then allow us <a id="_idIndexMarker937"/>to <a id="_idIndexMarker938"/>inject <strong class="source-inline">AutoMapper</strong> into various services and controllers. Let's now look at the <a id="_idTextAnchor1156"/><a id="_idTextAnchor1157"/>configuration of the <strong class="source-inline">HttpClient</strong> factory, which is used for calling th<a id="_idTextAnchor1158"/>e data access service.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor1159"/>HttpClient factory for service-to-service calls</h2>
			<p>To retrieve<a id="_idIndexMarker939"/> data, we must call APIs exposed by<a id="_idIndexMarker940"/> our data access service defined in <strong class="source-inline">Packt.Ecommerce.DataAccess</strong>. For this, we need a resilient library that can effectively use the available sockets, allowing us to define a circuit breaker as well as retry/timeout policies. <strong class="source-inline">IHttpClientFactory</strong> is ideal for such scenarios.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One common issue with <strong class="source-inline">HttpClient</strong> is the potential <strong class="source-inline">SocketException</strong> error, which happens as <strong class="source-inline">HttpClient</strong> leaves<a id="_idIndexMarker941"/> the <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) connection open even after the object has been disposed of, and the recommendation is to create <strong class="source-inline">HttpClient</strong> as a static/singleton—which has its own overheads—while connecting to multiple services. These issues are summarized at <a href="https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests">https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests</a>, and these are all now addressed by <strong class="source-inline">IhttpClientFactory</strong>.</p>
			<p>To configure <strong class="source-inline">IHttpClientFactory</strong>, perform the following steps:</p>
			<ol>
				<li value="1">Install <strong class="source-inline">Microsoft.Extensions.Http</strong>.</li>
				<li>We will be configuring <strong class="source-inline">IHttpClientFactory</strong> using typed clients, so add a <strong class="source-inline">Services</strong> folder and a <strong class="source-inline">ProductsService</strong> class and inherit them from <strong class="source-inline">IProductService</strong>. For now, leave the implementation empty. Now, map <strong class="source-inline">IProductService</strong> and <strong class="source-inline">ProductsService</strong> in the <strong class="source-inline">Program</strong> class using the following code:<p class="source-code">builder.Services.AddHttpClient&lt;IProductService, ProductsService&gt;()</p><p class="source-code">       .SetHandlerLifetime(TimeSpan.FromMinutes(5))</p><p class="source-code">       .AddPolicyHandler(RetryPolicy()) // Retry </p><p class="source-code">                                        // policy.</p><p class="source-code">       .AddPolicyHandler(CircuitBreakerPolicy()); </p><p class="source-code">       // Circuit breakerpo<a id="_idTextAnchor1160"/>licy</p></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker942"/>are <a id="_idIndexMarker943"/>defining the timeout for <strong class="source-inline">HttpClient</strong> used by <strong class="source-inline">ProductsService</strong> as <strong class="source-inline">5</strong> minutes and additionally configuring a policy for retrie<a id="_idTextAnchor1161"/>s and a circuit breaker.</p>
			<h3>Implementing a circuit-breaker policy</h3>
			<p>To define<a id="_idIndexMarker944"/> these<a id="_idIndexMarker945"/> policies, we will use a library called <strong class="source-inline">Polly</strong> (refer to <a href="https://github.com/App-vNext/Polly">https://github.com/App-vNext/Polly</a> for the official documentation), which gives out-of-the-box resiliency and fault-handling capabilities. Install the <strong class="source-inline">Microsoft.Extensions.Http.Polly</strong> package and then add the following static method to the <strong class="source-inline">Program</strong> class that defines our circuit-breaker policy:</p>
			<pre class="source-code">static IAsyncPolicy&lt;HttpResponseMessage&gt; CircuitBreakerPolicy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return HttpPolicyExtensions</pre>
			<pre class="source-code">        .HandleTransientHttpError()</pre>
			<pre class="source-code">        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));</pre>
			<pre class="source-code">}</pre>
			<p>Here, we are saying that the circuit would be opened if there are 5 failures within 30 seconds. A circuit breaker assists in avoiding unnecessary HTTP calls where there is a <a id="_idTextAnchor1162"/>critical failure<a id="_idIndexMarker946"/> that<a id="_idIndexMarker947"/> cannot be fixed with a retry.</p>
			<h3>Implementing a retry policy</h3>
			<p>Now, let's add <a id="_idIndexMarker948"/>our <a id="_idIndexMarker949"/>retry policy, which is a bit smarter compared with the standard retries that retire within a specified timeframe. So, we define a policy that will affect a retry and HTTP service calls on five occasions, and each retry would have a time difference in seconds at a rate of power of two. The code is illustrated here: </p>
			<p>To add some randomness in terms of the time variation, we will use a <strong class="source-inline">Random</strong> class of C# to generate a random number and add it to the time gap. This random generation will be as shown in the following code:</p>
			<pre class="source-code">private static IAsyncPolicy&lt;HttpResponseMessage&gt; RetryPolicy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    Random random = new Random();</pre>
			<pre class="source-code">    var retryPolicy = HttpPolicyExtensions</pre>
			<pre class="source-code">        .HandleTransientHttpError()</pre>
			<pre class="source-code">        .OrResult(msg =&gt; msg.StatusCode == </pre>
			<pre class="source-code">          System.Net.HttpStatusCode.NotFound)</pre>
			<pre class="source-code">        .WaitAndRetryAsync(</pre>
			<pre class="source-code">        5,</pre>
			<pre class="source-code">        retry =&gt; TimeSpan.FromSeconds(Math.Pow(2, retry))</pre>
			<pre class="source-code"><a id="_idTextAnchor1163"/>         + TimeSpan.FromMilliseconds(random.Next(0, 100)));</pre>
			<pre class="source-code">    return retryPolicy;</pre>
			<pre class="source-code">}</pre>
			<p>Here, <strong class="source-inline">retry</strong> is an integer that increments by one with every retry. With this, add a static method to the <strong class="source-inline">Program</strong> class that has the preceding logic.</p>
			<p>This completes our <strong class="source-inline">HTTPClient</strong> factory configuration, and <strong class="source-inline">ProductsService</strong> can use constructor injection to instantiate <strong class="source-inline">IHttpClientFactory</strong>, which can be further used to create <strong class="source-inline">HttpClient</strong>.</p>
			<p>With a<a id="_idTextAnchor1164"/><a id="_idTextAnchor1165"/>ll <a id="_idIndexMarker950"/>this<a id="_idIndexMarker951"/> configuration, we can now imp<a id="_idTextAnchor1166"/>lement our service class. Let's look at that in the next section.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor1167"/>Implementing service classes</h2>
			<p>Let's now <a id="_idIndexMarker952"/>implement <strong class="source-inline">ProductsService</strong>, starting by defining various properties that we have now built and instantiating them using constructor injections, as shown in the following code block:</p>
			<pre class="source-code">private readonly IOptions&lt;ApplicationSettings&gt; applicationSettings;</pre>
			<pre class="source-code">private readonly HttpClient httpClient;</pre>
			<pre class="source-code">private readonly IMapper autoMapper;</pre>
			<pre class="source-code">private readonly IDistributedCacheService cacheService;</pre>
			<pre class="source-code">public ProductsService(IHttpClientFactory httpClientFactory, IOptions&lt;ApplicationSettings&gt; applicationSettings, IMapper autoMapper, IDistributedCacheService cacheService)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    NotNullValidator.ThrowIfNull(applicationSettings, </pre>
			<pre class="source-code">      nameof(applicationSettings));</pre>
			<pre class="source-code">    IHttpClientFactory httpclientFactory = </pre>
			<pre class="source-code">      httpClientFactory;</pre>
			<pre class="source-code">    this.applicationSettings = applicationSettings;</pre>
			<pre class="source-code">    this.httpClient = httpclientFactory.CreateClient();</pre>
			<pre class="source-code">    this.autoMapper = autoMapper;</pre>
			<pre class="source-code">    this.cacheService = cacheService;</pre>
			<pre class="source-code">}</pre>
			<p>All our services are going to use the same exception-handling middleware we defined in this chapter, so during service-to-service calls, if there is a failure in another service, the response would be of the <strong class="source-inline">ExceptionResponse</strong> type. Hence, let's create a private method, so<a id="_idIndexMarker953"/> deserialize the <strong class="source-inline">ExceptionResponse</strong> class and raise it accordingly. This is required because <strong class="source-inline">HttpClient</strong> would represent success or failure while using the <strong class="source-inline">IsSuccessStatusCode</strong> and <strong class="source-inline">StatusCode</strong> properties, so if there is an exception, w<a id="_idTextAnchor1168"/>e need to check <strong class="source-inline">IsSuccessStatusCode</strong> and rethrow it. Let's call this method <strong class="source-inline">ThrowServiceToServiceErrors</strong> and refer to the following code snippet:</p>
			<pre class="source-code">private async Task ThrowServiceToServiceErrors(HttpResponseMessage response)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    var exceptionReponse = await response.Content.ReadFromJsonAsync&lt;ExceptionResponse&gt;().ConfigureAwait(false);</pre>
			<pre class="source-code">    throw new Exception(exceptionReponse.InnerException);</pre>
			<pre class="source-code">}</pre>
			<p>Let's now implement the <strong class="source-inline">GetProductsAsync</strong> method, in which we will use <strong class="source-inline">CacheService</strong> to retrieve data from the cache, and if it is not available in the cache, we will ca<a id="_idTextAnchor1169"/>ll the data access service using <strong class="source-inline">HttpClient</strong>, and finally map the <strong class="source-inline">Product</strong> domain's model to<a id="_idIndexMarker954"/> a DTO and return it asynchronously. The code will look like this:</p>
			<pre class="source-code">public async Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    var products = await this.cacheService</pre>
			<pre class="source-code">      .GetCacheAsync&lt;IEnumerable&lt;Packt.Ecommerce</pre>
			<pre class="source-code">      .Data.Models.Product&gt;&gt;($"products{filterCriteria}")</pre>
			<pre class="source-code">      .ConfigureAwait(false);</pre>
			<pre class="source-code">    if (products == null)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        using var productRequest = new </pre>
			<pre class="source-code">          HttpRequestMessage(HttpMethod.Get, </pre>
			<pre class="source-code">          $"{this.applicationSettings.Value</pre>
			<pre class="source-code">           .DataStoreEndpoint}api/products</pre>
			<pre class="source-code">           ?filterCriteria={filterCriteria}");</pre>
			<pre class="source-code">        var productResponse = await this.httpClient</pre>
			<pre class="source-code">         .SendAsync(productRequest).ConfigureAwait(false);</pre>
			<pre class="source-code">        if (!productResponse.IsSuccessStatusCode)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            await this.ThrowServiceToServiceErrors(</pre>
			<pre class="source-code">              productResponse).ConfigureAwait(false);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        products = await productResponse.Content</pre>
			<pre class="source-code">          .ReadFromJsonAsync&lt;IEnumerable&lt;Packt</pre>
			<pre class="source-code">          .Ecommerce.Data.Models.Product&gt;&gt;()</pre>
			<pre class="source-code">          .ConfigureAwait(false);</pre>
			<pre class="source-code">        if (products.Any())</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            await this.cacheService.AddOrUpdateCacheAsync</pre>
			<pre class="source-code">              &lt;IEnumerable&lt;Packt.Ecommerce.Data.Models</pre>
			<pre class="source-code">             .Product&gt;&gt;($"products{filterCriteria}", </pre>
			<pre class="source-code">             products).ConfigureAwait(false);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    var productList = t<a id="_idTextAnchor1170"/>his.autoMapper.Map&lt;List</pre>
			<pre class="source-code">      &lt;ProductListViewModel&gt;&gt;(products);</pre>
			<pre class="source-code">    return productList;</pre>
			<pre class="source-code">}</pre>
			<p>We will follow a similar pattern and implement <strong class="source-inline">AddProductAsync</strong>, <strong class="source-inline">UpdateProductAsync</strong>, <strong class="source-inline">GetProductByIdAsync</strong>, and <strong class="source-inline">DeleteProductAsync</strong>. The only difference in each of these methods would be to use the relevant <strong class="source-inline">HttpClient</strong> me<a id="_idTextAnchor1171"/><a id="_idTextAnchor1172"/>thod <a id="_idIndexMarker955"/>and handle them accordingly. Now that we have our service impl<a id="_idTextAnchor1173"/>emented, let's implement our controller.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor1174"/>Implementing action methods in the controller</h2>
			<p>Let's first inject<a id="_idIndexMarker956"/> the service created in the previous<a id="_idIndexMarker957"/> section into the ASP.NET Core 6 DI container so that we can use constructor injection to create an object of <strong class="source-inline">ProductsService</strong>. We will do this in the <strong class="source-inline">Program</strong> class using the following code:</p>
			<pre class="source-code">builder.Services.AddScoped&lt;IProductService, ProductsService&gt;();</pre>
			<p>Also, ensure that all the required framework components—such as <strong class="source-inline">ApplicationSettings</strong>, <strong class="source-inline">CacheService</strong>, and <strong class="source-inline">AutoMapper</strong>—are configured.</p>
			<p>Add a controller to the <strong class="source-inline">Controllers</strong> folder and name it <strong class="source-inline">ProductsController</strong> with the default route as <strong class="source-inline">api/products</strong>, and then add an <strong class="source-inline">IProductService</strong> property and inject it using constructor injection. The controller should implement five action methods, each calling one of the service methods, and use various out-of-the-box helper methods and attributes discussed in <em class="italic">The ControllerBase class, the</em> <em class="italic">ApiController attribute, and the ActionResult class</em> section of this chapter. The methods for retrieving<a id="_idIndexMarker958"/> specific products and <a id="_idIndexMarker959"/>creating a new product are shown in the following code block:</p>
			<pre class="source-code">[HttpGet]</pre>
			<pre class="source-code">[Route("{id}")]</pre>
			<pre class="source-code">public async Task&lt;IActionResult&gt; GetProductById(string id, [FromQuery][Required]string name)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    // FromQuery supports reading parameters from query </pre>
			<pre class="source-code">    // string, here the value of the query string parameter </pre>
			<pre class="source-code">    // 'name' will be mapped to name parameter.</pre>
			<pre class="source-code">    var product = await </pre>
			<pre class="source-code">      this.productService.GetProductByIdAsync(id, </pre>
			<pre class="source-code">      name).ConfigureAwait(false);</pre>
			<pre class="source-code">    if (product != null)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return this.Ok(product);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    else</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return this.NoContent();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">[HttpPost]</pre>
			<pre class="source-code">public async Task&lt;IActionResult&gt; AddProductAsync(ProductDetailsViewModel product)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    // Product null check is to avoid null attribute </pre>
			<pre class="source-code">    // validation error.</pre>
			<pre class="source-code">    if (product == null || product.Etag != null)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return this.BadRequest();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    var result = await this.productService</pre>
			<pre class="source-code">      .AddProductAsync(product).ConfigureAwait(false);</pre>
			<pre class="source-code">    return this.CreatedAtAction(nameof(</pre>
			<pre class="source-code">      th<a id="_idTextAnchor1175"/>is.GetProductById), new { id = result.Id, na<a id="_idTextAnchor1176"/>me = </pre>
			<pre class="source-code">      result.Name }, result); // HATEOS principle</pre>
			<pre class="source-code">}</pre>
			<p>The<a id="_idIndexMarker960"/> method<a id="_idIndexMarker961"/> implementation is self-explanatory and based purely on the fundamentals discussed in the <em class="italic">Handling requests using controllers and actions</em> section of this chapter. Similarly, we will implement all the other methods (<strong class="source-inline">Delete</strong>, <strong class="source-inline">Update</strong>, and <strong class="source-inline">Get</strong> all products) by calling the corresponding service method and returning the relevant <strong class="source-inline">ActionResult</strong>. Wit<a id="_idTextAnchor1177"/>h that, we will have APIs shown in the following table to handle various scenarios related to the product entity:</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/Table_10.2.jpg" alt="Table 10.2 &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.2 </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Another common scenario with APIs is to have an API that supports file upload/download. The upload scenario is achieved by passing <strong class="source-inline">IFormFile</strong> as an input parameter to the API. This serializes the uploaded file and can also save on the server. Similarly, for file downloading, <strong class="source-inline">FileContentResult</strong> is av<a id="_idTextAnchor1178"/>ailable and can stream files to any client. This is left to you as a<a id="_idTextAnchor1179"/>n activity to explore further.</p>
			<p>Fo<a id="_idTextAnchor1180"/>r the<a id="_idIndexMarker962"/> testing<a id="_idIndexMarker963"/> API, we will use Postman (<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>). All Postman collections can be found under the <strong class="source-inline">Solution Items</strong> folder file, <strong class="source-inline">Mastering enterprise application development Book.postman_collection.json</strong>. To import a collection once Postman has been installed, perform the following steps:</p>
			<ol>
				<li value="1">Open Postman, and then click on <strong class="bold">File</strong>.</li>
				<li>Click <strong class="bold">Import</strong> | <strong class="bold">Upload files</strong>, navigate to the location of the <strong class="source-inline">Mastering enterprise application development Book.postman_collection.json</strong> file and then click on <strong class="bold">Import</strong>.</li>
			</ol>
			<p>A succe<a id="_idTextAnchor1181"/>ssful import will show the collection in the <strong class="bold">Collectio<a id="_idTextAnchor1182"/>ns</strong> menu of Postman, as depicted in the following <a id="_idTextAnchor1183"/>screenshot:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/Figure_10.8_B18507.jpg" alt="Figure 10.8 – Collections in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – Collections in Postman</p>
			<p>This completes our <strong class="source-inline">Products</strong> RESTful service implementation. All the other services mentioned at the beginning of this section are implemented in a similar wa<a id="_idTextAnchor1184"/><a id="_idTextAnchor1185"/>y, where each of them is <a id="_idIndexMarker964"/>an <a id="_idIndexMarker965"/>individual web <a id="_idTextAnchor1186"/>API project and handles the relevant domain logic for that en<a id="_idTextAnchor1187"/>tity.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor1188"/>Understanding gRPC</h1>
			<p>As per <strong class="source-inline">grpc.io</strong>, gRPC is<a id="_idIndexMarker966"/> a high-performance, open source universal<a id="_idTextAnchor1189"/> RPC framework. Originally developed by Google, gRPC uses HTTP/2 for transport and a <strong class="bold">Protocol Buffer</strong> (<strong class="bold">protobuf</strong>) as the <a id="_idIndexMarker967"/>interface description language. gRPC is a contract-based binary communication system, and it is available across multiple ecosystems. The fol<a id="_idTextAnchor1190"/>lowing diagram from gRPC's official documentation (<span class="hidden">https://grpc.io</span>) illustrates client<a id="_idTextAnchor1191"/>-server interaction using gRPC:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/Figure_10.9_B18507.jpg" alt="Figure 10.9 – gRPC client-server interaction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – gRPC client-server interaction</p>
			<p>As with many distributed systems, gRPC is based on the idea of defining a service and specifying an interface with methods that can be invoked remotely, along with contracts. In gRPC, the server implements the interface and runs the gRPC server to handle client<a id="_idIndexMarker968"/> calls. The client side has the stub, which provides the same interface as defined by the server. The client calls the stub in the same way as it invokes methods in any other local object to invoke a method on the server.</p>
			<p>By default, data<a id="_idIndexMarker969"/> contracts use <strong class="bold">protocol buffers</strong> (<strong class="bold">protobufs</strong>) to serialize the data from and to the client. Protobufs are defined in a text file with a <strong class="source-inline">.proto</strong> extension. In a protobuf, the data is structured as a logical record of the information contained in fields. In the upcoming section, we will learn about how to d<a id="_idTextAnchor1192"/>efine a protobuf in Visual Studio for a .NET 6 application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the official documentation to learn more about gRPC: <a href="https://grpc.io">https://grpc.io</a>. To learn more about <a id="_idIndexMarker970"/>protobufs, refer to <a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a>.</p>
			<p>Given the benefits of high performance, language-agnostic implementation, and reduced network usage associated with the protobuf of gRPC, many teams are exploring the use of gRPC in<a id="_idIndexMarker971"/> th<a id="_idTextAnchor1193"/><a id="_idTextAnchor1194"/>eir endeavors to build microservices.<a id="_idTextAnchor1195"/></p>
			<p>In the next section, we will learn how to build a gRPC server a<a id="_idTextAnchor1196"/>nd client in .NET 6.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor1197"/>Building a gRPC server in .NET</h2>
			<p>After making<a id="_idIndexMarker972"/> its<a id="_idIndexMarker973"/> first appearance in .NET Core 3.0, gRPC has become a first-class citizen in the .NET ecosystem. Fully managed gRPC implementation is now available in .NET. Using Visual Studio 2022 and .NET 6, we can create gRPC server and client applications easily. Let's create a gRPC<a id="_idTextAnchor1198"/> service using the gRPC service template in Visual Studio, shown in the following screenshot, and name it <strong class="source-inline">gRPCDemoService</strong>:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/Figure_10.10_B18507.jpg" alt="Figure 10.10 – gRPC Visual Studio 2022 project template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – gRPC Visual Studio 2022 project template</p>
			<p>This will create a solution with a sample gRPC service named <strong class="source-inline">GreetService</strong>. Let's now understand the solution created with the template. The solution created will have a package reference to <strong class="source-inline">Grpc.AspNetCore</strong>. This will have the libraries required to host the gRPC service and a code generator for the <strong class="source-inline">.proto</strong> files. This solution will have a proto file created for <strong class="source-inline">GreetService</strong> under the <strong class="source-inline">Protos</strong> solution folder. The following code defines the <strong class="source-inline">Greeter</strong> service:</p>
			<pre class="source-code">service Greeter {</pre>
			<pre class="source-code">  // Sends a greeting</pre>
			<pre class="source-code">  rpc SayHello (HelloRequest) returns (HelloReply);</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">Greeter</strong> service has only one method named <strong class="source-inline">SayHello</strong>, which takes the input parameter as <strong class="source-inline">HelloRequest</strong> and returns a message of the <strong class="source-inline">HelloReply</strong> type. <strong class="source-inline">HelloRequest</strong> and <strong class="source-inline">HelloReply</strong> messages are defined in the same proto file, as shown in the followi<a id="_idTextAnchor1199"/>ng code snippet:</p>
			<pre class="source-code">message HelloRequest {</pre>
			<pre class="source-code">  string n<a id="_idTextAnchor1200"/>ame = 1;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">message HelloReply {</pre>
			<pre class="source-code">  string message = 1;</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">HelloRequest</strong> has one field named <strong class="source-inline">name</strong>, and <strong class="source-inline">HelloReply</strong> has one field named <strong class="source-inline">message</strong>. The<a id="_idIndexMarker974"/> number<a id="_idIndexMarker975"/> next to the field shows the ordinal position of the field in the buffer. The proto files are compiled with the <strong class="source-inline">Protobuf</strong> compiler to generate stub classes with all the plumbing required. We can specify the kind of stub classes to generate from the properties of the proto file. Since this is a server, it will have the configuration set to <strong class="bold">Server only</strong>.</p>
			<p>Now, let's look at the <strong class="source-inline">GreetService</strong> implementation. This will appear as shown in the following code snippet:</p>
			<pre class="source-code">public class GreeterService : Greeter.GreeterBase</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    private readonly ILogger&lt;GreeterService&gt; _logger;</pre>
			<pre class="source-code">    public GreeterService(ILogger&lt;GreeterService&gt; logger)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        _logger = logger;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public override Task&lt;HelloReply&gt; SayHello(</pre>
			<pre class="source-code">      HelloRequest request, ServerCallContext context)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        return Task.FromResult(new HelloReply</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            Message = "H<a id="_idTextAnchor1201"/>ello " + request.Name</pre>
			<pre class="source-code">        });</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">GreetService</strong> inh<a id="_idTextAnchor1202"/>erits from <strong class="source-inline">Greeter.GreeterBase</strong>, which is generated by the protobuf compiler. The <strong class="source-inline">SayHello</strong> method is overridden to provide the implementation so as to return a greeting to the caller by constructing <strong class="source-inline">HelloReply</strong>, as defined in the proto file.</p>
			<p>To expose gRPC services in a .NET 6 application, all the required gRPC services are to be added to the service collection by calling <strong class="source-inline">AddGrpc</strong> in the <strong class="source-inline">Program</strong> class. The <strong class="source-inline">GreeterService</strong> gRPC service is exposed by calling <strong class="source-inline">MapGrpcService</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">app.MapGrpcService&lt;GreeterService&gt;();</pre>
			<p>That is<a id="_idIndexMarker976"/> everything<a id="_idIndexMarker977"/> that is required to ex<a id="_idTextAnchor1203"/><a id="_idTextAnchor1204"/>pose a gRPC service in a .NET 6 a<a id="_idTextAnchor1205"/>pplication. In the next section, we will implement a .NET 6 client to consume <strong class="source-inline">GreeterServ<a id="_idTextAnchor1206"/>ice</strong>.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor1207"/>Building a gRPC client in .NET</h2>
			<p>As specified<a id="_idIndexMarker978"/> at<a id="_idIndexMarker979"/> the start of this <em class="italic">Understanding gRPC</em> section, .NET 6 has very good tooling for building a gRPC client as well. In this section, we will be building a gRPC client in a console application. Here are the steps to follow for you to accomplish this:</p>
			<ol>
				<li value="1">Create a .NET 6 console application and name it <strong class="source-inline">gRPCDemoClient</strong>.</li>
				<li>Now, right-click on the project and cli<a id="_idTextAnchor1208"/>ck on the <strong class="bold">Add</strong> | <strong class="bold">Service reference…</strong> menu items. This will open the <strong class="bold">Connected Services</strong> tab, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/Figure_10.11_B18507.jpg" alt="Figure 10.11 – gRPC Connected Services tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – gRPC Connected Services tab</p>
			<ol>
				<li value="3">Select <strong class="bold">gRPC</strong> in<a id="_idIndexMarker980"/> the <strong class="bold">Add service reference</strong> dialog, and then<a id="_idIndexMarker981"/> click on <strong class="bold">Next</strong>.</li>
				<li>In the <strong class="bold">Add new gRPC service reference</strong> dialog, as shown in the following screenshot, select the <strong class="bold">File</strong> option, then select the <strong class="source-inline">greet.proto</strong> file from <strong class="source-inline">gRPC<a id="_idTextAnchor1209"/>DemoService</strong>,<a id="_idTextAnchor1210"/> and then click on the <a id="_idTextAnchor1211"/><strong class="bold">Finish</strong> button. This will add the proto file link to the project and marks the protobuf compiler to generate <strong class="source-inline">Client</strong> stub classes:</li>
			</ol>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/Figure_10.12_B18507.jpg" alt="Figure 10.12 – Adding a gRPC service reference&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – Adding a gRPC service reference</p>
			<p>This will also add the required <strong class="source-inline">Google.Protobuf</strong>, <strong class="source-inline">Grpc.Net.ClientFactory</strong>, and <strong class="source-inline">Grpc.Tools</strong> NuGet packages to the project.</p>
			<ol>
				<li value="5">Now, add <a id="_idIndexMarker982"/>the <a id="_idIndexMarker983"/>following code to the <strong class="source-inline">Program</strong> class of the <strong class="source-inline">gRPCDemoClient</strong> project:<p class="source-code"><strong class="bold">    var channel = GrpcChannel.ForAddress("https://localhost:5001");</strong></p><p class="source-code"><strong class="bold">    var client = new Greeter.GreeterClient(channel);</strong></p><p class="source-code"><strong class="bold">    HelloReply response = await client.SayHelloAsync(new HelloRequest { Name="Suneel" });</strong></p><p class="source-code"><strong class="bold">    Console.WriteLine(response.Message);</strong></p></li>
			</ol>
			<p>In this code snippet, we are creating a gRPC channel to the <strong class="source-inline">gRPCDemoService</strong> endpoint<a id="_idTextAnchor1212"/>, and then instantiating <strong class="source-inline">Greeter.GreeterClient</strong>, which is a <a id="_idTextAnchor1213"/>stub to <strong class="source-inline">gRPCDemoService</strong>, by passing in the gRPC channel.</p>
			<ol>
				<li value="6">Now, to invoke the service, we just need to call the <strong class="source-inline">SayHelloAsync</strong> method on the stub by passing the <strong class="source-inline">HelloRequest</strong> message. This call will return <strong class="source-inline">HelloReply</strong> from the service.</li>
			</ol>
			<p>Up to now, we <a id="_idIndexMarker984"/>have<a id="_idIndexMarker985"/> created a simple gRPC service and a<a id="_idTextAnchor1214"/><a id="_idTextAnchor1215"/> console client for that service. In the next section, we <a id="_idTextAnchor1216"/>will learn about <strong class="source-inline">grpcurl</strong>, which is a generic client to test gRPC services.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor1217"/>Testing gRPC services</h2>
			<p>To test or invoke a <a id="_idIndexMarker986"/>REST service, we use tools such as Postman or Fiddler. <strong class="source-inline">grpcurl</strong> is a command-line utility that helps us to interact with gRPC services. Using <strong class="source-inline">grpcurl</strong>, we can test gRPC services without building client apps. <strong class="source-inline">grpcurl</strong> is available for download from <a href="https://github.com/fullstorydev/grpcurl">https://github.com/fullstorydev/grpcurl</a>.</p>
			<p>Once <strong class="source-inline">grpcurl</strong> is downloaded, we can call <strong class="source-inline">GreeterService</strong> u<a id="_idTextAnchor1218"/>sing the following command:</p>
			<pre class="source-code">grpcurl -d "{\"name\": \"World\"}" localhost:5001 greet.Greeter/SayHello</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Currently, gRPC <a id="_idIndexMarker987"/>applications can only be hosted in Azure App Service and <strong class="bold">Internet Information Services</strong> (<strong class="bold">IIS</strong>), hence we did not leverage gRPC in the demo e-commerce application that is hosted on Azure App Service. However, there is a version of the e-commerce a<a id="_idTextAnchor1219"/><a id="_idTextAnchor1220"/>pplication in this chapter demo, where obtaining a product according to its ID is exposed as a gRPC endpoint in a self-hosted service.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor1221"/>Summary</h1>
			<p>In this chapter, we covered the basic principles of REST and also designed enterprise-level RESTful services for our e-commerce application.</p>
			<p>Along the way, we got to grips with the various web API internals of an ASP.NET Core 6 web API—including routing and sample middleware—and became familiar with tools for testing our services, while learning how to handle requests using a controller and its actions, which we also learned to build. Also, we saw how to create and test basic gRPC client and server applications in .NET 6. You should now be able to confidently build RESTful services using an ASP.NET Core 6 web API.</p>
			<p>In the n<a id="_idTextAnchor1222"/><a id="_idTextAnchor1223"/>ext chapter, we will go through the fundamentals of ASP.NET MVC, build our UI layer using ASP.NET MVC, and integrate it with our APIs.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor1224"/>Questions</h1>
			<ol>
				<li value="1">Which of the following HTTP verbs is recommended for creating a resource?</li>
			</ol>
			<p>a. <strong class="source-inline">GET</strong></p>
			<p>b. <strong class="source-inline">POST</strong></p>
			<p>c. <strong class="source-inline">DELETE</strong></p>
			<p>d. <strong class="source-inline">PUT</strong></p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="2">Which of the following HTTP status codes represents <strong class="source-inline">No Content</strong>?</li>
			</ol>
			<p>a. <strong class="source-inline">200</strong></p>
			<p>b. <strong class="source-inline">201</strong></p>
			<p>c. <strong class="source-inline">202</strong></p>
			<p>d. <strong class="source-inline">204</strong></p>
			<p><strong class="bold">Answer: d</strong></p>
			<ol>
				<li value="3">Which of the following middlewares is used to configure routing?</li>
			</ol>
			<p>a. <strong class="source-inline">UseDeveloperExceptionPage()</strong></p>
			<p>b. <strong class="source-inline">UseHttpsRedirection()</strong></p>
			<p>c. <strong class="source-inline">UseRouting()</strong></p>
			<p>d. <strong class="source-inline">UseAuthorization()</strong></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="4">If a controller is annotated with the <strong class="source-inline">[ApiController]</strong> attribute, do I need to class <strong class="source-inline">ModelState.IsValid</strong> explicitly in each action method?</li>
			</ol>
			<p>a. Yes—model validation isn't part of the <strong class="source-inline">ApiController</strong> attribute, hence you need to call <strong class="source-inline">ModelState.Valid</strong> in each action method.</p>
			<p>b. No—model validatio<a id="_idTextAnchor1225"/><a id="_idTextAnchor1226"/>n is handled as part of the <strong class="source-inline">ApiController</strong> attribute, hence <strong class="source-inline">ModelState.Valid</strong> is triggered automatically for all action items.</p>
			<p><strong class="bold">Answer: b</strong></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor1227"/>Further reading</h1>
			<ul>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/odata/overview">https://docs.microsoft.com/en-us/odata/overview</a></li>
			</ul>
		</div>
	</body></html>