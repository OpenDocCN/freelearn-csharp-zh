- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Movement, Camera Controls, and Collisions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动、摄像机控制和碰撞
- en: One of the first things a player does when starting a new game is to try out
    character movement (if, of course, the game has a moveable character) and camera
    controls. Not only is this exciting, but it lets your player know what kind of
    gameplay they can expect. The character in *Hero Born* will be a capsule object
    that can be moved and rotated using the `W`, `A`, `S`, `D`, or arrow keys, respectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家在开始新游戏时做的第一件事通常是尝试角色移动（如果游戏中有可移动的角色）和摄像机控制。这不仅令人兴奋，而且可以让你的玩家知道他们可以期待什么样的游戏玩法。"英雄降世"中的角色将是一个胶囊对象，可以使用`W`、`A`、`S`、`D`键或箭头键分别进行移动和旋转。
- en: We'll start by learning how to manipulate the player object's `Transform` component
    and then replicate the same player control scheme using applied force. This produces
    a more realistic movement effect. When we move the player, the camera will follow
    along from a position that is slightly behind and above the player, making aiming
    easier when we implement the shooting mechanic. Finally, we'll explore how collisions
    and physical interactions are handled by Unity's physics system by working with
    our item pickup Prefab.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何操作玩家对象的`Transform`组件，然后使用施加的力来复制相同的玩家控制方案。这会产生更逼真的移动效果。当我们移动玩家时，摄像机将从稍微在玩家后面和上面的位置跟随，这使得在实现射击机制时瞄准更容易。最后，我们将通过使用我们的物品拾取Prefab来探索Unity的物理系统如何处理碰撞和物理交互。
- en: 'All of this will come together at a playable level, albeit without any shooting
    mechanics just yet. It''s also going to give us our first taste of C# being used
    to program game features by tying together the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将汇集在一个可玩级别上，尽管目前还没有任何射击机制。这还将让我们第一次尝到使用C#编程游戏功能的滋味，通过结合以下主题：
- en: Managing player movement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理玩家移动
- en: Moving the player with the `Transform` component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Transform`组件移动玩家
- en: Scripting camera behavior
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写摄像机行为脚本
- en: Working with the Unity physics system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity物理系统
- en: Managing player movement
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理玩家移动
- en: When you're deciding on how best to move your player character around your virtual
    world, consider what's going to look the most realistic and not run your game
    into the ground with expensive computations. This is somewhat of a trade-off in
    most cases, and Unity is no different.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定如何最好地在你的虚拟世界中移动玩家角色时，考虑什么看起来最逼真，并且不会因为昂贵的计算而让你的游戏陷入困境。这在大多数情况下是一种权衡，Unity也不例外。
- en: 'The three most common ways of moving a `GameObject` and their results are as
    follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 移动`GameObject`的三个最常见方法及其结果如下：
- en: '**Option A**: Use a `GameObject`''s `Transform` component for movement and
    rotation. This is the easiest solution and the one we''ll be working with first.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项A**：使用`GameObject`的`Transform`组件进行移动和旋转。这是最简单的解决方案，也是我们将首先使用的方案。'
- en: '**Option B**: Use real-world physics by attaching a **Rigidbody** component
    to a `GameObject` and apply force in code. `Rigidbody` components add simulated
    real-world physics to any `GameObject` they are attached to. This solution relies
    on Unity''s physics system to do the heavy lifting, delivering a far more realistic
    effect. We''ll update our code to use this approach later on in this chapter to
    get a feel for both methods.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项B**：通过将**Rigidbody**组件附加到`GameObject`并应用代码中的力来使用现实世界的物理。`Rigidbody`组件为它们附加到的任何`GameObject`添加了模拟的现实世界物理。这种解决方案依赖于Unity的物理系统来完成繁重的工作，从而产生更逼真的效果。我们将在本章后面更新我们的代码以使用这种方法，以便了解两种方法。'
- en: Unity suggests sticking to a consistent approach when moving or rotating a `GameObject`;
    either manipulate an object's `Transform` or `Rigidbody` component, but never
    both at the same time.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity建议在移动或旋转`GameObject`时保持一致的方法；要么操作一个对象的`Transform`或`Rigidbody`组件，但不要同时操作两者。
- en: '**Option C**: Attach a ready-made Unity component or Prefab, such as Character
    Controller or First Person Controller. This cuts out the boilerplate code and
    still delivers a realistic effect while speeding up the prototyping time.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项C**：附加一个现成的Unity组件或Prefab，例如Character Controller或First Person Controller。这可以省去样板代码，同时仍然提供逼真的效果，并加快原型设计的时间。'
- en: You can find more information on the Character Controller component and its
    uses at [https://docs.unity3d.com/ScriptReference/CharacterController.html](https://docs.unity3d.com/ScriptReference/CharacterController.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unity3d.com/ScriptReference/CharacterController.html](https://docs.unity3d.com/ScriptReference/CharacterController.html)上找到有关Character
    Controller组件及其用途的更多信息。
- en: The First Person Controller Prefab is available from the Standard Assets package,
    which you can download from [https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351](https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一人称控制器Prefab可以从标准资产包中获取，您可以从[https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351](https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351)下载。
- en: Since you're just getting started with player movement in Unity, you'll start
    off using the player Transform component in the next section, and then move on
    to `Rigidbody` physics later in the chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你刚开始在Unity中使用玩家移动，你将在下一节中使用玩家Transform组件，然后在章节的后面部分学习`Rigidbody`物理。
- en: Moving the player with the Transform component
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Transform组件移动玩家
- en: We want a third-person adventure setup for *Hero Born*, so we'll start with
    a capsule that can be controlled with keyboard input and a camera to follow the
    capsule as it moves. Even though these two GameObjects will work together in the
    game, we'll keep them and their scripts separate for better control.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为*英雄降生*设置一个第三人称冒险场景，所以我们将从一个可以通过键盘输入控制的胶囊开始，并设置一个跟随胶囊移动的摄像头。尽管这两个GameObject将在游戏中协同工作，但我们将保持它们及其脚本的分离，以便更好地控制。
- en: Before we can do any scripting, you'll need to add a player capsule to the scene,
    which is your next task.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何脚本编写之前，你需要将玩家胶囊添加到场景中，这是你的下一个任务。
- en: 'We can create a nice player capsule in just a few steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅通过几个步骤就创建一个不错的玩家胶囊：
- en: Click on **+** | **3D Object** | **Capsule** from the **Hierarchy** panel and
    name it `Player`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**面板中点击**+** | **3D Object** | **Capsule**，并将其命名为`Player`。
- en: Select the `Player` GameObject and click on **Add Component** at the bottom
    of the **Inspector** tab. Search for **Rigidbody** and hit `Enter` to add it.
    We won't use this component until later, but it's good to set things up properly
    at the beginning.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Player`GameObject，然后在**Inspector**标签页底部点击**Add Component**。搜索**Rigidbody**并按`Enter`键添加它。我们将在稍后使用此组件，但最好从一开始就正确设置好。
- en: 'Expand the **Constraints** property at the bottom of the **Rigidbody** component:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**Rigidbody**组件底部的**Constraints**属性：
- en: Check the boxes for **Freeze Rotation** on the **X**, **Y**, and **Z** axes
    so the player can't be rotated in any way other than through the code we'll write
    later on:![](img/B17573_07_01.png)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**X**、**Y**和**Z**轴上勾选**Freeze Rotation**的复选框，这样玩家就不能通过我们稍后编写的代码以外的任何方式旋转：![img/B17573_07_01.png](img/B17573_07_01.png)
- en: 'Figure 7.1: Rigidbody component'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1：Rigidbody组件
- en: Select the `Materials` folder in the **Project** panel and click on **Create**
    | **Material**. Name it `Player_Mat`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**面板中选择`Materials`文件夹，然后点击**Create** | **Material**。将其命名为`Player_Mat`。
- en: Select `Player_Mat` in the **Hierarchy**, then change the **Albedo** property
    in the **Inspector** to a bright green and drag the material to the **Player**
    object in the **Hierarchy** panel:![](img/B17573_07_02.png)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**面板中选择`Player_Mat`，然后在**Inspector**面板中将**Albedo**属性更改为明亮的绿色，并将材质拖动到**Hierarchy**面板中的**Player**对象上：![img/B17573_07_02.png](img/B17573_07_02.png)
- en: 'Figure 7.2: Player material attached to capsule'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：胶囊上的玩家材质
- en: 'You''ve created the **Player** object out of a capsule primitive, a Rigidbody
    component, and a new bright green material. Don''t worry about what the Rigidbody
    component is just yet—all you need to know right now is that it allows our capsule
    to interact with the physics system. We''ll go into more detail at the end of
    this chapter when we discuss how Unity''s physics system works. Before we get
    to that, we need to talk about a very important subject in 3D space: vectors.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用胶囊原形、Rigidbody组件和一种新的明亮的绿色材质创建了一个**玩家**对象。现在不必担心Rigidbody组件是什么——你只需要知道它允许我们的胶囊与物理系统交互。我们将在本章末尾讨论Unity的物理系统工作原理时详细介绍。在我们到达那里之前，我们需要讨论3D空间中的一个非常重要的话题：向量。
- en: Understanding vectors
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解向量
- en: Now that we have a player capsule and camera set up, we can start looking at
    how to move and rotate a GameObject using its `Transform` component. The `Translate`
    and `Rotate` methods are part of the `Transform` class that Unity provides, and
    each needs a vector parameter to perform its given function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了玩家胶囊和摄像头，我们可以开始探讨如何使用其`Transform`组件来移动和旋转GameObject。`Translate`和`Rotate`方法是Unity提供的`Transform`类的一部分，每个方法都需要一个向量参数来执行其特定的功能。
- en: In Unity, vectors are used to hold position and direction data in 2D and 3D
    spaces, which is why they come in two varieties—`Vector2` and `Vector3`. These
    can be used like any other variable type we've seen; they just hold different
    information. Since our game is in 3D, we'll be using `Vector3` objects, which
    means we'll need to construct them using *x*, *y*, and *z* values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，向量用于在2D和3D空间中保存位置和方向数据，这就是为什么它们有两种类型——`Vector2`和`Vector3`。它们可以像我们见过的任何其他变量类型一样使用；它们只是保存不同的信息。由于我们的游戏是3D的，我们将使用`Vector3`对象，这意味着我们需要使用*x*、*y*和*z*值来构建它们。
- en: 'For 2D vectors, only the *x* and *y* positions are required. Remember, the
    most up-to-date orientation in your 3D scene will be displayed in the upper-right
    graphic that we discussed in the previous chapter, *Chapter 6*, *Getting Your
    Hands Dirty with Unity*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2D向量，只需要*x*和*y*位置。记住，您3D场景中最新的方向将在我们之前章节中讨论的右上角图形中显示，即*第6章*，*用Unity动手实践*：
- en: '![](img/B17573_07_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_07_03.png)'
- en: 'Figure 7.3: Vector gizmos in Unity editor'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：Unity编辑器中的向量图示
- en: If you would like more information about vectors in Unity, refer to the documentation
    and scripting reference at [https://docs.unity3d.com/ScriptReference/Vector3.html](https://docs.unity3d.com/ScriptReference/Vector3.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Unity中向量的信息，请参考[https://docs.unity3d.com/ScriptReference/Vector3.html](https://docs.unity3d.com/ScriptReference/Vector3.html)的文档和脚本参考。
- en: 'For instance, if we wanted to create a new vector to hold the origin position
    of our scene, we could use the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个新的向量来保存场景的原点位置，我们可以使用以下代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All we've done here is created a new `Vector3` variable and initialized it with
    a `0` for the *x* position, `0` for the *y* position, and `0` for the *z* position,
    in that order. This spawns the player at the origin of the game arena. `Float`
    values can be written with or without a decimal, but they always need to end with
    a lowercase `f`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是创建了一个新的`Vector3`变量，并按顺序用`0`初始化其*x*位置、*y*位置和*z*位置。这将在游戏竞技场的原点生成玩家。浮点值可以带小数点或不带小数点，但它们总是需要以小写`f`结尾。
- en: 'We can also create directional vectors by using the `Vector2` or `Vector3`
    class properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用`Vector2`或`Vector3`类的属性来创建方向向量：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of holding a position, `ForwardDirection` references the forward direction
    in our scene along the *z* axis in the 3D space. The neat thing about using the
    Vector3 direction is that no matter which way we make the player look, our code
    will always know which way is forward. We'll look at using vectors later in this
    chapter, but for now just get used to thinking about 3D movement in terms of *x*,
    *y*, and *z* positions and directions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与保持位置不同，`ForwardDirection`引用了我们场景中沿3D空间中的*z*轴的前进方向。使用Vector3方向的一个好处是，无论我们让玩家朝哪个方向看，我们的代码总是会知道哪个方向是前进的。我们将在本章后面讨论如何使用向量，但现在只需习惯于用*x*、*y*和*z*位置和方向来思考3D移动。
- en: 'Don''t worry if the concept of vectors is new to you—it''s a complicated topic.
    Unity''s vector cookbook is a great place to start: [https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量的概念对您来说是新的，请不要担心——这是一个复杂的话题。Unity的向量食谱是一个很好的起点：[https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html)。
- en: Now that you understand vectors a bit more, you can start implementing the basics
    of moving the player capsule. For that, you'll need to gather player input from
    the keyboard, which is the topic of the following section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对向量有了更多的了解，您就可以开始实现移动玩家胶囊的基本功能了。为此，您需要从键盘收集玩家输入，这是下一节的主题。
- en: Getting player input
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取玩家输入
- en: Positions and directions are useful in themselves, but they can't generate movement
    without input from the player. This is where the `Input` class comes in, which
    handles everything from keystrokes and mouse position to acceleration and gyroscopic
    data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 位置和方向本身很有用，但如果没有玩家的输入，它们不能产生移动。这就是`Input`类发挥作用的地方，它处理从按键和鼠标位置到加速度和陀螺仪数据的所有事情。
- en: We're going to be using the `W`, `A`, `S`, `D`, and arrow keys for movement
    in *Hero Born*, coupled with a script that allows the camera to follow where the
    player points the mouse. To do that, we'll need to understand how input axes work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在《英雄降生》中，我们将使用`W`、`A`、`S`、`D`和箭头键进行移动，并配合一个允许相机跟随玩家鼠标指向的脚本。为此，我们需要了解输入轴的工作原理。
- en: 'First, go to **Edit** | **Project Settings** | **Input Manager** to open up
    the **Input Manager** tab shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到 **Edit** | **Project Settings** | **Input Manager** 以打开以下截图所示的 **Input
    Manager** 选项卡：
- en: '![](img/B17573_07_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_07_04.png)'
- en: 'Figure 7.4: Input Manager window'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：输入管理器窗口
- en: 'Unity 2021 has a new input system that removes a lot of the coding work, making
    it easier to set up inputs as actions in the editor. Since this is a programming
    book, we''re going to do things from scratch. However, if you want to see how
    the new input system works, check out this great tutorial: [https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2021 引入了一个新的输入系统，该系统减少了大量的编码工作，使得在编辑器中设置输入作为动作变得更加容易。由于这是一本编程书籍，我们将从头开始。然而，如果你想了解新输入系统的工作原理，请查看这个优秀的教程：[https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity)。
- en: You'll see a long list of Unity's default inputs already configured, but let's
    take the **Horizontal** axis as an example. You can see that the **Horizontal**
    input axis has the **Positive** and **Negative** buttons set to `left` and `right`,
    and the **Alt** **Negative** and **Alt Positive** buttons set to the `a` and `d`
    keys.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个 Unity 默认输入的长列表，已经配置好了，但让我们以 **Horizontal** 轴为例。你可以看到 **Horizontal** 输入轴的
    **Positive** 和 **Negative** 按钮设置为 `left` 和 `right`，而 **Alt Negative** 和 **Alt
    Positive** 按钮设置为 `a` 和 `d` 键。
- en: Whenever an input axis is queried from the code, its value will be between -1
    and 1\. For example, when the left arrow or `A` key is pushed down, the horizontal
    axis registers a -1 value. When those keys are released, the value returns to
    0\. Likewise, when the right arrow or `D` keys are used, the horizontal axis registers
    a value of 1\. This allows us to capture four different inputs for a single axis
    with only one line of code, as opposed to writing out a long `if-else` statement
    chain for each.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码查询任何输入轴时，其值将在 -1 和 1 之间。例如，当按下左箭头或 `A` 键时，水平轴注册 -1 值。当这些键释放时，值返回 0。同样，当使用右箭头或
    `D` 键时，水平轴注册 1 的值。这允许我们仅用一行代码捕获单个轴的四个不同输入，而不是为每个输入编写一个长的 `if-else` 语句链。
- en: Capturing input axes is as simple as calling `Input.GetAxis()` and specifying
    the axis we want by name, which is what we'll do with the `Horizontal` and `Vertical`
    inputs in the following sections. As a side benefit, Unity applies a smoothing
    filter, which makes the input frame rate independent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获输入轴就像调用 `Input.GetAxis()` 并通过名称指定我们想要的轴一样简单，这就是我们在下一节中将要做的 `Horizontal` 和
    `Vertical` 输入。作为额外的好处，Unity 应用了一个平滑滤波器，这使得输入帧率独立。
- en: Default inputs can be modified in any way you need, but you can also create
    custom axes by increasing the `Size` property in the input manager and renaming
    the copy that's been created for you. You have to increase the `Size` property
    in order to add a custom input.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输入可以根据需要修改，但你也可以通过在输入管理器中增加 `Size` 属性并重命名为你创建的副本来创建自定义轴。你必须增加 `Size` 属性才能添加自定义输入。
- en: Let's start getting our player moving using Unity's input system and a custom
    locomotion script of our own.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Unity 的输入系统和我们自己的自定义移动脚本来让玩家移动。
- en: Moving the player
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动玩家
- en: 'Before you get the player moving, you''ll need to attach a script to the player
    capsule:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在你让玩家移动之前，你需要将脚本附加到玩家胶囊上：
- en: Create a new C# script in the `Scripts` folder, name it `PlayerBehavior`, and
    drag it onto the **Player** capsule in the **Hierarchy** panel.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的 C# 脚本，命名为 `PlayerBehavior`，并将其拖放到 **Hierarchy** 面板中的
    **Player** 胶囊上。
- en: 'Add the following code and save:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `this` keyword is optional. Visual Studio 2019 may suggest that you
    remove it to simplify the code, but I prefer leaving it in for clarity. When you
    have empty methods, such as `Start`, in this case, it's common to delete them
    for clarity.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `this` 关键字是可选的。Visual Studio 2019 可能建议你移除它以简化代码，但我更喜欢保留它以提高清晰度。当你有空的 `Start`
    方法等空方法时，通常为了清晰起见会删除它们。
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的分解：
- en: 'Declares two public variables to be used as multipliers:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个公共变量作为乘数：
- en: '`MoveSpeed` for how fast we want the Player to go forward and backward'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveSpeed` 用于设置玩家前后移动的速度'
- en: '`RotateSpeed` for how fast we want the Player to rotate left and right'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotateSpeed` 用于设置玩家左右旋转的速度'
- en: 'Declares two private variables to hold inputs from the player; initially set
    with no value:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有变量来保存玩家的输入；最初设置为无值：
- en: '`_vInput` will store the vertical axis input.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_vInput` 将存储垂直轴输入。'
- en: '`_hInput` will store the horizontal axis input.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_hInput` 将存储水平轴输入。'
- en: '`Input.GetAxis("Vertical")` detects when the up arrow, down arrow, `W`, or
    `S` keys are pressed and multiplies that value by `MoveSpeed`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.GetAxis("Vertical")` 检测向上箭头、向下箭头、`W` 或 `S` 键是否被按下，并将该值乘以 `MoveSpeed`：'
- en: The up arrow and `W` keys return a value of 1, which will move the player in
    the forward (positive) direction.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上箭头和 `W` 键返回值为 1，这将使玩家向前（正方向）移动。
- en: The down arrow and `S` keys return -1, which moves the player backward in the
    negative direction.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下箭头和 `S` 键返回 -1，使玩家向负方向后退。
- en: '`Input.GetAxis("Horizontal")` detects when the left arrow, right arrow, `A`,
    and `D` keys are pressed and multiplies that value by `RotateSpeed`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.GetAxis("Horizontal")` 检测左箭头、右箭头、`A` 和 `D` 键是否被按下，并将该值乘以 `RotateSpeed`：'
- en: The right arrow and `D` keys return a value of 1, which will rotate the capsule
    to the right.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右箭头和 `D` 键返回值为 1，这将使胶囊向右旋转。
- en: The left arrow and `A` keys return -1, rotating the capsule to the left.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左箭头和 `A` 键返回 -1，使胶囊向左旋转。
- en: If you're wondering whether it's possible to do all the movement calculations
    on one line, the simple answer is yes. However, it's better to have your code
    broken down, even if you're the only one reading it.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想知道是否可以在一行内完成所有移动计算，简单的回答是肯定的。然而，即使只有你自己阅读代码，将代码拆分也是更好的做法。
- en: 'Uses the `Translate` method, which takes in a `Vector3` parameter, to move
    the capsule''s Transform component:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Translate` 方法，该方法接受一个 `Vector3` 参数，来移动胶囊的 Transform 组件：
- en: Remember that the `this` keyword specifies the GameObject the current script
    is attached to, which, in this case, is the player capsule.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`this` 关键字指定了当前脚本附加的 GameObject，在这个例子中，是玩家胶囊。
- en: '`Vector3.forward` multiplied by `_vInput` and `Time.deltaTime` supplies the
    direction and speed the capsule needs to move forward or back along the *z* axis
    at the speed we''ve calculated.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.forward` 乘以 `_vInput` 和 `Time.deltaTime` 提供了胶囊在 *z* 轴上前进或后退的方向和速度，这是我们计算出的速度。'
- en: '`Time.deltaTime` will always return the value in seconds since the last frame
    of the game was executed. It''s commonly used to smooth values that are captured
    or run in the `Update` method instead of letting it be determined by a device''s
    frame rate.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time.deltaTime` 总是返回自游戏上一帧执行以来经过的秒数。它通常用于平滑在 `Update` 方法中捕获或运行的值，而不是让它由设备的帧率决定。'
- en: 'Uses the `Rotate` method to rotate the capsule''s Transform component relative
    to the vector we pass in as a parameter:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Rotate` 方法来旋转胶囊的 Transform 组件相对于我们传递的参数向量：
- en: '`Vector3.up` multiplied by `_hInput` and `Time.deltaTime` gives us the left/right
    rotation axis we want.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.up` 乘以 `_hInput` 和 `Time.deltaTime` 给我们想要的左右旋转轴。'
- en: We use the `this` keyword and `Time.deltaTime` here for the same reasons.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里使用 `this` 关键字和 `Time.deltaTime` 的原因相同。
- en: As we discussed earlier, using direction vectors in the `Translate` and `Rotate`
    functions is only one way to go about this. We could have created new Vector3
    variables from our axis inputs and used them as parameters just as easily.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，在 `Translate` 和 `Rotate` 函数中使用方向向量是处理此问题的方法之一。我们同样可以创建新的 Vector3 变量从我们的轴输入，并将它们作为参数使用。
- en: When you click play, you'll be able to move the capsule forward and backward
    using the up/down arrow keys and the `W`/`S` keys, while rotating or turning with
    the left/right arrow keys and the `A`/`D` keys.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击播放时，你可以使用上下箭头键和 `W`/`S` 键来前后移动胶囊，同时使用左右箭头键和 `A`/`D` 键进行旋转或转向。
- en: With these few lines of code, you've set up two separate controls that are frame
    rate independent and easily modified. However, our camera doesn't follow the capsule
    as it moves around, so let's fix that in the following section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行代码，你已经设置了两个独立的、与帧率无关且易于修改的控制。然而，我们的相机并没有跟随胶囊移动，所以让我们在下一节中修复这个问题。
- en: Scripting camera behavior
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本控制相机行为
- en: The easiest way to get one GameObject to follow another is to make one of them
    a child of the other. When an object is a child of another, the child object's
    position and rotation are relative to the parent. This means that any child object
    will move and rotate with the parent object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个 GameObject 跟随另一个 GameObject，最简单的方法是将其中一个设置为另一个的子对象。当一个对象是另一个对象的子对象时，子对象的位置和旋转相对于父对象。这意味着任何子对象都会随着父对象移动和旋转。
- en: However, this approach means that any kind of movement or rotation that happens
    to the player capsule also affects the camera, which is something we don't necessarily
    want. We always want the camera to be positioned a set distance behind our player
    and always rotate to look at it, no matter what. Luckily, we can easily set the
    position and rotation of the camera relative to the capsule with methods from
    the `Transform` class. It's your task to script out the camera logic in the next
    challenge.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法意味着任何发生在玩家胶囊上的移动或旋转也会影响摄像机，而这并不是我们一定想要的。我们始终希望摄像机位于玩家后方一定的距离，并且始终旋转以面向它，无论发生什么。幸运的是，我们可以通过`Transform`类的方法轻松设置摄像机相对于胶囊的位置和旋转。在下一个挑战中，你的任务是编写摄像机的逻辑脚本。
- en: 'Since we want the camera behavior to be entirely separate from how the player
    moves, we''ll be controlling where the camera is positioned relative to a target
    we can set from the **Inspector** tab:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望摄像机的行为完全独立于玩家的移动方式，我们将通过**Inspector**选项卡设置一个可以设置的目标来控制摄像机的位置：
- en: Create a new C# script in the `Scripts` folder, name it `CameraBehavior`, and
    drag it into **Main Camera** in the **Hierarchy** panel.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`CameraBehavior`，并将其拖放到**Hierarchy**面板中的**Main Camera**。
- en: 'Add the following code and save it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的分解：
- en: 'Declares a `Vector3` variable to store the distance we want between the **Main
    Camera** and the **Player** capsule:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Vector3`变量来存储我们想要在**主摄像机**和**玩家**胶囊之间的距离：
- en: We'll be able to manually set the *x*, *y*, and *z* positions of the camera
    offset in the **Inspector** because it's `public`.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是`public`的，我们可以在**Inspector**中手动设置摄像机偏移的*x*、*y*和*z*位置。
- en: These default values are what I think looks best, but feel free to experiment.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些默认值是我认为看起来最好的，但请随意实验。
- en: 'Creates a variable to hold the player capsule''s Transform information:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存玩家胶囊的Transform信息：
- en: This will give us access to its position, rotation, and scale.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将使我们能够访问其位置、旋转和缩放。
- en: We don't want any other script to be able to change the camera's target, which
    is why it's `private`.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不希望其他脚本能够更改摄像机的目标，这就是为什么它是`private`的。
- en: 'Uses `GameObject.Find` to locate the capsule by name and retrieve its Transform
    property from the scene:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GameObject.Find`通过名称定位胶囊并从场景中检索其Transform属性：
- en: This means the capsule's *x*, *y*, and *z* positions are updated and stored
    in the `_target` variable every frame.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着胶囊的*x*、*y*和*z*位置在每一帧都会更新并存储在`_target`变量中。
- en: Finding objects in the scene is a computationally expensive task, so it's good
    practice to only do it once in the `Start` method and store the reference. Never
    use `GameObject.Find` in the `Update` method, as that will try to continually
    find the object you're looking for and potentially crash the game.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中查找对象是一个计算密集型任务，因此，在`Start`方法中只执行一次并存储引用是一个好习惯。永远不要在`Update`方法中使用`GameObject.Find`，因为这会尝试不断查找你正在寻找的对象，并可能导致游戏崩溃。
- en: '`LateUpdate` is a `MonoBehavior` method, like `Start` or `Update`, that executes
    after `Update`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LateUpdate`是一个`MonoBehavior`方法，类似于`Start`或`Update`，它在`Update`之后执行：'
- en: Since our `PlayerBehavior` script moves the capsule in its `Update` method,
    we want the code in `CameraBehavior` to run after the movement happens; this guarantees
    that `_target` has the most up-to-date position to reference.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的`PlayerBehavior`脚本在`Update`方法中移动胶囊，我们希望在移动发生后运行`CameraBehavior`中的代码；这保证了`_target`有最新的位置可以参考。
- en: 'Sets the camera''s position to `_target.TransformPoint(CamOffset)` for every
    frame, which creates the following effect:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一帧将摄像机的位置设置为`_target.TransformPoint(CamOffset)`，从而产生以下效果：
- en: The `TransformPoint` method calculates and returns a relative position in the
    world space.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformPoint`方法计算并返回世界空间中的相对位置。'
- en: In this case, it returns the position of the `target` (our capsule) offset by
    `0` in the *x* axis, `1.2` in *the* y axis (putting the camera above the capsule),
    and `-2.6` in the *z* axis (putting the camera slightly behind the capsule).
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，它返回`target`（我们的胶囊）在*x*轴上偏移`0`，在*y*轴上（将摄像机置于胶囊上方）偏移`1.2`，在*z*轴上偏移`-2.6`（将摄像机稍微置于胶囊后方）的位置。
- en: The `LookAt` method updates the capsule's rotation every frame, focusing on
    the Transform parameter we pass in, which, in this case, is `_target`:![](img/B17573_07_05.png)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LookAt`方法在每一帧更新胶囊的旋转，聚焦于我们传递的Transform参数，在这种情况下，是`_target`：![](img/B17573_07_05.png)'
- en: 'Figure 7.5: Capsule and following camera in Play mode'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.5：播放模式下的胶囊和跟随摄像机
- en: 'This was a lot to take in, but it''s easier to process if you break it down
    into its chronological steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要吸收很多信息，但如果将其分解为按时间顺序排列的步骤，则更容易处理：
- en: We created an offset position for the camera.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为相机创建了一个偏移位置。
- en: We found and stored the player capsule's position.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到了并存储了玩家胶囊的位置。
- en: We manually updated its position and rotation every frame so that it's always
    following at a set distance and looking at the player.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们手动更新了每一帧的位置和旋转，以确保它始终以固定距离跟随并朝向玩家。
- en: When using class methods that deliver platform-specific functionality, always
    remember to break things down to their most basic steps. This will help you to
    stay above water in new programming environments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用提供平台特定功能的方法时，请始终记得将其分解为最基本的步骤。这将帮助你在新的编程环境中保持清醒。
- en: While the code you've written to manage player movement is perfectly functional,
    you might have noticed that it's a little jerky in places. To create a smoother,
    more realistic movement effect, you'll need to understand the basics of the Unity
    physics system, which you'll dive into next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你编写的用于管理玩家运动代码完全有效，但你可能已经注意到它在某些地方有点不流畅。为了创建更平滑、更逼真的运动效果，你需要了解 Unity 物理系统的基本知识，你将在下一节中深入了解。
- en: Working with the Unity physics system
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Unity 物理系统一起工作
- en: Up to this point, we haven't talked about how the Unity engine works, or how
    it manages to create lifelike interactions and movement in a virtual space. We'll
    spend the rest of this chapter learning the basics of Unity's physics system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论过 Unity 引擎的工作原理，或者它是如何管理在虚拟空间中创建逼真的交互和运动的。我们将在本章的剩余部分学习 Unity 物理系统的基本知识。
- en: 'The two main components that power Unity''s NVIDIA PhysX engine are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动 Unity 的 NVIDIA PhysX 引擎的两个主要组件如下：
- en: '**Rigidbody** components, which allow GameObjects to be affected by gravity
    and add properties such as **Mass** and **Drag**. Rigidbody components can also
    be affected by an applied force if they have a Collider component attached, which
    generates more realistic movement:![](img/B17573_07_06.png)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rigidbody** 组件，允许 GameObject 受重力影响并添加如 **质量** 和 **阻力** 等属性。如果 Rigidbody 组件附加了
    Collider 组件，它还可以受到施加的力的作用，从而产生更逼真的运动：![img/B17573_07_06.png](img/B17573_07_06.png)'
- en: 'Figure 7.6: Rigidbody component in the Inspector pane'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：检查器面板中的 Rigidbody 组件
- en: '**Collider** components, which determine how and when GameObjects enter and
    exit each other''s physical space or simply collide and bounce away. While there
    should only be one Rigidbody component attached to a given GameObject, there can
    be several Collider components if you need different shapes or interactions. This
    is commonly referred to as a compound Collider setup:![](img/B17573_07_07.png)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collider** 组件，确定 GameObject 如何以及何时进入和退出彼此的物理空间，或者简单地碰撞并弹开。虽然应该只有一个 Rigidbody
    组件附加到特定的 GameObject，但如果需要不同的形状或交互，则可以有多个 Collider 组件。这通常被称为复合 Collider 设置：![img/B17573_07_07.png](img/B17573_07_07.png)'
- en: 'Figure 7.7: Box collider component in the Inspector pane'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：检查器面板中的盒子碰撞器组件
- en: When two Collider components interact with each other, the Rigidbody properties
    determine the resulting interaction. For example, if one GameObject's mass is
    higher than the other, the lighter GameObject will bounce away with more force,
    just like in real life. These two components are responsible for all physical
    interactions and simulated movement in Unity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个 Collider 组件相互作用时，Rigidbody 属性决定了产生的交互。例如，如果一个 GameObject 的质量高于另一个，较轻的 GameObject
    将以更大的力量弹开，就像现实生活中一样。这两个组件负责 Unity 中所有物理交互和模拟运动。
- en: 'There are some caveats to using these components, which are best understood
    in terms of the types of movement Unity allows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些组件有一些注意事项，最好在 Unity 允许的运动类型方面理解：
- en: '*Kinematic* movement happens when a Rigidbody component is attached to a GameObject,
    but it doesn''t register to the physics system in the scene. In other words, kinematic
    objects have physics interactions but don''t react to them, like a wall in real
    life. This is only used in certain cases and can be enabled by checking the **Is
    Kinematic** property of a Rigidbody component. Since we want our capsule to interact
    with the physics system, we won''t be using this kind of motion.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运动学*运动发生在 Rigidbody 组件附加到 GameObject 上时，但它不会在场景的物理系统中注册。换句话说，运动学对象具有物理交互，但不会对其做出反应，就像现实生活中的墙壁一样。这仅在特定情况下使用，可以通过检查
    Rigidbody 组件的 **Is Kinematic** 属性来启用。由于我们想让我们的胶囊与物理系统交互，我们不会使用这种运动方式。'
- en: '*Non-kinematic* movement is when a Rigidbody component is moved or rotated
    by applying force rather than manually changing a GameObject''s Transform properties.
    Our goal for this section is to update the `PlayerBehavior` script to implement
    this type of motion.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非动力学* 移动是指通过施加力而不是手动更改 GameObject 的 Transform 属性来移动或旋转 Rigidbody 组件。本节的目标是更新
    `PlayerBehavior` 脚本来实现这种类型的运动。'
- en: The setup we have now, that is, manipulating the capsule's Transform component
    while using a Rigidbody component to interact with the physics system, was meant
    to get you thinking about movement and rotation in a 3D space. However, it's not
    meant for production and Unity suggests avoiding a mix of kinematic and non-kinematic
    movement in your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的设置，即在使用 Rigidbody 组件与物理系统交互的同时操作胶囊的 Transform 组件，旨在让你思考在 3D 空间中的移动和旋转。然而，这并不是为了生产使用，Unity
    建议在代码中避免混合使用动力学和非动力学移动。
- en: Your next task is to use applied force to convert the current movement system
    into a more realistic locomotion experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是使用施加的力将当前的移动系统转换为更真实的移动体验。
- en: Rigidbody components in motion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在运动的 Rigidbody 组件
- en: 'Since our player has a Rigidbody component attached, we should let the physics
    engine control our movement instead of manually translating and rotating the Transform.
    There are two options when it comes to applying force:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的玩家附加了 Rigidbody 组件，我们应该让物理引擎控制我们的移动，而不是手动平移和旋转 Transform。在施加力方面有两个选择：
- en: You can do it directly by using Rigidbody class methods such as `AddForce` and
    `AddTorque` to move and rotate an object, respectively. This approach has its
    drawbacks and often requires additional code to compensate for unexpected physics
    behavior such as unwanted torque or applied force during collisions.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以直接使用 Rigidbody 类方法，如 `AddForce` 和 `AddTorque` 来移动和旋转对象，分别。这种方法有其缺点，通常需要额外的代码来补偿意外的物理行为，如碰撞期间的不想要的扭矩或施加的力。
- en: Alternatively, you can use other Rigidbody class methods such as `MovePosition`
    and `MoveRotation`, which still use applied force.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以使用其他 Rigidbody 类方法，如 `MovePosition` 和 `MoveRotation`，这些方法仍然使用施加的力。
- en: 'We''ll take the second route in the next section so that Unity takes care of
    the applied physics for us, but if you''re curious about manually applying force
    and torque to your GameObjects, then start here: [https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将选择第二条路线，让 Unity 为我们处理施加的物理，但如果你对手动施加力和扭矩到你的 GameObject 感兴趣，那么从这里开始：[https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html)。
- en: Either of these will give the player a more lifelike feel and allow us to add
    in jumping and dashing mechanics in *Chapter 8*, *Scripting Game Mechanics*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会让玩家有更真实的感觉，并允许我们在 *第 8 章*，*脚本游戏机制* 中添加跳跃和冲刺机制。
- en: If you're curious about what happens when a moving object without a Rigidbody
    component interacts with pieces of the environment that have them equipped, remove
    the component from the Player and run around the arena. Congratulations—you're
    a ghost and can walk through walls! Don't forget to add the Rigidbody component
    back, though!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇当一个没有 Rigidbody 组件的移动物体与装备了该组件的环境部件交互时会发生什么，请从玩家身上移除组件并在竞技场周围跑动。恭喜你——你现在是一个幽灵，可以穿过墙壁！不过，别忘了将
    Rigidbody 组件重新添加回去！
- en: The player capsule already has a Rigidbody component attached, which means that
    you can access and modify its properties. First, though, you'll need to find and
    store the component, which is your next challenge.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家胶囊已经附加了 Rigidbody 组件，这意味着你可以访问和修改其属性。不过，首先你需要找到并存储该组件，这是你的下一个挑战。
- en: 'You''ll need to access and store the Rigidbody component on our player capsule
    before modifying it. Update `PlayerBehavior` with the following changes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改之前，你需要访问并存储我们玩家胶囊上的 Rigidbody 组件。使用以下更改更新 `PlayerBehavior`：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: Adds a private variable of type `Rigidbody` that will contain a reference to
    the capsule's Rigidbody component.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个私有变量，类型为 `Rigidbody`，它将包含对胶囊的 Rigidbody 组件的引用。
- en: The `Start` method fires when a script is initialized in a scene, which happens
    when you click on play, and should be used any time variables need to be set at
    the beginning of a class.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start` 方法在脚本在场景中初始化时触发，这发生在你点击播放时，并且应该在类开始时设置任何变量时使用。'
- en: 'The `GetComponent` method checks whether the component type we''re looking
    for, in this case, `Rigidbody`, exists on the GameObject the script is attached
    to and returns it:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetComponent`方法检查我们正在寻找的组件类型（在本例中为`Rigidbody`）是否存在于脚本附加的GameObject上，并返回它：'
- en: If the component isn't attached to the GameObject, the method will return `null`,
    but since we know there's one on the player, we won't worry about error checking
    right now.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组件未附加到GameObject，则该方法将返回`null`，但由于我们知道玩家上有一个，所以我们现在不必担心错误检查。
- en: 'Comments out the `Transform` and `Rotate` method calls in the `Update` function
    so that we won''t be running two different kinds of player controls:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`函数中注释掉`Transform`和`Rotate`方法调用，这样我们就不会运行两种不同的玩家控制：
- en: We want to keep our code that captures player input so that we can still use
    it later on.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望保留捕获玩家输入的代码，以便我们以后还能使用它。
- en: You've initialized and stored the Rigidbody component on the player capsule
    and commented out the obsolete `Transform` code to set the stage for physics-based
    movement. The character is now ready for the next challenge, which is to add force.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经初始化并存储了玩家胶囊上的刚体组件，并注释掉了过时的`Transform`代码，为基于物理的运动做好了准备。现在角色已经准备好迎接下一个挑战，即添加力。
- en: 'Use the following steps to move and rotate the Rigidbody component. Add in
    the following code to `PlayerBehavior` underneath the `Update` method, and then
    save the file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤来移动和旋转刚体组件。在`Update`方法下方添加以下代码到`PlayerBehavior`中，然后保存文件：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的分解：
- en: 'Any physics- or Rigidbody-related code always goes inside the `FixedUpdate`
    method, rather than `Update` or the other `MonoBehavior` methods:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何与物理或刚体相关的代码都应该放在`FixedUpdate`方法内部，而不是`Update`或其他`MonoBehavior`方法中：
- en: '`FixedUpdate` is frame rate independent and is used for all physics code.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate`与帧率无关，用于所有物理代码。'
- en: 'Creates a new `Vector3` variable to store our left and right rotation:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Vector3`变量来存储我们的左右旋转：
- en: '`Vector3.up * _hInput` is the same rotation vector we used with the `Rotate`
    method in the previous example.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.up * _hInput`是我们之前在示例中使用`Rotate`方法的相同旋转向量。'
- en: '`Quaternion.Euler` takes a `Vector3` parameter and returns a rotation value
    in Euler angles:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Quaternion.Euler`接受一个`Vector3`参数并返回一个欧拉角度的旋转值：'
- en: We need a `Quaternion` value instead of a `Vector3` parameter to use the `MoveRotation`
    method. This is just a conversion to the rotation type that Unity prefers.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要`Quaternion`值而不是`Vector3`参数来使用`MoveRotation`方法。这只是将旋转类型转换为Unity更喜欢的类型。
- en: We multiply by `Time.fixedDeltaTime` for the same reason we used `Time.deltaTime`
    in `Update`.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们乘以`Time.fixedDeltaTime`的原因与我们在`Update`中使用`Time.deltaTime`的原因相同。
- en: 'Calls `MovePosition` on our `_rb` component, which takes in a `Vector3` parameter
    and applies force accordingly:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`_rb`组件上调用`MovePosition`，它接受一个`Vector3`参数并相应地应用力：
- en: 'The vector that''s used can be broken down as follows: the capsule''s `Transform`
    position in the forward direction, multiplied by the vertical inputs and `Time.fixedDeltaTime`.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的向量可以分解如下：胶囊的`Transform`位置在前进方向上，乘以垂直输入和`Time.fixedDeltaTime`。
- en: The Rigidbody component takes care of applying movement force to satisfy our
    vector parameter.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体组件负责应用运动力以满足我们的向量参数。
- en: 'Calls the `MoveRotation` method on the `_rb` component, which also takes in
    a `Vector3` parameter and applies the corresponding forces under the hood:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_rb`组件上调用`MoveRotation`方法，它也接受一个`Vector3`参数并在幕后应用相应的力：
- en: '`angleRot` already has the horizontal inputs from the keyboard, so all we need
    to do is multiply the current Rigidbody rotation by `angleRot` to get the same
    left and right rotation.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angleRot`已经包含了来自键盘的水平输入，所以我们只需要将当前的刚体旋转乘以`angleRot`以获得相同的左右旋转。'
- en: Be aware that `MovePosition` and `MoveRotation` work differently for non-kinematic
    game objects. You can find more information in the Rigidbody scripting reference
    at [https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`MovePosition`和`MoveRotation`对于非刚体游戏对象的工作方式不同。您可以在Rigidbody脚本参考中找到更多信息，链接为[https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html)。
- en: If you click on play now, you'll be able to move forward and backward in the
    direction you're looking, as well as rotate around the *y* axis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在点击播放，您将能够朝您所看的方向前后移动，以及围绕*y*轴旋转。
- en: Applied force produces stronger effects than translating and rotating a Transform
    component, so you may need to fine-tune the `MoveSpeed` and `RotateSpeed` variables
    in the **Inspector** pane. You've now recreated the same type of movement scheme
    as before, just with more realistic physics.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 应用力产生的效果比平移和旋转变换组件更强，因此你可能需要在**检查器**面板中微调`MoveSpeed`和`RotateSpeed`变量。你现在已经重新创建了之前相同类型的运动方案，只是加入了更真实的物理效果。
- en: If you run up a ramp or drop off the central platform, you might see the player
    launch into the air, or slowly drop to the ground. Even though the Rigidbody component
    is set to use gravity, it's fairly weak. We'll tackle applying our gravity to
    the player in the next chapter when we implement the jump mechanic. For now, your
    job is to get comfortable with how Collider components handle collisions in Unity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跑上斜坡或从中央平台掉落，你可能会看到玩家被弹射到空中，或者缓慢地落到地上。尽管刚体组件被设置为使用重力，但它相当弱。我们将在下一章中处理将我们的重力应用到玩家上，当时我们将实现跳跃机制。现在，你的任务是熟悉碰撞组件在Unity中处理碰撞的方式。
- en: Colliders and collisions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞和碰撞
- en: Collider components not only allow GameObjects to be recognized by Unity's physics
    system, but they also make interactions and collisions possible. Think of colliders
    as invisible force fields that surround GameObjects; they can be passed through
    or bumped into depending on their settings, and they come with a host of methods
    that execute during different interactions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞组件不仅允许游戏对象被Unity的物理系统识别，而且它们还使得交互和碰撞成为可能。将碰撞组件想象成围绕游戏对象的不可见力场；根据它们的设置，它们可以被穿过或碰撞，并且它们包含一系列在交互过程中执行的方法。
- en: Unity's physics system works differently for 2D and 3D games, so we will only
    be covering the 3D topics in this book. If you're interested in making 2D games,
    refer to the `Rigidbody2D` component at [https://docs.unity3d.com/Manual/class-Rigidbody2D.html](https://docs.unity3d.com/Manual/class-Rigidbody2D.html)
    and the list of available 2D colliders at [https://docs.unity3d.com/Manual/Collider2D.html](https://docs.unity3d.com/Manual/Collider2D.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理系统对于2D和3D游戏的工作方式不同，因此本书中我们只会涵盖3D主题。如果你对制作2D游戏感兴趣，请参考[https://docs.unity3d.com/Manual/class-Rigidbody2D.html](https://docs.unity3d.com/Manual/class-Rigidbody2D.html)中的`Rigidbody2D`组件和可用的2D碰撞组件列表[https://docs.unity3d.com/Manual/Collider2D.html](https://docs.unity3d.com/Manual/Collider2D.html)。
- en: 'Take a look at the following screenshot of the **Capsule** in the **Health_Pickup**
    object. If you want to see the **Capsule Collider** a little better, increase
    the **Radius** property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下**Health_Pickup**对象中**胶囊**的以下截图。如果你想更好地看到**胶囊碰撞组件**，请增加**半径**属性：
- en: '![](img/B17573_07_08.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_07_08.png)'
- en: 'Figure 7.8: Capsule collider component attached to pickup item'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：附加到拾取物品的胶囊碰撞组件
- en: The green shape around the object is the **Capsule Collider**, which can be
    moved and scaled using the **Center**, **Radius**, and **Height** properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 物体周围的绿色形状是**胶囊碰撞组件**，可以使用**中心**、**半径**和**高度**属性来移动和缩放。
- en: When a primitive is created, the Collider matches the primitive's shape by default;
    since we created a capsule primitive, it comes with a Capsule Collider.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个原形时，碰撞组件默认匹配原形的形状；由于我们创建了一个胶囊原形，因此它自带胶囊碰撞组件。
- en: Colliders also come in **Box**, **Sphere**, and **Mesh** shapes and can be manually
    added from the **Component** | **Physics** menu or from the **Add Component**
    button in the **Inspector**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞组件还有**盒形**、**球形**和**网格**形状，可以从**组件** | **物理**菜单或从**检查器**中的**添加组件**按钮手动添加。
- en: When a Collider comes into contact with other components, it sends out what's
    called a message, or broadcast. Any script that adds one or more of those methods
    will receive a notification when the Collider sends out a message. This is called
    an *event*, which is a topic that we'll cover in more detail in *Chapter 14*,
    *The Journey Continues*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当碰撞组件接触到其他组件时，它会发出所谓的消息或广播。任何添加了一个或多个这些方法的脚本都会在碰撞组件发出消息时收到通知。这被称为**事件**，这是我们将在第14章“旅程继续”中更详细讨论的主题。
- en: For example, when two GameObjects with colliders come into contact, both objects
    register an `OnCollisionEnter` event, complete with a reference to the object
    they ran into. Think of an event like a message being sent out – if you choose
    to listen for it you'll get notified when a collision happens in this case. This
    information can be used to track a variety of interactive events, but the simplest
    one is picking up an item. For cases where you want objects to be able to pass
    through others, you can use collision triggers, which we'll talk about in the
    next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当两个具有碰撞器的 GameObject 相互接触时，两个对象都会注册一个 `OnCollisionEnter` 事件，并附带它们所碰撞的对象的引用。将事件想象成发送出去的消息——如果你选择监听它，当在这个情况下发生碰撞时，你会收到通知。这些信息可以用来跟踪各种交互事件，但最简单的一个是拾取物品。对于想要对象能够穿过其他对象的情况，你可以使用碰撞触发器，我们将在下一节中讨论。
- en: A complete list of Collider notifications can be found here underneath the **Messages**
    header at [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Collider 通知的完整列表可以在 [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html)
    的 **Messages** 标题下找到。
- en: Collision and trigger events are only sent out when the colliding objects belong
    to a specific combination of Collider, Trigger, and RigidBody components and kinematic
    or non-kinematic motion. You can find details under the **Collision action matrix**
    section at [https://docs.unity3d.com/Manual/CollidersOverview.html](https://docs.unity3d.com/Manual/CollidersOverview.html).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当碰撞对象属于特定的 Collider、Trigger 和 RigidBody 组件以及运动学或非运动学运动的组合时，才会发出碰撞和触发事件。你可以在
    [https://docs.unity3d.com/Manual/CollidersOverview.html](https://docs.unity3d.com/Manual/CollidersOverview.html)
    的 **Collision action matrix** 部分找到详细信息。
- en: The health item you previously created is a perfect place to test out how collisions
    work. You'll tackle that in the next challenge.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前创建的健康物品是测试碰撞工作原理的完美场所。你将在下一个挑战中处理这个问题。
- en: Picking up an item
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拾取物品
- en: 'To update the `Health_Pickup` object using collision logic, you need to do
    the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用碰撞逻辑更新 `Health_Pickup` 对象，你需要执行以下操作：
- en: 'Create a new C# script in the `Scripts` folder, name it `ItemBehavior`, and
    then drag it onto the `Health_Pickup` object in the **Hierarchy** panel:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的 C# 脚本，命名为 `ItemBehavior`，然后将它拖放到 **Hierarchy** 面板中的 `Health_Pickup`
    对象上：
- en: Any script that uses collision detection *must* be attached to a GameObject
    with a Collider component, even if it's the child of a Prefab.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何使用碰撞检测的脚本 *必须* 附带一个具有 Collider 组件的 GameObject，即使它是预制体的子对象。
- en: Select `Health_Pickup` in the **Hierarchy panel**, click the three vertical
    dots icon in the **Inspector** to the right of the **Item Behavior (Script)**
    component, and choose **Added Component** | **Apply to Prefab 'Health_Pickup'**:![](img/B17573_07_09.png)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy 面板** 中选择 `Health_Pickup`，点击 **Inspector** 中 **Item Behavior (Script)**
    组件右侧的三个垂直点图标，然后选择 **Added Component** | **Apply to Prefab 'Health_Pickup'**:![](img/B17573_07_09.png)
- en: 'Figure 7.9: Applying Prefab changes to pickup item'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.9：应用预制体更改以拾取物品
- en: 'Replace the default code in `ItemBehavior` with the following, and then save
    it:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ItemBehavior` 中的默认代码替换为以下内容，然后保存：
- en: '[PRE6]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Click on play and move the player over the capsule to pick it up!
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放，并将玩家移动到胶囊上以拾取它！
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的分解：
- en: 'When another object runs into the `Item` Prefab, Unity automatically calls
    the `OnCollisionEnter` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当另一个对象撞到 `Item` 预制体时，Unity 会自动调用 `OnCollisionEnter` 方法：
- en: '`OnCollisionEnter` comes with a parameter that stores a reference to the Collider
    that ran into it.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter` 方法附带一个参数，用于存储与之发生碰撞的 Collider 引用。'
- en: Notice that the collision is of type `Collision`, not `Collider`.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，这里的碰撞类型是 `Collision`，而不是 `Collider`。
- en: 'The `Collision` class has a property, called `gameObject`, which holds a reference
    to the colliding GameObject''s Collider:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Collision` 类有一个名为 `gameObject` 的属性，它包含对碰撞 GameObject 的 Collider 的引用：'
- en: We can use this property to get the GameObject's name and use an `if` statement
    to check whether the colliding object is the player.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用这个属性来获取 GameObject 的名称，并使用 `if` 语句检查碰撞对象是否是玩家。
- en: If the colliding object is the player, we'll call the `Destroy()` method, which
    takes in a GameObject parameter and removes the object from the scene.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果碰撞对象是玩家，我们将调用 `Destroy()` 方法，该方法接受一个 GameObject 参数，并将对象从场景中移除。
- en: It then prints out a simple log to the console that we have collected an item:![](img/B17573_07_10.png)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它会在控制台打印出一个简单的日志，表示我们已经收集了一个物品:![](img/B17573_07_10.png)
- en: 'Figure 7.10: Example of game objects being deleted from a scene'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.10：场景中游戏对象被删除的示例
- en: We've set up `ItemBehavior` to essentially listen for any collisions with the
    `Health_Pickup` object Prefab. Whenever a collision occurs, `ItemBehavior` uses
    `OnCollisionEnter()` and checks whether the colliding object is the player and,
    if so, destroys (or collects) the item.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了`ItemBehavior`来监听与`Health_Pickup`对象Prefab的任何碰撞。每当发生碰撞时，`ItemBehavior`使用`OnCollisionEnter()`并检查碰撞对象是否是玩家，如果是，则销毁（或收集）物品。
- en: If you're feeling lost, think of the collision code we wrote as a receiver for
    notifications from the `Health_Pickup`; any time it's hit, the code fires.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到困惑，想想我们编写的碰撞代码作为从`Health_Pickup`接收通知的接收器；每次被击中时，代码都会触发。
- en: It's also important to understand that we could have created a similar script
    with an `OnCollisionEnter()` method, attached it to the player, and then checked
    whether the colliding object was a `Health_Pickup` Prefab. Collision logic depends
    on the perspective of the object being collided with.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，我们也可以创建一个具有`OnCollisionEnter()`方法的类似脚本，将其附加到玩家上，然后检查碰撞对象是否是`Health_Pickup`
    Prefab。碰撞逻辑取决于被碰撞对象的视角。
- en: Now the question is, how would you set up a collision without stopping the colliding
    objects from moving through each other? We'll tackle that in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，你将如何设置碰撞，而不会阻止碰撞对象相互穿过？我们将在下一节中解决这个问题。
- en: Using Collider triggers
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用碰撞触发器
- en: By default, Colliders are set with the `isTrigger` property unchecked, meaning
    that the physics system treats them as solid objects and will raise a Collision
    event on impact. However, in some cases, you'll want to be able to pass through
    a Collider component without it stopping your GameObject. This is where triggers
    come in. With `isTrigger` checked, a GameObject can pass through it, but the Collider
    will send out the `OnTriggerEnter`, `OnTriggerExit`, and `OnTriggerStay` notifications
    instead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，碰撞体使用`isTrigger`属性未勾选，这意味着物理系统将它们视为固体对象，并在碰撞时引发碰撞事件。然而，在某些情况下，你可能希望能够在不停止你的GameObject的情况下穿过碰撞体组件。这就是触发器的作用所在。勾选`isTrigger`后，GameObject可以穿过它，但碰撞体会发送出`OnTriggerEnter`、`OnTriggerExit`和`OnTriggerStay`通知。
- en: Triggers are most useful when you need to detect when a GameObject enters a
    certain area or passes a certain point. We'll use this to set up the areas around
    our enemies; if the player walks into the trigger zone, the enemies will be alerted,
    and, later on, attack the player. For now, you're going to focus just on the enemy
    logic in the following challenge.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器在需要检测GameObject进入某个区域或通过某个点时最有用。我们将使用它来设置敌人周围的区域；如果玩家进入触发区域，敌人将会警觉，并在稍后攻击玩家。现在，你将专注于以下挑战中的敌人逻辑。
- en: Creating an enemy
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个敌人
- en: 'Use the following steps to create an enemy:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建一个敌人：
- en: Create a new primitive using **+** | **3D Object** | **Capsule** in the **Hierarchy**
    panel and name it `Enemy`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中使用**+** | **3D对象** | **胶囊**创建一个新的原形，并将其命名为`Enemy`。
- en: 'Inside the `Materials` folder, use **+** | **Material**, name it `Enemy_Mat`,
    and set its **Albedo** property to a bright red:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质**文件夹中，使用**+** | **材质**，将其命名为`Enemy_Mat`，并将其**Albedo**属性设置为明亮的红色：
- en: Drag and drop `Enemy_Mat` into the `Enemy` GameObject.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Enemy_Mat`拖放到`Enemy`GameObject中。
- en: 'With `Enemy` selected, click on **Add Component**, search for **Sphere Collider**,
    and hit `Enter` to add it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Enemy`后，点击**添加组件**，搜索**球体碰撞体**，然后按**Enter**键添加：
- en: Check the **isTrigger** property box and change the **Radius** to `8`:![](img/B17573_07_11.png)
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勾选**isTrigger**属性框，并将**半径**更改为`8`：![img/B17573_07_11.png]
- en: 'Figure 7.11: Sphere collider component attached to an enemy object'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.11：附加到敌人对象上的球体碰撞组件
- en: Our new **Enemy** primitive is now surrounded by an 8-unit trigger radius shaped
    like a sphere. Any time another object enters, stays inside, or exits that area,
    Unity will send out notifications that we can capture, just like we did with collisions.
    Your next challenge will be to capture that notification and act on it in code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的**Enemy**原形现在被一个8个单位的触发半径包围，形状像一个球体。每当另一个对象进入、停留在该区域内或退出该区域时，Unity都会发送出我们可以捕获的通知，就像我们处理碰撞一样。你的下一个挑战将是捕获那个通知并在代码中对其做出反应。
- en: 'To capture trigger events, you''ll need to create a new script by following
    these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获触发事件，你需要按照以下步骤创建一个新的脚本：
- en: Create a new C# script in the `Scripts` folder, name it `EnemyBehavior`, and
    then drag it into **Enemy**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`EnemyBehavior`，然后将它拖放到**Enemy**上。
- en: 'Add the following code and save the file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存文件：
- en: '[PRE7]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Click play and walk over to the Enemy to set off the first notification, then
    walk away from the Enemy to set off the second notification.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并走到敌人那里触发第一个通知，然后走开触发第二个通知。
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: '`OnTriggerEnter()` is fired whenever an object enters the Enemy Sphere Collider
    radius:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter()`在对象进入敌人Sphere Collider半径时触发：'
- en: Similar to `OnCollisionEnter()`, `OnTriggerEnter()` stores a reference to the
    trespassing object's Collider component.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`OnCollisionEnter()`类似，`OnTriggerEnter()`存储了对违规对象Collider组件的引用。
- en: Note that `other` is of type `Collider`, not `Collision`.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，`other`是`Collider`类型，而不是`Collision`。
- en: We can use `other` to access the name of the colliding GameObject, and check
    whether it's the `Player` with an `if` statement. If it is, the console prints
    out a log that the `Player` is in the danger zone.![](img/B17573_07_12.png)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`other`来访问碰撞GameObject的名称，并使用`if`语句检查它是否是`Player`。如果是，控制台会打印出日志，说明`Player`处于危险区域。![图片](img/B17573_07_12.png)
- en: 'Figure 7.12: Collision detection between player and enemy objects'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12：玩家和敌人对象之间的碰撞检测
- en: '`OnTriggerExit()` is fired when an object leaves the Enemy Sphere Collider
    radius:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对象离开敌人Sphere Collider半径时，会触发`OnTriggerExit()`。
- en: 'This method also has a reference to the colliding object''s Collider component:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法还有一个对碰撞对象的Collider组件的引用：
- en: 'We check the object leaving the Sphere Collider radius by name using another
    `if` statement:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用另一个`if`语句通过名称检查离开Sphere Collider半径的对象：
- en: If it's `Player`, we print out another log to the console saying that they're
    safe:![](img/B17573_07_13.png)
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是`Player`，我们在控制台打印出另一条日志，说明他们安全了！![图片](img/B17573_07_13.png)
- en: 'Figure 7.13: Example of collision triggers'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.13：碰撞触发器的示例
- en: The Sphere Collider on our Enemy sends out notifications when its area is invaded,
    and the `EnemyBehavior` script captures two of those events. Whenever the player
    enters or exits the collision radius, a debug log appears in the console to let
    us know that the code is working. We'll continue to build on this in *Chapter
    9*, *Basic AI and Enemy Behavior*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敌人的Sphere Collider在区域被侵犯时发送通知，`EnemyBehavior`脚本捕获了其中两个事件。每当玩家进入或退出碰撞半径时，控制台都会出现一个调试日志，让我们知道代码正在工作。我们将在*第9章*，*基本AI和敌人行为*中继续构建这个内容。
- en: Unity makes use of something called the Component design pattern. Without going
    into too much detail, that's a fancy way of saying objects (and, by extension,
    their classes) should be responsible for their behavior as opposed to having all
    the code in one huge file. This is why we put separate collision scripts on the
    pickup item and enemy instead of having a single class handle everything. We'll
    discuss this further in *Chapter 14*, *The Journey Continues*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用了一种称为组件设计模式的东西。不深入细节，这是一个复杂的方式来说明对象（以及通过扩展，它们的类）应该对其行为负责，而不是将所有代码放在一个巨大的文件中。这就是为什么我们在拾取物品和敌人上放置单独的碰撞脚本，而不是有一个单独的类来处理所有事情。我们将在*第14章*，*旅程继续*中进一步讨论这一点。
- en: Since this book is all about instilling as many good programming habits as possible,
    your last task for the chapter is to make sure all your core objects are converted
    into Prefabs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书的目的是尽可能灌输尽可能多的良好编程习惯，所以本章的最后一个任务是确保所有核心对象都转换为预制体。
- en: Hero's trial – all the Prefabs!
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的考验——所有预制体！
- en: To get the project ready for the next chapter, go ahead and drag the `Player`
    and `Enemy` objects into the **Prefabs** folder. Remember, from now on you always
    need to right-click on the Prefab in the **Hierarchy** panel and choose **Added
    Component** | **Apply to Prefab** to solidify any changes you make to these GameObjects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为下一章做好准备，请将`Player`和`Enemy`对象拖到**预制体**文件夹中。记住，从现在开始，你总是需要在**层次结构**面板中右键单击预制体，然后选择**添加组件**|**应用到预制体**来巩固对这些GameObject所做的任何更改。
- en: With that done, continue to the *Physics roundup* section and make sure that
    you've internalized all the major topics we've covered before moving on.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，继续到*物理总结*部分，确保你理解了我们之前覆盖的所有主要主题，然后再继续。
- en: Physics roundup
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理总结
- en: 'Before we wrap up the chapter, here are a few high-level concepts to cement
    what we''ve learned so far:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，这里有一些高级概念来巩固我们迄今为止学到的内容：
- en: Rigidbody components add simulated real-world physics to GameObjects they are
    attached to.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rigidbody组件为它们附加的GameObject添加了模拟的真实世界物理。
- en: 'Collider components interact with each other, as well as objects, using Rigidbody
    components:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体组件通过Rigidbody组件相互交互，以及与对象交互：
- en: If a Collider component is not a trigger, it acts as a solid object.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个碰撞体组件不是触发器，则它充当一个固体对象。
- en: If a Collider component is a trigger, it can be walked through.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个碰撞体组件是触发器，则可以穿过它。
- en: An object is *kinematic* if it uses a Rigidbody component and has **Is Kinematic**
    checked, telling the physics system to ignore it.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个对象使用Rigidbody组件并且勾选了**“是运动学”**，则该对象是*运动学*的，告诉物理系统忽略它。
- en: An object is *non-kinematic* if it uses a Rigidbody component and applied force
    or torque to power its movement and rotation.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个对象使用Rigidbody组件并施加力或扭矩来驱动其运动和旋转，则该对象是*非运动学*的。
- en: Colliders send out notifications based on their interactions. These notifications
    depend on whether the Collider component is set to be triggered or not. Notifications
    can be received from either colliding party, and they come with reference variables
    that hold an object's collision information.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体根据其交互发送通知。这些通知取决于碰撞体组件是否设置为触发。通知可以从任一碰撞方接收，并且它们带有引用变量，这些变量包含对象的碰撞信息。
- en: Remember, a topic as broad and complex as the Unity physics system isn't learned
    in a day. Use what you've learned here as a springboard to launch yourself into
    more intricate topics!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，像Unity物理系统这样广泛且复杂的主题不是一天就能学会的。利用您在这里学到的知识作为跳板，将自己投入到更复杂的话题中！
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This wraps up your first experience of creating independent gameplay behaviors
    and tying them all together into a cohesive, albeit simple, game prototype. You've
    used vectors and basic vector math to determine positions and angles in a 3D space,
    and you're familiar with player input and the two main methods of moving and rotating
    GameObjects. You've even gone down into the bowels of the Unity physics system
    to get comfortable with Rigidbody physics, collisions, triggers, and event notifications.
    All in all, *Hero Born* is off to a great start.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着您创建独立游戏行为并将其整合成一个连贯、尽管简单，的游戏原型的第一次体验。您已经使用了向量和基本的向量数学来确定3D空间中的位置和角度，并且您熟悉玩家输入以及移动和旋转GameObject的两种主要方法。您甚至深入Unity物理系统，熟悉Rigidbody物理、碰撞、触发和事件通知。总的来说，*英雄降生*已经取得了良好的开端。
- en: In the next chapter, we'll start tackling more game mechanics, including jumping,
    dashing, shooting projectiles, and interacting with parts of the environment.
    This will give you more hands-on experience of using force with Rigidbody components,
    gathering player input, and executing logic based on the desired scenario.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始处理更多的游戏机制，包括跳跃、冲刺、发射弹丸以及与环境部分交互。这将为您使用Rigidbody组件的力、收集玩家输入以及根据所需场景执行逻辑提供更多实际经验。
- en: Pop quiz – player controls and physics
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答 - 玩家控制和物理
- en: What data type would you use to store 3D movement and rotation information?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用什么数据类型来存储3D运动和旋转信息？
- en: What built-in Unity component allows you to track and modify player controls?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个内置Unity组件允许您跟踪和修改玩家控制？
- en: Which component adds real-world physics to a GameObject?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个组件为GameObject添加真实世界的物理效果？
- en: What method does Unity suggest using to execute physics-related code on GameObjects?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity建议使用哪种方法在GameObject上执行与物理相关的代码？
- en: JOIN us on Discord!
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和哈里森·费罗内一起阅读这本书。提问，为其他读者提供解决方案，通过*问我任何问题*会议与作者聊天等等。
- en: Join Now!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
