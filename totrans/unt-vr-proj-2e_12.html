<html><head></head><body>
        

                            
                    <h1 class="header-title">Social VR Metaverse</h1>
                
            
            
                
<p class="calibre3"><em class="calibre14">That's me, Linojon, the guy with a baseball cap in front, to the left!</em> Momentously, the following photo was captured during the eve of the metaverse on December 21, 2014 at a live VRChat session. I had built a seasonally-themed world named GingerLand and invited my chatroom friends to visit during one of the weekly meetups. Then, someone suggested, "Hey, let's take a group picture!" So, we all assembled on the front porch of my wintry cabin and said "Cheese!" The rest is history:</p>
<div><img class="image-border17" src="img/5a4f0680-a02b-4481-8843-d4de41941b49.png"/></div>
<p class="calibre3">For many people, the visceral experience of socially interacting live with other people in VR is at least as dramatic as the difference between using Facebook versus browsing a static website, or sharing Snapchats versus viewing an online photo album. It's very personal and alive. If you've tried it out yourself, you know exactly what I mean. We're now going to look at how social VR experiences can be implemented using Unity. There are many approaches, from building it from scratch to plugging into an existing social VR platform. In this chapter, we will discuss the following topics:</p>
<ul class="calibre11">
<li class="calibre12">An introduction to how multiplayer networking works</li>
<li class="calibre12">Implementing a multiplayer scene that runs in VR using the Unity Networking engine</li>
<li class="calibre12">Using Oculus personalized avatars</li>
<li class="calibre12">Building and sharing a custom VRChat room</li>
</ul>
<p>Note that the projects in this chapter are separate and not directly required by the other chapters in this book. If you decide to skip any of it or not save your work, that's OK.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiplayer networking</h1>
                
            
            
                
<p class="calibre3">Before we begin any implementation, let's take a look at what multiplayer networking is all about and define some terms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Networking services</h1>
                
            
            
                
<p class="calibre3">Consider a situation where you are running a VR application that is connected over the internet to other players running the same application on their own VR rigs at the same time. When you move your first person view within the game, shoot things, or otherwise interact with the virtual environment, you expect the other players to see that, too. Their version of the game stays in sync with yours and vice versa. How does this work?</p>
<p class="calibre3">One instance of the running game acts as a host or server. Other players are concurrently connected to the same. When you move, your character's new position is shared with each of the other connections, which then updates your avatar's position in their own views. Similarly, when your game receives a changed position of another character, it is updated in your view. The faster, the better. That is, the shorter the delay (latency) between the <em class="calibre14">send</em> and <em class="calibre14">receive</em> messages and the corresponding screen updates, the more live, or real-time, the interaction feels.</p>
<p class="calibre3">Multiplayer services should help you manage the sharing of the game's state between all active clients, the spawning of new players and objects, security considerations, as well as the management of low-level network connections, protocols, and quality of service (such as data rate and performance).</p>
<p class="calibre3">Networking is built as a series of API layers, where the low-level functions deal with details of the data transport and would be agnostic to the content of the data. Middle and higher layers provide increasingly aggregated features that also may be more directly helpful for the networking application. In our case, this is multiplayer gaming and social VR. Ideally, the high-level layer will provide all you need to implement multiplayer features into your games with minimal custom scripting, while offering access to other layers through a clean API in case you have special requirements.</p>
<p class="calibre3">There are a number of multiplayer services available, including Photon from Exit Games and platforms from Google, Facebook/Oculus, Apple, Microsoft, Amazon, and more.</p>
<ul class="calibre11">
<li class="calibre12">The popular Photon Cloud service can be easily added using their free <strong class="calibre1">Photon Unity Networking</strong> (<strong class="calibre1">PUN</strong>) package from the Unity Asset Store (for more information, visit <a href="https://www.assetstore.unity3d.com/#/content/1786" class="calibre10">https://www.assetstore.unity3d.com/#/content/1786</a>). If you are interested in trying Photon with Unity, take a look their documentation and tutorial pages (<a href="https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links" class="calibre10">https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links</a>). </li>
<li class="calibre12">Unity has its own built-in networking system, <strong class="calibre1">Unity Networking</strong> (<strong class="calibre1">UNet</strong>), which reduces the need for custom scripting and provides a feature-rich set of components and API that tightly integrate with Unity. There is a whole tutorial series on the Unity website (<a href="https://unity3d.com/learn/tutorials/s/multiplayer-networking" class="calibre10">https://unity3d.com/learn/tutorials/s/multiplayer-networking</a>), and it's what we will use in this chapter's project.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The network architecture</h1>
                
            
            
                
<p class="calibre3">A key to networking is the client-server system architecture. We see this all around us in today's world; your web browser is a client and websites are hosted on a server. Your favorite music listening app is a client and its streaming service is a server. Similarly, each instance of your game, when connected to a network, is a client. It talks to a server, which communicates the status and control information between all the other game clients.</p>
<p class="calibre3">I say <em class="calibre14">server</em>, but it doesn't necessarily need to be a separate physical computer somewhere. It could be, but it's probably not. It's best to think of a client and server as <em class="calibre14">processes</em>: instances of a program or an application running somewhere. A <strong class="calibre5">cloud server</strong> is a virtual process that is accessible via the internet as a service.</p>
<p class="calibre3">A single app can sometimes act as both a client and a server at the same time. This latter case, where the server and client are one, is said to be running as a host. With Unity networking, games can be run as a client, a server, and/or as a host.</p>
<p class="calibre3">Even so, a public <strong class="calibre5">IP</strong> (<strong class="calibre5">Internet Protocol</strong>) address is needed for game instances to talk to one another. A lightweight relay server can provide this service with minimal resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Local versus server</h1>
                
            
            
                
<p class="calibre3">In Unity, you can use scripting to create, or instantiate, new objects during gameplay. In a multiplayer situation, these objects need to be activated, or spawned, locally as well as on the network so that all the clients will know about it. A spawning system manages objects across all the clients.</p>
<p>It is important to make a distinction between objects that are local player o<em class="calibre2">bjects</em> versus network ones. Local player objects are controlled by actions in your playing version of the game, on your client, rather than remotely.</p>
<p class="calibre3">For example, in a first-person experience, you are the camera whereas other players see you as your avatar, and you would want security precautions; for example, to prevent others from hacking a game and changing your avatar.</p>
<p class="calibre3">Local player objects have local authority, that is, the player object is responsible for controlling itself, such as its own movement. Otherwise, when the creation, movement, and destruction of objects are not controlled by any player, the authority should reside on a server. Local authority is needed when individual players are driving gameplay.</p>
<p class="calibre3">On the other hand, server authority is needed when game logic and random events are driving the gameplay. For example, when a game creates enemies at random locations, you'd want all the clients to get the same random locations. When a new player joins an ongoing game, the server helps create and set up objects that are active in the current gameplay. You wouldn't want an object to show up in its default position and then jump to a different current position as it's syncing with the other clients.</p>
<p class="calibre3">The following image from Unity documentation shows ways in which actions are performed across the network. The server makes <strong class="calibre5">remote procedure calls</strong> (<strong class="calibre5">RPC</strong>) to the client to spawn or update objects. The client sends <strong class="calibre5">commands</strong> to the server and affects actions, which then are communicated to all the remote clients:</p>
<div><img src="img/d81af447-bdbf-426a-b0ba-6ace7f23b0f1.jpg" class="calibre87"/></div>
<p>Image source: <a href="https://docs.unity3d.com/Manual/class-NetworkBehaviour.html" class="calibre8">https://docs.unity3d.com/Manual/class-NetworkBehaviour.html</a></p>
<p class="calibre3">Real-time networking is an engineering discipline. Layered network architectures aim to simplify and shield you from brutally arcane details.</p>
<p>It all comes down to performance, security, and reliability. If you need to debug or optimize any of these in your multiplayer game, you may need to dig in your heels and gain a better understanding of what's going on under the hood. Refer to the next chapter, <a href="c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml" class="calibre20">Chapter 13</a>, <em class="calibre2">Optimizing for Performance and Comfort</em>, for suggestions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Unity networking system</h1>
                
            
            
                
<p class="calibre3">The <strong class="calibre5">Unity Networking</strong> engine (<strong class="calibre5">UNet</strong>) includes a robust set of high-level component scripts that make it easy to add multiplayer capabilities to your games. Some of the more important components include <em class="calibre14">Network Identity</em>, <em class="calibre14">Network Behavior</em>, <em class="calibre14">Network Transform</em>, and <em class="calibre14">Network Manager</em>.</p>
<div><br class="title-page-name"/>
A good overview of Unity Networking and exposition of the concepts is the Unity Networking Concepts document (<a href="http://docs.unity3d.com/Manual/UNetConcepts.html" class="calibre20">http://docs.unity3d.com/Manual/UNetConcepts.html</a>).</div>
<p class="calibre3">The <strong class="calibre5">Network Identity</strong> component is required on each game object prefab that may be spawned (created) on clients. Internally, it provides a universally unique asset ID, and other parameters, so that objects can be unambiguously identified and spawned across the network.</p>
<p class="calibre3">The <kbd class="calibre13">NetworkBehaviour</kbd> class is derived from <kbd class="calibre13">MonoBehaviour</kbd> and provides network functionality to scripts. We'll be using it in the examples in this chapter. Details are documented at <a href="http://docs.unity3d.com/Manual/class-NetworkBehaviour.html" class="calibre10">http://docs.unity3d.com/Manual/class-NetworkBehaviour.html</a>.</p>
<p class="calibre3">When you want to synchronize the movement and physics of objects, add a <strong class="calibre5">Network Transform</strong> component. It's like a shortcut for the more general <kbd class="calibre13">SyncVar</kbd> variable synchronization with additional intelligent interpolation for smoother movement between updates.</p>
<p class="calibre3">The <strong class="calibre5">Network Manager</strong> component is the glue that puts it all together. It handles the managing of connections, the spawning of objects across the network, and configuration.</p>
<p class="calibre3">When new player objects are spawned, you can specify a spawn position in the Network Manager component. Alternatively, you can add game objects to your scene and give them a <em class="calibre14">Network Start Position</em> component, which can be used by the spawning system.</p>
<p class="calibre3">Nonplayer objects that can get spawned can also be set in the Network Manager spawn list. Additionally, the Network Manager component handles scene changes and provides debugging information.</p>
<p class="calibre3">Related to the Network Manager component is the matchmaking functionality, using Unity Cloud Services, which can be configured to match up players to make them come together and start a game at the same time-a multiplayer lobby manager where players can set themselves as ready for the game to start, among other useful features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a simple scene</h1>
                
            
            
                
<p class="calibre3">Let's jump right in and make our own multiplayer demo project. For instructional purposes, we'll start out with a very simple scene with a standard first-person camera and get the networking implemented. Then, we'll synchronize multiple players' avatars over the network. And then we'll share a game object, a bouncy ball, between players to play a game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a scene environment</h1>
                
            
            
                
<p class="calibre3">To get set up, we will make a new scene with a ground plane and a cube and create a basic first-person character. Perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene by navigating to File | New Scene. Then, File | Save Scene As... and name the scene <kbd class="calibre13">MultiPlayer</kbd>.</li>
<li class="calibre12">Remove the <kbd class="calibre13">Main Camera</kbd> and insert a copy of your <kbd class="calibre13">MeMyselfEye</kbd> prefab. Reset its Transform so it's positioned at the origin.</li>
<li class="calibre12">Create a new plane by navigating to GameObject | 3D Object | Plane, rename it <a class="calibre10"><kbd class="calibre26">GroundPlane</kbd></a>, and reset its Transform using the Transform component's <em class="calibre2">gear</em> icon | Reset. Make the plane bigger by setting Scale to (<kbd class="calibre13">10, 1, 10</kbd>). </li>
<li class="calibre12">Make <kbd class="calibre13">GroundPlane</kbd> easier on the eyes. Drag your <kbd class="calibre13">Ground Material</kbd> onto the plane. If you need to create one, navigate to Assets | Create | Material, name it <kbd class="calibre13">Ground Material</kbd>, click on its Albedo color chip, and select a neutral color.</li>
<li class="calibre12">To provide some context and orientation, we'll just add a cube. Navigate to GameObject | 3D Object | Cube, reset its Transform, and set its Position to the side, such as (<kbd class="calibre13">-2, 0.75, 1</kbd>). </li>
<li class="calibre12">Give the cube some color. Drag your <kbd class="calibre13">Red Material</kbd> onto the cube. If you need to create one, Navigate to Assets | Create | Material, name it <kbd class="calibre13">Red Material</kbd>, click on its Albedo color chip, and select a nice red, such as RGB (<kbd class="calibre13">240, 115, 115</kbd>).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Avatar head</h1>
                
            
            
                
<p class="calibre3">Next, you'll need an avatar to represent yourself and your friends. Again, I'm going to keep this super simple so that we can focus on the fundamentals. Forget about a body for now. Just make a floating head with a face. Here's what I did. Your mileage may vary. Just be sure that it's facing forward (the positive Z direction):</p>
<ol class="calibre15">
<li class="calibre12">Create an avatar container. Navigate to GameObject | Create Empty, rename it <kbd class="calibre13">Avatar</kbd>, reset its Transform, and set its <kbd class="calibre13">Position</kbd> to the eye level, such as (<kbd class="calibre13">0, 1.4, 0</kbd>).</li>
<li class="calibre12">Create a sphere under the <kbd class="calibre13">Avatar</kbd> for the head (3D Object | Sphere), rename it <kbd class="calibre13">Head</kbd>, reset its transformation, and set Scale to (<kbd class="calibre13">0.5, 0.5, 0.5</kbd>).</li>
<li class="calibre12">Give the head some color. Navigate to Assets | Create | Material, name it <kbd class="calibre13">Avatar Head Material</kbd>, click on its Albedo color chip, and select a nice red, such as RGB (<kbd class="calibre13">115, 115, 240</kbd>). Drag the <kbd class="calibre13">Avatar Head Material</kbd> onto the <kbd class="calibre13">Head</kbd>.</li>
<li class="calibre12">The dude has got to be cool (and bald headed). We'll borrow a pair of Ethan's glasses and put them on the head. Navigate to GameObject | Create Empty, as a child of <kbd class="calibre13">Avatar</kbd>, rename it <kbd class="calibre13">Glasses</kbd>, reset its Transform, and set its Position to (<kbd class="calibre13">0, -5.6, 0.1</kbd>) and Scale (<kbd class="calibre13">4, 4, 4</kbd>).</li>
<li class="calibre12">Then, while <kbd class="calibre13">Glasses</kbd> is selected, go to the <kbd class="calibre13">Project</kbd> pane, drill down into the <kbd class="calibre13">Assets/Standard Assets/Characters/ThirdPersonCharacter/ Models</kbd> folder, unfold the <kbd class="calibre13">Ethan</kbd> prefab, find the <kbd class="calibre13">EthanGlasses.fbx</kbd> file (the mesh file), and drag it into the Inspector panel<em class="calibre2">.</em> Be sure to select the fbx version of <kbd class="calibre13">EthanGlasses</kbd>, not the prefab.</li>
<li class="calibre12">It has a mesh, but it needs a material. While <kbd class="calibre13">Glasses</kbd> is selected, go to the Project pane, find the <kbd class="calibre13">Assets/Standard Assets/Characters/ThirdPersonCharacter/Materials/</kbd> folder, find  <kbd class="calibre13"> EthanWhite</kbd>, and drag it into the Inspector.</li>
</ol>
<p class="calibre3">The following screenshot shows a version of mine (which also includes a mouth):</p>
<div><img class="image-border18" src="img/89e2e205-974f-47f8-82a2-e8efc8dc94bb.png"/></div>
<p class="calibre3">When running as multiplayer, an instance of the avatar will get spawned for each connected player. So, we must first save the object as a prefab and remove it from the scene, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">Avatar</kbd> selected in the Hierarchy, drag it into your  Project <kbd class="calibre13">Assets/Prefabs</kbd> folder</li>
<li class="calibre12">Select <kbd class="calibre13">Avatar</kbd> again from the Hierarchy and delete it</li>
<li class="calibre12">Save the scene</li>
</ol>
<p class="calibre3">OK, now we should be ready to add multiplayer networking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding multiplayer networking</h1>
                
            
            
                
<p class="calibre3">To make the scene run as multiplayer, we need at a minimum a Network Manager component and we need to identify any objects that will get spawned using the Network Identity component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Network Manager and HUD</h1>
                
            
            
                
<p class="calibre3">First, we'll add the Network Manager component, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty game object and name it <kbd class="calibre13">NetworkController</kbd></li>
<li class="calibre12">Select Add Component | Network | Network Manager</li>
<li class="calibre12">Select Add Component | Network | Network Manager HUD</li>
</ol>
<p class="calibre3">We added a Network Controller HUD which displays a simplistic default menu, in screen space, that Unity offers to select the runtime networking options (you can see it in the images that follow). It's for development. In a real project, you'll probably replace the default HUD with something more interesting. And for VR, you'll want to make yours in world space.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Network Identity and sync Transform</h1>
                
            
            
                
<p class="calibre3">Next, add a Network Identity to the <kbd class="calibre13">Avatar</kbd> prefab. We will also add a Network Transform, which instructs the networking system to synchronize the player's Transform values to the avatar instances on each client, as follows:</p>
<ol class="calibre15">
<li class="calibre12">In Project Assets, select the <kbd class="calibre13">Avatar</kbd> prefab</li>
<li class="calibre12">Navigate to Add Component | Network | Network Identity</li>
<li class="calibre12">Ensure the Local Player Authority checkbox is checked</li>
</ol>
<p class="calibre3">We will now tell the <kbd class="calibre13">Avatar</kbd> to sync its Transform properties with all other players over the network, by adding an <kbd class="calibre13">Network Transform</kbd> component:</p>
<ol class="calibre15">
<li class="calibre12">Navigate to Add Component | Network | Network Transform</li>
<li class="calibre12">Ensure that Transform Sync Mode is set to Sync Transform</li>
<li class="calibre12">And Rotation Axis is set to XYZ (full 3D)</li>
</ol>
<p class="calibre3">The Network Transform component is configured to share the actual Transform values with other player's instances of this object, including the full XYZ rotations.</p>
<p class="calibre3">Now, tell the <kbd class="calibre13">Network Manager</kbd> that our <kbd class="calibre13">Avatar</kbd> prefab represents players:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, select <kbd class="calibre13">NetworkController</kbd></li>
<li class="calibre12">In Inspector, unfold the Network Manager Spawn Info parameters so that you can see the Player Prefab slot</li>
</ol>
<ol start="3" class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">Avatar</kbd> prefab from Project Assets onto the Player Prefab slot</li>
<li class="calibre12">Save the scene</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Running as a host</h1>
                
            
            
                
<p class="calibre3">Click on the Play mode. As shown in the following screenshot, the screen comes up with the HUD start menu, which lets you select whether you wish to run and connect this game:</p>
<div><img class="image-border19" src="img/e29b8521-b239-4f76-981e-5bdaba07b3a5.png"/></div>
<p class="calibre3">Choose LAN Host (press <em class="calibre14">H</em> on keyboard). This will initiate a server (default port <kbd class="calibre13">7777</kbd> on <kbd class="calibre13">localhost</kbd>) and spawn an <kbd class="calibre13">Avatar</kbd>. The avatar is positioned at a default location, (<kbd class="calibre13">0, 0, 0</kbd>). Also, it's not connected to the camera. So, it is more like a third-person view. As mentioned above, for VR you'll eventually want to modify this default HUD to run in World Space.</p>
<p class="calibre3">The next thing to do is run a second instance of the game and see two spawned avatars in the scene. However, we wouldn't want them to overlap as both are positioned at the origin, so first we define a couple of spawn positions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding spawn positions</h1>
                
            
            
                
<p class="calibre3">To add a spawn position, you just need a game object with a Network Start Position component:</p>
<ol class="calibre15">
<li class="calibre12">Navigate to GameObject | Create Empty, rename it <kbd class="calibre13">Spawn1</kbd>, and set its Position to (<kbd class="calibre13">0, 1.4, 1</kbd>)</li>
<li class="calibre12">Navigate to Add Component | Network | Network Start Position</li>
<li class="calibre12">Duplicate the object (Ctrl-D), rename it  <kbd class="calibre13">Spawn2</kbd>, and set its Position to (<kbd class="calibre13">0, 1.4, -1</kbd>)</li>
<li class="calibre12">In Hierarchy, select <kbd class="calibre13">NetworkController</kbd>. In Inspector,  Network Manager | Spawn Info | Player Spawn Method, select Round Robin</li>
</ol>
<p class="calibre3">We now have two different spawn locations. The Network Manager will choose one or the other when a new player joins the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running two instances of the game</h1>
                
            
            
                
<p class="calibre3">A reasonable way to run two copies of the game on the same machine (<kbd class="calibre13">localhost</kbd>) is to build and run one instance as a separate executable and the other instance from the Unity Editor (the Play mode). Unfortunately, we cannot run both in VR. (Ordinarily, you can only run one VR device on a PC at a time, and one VR app on that device). So, we'll build one without VR, using a non-VR first-person controller, and run the editor version with VR enabled.  </p>
<p class="calibre3">Add a standard first-person character to the scene, as follows:</p>
<ol class="calibre15">
<li class="calibre12">If you do not have the standard Characters assets package loaded, navigate to Assets | Import Package | Characters and choose Import</li>
<li class="calibre12">Find the <kbd class="calibre13">FPSController</kbd> in the Project <kbd class="calibre13">Assets /Standard Assets/Characters/FirstPersonCharacter/Prefabs/</kbd> folder and drag it into the scene</li>
<li class="calibre12">Reset its Transform, and set it looking at the front of objects. Set Position to eye level, (<kbd class="calibre13">0, 1.4, 0</kbd>)</li>
</ol>
<ol start="4" class="calibre15">
<li class="calibre12">With <kbd class="calibre13">FPSController</kbd> selected, in the Inspector, on the First Person Controller component, set Walk Speed to <kbd class="calibre13">1</kbd></li>
<li class="calibre12">Disable<kbd class="calibre13">MeMyselfEye</kbd></li>
</ol>
<p>It can also be helpful to modify the XR Settings in Player Settings, by adding the SDK named <kbd class="calibre26">None</kbd> to the top of this list. This will cause projects to build and run without VR hardware even if you forget to uncheck the Virtual Reality Supported checkbox.</p>
<p class="calibre3">Build the executable as usual. For standalone Windows:</p>
<ol class="calibre15">
<li class="calibre12">Navigate to File | Build Settings....</li>
<li class="calibre12">Ensure that the current scene is the only one checked in Scenes In Build. If it's not present, click on Add Open Scenes.</li>
<li class="calibre12">OpenPlayer Settings....</li>
<li class="calibre12">Under XR Settings, uncheck the Virtual Reality Supported checkbox.</li>
<li class="calibre12">Under Resolution and Presentation, check the Run In Background checkbox as true.</li>
<li class="calibre12">Select Build and Run, give it a name. Subsequently, you can launch the game by double-clicking after it's built.</li>
</ol>
<p class="calibre3">Enabling the Run In Background will permit the user input controls (keyboard and mouse) in each window when running the executables.</p>
<p class="calibre3">To run the game in Unity Editor, we need to reverse some of these settings:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, disable <kbd class="calibre13">FPSController</kbd> and enable <kbd class="calibre13">MeMyselfEye</kbd></li>
<li class="calibre12">In Player Settings, check the Virtual Reality Supported checkbox and move your SDK to the top of the list</li>
</ol>
<p class="calibre3">In one of your game windows, click on the Play mode and select LAN Host (H), like we did previously. Then, in the other window, select LAN Client (C). In each game, you should now see two instances of the avatar, one for each player, as shown in the following screenshot:</p>
<div><img class="image-border20" src="img/60190bd5-d23d-4621-bcaf-884af4b0a034.png"/></div>
<p class="calibre3">If you want to run an instance of the game on a separate machine, enter the IP address of the host machine into the Client input field (for instance, <kbd class="calibre13">10.0.1.14</kbd> on my LAN) instead of <kbd class="calibre13">localhost</kbd>. If each machine has its own VR device, they can each run the corresponding MeMyselfEye prefab as applicable.</p>
<p>If you're running multiple instances of the project on a single machine, just set the LAN Client address to <kbd class="calibre26">localhost</kbd>. If you want to run on other machines on your network (including mobile devices), note the IP address of the LAN host machine and enter that value on the Client connections (for example, mine is <kbd class="calibre26">10.0.1.14</kbd>). A default value for this can even be added to your project's Network Manager component's Network Info | Network Address parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Associating Avatar with the first-person character</h1>
                
            
            
                
<p class="calibre3">It's not very interesting if the avatars don't move. That's the next piece of this puzzle.</p>
<p class="calibre3">You might think that we should have parented the avatar object under the player camera, (<kbd class="calibre13">MeMyselfEye</kbd> or <kbd class="calibre13">FPSController</kbd> ) and saved it as a Prefab, and then told the Network Manager to use that for spawns. But then, you'd end up with multiple cameras in the scene and controller scripts listening on user input. Not good.</p>
<p class="calibre3">We must have only one active player in the scene. Other players' avatars get spawned but are not controlled here. In other words, when the local player (and only the local player) gets spawned, its avatar should become a child of the camera. To achieve this, we will write a script:</p>
<ol class="calibre15">
<li class="calibre12">In Project Assets, select <kbd class="calibre13">Avatar</kbd>, navigate to Add Component | New Script, and name it <kbd class="calibre13">AvatarMultiplayer</kbd></li>
<li class="calibre12">Open and edit the <kbd class="calibre13">AvatarMultiplayer.cs</kbd> script, as follows:</li>
</ol>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.Networking; 
 
public class AvatarMultiplayer : NetworkBehaviour <br class="title-page-name"/>{ 
  public override void OnStartLocalPlayer () <br class="title-page-name"/>  { 
    GameObject camera = Camera.main.gameObject; 
    transform.parent = camera.transform; 
    transform.localPosition = Vector3.zero; 
  } 
} </pre>
<p class="calibre3">The first thing you'll notice is that we need to include the <kbd class="calibre13">using UnityEngine.Networking</kbd> namespace to access the networking API. Then, the class <kbd class="calibre13">AvatarMultiplayer</kbd> is derived from <kbd class="calibre13">NetworkBehaviour</kbd>, which internally is derived from <kbd class="calibre13">MonoBehaviour</kbd>.</p>
<p class="calibre3"><kbd class="calibre13">NetworkBehaviour</kbd> provides additional callback functions. We are going to use <kbd class="calibre13">OnStartLocalPlayer</kbd>, which gets called whenever the local player object is spawned. However, it is not called when the remote player objects are spawned. Its declaration requires the <kbd class="calibre13">override</kbd> keyword.</p>
<p class="calibre3"><kbd class="calibre13">OnStartLocalPlayer</kbd> is exactly what we want because only when a local player is spawned do we want to parent it to the camera. We access the current main camera object and make it the avatar's parent (<kbd class="calibre13">transform.parent = camera.transform</kbd>). We also reset the avatar's transform so that it's centered at the camera's position.</p>
<p>Consider improving the script to specify the actual game object you want to parent your avatar.</p>
<p class="calibre3">Run two instances of the game: Build &amp; Run to execute one, and use the Play mode for the other. Control the player in one window, and it moves the avatar in the other. Wow! You can even launch more executables and have a party!</p>
<p>Depending on the size and local position of your avatar, its model objects (such as eye glasses) may be visible from the first person camera and obstruct the view. You can hide them by disabling the child graphics. But then, for example, you wont see your own shadow (which I like). Another option is to shift the avatar graphics backwards to ensure they don't obstruct the camera's view. Either way, this can be done in this <kbd class="calibre26">AvatarMultiplayer</kbd> script. Likewise, if your game gives each avatar a body, or chair, or whatnot, the current player's instance may not need or want all those graphic detail to be following them around.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a matchmaking lobby</h1>
                
            
            
                
<p class="calibre3">So far, connecting two or more players over the network requires you to know the IP address of the host instance of the game that is running, or simply <kbd class="calibre13">localhost</kbd> if they're all running on the same machine. </p>
<p class="calibre3">Unity Networking and Cloud Services includes a built-in networking lobby manager for matchmaking between online players. It lets you create and join online "rooms," limited to a maximum number of players. Using the lobby feature is as easy as choosing Enable Match Maker in the Network HUD in your app. But first, you must subscribe to Unity Multiplayer cloud services (free, with limits for the number of concurrent users, based on your Unity license).</p>
<p class="calibre3">To use it, first enable Unity Cloud Services for your app:</p>
<ol class="calibre15">
<li class="calibre12">Above Inspector, select the Cloud icon (indicated in the following screenshot) to open the Services window</li>
<li class="calibre12">Create or choose a Unity Project ID for this project. To create an ID, click Select Organization and choose your organization, and then click Create.</li>
<li class="calibre12">Choose Multiplayer to open the multiplayer services panel</li>
<li class="calibre12">From there, open the web-based dashboard, where you're asked to specify the Max Players Per Room. Enter <kbd class="calibre13">4</kbd> and press Save</li>
</ol>
<p class="calibre3">A configured Multiplayer Services panel is shown here, with the Cloud services icon highlighted for your reference:</p>
<div><img src="img/4efeb373-190d-45a3-a550-4efb051b51f0.png" class="calibre88"/></div>
<p class="calibre3">After enabling the services in your project, you may need to rebuild the executable (File | Build And Run) and then, in the first instance of the game:</p>
<ol class="calibre15">
<li class="calibre12">From the HUD menu choose Enable Match Maker (M)</li>
<li class="calibre12">Type in a name for your room</li>
<li class="calibre12">Choose Create Internet Match</li>
</ol>
<p class="calibre3">In the second instance of the game:</p>
<ol class="calibre15">
<li class="calibre12">From the HUD menu, also choose Find Internet Match</li>
<li class="calibre12">Your room should appear as a new button</li>
<li class="calibre12">Choose the Join: button for your room</li>
</ol>
<p class="calibre3">You can now run the multiplayer game across the internet, letting Unity Services negotiate the IP addresses and maximum connections per room.</p>
<p class="calibre3">This will get you started. Of course, you have full control of the networking lobby matchmaking, like other Unity Networking services. And you most likely will want to make your own GUI. For documentation, see the NetworkManager API (<a href="https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html" class="calibre10">https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html</a>). </p>
<p>Consider starting with the example Network Lobby free asset from Unity (<a href="https://assetstore.unity.com/packages/essentials/network-lobby-41836" class="calibre20">https://assetstore.unity.com/packages/essentials/network-lobby-41836</a>). Unfortunately this asset is out of date and has bugs, but you can get it to work (read the comments). Or at least, reference it as an example when writing your own UI. Also, it is a screen space UI; for VR, you would need to modify it to be a world space canvas.</p>
<p>An example of HUD code that seems up to date can be found in this forum comment: <a href="https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400" class="calibre20">https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Syncing objects and properties</h1>
                
            
            
                
<p class="calibre3">Let's play ball! Back in <a href="77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml" class="calibre10">Chapter 8</a>, <em class="calibre14">Playing With Physics And Fire</em>, we implemented various ball games in VR. Now, we have the means to make a multiplayer one. We will make a game similar to the <em class="calibre14">Headshot</em> game, which uses your head as the paddle. But after this exercise, feel free to go and build multiplayer versions of the <em class="calibre14">Paddle Ball</em> and/or <em class="calibre14">Shooter Ball</em> games, which use a hand controller to hold and move a paddle to hit or deflect the ball.</p>
<p class="calibre3">Also, since the objective here is to focus on the multiplayer networking considerations, we will leave out some details covered in the earlier chapter, such as sound effects, particles, and object pooling.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the headshot ball game</h1>
                
            
            
                
<p class="calibre3">First, we'll add the cube paddle to the Avatar head as the one and only Collider on the Avatar:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of the <kbd class="calibre13">Avatar</kbd> prefab into your Hierarchy for editing</li>
<li class="calibre12">For each of its children (<kbd class="calibre13">Head, Glasses</kbd>), disable the Collider if present</li>
<li class="calibre12">Create a new cube child of <kbd class="calibre13">Avatar</kbd> (Create | 3D Object | Cube) and name it <kbd class="calibre13">CubePaddle</kbd></li>
<li class="calibre12">Reset its Transform and set its Scale to (<kbd class="calibre13">0.5, 0.5, 0.5</kbd>)</li>
<li class="calibre12">Disable the Cube's Mesh Renderer</li>
<li class="calibre12">Apply the Avatar changes back to its prefab (click Apply in Inspector)</li>
<li class="calibre12">Delete it from Hierarchy</li>
</ol>
<p class="calibre3">Now, we'll add a <kbd class="calibre13">GameController</kbd> object and a script that serves balls to the avatar at fixed intervals:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty game object at the Hierarchy root named <kbd class="calibre13">GameController</kbd>, and reset its Transform</li>
<li class="calibre12">Add Component | New Script and name it <kbd class="calibre13">BallServer</kbd></li>
</ol>
<p class="calibre3">Open the script and write it as follows:</p>
<pre class="calibre18">using System.Collections;<br class="title-page-name"/>using System.Collections.Generic;<br class="title-page-name"/>using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class BallServer : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public GameObject ballPrefab;<br class="title-page-name"/>    public float startHeight = 10f;<br class="title-page-name"/>    public float interval = 5f;<br class="title-page-name"/>    public List&lt;Color&gt; colors = new List&lt;Color&gt;();<br class="title-page-name"/><br class="title-page-name"/>    [SerializeField] private int colorId;<br class="title-page-name"/>    private Transform player;<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        colorId = Random.Range(0, colors.Count);<br class="title-page-name"/>        player = Camera.main.transform;<br class="title-page-name"/>        StartCoroutine("DropBall");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    IEnumerator DropBall()<br class="title-page-name"/>    {<br class="title-page-name"/>        while (true)<br class="title-page-name"/>        {<br class="title-page-name"/>            Vector3 position = new Vector3(player.position.x, <br class="title-page-name"/>                                   startHeight, player.position.z);<br class="title-page-name"/>            GameObject ball = Instantiate(ballPrefab, position, <br class="title-page-name"/>                                   Quaternion.identity);<br class="title-page-name"/>            ball.GetComponent&lt;Renderer&gt;().material.color = <br class="title-page-name"/>                                                 colors[colorId];<br class="title-page-name"/>            // (network spawn will go here)<br class="title-page-name"/><br class="title-page-name"/>            Destroy(ball, interval * 5);<br class="title-page-name"/><br class="title-page-name"/>            yield return new WaitForSeconds(interval);<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">In this script, we play a new ball every 5 seconds. Each ball remains in the scene for 25 seconds (<kbd class="calibre13">interval * 5</kbd>). We use a coroutine, with <kbd class="calibre13">yield return new WaitForSeconds(interval)</kbd> to instantiate a new ball each interval. </p>
<p class="calibre3">We also create a list of <kbd class="calibre13">colors</kbd> and randomly choose one for this player when the game starts. All balls instantiated by this player will be this color. Create the list of colors to pick from:</p>
<ol class="calibre15">
<li class="calibre12">On Ball Server component, unfold the Colors parameter</li>
<li class="calibre12">Set Size to <kbd class="calibre13">4</kbd> or higher</li>
<li class="calibre12">Define unique colors for each of the Element n color slots</li>
</ol>
<p class="calibre3">The GameController component will look similar to this in Inspector:</p>
<div><img src="img/a85e9964-4a9e-4a14-9207-cda2e5a5e12c.png" class="calibre89"/></div>
<p class="calibre3">Create a bouncy ball. We'll name it <kbd class="calibre13">NetworkBall</kbd> because in the next section we will share it across the network:</p>
<ol class="calibre15">
<li class="calibre12">Create 3D Object | Sphere, name it <kbd class="calibre13">NetworkBall</kbd>, and Scale (<kbd class="calibre13">0.5, </kbd><kbd class="calibre13">0.5, 0.5</kbd>)</li>
<li class="calibre12">On its Sphere Collider, assign the <kbd class="calibre13">Bouncy</kbd> physic material to the Material slot</li>
<li class="calibre12">Add a <kbd class="calibre13">Rigidbody</kbd> component (Add Component | Physics | Rigidbody)</li>
<li class="calibre12">Drag <kbd class="calibre13">NetworkBall</kbd> into your Project Assets <em class="calibre2">Prefabs</em> folder to create a prefab, and delete the object from Hierarchy</li>
<li class="calibre12">Drag a <kbd class="calibre13">NetworkBall</kbd> from <em class="calibre2">Prefabs</em> onto Ball Prefab slot of the GameController's BallServer</li>
</ol>
<p class="calibre3">Press Play. Locally, you'll get served balls from above, and you can deflect them with your head, just like we did in <a href="77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml" class="calibre10">Chapter 8</a>, <em class="calibre14">Playing with Physics and Fire</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spawning the ball over the network</h1>
                
            
            
                
<p class="calibre3">Other players in our networked game need to see the same balls you do. There are several steps to getting this going:</p>
<ul class="calibre11">
<li class="calibre12">First, when we instantiate a ball locally, we need to tell the network to also spawn it for all the players</li>
<li class="calibre12">When the ball moves, is bounced or hit, its Transform must be updated for all the players</li>
<li class="calibre12">When the ball's life is done, it must be destroyed for all the players</li>
</ul>
<p class="calibre3">In our present single-player version of the game, we instantiate new balls in the <kbd class="calibre13">BallServer</kbd> script. Let's make it networked:</p>
<ol class="calibre15">
<li class="calibre12">Open the <kbd class="calibre13">BallServer</kbd> script for editing</li>
<li class="calibre12">Add <kbd class="calibre13">using UnityEngine.Networking;</kbd> namespace at the top</li>
<li class="calibre12">Add a call to <kbd class="calibre13">NetworkServer.Spawn(ball);</kbd> once we have an instance created</li>
</ol>
<p class="calibre3">Then, we must register the <kbd class="calibre13">NetworkBall</kbd> prefab with the <kbd class="calibre13">NetworkManager</kbd> to inform it the prefab is spawnable:</p>
<ol class="calibre15">
<li class="calibre12">Select <kbd class="calibre13">NetworkController</kbd> in Hierarchy</li>
<li class="calibre12">In Inspector, unfold the Spawn Info parameters</li>
<li class="calibre12">Click + in the Registered Spawnable Prefabs list</li>
<li class="calibre12">Drag a copy of <kbd class="calibre13">NetworkBall</kbd> onto the spawnable prefab Game Object slot</li>
</ol>
<p class="calibre3">The Network Manager component now looks like the following:</p>
<div><img src="img/e932bb89-1992-48f0-bd5c-0790831b1735.png" class="calibre90"/></div>
<p class="calibre3">There's one other thing that we did not handle yet: destroying ball instances. In the standalone version, we called <kbd class="calibre13">Destroy(ball, interval*5)</kbd> to destroy the ball after the given time. For network spawned objects, you will call <kbd class="calibre13">Network.Destroy(ball)</kbd> instead. However, there is not an equivalent version with a timer argument. You could write a countdown timer for it in BallServer, or use some other strategy for determining when its life cycle is complete and it can be destroyed (such as a DestroySelf script on the ball prefab itself) that runs locally.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Synchronizing the ball transform</h1>
                
            
            
                
<p class="calibre3">Unity Networking has a component to share this data between players,<kbd class="calibre13">Network Transform</kbd>, which we used earlier for syncing the Avatar head. Now, we'll use it for the ball:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">NetworkBall</kbd> prefab in Project Assets.</li>
<li class="calibre12">Add Component | Network Transform.</li>
<li class="calibre12">Ensure the Transform Sync Mode is set to Sync Rigidbody/3D.</li>
<li class="calibre12">Adding Network Transform will add a Network Identity for you. Check its Local Player Authority checkbox. </li>
</ol>
<p class="calibre3">The Network Transform parameters for <kbd class="calibre13">NetworkBall</kbd> are shown here:</p>
<div><img src="img/942a0b77-a304-4b76-9d48-9c9bef6a66c4.png" class="calibre91"/></div>
<p class="calibre3">Run two copies of your project now. <em class="calibre14">Voila!</em> When you connect the games on the network, the player's balls will be visible to all other players (<em class="calibre14">nsfw? Keep it clean guys</em>). The movement of each ball in the local game will control its transform on all the other game instances.</p>
<p class="calibre3">Note that Unity is providing optimizations to limit the amount of data and frequency of updates while ensuring each player continues to see the same thing. For example, in the Network Transform, while you can sync an object's Transform position and rotation each update, you can also specify movement and velocity thresholds that signal when a sync is required. Perhaps more significant, you can choose what to sync. Instead of the Transform values themselves, you can sync changes in the Rigidbody physics (velocity, angular velocity, and so on), which happen much less often, and let each player's local game calculate the corresponding new Transform. This is the option we chose for the NetworkBall.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State variable synchronization</h1>
                
            
            
                
<p class="calibre3">When we spawn an object over the network, it uses the prefab object we registered with the Network Manager. So the spawned balls all have the default color, not the one we set locally when the object was instantiated in BallServer. We'll use this as an opportunity to show how to synchronize other properties.</p>
<p class="calibre3">The example is a little contrived, but let's say we want the object color to be a state variable. (You could add others too, such as power, health, magic and so on.) We will write a script that tells the network to sync the properties across the network, if and when its value is changed.</p>
<p class="calibre3">The compiler <kbd class="calibre13">[SyncVar]</kbd> attribute identifies the property we want to sync and sets up an <em class="calibre14">observer</em>. If we include a <kbd class="calibre13">hook</kbd>, that function will be called by the observer when the value changes.</p>
<p class="calibre3">On the <kbd class="calibre13">NetworkBall</kbd> prefab, create a new script named <kbd class="calibre13">StateVariables</kbd> and write it as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/><br class="title-page-name"/>public class StateVariables : NetworkBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    [SyncVar(hook = "OnColorChanged")]<br class="title-page-name"/>    public Color color;<br class="title-page-name"/><br class="title-page-name"/>    public void SetColor(Color changedColor)<br class="title-page-name"/>    {<br class="title-page-name"/>        color = changedColor;<br class="title-page-name"/>        GetComponent&lt;Renderer&gt;().material.color = color;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void OnColorChanged(Color networkColor)<br class="title-page-name"/>    {<br class="title-page-name"/>        GetComponent&lt;Renderer&gt;().material.color = networkColor;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">The class derives from <kbd class="calibre13">NetworkBehaviour</kbd>. We declare <kbd class="calibre13">color</kbd> with a <kbd class="calibre13">SyncVar</kbd> attribute. We provide a public setter function, <kbd class="calibre13">SetColor</kbd>, that can be called from other game objects as normal. Likewise, when the <kbd class="calibre13">color</kbd> variable is changed, it will be synchronized over the network. Remote copies running your game will call <kbd class="calibre13">OnColorChanged</kbd> to change that instance of the object too.</p>
<p class="calibre3">Now, we just need to modify the <kbd class="calibre13">BallServer</kbd> to set the color using this interface rather than modifying the material color directly. Modify the loop in the <kbd class="calibre13">DropBall</kbd> function to read as follows:</p>
<pre class="calibre18">IEnumerator DropBall()<br class="title-page-name"/>{<br class="title-page-name"/>    while (true)<br class="title-page-name"/>    {<br class="title-page-name"/>        Vector3 position = new Vector3(player.position.x, startHeight, player.position.z);<br class="title-page-name"/>        GameObject ball = Instantiate(ballPrefab, position, Quaternion.identity);<br class="title-page-name"/>        NetworkServer.Spawn(ball);<br class="title-page-name"/><strong class="calibre1">        ball.GetComponent&lt;StateVariables&gt;().SetColor( colors[colorId] );</strong><br class="title-page-name"/>        Destroy(ball, interval * 5);<br class="title-page-name"/><br class="title-page-name"/>        yield return new WaitForSeconds(interval);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Now the server will not just spawn balls on the clients, but will then send its color property setting as well.</p>
<p class="calibre3">Here is a screenshot of live two-player HeadShot gameplay on our makeshift game court:</p>
<div><img src="img/92b61774-5e4a-48c8-9426-aee68f71552f.png" class="calibre92"/></div>
<p class="calibre3">Using this basic pattern, you could extend this script to set and sync other variables representing the state of individual objects (heath, power, and so on) or the game itself (score, who's turn it is to serve, and so on).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced networking topics</h1>
                
            
            
                
<p class="calibre3">We have only touched the surface of what you can do with networking. If this interests you, I recommend you look closely at the Unity manual and go through their tutorials too. As we mentioned at the beginning of this chapter, a good place to start is the Unity Networking Concepts document (<a href="http://docs.unity3d.com/Manual/UNetConcepts.html" class="calibre10">http://docs.unity3d.com/Manual/UNetConcepts.html</a>). </p>
<p class="calibre3">It's important to understand Peer-to-Peer versus Client-Server versus Dedicated Server networking architecture. As we've seen, by default Unity Networking is Client-Server, with a player as the host Server (the player is also its own Client). You also have the option of setting up with a dedicated server running Unity as a standalone player in headless mode. </p>
<p class="calibre3">Some other networking topics and issues include:</p>
<ul class="calibre11">
<li class="calibre12">Synchronizing other serializable state variables (<a href="https://docs.unity3d.com/Manual/UNetStateSync.html" class="calibre10">https://docs.unity3d.com/Manual/UNetStateSync.html</a>)</li>
<li class="calibre12">Client custom spawn functions (<a href="https://docs.unity3d.com/Manual/UNetCustomSpawning.html" class="calibre10">https://docs.unity3d.com/Manual/UNetCustomSpawning.html</a>)  </li>
<li class="calibre12">Spawning and controlling non-player characters (NPC) from a server</li>
<li class="calibre12">Further understanding when to use local player authority versus server authority (<a href="https://answers.unity.com/questions/1440902/unet-local-player-authority.html" class="calibre10">https://answers.unity.com/questions/1440902/unet-local-player-authority.html</a>)</li>
<li class="calibre12">Calling Commands (client to server) versus  Remote Procedure Call (RPC) (server to client) (<a href="https://docs.unity3d.com/Manual/UNetActions.html" class="calibre10">https://docs.unity3d.com/Manual/UNetActions.html</a>)</li>
<li class="calibre12">Building your own multiplayer lobby (<a href="https://docs.unity3d.com/Manual/UNetLobby.html" class="calibre10">https://docs.unity3d.com/Manual/UNetLobby.html</a>)</li>
<li class="calibre12">Testing, debugging, and simulating networking conditions (<a href="https://docs.unity3d.com/Manual/UNetManager.html" class="calibre10">https://docs.unity3d.com/Manual/UNetManager.html</a>)</li>
</ul>
<p class="calibre3">Networking is not specifically a VR topic, but if you do embark on building a multiplayer networked VR application, you should spend time gaining an understanding of how data, messages, and commands are exchanged between client and server. VR includes its own unique networking challenges. The immediate, immersive experience of VR can amplify problems of latency, synchronization, and realism. We will also address some of these issues in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Options for voice chat</h1>
                
            
            
                
<p class="calibre3">Once you have two or more people in the same VR space, it is natural to want to speak with one another. Almost all VR devices have headphones and microphones so the hardware support is ubiquitous. </p>
<p class="calibre3">Presently, Unity Networking does not support voice chat (VoIP). But there are other solutions:</p>
<ul class="calibre11">
<li class="calibre12">Third-party packages such as <em class="calibre2">Dissonance Voice Chat</em> (<a href="https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078" class="calibre10">https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078</a>) add voice chat over your existing network connection. </li>
<li class="calibre12"><em class="calibre2">Photon Voice</em> (<a href="https://assetstore.unity.com/packages/tools/audio/photon-voice-45848" class="calibre10">https://assetstore.unity.com/packages/tools/audio/photon-voice-45848</a>). If you are already using <strong class="calibre1">Photon Unity Networking</strong> (<strong class="calibre1">PUN</strong>), this is the go-to package to use. If you are using Unity Network (UNet), then Photon Voice is not a great choice, or at least you'd need to establish separate connections for voice on the Photon network from your other networking.</li>
<li class="calibre12"><em class="calibre2">Oculus VoIP</em> (<a href="https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/" class="calibre10">https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/</a>). If you are using the Oculus OVR Utilities for Unity (see next topic), you can add the Oculus VoIP SDK and its sister package, Oculus Lipsync.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Oculus platform and avatars</h1>
                
            
            
                
<p class="calibre3">It is worthwhile, and fun, to mention at this point the rich platform networking tools provided by Oculus for their VR devices. As a Facebook organization, Oculus obviously has a keen interest in making VR an engaging social experience. With Oculus Platform SDK (<a href="https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/" class="calibre10">https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/</a>), each user can create and use a personalized identity and avatar across Oculus games and apps, and find and connect with friends, all with a respectable degree of security and authentication. </p>
<ul class="calibre11">
<li class="calibre12">Oculus Platform SDK Intro (<a href="https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/" class="calibre10">https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/</a>)</li>
<li class="calibre12">Oculus Platform Getting Started Guide (<a href="https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/" class="calibre10">https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/</a>)</li>
<li class="calibre12">Oculus Avatar Getting Started Guide (<a href="https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/" class="calibre10">https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/</a>)</li>
</ul>
<p class="calibre3">Along with the basic Unity integration SDK, the Oculus development ecosystem includes Oculus Rooms with match-making, 3D ambisonic audio, voice chat, lip sync, and their integrated Oculus Avatar system. </p>
<p class="calibre3">In <a href="5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml" class="calibre10">Chapter 3</a>, <em class="calibre14">VR Build and Run</em>, we included a section on <em class="calibre14">Building for Oculus Rift</em>, where you may have set up your scene to include the following:</p>
<ul class="calibre11">
<li class="calibre12">Add <kbd class="calibre13">Oculus</kbd> SDK to the Virtual Reality SDKs in Player Settings</li>
<li class="calibre12">Import the <em class="calibre2">Oculus Integration package</em> from the Asset Store, which installs an OVR folder in your Project Assets (<a href="https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022" class="calibre10">https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022</a>)</li>
<li class="calibre12">Use the <kbd class="calibre13">OVRCameraRig</kbd> prefab instead of <kbd class="calibre13">Main Camera</kbd> in <kbd class="calibre13">MeMyselfEye</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Oculus platform entitlement check</h1>
                
            
            
                
<p class="calibre3">To use the Oculus platform and cloud services, your app needs to be registered with Oculus.</p>
<p class="calibre3">Register your app in the Developer Center in order to obtain an App ID, as follows:</p>
<ol class="calibre15">
<li class="calibre12">In your browser, go to <a href="https://dashboard.oculus.com/" class="calibre10">https://dashboard.oculus.com/</a></li>
<li class="calibre12">Select Create New App and choose the device, GearVR or Oculus Rift</li>
<li class="calibre12">Make a note of the App ID (copy into your clipboard), required to initialize the Platform SDK (if you need to revisit this page, it's located at Manage | your organization | your app | Getting Started API)</li>
<li class="calibre12">Create a Test User by navigating to Manage | your organization | Settings | Test Users, and Add Test User</li>
</ol>
<p class="calibre3">Now in Unity, we need to configure your settings so it will pass the entitlement checks:</p>
<ol class="calibre15">
<li class="calibre12">Select Oculus Platform | Edit Settings from the main menu</li>
<li class="calibre12">Paste your App ID into the corresponding slot in Inspector</li>
<li class="calibre12">Under the Unity Editor Settings, check the Use Standalone Platform checkbox, and enter the Test User Email and Password generated by Add Test User previously</li>
</ol>
<p class="calibre3">Setting Use Standalone Platform will bypass your credential's entitlement checks on the Oculus server when running in the Unity Editor. But otherwise, you need to add code for this to your project, as follows:</p>
<ol class="calibre15">
<li class="calibre12">On an object in your Hierarchy, such as <kbd class="calibre13">GameController</kbd>, create a script named <kbd class="calibre13">OculusEntitlementCheck</kbd></li>
<li class="calibre12">Write it as follows (derived from the Oculus docs):</li>
</ol>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using Oculus.Platform;<br class="title-page-name"/><br class="title-page-name"/>public class OculusEntitlementCheck : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    void Awake()<br class="title-page-name"/>    {<br class="title-page-name"/>        try<br class="title-page-name"/>        {<br class="title-page-name"/>            Core.AsyncInitialize();<br class="title-page-name"/>            Entitlements.IsUserEntitledToApplication().OnComplete(EntitlementCallback);<br class="title-page-name"/>        }<br class="title-page-name"/>        catch (UnityException e)<br class="title-page-name"/>        {<br class="title-page-name"/>            Debug.LogError("Oculus Platform failed to initialize due to <br class="title-page-name"/>                                                     exception.");<br class="title-page-name"/>            Debug.LogException(e);<br class="title-page-name"/>            // Immediately quit the application<br class="title-page-name"/>            UnityEngine.Application.Quit();<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void EntitlementCallback(Message msg)<br class="title-page-name"/>    {<br class="title-page-name"/>        if (msg.IsError)<br class="title-page-name"/>        {<br class="title-page-name"/>            Debug.LogError("Oculus entitlement check FAILED.");<br class="title-page-name"/>            UnityEngine.Application.Quit();<br class="title-page-name"/>        }<br class="title-page-name"/>        else<br class="title-page-name"/>        {<br class="title-page-name"/>            Debug.Log("Oculus entitlement passed.");<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a local avatar</h1>
                
            
            
                
<p class="calibre3">Now, we'll add the Oculus Avatar to the scene for the local player. There are two avatar prefabs in the Project <kbd class="calibre13">Assets/OvrAvatar</kbd> folder: one for the local user, which may show just the player's hands in first-person view, and one for the remote players. Note that the Oculus avatars will not appear in your Unity Scene window until you press play, as they are procedurally generated and (ordinarily) require a connection to the Oculus cloud server:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, locate and unfold your <kbd class="calibre13">OVRCameraRig</kbd>. Notice it contains a child <kbd class="calibre13">TrackingSpace</kbd></li>
<li class="calibre12">From the Project Assets <kbd class="calibre13">OvrAvatar/Content/Prefabs/</kbd> folder, drag the <kbd class="calibre13">LocalAvatar</kbd> into the Hierarchy as a child of <kbd class="calibre13">TrackingSpace</kbd></li>
<li class="calibre12">In Inspector, check the Start With Controllers checkbox</li>
<li class="calibre12">Check the Show First Person checkbox</li>
</ol>
<p class="calibre3">Press Play. You can now see your hands and controllers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding remote avatars</h1>
                
            
            
                
<p class="calibre3">The Avatar SDK also uses the Oculus cloud services to get specific player's avatar settings and preferences. Set the App ID for the Avatar SDK, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select Oculus Avatars | Edit Settings from the main menu</li>
<li class="calibre12">Paste your App ID into the corresponding slot in Inspector</li>
</ol>
<p class="calibre3">This may not really be necessary right now if you're OK with the default "blue" avatar, but we'll need it for multiplayer networking. According to the Oculus docs:</p>
<p>Note: You may ignore any <strong class="calibre1">No Oculus Rift App ID</strong> warnings you see during development. While an App ID is required to retrieve Oculus avatars for specific users, you can prototype and test experiences that make use of Touch and Avatars with just the default blue avatar.</p>
<p class="calibre3">To add other player's avatars, we'll use the Oculus RemoteAvatar prefab. We need to set it up for Unity Networking like we did previously with our handmade one, including a Network Identity and Network Transform. </p>
<ol class="calibre15">
<li class="calibre12">In the Project Assets <kbd class="calibre13">OvrAvatar/Content/Prefabs/</kbd> folder, select the <kbd class="calibre13">RemoteAvatar</kbd> prefab</li>
<li class="calibre12">Choose  Add Component | Network | Network Identity</li>
<li class="calibre12">Ensure the Local Player Authority checkbox is checked</li>
<li class="calibre12">Choose Add Component | Network | Network Transform</li>
<li class="calibre12">Set Transform Sync Mode to Sync Transform</li>
<li class="calibre12">Set Rotation Axis to XYZ (full 3D)</li>
<li class="calibre12">Select <kbd class="calibre13">Network Manager</kbd> in Hierarchy</li>
<li class="calibre12">Drag the <kbd class="calibre13">RemoteAvatar</kbd> onto the Network Manager's Player Prefab slot</li>
</ol>
<p class="calibre3">We can also modify the <kbd class="calibre13">AvatarMultiplayer</kbd> script we wrote previously, which moves the local player's avatar under the player camera. In the present case, we don't really want to render the remote avatar but we do want other players to sync its Transform values, so we'll disable the rendering as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/><br class="title-page-name"/>public class AvatarMultiplayer : NetworkBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>    public override void OnStartLocalPlayer()<br class="title-page-name"/>    {<br class="title-page-name"/>        GameObject camera = Camera.main.gameObject;<br class="title-page-name"/>        transform.parent = camera.transform;<br class="title-page-name"/>        transform.localPosition = Vector3.zero;<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        GetComponent&lt;OvrAvatar&gt;().enabled = false;</strong><br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Now, when two or more players join the same room, the players should be tracked and synchronized over the network. Here is a screen capture of an Oculus Avatar playing ball in our scene:</p>
<div><img src="img/26671fd8-03af-4a84-a310-79854ddec6ea.png" class="calibre93"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and sharing custom VRChat rooms</h1>
                
            
            
                
<p class="calibre3">If your goal is simpler, to build a virtual reality world and share it with others as a shared social experience, you can use one of a number of existing social VR platforms that provide the infrastructure and allow customization. Among the best, VRChat is the only one that lets you create custom worlds and personalized avatar rigs using Unity.</p>
<p class="calibre3">VRChat is built with Unity, and you can use Unity to make custom worlds and avatars. If you haven't tried it, download a copy of the client from Steam (<a href="http://store.steampowered.com/app/438100/VRChat/" class="calibre10">http://store.steampowered.com/app/438100/VRChat/</a>) and play around with it. </p>
<p>As of this writing, VRChat requires the older Unity 5.6.3p1 version. (Download at <a href="https://unity3d.com/unity/qa/patch-releases/5.6.3p1" class="calibre20">https://unity3d.com/unity/qa/patch-releases/5.6.3p1</a>.) Copy your project into a new folder before attempting to open it in an older version of Unity. You may get warnings, but go ahead. They're mostly pertaining to scripts and we will not be exporting scripts to VRChat.</p>
<p class="calibre3">To develop for VRChat requires you have an account on their site (not the same as your Steam account). Go to <a href="https://www.vrchat.net/register" class="calibre10">https://www.vrchat.net/register</a> to register.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing and building the world</h1>
                
            
            
                
<p class="calibre3">Before we begin, decide a scene to use in VRChat. Pick any Unity scene you want. It could be the <kbd class="calibre13">Diorama</kbd> playground that we used earlier in this book, the PhotoGallery from Chapter 9, <em class="calibre14">Making Interactive Spaces</em>, or something else.</p>
<ol class="calibre15">
<li class="calibre12">Open the scene in Unity that you want to export.</li>
<li class="calibre12">Save a copy to a new name, such as <kbd class="calibre13">VRChatRoom</kbd></li>
</ol>
<p class="calibre3">Download the VRChat SDK from <a href="http://www.vrchat.net/download/sdk" class="calibre10">http://www.vrchat.net/download/sdk</a> and check the documentation at <a href="https://docs.vrchat.com/" class="calibre10">https://docs.vrchat.com/</a> for the latest instructions:</p>
<ol class="calibre15">
<li class="calibre12">Import the VRChat SDK package. Navigate to Assets | Import Package | Custom Package..., find your downloaded copy of <kbd class="calibre13">VRCSDK-*.package</kbd>, click on Open, and select Import</li>
<li class="calibre12">Delete the camera object (<kbd class="calibre13">Main Camera</kbd>, or <kbd class="calibre13">MeMyselfEye</kbd>, or whatever it is named)</li>
<li class="calibre12">From the Project <kbd class="calibre13">Assets/VRCSDK/Prefabs/World/</kbd> folder, add the <kbd class="calibre13">VRCWorld</kbd> prefab into the scene</li>
</ol>
<p class="calibre3">Spawn points define where players enter the scene. <kbd class="calibre13">VRCWorld</kbd>, by default, acts as a spawn point itself, so you can just position this object in the scene. Or, create other Empty game objects, position them where you like, and add them to the Spawns list in the <kbd class="calibre13">VRCWorld</kbd> VRC_SceneDescriptor component.</p>
<p class="calibre3">Take a look at the other VRC_SceneDescriptor parameters. Explanations can be found in the documentation at <a href="https://docs.vrchat.com/docs/vrc_scenedescriptor" class="calibre10">https://docs.vrchat.com/docs/vrc_scenedescriptor</a>. The VRC_SceneDescriptor inspector is shown here:</p>
<div><img src="img/30760ecb-e49e-4ebd-ada8-c7b1ede9d926.png" class="calibre94"/></div>
<p class="calibre3">Continue to prepare your scene for VRChat as follows:</p>
<ol class="calibre15">
<li class="calibre12">Log in to your VRChat account, via VRChat SDK | Settings</li>
<li class="calibre12">Navigate to VRChat SDK | Show Build Control Panel and review the options there.</li>
<li class="calibre12">Click the Setup Layers button, if present, to add the layers required by VRChat</li>
<li class="calibre12">Click the Setup Collision Layer Matrix button, if present</li>
<li class="calibre12">Click the Enable 3D Spatialization button</li>
</ol>
<p class="calibre3">When you're ready, you can test your world:</p>
<ol class="calibre15">
<li class="calibre12">Click the Test | New Build button to begin building a new test world</li>
<li class="calibre12">A local version of VRChat will open in a window</li>
</ol>
<p class="calibre3">When you're ready to publish the world in cyberspace:</p>
<ol class="calibre15">
<li class="calibre12">Click the Publish | New Build button</li>
<li class="calibre12">When prompted, enter the name, player capacity, description, and other information requested in the Game window in Unity</li>
<li class="calibre12">The world will be uploaded to VRChat</li>
<li class="calibre12">You can manage your uploads via VRChat SDK | Manage Uploaded Content</li>
</ol>
<p class="calibre3">Your uploaded world will be private. You can use it in VRChat and invite others to join you, but otherwise it is not public. To go public with your uploaded content, you must email a request to <kbd class="calibre13">support@vrchat.net</kbd>.</p>
<p class="calibre3">The VRC SDK provides a toolbox of components you can add to your scene, including pedestals, mirror reflections, YouTube videos, and even a combat system. To make your scene interactive, you can add your own scripts to objects with basic actions triggered by events in the world, including <kbd class="calibre13">OnSpawn</kbd>, <kbd class="calibre13">OnPickup</kbd>, <kbd class="calibre13">OnDrop</kbd>, and <kbd class="calibre13">OnAvatarHit</kbd>, to name just a few. </p>
<p class="calibre3">VRChat is one of the original social VR platforms and has proven itself with a strong community and longevity. It is a little rough around the edges but as an indie project, we have a great deal of respect and offer a lot of kudos! It is a good stable implementation that is community driven and welcomes user contributions of content. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we learned about networking concepts and architecture and used some of the many features of Unity's own multiplayer networking system. We built a simple scene and an avatar, keeping in mind that the intent is to allow the avatar's head movement to be synchronized with the player's head-mounted display.</p>
<p class="calibre3">We then converted the scene to multiplayer, adding the Unity Network components, which simplifies the multiplayer implementation to just a handful of clicks. Having proven we can build a shared multiplayer experience with the avatars, we added a bouncy ball game object shared between players, providing the fundamentals for building a multiplayer networked game.</p>
<p class="calibre3">Next, we took a quick spin of the Oculus Avatar SDKs, replacing our spherical avatars with full bodied personalized ones from the Oculus Platform ecosystem. Finally, we stepped through how easy it is to create a virtual room in VRChat by exporting a scene that you can share almost instantly.</p>
<p class="calibre3">In the next chapter, we will dive into the technical details of optimizing your VR projects to run smoothly and comfortably in VR. We will consider the different areas that affect performance and latency, from model polygon count, to Unity scripting, to bottlenecks on the CPU and GPU processors.</p>
<p class="calibre3"> </p>


            

            
        
    </body></html>