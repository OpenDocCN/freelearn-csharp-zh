- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Service Orientation and APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务导向和API
- en: Now that we have explained many principles and several methods, we are going
    to move on to chapters that will be a bit more technical and thus will show more
    examples being applied to our demonstration application. In this chapter, we will
    explain the notion of *service* from the IT perspective and will try to place
    services in the history of IT to give you a good understanding of what they are
    for and what they have brought to the industry. There are still shortcomings,
    of course, but web-oriented architecture and web services in general bring huge
    value to the software industry when they are correctly designed (which, sadly,
    is far from being common).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了许多原则和几种方法，我们将继续进入一些技术性更强的章节，这些章节将展示更多应用到我们的演示应用程序中的示例。在本章中，我们将从IT的角度解释“服务”的概念，并尝试将服务置于IT历史中，以便您更好地理解它们的目的以及它们为行业带来了什么。当然，仍然存在一些不足，但面向Web的架构和一般意义上的Web服务，当它们被正确设计时（遗憾的是，这远非普遍现象），为软件行业带来了巨大的价值。
- en: After this examination of the history of services, we will detail the characteristics
    of a good service-based architecture (I am not using the expression *Service-Oriented
    Architecture* for a precise reason, as you will discover shortly) and explain
    how their current evolution, namely REST APIs, can be of benefit to many software
    systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在对服务的历史进行了考察之后，我们将详细阐述良好服务导向架构的特征（我之所以不使用“服务导向架构”这个表达，是有确切原因的，您很快就会明白），并解释它们当前的演变，即REST
    API，如何对许多软件系统有益。
- en: Finally, we will show how the architecture patterns seen in the previous chapter
    apply to the definition of services for the demo application. To do so, we will
    of course use REST APIs since they are at the core of every modern approach to
    IT system architecture. We will come back to the notion of standards, which was
    heavily discussed in [*Chapter 2*](B21293_02.xhtml#_idTextAnchor038), and explain
    which ones can be used in our demonstration system. Finally, we will explain what
    we can do when no standards exist or apply, and this will form the transition
    point to the next chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示上一章中提到的架构模式如何应用于演示应用程序的服务定义。为此，我们当然会使用REST API，因为它们是现代IT系统架构方法的核心理念。我们将回到在[*第二章*](B21293_02.xhtml#_idTextAnchor038)中广泛讨论的标准概念，并解释哪些标准可以用于我们的演示系统。最后，我们将解释当没有标准存在或适用时我们可以做什么，这将成为下一章的过渡点。
- en: 'In this chapter, we’ll cover the following points:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Looking at the history of service orientation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看服务导向的历史
- en: Characteristics of a service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的特征
- en: Application to our demonstration system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到我们的演示系统中
- en: Looking at the history of service orientation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看服务导向的历史
- en: 'First of all, let’s start with a bit of history. it may be because I am an
    old-timer and have been programming for the past 37 years, with 25 of them in
    industrial contexts, but I think it is always interesting to know where we are
    coming from as this explains a lot of what technologies today have been created
    for, and what they still miss. This way, not only can we anticipate the shortcomings
    of certain techniques and software artifacts, but we also avoid the risk of not
    using them to their full potential, as intended by their creators. Unrolling the
    history of technologies has yet another advantage: while strolling along this
    path, you may stumble upon an old but still interesting technology that may better
    fit your context than the new kid on the block. This does not happen so often,
    but when it does and you can solve your IT problem with a battle-hardened, yet
    simpler technology than the tools generally used at present, it can provide you
    a huge boost in maintenance time and performance. For example, files-based interop
    may seem laughable to someone using web APIs every day, but in particular, contexts
    where asynchronous is better, security is not a problem, independence of the process
    is an advantage, and avoiding the deployment of a web server is a time-saver,
    they can be the perfect solution.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一点历史开始。这可能是因为我是一名老程序员，过去37年中一直在编程，其中25年在工业环境中，但我认为了解我们从哪里来总是很有趣，因为这解释了今天许多技术被创造的原因，以及它们仍然缺少什么。这样，我们不仅能够预见某些技术和软件实体的不足，还可以避免不充分利用它们的风险，正如它们的创造者所期望的。回顾技术的历史还有另一个优点：在沿着这条道路漫步时，你可能会偶然发现一个古老但仍然有趣的技术，它可能比新出现的技术更适合你的环境。这种情况并不经常发生，但当它发生时，如果你可以用一个经过实战考验的、比目前普遍使用的工具更简单的技术来解决你的IT问题，这可以在维护时间和性能上为你提供巨大的提升。例如，基于文件的互操作性可能对每天使用Web
    API的人来说显得可笑，但在特定情况下，异步操作更好、安全性不是问题、进程的独立性是一个优势、避免部署Web服务器可以节省时间的情况下，它们可以是一个完美的解决方案。
- en: So, let’s start this journey with interop techniques, and in particular begin
    with why we need them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从互操作性技术开始这段旅程，并且特别开始于为什么我们需要它们。
- en: The long-awaited reusability
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期期待的可重用性
- en: 'Making two parts of a software entity interop with each other is a concept
    almost as old as programming itself since it is related to reusability. For a
    common function to not need to be typed twice, there needs to be a way to separate
    it from the rest of the code that is different, and make it callable, one way
    or another, by these pieces of code. This can be easily schematized as shown in
    *Figure 8**.1*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使软件实体的两个部分相互互操作是一个几乎与编程本身一样古老的概念，因为它与可重用性相关。为了使一个常用函数不需要被输入两次，需要有一种方法将其从其他不同的代码部分中分离出来，并且以某种方式使其可以被这些代码片段调用。这可以很容易地如图*图8.1*所示进行图解：
- en: '![Figure 8.1 – Reusing common code](img/B21293_08_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 重复使用通用代码](img/B21293_08_01.jpg)'
- en: Figure 8.1 – Reusing common code
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 重复使用通用代码
- en: Code duplication is a problem (although the Don’t Repeat Yourself principle
    may have its own shortcomings and every programming choice is always a compromise),
    so putting some code in common is generally a valuable orientation. There are
    lots of ways to organize this, and reusability has been sought after like the
    Graal in IT for many years, even decades.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重复是一个问题（尽管“不要重复自己”原则可能有其自身的不足，而且每个编程选择总是需要妥协），因此将一些代码放在公共部分通常是一种有价值的方向。有众多方法可以组织这一点，而且可重用性就像IT领域的格拉尔一样，多年来一直被追求，甚至几十年。
- en: Routines and avoiding punching additional paper cards
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序和避免额外打纸卡
- en: The first attempt at reusability came from an era that most of you will not
    even know about, where programs existed in the form of paper cards punched with
    holes to provide instructions to the computer. This actually came from the Jacquard
    weaving mechanisms where these paper cards were used to control cloth threads
    in semi-automated machines to make certain figures and weaving patterns appear
    in the resulting cloth. Repeatability was already possible by using the same card
    again and again, but the reuse of a pattern on a given card was done by punching
    the card many times in the exact same way, resulting in a long manual process
    and involving the risk of errors. Also, each application, composed of boxes with
    punched cards in the exact order, had to contain every single instruction. Due
    to the fixed number of instructions that could fit on a card, it was practically
    impossible that a card could be reused in another stack. Even if it was possible,
    extracting the right card, using it, and then returning it to the right position
    in the stack would have been too dangerous for both applications involved, particularly
    with regard to duplicating the paper card, even if it was a manual operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首次尝试实现可重用性来自一个你们大多数人甚至都不太可能了解的时代，那时程序以穿孔纸卡的形式存在，这些纸卡上打有孔洞，为计算机提供指令。这实际上源于雅各德织机机制，在这些纸卡被用来控制半自动化机器中的布线，以在最终布料上形成特定的图案和编织图案。通过重复使用相同的卡片，可重复性已经实现，但在给定卡片上重复图案是通过多次以完全相同的方式打孔来完成的，这导致了一个漫长的手动过程，并涉及到出错的风险。此外，每个应用程序，由按精确顺序排列的带有穿孔纸卡的盒子组成，必须包含每一条单独的指令。由于卡片上可以容纳的指令数量是固定的，因此卡片在另一个堆栈中再次使用实际上是不可能的。即使可能，提取正确的卡片，使用它，然后将其放回堆栈的正确位置，对于涉及的两个应用程序来说都太危险了，尤其是关于复制纸卡，即使这是一个手动操作。
- en: 'Then came the idea of routines and sending the code back to a given address
    of the program to make it repeat some part of its instructions. The notion associated
    with the infamous (but still worthy) `GOTO` instruction was born, and it saved
    many instructions in the programs that followed. But there was a problem: routines
    could only be used inside a single program. Admittedly, it helped reduce their
    size. Nonetheless, when creating a new program, it was still necessary to type
    in the same code – and we’re talking about a time when copy-paste simply did not
    exist. So, there was a need for something better. This is what we are going to
    explore in the coming sections.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现了使用例程并将代码发送回程序中给定地址以使其重复部分指令的想法。与臭名昭著但仍然值得尊敬的`GOTO`指令相关的概念诞生了，它为后续的程序节省了许多指令。但有一个问题：例程只能在单个程序内部使用。诚然，它有助于减少它们的大小。然而，当创建一个新的程序时，仍然需要输入相同的代码——我们谈论的是一个复制粘贴根本不存在的时代。因此，需要更好的东西。这就是我们将在接下来的章节中要探讨的内容。
- en: Libraries and the capacity to share instructions between programs
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库和程序间共享指令的能力
- en: 'The next evolution of reuse was the concept of `.dll` files, or Java modules
    in `.jar` archives, are still the foundations of reuse, and universality is not
    far when Base Class Libraries like the one from Microsoft are evidence for all
    .NET programmers. For this particular framework that started under the strict
    control of Microsoft and progressively flourished into open-source availability,
    history has been a blessing, since lots of libraries are simply implemented once
    and for all. Java, on the other side, started as a more open platform but became
    progressively more closed after the buying of Sun by Oracle. Though things start
    to unify a bit (at the price of a slower evolution), there still are many libraries
    to do the same thing within the Java ecosystem. I remember being flabbergasted
    with my first professional developments in Java, after five years of .NET, by
    the fact that there was not a single XML parser library, but many of them, each
    being the best at one thing: Xerces being good at streaming analysis; Xalan recognized
    as the quickest at fully loading an XML DOM; some other library handling the DTD
    schemas and validation better; and so on. For someone used to having only `System.Xml`
    to think about, that was a huge surprise and a big disappointment, since it made
    the learning curve all of a sudden dramatically steeper than the closeness of
    the platform and language led me to expect.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用的下一个发展阶段是`.dll`文件的概念，或者说是`.jar`存档中的Java模块，它们仍然是重复使用的基石，当像微软的基类库这样的库成为所有.NET程序员的证据时，通用性就不远了。对于这个最初在微软严格控制下开始，并逐渐发展到开源可用性的特定框架，历史是一份祝福，因为许多库只是一次性实现。另一方面，Java最初是一个更开放的平台，但在Oracle收购Sun之后，它逐渐变得更加封闭。尽管事情开始有所统一（以牺牲更慢的进化为代价），Java生态系统中仍然存在许多做同样事情的库。我记得在我使用.NET五年后的第一次Java专业开发中感到震惊，因为没有一个XML解析库，而是有许多，每个库在某一件事上都是最好的：Xerces擅长流分析；Xalan被认为是加载XML
    DOM最快；有些其他库在处理DTD模式验证方面做得更好；等等。对于习惯于只有`System.Xml`的人来说，这真是一个巨大的惊喜和巨大的失望，因为它使得学习曲线突然比平台和语言的亲近性预期的陡峭得多。
- en: 'Anyhow, libraries are certainly the most widespread approach for reuse in programming
    platforms and exist in almost all modern languages, be it JavaScript, Python,
    C or C++, and so on. Though libraries also have their difficulties, not only in
    the versioning and forward-compatibility areas but also in the ease of copying
    a file, which sometimes ends up in multiple copies in a code base (which goes
    against the initial goal of reuse), they remain the go-to approach when reuse
    is necessary. Of course, as far as interop is needed, they have pronounced shortcomings
    since they are only usable in their own execution platforms: though bridges may
    exist, a Java library can only be used by a Java program, a .NET assembly can
    only be called by another .NET assembly, and so on. This is a problem that has
    occupied IT engineers for a long time and is where lots of solutions have appeared.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，库无疑是编程平台中重复使用最普遍的方法，并且几乎存在于所有现代语言中，无论是JavaScript、Python、C还是C++等等。尽管库也有它们的困难，不仅在于版本控制和向前兼容性领域，还在于复制文件时的便捷性，有时这会导致代码库中出现多个副本（这与重复使用的初始目标相悖），但它们仍然是必要时首选的方法。当然，就互操作性而言，它们有明显的不足，因为它们只能在它们自己的执行平台上使用：尽管可能存在桥梁，但Java库只能由Java程序使用，.NET程序集只能由另一个.NET程序集调用，等等。这是一个长期困扰IT工程师的问题，也是许多解决方案出现的地方。
- en: Attempts at general interoperability
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试实现通用互操作性
- en: 'The main solution to the aforementioned limitation was to create libraries
    that contained code in a compiled form, in such a way that the machine code was
    usable from any caller, whatever language was used to create the calling program,
    as long as it was also compiled in machine-readable code. The difficulty there
    was mostly technical: calling one such library was not as simple as using a function
    name and attributes. Also, there was still a limitation due to the platform of
    compilation. There was indeed no way to execute a Windows library inside a Linux
    operating system and vice versa.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述限制的主要方法是创建包含编译后代码的库，这样机器代码就可以从任何调用者处使用，无论创建调用程序的编程语言是什么，只要它也以机器可读代码编译。那里的困难主要在于技术层面：调用这样的库并不像使用函数名和属性那样简单。此外，由于编译平台的原因，仍然存在限制。确实没有在Linux操作系统内执行Windows库或反之亦然的方法。
- en: 'Microsoft actually tried to go a bit further in this direction by introducing
    the notion of OS-controlled components. These reusable units were not directly
    available as files but as entities known by the operating system itself: their
    concrete form was still filed, with the `.dll` extension, but when *registered*,
    Windows would make the functions available to any program even if it did not have
    access to the original file. In addition to being a repository for application
    customization, the registry also stores the necessary information for the **Component
    Object Model** (**COM**); in fact, it even started its career in Windows 3.11
    mostly for this use. Together with COM, a Microsoft technology called Dynamic
    Data Exchange allowed application components to be inserted into one another.
    This is what you use today when you open an Excel worksheet inside a Word document
    and see the menus adapt.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微软实际上通过引入由操作系统控制的组件的概念，在这个方向上尝试走得更远。这些可重用单元不是直接作为文件提供，而是作为操作系统本身所知的实体：它们的实际形式仍然是文件，具有`.dll`扩展名，但一旦注册，Windows就会使函数对任何程序可用，即使它没有访问原始文件。除了作为应用程序定制的存储库之外，注册表还存储了**组件对象模型**（**COM**）所需的信息；实际上，它甚至从Windows
    3.11开始就主要为了这个用途而开始其职业生涯。与COM一起，微软的一项名为动态数据交换（Dynamic Data Exchange）的技术允许应用程序组件相互插入。这就是你今天在Word文档中打开Excel工作表时看到菜单适应的原因。
- en: After COM came extensions such as COM+, then for **Distributed COM** (**DCOM**),
    which was an attempt at breaking out of the perimeter of the local computer and
    introducing remote execution of components. These did not have the same success
    as the latest innovation in this vein of components, called ActiveX. ActiveX was
    a technology built on COM to make it easier to integrate graphical components
    into applications, instead of just functions. It was even possible to embed these
    in web applications by delivering them within the browser. At a time when browser
    security was not as extended as today, it provided lots of interesting features,
    but the technology is now outdated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在COM之后，出现了COM+等扩展，然后是**分布式COM**（**DCOM**），这是试图突破本地计算机的边界并引入组件的远程执行。这些并没有像这个组件领域最新创新——ActiveX——那样成功。ActiveX是一种基于COM的技术，旨在使将图形组件集成到应用程序中变得更容易，而不仅仅是函数。甚至可以通过在浏览器中交付它们来将这些组件嵌入到Web应用程序中。在浏览器安全没有像今天这样扩展的时候，它提供了许多有趣的功能，但现在这项技术已经过时。
- en: Other technologies for distributed components existed, such as Enterprise Java
    Beans and all platforms using CORBA, but they had the same limitations as DCOM
    and did not exhibit the level of low coupling that was initially promised. Version
    control was left to the maintainer of the platform, no capacity existed for a
    relationship with the presentation layer, and other shortcomings made for a limited
    future for these technologies that are nowadays pure legacy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 存在其他用于分布式组件的技术，例如企业JavaBeans和所有使用CORBA的平台，但它们与DCOM相同的局限性，并且没有展现出最初承诺的低耦合水平。版本控制留给了平台维护者，没有能力与表示层建立关系，以及其他不足之处使得这些技术如今纯粹是遗留技术，未来有限。
- en: In fact, interoperation in the form of components might have been too humble
    to really reach the state of an ever-lasting technology such as ASCII, Unicode,
    HTTP, and some other norms that are so widely used, including as the basis for
    new approaches, that they will be around for the foreseeable future of software.
    Components started inside the perimeter of a single machine and never found a
    way to step out. A completely universal approach was necessary to make the next
    step, and it concerned bringing interoperability and reuse to a whole network
    of computers – and to be worth it, this had to be in the biggest network of all,
    the Internet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，以组件形式实现的互操作性可能过于谦逊，以至于无法真正达到ASCII、Unicode、HTTP等广泛使用的技术如持久技术状态。组件最初是在单台机器的范围内开始的，并且从未找到一种方法走出这个范围。为了迈出下一步，需要一个完全通用的方法，这涉及到将互操作性和重用带到整个计算机网络中——而且为了值得这样做，这必须在所有网络中最大的网络，即互联网中。
- en: Using web standards to try and get universal
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试使用Web标准实现通用性
- en: The next milestone in our history of interop concerns web services, in the general
    acceptance of the term, meaning providing a service through web standards. The
    web was the obvious way to make this next step since its foundations of HTTP,
    TCP/IP, Unicode, and XML were already available and offered a good part of the
    foundation such a universal interop technology would need.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们互操作历史的下一个里程碑涉及Web服务，在术语的一般接受意义上，意味着通过Web标准提供服务。由于HTTP、TCP/IP、Unicode和XML等基础已经可用，并提供了这样一个通用互操作技术所需的大部分基础，因此网络是进行这一步的明显方式。
- en: The first attempt at web services (or what we could call *reusable functions
    over the internet*) was implemented with technologies such as **Simple Object
    Access Protocol (SOAP)** and **Web Service Description Language (WSDL)**, and
    since these standards were alone in the field, they simply preempted the term
    *web service*, which became the accepted jargon for SOAP- and WSDL-compatible
    expositions. SOAP was about standardizing the XML content of requests and responses
    over HTTP to make them look like function calls, with an envelope, attributes
    with types, possible metadata, and so on. WSDL was the norm used to express the
    associated contract, in short, the grammar that was supposed to be used in SOAP
    messages. There were additional norms such as **Universal Description, Discovery,
    and Integration (UDDI)**, for example, but these fell short of their objectives
    and quickly declined. This was also the case for lots of the so-called *WS-**
    standards – WS-Authentication, WS-Routing, and other syntax additions to the web-service
    grammar that were intended to allow for complementary features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试实现Web服务（或者我们可以称之为*互联网上的可重用函数*）使用了诸如**简单对象访问协议（SOAP**）和**Web服务描述语言（WSDL**）等技术，由于这些标准在领域内是独一无二的，它们简单地预占了*web
    service*这个术语，这成为了SOAP和WSDL兼容的表述所接受的行话。SOAP旨在标准化通过HTTP请求和响应的XML内容，使它们看起来像函数调用，包括一个信封、具有类型的属性、可能的元数据等等。WSDL是用来表达相关合同的标准，简而言之，是应该在SOAP消息中使用的语法。还有额外的标准，例如**通用描述、发现和集成（UDDI**），例如，但这些未能实现其目标，并迅速衰落。许多所谓的*WS-*标准也是如此——WS-Authentication、WS-Routing以及添加到Web服务语法的其他语法，旨在允许补充功能。
- en: These solutions gained a lot of momentum in the industry in the 2000s and were
    at their strongest in the early 2010s. In fact, they generated a whole architecture
    known as **Service Oriented Architecture (SOA)**. SOA should have remained a generic
    term, but it has become associated with particular architectures and software.
    Also, software manufacturers heavily invested in *SOA tools*, making companies
    believe that central middleware was all they needed to reach interop, while people
    knowledgeable in interoperability knew that this was only one part of the deal,
    with semantic and functional interoperability being, in fact, more critical and
    more complex to obtain than technical interoperability, which is generally the
    last mile in the process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案在2000年代在行业中获得了很大的动力，并在2010年代初达到了顶峰。实际上，它们产生了一个整个架构，被称为**面向服务的架构（SOA**）。SOA本应是一个通用术语，但它已经与特定的架构和软件相关联。此外，软件制造商大量投资于*SOA工具*，使公司相信，中央中间件是他们实现互操作性的全部所需，而了解互操作性的专家知道，这仅仅是交易的一部分，语义和功能互操作性实际上比技术互操作性更关键、更复杂，而技术互操作性通常是过程中的最后一公里。
- en: This of course led to lots of critics of SOA, and many articles in the mid-2010s
    announced the death of SOA and its failure to reach its goals. In the meantime,
    its spread was still huge in the industry and lots of technologies had a rebirth
    due to SOA.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这导致了对SOA的大量批评，2010年代中期，许多文章宣布了SOA的死亡及其未能实现目标。与此同时，在行业中它的传播仍然非常广泛，许多技术因为SOA而得到了新生。
- en: The steps in middleware
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件中的步骤
- en: Middleware applications in particular were pumped up by the SOA architecture
    and, even when they were not based on SOAP and WSDL, they were able to adapt to
    it. **Enterprise Application Integration** (**EAI**) was an old dream and supposed
    that centralized adapters made it possible for many applications in a system to
    talk to each other, with the EAI platform translating every message from one format
    to the target format. Of course, its centralized aspect was a **Single Point of
    Failure** (**SPoF**) and quite a drawback. If you add to this an update of the
    EAI bricks, which is needed every time any of the applications change its version,
    it is no wonder that these customized systems never reached maturity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是中间件应用在SOA架构中被推高，即使它们不是基于SOAP和WSDL，也能适应它。**企业应用集成**（**EAI**）是一个古老的梦想，并假设集中的适配器使得系统中的许多应用程序能够相互通信，EAI平台将每个消息从一种格式转换为目标格式。当然，其集中化的方面是一个**单点故障**（**SPoF**），相当大的缺点。如果你再加上每次任何应用程序更改其版本时都需要更新的EAI砖块，那么这些定制系统从未达到成熟也就不足为奇了。
- en: '**Extract, Transform, Load** (**ETL**) is a set of data manipulation tools,
    but they can be classified as middleware applications, particularly since lots
    of interoperability streams between applications in common information systems
    are really pure data transfer, and not business function calls. Of course, this
    is a crude middleware, but the quality of the data is more important than the
    sophistication of the tool, and a well-controlled ETL can go a long way in structuring
    streams of information. Still, ETLs are not completely adapted to digital transformation,
    and it can be easy to lose control of them. One of the companies I have consulted
    for had such a messy system of ETL jobs, with more than a thousand of them kicking
    up every night, that the whole system needed a dedicated tool to orchestrate the
    jobs in a precise sequence for them to end up in clean data in the morning. With
    the never-ending addition of new jobs, time started to become scarce during the
    low-activity periods, and after using simple solutions such as adding more server
    power and parallelizing what could be parallelized, it reached a point where the
    whole system would finish its work only after the offices had opened. This, of
    course, became an important problem that had to be dealt with using radical decisions.
    To make it worse, the jobs were so interdependent and brittle that there was never
    a night where all jobs passed and it was necessary to run a few correcting jobs
    during operations, or—for the riskiest ones—to simply wait for the next night
    to, hopefully, get the clean data. For informational purposes (and may it serve
    as a warning as well, since the sheer number of jobs makes the diagram almost
    unreadable), the following diagram shows a graph of the chronological execution
    of the jobs. This diagram is meant to be an overview of complex jobs; text readability
    is not intended.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**提取、转换、加载**（**ETL**）是一组数据处理工具，但它们可以被归类为中间件应用，尤其是由于在常见的信息系统中的应用程序之间有很多互操作性流实际上是纯粹的数据传输，而不是业务功能调用。当然，这是一种粗略的中间件，但数据质量比工具的复杂性更重要，一个良好的ETL可以在结构化信息流方面走得很远。然而，ETL并不完全适应数字化转型，而且很容易失去对它们的控制。我咨询的一家公司有一个非常混乱的ETL作业系统，每晚有超过一千个作业启动，整个系统需要一个专门的工具来精确地编排这些作业，以便在早上结束时有干净的数据。随着新作业的不断添加，在低活动期间时间开始变得稀缺，在添加更多服务器功率和并行化可以并行化的内容之后，整个系统只有在办公室开门后才能完成工作。这当然成为一个重要的问题，必须通过激进的决定来解决。更糟糕的是，作业之间相互依赖且脆弱，以至于没有一个夜晚所有作业都通过，在操作期间需要运行一些纠正作业，或者对于风险最高的作业，简单地等待下一个夜晚，希望得到干净的数据。出于信息目的（并且希望它也能起到警告的作用，因为作业的数量使得图表几乎无法阅读），以下图表显示了作业的按时间顺序执行的图形。这个图表旨在概述复杂的作业；文本可读性不是目的。'
- en: '![Figure 8.2 – Complex job orchestration](img/B21293_08_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 复杂作业编排](img/B21293_08_2.jpg)'
- en: Figure 8.2 – Complex job orchestration
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 复杂作业编排
- en: '**Message-Oriented Middlewares (MOMs)** already existed for some time but got
    a kick from SOA and AMQP, ActiveMQ, MSMQ, and RabbitMQ gaining some market visibility
    by introducing robustness in message delivery (the WS-Reliability and WS-ReliableMessaging
    standards never really made it to the top, particularly because reliability needs
    to be ensured at the application level and not only in the messaging layer). Even
    in today’s architecture, which does not use SOAP web services anymore, a MOM is
    useful to ensure full-featured transportation of particularly important messages
    in the system. Some MOM proponents argue that all messages should pass through
    the middleware, preventing applications from talking directly from one to the
    other, but this has a toll on performance and we will show that functional standards
    for messages allow the removal of the mediation layer.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息导向中间件（MOMs）**已经存在了一段时间，但得益于SOA和AMQP、ActiveMQ、MSMQ和RabbitMQ的引入，它们在消息传递的可靠性方面获得了市场关注度。即使在今天不再使用SOAP
    Web服务的架构中，MOM仍然有助于确保系统内特别重要消息的全面传输功能。一些MOM支持者认为所有消息都应该通过中间件传递，防止应用程序直接相互通信，但这会影响性能，我们将展示消息的功能标准允许移除中介层。'
- en: 'As far as the mediation layer is concerned, MOMs benefited a lot from a standard
    way of manipulating messages that were defined by Hohpe and Wolf ([https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/)),
    called **Enterprise Integration Patterns** (**EIP**). EIP defines some standard
    bricks for handling software messages, such as Multiplex, Content-Based Router,
    Enrich, and so on. By combining these basic bricks of message transformation or
    routing, a MOM was able to handle almost all possible functional situations. Apache
    Camel is the reference open-source EIP implementation, and it is used in many
    middlewares. The term *bricks* is particularly adapted to these patterns, as they
    can be explained with actual, concrete, Lego™ bricks: I have often used these
    to visually explain the concepts of software system architecture and in particular,
    how to make it evolve with minimal impact by introducing a mediation layer with
    composable actions, each of them handled by a simple assembly of Technical Lego™
    bricks, as shown in *Figure 8**.3*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '就中介层而言，消息导向中间件（MOMs）从霍普和沃尔夫（[https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/)）定义的标准消息操作方式中受益良多，这种方式被称为**企业集成模式**（**EIP**）。EIP定义了一些处理软件消息的标准模块，例如多路复用、基于内容的路由器、丰富化等。通过组合这些基本的消息转换或路由模块，MOM能够处理几乎所有可能的功能场景。Apache
    Camel是参考开源的EIP实现，并被广泛应用于许多中间件中。术语*砖块*特别适用于这些模式，因为它们可以用实际的、具体的乐高™砖块来解释：我经常使用这些来直观地解释软件系统架构的概念，特别是如何通过引入具有可组合动作的中介层，以最小的冲击使系统架构演变，每个动作都由简单的技术乐高™砖块组装处理，如图*8**.3*所示。3*:'
- en: '![Figure 8.3 – Enterprise Integration Patterns simulated with Lego(TM) bricks](img/B21293_08_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 8.3 – 使用乐高™砖块模拟的企业集成模式](img/B21293_08_3.jpg)'
- en: Figure 8.3 – Enterprise Integration Patterns simulated with Lego(TM) bricks
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.3 – 使用乐高™砖块模拟的企业集成模式
- en: '**Enterprise Service Buses** (**ESBs**) are the natural evolution of MOM and
    SOA, colliding with the principles of the internet. An ESB integrates all the
    technologies we have talked about in a system where there is no centralization
    anymore: the network (in TCP/UDP) is the only thing that remains central and its
    ability to adapt delivery is used to improve robustness to a node failure. At
    the same time, the *Store & Forward* pattern is used to make sure that the messages
    can almost never be lost since they are persisted and only deleted when the next
    destination has confirmed that they persisted under their control. ESBs had just
    about everything that was needed to reach the complete functional goal of interoperability
    in systems that were internet-scaled. But still, they failed, or at least did
    not succeed as much as would be expected for the ideal solution to such an important
    problem in the IT industry. In fact, ESBs added all the necessary features, but
    this was their doom. Since they could make everything, their heavy, complex machinery
    required extensive expertise to run and maintain.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业服务总线（ESB**）是MOM和SOA的自然演变，与互联网的原则相冲突。ESB将我们讨论过的所有技术集成到一个不再有集中的系统中：网络（在TCP/UDP中）是唯一保持中心化的东西，其适应交付的能力被用来提高对节点故障的鲁棒性。同时，使用**存储和转发**模式来确保消息几乎永远不会丢失，因为它们被持久化，并且只有在下一个目的地确认它们在其控制下已持久化后才会被删除。ESBs几乎拥有实现互联网规模系统互操作完整功能目标所需的一切。但仍然，它们失败了，或者至少没有像预期的那样成功，因为这是解决IT行业如此重要问题的理想解决方案。事实上，ESBs添加了所有必要的功能，但这正是它们的厄运。由于它们可以做到一切，它们庞大、复杂的机器需要大量的专业知识来运行和维护。'
- en: The most recent evolution – REST APIs
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新的演变——REST API
- en: Then came REST, which is a much lighter way of creating web-based APIs, and
    this changed the ecosystem quite radically again. **REpresentational State Transfer
    (REST)** had been defined before 2000 but became really famous in the early 2010s.
    In the 2020s, though the part of the legacy software is huge and SOAP web services
    continue to be exploited, no new project would start based on these old technologies
    and virtually every new API project is using REST, or at least some degraded,
    not really “RESTful” approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现了REST，这是一种创建基于Web的API的更轻量级的方式，这再次彻底改变了生态系统。**表示性状态转移（REST）**在2000年之前就已经被定义，但在2010年代初才真正成名。到了2020年代，尽管遗留软件的部分很大，SOAP
    Web服务仍在被利用，但没有任何新项目是基于这些旧技术开始的，几乎每个新的API项目都在使用REST，或者至少采用了某种降级的、并非真正“RESTful”的方法。
- en: In a few words, REST is about going back to the basic mechanisms of HTTP to
    allow function calls on the web. For example, instead of sending the code of the
    operation in the envelope as SOAP does, REST uses HTTP verbs such as `GET`, `POST`,
    `PUT`, `PATCH`, and `DELETE` to instruct the server on what should be done. Instead
    of sending function calls, it deals with resources just as HTTP does with the
    more-known HTML pages or images that are served through the web; it just happens
    that these resources are functionally oriented, such as a customer or a contract.
    Each of these business entities has URLs just like a web page or resource has.
    Their representation can be in HTML but is more suited to XML or JSON, the latter
    of which is also lighter than its predecessor XML. Hypermedia, format negotiation,
    and headers are also used for the equivalent interop function. Authorization is
    simply left to the equivalent feature in any HTTP call, using Basic Authentication,
    Bearer tokens, and so on. In short, REST stripped the web-based interop to the
    bone and eliminated every ounce of fat to focus on the pure and complete use of
    existing standards. REST does not actually need anything else beyond existing
    standards such as HTTP, JSON or XML, and Unicode. In this way, it is more a practice
    than a new protocol.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，REST是关于回归HTTP的基本机制，以允许在Web上进行函数调用。例如，与SOAP将操作代码发送到信封中不同，REST使用HTTP动词，如`GET`、`POST`、`PUT`、`PATCH`和`DELETE`来指示服务器应该做什么。它不是发送函数调用，而是像HTTP处理更知名的HTML页面或通过Web提供的图像一样处理资源；只是这些资源在功能上是有方向的，比如客户或合同。这些业务实体每个都有URL，就像网页或资源一样。它们的表示可以是HTML，但更适合XML或JSON，后者比其前身XML更轻量。超媒体、格式协商和头部也被用于等效的互操作功能。授权简单地留给任何HTTP调用中的等效功能，使用基本身份验证、Bearer令牌等。简而言之，REST将基于Web的互操作简化到了极致，消除了每一丝冗余，以专注于现有标准的纯粹和完整使用。实际上，REST并不需要除HTTP、JSON或XML、Unicode等现有标准之外的其他任何东西。因此，它更多的是一种实践，而不是一种新的协议。
- en: 'And it worked… It actually worked so well that commentators on the internet
    did not hesitate to talk about SOA 2.0, or even *SOA made right*. Some introduced
    new architectural terms such as *Web-Oriented Application* to separate this approach
    from the original SOA. The best proof of success for REST is that no editor has
    built on its fame to try and impose a proprietary implementation: REST works well
    because it does not add anything but reduces any software layer to nil since everything
    already exists, and engineers only have to use it in the way it was intended.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它确实有效……它实际上运作得如此之好，以至于互联网上的评论者毫不犹豫地谈论SOA 2.0，甚至*正确的SOA*。有些人引入了新的架构术语，如*面向Web的应用*，以将这种方法与原始SOA区分开来。REST成功的最好证明是，没有编辑利用其名声来尝试强制实施专有实现：REST之所以运作良好，是因为它没有添加任何东西，而是将任何软件层减少到零，因为一切都已经存在，工程师只需按照其预期的方式使用它即可。
- en: What we are missing to reach actual service reusability
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们缺少什么才能达到实际的服务重用性
- en: This is where we are at the moment of writing this book, and there is absolutely
    no doubt that the situation will keep evolving, but we have reached a point where
    actual web-based interop, including between two separate entities, is an everyday
    reality for lots of companies, which is already a huge victory in itself. Sure,
    we can always go further, but the main path has been paved and the remaining tasks
    now are mostly about spreading good practices in this way of interoperating rather
    than imagining a new approach that overcomes any current shortcomings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在撰写本书时的现状，毫无疑问，情况将继续发展，但我们已经达到了一个点，即基于实际的基于Web的互操作性，包括两个独立实体之间的互操作性，对于许多公司来说已经成为日常现实，这本身就是一个巨大的胜利。当然，我们总是可以更进一步，但主要道路已经铺好，现在剩下的任务主要是传播这种互操作方式的好做法，而不是想象一种克服任何当前缺点的新方法。
- en: In fact, most of the remaining problems are the presence of mediation connectors
    due to the lack of accepted formats for functional data exchange. If we want to
    reach the ideal place where global, universal interop will not be an issue anymore
    but rather a problem of the past, we would need to have an indisputable standard
    for each of the data streams. This is of course not possible and we are very far
    from such a satisfying state, but some precise, very widespread, and technically
    easy forms of exchange are currently covered. For example, authentication and
    identification are now well implemented by OpenID Connect, SAML, JSON Web Tokens,
    SCIM, and a few other norms. Sure, there are lots of legacy software and even
    expert engineers that do not use these, but the general orientation is that they
    are the future and everyone globally accepts this and works towards these norms,
    which will become convenience standards in the future, just as ASCII and Unicode
    are for text binary representations. A few other domains are covered, or at least
    have nice, fully-featured norms that could solve the problem, such as CMIS for
    electronic document exchanges or BPMN 2.0 for workflow modeling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大部分剩余的问题都是由于缺乏功能数据交换的公认格式，导致存在中介连接器。如果我们想要达到一个理想的地方，在那里全球通用的互操作性不再是问题，而是一个过去的问题，我们就需要为每个数据流拥有一个无可争议的标准。这当然是不可能的，而且我们离这样的满意状态还非常遥远，但一些精确的、非常普遍的、技术上容易的交换形式目前已被涵盖。例如，认证和识别现在由OpenID
    Connect、SAML、JSON Web Tokens、SCIM以及一些其他规范很好地实现了。当然，有很多遗留软件甚至专家工程师没有使用这些，但总体趋势是它们是未来的方向，全球各地都接受这一点，并朝着这些规范努力，这些规范将成为未来的便利标准，就像ASCII和Unicode对于文本的二进制表示一样。还有一些其他领域被涵盖，或者至少有很好的、功能齐全的规范可以解决这个问题，例如CMIS用于电子文档交换或BPMN
    2.0用于工作流建模。
- en: 'But the vast majority of exchanges are not covered by an indisputable standard
    and legions of connectors are still developed to establish correspondence between
    applications. This is a major waste of resources in global IT today, as these
    mediation connectors do not add any additional value to customers and end users.
    But the reality is that crafting a standard takes a lot of time, as we have seen
    in [*Chapter 2*](B21293_02.xhtml#_idTextAnchor038). Let’s try to focus on the
    positive, though: the movement is now active and the situation is getting better
    every year, with a strong interop foundation where the technical bits are now
    considered solved. Only the semantics and functional interop remain to be handled.
    This will be the subject of the next chapter but, before talking about this, we
    need to come back to the very notion of *service* and explain how a good service
    should be defined. We will then use these principles to draft the first services
    for our demonstration system using the architecture principles shown in the previous
    chapter and applying them to the demo application that has been shown previously
    and that we will develop in greater detail throughout the rest of the book.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但绝大多数的交换都没有被一个无可争议的标准所覆盖，大量的连接器仍在开发中，以建立应用程序之间的对应关系。这在当今全球IT领域是一个巨大的资源浪费，因为这些中介连接器并没有为顾客和最终用户增加任何额外的价值。但现实是，制定一个标准需要花费大量的时间，正如我们在[*第二章*](B21293_02.xhtml#_idTextAnchor038)中看到的。尽管如此，让我们尝试关注积极的一面：现在这个运动正在活跃，情况每年都在改善，有一个强大的互操作性基础，其中技术问题现在已经得到解决。只剩下语义和功能互操作性需要处理。这将是下一章的主题，但在讨论这一点之前，我们需要回到“服务”这个概念本身，并解释一个好的服务应该如何定义。然后我们将使用这些原则来制定我们演示系统的第一个服务，使用上一章中展示的架构原则，并将它们应用于之前展示的演示应用程序，并在本书的其余部分对其进行更详细的开发。
- en: Characteristics of a service
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务的特征
- en: '**Service** is such a blurry designation that a complete section will be necessary
    to give a good sense—rather than a single definition—of this concept.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**是一个如此模糊的术语，以至于需要一个完整的章节来给出一个良好的概念理解——而不是一个单一的定义。'
- en: As a service explained
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如同服务所解释的
- en: 'The expression *as a service* is used in many formulations: **SaaS** for **Software
    as a Service**, **PaaS** for **Platform as a Service**, **CaaS** for **Containers
    as a Service**, and so on. Have you ever considered why such different things
    use this common denomination? This in itself gives maybe the best definition of
    what a service is: something that benefits from the advantages of something else
    without having to deal with the usually-associated externalities. A hotel room
    is a service because you benefit from a bed and a roof without needing to buy
    and maintain a house, or even clean the room. SaaS is a service because you can
    use the software (manipulating its interface, storing data and retrieving it,
    realizing complex computations, and exporting the results) without having to install
    the software, buy a long-term license, operate it, install new versions, and so
    on. IaaS is a service because it offers what you expect from infrastructure (CPU
    power, RAM, I/O, storage, network bandwidth, and use) without you needing to worry
    about the hardware aspect of buying servers, operating them, renting some room,
    sorting electricity and cooling, securing them physically, renewing the hardware
    when there is a failure, and so on.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “作为服务”这个表达在许多公式中被使用：**SaaS**代表**软件即服务**，**PaaS**代表**平台即服务**，**CaaS**代表**容器即服务**，等等。你有没有考虑过为什么如此不同的事物使用这个共同的名称？这本身可能就是对服务最好的定义：从其他事物中受益，而不必处理通常与之相关的外部性。酒店房间是一种服务，因为你可以享受到床和屋顶的好处，而不需要购买和维护一栋房子，甚至不需要打扫房间。SaaS是一种服务，因为你可以使用软件（操作其界面、存储数据并检索它、实现复杂的计算、导出结果），而不需要安装软件、购买长期许可证、操作它、安装新版本等等。IaaS是一种服务，因为它提供了你对基础设施的预期（CPU功率、RAM、I/O、存储、网络带宽和使用），而不需要你担心购买服务器的硬件方面、操作它们、租用一些房间、整理电力和冷却、物理上保护它们、在出现故障时更新硬件等等。
- en: 'This explanation of the *as a service* expression was necessary because the
    word *service* by itself is very generic and one may be a bit lost as to why we
    talk about *service-oriented architecture*, then web services in the sense of
    SOAP web services, then services in the context of the web, and so on. When we
    talk about service in this book, we really mean service as a software function
    that is proposed to a user without them having to work on its implementation:
    the user does not have to know which platform is used, where the servers are,
    and so on. They only have to know the minimal information possible, namely a URL
    and the contract defining the exchange grammar, to interoperate with the service.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解释**作为服务**的表达式是必要的，因为“服务”这个词本身非常通用，人们可能会有些困惑，为什么我们谈论**面向服务架构**，然后是SOAP网络服务的概念，然后是网络环境中的服务，等等。当我们在这本书中谈论服务时，我们真正指的是作为软件功能向用户提供的服务，而用户无需关注其实现：用户不需要知道使用的是哪个平台，服务器在哪里等等。他们只需要知道尽可能少的信息，即一个URL和定义交换语法的合同，以便与该服务进行互操作。
- en: 'Does this remind you of something? Depending on only the functional definition
    of something, without any software-associated constraint? This is something that
    has already been exposed in the book, in particular where we talked about the
    four-layer CIGREF map model:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你想起了什么吗？仅仅依赖于某物的功能定义，而不考虑任何与软件相关的约束？这正是书中已经提到过的内容，特别是我们讨论了四层CIGREF图模型的部分：
- en: '![Figure 8.4 – Decoupling illustrated with the CIGREF map](img/B21293_08_4.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 使用CIGREF图解耦](img/B21293_08_4.jpg)'
- en: Figure 8.4 – Decoupling illustrated with the CIGREF map
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 使用CIGREF图解耦
- en: When talking about providing a *function* *as a service*, one can view it as
    having something in the second layer from the top (the Business Capability Map)
    without having to worry about how it is implemented in the third and fourth layers
    (the technical ones).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论提供**作为服务**的**功能**时，可以将其视为从第二层（业务能力图）获得某些内容，而无需担心它在第三层和第四层（技术层）如何实现。
- en: Getting rid of middleware altogether
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全去除中间件
- en: 'The nice advantage of the *as-a-service* approach is that it allows us to get
    rid of the middleware altogether. Indeed, what we really want to avoid is the
    direct, point-to-point interop that causes a lot of coupling, as shown in the
    following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**作为服务**的方法的一个优点是它允许我们完全去除中间件。实际上，我们真正想避免的是直接、点对点的互操作，这会导致大量的耦合，如下面的图所示：'
- en: '![Figure 8.5 – Point-to-point interoperation](img/B21293_08_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 点对点互操作](img/B21293_08_05.jpg)'
- en: Figure 8.5 – Point-to-point interoperation
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 点对点互操作
- en: 'But the middleware, while introducing an indirection layer, poses two problems.
    The first one is that it introduces an additional software complexity, which can
    be hard to maintain. The second one is that we are still in the software layer
    of the CIGREF map, and this means that, if done badly (without standardizing the
    messages), we could very well end up with two steps of coupling instead of simplifying
    it! The following schema expresses this potential danger:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但中间件，虽然引入了一个间接层，却带来了两个问题。第一个问题是它引入了额外的软件复杂性，这可能很难维护。第二个问题是我们仍然处于CIGREF图的软件层，这意味着，如果没有进行标准化（没有标准化消息），我们可能会遇到两步耦合而不是简化它！以下方案表达了这种潜在的危险：
- en: '![Figure 8.6 – Interoperation through a middleware](img/B21293_08_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 通过中间件进行互操作](img/B21293_08_06.jpg)'
- en: Figure 8.6 – Interoperation through a middleware
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 通过中间件进行互操作
- en: 'ESBs are often presented as a solution to avoid a centralized entity, but the
    way they actually work still implies the presence—though distributed—of software
    agents that can cause coupling:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 企业服务总线（ESB）通常被提出作为避免集中实体的解决方案，但它们实际工作的方式仍然意味着存在（尽管是分布式的）可能导致耦合的软件代理：
- en: '![Figure 8.7 – Interoperation with Enterprise Service Bus](img/B21293_08_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 与企业服务总线进行互操作](img/B21293_08_07.jpg)'
- en: Figure 8.7 – Interoperation with Enterprise Service Bus
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 与企业服务总线进行互操作
- en: 'One way to avoid this coupling is to standardize the messages from a functional
    point of view:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种耦合的一种方法是从功能角度标准化消息：
- en: '![Figure 8.8 – Interoperation with standardized decoupled functions](img/B21293_08_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 与标准化解耦功能进行互操作](img/B21293_08_08.jpg)'
- en: Figure 8.8 – Interoperation with standardized decoupled functions
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 与标准化解耦功能进行互操作
- en: 'But if we reach this state where a functional standard has been created, the
    middleware actually does not need to map data anymore or translate any format,
    because the `f` and `f''` functions are actually the same (otherwise they would
    not have been included in a single stream of data). The middleware’s sole functions
    remain routing, authentication, and some other features that can simply be realized
    by HTTP and do not need any middleware. Thus, the intermediate simply disappears
    and we reach the ideal situation that was expressed previously:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们达到了这样一个状态，即已经创建了一个功能标准，那么中间件实际上不再需要映射数据或转换任何格式，因为`f`和`f'`函数实际上是相同的（否则它们不会被包含在单一的数据流中）。中间件唯一的功能仍然是路由、认证以及一些可以通过HTTP简单实现的功能，而不需要任何中间件。因此，中间件简单地消失了，我们达到了之前所表达的理想情况：
- en: '![Figure 8.9 – Principle of decoupling by indirection](img/B21293_08_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 间接解耦原理](img/B21293_08_09.jpg)'
- en: Figure 8.9 – Principle of decoupling by indirection
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 间接解耦原理
- en: Here, the only difficulty remaining is a functional one, that of describing
    the business-related need. Admittedly, this can be a very difficult thing to do,
    but the main difference is that this is intrinsic complexity that we need to overcome
    in any case (otherwise the software will simply not work correctly) and not accidental,
    technical complexity that steps into our design phase and adds unnecessary problems
    of versioning, maintenance, and so on. This is the essence of decoupling and making
    it easier for the system to evolve.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，唯一剩下的困难是一个功能性的，即描述与业务相关的需求。诚然，这可能是一件非常困难的事情，但主要区别在于这是我们需要在任何情况下克服的内在复杂性（否则软件将无法正确工作），而不是偶然的技术复杂性，它进入我们的设计阶段并增加了版本控制、维护等问题。这是解耦的本质，也是使系统更容易演化的关键。
- en: Again, even though this is something we should strive to achieve in as many
    cases as possible and definitely a way to create some low-coupling interop, this
    kind of interaction is not always easy to realize. MOM and other middleware systems
    will not be retired any time soon, as they remain a good choice to interoperate
    complex messages, apply mediation, and ensure robustness of delivery when it is
    not possible to put in place a complete standardization of messages in the information
    system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管我们应该尽可能努力实现这一点，并且这确实是一种创建低耦合互操作性的方法，但这种交互并不总是容易实现。MOM和其他中间件系统在不久的将来不会退役，因为它们仍然是互操作复杂消息、应用调解以及在无法在信息系统中对消息进行完全标准化时确保交付鲁棒性的好选择。
- en: External interop finally becoming a reality
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部互操作性最终成为现实
- en: All of this may sound a bit theoretical, but this approach is what enables us
    to finally reach the stage where the interop between software `A` and software
    `B` in the preceding diagrams (*Figures 8.5* to *8.9*) does not depend on middleware
    or other artifacts that get in the way and make it complicated. The best way to
    show this is to provide a few practical examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能听起来有点理论化，但正是这种方法使我们最终达到了这样一个阶段，即前面图示中的软件`A`和软件`B`之间的互操作性（*图8.5*至*8.9*）不再依赖于中间件或其他阻碍其复杂化的工件。展示这一点最好的方式是提供一些实际例子。
- en: 'In a company I worked for in the past, two customers (a regional council and
    a town) wanted to interop in such a way that, when the regional council added
    an association to its list, the city would automatically receive the information
    and store it in its own database, provided that it was the given city of registration.
    The way this was done necessitated some important preliminary work that had been
    done by my employer, which was to define a standard format for French associations.
    Since we knew the subject well, this took only a few days and we proposed this
    format to the French government for publication in their open source forge as
    they did not have any existing standard for this. This format was the functional
    contract between the two customers. They agreed that, whatever changes they might
    make to their software, the content of the association JSON would always be the
    following (this extract is highly simplified and translated into English for improved
    readability):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前工作的一家公司中，两个客户（一个区域委员会和一个城镇）希望以这种方式进行互操作，即当区域委员会将其列表中的关联添加时，城市会自动接收到信息并将其存储在其自己的数据库中，前提是它是注册的城市。这种方式需要一些重要的前期工作，这是我的雇主完成的，即定义法国协会的标准格式。由于我们对主题很了解，这仅花了几天时间，我们就将此格式提交给法国政府，以便在他们的开源
    forge 中发布，因为他们没有为这个现有的标准。这个格式是两个客户之间的功能合同。他们同意，无论他们可能对其软件进行何种更改，协会JSON的内容始终如下（此提取高度简化并翻译成英语以提高可读性）：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It happened that the regional council was already a customer before this project,
    so they already were using our moral person referential software based on this
    format. So, on this side, we only had to customize the event management system
    to call the second customer callback address whenever the events of creation,
    modification, or removal of an association happened. This was done with the following
    grammar:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，区域委员会在这个项目之前已经是客户，所以他们已经在使用基于此格式的我们道德人参考软件。因此，在这一方面，我们只需要定制事件管理系统，以便在发生创建、修改或删除协会的事件时调用第二个客户的回调地址。这是通过以下语法完成的：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To give a bit of explanation, webhooks are registrations of an external system
    to events emitted by the given application. In our case, when the regional council
    actors’ referential service received data of a new organization or a change in
    existing data, through the referential service’s API methods, associated events
    were raised and the aforementioned customization file extract associated these
    with calls of the provided URL. This URL was exposed by the second customer (the
    city of Saint-Nazaire) using PHP (but the specific technology doesn’t matter).
    When, for example, we applied `POST` to a new organization, the callback URL was
    called with the identifier of the created entity along with the `PUT` verb. This
    is also where we introduced the fact that the city was only interested in associations
    (not all organizations), and in particular, the ones based in their territory,
    with the `filter` attribute.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍作解释，webhooks 是外部系统对由给定应用程序发出的事件的注册。在我们的案例中，当区域委员会的参考服务接收到新组织或现有数据变更的数据时，通过参考服务的API方法，会引发相关事件，上述定制文件提取将这些事件与提供的URL的调用相关联。这个URL是由第二个客户（圣纳泽尔市）使用PHP（但具体技术不重要）公开的。例如，当我们对一个新组织应用`POST`操作时，回调URL会调用创建实体的标识符以及`PUT`动词。这也是我们引入事实的地方，即该城市只对关联（不是所有组织）感兴趣，特别是那些在其领土上的组织，使用`filter`属性。
- en: The URL implementation was then free to work as it pleased, without any dependence
    on the emitter. In some operations, the fact that there was an event on a given
    identifier was enough (for example, to deactivate the association in case of a
    `DELETE` order in the regional council information system). In some other cases,
    for example when an association was created, the JSON content—the exact grammar
    of which was agreed upon between the two participants—would be retrieved through
    a `GET` operation owing to the identifier obtained in the callback (where there
    was a use for all information of the association) or simply read in the body of
    the callback call (as the most important data were sent there, using the same
    contractual grammar, of course).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，URL 实现可以自由地按其意愿工作，而不依赖于发射器。在某些操作中，给定标识符上发生事件的现实就足够了（例如，在区域议会信息系统中收到`DELETE`命令时，可以取消关联）。在其他情况下，例如创建关联时，JSON
    内容——其精确语法由双方达成一致——将通过回调中获得的标识符通过`GET`操作检索（因为关联的所有信息都有用）或简单地读取回调调用体（因为最重要的数据被发送到那里，当然使用相同的合同语法）。
- en: 'This example proved to be a successful experiment, as each of the customers
    was then free to evolve their systems in the way they wanted, changing technologies
    or other parameters without their partner even needing to know about it. At some
    point, the city would be interested in associations outside its own zip-code area
    and could simply register a new webhook content with the updated filter. This
    did not impact the emitter of the event, not even in its authorization scheme:
    if the city had requested to be called for associations outside its department
    (a French geographical unit between a region and a city), the event would have
    been sent, but reading the information with the help of the identifier received
    would simply end up in a `403 Forbidden` HTTP status code. This particular mechanism
    was something that initially made us decide to never send any data in the callback
    request in order to simplify authorization mechanisms. But, at some point, it
    was decided that forcing the called entity to always reply with a `GET` call to
    obtain the name and basic information of a new association was a waste of bandwidth.
    Performance was not so much an issue, but simplicity was more important in this
    context than the risk of authorization mishaps, since this data is public in France
    and easy to obtain.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子证明是一个成功的实验，因为每个客户都可以自由地以他们想要的方式发展他们的系统，改变技术或其他参数，而他们的合作伙伴甚至不需要知道这一点。在某个时候，城市可能会对其邮政编码区域外的关联感兴趣，只需简单地注册一个新的带有更新过滤器的
    webhook 内容。这不会影响事件发射器，甚至不会影响其授权方案：如果城市要求在部门（法国的一个介于地区和城市之间的地理单位）之外被调用，事件就会被发送，但通过接收到的标识符读取信息最终只会导致`403
    Forbidden` HTTP 状态码。这种特定的机制最初让我们决定在回调请求中永远不发送任何数据，以简化授权机制。但是，在某个时候，有人决定强制被调用实体始终以`GET`调用回复以获取新关联的名称和基本信息是一种带宽浪费。性能并不是问题，但在这种情况下，简单性比授权失误的风险更重要，因为这项数据在法国是公开的，而且很容易获得。
- en: Interop made real with standards
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准化实现互操作性
- en: The preceding example demonstrated a case where a particular data schema (we
    call this a *pivotal format*, but we will come back to this in more detail at
    the end of this chapter and in the next one) had to be devised to exchange data
    in a free and decoupled manner. But an even better case is where this contract
    already exists in the industry. This is another practical case I had the pleasure
    of dealing with, in particular, because the small company I worked for by then
    forced a much bigger one to comply with our way of working, simply because we
    used a recognized standard. Let me explain the situation better…
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子演示了一个特定数据模式（我们称之为*关键格式*，但我们将在本章末尾和下一章中更详细地讨论这一点）必须被设计出来以自由和松耦合的方式交换数据的情况。但更好的情况是，这种合同在行业中已经存在。这是另一个我有幸处理的实际案例，特别是，因为当时我工作的那家小公司迫使一家更大的公司遵守我们的工作方式，仅仅因为我们使用了公认的标准。让我更好地解释一下情况……
- en: Our flagship application, a kind of ERP, generates PDF documents and other binary
    files, and these should be stored. For quite some time, those would be stored
    alongside the database in a network share or, sometimes, in a dedicated server
    accessed through a UNC link. Electronic document management systems started to
    become mainstream after a few years and we needed to adapt our application so
    that it could use these systems to store documents. The natural choice for this
    was the Content Management Interoperability Services norm, as OASIS published
    a fully-featured 1.1 version supporting multiple metadata schemas, classification,
    versioning, and many more functions that we did not even need. It also happened
    that this was the only standard in use in this functional area, which makes for
    a very easy architectural decision.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旗舰应用程序，一种类型的ERP，生成PDF文档和其他二进制文件，这些文件应该被存储。在相当长的一段时间里，这些文件会存储在数据库旁边的网络共享中，有时也会存储在通过UNC链接访问的专用服务器上。电子文档管理系统在几年后开始成为主流，我们需要调整我们的应用程序，使其能够使用这些系统来存储文档。对于这一点，自然的选择是内容管理互操作性服务规范，因为OASIS发布了一个功能齐全的1.1版本，支持多个元数据模式、分类、版本控制以及许多我们甚至不需要的功能。而且，这也恰好是这个功能领域唯一使用的标准，这使得架构决策变得非常简单。
- en: 'So we ended up using a few operations from the standard (in the first step,
    we only needed to create documents, add metadata and binary content to them, and
    then retrieve documents through a query on their metadata content), which took
    us a few weeks to add to our application. Customers were quite satisfied because
    a simple customization of the software would make documents appear in their Alfresco
    or Nuxeo EDM systems, since these applications are natively CMIS 1.1 compatible.
    But what really demonstrated the importance of such a normative approach was the
    first time we had to deal with a customer equipped with a proprietary EDM: the
    editor, a quite large company, with an important footprint in the information
    system of our common customer, wanted us to make changes to our application in
    order to support their proprietary web services in order to send documents and
    metadata. After an initial refusal from us, the situation got a bit tense but
    we were lucky that the information system owner was a clever person who understood
    perfectly the value of low coupling. She intelligently asked what the effort would
    be for one partner if she had to select another supplier for the services this
    one talked to. The EDM provider stated that they would not have to do anything
    if our company was replaced by another one. As far as our company was concerned,
    I explained that—in the reverse hypothesis—we would have to rewrite some parts
    of the code to adapt to another proprietary protocol. This was enough for the
    customer, even if she was not a technical expert, to realize that something was
    wrong with this way of operating and to demand that a standard-based, contractual
    communication channel was used. Disapproved by the customer, the EDM provider
    had no choice but to implement, at its own cost, support for the CMIS standard
    in its product.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终使用了标准操作中的几个操作（在第一步中，我们只需要创建文档，向它们添加元数据和二进制内容，然后通过对其元数据内容的查询检索文档），这花费了我们几周时间才将其添加到我们的应用程序中。客户非常满意，因为对软件的简单定制就能使文档出现在他们的Alfresco或Nuxeo
    EDM系统中，因为这些应用程序是原生CMIS 1.1兼容的。但真正证明这种规范性方法重要性的，是我们第一次遇到一个配备了专有EDM的客户：编辑，一家相当大的公司，在我们的共同客户的信息系统中占有重要地位，希望我们修改我们的应用程序以支持他们的专有网络服务，以便发送文档和元数据。在我们最初拒绝后，情况变得有些紧张，但我们很幸运，信息系统所有者是一个聪明的人，她完全理解低耦合的价值。她明智地询问，如果她必须选择另一个供应商来提供这项服务，一个合作伙伴需要付出多少努力。EDM提供商表示，如果我们的公司被另一家公司取代，他们就不需要做任何事情。就我们公司而言，我解释说——在相反的假设中——我们可能需要重写一些代码以适应另一个专有协议。这对客户来说已经足够了，即使她不是技术专家，也能意识到这种操作方式有问题，并要求使用基于标准的、合同式的通信渠道。由于客户的反对，EDM提供商别无选择，只能在自己的成本下在其产品中实现对CMIS标准的支持。
- en: 'This proved a very satisfying experience for many reasons:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这在许多方面都证明是一次非常令人满意的经历：
- en: First, I have to admit that replaying David against Goliath was one of the best
    ego boosts I had in my career.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我必须承认，重新演绎大卫对抗歌利亚是我职业生涯中最令人自豪的时刻之一。
- en: Second, we went out of the meeting without having anything to add to our software,
    since it was already CMIS-ready.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们没有在会议中添加任何东西到我们的软件中，因为它已经准备好支持CMIS。
- en: Third, the customer appreciated our expertise in helping them reach a better,
    more evolutive, system and not trying to push them into a vendor lock-in situation
    as the other *partner* did.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，客户赞赏我们在帮助他们达到更好、更具进化性的系统方面的专业知识，而不是像其他*合作伙伴*那样试图将他们推入供应商锁定的情况。
- en: Fourth, the interop project was technically very easy to lead because we would
    simply provide the partner with a Postman collection of the API calls we needed
    to work and they were able to validate them from the CMIS norm point of view.
    There were no “hidden parameters” in the interop calls, everything was explicit
    and strictly regulated through the OASIS standard. We only had one tweak to add
    in the case of authentication.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，互操作性项目在技术上非常容易领导，因为我们只需向合作伙伴提供我们需要的API调用Postman集合，他们就能从CMIS规范的角度验证它们。互操作性调用中没有“隐藏参数”，一切都是明确的，并且严格通过OASIS标准进行规范。我们只需在认证的情况下进行一次调整。
- en: Finally, even the initially reluctant partner admitted at the end of the project
    that this approach helped to avoid the ping-pong effect in the project, where
    both partners reject responsibility for a non-working call to the other, ending
    up in a global loss of time and the customer not being satisfied. And I am truly
    convinced that the CMIS support would open new opportunities for their product
    further down the line.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，即使最初不愿意的合作伙伴也承认，在项目结束时，这种方法有助于避免项目中的乒乓效应，即双方都拒绝对对方的非工作调用承担责任，最终导致时间全球损失，客户不满意。我真正相信CMIS支持将为他们的产品在未来的某个时候开辟新的机会。
- en: Keeping complete compatibility
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持完全兼容性
- en: 'All this sounds like a beautiful dream, with pink unicorns and rainbows everywhere,
    but having great APIs using international standards and norms does not prevent
    one last danger in interop. Actually, it is quite the reverse, and the cleaner
    and more usable an API is, the bigger this danger is. Sounds weird, doesn’t it?
    Welcome to Hyrum’s Law ([https://www.hyrumslaw.com/](https://www.hyrumslaw.com/)),
    which states the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来像是一个美丽的梦想，到处都是粉红色的独角兽和彩虹，但使用国际标准和规范构建的伟大API并不能防止互操作性中的最后一种危险。实际上，情况正好相反，API越干净、越易用，这种危险就越大。听起来很奇怪，不是吗？欢迎来到Hyrum定律([https://www.hyrumslaw.com/](https://www.hyrumslaw.com/))，它陈述了以下内容：
- en: With a sufficient number of users of an API,
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个API有足够多的用户的情况下，
- en: 'it does not matter what you promise in the contract:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在合同中承诺了什么：
- en: all observable behaviors of your system
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您系统的所有可观察行为
- en: will be depended on by somebody.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有人依赖。
- en: The more successful your API gets, the more important forward compatibility
    becomes as it is impossible to break the uses of many clients. But after all,
    this is just the flip side of success and not a bad price to pay if your API is
    the most used in your context, which ensures a large market share and notable
    income. Hyrum’s Law is harsher because even some parts of the API that you have
    no formal engagement with will become things that get you into trouble. A sudden
    change in performance, for example, might make it impossible for one of your biggest
    customers to continue working with your API. Even a smaller, non-contractual,
    modification may get you into this kind of trouble. You know what? Even removing
    a bug might make some of your API users unhappy because—in some twisted way—their
    system depended on this particular behavior to operate. That may sound silly but
    it occurs more widely than you may imagine. After all, it is very common that
    some API users consume response attributes by their order instead of their identifier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API越成功，向前兼容性就越重要，因为不可能打破许多客户端的使用。但毕竟，这只是成功的一面，如果你的API在你的环境中是最常用的，这确保了很大的市场份额和显著的收入，这并不是一个坏价格。Hyrum定律更为严厉，因为即使是你没有正式承诺的API的一些部分，也可能成为让你陷入麻烦的事情。例如，性能的突然变化可能会使你的最大客户无法继续使用你的API。即使是较小的、非合同的修改也可能让你陷入这种麻烦。你知道吗？即使是移除一个错误，也可能让一些API用户不满意，因为——以一种扭曲的方式——他们的系统依赖于这种特定的行为来运行。这听起来可能很荒谬，但它比你想象的要普遍得多。毕竟，一些API用户按照它们的顺序而不是它们的标识符来消费响应属性是非常常见的。
- en: 'To a certain extent, Hyrum’s Law can be considered as the API equivalent to
    the Liskhov substitution principle in object-oriented programming: even if a class
    can replace another one by implementing the same interface, if its behavior is
    not the same when the function calls have the same parameter values, then actual
    compatibility (and thus substitutability) is not achieved.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，Hyrum定律可以被认为是面向对象编程中Liskov替换原则的API等价物：即使一个类可以通过实现相同的接口来替换另一个类，但如果在函数调用具有相同的参数值时其行为不同，那么实际的兼容性（以及因此的可替换性）并未实现。
- en: Managing APIs
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理API
- en: Even if this is more of an operational concern, managing a number of APIs, with
    all the authorization access issues, logging, and possibly invoicing for API consumption,
    follow-up of versions, and so on can make for a tough challenge. Some dedicated
    software products exist for this under the common name of *API gateways*. They
    generally are implemented in the form of reverse proxies that act as a frontal
    server, hiding the actual API expositions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这更多的是一个操作问题，管理大量的API，包括所有授权访问问题、日志记录，以及可能对API消费进行计费、版本跟踪等问题，可能会构成一个严峻的挑战。一些专门的软件产品存在，通常被称为*API网关*。它们通常以反向代理的形式实现，充当前端服务器，隐藏实际的API暴露。
- en: Depending on whether you need a very low-coupled system or a very integrated
    one, you could respectively use systems such as WSO² or Ocelot (in the case of
    an ASP.NET implementation of your API system).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您是否需要一个低耦合的系统或一个非常集成的系统，您可以使用WSO²或Ocelot（如果您使用ASP.NET实现API系统）等系统。
- en: Inversion of dependency for services
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务依赖反转
- en: 'If you remember the following schema from the previous chapter, you will recall
    that a port and adapter pattern is used in order for the satellite modules to
    depend on the main one that implements the business domain model, even if the
    calls come from the latter and go to the former:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章中的以下架构，你会回想起为了使卫星模块依赖于实现业务领域模型的主体模块，即使调用来自后者并前往前者，使用了端口和适配器模式：
- en: '![Figure 8.10 – Hexagonal architecture](img/B21293_08_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 六角架构](img/B21293_08_10.jpg)'
- en: Figure 8.10 – Hexagonal architecture
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 六角架构
- en: This is simply the principle of dependency inversion applied to architecture,
    with the description of a conventional interface being called by one module, without
    knowing what implementation is used behind this interface. In **Object-Oriented
    Programming (OOP)** code, this is generally done by object injection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是依赖倒置原则在架构中的应用，描述一个传统接口被一个模块调用，而无需知道这个接口背后使用了什么实现。在**面向对象编程（OOP）**的代码中，这通常是通过对象注入来实现的。
- en: In service-oriented systems, and in particular, when using web APIs, the indirection
    level is done by the URL that the caller uses without knowing what is behind it.
    If having a dependency on this module is not a problem, then the call can be direct.
    But if the business domain module calls an API, a direct dependency is not a good
    idea for evolution and a way has got to be found in order to reverse the dependency.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向服务的系统中，尤其是在使用Web API时，间接层是通过调用者使用的URL来完成的，而无需知道其背后是什么。如果对这个模块的依赖不是问题，那么调用可以是直接的。但如果业务领域模块调用API，直接的依赖对于演化和找到反转依赖的方法来说并不是一个好的主意。
- en: 'This is generally done by using some kind of callback mechanism, where the
    domain model module is instructed from the outside (the dependency, in our case)
    with the URL it should call, possibly in its customization but also in the runtime
    initialization steps. In the first explanation of the preceding webhooks, this
    is what happened when the town needed a change of filter on the events the regional
    council should take into account for informing the town: it would not be normal
    for the regional council to depend on the town, since the town is the functional
    requester of the information. This is why the best way for the town to provide
    the callback URL to the regional council is by registering for the events, possibly
    through a `/``subscribe` API.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过使用某种回调机制来完成的，其中领域模型模块从外部（在我们的例子中是依赖）被指示调用它应该调用的URL，可能在其定制中，也可能在运行时初始化步骤中。在前面的webhooks的第一种解释中，这就是当城镇需要更改区域委员会应考虑通知城镇的事件过滤器时发生的情况：区域委员会依赖于城镇是不正常的，因为城镇是信息功能请求者。这就是为什么城镇向区域委员会提供回调URL的最佳方式是通过注册事件，可能通过`/subscribe`
    API来实现。
- en: 'This way, we reach a nice separation of responsibilities, as the regional council
    is responsible for the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就达到了一个很好的责任分离，因为地区议会负责以下事项：
- en: Exposing an API that allows clients to create, modify, and remove organizations
    from the data referential service’s persistence mechanism
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露一个API，允许客户端从数据参照服务的持久化机制中创建、修改和删除组织
- en: Exposing an API that allows clients (possibly other ones, possible the same
    ones) to register for events on organizations
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露一个API，允许客户端（可能是其他客户端，也可能是相同的客户端）在组织中注册事件
- en: Calling the URL provided by these clients upon registration whenever the event
    appears in the code
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当代码中出现事件时，在注册时调用这些客户端提供的URL
- en: Applying the filter provided upon registration to only emit requested events
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册时应用提供的过滤器，仅发射请求的事件
- en: 'On the other end, the town is responsible for the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，城镇负责以下事项：
- en: Registering on the organization referential for the events it needs to observe
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组织参照系上注册它需要观察的事件
- en: Providing a URL for callbacks that is reachable, and points to the necessary
    implementation
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个可访问的回调URL，并指向必要的实现
- en: 'When this kind of event-based mechanism is used for every interaction to provide
    a very low degree of coupling, the jargon term is **Event-Driven Architecture**
    (**EDA**). In its most advanced form, EDA adds lots of very precisely defined
    responsibilities to allow for the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种基于事件机制的机制用于每次交互以提供非常低的耦合度时，术语是**事件驱动架构**（**EDA**）。在其最先进的形式中，EDA添加了许多非常精确定义的责任，以允许以下操作：
- en: Different authentication and authorization methods for the registration and
    emission mechanisms
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的注册和发射机制认证和授权方法
- en: Management of robustness of delivery by reapplying the calls if necessary and,
    if needed, warning an administrator that, after a certain amount of tries, the
    event has been stored for later emission to certain registered clients
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在必要时重新应用调用并，如果需要，警告管理员，在尝试了一定次数后，事件已被存储以供稍后向某些已注册客户端发射
- en: Handling high volumes of events
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大量事件
- en: Handling large numbers of registered clients
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大量已注册客户端
- en: Service-level agreement management, among many other features
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务级别协议管理，以及其他许多功能
- en: In its correct implementation, an EDA-based system is the most accomplished
    outcome of decoupling in software systems, allowing for a completely transparent
    evolution of the different modules and linear performance. But despite its long
    theoretical existence, there are very few actual implementations of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确的实现中，基于EDA的系统是软件系统中解耦的最成功成果，允许不同模块完全透明的演变和线性性能。但尽管它在理论上有很长的存在，实际实现却非常少。
- en: Now that the notion of *service* has been presented and studied from various
    points of view, we are going to return to our sample information system and apply
    this new knowledge to it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经从不同的角度介绍了并研究了“服务”的概念，我们将回到我们的示例信息系统，并将这些新知识应用到它上面。
- en: Application to our demonstration system
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用到我们的演示系统中
- en: Now that the notion of *service* should hold any secrets for you, it is time
    to see some practical applications of what we have covered on our demonstration
    system to reinforce the takeaways from this chapter. Since we aim at something
    modern, the choice is quite obvious that the different modules of the example
    system will interact with each other through REST APIs. As much as possible, we
    will try to keep the middleware as transparent as we can. We may need some connectors
    for mediation in some cases, but other than that, applications will talk to centralized
    APIs that will then be implemented separately (this will be done using the concept
    of service in the container orchestrator that will be put in place).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该对“服务”的概念不再有任何秘密，是时候看看我们在演示系统中涵盖的一些实际应用，以加强本章的收获。鉴于我们追求的是现代的，选择显然是示例系统的不同模块将通过REST
    API相互交互。尽可能保持中间件尽可能透明。在某些情况下，我们可能需要一些连接器来进行调解，但除此之外，应用程序将与其他集中式API进行通信，这些API将单独实现（这将通过容器编排器中将要实施的服务概念来完成）。
- en: Interfaces needing analysis
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要分析的接口
- en: First, we will start with a hexagonal architecture diagram to list all the business
    domain models and their dependencies. The C4 approach used in the previous chapter
    showed that we will need at least three business domains, namely books, authors,
    and sales.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从六角架构图开始，列出所有业务域模型及其依赖关系。上一章中使用的C4方法表明，我们需要至少三个业务域，即书籍、作者和销售。
- en: 'If we concentrate on books, for example, the dependencies are the persistence
    mechanism, the authors cache module, the books’ GUI system, the books’ API controller,
    and some technical satellites such as logging, and identity and authorization
    management. This can be schematized as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们专注于书籍，那么依赖关系包括持久化机制、作者缓存模块、书籍的GUI系统、书籍的API控制器，以及一些技术卫星，如日志记录、身份和授权管理。这可以概括如下：
- en: '![Figure 8.11 – An example of hexagonal architecture](img/B21293_08_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 六角架构的示例](img/B21293_08_11.jpg)'
- en: Figure 8.11 – An example of hexagonal architecture
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 六角架构的示例
- en: In terms of the Agile approach, I am not saying that this contains all the interfaces
    that will be present at the end of our journey together. But in order to keep
    this exercise as realistic as possible, I am creating the sample information system
    at the same time as I write the book, in order not to leave anything hidden and
    so that you can follow the precise method of design that I recommend, and that
    I of course try to follow myself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷方法方面，我并不是说这包含了我们旅程结束时将出现的所有接口。但为了使这个练习尽可能真实，我在写书的同时创建了这个示例信息系统，这样就不会有任何东西被隐藏起来，并且你可以跟随我推荐的精确设计方法，当然我也尽力遵循。
- en: So, now that the first interfaces have been listed, we need to be a bit more
    precise than just a name. What are they going to do? How will they be designed
    to provide for clean, future-proof usage? Most importantly, how are these choices
    going to reflect the business/IT alignment principles that I have pushed forward
    since the first chapters?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经列出了第一个接口，我们需要比仅仅一个名称更精确一些。它们将要做什么？它们将如何设计以提供干净、未来兼容的使用？最重要的是，这些选择将如何反映我从第一章开始就推动的业务/IT对齐原则？
- en: Using norms and standards
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用规范和标准
- en: Since I have spoken so much about the crucial importance of norms and standards,
    it would have been a terrible signal not to start with them for the precise definition
    of the interfaces. And describing more precisely the interfaces we talked about
    in the previous section is as easy as can be when we use a standard because we
    simply need to name it (and possibly cite the version of it that will be used)
    and all the operations, formats, semantics, and other functions of the standard
    are immediately clearly defined through the documentation of the standard.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我已经谈了很多关于规范和标准至关重要的内容，如果不从它们开始，就无法精确定义接口，那将是一个可怕的信号。而且，当我们使用标准时，精确描述我们在上一节中讨论的接口是非常容易的，因为我们只需要命名它（并且可能引用将要使用的版本）并且所有标准的功能、格式、语义和其他操作都通过标准的文档立即明确定义。
- en: For example, let’s start with the authentication and identification service.
    For this particular interface, we will use the OpenID Connect protocol, based
    on OAuth 2.0 (RFC 6749) and using JSON Web Tokens (RFC 7519), the JWT profile
    for OAuth 2.0 itself being standardized (RFC 7523). Again, the great thing about
    norms and standards is that they greatly simplify our work. If I had to describe
    with the same degree of precision the use of an interface without a standard,
    this chapter would be extra long. For this service, citing a few RFCs (and of
    course, in the next chapters, using good implementations of these norms) is enough
    to make everything explicit.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们从认证和识别服务开始。对于这个特定的接口，我们将使用基于OAuth 2.0（RFC 6749）和JSON Web Tokens（RFC 7519）的OpenID
    Connect协议，OAuth 2.0本身的JWT配置文件是标准化的（RFC 7523）。再次强调，规范和标准的好处是它们极大地简化了我们的工作。如果我要用同样的精确度描述没有标准的接口使用，那么这一章将会更长。对于这个服务，引用几个RFC（当然，在下一章中，使用这些规范的优秀实现）就足以使一切变得明确。
- en: How about the database interface or, to be more precise, the persistence interface?
    The decision is to use a NoSQL document-based approach since it sounds the most
    adapted to the business entities we talked about and the volumetry we want to
    address. It may not be a very well-known fact about MongoDB, but most protocols
    used are open standards, and are, in fact, used by many other NoSQL database implementations.
    If you want to improve on your local MongoDB database, all you need to do to switch
    to an Atlas service or an Azure CosmosDB instance is to change the connection
    string, as everything works the same. The MongoDB Wire Protocol Specification
    is licensed under a Creative Commons *Attribution-NonCommercial-ShareAlike 3.0*
    license. The BSON format ([https://bsonspec.org/#/specification](https://bsonspec.org/#/specification))
    used is documented openly and can be implemented by any software. And the list
    goes on. In addition to the appropriate adaptation of the software to our needs
    and the fact it is easy to create a free database, the standardized aspect is
    the cherry on top that makes MongoDB a sound choice for our sample application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那么数据库接口呢，或者更准确地说，持久化接口呢？决定使用一个NoSQL文档型方法，因为它听起来最适应我们讨论的业务实体和我们要处理的数据量。关于MongoDB可能不是一个非常知名的事实，但大多数使用的协议都是开放标准，实际上也被许多其他NoSQL数据库实现所使用。如果你想要改进你本地的MongoDB数据库，你只需要更改连接字符串即可切换到Atlas服务或Azure
    CosmosDB实例，因为一切工作方式都是相同的。MongoDB Wire Protocol规范是在Creative Commons *Attribution-NonCommercial-ShareAlike
    3.0*许可下发布的。使用的BSON格式([https://bsonspec.org/#/specification](https://bsonspec.org/#/specification))是公开文档化的，并且可以被任何软件实现。还有更多。除了对软件进行适当的适应以满足我们的需求，以及它易于创建免费数据库的事实之外，标准化方面是使MongoDB成为我们示例应用程序的一个合理选择的关键。
- en: OK, now on to authorizations! There happens to exist two main norms around software
    authorization management, namely `admin` role has all rights, the `operator` can
    read and write entities based on a portfolio, and the `reader` role can only read
    data, for example), then using OPA would not be the right choice, as it would
    add lots of overhead. Of course, the real question, again, is to take time into
    account. Of course, by the end of the book, our sample application will be so
    simple that using OPA would be over-dimensioning. However the goal of this exercise
    is to show how to work if we aim at a real, industrial, freely evolving information
    system. And since we operate under the hypothesis that rights management is going
    to be more complicated, then we will start right away with the adapted interface,
    which means OPA 1.0 in our case.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在转到授权问题！在软件授权管理方面存在两个主要规范，即`admin`角色拥有所有权限，`operator`可以根据投资组合读取和写入实体，而`reader`角色只能读取数据（例如）。然后，使用OPA可能不是正确的选择，因为它会添加很多开销。当然，真正的疑问，再次，是考虑时间。当然，到本书结束时，我们的示例应用程序将非常简单，使用OPA将是过度设计。然而，这个练习的目标是展示如果我们旨在一个真实、工业、自由发展的信息系统，我们应该如何工作。鉴于我们假设权利管理将会更复杂，我们将立即开始使用适应的接口，在我们的情况下意味着OPA
    1.0。
- en: The logging feature is a bit of a different situation because this is not something
    directly functional, but rather a technical feature. However this does not mean
    that the same approach of standardization should not be used. The only difference
    is that this level of indirection will not be standardized at the international
    level as with other norms, but rather locally to the platform. Our sample application
    being implemented mostly uses .NET Core, so we will use whatever is standard for
    this technology, and there happens to be a standard global interface in `Microsoft.Extensions.Logging`
    called `ILogger`, which exists also as a generic class `ILogger<T>`. We will return
    in the technical chapters to see how to use it and maybe we will even spice it
    up by using a semantic logging system such as Serilog. But for now, suffice it
    to say that the logging mechanism will be standardized as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 记录功能的情况有些不同，因为这并不是一个直接的功能，而是一个技术特性。然而，这并不意味着不应该使用相同的标准化方法。唯一的区别是，这种间接级别不会像其他规范那样在国际层面上标准化，而是将在平台上本地化。我们的示例应用程序主要使用.NET
    Core，因此我们将使用该技术的标准，而恰好有一个标准全局接口在`Microsoft.Extensions.Logging`中，称为`ILogger`，它也存在一个泛型类`ILogger<T>`。我们将在技术章节中返回来看如何使用它，也许我们甚至会通过使用像Serilog这样的语义日志系统来增加一些趣味。但就目前而言，只需说日志机制也将得到标准化即可。
- en: It is worth noting that some players in the field currently work towards a first
    level of standardization, such as Elastic with the ECS specification (see [https://www.elastic.co/guide/en/ecs/current/ecs-reference.html](https://www.elastic.co/guide/en/ecs/current/ecs-reference.html)
    for details). As Elastic is one of the major publishers of observation platforms
    and the specification is open source, we can place some hope in the spreading
    of this as a standard, although only time will tell.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，该领域的某些参与者目前正在努力实现第一级标准化，例如Elastic的ECS规范（详情请见[https://www.elastic.co/guide/en/ecs/current/ecs-reference.html](https://www.elastic.co/guide/en/ecs/current/ecs-reference.html)）。由于Elastic是观察平台的主要出版商之一，且该规范是开源的，我们可以对它作为标准的传播抱有一定的希望，尽管只有时间才能证明一切。
- en: Where do I find norms and standards?
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我在哪里可以找到规范和标准？
- en: 'When I teach or consult about business/IT alignment and in particular about
    this need to refer to norms and standards, the same question always comes up at
    some point: *How do we search for norms?* I should say that I am really astonished
    by this question, and for several reasons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我教授或咨询关于业务/IT一致性，特别是关于需要参考规范和标准的问题时，这个问题总是在某个时候出现：*我们该如何搜索规范？* 我必须说，我对这个问题感到非常惊讶，原因有几个：
- en: Finding them is as easy as any internet search and virtually all of them are
    public, with the need to be as visible as possible in order to achieve their goals,
    so there is absolutely no technical difficulty in finding them. It shows that
    most people working in the IT industry (and with the number of people I have trained
    or taught, I do have significant statistics) are ignorant of the standards of
    their industry, which is quite annoying. I can understand that not a lot of people
    know BPMN 2.0, for example, as processes are a specific use case, and not all
    applications need a workflow engine. But how can some architects not know about
    OAuth 2.0, since this is used almost everywhere on the internet and almost all
    software applications need some kind of authentication at some point?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找它们就像任何互联网搜索一样简单，几乎所有这些规范都是公开的，为了实现它们的目标，需要尽可能的可见，因此找到它们在技术上绝对没有任何困难。这表明，大多数在IT行业工作的人（根据我培训或教授的人数，我确实有一些显著的统计数据）对自己的行业标准一无所知，这相当令人烦恼。我可以理解，不是很多人知道BPMN
    2.0，因为流程是一个特定的用例，并不是所有应用程序都需要工作流引擎。但为什么一些架构师不知道OAuth 2.0，因为这在互联网上几乎无处不在，几乎所有软件应用程序在某个时候都需要某种形式的身份验证？
- en: Even some people outside of the profession know some of the most identified
    providers of norms and standards, such as ISO or IETF. Even just the term **Request
    For Comments (RFC)** is understood by many people. Granted, some IT-specific organizations
    producing norms, such as OASIS, are lesser known. But then again, the **World
    Wide Web Consortium** (**W3C**) is a very active and recognized institution. So
    how come people asking this question do not have the reflex to start with these
    organizations and search them for what they need?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使一些非专业人士也知道一些最著名的规范和标准提供者，例如ISO或IETF。甚至**请求评论（RFC）**这个术语也被很多人所理解。当然，一些生产规范的IT特定组织，如OASIS，可能不太为人所知。但另一方面，**万维网联盟（W3C）**是一个非常活跃且被广泛认可的机构。那么，为什么问这个问题的人没有本能地从这些组织开始，搜索他们所需的内容呢？
- en: 'For some customers, I even created a whitepaper at some point with almost a
    hundred norms and standards used in the business context I was working in at the
    time (public and government organizations) because this question came back all
    the time and I wanted to have a quick answer, not only telling them where to find
    what they needed, but providing them with the answers already found for them.
    This is for a simple reason: because I found out that the real issue was not that
    these people did not know “where to find the norm,” but because it indicated doubts
    in their ability to use them. Norms and standards can be a bit intimidating with
    their hundreds of pages explaining all the possible cases. Even simple RFCs are
    indeed not easy to read.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些客户，我在某个时候甚至创建了一份白皮书，其中包含了我在当时工作的业务环境中（公共和政府机构）使用的近一百个规范和标准，因为这个问题总是反复出现，我希望有一个快速的答案，不仅告诉他们在哪里可以找到他们需要的东西，还提供给他们已经找到的答案。这有一个简单的原因：因为我发现真正的问题不是这些人不知道“在哪里可以找到规范”，而是这表明了他们对使用这些规范的能力存在疑虑。规范和标准可能因为数百页解释所有可能情况而显得有些令人畏惧。即使是简单的RFC也确实不易阅读。
- en: 'But there are other answers to this as well:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个问题也有其他答案：
- en: First, finding the right norm and starting to use it does not require you to
    read the norm specification. In fact, only if you need to implement large parts
    of it will you gain a benefit from reading it.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，找到合适的规范并开始使用它并不需要你阅读规范说明。实际上，只有当你需要实现其中大部分内容时，阅读它才会对你有益。
- en: In most cases, you will use components that implement the norm and all you have
    to do is check that they are recognized, well-established modules.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会使用实现规范的组件，你所要做的就是确认它们是被认可、已经建立起来的模块。
- en: For example, in order to use OpenID Connect in our sample information system,
    we will basically need to know nothing about the protocol itself since we will
    rely on Apache Keycloak, which implements it in a transparent way for us. All
    we have to deal with is the choice of identity provider and some customizations
    made easy by the Keycloak GUI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了在我们的示例信息系统中使用OpenID Connect，我们基本上不需要了解该协议本身，因为我们将依赖Apache Keycloak，它以透明的方式为我们实现它。我们唯一需要处理的是选择身份提供者以及Keycloak
    GUI简化的一些自定义设置。
- en: Even if you have to dive into the details of the norms, most of the time, you
    will only need to understand a very small portion of them. For example, in our
    sample application, we will certainly need at some point to implement some kind
    of support for binary documents for authors’ contracts; which means we will of
    course use CMIS 1.1 since this is the recognized standard for this use case. But
    as we will only send documents, add binaries and metadata, and query documents
    in return, we may only use 10% of the whole norm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你必须深入研究规范的细节，大多数时候，你只需要理解其中的一小部分。例如，在我们的示例应用程序中，我们将在某个时候肯定需要实现某种对作者合同二进制文档的支持；这意味着我们当然会使用CMIS
    1.1，因为这是这个用例的公认标准。但因为我们只会发送文档，添加二进制和元数据，并查询文档作为回报，我们可能只使用整个规范中的10%。
- en: 'Finally, a good norm is normally quite spread out and used internationally
    already. So, reading the full-blown specification is always an interesting read
    but let’s be honest: the way you will be exposed to the standards in the first
    steps is simply by mimicking some sample calls that you will find on reference
    websites and adapt to your needs. Only if you reach a certain level of complexity
    will it be easier at some point to find the exact nitty-gritty detail of implementation
    in the full text of the RFC.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个好的规范通常已经相当广泛地传播并在国际上使用。所以，阅读完整的规范说明总是很有趣的，但让我们说实话：你在最初接触标准的方式主要是通过模仿在参考网站上找到的一些示例调用，并根据你的需求进行调整。只有当你达到一定程度的复杂性时，在RFC的全文中找到实施细节的精确细节才会变得容易一些。
- en: Pivotal format for the other interfaces
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于其他接口的关键格式
- en: 'And for the last part of this subject, the next question that arises is, logically:
    *What do we do when there is no norm or standard for* *our context?*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个主题的最后一部分，接下来出现的逻辑问题是：*当我们的环境中没有规范或标准时，我们该怎么办？*
- en: My first reflexive reply to this question is always, “*Are you willing to bet
    that there is indeed no norm I can show you on this?”* Most of the time, this
    question goes back to the previous one and just shows that the person asking it
    is simply not comfortable with norms, or is afraid as they think it is going to
    be difficult (where in reality, on the contrary, norms free you from all the difficult
    design aspects). Because, let’s face it, we have norms for virtually everything
    today. All right, there may be fewer norms in IT than in the mechanical domain.
    But there are standards for every common feature. You have norms for all generic
    techniques, norms for every entity used in international data transfers, and for
    every common human activity including banking, insurance, travel, and so on. You
    even have an ISO-Gender norm (ISO/CEI 5218) for representing human genders in
    numeric format.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我总是首先本能地回答，“*你愿意打赌确实没有我可以向你展示的规范吗？*” 大多数时候，这个问题会回到之前的问题，只是表明提问者对规范感到不舒服，或者他们害怕这会很难（但实际上，规范反而让你摆脱了所有困难的设计方面）。因为，让我们面对现实，今天我们几乎为所有事情都有规范。好吧，在IT领域可能比机械领域少一些规范。但是，对于每个常见功能都有标准。你有一套通用的技术规范，用于国际数据传输中使用的每个实体，以及包括银行、保险、旅行等在内的每个常见的人类活动。甚至还有一个ISO-Gender规范（ISO/CEI
    5218），用于以数字格式表示人类性别。
- en: 'The second part of the answer concerns what we should do when there is indeed
    no applicable norm for your context. And the answer to this has already been given
    a bit earlier in this chapter: you then create what is called a **pivotal format**,
    which has the same goal of standardization as a real norm, but limited to your
    own context. Of course, it is always better to aim at something universal. Not
    only because, you never know, but your format may become a norm if you put enough
    effort into it and other people have an interest in it (this is the way norms
    appear: it always starts with the effort of an individual who knows the business
    domain extremely well and makes the effort to transcribe their knowledge into
    something technical, which is then agreed upon by other participants as a sound
    basis for exchanges). But also because aiming at something universal will make
    your pivotal format as close to a norm as possible, with as many resulting advantages
    as possible.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 答案的第二个部分涉及当确实没有适用于你所在环境的规范时我们应该做什么。对这个问题的答案已经在本章中给出了一部分：然后你创建一个被称为**关键格式**的东西，它具有与真实规范相同的标准化目标，但仅限于你自己的环境。当然，目标是追求普遍性总是更好的。不仅因为，你永远不知道，但如果你投入足够的努力，并且其他人对此感兴趣，你的格式可能会成为规范（这是规范出现的方式：它总是从对业务领域极其了解的个人开始，他们努力将他们的知识转化为技术性的东西，然后其他参与者将其作为交换的合理基础达成一致）。而且因为追求普遍性将使你的关键格式尽可能接近规范，并带来尽可能多的优势。
- en: 'And the rule for this is to fall back on existing norms as quickly as possible.
    Sure, there does not seem to exist an international norm for the concept of authoring
    (though the Dublin Core `creator` attribute allows us to draw a link between a
    resource and the person or organization that authored this resource), but since
    it points to individual persons, lots of other related norms will quickly apply,
    such as Social Security Numbers for unique identification, ISO 8601 for the date
    of authoring, and so on. The same applies to books: of course, we may not find
    the perfect standard to precisely address what we need for our sample application,
    and in particular its persistence system, but there are nonetheless norms for
    languages (ISO 639), internationally-recognized standard codes for registered
    book identification such as **International Standard Book Numbers (ISBNs)**, and
    standards for virtually everything we will set out to record in the descriptions
    of the books in our system.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，规则是尽可能快地回归到现有的规范。当然，似乎不存在一个关于作者概念的国际化规范（尽管都柏林核心的`creator`属性允许我们从一个资源到创建该资源的个人或组织之间建立联系），但因为它指向个人，所以许多其他相关的规范会迅速适用，例如社会保险号码用于唯一标识，ISO
    8601用于创作日期，等等。同样的情况也适用于书籍：当然，我们可能找不到一个完美的标准来精确地满足我们样本应用的需求，特别是其持久化系统，但尽管如此，还是有关于语言的规范（ISO
    639），以及用于注册书籍识别的国际公认标准代码，如**国际标准书号（ISBNs）**，以及我们将在系统中记录的书籍描述中几乎一切事物的标准。
- en: Now, the real question is what to put in the book and author’s pivotal format?
    And this is such a huge question that it will necessitate a chapter on its own.
    The good news is that the following chapter will explain how to answer this.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的问题是什么应该放入书中以及作者的关键格式？这是一个如此重大的问题，以至于需要单独用一章来阐述。好消息是，下一章将解释如何回答这个问题。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I have used a short historical approach (a detailed one would
    be a book in itself) to explain what the stakes at play are in service orientation
    and how this seemingly simple yet hard-to-define word of *service* has been implemented
    in the past decades. We are definitely not at the end of the story yet, but nowadays,
    it seems the best approach is to use REST APIs with a middleware, reduced as much
    as possible through the use of norms and standards. This not only avoids the costly
    mediation connectors that translate one format to another, since everybody in
    the interaction talks the same language but also helps us know whether our design
    is the right one since consortiums and experts have thought a lot about this business
    domain.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我采用了简短的历史方法（详细的方法本身就可以写成一本书）来解释在面向服务中涉及的风险是什么，以及这个看似简单却难以定义的“服务”一词在过去几十年是如何被实施的。我们肯定还没有到达故事的结尾，但如今，似乎最好的方法就是使用带有中间件的REST
    API，尽可能通过使用规范和标准来减少。这不仅避免了昂贵的转换连接器，因为互动中的每个人都使用同一种语言，而且还帮助我们了解我们的设计是否正确，因为联盟和专家已经对这个业务领域进行了很多思考。
- en: Standardized APIs are what make it easy today to change some parts of important
    information systems without breaking them. They allow for international banking,
    much more efficient insurance systems, simplified travel abroad, and many other
    feats of the industrialized IT world.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化的API使得今天在不破坏它们的情况下改变重要信息系统的一些部分变得容易。它们允许进行国际银行业务、更高效的保险系统、简化出国旅行，以及许多工业IT世界的成就。
- en: 'We talked about norms, but also compatibility, the evolution of services, how
    services will be integrated through interfaces, and much more. By the end of this
    chapter, we came back to our sample application and showed which norms would be
    used to implement a few of the services it will expose. Now a difficult question
    remains: when there is no standard format for a business need and we need to create
    a pivotal format (of course, using norms as much as possible for its inner attributes),
    how do we determine the content of this format? The best answer I have is to use
    **Domain-Driven Design** (**DDD**). And this is the subject of the next chapter.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了规范，还讨论了兼容性、服务的演变、服务将通过接口如何集成，以及更多内容。到本章结束时，我们回到了我们的示例应用程序，并展示了将用于实现它将公开的一些服务的规范。现在，一个难题仍然存在：当没有针对商业需求的标准化格式，而我们又需要创建一个关键的格式（当然，尽可能使用规范来定义其内部属性）时，我们如何确定这个格式的内容？我给出的最佳答案是使用**领域驱动设计**（**DDD**）。这正是下一章的主题。
