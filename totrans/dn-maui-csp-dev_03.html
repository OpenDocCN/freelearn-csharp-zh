<html><head></head><body>
		<div><h1 id="_idParaDest-37" class="chapter-number"><a id="_idTextAnchor036"/>3</h1>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>XAML and Fluent C#</h1>
			<p>In this chapter, we will look at how .NET MAUI applications are created using a markup language for the user interface and C# for all the logic.</p>
			<p>.NET MAUI programs are (typically) written in two languages. One is C#, which is used for all the logic, and the other is <strong class="bold">XAML</strong> (pronounced <em class="italic">zamel</em>, to rhyme with camel), which is used for the layout and creation of controls. As you’ll see, the use of XAML is optional. You can create your layout and controls all in C#, but most people don’t. However, that may be changing (more and more of the Microsoft Learn documentation shows both ways).</p>
			<p class="callout-heading">When might you choose to use C#?</p>
			<p class="callout">There are a few reasons to use C# instead of XAML, not least that you know C# and don’t want to bother learning XAML. If you do this, however, you’ll find it difficult to read other people’s code, as most existing <code>Xamarin.Forms</code> (the precursor to .NET MAUI) apps are written with XAML.</p>
			<p class="callout">Using C# can assist in those situations where the design should change based on some condition (such as the type of data you get at runtime). But there are other ways to handle that with XAML as explained in <a href="B19723_11.xhtml#_idTextAnchor216"><em class="italic">Chapter 11</em></a>, <em class="italic">Advanced Topics</em>.</p>
			<p class="callout">This book will show C# for some pages, but the focus will be on XAML.</p>
			<p>All of the Microsoft documentation is at least in XAML; only some is in C# and some is in Fluent C# (a topic we’ll take up later in this chapter). Nearly all <strong class="bold">Xamarin.Forms</strong> applications and samples use XAML and, for that reason alone, it is worth learning. More important, XAML is a highly expressive declarative markup language that makes creating layouts and controls if not easy, then at least manageable.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Understanding the structure of XAML</li>
				<li>Code-behind and event handlers</li>
				<li>Exploring the layout options</li>
				<li>Creating the UI in C#</li>
			</ul>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need the following:</p>
			<ul>
				<li>Visual Studio version 17.5 or later (it’s best to update to the latest version)</li>
				<li>The source code covered in this chapter can be found in the GitHub repository: <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp</a></li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Understanding the structure of XAML</h1>
			<p>XAML files have the <code>.xaml</code> extension, for example, <code>MainPage.xaml</code>, in the out-of-the-box program as shown in <a href="B19723_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>. Let’s<a id="_idIndexMarker026"/> examine this file to explore XAML for its layout and declaration of controls.</p>
			<p class="callout-heading">Just an overview</p>
			<p class="callout">This chapter will only scratch the surface of creating XAML layout and controls. <a href="B19723_04.xhtml#_idTextAnchor054"><em class="italic">Chapter 4</em></a> and <a href="B19723_05.xhtml#_idTextAnchor092"><em class="italic">Chapter 5</em></a> will cover the details on controls and layouts, respectively.</p>
			<p>A .NET MAUI page that is written in XAML will have a name in the format <code>MyName.xaml</code>, and associated with that page will be a code-behind page (explained shortly) in the format <code>MyName.xaml.cs</code>.</p>
			<p>At the top of the XAML page is a declaration that this file is, in reality, an XML-type file. That declaration must be at the very top of every <code>.</code><code>xaml</code> file.</p>
			<p>There are different types of <a id="_idIndexMarker027"/>pages (also called views). The most common is <code>ContentPage</code>, and here <code>MainPage</code> is created as <code>ContentPage</code> using this code:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage xmlns="http://schemas.microsoft.com/
  dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
       x:Class="ForgetMeNotDemo.View.MainPage"&gt;</pre>
			<p>As part of the declaration of <code>ContentPage</code>, we identify two namespaces (<code>xmlns</code>). The first namespace is unnamed and is for .NET MAUI itself. The second namespace, named <code>x</code>, is for XAML.</p>
			<p>Finally, the class that this XAML file is part of is <code>ForgetMeNotDemo.View.MainPage</code>.</p>
			<p>The first part (<code>ForgetMeNotDemo.View</code>) is the namespace, and <code>MainPage</code> is the name of the class. The <code>View</code> part is added to indicate the folder under the project.</p>
			<p>Associated with every <code>.xaml</code> page is a code-behind page, as mentioned earlier. It is possible to put the logic of your <a id="_idIndexMarker028"/>program in the code-behind, which is what we will do for this chapter (in the next chapter, we’ll look at an alternative that is better for testing). In any case, there are a few things that must go in the code-behind, as you’ll see in the next section.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>The code-behind file</h2>
			<p>Every XAML file has an associated code-behind page whose name is in the format <code>&lt;pagename&gt;.xaml.cs</code>. Thus, the <a id="_idIndexMarker029"/>code-behind for this page is <code>MainPage.xaml.cs</code>.</p>
			<p>The code-behind file is typically (and correctly) named after the class (that is, the <code>MainPage</code> class will be in <code>MainPage.xaml</code> and <code>MainPage.xaml.cs</code>). The namespace is explicitly declared in the file and should follow the folder structure. Thus, if the namespace is <code>ForgetMeNotDemo</code>/<code>MainPage</code>, then we’d expect <code>MainPage.cs</code> to have the <code>ForGetMeNotDemo</code> namespace:</p>
			<pre class="source-code">
namespace ForgetMeNotDemo.View;
public partial class MainPage : ContentPage</pre>
			<p>Notice that this is a partial class. In .NET MAUI, all UI classes are marked partial. Notice also that the class indicates that it is <code>ContentPage</code>, which is consistent with what we saw in the XAML.</p>
			<p>In addition to defining classes, you can use XAML to create the layout of the page, that is, where things go in relation to one another. XAML provides a number of layout options as described next.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Exploring the layout options</h1>
			<p>Returning to <code>MainPage.xaml</code>, the first thing we see below <code>ContentPage</code> is a <code>ScrollView</code> layout element. This is a <a id="_idIndexMarker030"/>layout that essentially says that anything contained in <code>ScrollView</code> can (surprise!) scroll.</p>
			<p>A layout contains other layouts and controls. It does this just as it’s done in XML, which is with opening and closing tags. Here is the syntax:</p>
			<pre class="source-code">
&lt;ScrollView&gt;
   // … layouts and controls
&lt;/ScrollView&gt;</pre>
			<p>A page can have only one element. Typically, that element is a layout, and since layouts can contain other layouts and controls, an entire hierarchy can be created.</p>
			<p>The top four elements in <code>MainPage.xaml</code> (out of the box) are as foll<a id="_idTextAnchor042"/>ows:</p>
			<pre class="source-code">
&lt;ScrollView&gt;  [1]
     &lt;VerticalStackLayout  [2]
         Spacing="25"
         Padding="30,0"
         VerticalOptions="Center"&gt;
         &lt;Image [3]
             Source="dotnet_bot.png"
             SemanticProperties.Description="Cute dot net
               bot waving hi to you!"
             HeightRequest="200"
             HorizontalOptions="Center" /&gt;
         &lt;Label [4]
             Text="Hello, World!"
             SemanticProperties.HeadingLevel="Level1"
             FontSize="32"
             HorizontalOptions="Center" /&gt;
&lt;/ScrollView&gt;</pre>
			<p class="callout-heading">Why is this code different from what is in the repo?</p>
			<p class="callout">The preceding code is what you get out of the box. In this chapter, we will enhance this code, and the repo reflects the finished version as of the end of the chapter.</p>
			<p>Let’s take this one element at a<a id="_idIndexMarker031"/> time. We’ve already discussed the first element, <code>ScrollView</code>, so let’s start with the next, that is, <code>VerticalStackLayout</code>.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>VerticalStackLayout</h2>
			<p>Inside <code>ScrollView</code> is <code>VerticalStackLayout</code>. As the name implies, this layout holds things stacked one on top <a id="_idIndexMarker032"/>of another. Here, we have defined three properties for <code>VerticalStackLayout</code>: <code>Spacing</code>, <code>Padding</code>, and <code>VerticalOptions</code>. Now, <code>VerticalStackLayout</code> has dozens of properties and methods. We will learn more about this in <a href="B19723_05.xhtml#_idTextAnchor092"><em class="italic">Chapter </em><em class="italic">5</em></a><em class="italic">, Layouts</em>.</p>
			<p><code>Spacing</code> determines the amount of<a id="_idIndexMarker033"/> vertical space there is between each of the contained elements. Here, <code>Spacing</code> is set to <code>25</code> <strong class="bold">device-independent units</strong> (<strong class="bold">DIPs</strong>). Using DIPs means that you can define the size for one device (phone, Windows, and so on) and have it look as you intend on all other devices. At least that’s the theory. As a good friend once said, “In theory, theory and practice are the same. But in practice, they never are.”</p>
			<p>The second property is <code>Padding</code>. This is one of the ways you can control the position and alignment of your controls. The second principal way is with <code>Margins</code>. This tells you the distance from the <a id="_idIndexMarker034"/>nearest other element (or from the edge of the page), whereas <code>Padding</code> tells you the size of the buffer around the current element, as shown in <em class="italic">Figure 3</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_3.1_B19723.jpg" alt="Figure 3.1 – Padding and Margin&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Padding and Margin</p>
			<p><code>Padding</code> is written in the format <em class="italic">left</em>, <em class="italic">top</em>, <em class="italic">right</em>, <em class="italic">bottom</em>. A <code>Padding</code> value of (<code>20</code>,<code>10</code>,<code>5</code>,<code>0</code>) would <a id="_idIndexMarker035"/>have a padding on the left of <code>20</code> DIPs, <code>10</code> on the top, <code>5</code> on the right, and no DIPs on the bottom. If the top and bottom are the same, they can be combined. The same is true for the right and left. Thus, as we have here, <code>Padding = "30,0"</code>, which means that the left and right will have a padding of <code>30</code> but there will be no padding on the top and bottom.</p>
			<p>The final property in <code>VerticalStackLayout</code> is <code>VerticalOptions</code>, which indicates where to place <code>VerticalStackLayout</code> with respect to its container (in this case, <code>ScrollView</code>). The options for this are based on an enumeration:</p>
			<ul>
				<li><em class="italic">Center</em></li>
				<li><em class="italic">End</em></li>
				<li><em class="italic">Fill</em></li>
				<li><em class="italic">Start</em></li>
			</ul>
			<p>This enumeration is used with a number of different layouts and controls. For now, it is enough to know that <em class="italic">Start</em> means <em class="italic">top</em> for<a id="_idIndexMarker036"/> vertical layouts and <em class="italic">far left</em> for horizontal. Similarly, <em class="italic">End</em> means <em class="italic">far right</em> for horizontal and <em class="italic">bottom</em> for vertical. We’ll return to these values later in the book.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Image</h2>
			<p>The third element of the<a id="_idIndexMarker037"/> page is an <code>Image</code> element, which in this case has four properties. The first is the source (where to find the image). The second is called <code>SemanticProperties.Description</code>. <strong class="bold">Semantic properties</strong> are added to assist<a id="_idIndexMarker038"/> those who use screen readers.</p>
			<p>You cannot set the height directly (it is read only), but you can set <code>HeightRequest</code>, which we have done here to <code>200</code> DIPs. .NET MAUI will try to provide that height depending on your other settings on the page and the available space. Finally, we set <code>HorizontalOptions</code> to <code>Center</code> so that we center the image on the horizontal axis.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Label</h2>
			<p>Next, we see <code>Label</code>. In this case, it too has four properties. The first is the text to display on the label. The <a id="_idIndexMarker039"/>second is, again, for screen readers, indicating the organizational structure (here the label is at the top level). The third property is <code>FontSize</code>. There are a couple of ways to set <code>FontSize</code>, as we’ll see in <a href="B19723_04.xhtml#_idTextAnchor054"><em class="italic">Chapter 4</em></a>, but here we are using DIPs. Finally, once again, we set <code>HorizontalOptions</code> to <code>Center</code>.</p>
			<p>If you scroll down the page, you’ll see there<a id="_idIndexMarker040"/> is another <code>Label</code> and a <code>Button</code> control (which does pretty much what you’d guess).</p>
			<p>At the bottom, you will see the close for <code>VerticalStackLayout</code>, then the close for <code>ScrollView</code>, and finally the close for <code>ContentPage</code> itself.</p>
			<p>The XAML thus provides a highly structured approach to describing the layout. Here is the complete XAML page:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encodi<a id="_idTextAnchor046"/>ng="utf-8" ?&gt;
&lt;ContentPage
    x:Class="ForgetMeNotDemo.MainPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"&gt;
    &lt;ScrollView&gt;
        &lt;VerticalStackLayout
            Padding="30,0"
            Spacing="25"
            VerticalOptions="Center"&gt;
            &lt;Image
                HeightRequest="200"
                HorizontalOptions="Center"
                SemanticProperties.Description="Cute dot
                  net bot waving hi to you!"
                Source="dotnet_bot.png" /&gt;
            &lt;Label
                FontSize="32"
                HorizontalOptions="Center"
                SemanticProperties.HeadingLevel="Level1"
                Text="Hello, World!" /&gt;
            &lt;Label
                FontSize="18"
                HorizontalOptions="Center"
                SemanticProperties.Description="
                      Welcome to dot net Multi platform
                        App U I"
                SemanticProperties.HeadingLevel="Level2"
                Text="Welcome to .NET Multi-platform
                  App UI" /&gt;
            &lt;Button
                x:Name="CounterBtn"
                Clicked="OnCounterClicked"
                HorizontalOptions="Center"
                SemanticProperties.Hint="Counts the number
                  of times you click"
                Text="Click me" /&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/ScrollView&gt;
&lt;/ContentPage&gt;</pre>
			<p>This page opens by declaring <code>ContentPage</code> (the most common type of page) and defines the namespace and name of the page (which will be reflected in the code-behind as well). It then declares two standard namespaces (using <code>xmlns</code>), the first for .NET MAUI and the second for the XAML markup.</p>
			<p>We see <code>ScrollView</code>, and<a id="_idIndexMarker041"/> inside of that, we see <code>VerticalStackLayout</code>, <a id="_idIndexMarker042"/>which is set to use padding and spacing and to be centered vertically. We’ll review these properties as we go along.</p>
			<p><code>VerticalStackout</code> contains four controls: an image, two labels, and a button. Each of these controls has its own properties. You do not have to be concerned about these properties now; they are explained later. The takeaway here is that layouts can contain layouts and controls. They stack like Ukrainian dolls, one within the other (though controls do not contain controls).</p>
			<p class="callout-heading">Notes</p>
			<p class="callout">Each <code>ContentPage</code> can have only one layout, but that layout can contain other layouts (as we see here), and so that is not a troublesome problem.</p>
			<p class="callout">Also, note that due to the size restriction of the printed page, some text will wrap to the next line.</p>
			<p class="callout">You can even do this in Visual Studio by going to <strong class="bold">Tools</strong> | <strong class="bold">Options</strong> | <strong class="bold">C#</strong> | <strong class="bold">General</strong> and checking the box for <strong class="bold">Word wrap</strong>. If you do this, I recommend also checking <strong class="bold">Show visual glyphs for word wrap</strong>, which makes reading the code easier. While you are there, you may want to check <strong class="bold">Line numbers</strong>, which can come in very handy, especially when tracking down compile errors. These options are shown in <em class="italic">Figure 3</em><em class="italic">.2</em>.</p>
			<div><div><img src="img/Figure_3.2_B19723.jpg" alt="Figure 3.2 – Setting Word wrap and Line numbers&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Setting Word wrap and Line numbers</p>
			<p>Now, when your line <a id="_idIndexMarker043"/>of code is too wide to display, it will wrap and you’ll see <a id="_idIndexMarker044"/>a small arrow on the right side indicating that the line has continued, as shown in <em class="italic">Figure 3</em><em class="italic">.3</em>.</p>
			<div><div><img src="img/Figure_3.3_B19723.jpg" alt="Figure 3.3 – Visual Studio word wrap&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Visual Studio word wrap</p>
			<p>When something happens such as the user clicking a button, an event is raised. The event is handled in the code-behind, which we’ll review next.</p>
			<p class="callout-heading">Events versus commands</p>
			<p class="callout">Starting in the next chapter, we <a id="_idIndexMarker045"/>will stop working with events and switch to commands. Commands<a id="_idIndexMarker046"/> are handled in the ViewModel, which makes them easier to test. For now, for convenience, we’ll handle events and we’ll do so in the code-behind.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>Code-behind and event handlers</h2>
			<p>We see in the <code>Button</code> control listed <a id="_idIndexMarker047"/>next that there is a <code>Clicked</code> property that points to a <code>OnCounterClicked</code> method:</p>
			<pre class="source-code">
&lt;Button
  x:Name="CounterBtn"
  Clicked="OnCounterClicked"
  HorizontalOptions="Center"
  SemanticProperties.Hint="Counts the number of times you
    click"
  Text="Click me" /&gt;</pre>
			<p>This method (<code>onCounterClicked</code>) is found in the code-behind file, <code>MainPage.xaml.cs</code>. All <code>EventArgs</code> (or a class derived from <code>EventArgs</code>). By convention, the <code>EventArgs</code> parameter is named <code>e</code>.<a id="_idIndexMarker049"/></p>
			<p>In our case (and most cases), we don’t care about the sender and the simple <code>EventArgs</code> (as used here) is empty and serves only as a base class for derived classes that provide additional information to the event handler (thus you might have a type derived from <code>EventArgs</code> that provides information that the event handler needs):</p>
			<pre class="source-code">
private void OnCounterClicked(object sender, EventArgs e)
{
    count++;
    if (count == 1)
        CounterBtn.Text = $"Clicked {count} time";
    else
        CounterBtn.Text = $"Clicked {count} times";
    SemanticScreenReader.Announce(CounterBtn.Text);
}</pre>
			<p>The event handler name matches the event handler identified in the XAML.</p>
			<pre class="source-code">
&lt;Button
    Clicked="OnCounterClicked"</pre>
			<p>This handler’s job is <a id="_idIndexMarker050"/>only to update the text on the button each time the button<a id="_idIndexMarker051"/> is clicked. Finally, it uses the <code>SemanticScreenReader Announce</code> method to show that text, again for screen<a id="_idIndexMarker052"/> readers:</p>
			<p>The count instance field is declared at the top of the class:</p>
			<pre class="source-code">
public partial class MainPage : ContentPage
{
    private int count = 0;
    public MainPage()
    {
        InitializeComponent();
    }</pre>
			<p class="callout-heading">InitializeComponent</p>
			<p class="callout">Notice that the constructor calls <code>InitializeComponent</code>. This will be true in the code-behind file of every XAML<a id="_idIndexMarker053"/> file. It is the job of <code>InitializeComponent</code> to initialize all the elements of the page.</p>
			<p>When we get to <a href="B19723_04.xhtml#_idTextAnchor054"><em class="italic">Chapter 4</em></a>, you’ll see that we try to minimize the contents of the code-behind file, principally to facilitate the creation of unit tests. At that point, we’ll substitute commands for our <a id="_idIndexMarker054"/>events, but let’s hold off on that for now.</p>
			<p>While nearly all the<a id="_idIndexMarker055"/> Microsoft documentation and all the existing sample code uses XAML for markup, it is possible to create layouts and views in C#. In fact, in recent years, more and more of the Microsoft documentation shows both.</p>
			<p class="callout-heading">.NET MAUI Community Toolkit</p>
			<p class="callout">This section requires the .NET MAUI Community<a id="_idIndexMarker056"/> Toolkit that you added as a NuGet package in the previous chapter. The Community Toolkit is actually part of a set of toolkits that are open source projects and supplement what is in the release version of .NET MAUI. They are created by community members who work closely with Microsoft developers. It is fair to assume that many of the Community Toolkit features will migrate into .NET MAUI properly over time. I would strongly urge you to use these toolkits, and this book does so.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor048"/>If you can do it in XAML, you can do it in C#</h1>
			<p>Anything that can be declared<a id="_idIndexMarker057"/> in XAML can be declared in C#. Containment is managed by using the <code>children</code> property of an object. Event handlers must be registered on an instance of the control. That is, an event handler would be registered for a particular button, as you’ll see in this example.</p>
			<p>Here is the code we wrote in XAML converted to C#:</p>
			<pre class="source-code">
using CommunityToolkit.Maui.Markup;    [1]
namespace ForgetMeNotDemo;
class MainPageCS : ContentPage
{
  private readonly Button counterBtn = new Button  [2]
  {
    Text = "Click Me",
    HorizontalOptions = LayoutOptions.Center,
  }.SemanticHint("Counts the number of times you click");
  public MainPageCS()
  {
    counterBtn.Clicked += OnCounterClicked;   [3]
    Content = new VerticalStackLayout    [4]
    {
      Spacing = 30,
      Padding = new Thickness(30, 0),
      VerticalOptions = LayoutOptions.Center,
      Children =   [5]
                {
                    new Image()
                    {
                        Source = "dotnet_bot.png",
                        HeightRequest = 200,
                        HorizontalOptions =
                          LayoutOptions.Center,
                    }.SemanticDescription("Cute dot net bot
                         waving hi to you!"), [6]
                    new Label()
                    {
                        Text="Hello, World",
                        FontSize=32,
                        HorizontalOptions =
                          LayoutOptions.Center,
                    }.SemanticHeadingLevel
                       (SemanticHeadingLevel.Level1),
                    new Label()
                    {
                        Text = "Welcome to .NET Multi-
                          platform App UI",
                        FontSize = 18,
                        HorizontalOptions =
                           LayoutOptions.Center,
                    }.SemanticHeadingLevel
                       (SemanticHeadingLevel.Level2)
                        .SemanticDescription(
                          "Welcome to dot net Multi
                            platform App UI"),
                    counterBtn, [7]
                }
    };
  }
  private int count = 0;
  private void OnCounterClicked(object sender, EventArgs e)
    [8]
  {
    count++;
    if (count == 1)
      counterBtn.Text = $"Clicked {count} time";
    else
      counterBtn.Text = $"Clicked {count} times";
    SemanticScreenReader.Announce(counterBtn.Text);
  }
}</pre>
			<p>Let’s quickly take a look at <a id="_idIndexMarker058"/>hooking up this new <code>MainPage</code>. To test this C# version, set the <code>ShellContent</code> element in <code>AppShell.xaml</code> to point to your new page like this:</p>
			<pre class="source-code">
&lt;ShellContent
    Title="Home"
    ContentTemplate="{DataTemplate local:MainPageCS}"
    Route="MainPageCS" /&gt;</pre>
			<p>Coming back to the XAML converted to C# code, let’s break it down for a better understanding. The numbers refer to the numbers in square brackets in the code:</p>
			<ol>
				<li>We begin by adding a <code>using</code> statement for <code>CommunityToolkit</code>. We need this for the semantic hints, which are used by screen readers for people with limited or no eyesight. While a finished project should have these for every control, we won’t be using them in this book to save space and confusion.</li>
				<li>We want to add a button, and that button will need an event handler (for the click event). In this example, the event handler for the <code>Clicked</code> event is at the bottom of the file. To add an event handler to our button, we must first define <code>Button</code>. We do this outside of the constructor and we set its properties [<code>2</code>].</li>
				<li>At the very beginning of the constructor, we assign the event handler method to the <code>Clicked</code> event. As noted, that event handler method is at the bottom of the file, though of course it could be (and perhaps should be) in its own file [<code>3</code>].</li>
				<li>We are now ready to create <code>VerticalStackLayout</code> and all the elements contained within the stack layout [<code>4</code>].</li>
				<li>These elements will be in the stack layout’s <code>Children</code> collection [<code>5</code>].</li>
				<li>Notice that the semantic <a id="_idIndexMarker059"/>description is attached to the image using a fluent syntax [<code>6</code>].</li>
				<li>After all the other elements, we are ready to insert our button into the stack layout’s <code>Children</code> collection [<code>7</code>].</li>
				<li>We’ve put the event handler for the button at the bottom of this file, though you certainly could move it to a different file, probably in a different folder. If you do so, however, remember to add a <code>using</code> statement for that namespace [<code>8</code>].</li>
			</ol>
			<p class="callout-heading">A note on comments</p>
			<p class="callout">There is a raging controversy in the industry about the use of comments in C# code. I take a rather extreme position: code <a id="_idIndexMarker060"/>should be almost completely self-explanatory. That is, if you use appropriate and descriptive names for variables, fields, methods, and so on, no comments should be needed. I’m not a fanatic about this; if the code is sufficiently complex, a comment here and there can be a big help, but comments <em class="italic">rust</em> and should be used sparingly. Thus, you will find few comments in the code, though we will walk through the code in some detail in the paragraphs that follow each listing.</p>
			<p>A recent addition to our tool set is the ability to use Fluent C#, which can make your C# code tighter and yet easier to read.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>C# versus Fluent C#</h2>
			<p>In addition to using C# to create your pages, there is a new (as of Winter 2022) <strong class="bold">Community Toolkit</strong> for Fluent C#. This does not change the basic approach but can make creating C# pages cleaner and easier to understand.</p>
			<p>To use this, you’ll need to add the <code>CommunityToolkit.Maui.Markup</code> NuGet package. Refer to the following figure:</p>
			<div><div><img src="img/Figure_3.4_B19723.jpg" alt="Figure 3.4 – Getting the markup package from NuGet&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Getting the markup package from NuGet</p>
			<p>The project is open source <a id="_idIndexMarker061"/>and can be examined (and extended!) at <a href="https://github.com/communitytoolkit/Maui.Markup">https://github.com/communitytoolkit/Maui.Markup</a>. The <code>ReadMe</code> file will get you started, though we’ll cover that material in this book as well.</p>
			<p>The first thing you need to do is to <a id="_idIndexMarker062"/>update <code>MauiProgram.cs</code> to add the toolkit to the builder using the following code snippet:</p>
			<pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
        .UseMauiCommunityToolkit()
        .UseMauiCommunityToolkitMarkup()
        .ConfigureFonts(fonts =&gt;
        {
            fonts.AddFont("OpenSans-Regular.ttf", 
                "OpenSansRegular");
            fonts.AddFont("OpenSans-Semibold.ttf", 
                "OpenSansSemibold");
        });</pre>
			<p>You can and<a id="_idIndexMarker063"/> should chain <code>UseMauiCommunityToolkitMarkup</code> to <code>UseMauiCommunityToolkit</code> in the builder [<code>1</code>].</p>
			<p>Now, you can avoid <a id="_idIndexMarker064"/>writing this:</p>
			<pre class="source-code">
var entry = new Entry();
entry.WidthRequest = 400;
entry.HeightRequest = 40;</pre>
			<p>Instead, you can chain all of that together and just write this:</p>
			<pre class="source-code">
new Entry().Size(200,40);</pre>
			<p>This makes <a id="_idIndexMarker065"/>the code much cleaner.</p>
			<p>I will provide C# and <a id="_idIndexMarker066"/>Fluent C# examples throughout the book; although, as noted, the primary markup language we’ll use is XAML.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Summary</h1>
			<p>In this chapter, we examined the markup language XAML, which is used to create layouts and controls. We saw that anything that can be done in XAML can also be done in C#, and we saw that there are two ways to write that C#: the traditional declarative way and the newer fluent form.</p>
			<p>We examined a few important classes (<code>Button</code>, <code>Label</code>, <code>Image</code>, and so on) and how events can be handled in the code-behind class. I also hinted that code-behind event handlers will be replaced by commands and their implementation in the ViewModel in the next chapter.</p>
			<p>In <a href="B19723_04.xhtml#_idTextAnchor054"><em class="italic">Chapter 4</em></a>, we’ll dive into the principal architecture for writing apps in .NET MAUI: <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) and we’ll look at data binding. We’ll then explore a number of cont<a id="_idTextAnchor051"/>rols and how they can work together.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor052"/>Quiz</h1>
			<ol>
				<li>In a sentence, what is XAML?</li>
				<li>What is XAML used for?</li>
				<li>What is an alternative to using XAML?</li>
				<li>How do we nest one layout inside another using C#?</li>
				<li>What is an event handler?</li>
				<li>If an event is declared in XAML, where is the event handler?</li>
			</ol>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Try it out</h1>
			<p>Time to start writing code!</p>
			<p>Create a new project named <code>ForgetMeNotJesse</code> (you might want to use your own name where I have put mine). Ideally, put that project under source control (see the <em class="italic">Technical requirements</em> section at the top of this chapter).</p>
			<p>Use the .NET MAUI template to create your project, using the latest version of .NET (.NET 7 at the time of the writing of this book).</p>
			<p>Run your program to make sure everything is set up correctly.</p>
			<p>Change <code>MainPage</code> so that clicking on the button updates a label below the button with the number of clicks (in addition to displaying it on the button itself).</p>
			<p>Once the page is working as intended, create a new page and recreate your <code>MainPage</code> in C# rather than in XAML. To test it, remember to set the <code>ShellContent</code> element in <code>AppShell.xaml</code> to point to your new page like this:</p>
			<pre class="source-code">
&lt;ShellContent
    Title="Home"
    ContentTemplate="{DataTemplate local:MainPageCS}"
    Route="MainPageCS" /&gt;</pre>
			<p>If you get stuck at any point, pull down the XAML and C# branch from the book’s repository and compare that solution with yours.</p>
		</div>
	</body></html>