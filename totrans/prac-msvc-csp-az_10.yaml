- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All About Testing the Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating microservices and using **continuous integration and continuous
    delivery** (**CI/CD**), finding errors early is an important part. Having errors
    in production is costly, and it’s best to find them as early as possible. Testing
    helps reduce costs by finding errors early.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers different kinds of tests needed with microservices solutions.
    We start creating unit tests, which should be the major tests used because issues
    are found fast, followed by integration tests, where multiple components of the
    solution are tested in collaboration. Integration tests can be done in-process
    where HTTP requests are simulated and in an environment where services are running
    on the systems, which allows you to test the environment under load.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create .NET Aspire integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create end-to-end .NET Playwright tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, as with the previous chapters, you need an Azure subscription
    and a Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ch10/final` folder, you’ll see these projects with the final result
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'These projects are unchanged from previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – The .NET Aspire host project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.ServiceDefaults` – Common service configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot` – The bot service to run games'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These projects are unchanged from previous chapters, but of special interest
    for the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.Analyzers` – This is the project that contains analyzers to verify
    game moves and return results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameApis` – The games API service project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These projects are new:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.Analyzers.Tests` – Unit tests for the analyzer library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot.Tests` – Unit tests for the bot service library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.Tests` – Unit tests for the games services project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.IntegrationTests` – In-memory integration tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.Playwright` – Tests with Microsoft Playwright'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working through the code with this chapter, you can start using the `start`
    folder, which contains the same projects without the test projects.
  prefs: []
  type: TYPE_NORMAL
- en: To easily deploy the solution to Microsoft Azure, check out the README file
    in the source code repo of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are tests that test a small piece of testable software. Does this
    functionality behave as expected? These tests should be fast, used directly on
    the developer system (and run with CI as well). With the **Visual Studio Live
    Unit Testing** feature (part of Visual Studio Enterprise), unit tests run while
    the code is updated, even before saving the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of bugs grows during the **software development life cycle** (**SDLC**).
    When bugs are found late (for example, in production), the cost grows exponentially.
    For fixing bugs early (for example, while typing the code), Visual Studio can
    give hints and show errors; as we are already working on the code, it’s not necessary
    to take the time to dive into the functionality as we are already working on it.
    For finding bugs with other test types (for example, integration or load tests),
    the fixes are more expensive – but of course, a lot less expensive than finding
    a bug in production.
  prefs: []
  type: TYPE_NORMAL
- en: A goal should be to reduce cost, and thus if some functionality can be verified
    with unit tests and other test types, prefer unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start creating a unit test, what is the heart of the games service
    in need of unit tests? It’s the analyzer library. There’s some complexity with
    the game rules, and it’s easy to make some logical errors writing the code. It’s
    also a place where some refactoring could be done to increase performance and
    reduce memory needs. After refactoring, the application should function in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When I was initially developing the games analyzer library, I created unit tests
    beforehand and enhanced the unit tests while developing the algorithms. With **test-driven
    development** (**TDD**), unit tests are created before the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Before fixing bugs, I also created new unit tests. Why did the bug occur? Why
    was it not covered by a test? With many different projects, I see bugs that have
    been fixed come back with a later version. If there’s a unit test to verify the
    functionality, the same issue cannot resurface with a new version.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s dive into the `Codebreaker` code, which needs many unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the games analyzer library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the `GameGuessAnalyzer` class in the `Codebreaker` analyzer library:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/GameGuessAnalyzer.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `GetResult` method is the heart of this class. With the constructor of the
    `GameGuessAnalyzer` abstract base class, the game and the guesses are passed with
    parameters. The `GetResult` method uses the codes of the game and uses the guesses
    to return the result – the number of colors that are in the correct position and
    the number of colors that are correct but in the wrong position. The implementation
    of the `GetResult` method is just an invocation of four methods. The `ValidateGuess`
    method analyses the correctness of guesses and throws an exception if the guesses
    are not correct. The `GetCoreResult` method is abstract and needs to be implemented
    by a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the classes deriving from the `GameGuessAnalyzer` class is the `ColorGameGuessAnalyzer`
    class. This is used by the `Game6x4` and `Game8x5` game types (six colors with
    four codes and eight colors with five codes):'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Analyzers.Tests/Analyzers/ColorGameGuessAnalyzer.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This class overrides the `ValidateGuessValues` and the `GetCoreResult` methods.
    `ValidateGuessValues` validates the input data and throws exceptions if the data
    is not valid. The `GetCoreResult` method implements the algorithm for the `Codebreaker`
    game, finds if the guesses are correctly placed and if the guesses are correct
    but incorrectly placed, and returns the result accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a unit test project for this library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the .NET CLI, we can create a new xUnit test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a `Codebreaker.Analyzers.Tests` project with references
    to xUnit NuGet packages and a project reference to the analyzer project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’m mainly using xUnit for unit tests. It’s a matter of choice whether to use
    **MSTest**, **NUnit**, or **xUnit**; you can use any of these frameworks for unit
    tests, and all of these are greatly integrated within the .NET tools. I myself
    switched from MSTest to xUnit with early betas of .NET Core 1.0 when xUnit was
    available, but MSTest was not ready for the new .NET – and most unit tests from
    the .NET team themselves are done using xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the first tests, some preparations need to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the IGame interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the constructor of the `ColorGameGuessAnalyzer` class, an object implementing
    the `IGame` interface is required with the constructor. A unit test should only
    test a small functionality without testing dependencies that are covered by their
    own unit tests. When testing the `ColorGameGuessAnalyzer` class, we don’t want
    to add a dependency to the `Game` class while testing the analyzer. What’s needed
    by the `ColorGameGuessAnalyzer` class is the `IGame` interface. To allow the test
    to run, the `IGame` interface is implemented by a mocking class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/MockColorGame.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `MockColorGame` class is just a simple data holder to implement the `IGame`
    interface, thus we don’t need to use any mocking library. With another unit test
    implementation done later, we’ll use a mocking library to mock functionality that
    should not be tested by the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define common functionality needed by multiple unit tests, helper methods
    are created within the `ColorGame6x4AnalyzerTests` test class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/ColorGame6x4AnalyzerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AnalyzeGame` method receives a string array representing the valid code,
    a string array representing the guesses, and the move number. This information
    is used to create a mocked game instance and to invoke the `GetResult` method
    of the analyzer class. The result of the analysis is returned with a `ColorResult`
    type. This helper method can now be used to easily create unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first unit test is implemented with the `GetResult_Should_ReturnThreeWhite`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using xUnit, the `Fact` attribute declares a method to be a unit test. A unit
    test consists of three parts: `expectedKeyPegs` variable. Invoking the `AnalyzeGame`
    method is the act. The `Green` – `Yellow` – `Green` – `Black` code is passed as
    valid code, and `Yellow` – `Green` – `Black` – `Blue` as a guess. With this guess,
    no color is in the correct position, but three colors are correct in the wrong
    positions, thus three whites should be returned. If this result is correct, this
    is verified using the `Assert.Equal` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing test data to unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this scenario, it’s useful to just define one method that’s used with
    different test data to verify the different outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With xUnit, using the `Theory` attribute instead of the `Fact` attribute allows
    the test method to be invoked multiple times, passing different test data. The
    `GetResult_ShouldReturn_InlineResults` method uses arguments that are specified
    with the `InlineData` attribute. With every `InlineData` attribute, the parameter
    values for the arguments defined with the method are passed. Here, two tests are
    covered with one implementation. This feature allows for quickly extending test
    cases by just adding new `InlineData` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `InlineDataAttribute` class, a class can be created implementing
    `IEnumerable<object[]>` to supply test data:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`object[]` defines all the values for one method invocation. The first argument
    passed defines the valid code for the game, the second argument the guess data,
    and the third argument the expected result. With every iteration of `IEnumerable`,
    a new test run is done. The next code snippet shows the test method implementation
    using the data class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `InlineData` attribute, here `ClassData` is used. Using
    an object returning the test data is more flexible. The `InlineData` attribute
    requires constant values that are stored by the compiler. With the `ClassData`
    attribute, data can also be created dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting exceptions with a unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another test case where we expect an exception to be thrown is shown in the
    next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Assert.Throws` defines the exception type that should be thrown by the implementation
    when the test data is passed. If an exception is not thrown, the test fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a mocking library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With some classes that should be tested, it’s great to have a mocking library.
    The `GamesService` class injecting the `IGamesRepository` interface is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the `GamesService` class, the `IGamesRepository` interface is injected
    using constructor injection. When testing the `SetMoveAsync` method, the implementation
    of the `IGamesRepository` interface should not be part of this test. There’s another
    test for the games repository. Instead, a mocking implementation of this class
    is used for the unit test. The `SetMoveAsync` method invokes the `GetGameAsync`
    method of the `IGamesRepository` interface. The real implementation of this method
    should not be part of the test, but we need some different results that can be
    used with the methods used afterward. When this method returns `null` because
    it didn’t find the game, `CodebreakerException.ThrowIfNull` should throw an exception.
    If the method returns a game that already ended, the next method should throw
    an exception because a new move cannot be set to a game that already ended. The
    `ThrowIfUnexpectedGameType` method should throw an exception if the game type
    passed is different from the game type of the game retrieved. This can easily
    be solved by using a mocking library.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create another xUnit test project named `Codebreaker.GameAPIs.Tests` to
    test the `GamesService` class. To mock the `IGamesRepository` interface, add the
    `moq` NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows fields for games and game IDs that are used
    by the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `IGamesRepository` interface is mocked creating a new instance by using
    the generic `Mock` type. After this, games are predefined for a game not found
    in the repository (`_notFoundGameId`), a game that already ended (`_endedGame`),
    and a running game that is active (`_running6x4Game`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the `GamesServiceTests` class initializes the game objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the constructor, instances of the different game types are created. The
    game already ended has the `EndTime` property set. To specify the behavior of
    the mocking implementation, the `Setup` method is invoked. With this, if the `GetGameAsync`
    method receives the ended game ID with the parameter, it returns the configured
    game instance that already ended. Passing the game ID of the running game, the
    corresponding instance is returned. With the third invocation of the `Setup` method,
    it’s defined that the `AddMoveAsync` method contains an implementation when passing
    the running game. `It.IsAny<Move>` allows us to invoke this method with any `Move`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement unit tests. The first unit test is to verify that the
    `SetMoveAsync` method throws an exception if the game already ended:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the *arrange* step, the `GamesService` class is instantiated with the mocking
    object of the `IGamesRepository` implementation. With the unit test act – as already
    used before – `Assert.ThrowAsync` is used to check if an exception was thrown
    when invoking the `SetMoveAsync` method with the specified game that already ended.
    Another check that is done here is using the `Verify` method on the `Mock` class
    to check if the method is exactly called once.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetMoveAsync_Should_ThrowWithUnexpcectedGameType` and `SetMoveAsync_Should_ThorwWithNotFoundGameType`
    unit test methods are very similar, thus are not listed here. Check the source
    code repo for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test method to test the normal flow is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `SetMoveAsync_Should_UpdateGameAndAddMove` method verifies that the `GetGameAsync`
    and `AddMoveAsync` methods are called once, and with the first move in the game,
    the `Moves` property contains exactly one value.
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start unit tests, you can use the `dotnet test` .NET CLI command to run
    all the tests. Using Visual Studio, the **Test** menu is available to run all
    the tests. Using **Test Explorer**, as shown in *Figure 10**.1*, you can start
    testing by test, a group of tests, or all tests, see the outcome of every test,
    debug tests, run tests until they fail, define a playlist of tests, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Visual Studio Test Explorer](img/B21217_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Visual Studio Test Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Visual Studio 2022 Enterprise Edition, you can start Live Unit Testing.
    With Live Unit Testing, a unit test runs while you change the source code. Here,
    you can also monitor which code lines are covered by a unit test and which lines
    are missed. *Figure 10**.2* shows the Visual Studio Code editor with Live Unit
    Testing turned on, and code line *53* missed from all unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Visual Studio Live Unit Testing](img/B21217_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Visual Studio Live Unit Testing
  prefs: []
  type: TYPE_NORMAL
- en: After working through some unit tests, let’s move over to other test types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating .NET Aspire integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While unit tests should be the primary tests, integration tests not only test
    a small functionality but include testing of multiple components within one test,
    such as including infrastructure – for example, a database.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire contains a library and test templates using xUnit, which easily
    allows creating integration tests to directly access the app model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a .NET Aspire test project using .NET Aspire and xUnit, named
    `Codebreaker.IntegrationTests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This project includes references to the `Aspire.Hosting.Testing` NuGet package,
    as well as `Microsoft.NET.Test.Sdk`, xUnit, and `xunit.runner.visualstudio`. To
    allow accessing the app model, add a project reference to `Codebreaker.AppHost`.
    With the integration test we implement, we need types from the game APIs project,
    thus we also add a reference to `Codebreaker.GameAPIs`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all the integration tests of the game APIs, we need an `HttpClient` instance.
    xUnit allows for asynchronous initialization by implementing the `IAsyncLifetime`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Renaming the class created from the `IAsyncLifetime` interface defines the `InitializeAsync`
    and `DisposeAsync` methods. Field members that will be initialized within the
    InitalizeAsync method are the `DistributedApplication` and `HttpClient` classes.
    You already know the `DistributedApplication` class from the app model in the
    `AppHost` project. You’ll see how this will be used in the `InitalizeAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: While we didn’t dispose of the `DistributedApplication` instance in the `AppHost`
    project (because there’s only one instance running for the lifetime of the application,
    and the resources are freed on the application end), it’s important to dispose
    of it with unit tests, as it initialized providers and file watchers. With many
    tests, the user limit of `INotify` instances and the process limit of open file
    descriptors can be reached – thus, don’t forget to dispose of this resource in
    test projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to create `DistributedApplication` and `HttpClient` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using `DistributedApplicationTestingBuilder` (defined in the `Aspire.Hosting.Testing`
    namespace), invoking the `CreateAsync` method, a new instance of `DistributedApplicationTestingBuilder`
    is returned. The generic parameter references the `Codebreaker` `AppHost` project.
    Similar to what you’ve seen when using the generic parameter with the projects
    referenced in the `AppHost` project, the same mechanism is used here, referencing
    the `AppHost` project itself. Invoking the `BuildAsync` method returns a `DistributedApplication`
    instance that we may forget to dispose of. Using this instance, we can access
    the app model definition. In the app model specified by the `Codebreaker.AppHost`
    project, we have `gameapis` defined, which is the name of the `Codebreaker.GameAPIs`
    project. `CreateHttpClient` returns an `HttpClient` object to reference this service.
    Both the `HttpClient` and the `DistributedApplication` objects returned are assigned
    to field members. Now, we are ready to create tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test to verify an HTTP bad request status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the first test, let’s verify if the correct status code is returned when
    an invalid move number is sent. First, we need to start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Starting the game, we already use the `HttpClient` instance and invoke an HTTP
    `POST` request, passing the `CreateGameRequest` object. `CreateGameRequest` is
    available in the test project because we added a project reference to the `Codebreaker.GameAPIs`
    project on creation of the test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue the implementation of this method by setting a game move:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We use `HttpClient` once more – this time to send a `PATCH` request. Passing
    `moveNumber` with a `0` value specifies an incorrect move. The first correct move
    starts with `1`. This way, we expect to receive a `BadRequest` result, which is
    verified using `Assert.Equal`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create another test to play a complete game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test to play a complete game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code snippet shows an integration test setting multiple moves:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting the game is the same as before, thus the code is not shown here. Sending
    the first move is just a little bit different in that we send the correct move
    number. From there, we continue sending a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Before sending a `GET` request, we check if the game was won with the first
    move. This should happen about once in 1,296 invocations; thus, it will happen
    when running the test often. We don’t want to fail the test if the game was won
    with the first move. If the game has not been won yet, a `GET` request is done
    to find out the correct values, then the correct values are used to make the second
    move.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending the correct move, we should get a successful result:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.IntegrationTests/GameAPIsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After sending the second move, the result is verified. Finally, the game is
    deleted. In between all these invocations, results are verified.
  prefs: []
  type: TYPE_NORMAL
- en: Run all the integration tests either using the `dotnet test` .NET CLI command
    or with Visual Studio Test Explorer, just as before with the unit tests. Just
    remember not to use integration tests with Live Unit Testing.
  prefs: []
  type: TYPE_NORMAL
- en: With CI, as covered in [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183), all
    these tests should run as well. This can simply be done using `dotnet test`.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Aspire testing for integration tests has the advantage that the server
    doesn’t need to be started. However, creating load tests, testing the solution
    before a switch to the production environment, and directly sending HTTP requests
    should be done from a test environment as well. We’ll do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating end-to-end .NET Playwright tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microsoft Playwright** ([https://playwright.dev](https://playwright.dev))
    offers tools and libraries from Microsoft for web tests, which include tests on
    web APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Playwright offers several tools (including generating tests by recording actions
    with web pages, inspecting web pages, generating selectors, and viewing traces),
    tests across different platforms, and test libraries for TypeScript, JavaScript,
    Python, .NET, and Java. With UI automation, Playwright can replace manual testers!
    Here, we’ll use Playwright to test APIs – using .NET!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test project with Playwright
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start creating a test project with Playwright. Because xUnit has a focus
    on unit tests and there’s an issue with limiting concurrent test runs, Playwright
    supports NUnit and MSTest. Here, we use NUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `dotnet new`, we create a new .NET project, this time using NUnit for
    the testing framework. `Microsoft.Playwright.NUnit` is the Playwright package
    for NUnit. After `dotnet build`, a `playwright.ps1` PowerShell script file is
    created in the `bin/debug/net8.0` folder that installs required browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating a context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Playwright has its own API for creating HTTP requests. This needs to be initialized,
    together with some housekeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Because this test class shouldn’t participate in live unit testing, the `Category`
    assembly attribute is used to mark the complete assembly with `SkipWhenLiveUnitTesting`.
    Contrary to xUnit where the `AssemblyTrait` attribute was used, NUnit uses the
    `Category` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Playwright, the test class needs to derive from the `PlaywrightTest` base
    class. The field of type `IAPIRequestContext` is Playwright’s API to create HTTP
    requests. This field is initialized with the next source code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `SetupAPITesting` method is invoked before every test. With NUnit, such
    an initialization method needs to be annotated with the `Setup` attribute. To
    initialize `IAPIRequestContext`, the `Playwright.APIRequest.NewContextAsync` method
    is invoked. Here, the HTTP headers and the base address for the service are specified.
    To allow this to be configured with the `appsettings.json` file, the `ConfigurationBuilder`
    class is used. To simulate a think time, `_thinkTimeMS` is retrieved from the
    configuration, which is then used before setting every game move.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the API context is created, it also needs to be disposed of:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A method that’s invoked after the test has run is annotated with the `TearDown`
    attribute. The context needs to be disposed of after use.
  prefs: []
  type: TYPE_NORMAL
- en: After the preparation, let’s create our test.
  prefs: []
  type: TYPE_NORMAL
- en: Playing a game with Playwright
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tests created with NUnit are annotated with the `Test` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: NUnit uses the `Test` attribute to specify a test. The `Repeat` attribute can
    be used to specify the number of runs the test should be repeated running one
    test. This attribute is useful in generating a longer load on the server. The
    `PlayTheGameToWin` method defines the flow with the API. First, a new game is
    created invoking the `CreateGameAsync` method. After this, for up to 10 moves,
    moves are placed with the `SetMoveAsync` method. If – with the randomly chosen
    guesses – the game is already finished, we are done. Otherwise, information about
    the game is retrieved using `GetGameAsync`, and one more time, `SetMoveAsync`
    is invoked – this time with the correct move.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these invocations is shown in the next code snippet. For the other ones,
    check the source code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Playwright/GamesAPITests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `SetMoveAsync` method sets a move by using the `IAPIRequestContext` interface’s
    `PatchAsync` method. Depending on the HTTP verb used, `GetAsync`, `PostAsync`…
    methods are available. The HTTP body that is sent to the service is specified
    with the `DataObject` property. The `PatchAsync` method returns an `IAPIResponse`
    response. Using this response, the JSON data can be retrieved using the `JsonAsync`
    method. The `Ok` property that is used with an `Assert` verification returns `true`
    with a status code in the range of 200 to 299.
  prefs: []
  type: TYPE_NORMAL
- en: With this test in place, we can run the test using `dotnet test` or with Test
    Explorer within Visual Studio. Just this time, the service needs to be running!
  prefs: []
  type: TYPE_NORMAL
- en: Creating test loads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Playwright tests can now be used to simulate a user load, to run multiple
    users concurrently. For this, just compute resources are needed to run the needed
    load. By reducing the delay time, a few “virtual users” can be used to simulate
    the load of a bigger number of real users. How long real users are thinking between
    moves needs to be analyzed monitoring the solution in production.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the delay between moves, you can use fewer compute resources to simulate
    a large number of real users with just a few virtual users. There’s also a good
    reason to increase the delay time for the time used by real users. In [*Chapter
    12*](B21217_12.xhtml#_idTextAnchor294), we’ll enhance the solution with caching.
    What if the cached game is not available after a user has a long delay between
    moves? Does the application still behave correctly? You should also run such integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Microsoft Playwright Testing** cloud service, compute resources
    are available to test web applications. This service is – at the time of this
    writing – not available to test REST APIs. Another service to run load tests is
    **Azure Load Testing**. With this tool, you can write **JMeter** scripts to run
    the tests or specify web requests from the web portal. In [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294),
    we’ll use this service to create load tests to increase the replica count of the
    games API. This tool not only runs the load but also gives a great report to show
    information about all resources interacting with the requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the tests covered here can also be used with GitHub actions. After building
    the .NET libraries and applications, `dotnet test` should be triggered to start
    all the unit tests. After deploying the services to the test environment, integration
    tests should run before the solution is deployed to the next environment – for
    example, the staging environment. Automated load tests should make sure the solution
    is working under load.
  prefs: []
  type: TYPE_NORMAL
- en: Continuously – for workflows triggered on a timely basis – you should check
    if new security issues are found in dependencies, and these dependencies should
    be updated. For this, with GitHub, just *Dependabot* needs to be configured.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to create *unit tests* to test simple functionality.
    These tests can be used with Live Unit Testing where test errors immediately show
    up during development. With unit tests, you learned to use a *mocking library*
    to replace functionality that is not in the scope of the unit test and is covered
    by a different unit test.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how .NET Aspire makes *integration tests* simple using `Aspire.Hosting.Testing`.
    There’s no need to start the service, as the handler of `HttpClient` is replaced
    to send requests to the service in-process.
  prefs: []
  type: TYPE_NORMAL
- en: Using Microsoft Playwright, you created an integration test that makes HTTP
    requests to the API and can be used to test the solution under load.
  prefs: []
  type: TYPE_NORMAL
- en: While you monitored metrics data in this chapter, the next chapter expands on
    this so that you can create your own metric counts and add logging and distributed
    tracing to the microservices solution.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Martin Fowler on testing microservices: [https://martinfowler.com/articles/microservice-testing](https://martinfowler.com/articles/microservice-testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Live Unit Testing: [https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing](https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integration tests: [https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testing .NET Aspire* *apps*: [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Playwright: [https://playwright.dev/](https://playwright.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Guide to Secure .NET Development with OWASP Top* *10*: [https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/](https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with* *Dependabot*: [https://docs.github.com/en/code-security/dependabot/working-with-dependabot](https://docs.github.com/en/code-security/dependabot/working-with-dependabot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
