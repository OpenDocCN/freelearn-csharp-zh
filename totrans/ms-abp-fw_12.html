<html><head></head><body>
		<div><h1 id="_idParaDest-198"><em class="italic"><a id="_idTextAnchor300"/>Chapter 9</em>: Understanding Domain-Driven Design</h1>
			<p>The ABP Framework project's main goal is to introduce an architectural approach to application development and provide the necessary infrastructure and tools to implement that architecture with best practices.</p>
			<p><strong class="bold">Domain-driven design</strong> (<strong class="bold">DDD</strong>) is one of the core parts of ABP Framework's architecture offering. ABP's startup templates are layered based on DDD principles and patterns. ABP's entity, repository, domain service, domain event, specification, and many other concepts are directly mapped to the tactical patterns of DDD.</p>
			<p>Since DDD is a core part of the ABP application development architecture, this book has a dedicated section, <em class="italic">Part 3,</em> <em class="italic">Implementing Domain-Driven Design,</em> for DDD that consists of three chapters. In this book, I will focus on practical implementation details rather than the theoretical and strategic approaches and concepts of DDD. The examples will be mostly based on the <em class="italic">EventHub</em> project that was introduced in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>. In addition, I will show different examples for some scenarios that the <em class="italic">EventHub</em> project has no proper examples of.</p>
			<p>The next two chapters will show you explicit<a id="_idIndexMarker608"/> rules and concrete code examples for implementing DDD to help you learn how to implement DDD with the ABP Framework. </p>
			<p>However, in this first chapter, we will look at DDD in general and explore the core technical concepts in the following order:</p>
			<ul>
				<li>Introducing DDD</li>
				<li>Structuring a .NET solution based on DDD</li>
				<li>Dealing with multiple applications</li>
				<li>Understanding the execution flow</li>
				<li>The common principles of DDD</li>
			</ul>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor301"/>Technical requirements</h1>
			<p>You can clone or download the source code for the <em class="italic">EventHub</em> project from GitHub: <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>.</p>
			<p>If you want to run the solution in your local development environment, you need to have an IDE/editor (such as Visual Studio) to build and run ASP.NET Core solutions. Also, if you want to create ABP solutions, you need to have the ABP CLI installed, as explained in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor302"/>Introducing DDD</h1>
			<p>Before we cover the implementation details, let's define DDD's core concepts and building blocks. Let's begin with the definition of DDD.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor303"/>What is domain-driven design?</h2>
			<p>DDD is a software development approach for complex needs where you connect the software's implementation to an evolving model.</p>
			<p>DDD is suitable for complex domains and large-scale applications. In the case of simple, short-lived <strong class="bold">Create, Read, Update, Delete</strong> (<strong class="bold">CRUD</strong>) applications, you typically don't need to follow all the DDD principles. Fortunately, ABP doesn't force you to implement all the DDD principles in every application; you can just use which principles work best for your application. However, following DDD principles and patterns in a complex application helps you build a flexible, modular, and maintainable code base.</p>
			<p>DDD focuses on core domain logic rather than the infrastructure details, which are generally isolated from the business code.</p>
			<p>Implementing DDD is closely related to <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) principles. This book doesn't cover these basic principles, but still, a good understanding of OOP and the <strong class="bold">single responsibility, open-closed, Liskov-substitution, interface segregation, and dependency inversion</strong> (<strong class="bold">SOLID</strong>) principles will help you a lot while you're shaping and organizing your code base and implementing DDD in practice.</p>
			<p>Now that we've provided this brief definition, we can explore the fundamental layers of DDD.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor304"/>DDD layers</h2>
			<p>Layering is a common principle of organizing<a id="_idIndexMarker609"/> software solutions to reduce complexity and increase reusability. DDD offers a four-layered model to help you organize your business logic and abstract the infrastructure from the business logic, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_9.01_B17287.jpg" alt="Figure 9.1 – Layers of DDD&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Layers of DDD</p>
			<p>The preceding diagram shows the layers and their relationships:</p>
			<ul>
				<li>The <strong class="bold">domain layer</strong> contains the essential business objects and implements the core, use case-independent, reusable domain logic of the solution. This layer doesn't depend on any other layer, but all the other layers directly or indirectly depend on it.</li>
				<li>The <strong class="bold">application layer</strong> implements the use cases of the applications. A use case is typically an action that's taken by the user through the UI. The <strong class="bold">application layer</strong> uses the <strong class="bold">domain layer's</strong> objects to perform these use cases.</li>
				<li>The <strong class="bold">presentation layer</strong> contains the UI components of the application, such as the views, JavaScript, and CSS files for a web application. It does not directly use the <strong class="bold">domain layer</strong> or database objects. Instead, it uses the <strong class="bold">application layer</strong>. Typically, for every use case/action that's performed on the UI, there is a corresponding functionality/method on the <strong class="bold">application layer</strong>.</li>
				<li>The <strong class="bold">infrastructure layer</strong> depends on all the other layers and implements the abstractions that have been defined by these layers. It helps gracefully separate your business logic from third-party libraries and systems, such as database or cache providers.</li>
			</ul>
			<p>Each layer of this model has a responsibility and contains various building blocks, which are introduced in the next section.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor305"/>Building blocks</h2>
			<p>From a technical perspective, DDD is<a id="_idIndexMarker610"/> mostly related to designing your business code by focusing on the domain you are working on. Business logic is separated into two layers –  the domain layer and the application layer. The other layers (presentation and infrastructure) are considered as implementation details and should be implemented based on the best practices of the specific technologies you are using, such as Entity Framework.</p>
			<p>The domain layer implements the core domain logic by using the following fundamental building blocks:</p>
			<ul>
				<li><code>Event</code> and <code>Organization</code> entities.</li>
				<li><strong class="bold">Value Object</strong>: A value object is another type of business object. Value objects are identified by their state (properties), and they don't have an identifier. This means that two value objects are considered the same if all their properties are the same. Value objects are generally simpler than entities and are typically implemented as immutable. For example, we can create value objects such as address, money, or date.</li>
				<li><code>Event</code> entity of the EventHub solution is the aggregate root entity of the Event aggregate, which contains tracks and sessions as sub-collections.</li>
				<li><strong class="bold">Repository</strong>: A repository is a collection-like interface that's used by the domain and application layers to access the persistence system. It hides the complexity of the database provider from the business code.</li>
				<li><strong class="bold">Domain Service</strong>: A domain service is a stateless service (class) that implements core business rules. It is useful to implement domain logic that depends on multiple aggregate types (so that none of these aggregates can be responsible for implementing that logic) or external services. Domain services get/return domain objects and are generally consumed by the application services or other domain services.</li>
				<li><strong class="bold">Specification</strong>: A specification is a named, reusable, testable, and combinable filter that's applied to business objects to select them based on specific business rules.</li>
				<li><strong class="bold">Domain Event</strong>: A domain event is a way of informing other services in a loosely coupled manner when a domain-specific event occurs. It is useful for implementing side effects across multiple aggregates.</li>
			</ul>
			<p>The application layer implements<a id="_idIndexMarker611"/> the use case of the application by using the following building blocks:</p>
			<ul>
				<li><strong class="bold">Application Service</strong>: An application service is a stateless service (class) that implements the use cases of the application. It typically gets and returns data transfer objects, and its methods are used by the presentation layer. It uses and orchestrates the domain layer objects to perform a specific use case. A use case is typically implemented as a transactional (atomic) process.</li>
				<li><strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTO</strong>): A DTO is used to transfer data (state) between the presentation and application layers. It doesn't contain any business logic.</li>
				<li><strong class="bold">Unit of Work</strong> (<strong class="bold">UOW</strong>): A UOW is a transaction boundary. All the state changes (typically database operations) in a UOW must be implemented as atomic, committed together on success, or rolled back together on failure.</li>
			</ul>
			<p>It was important to see the big picture and become familiar with the core building blocks of DDD, which I why I introduced them in brief here. In the next few chapters, we will use them in practice and understand their implementation details. However, in this chapter, I will continue with the big picture and explain how ABP places the layers and building blocks into a .NET solution.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor306"/>Structuring a .NET solution based on DDD</h1>
			<p>So far, we have been introduced to the layers<a id="_idIndexMarker612"/> and core building blocks of a DDD-based software solution. In this section, we will learn how a .NET solution can be layered based on DDD. I will begin with the simplest possible solution structure. Then, I will explain how ABP's startup solution template evolved into its current structure. Finally, you will understand why the ABP startup solution has that many projects inside it and the purpose of each.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor307"/>Creating a simple DDD-based .NET solution</h2>
			<p>Let's start from scratch and keep things simple by creating four projects in our .NET solution, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.02_B17287.jpg" alt="Figure 9.2 – A simple DDD-based .NET solution in Visual Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – A simple DDD-based .NET solution in Visual Studio</p>
			<p>Assuming that we are building a <strong class="bold">Customer Relationship Management</strong> (<strong class="bold">CRM</strong>) solution, <strong class="bold">Acme</strong> is our company name, and <strong class="bold">Crm</strong> is the product name in this example. I've created a separate C# project for each layer. .NET projects perfectly fit into layers as they can physically separate the code base into different packages. A class/type in a project can directly use other classes/types in the same project. However, a class/type can't use a class/type in another project unless you explicitly define the dependency by referencing the other project.</p>
			<p><em class="italic">Figure 9.2</em> shows the projects in the solution in Visual Studio, as well as the dependencies between these projects:</p>
			<div><div><img src="img/Figure_9.03_B17287.jpg" alt="Figure 9.3 – Project dependencies of the simple DDD-based .NET solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 9.3 – Project dependencies of the simple DDD-based .NET solution</p>
			<p>In the preceding diagram, the solid lines represent development-time dependencies (project references), while the dashed line represents runtime dependencies. I will explain the difference later in this section.</p>
			<p>To understand these dependencies, we need to know<a id="_idIndexMarker613"/> what type of components these projects may contain. We saw which components are located in the domain and application layers in the <em class="italic">Building blocks</em> section. Here, I will mention some example components that are included in the projects of that CRM solution:</p>
			<ul>
				<li><code>Product</code> class (aggregate root entity) and an <code>IProductRepository</code> interface (repository abstraction). The <code>Product</code> class represents a product and has some properties such as <code>Id</code>, <code>Name</code>, and <code>Price</code>. <code>IProductRepository</code> has some methods to perform database operations for products, such as <code>Insert</code>, <code>Delete</code>, and <code>GetList</code>.</li>
				<li><code>CrmDbContext</code> class (the EF Core data context), which maps the <code>Product</code> entity to a database table. It also contains the <code>EfProductRepository</code> class, which implements the <code>IproductRepository</code> interface.</li>
				<li><code>ProductAppService</code> (application service), along with some methods to create, update, delete, and get a list of products. This service internally uses the <code>IProductRepository</code> interface and the <code>Product</code> entity (the domain objects).</li>
				<li><code>Products.cshtml</code> page (and a related JavaScript file) that renders the product data on the UI and allows you to manage (create, edit, and delete) the products. It internally uses <code>ProductAppService</code> to perform the actual operations.</li>
			</ul>
			<p>Now that we understand the purpose and contents of these projects, let's see why the projects have these dependencies:</p>
			<ul>
				<li><strong class="bold">Acme.Crm.Domain</strong> has no dependencies. In general, the domain layer has a minimal dependency and is abstracted from the infrastructural details.</li>
				<li><code>Product</code> class to map it to a database table, and it implements the <code>IProductRepository</code> interface.</li>
				<li><code>IProductRepository</code> repository and the <code>Product</code> entity to perform the use cases.</li>
				<li>Finally, <code>ProductAppService</code>).</li>
			</ul>
			<p>The <strong class="bold">Acme.Crm.Web</strong> project has one more dependency: it references the <strong class="bold">Acme.Crm.Infrastructure</strong> project. It doesn't directly<a id="_idIndexMarker614"/> use any class in that project, so there is no need for a direct dependency. However, <strong class="bold">Acme.Crm.Web</strong> is also the project that runs the application, and the application needs the infrastructure layer at runtime to use the database. An alternative structure will be discussed in the <em class="italic">Separating the hosting from the UI</em> section so that you can get rid of that dependency.</p>
			<p>This was a minimalistic layering of a DDD-based solution. In the next section, we will use that solution and explain how ABP's startup solution has evolved.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor308"/>Evolution of the ABP startup solution</h2>
			<p>ABP's startup solution is more complex than the solution shown in <em class="italic">Figure 9.2</em>. The following screenshot shows the same solution that was created with the ABP startup template, but this time using the <code>abp new Acme.Crm</code> CLI command:</p>
			<div><div><img src="img/Figure_9.04_B17287.jpg" alt="Figure 9.4 – The CRM solution created using the ABP startup template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – The CRM solution created using the ABP startup template</p>
			<p>Let's explain how this solution evolved from the four-project solution explained in the previous section.</p>
			<h3>Introducing the EntityFrameworkCore project</h3>
			<p>The minimalistic DDD solution <a id="_idIndexMarker615"/>contains the <strong class="bold">Acme.Crm.Infrastructure</strong> project, which is assumed to implement all the infrastructural abstractions and integrations. An ABP solution, on the other hand, has a dedicated Entity Framework Core integration project (<strong class="bold">Acme.Crm.EntityFrameworkCore</strong>) since we think it is good to create separate projects for such major dependencies, especially for the database integration.</p>
			<p>The infrastructure layer can be split into multiple projects. The ABP startup template has no such major dependency. The only infrastructure project is the <strong class="bold">Acme.Crm.EntityFrameworkCore</strong> project. If your solution grows, you can create additional infrastructure projects.</p>
			<p>With this change, the initial minimalistic DDD-based solution will be as follows:</p>
			<div><div><img src="img/Figure_9.05_B17287.jpg" alt="Figure 9.5 – Introducing the Entity Framework Core integration project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Introducing the Entity Framework Core integration project</p>
			<p>This change was trivial. It can be thought of as changing the <strong class="bold">Acme.Crm.Infrastructure</strong> project's name to <strong class="bold">Acme.Crm.EntityFrameworkCore</strong>. The next section will introduce a new project to the solution.</p>
			<h3>Introducing the application contracts</h3>
			<p>Currently, the <strong class="bold">Acme.Crm.Application</strong> project contains the application<a id="_idIndexMarker616"/> service classes. Therefore, the <strong class="bold">Acme.Crm.Web</strong> project references the <strong class="bold">Acme.Crm.Application</strong> project to use these services.</p>
			<p>This design has a problem: the <strong class="bold">Acme.Crm.Web</strong> project indirectly references the <strong class="bold">Acme.Crm.Domain</strong> project (over the <strong class="bold">Acme.Crm.Application</strong> project). This exposes the business objects (such as entities, domain services, and repositories) in the domain layer to the presentation layer and breaks the abstraction and true layering.</p>
			<p>The ABP startup template separates the application layer into two projects:</p>
			<ul>
				<li>The <code>IProductAppService</code>) and the related DTOs (such as <code>ProductCreationDto</code>).</li>
				<li>The <code>ProductAppService</code>).</li>
			</ul>
			<p>Introducing contracts (interfaces) for the application services has two important advantages:</p>
			<ul>
				<li>The UI layer (the <strong class="bold">Acme.Crm.Web</strong> project here) can depend on the service contracts without depending on the implementation, and therefore the domain layer.</li>
				<li>You can share the <strong class="bold">Acme.Crm.Application.Contracts</strong> project with a client application to rely on the same service interfaces and reuse the same DTO classes without sharing your business layers.</li>
			</ul>
			<p>The EventHub reference solution (introduced in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>) takes advantage of this design and reuses the <strong class="bold">Application.Contracts</strong> project between the UI and the HTTP API applications. This way, it easily sets up a tiered architecture where the application layer and the presentation layer are hosted in different applications yet share service contracts.</p>
			<p>By separating the application contracts project, the current solution structure will look like the one in the following figure:</p>
			<div><div><img src="img/Figure_9.06_B17287.jpg" alt="Figure 9.6 – Introducing the application contracts project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Introducing the application contracts project</p>
			<p>With this new design, the project dependency graph will be like in the following figure:</p>
			<div><div><img src="img/Figure_9.07_B17287.jpg" alt="Figure 9.7 – Project dependencies for the application contracts project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Project dependencies for the application contracts project</p>
			<p>The <strong class="bold">Acme.Crm.Web</strong> project now only depends on the <strong class="bold">Acme.Crm.Application.Contracts</strong> project and should always use the application<a id="_idIndexMarker617"/> service interfaces to perform the user interactions.</p>
			<p>The <strong class="bold">Acme.Crm.Web</strong> project still depends on the <strong class="bold">Acme.Crm.Application</strong> and <strong class="bold">Acme.Crm.EntityFrameworkCore</strong> projects since we need them at runtime. I have drawn these dependencies with dashed lines to indicate that these project dependencies should not exist in an ideal design, but are necessary for now. I will explain how we can get rid of those dependencies in the <em class="italic">Separating the hosting from the UI</em> section.</p>
			<p>Separating the application contracts from the implementation brings a small problem that we will solve in the next section.</p>
			<h3>Introducing the domain shared project</h3>
			<p>Once we have separated the contracts, we can no longer use the objects of the domain layer inside the contracts project because they have no reference to the domain layer, as shown in the previous section. This doesn't seem to be a problem at first glance. We shouldn't use these entities and other business objects in the application service contracts anyway – we should use DTOs instead. However, we still may want to reuse some types or values defined in the domain project.</p>
			<p>For example, we may want to reuse a <code>ProductType</code> enum in a DTO class or depend on the same constant value for the <a id="_idIndexMarker618"/>product name's maximum length. We don't want to duplicate such code parts, but we also can't add a reference to the <strong class="bold">Acme.Crm.Domain</strong> project from the <strong class="bold">Acme.Crm.Application.Contracts</strong> project. The solution is to introduce a new project to declare such types and values.</p>
			<p>We will name this new project <strong class="bold">Acme.Crm.Domain.Shared</strong> since this project will be part of the domain layer and shared with the rest of the solution. This project won't contain so many types in practice, but we still don't want to duplicate these types.</p>
			<p>With the introduction of the <strong class="bold">Acme.Crm.Domain.Shared</strong> project, the new solution structure will be as follows:</p>
			<div><div><img src="img/Figure_9.08_B17287.jpg" alt="Figure 9.8 – Introducing the domain shared project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Introducing the domain shared project</p>
			<p>The following diagram shows the dependencies between the projects in the solution:</p>
			<div><div><img src="img/Figure_9.09_B17287.jpg" alt="Figure 9.9 – Project dependencies for the domain shared project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Project dependencies for the domain shared project</p>
			<p>The new <strong class="bold">Acme.Crm.Domain.Shared</strong> project is used by the <strong class="bold">Acme.Crm.Domain</strong> and <strong class="bold">Acme.Crm.Application.Contracts</strong> projects. In this way, directly or indirectly, all the other projects in the solution can use the types in that new project.</p>
			<p>At this point, the fundamental layers of the ABP startup solution are complete. However, if you look at <em class="italic">Figure 9.4</em>, you will see that the ABP startup solution has three more projects. We will discuss these in the following subsections.</p>
			<h3>Introducing the HTTP API layer</h3>
			<p>In <em class="italic">Figure 9.4</em>, you can see that the ABP startup solution has two HTTP-related projects. </p>
			<p>First, the <strong class="bold">Acme.Crm.HttpApi</strong> project contains<a id="_idIndexMarker619"/> the API Controllers (that is, the REST APIs) of the solution. This project was introduced with the idea that separating the API from the UI would be better to organize and develop the solution.</p>
			<p>Separating the HTTP API layer as a class library project makes some advanced scenarios possible by allowing them to be reused. The EventHub solution takes advantage of this separation by using the HTTP API layer as a proxy in the UI layer (the UI and HTTP API are hosted in different applications in that solution). See the <em class="italic">Main website</em> and <em class="italic">Main HTTP API</em> sections of <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>, to learn how it works.</p>
			<p>The second HTTP API-related project is <strong class="bold">Acme.Crm.HttpApi.Client</strong>. This is a class library project that is not being used for this example<a id="_idIndexMarker620"/> solution but can be used in more advanced scenarios. You can use this library from a client application (it can be your application or a third-party .NET client) to easily consume your HTTP APIs. It uses ABP's Dynamic C# Client Proxy system, as will be explained in <a href="B17287_14_Epub_AM.xhtml#_idTextAnchor429"><em class="italic">Chapter 14</em></a>, <em class="italic">Building HTTP APIs and Real-Time Services</em>. Most of the time, you don't make any changes to this project, but it <em class="italic">automagically</em> works. The EventHub solution uses this technique to perform HTTP API requests from the UI application.</p>
			<p>By adding two new projects for the HTTP API layer, we now have eight projects in the solution, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.10_B17287.jpg" alt="Figure 9.10 – Adding the HTTP API projects to the solution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – Adding the HTTP API projects to the solution</p>
			<p>The following diagram shows the new dependency graph after adding these new projects (this time, I've removed the <code>Acme.Crm.</code> prefix from the project names to make them fit into the diagram):</p>
			<div><div><img src="img/Figure_9.11_B17287.jpg" alt="Figure 9.11 – Project dependencies for the HTTP API layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – Project dependencies for the HTTP API layer</p>
			<p>The <strong class="bold">Acme.Crm.HttpApi</strong> and <strong class="bold">Acme.Crm.HttpApi.Client</strong> projects depend on the <strong class="bold">Acme.Crm.Application.Contracts</strong> project because the server and client share the same contracts (application service interfaces). The <strong class="bold">Acme.Crm.Web</strong> project depends on the <strong class="bold">Acme.Crm.HttpApi</strong> project since it serves the APIs at runtime. This example solution has a single application at runtime. You can revisit the EventHub solution structure that was provided in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>, to see these projects in a more complex environment with multiple applications at runtime.</p>
			<p class="callout-heading">Discarding the HTTP API Layer</p>
			<p class="callout">Not every application needs to have HTTP APIs (that is, REST APIs). In this case, you can even remove this project from the solution. Also, if you like, you can move your API controllers to the <strong class="bold">Acme.Crm.Web</strong> project and discard the <strong class="bold">Acme.Crm.HttpApi</strong> project.</p>
			<p>The next section will explain the last project in the solution.</p>
			<h3>Understanding the database migrator project</h3>
			<p>In <em class="italic">Figure 9.4</em>, there is one more<a id="_idIndexMarker621"/> project named <strong class="bold">Acme.Crm.DbMigrator</strong>. This is a console application that can be used to apply EF Core code-first migrations to the database. It is a utility application and not part of the essential solution, so there is no need to investigate its details here.</p>
			<p class="callout-heading">Test Projects in the Solution</p>
			<p class="callout">Besides these nine projects, there are six more projects in the solution under the <code>test</code> folder. They are unit/integration tests projects separately configured for each layer. One of them (<strong class="bold">Acme.Crm.HttpApi.Client.ConsoleTestApp</strong>) demonstrates how to consume HTTP APIs using the <strong class="bold">Acme.Crm.HttpApi.Client</strong> project. You can explore them yourself.</p>
			<p>These are all the projects in the ABP startup solution. The solution structure that's been provided is the architectural model, followed by all the pre-built official ABP application modules. This model makes it possible to reuse the application modules in various scenarios, thanks to its flexibility and modularity.</p>
			<p>In the next section, we will discuss an additional project that can be used to separate the hosting from the UI application.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor309"/>Separating the hosting from the UI</h2>
			<p>One annoying thing in the architectural model shown in <em class="italic">Figure 9.11</em> is that the <strong class="bold">Web</strong> project references the <strong class="bold">Application</strong> and <strong class="bold">EntityFramework</strong> projects. None of the pages/classes in the <strong class="bold">Web</strong> project directly use classes in these projects. However, since the <strong class="bold">Web</strong> project is the project that runs the application, we needed to reference these projects to make them available at runtime.</p>
			<p>This structure is not a big problem, so long as you do not accidentally leak your domain and database layer<a id="_idIndexMarker622"/> objects into the presentation (web) layer. However, if you are worried and do not want to set development time dependencies for these runtime dependencies, you can add one more project, <strong class="bold">Acme.Crm.Web.Host</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.12_B17287.jpg" alt="Figure 9.12 – Adding a separate hosting project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Adding a separate hosting project</p>
			<p>With this change, the <code>Startup.cs</code>, <code>Program.cs</code>, and <code>appsettings.json</code> files. The <strong class="bold">Acme.Crm.Web.Host</strong> project becomes responsible for hosting by bringing all the projects together at runtime. It doesn't contain any application UI page or component.</p>
			<p>I think this design is better. It gracefully extracts the hosting configuration details from the UI layer, removes the runtime dependencies, and keeps it more focused. However, we haven't separated the hosting application in the ABP startup template since most of the developers already find the ABP startup template complicated (compared to single-project ASP.NET Core startup templates). This is because there are many projects inside it, and we didn't want to add one more. I believe that a solution with multiple projects, and with less code in each project, is a better approach than a single project with everything in one place.</p>
			<p>You can find the solution with a separate host project in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting">https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting</a> and explore the structure provided.</p>
			<p>In this section, you understood the roles that each project has in the ABP startup template, so you should be more comfortable while developing your solutions. In the next section, we will briefly revisit the EventHub reference solution from a DDD perspective.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor310"/>Dealing with multiple applications</h1>
			<p>So, we've learned the purpose of each of the<a id="_idIndexMarker623"/> projects in the ABP startup solution. It is a good starting point for a well-architected software solution. It sets up the layers properly, with a single domain layer and a single application layer (which is used by a single web application). However, in the real world, software solutions may be more complex. You may have multiple applications (on the same system) or may need to separate your domain into multiple sub-domains to reduce the complexity of each sub-domain.</p>
			<p>DDD addresses the design of complex software solutions. One of the main purposes of separating the business logic into domain logic and application logic is to correctly organize your code base when there are multiple applications in your solution. When you have multiple applications, you have multiple application layers. Each of these layers implements the application-specific business logic of the related application, yet still shares the same core domain logic by using the same domain layer.</p>
			<p>The <em class="italic">EventHub</em> project (introduced in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>) has two web applications. One of these applications is the main website that is used by end users. The other one is the admin (back office) application, which is used by system administrators. These applications have different user interfaces, different use cases, different authorization rules, and different performance, localization, caching, and scaling requirements. Separating these differences into two application layers helps us isolate these application-specific business and infrastructure requirements from each other. These applications share the core business logic that we don't want to duplicate across the applications. This means that two application layers use the same domain layer, as shown in the following diagram:</p>
			<div><div><img src="img/Figure_9.13_B17287.jpg" alt="Figure 9.13 – EventHub – multiple application layers and a single domain layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – EventHub – multiple application layers and a single domain layer</p>
			<p>When we have multiple applications, separating the business <a id="_idIndexMarker624"/>logic between the application and domain layers becomes even more important. Leaking domain logic into the application layers duplicates it. On the other hand, placing application-specific logic in the domain layer leads you to coupling the business logic of different applications and writing many conditional statements to make the domain layer usable by these applications. Both of these situations make your code base buggy and difficult to maintain.</p>
			<p>Domain logic versus application logic separation is important. We will return to this topic in <a href="B17287_11_Epub_AM.xhtml#_idTextAnchor340"><em class="italic">Chapter 11</em></a>, <em class="italic">DDD – The Application Layer</em>, after understanding the domain layer and the application layer building blocks. But before that, let's continue with the big picture and learn how a web request is executed in a DDD-based application.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor311"/>Understanding the execution flow</h1>
			<p>We've introduced many building blocks and their descriptions, as well as how these building blocks are placed in layers in a .NET solution. In this section, we will explore how an HTTP request is executed in a typical web application that has been layered based on DDD. The following diagram shows the layers in action:</p>
			<div><div><img src="img/Figure_9.14_B17287.jpg" alt="Figure 9.14 – Execution flow through the layers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – Execution flow through the layers</p>
			<p>A request starts with a request from a client application. The client can be a browser that expects an HTML page (with its CSS/JavaScript files) or a data result (such as JSON). In this case, a Razor Page can process the request and returns an HTML page. If the application making the request is another kind of client (such as a console application), you probably respond to the request from an HTTP API (an API controller) endpoint and return a plain data result.</p>
			<p>The MVC page (in the presentation layer) processes the UI logic, may perform some data conversions, and delegates<a id="_idIndexMarker625"/> the actual operation to a method of an application<a id="_idIndexMarker626"/> in the application layer. The application service may take a DTO, implement the use case logic, and return a resulting DTO to the presentation layer.</p>
			<p>The application service internally uses the domain objects (entities, repositories, domain services, and more) to coordinate the business operation. The business operation should be a unit of work. This means it should be atomic. All the database operations in a use case (typically, an application method) should be committed or rolled back together.</p>
			<p>The presentation and application layers typically implement the cross-cutting concerns, such as authorization, validation, exception handling, caching, audit logging, and so on.</p>
			<p>As you learned in the previous chapters, ABP Framework provides a complete infrastructure for all these cross-cutting concerns<a id="_idIndexMarker627"/> and automates them wherever possible. It also<a id="_idIndexMarker628"/> provides proper base classes and practical conventions to help you structure your business components and implement DDD with best practices.</p>
			<p>As the last part of this chapter, we will see some common principles of DDD in the next section.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor312"/>Understanding the common principles</h1>
			<p>DDD focuses on how you design<a id="_idIndexMarker629"/> your business code. It cares about state changes and how the business objects interact – how to create an entity, how to change its properties by applying (and even forcing) the business rules and constraints, and how to preserve the data validity and integrity.</p>
			<p>DDD doesn't care about reporting or mass querying. You may take the power of a reporting tool to create cool dashboards for your application. You can fully use your underlying database provider's features for high performance. You can even duplicate the data in another database provider for read-only reporting purposes. You are free to do anything, so long as you don't mix the infrastructure details with your business code. All these are the concerns we should care about as a developer, but DDD doesn't care.</p>
			<p>DDD also doesn't care about the infrastructure details; you are expected to isolate your business code from these details with proper abstractions. Two of these abstractions are especially important since they take a big place in your code base: the presentation technology and the database provider. In the next few sections, I will explain these two principles and discuss if we need to implement them.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor313"/>Database provider independence</h2>
			<p>It is a good practice to abstract<a id="_idIndexMarker630"/> the database integration<a id="_idIndexMarker631"/> in a DDD-based software solution. Your domain and application layers should be database and even ORM independent, in theory. There are some good reasons behind this suggestion. If you implement it, the following will occur:</p>
			<ul>
				<li>Your database provider (ORM or DBMS) may change in the future without affecting your business code. This makes your business code longer-lived.</li>
				<li>Your domain and application layers become more focused on your business code by hiding the data access logic behind the repositories.</li>
				<li>You can mock the database layer for automated tests more efficiently.</li>
			</ul>
			<p>The ABP startup template follows this principle – it doesn't include references to the database provider from the domain and application layers. ABP Framework already provides the infrastructure to implement the repository pattern easily. The ABP startup template also comes with the database layer, which uses an in-memory database instance for automated tests.</p>
			<p>The last two of these reasons<a id="_idIndexMarker632"/> are important and easy to apply with ABP Framework. However, the first one<a id="_idIndexMarker633"/> is not so easy. In the beginning, it seems like you make your business code ORM/database independent when you place your data access logic behind the repositories. However, it is not that simple. Let's assume that you are currently using EF Core with SQL Server (a relational database) and want to design your business code and entities so that you can easily switch to MongoDB (a document database) later. If you want to accomplish that, you must take the following into account:</p>
			<ul>
				<li>You can't assume that you have the change tracking system of EF Core because the MongoDB .NET driver doesn't provide that feature. So, you should always manually update the changed entities at the end of your business logic.</li>
				<li>You can't add navigation or collection properties to your entity where these properties are types of other aggregates. You must strictly implement the aggregate pattern (as will be explained in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>) by respecting the aggregate boundaries. This restriction deeply affects your entity design and the business code that works on your entities.</li>
			</ul>
			<p>As you can see, being database-agnostic requires care when it comes to designing the entity and affects your code base.</p>
			<p>You may be wondering, do you need it? Will you change the database provider in the future? If you change it later, how much effort do you need to make regarding that change? Is it more than your current effort to make it database-independent? Even if you try to do it, will it be truly database-independent (you may not know it before trying to switch)?</p>
			<p>All ABP pre-built application<a id="_idIndexMarker634"/> modules are designed to be independent of the database provider, and the same business<a id="_idIndexMarker635"/> code works both on EF Core and MongoDB. This is necessary since they are reusable modules and can't assume a database provider. On the other hand, a final application can make this assumption. I still suggest hiding the data access code behind the repositories, and ABP makes this very easy. However, if you want to go with an EF Core dependency, I see no problem with that.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor314"/>Presentation technology-agnostic</h2>
			<p>UI frameworks are the most dynamic systems in the software industry. There are plenty of alternatives, and the trending approaches<a id="_idIndexMarker636"/> and tools are rapidly changing. Coupling your business code with your UI<a id="_idIndexMarker637"/> code would be a bad idea.</p>
			<p>Implementing this principle is more important and relatively easier, especially with ABP Framework. The ABP startup template comes with proper layering. ABP Framework provides many abstractions that you can use in your application and domain layers without depending on ASP.NET Core or any other UI framework.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor315"/>Summary</h1>
			<p>In this first chapter on DDD, we looked at the four fundamental layers and the core building blocks in these layers. The ABP startup template is more complex than that four-layered structure. You learned how the startup template has evolved by one change at a time, and you understood the reasons behind these changes.</p>
			<p>Regarding DDD, you learned that the business logic is separated into two layers: the application layer and the domain layer. We discussed how to deal with multiple applications that share the same domain logic by referencing the EventHub example solution.</p>
			<p>We then understood how an HTTP request is executed and passed through the layers in a typical DDD-based software. Finally, we discussed isolating your application and domain layers from the infrastructure details, especially the database providers and UI frameworks.</p>
			<p>This chapter aimed to show the big picture and the fundamental concepts of DDD. The next chapter will focus on implementing domain layer building blocks, such as aggregates, repositories, and domain services.</p>
		</div>
	</body></html>