- en: '*Chapter* *5*: Asynchronous Programming with C#'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：使用 C# 进行异步编程'
- en: The .NET `async` and `await` keywords, was introduced in .NET Framework 4.5\.
    The C# language’s support for these keywords was released at the same time in
    C# 5\. Now, a decade later, the TAP model is an integral part of most .NET developers’
    toolsets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的 `async` 和 `await` 关键字是在 .NET Framework 4.5 中引入的。这些关键字在 C# 5 中与 C# 语言一起发布。现在，十年过去了，TAP
    模型已成为大多数 .NET 开发者工具集的一个组成部分。
- en: This chapter will explain asynchronous programming in C#, explore how to use
    `Task` objects, and delve into best practices of using `async` and `await` for
    **I/O-bound** and **CPU-bound** scenarios with .NET.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释 C# 中的异步编程，探讨如何使用 `Task` 对象，并深入研究使用 `async` 和 `await` 在 .NET 中针对 **I/O
    绑定** 和 **CPU 绑定** 场景的最佳实践。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下内容：
- en: More about asynchronous programming in .NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 .NET 异步编程的信息
- en: Working with Task objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Task 对象一起工作
- en: Interop with synchronous code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与同步代码的互操作
- en: Working with multiple background tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个后台任务一起工作
- en: Asynchronous programming best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程最佳实践
- en: By the end of this chapter, you will have a deeper understanding of asynchronous
    programming and should feel confident enough to add advanced async features to
    your team’s projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对异步编程有更深入的理解，并且应该有足够的信心将高级异步功能添加到团队的项目中。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using the .NET **command-line interface** (**CLI**)
    and Visual Studio Code to build and run the sample projects. To follow along with
    the examples, the following software is recommended:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 .NET **命令行界面**（**CLI**）和 Visual Studio Code 来构建和运行示例项目。为了跟随示例，以下软件是推荐的：
- en: Visual Studio Code version 1.65 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code 版本 1.65 或更高版本
- en: .NET 6 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6 或更高版本
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 version 17.0 or later if you
    are using Windows 10 or 11, Visual Studio 2022 for Mac on macOS 10.13 or later,
    or JetBrains Rider will work just as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐的，但如果已经安装了 .NET 6，你可以使用你喜欢的编辑器。例如，如果你使用的是 Windows 10 或 11，则可以使用 Visual
    Studio 2022 版本 17.0 或更高版本，如果你使用的是 macOS 10.13 或更高版本，则可以使用 Visual Studio 2022 for
    Mac，或者 JetBrains Rider 也可以正常工作。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter05)。
- en: Let’s get started by working our way through some examples that use the TAP
    model with `async` and `await`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通过一些使用 `async` 和 `await` 的 TAP 模型示例开始吧。
- en: More about asynchronous programming in .NET
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于 .NET 异步编程的信息
- en: 'There are two types of scenarios where async code is usually introduced:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码通常被引入的两个场景类型：
- en: '**I/O-bound operations**: These involve resources fetched from the network
    or disk.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O 绑定操作**：这些涉及从网络或磁盘获取的资源。'
- en: '**CPU-bound operations**: These are in-memory, CPU-intensive operations.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU 绑定操作**：这些是在内存中进行的、CPU 密集型操作。'
- en: In this section, we will create some real-world examples that use `async` and
    `await` for each type of operation. Whether you are waiting for an external process
    to complete or performing CPU-intensive operations within your application, you
    can leverage asynchronous code to improve your application’s performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一些使用 `async` 和 `await` 为每种操作类型提供真实世界示例。无论你是等待外部进程完成，还是在你的应用程序中执行 CPU
    密集型操作，你都可以利用异步代码来提高应用程序的性能。
- en: Let’s start by looking at some examples of I/O-bound operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一些 I/O 绑定操作的示例。
- en: I/O-bound operations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 绑定操作
- en: When you are working with I/O-bound code that is constrained by file or network
    operations, your code should use `async` and `await` to wait for the operations
    to complete.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理受文件或网络操作约束的 I/O 绑定代码时，你的代码应该使用 `async` 和 `await` 来等待操作完成。
- en: 'The .NET methods to perform network and file I/O are asynchronous, so the use
    of `Task.Run` will not be necessary:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 用于执行网络和文件 I/O 的方法都是异步的，因此不需要使用 `Task.Run`：
- en: '`ReadToEndAsync` method, splits the text where `Environment.NewLine` characters
    are found, and returns the data as a `List<string>` instance. Each line of text
    from the file is an item in the list:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadToEndAsync`方法在`Environment.NewLine`字符处分割文本，并将数据作为`List<string>`实例返回。文件中的每一行文本都是列表中的一个项：'
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`HttpClient` class to download a file from the provided URL with the `await`
    keyword before splitting and returning the lines of text in a list:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HttpClient`类下载提供的URL上的文件，在分割并返回文本行的列表之前，使用`await`关键字：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Those are some common I/O-bound operations, but what is a CPU-bound operation
    and how does it differ?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些常见的I/O密集型操作，但什么是CPU密集型操作，它与I/O密集型操作有何不同？
- en: CPU-bound operations
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU密集型操作
- en: In this case, your application is not waiting for an external process to complete.
    The application itself is performing a CPU-intensive operation that takes time
    to complete, and you want the application to remain responsive until the operation
    has finished.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的应用程序不是在等待外部过程完成。应用程序本身正在执行一个需要时间才能完成的CPU密集型操作，并且你希望应用程序在操作完成之前保持响应。
- en: 'In this example, we have a method that accepts a `List<string>` instance where
    each item in the list contains an XML representation of this `JournalEntry` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个接受`List<string>`实例的方法，其中列表中的每个项都包含这个`JournalEntry`类的XML表示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s assume that `EntryText` can be extremely large because some users who
    write in the journal application will add dozens of pages of text to a single
    entry. Each entry is stored in a database as XML and the application that loads
    the entries has a `DeserializeEntries` method to deserialize each XML string and
    return the data as a `List<JournalEntry>` instance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`EntryText`可以非常大，因为一些在日志应用程序中写作的用户会为单个条目添加数十页的文本。每个条目都以XML格式存储在数据库中，加载条目的应用程序有一个`DeserializeEntries`方法，用于反序列化每个XML字符串，并将数据作为`List<JournalEntry>`实例返回：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After months of adding journal entries, users are complaining about the time
    it takes to load the existing entries. They would like to start creating a new
    entry while the data is loading.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了几个月的日志条目之后，用户抱怨加载现有条目所需的时间。他们希望在数据加载时开始创建新条目。
- en: 'Luckily, using asynchronous .NET code can keep an application’s user interface
    responsive while waiting for a long-running process to complete. The thread is
    free to perform other work until the non-blocking call is completed. By adding
    an async method named `DeserializeJournalDataAsync` that calls the existing method
    with an awaited `Task.Run` method, the client code can remain responsive while
    users create new journal entries:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用异步.NET代码可以在等待长时间运行的过程完成时保持应用程序的用户界面响应。线程可以在非阻塞调用完成之前自由执行其他工作。通过添加一个名为`DeserializeJournalDataAsync`的异步方法，该方法使用`await`的`Task.Run`方法调用现有方法，客户端代码可以在用户创建新的日志条目时保持响应：
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you’re working with serialized data in JSON format instead of XML, the synchronous
    and asynchronous methods of deserialization are very similar. This is because
    .NET provides both the `Deserialize` and `DeserializeAsync` methods in the `System.Text.Json.JsonSerializer`
    class. Here are both methods with their differences highlighted:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用JSON格式的序列化数据而不是XML，反序列化的同步和异步方法非常相似。这是因为.NET在`System.Text.Json.JsonSerializer`类中提供了`Deserialize`和`DeserializeAsync`方法。以下是这两种方法，其中突出了它们之间的差异：
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Deserialize` method accepts `string`, but `DeserializeAsync` does not.
    Instead, we must create a `MemoryStream` instance from the `jsonEntry` string
    to pass to `DeserializeAsync`. Other than that, only the return types of the methods
    differ.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deserialize`方法接受`string`，但`DeserializeAsync`不接受。相反，我们必须从`jsonEntry`字符串创建一个`MemoryStream`实例，并将其传递给`DeserializeAsync`。除此之外，只有方法的返回类型不同。'
- en: 'Let’s wrap up this section by looking at one more method for handling JSON
    deserialization of a list of journal entries. In this example, the method that
    deserializes the data only processes a single JSON entry. A parent method named
    `GetJournalEntriesAsync` uses a LINQ `Select` operator to call `DeserializeJsonEntryAsync`
    for each string in the list and stores an `IEnumerable<Task<JournalEntry>>` instance
    in a `getJournalTasks` variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一个处理JSON反序列化日志条目列表的另一个方法来结束本节。在这个例子中，仅处理单个JSON条目的方法。一个名为`GetJournalEntriesAsync`的父方法使用LINQ的`Select`运算符对列表中的每个字符串调用`DeserializeJsonEntryAsync`，并将`IEnumerable<Task<JournalEntry>>`实例存储在`getJournalTasks`变量中：
- en: '[PRE59]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The highlighted code awaits all the `Task` objects in `journalTasks`, returning
    the results of every call as an array of `JournalEntry` objects. You can either
    declare `GetJournalEntriesAsync` with a return type of `Task<JournalEntry[]>`
    or use `ToList`, as we have in this sample, to return `Task<List<JournalEntry>>`.
    You can see how LINQ streamlines your code when it is necessary to iterate over
    a list of items and make an async call with each item.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码等待 `journalTasks` 中的所有 `Task` 对象，将每个调用的结果作为 `JournalEntry` 对象的数组返回。你可以声明
    `GetJournalEntriesAsync` 的返回类型为 `Task<JournalEntry[]>`，或者像我们在本示例中那样使用 `ToList`
    返回 `Task<List<JournalEntry>>`。你可以看到当需要遍历一个项目列表并对每个项目进行异步调用时，LINQ 如何简化你的代码。
- en: You have seen some different ways to use async and await in your code for both
    I/O-bound and CPU-bound operations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在代码中使用异步和 `await` 的不同方法，无论是针对 I/O 密集型操作还是 CPU 密集型操作。
- en: Next, we will discuss how **nested async methods** are chained and how to start
    the top level of that chain.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何链式调用嵌套异步方法以及如何启动该链的最高层。
- en: Nested async methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套异步方法
- en: When it comes to using async methods, it is important to use `await` when you
    want to preserve the order of execution. It is also important to preserve that
    chain of awaited calls to the entry point for the current thread.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用异步方法时，当您想要保持执行顺序时，使用 `await` 是很重要的。同样重要的是要保留对当前线程入口点的等待调用链。
- en: For example, if your application is a console application, the primary entry
    point is the `Main` method in `Program.cs`. If you cannot make this `Main` method
    `async`, then none of the method calls beneath `Main` are made with the `await`
    keyword. That is the reason why .NET now supports `async` `Main` methods. Now,
    when you create a new console application with .NET 6, it has an `async` `Main`
    method by default.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的应用程序是一个控制台应用程序，主要的入口点是 `Program.cs` 中的 `Main` 方法。如果你不能使这个 `Main` 方法变为
    `async`，那么在 `Main` 之下的所有方法调用都不会使用 `await` 关键字。这就是为什么 .NET 现在支持 `async` `Main`
    方法的原因。现在，当你使用 .NET 6 创建一个新的控制台应用程序时，它默认有一个 `async` `Main` 方法。
- en: 'If the entry point for execution is an event handler, you should mark the event
    handler method as `async`. This is the only time you will see `async` methods
    with a `void` return type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行的入口点是事件处理器，你应该将事件处理器方法标记为 `async`。这是唯一一次你会看到具有 `void` 返回类型的 `async` 方法：
- en: '[PRE76]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let’s look at an example of the right way to chain multiple nested async methods
    in a console application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在控制台应用程序中正确链式调用多个嵌套异步方法的例子：
- en: 'Start by creating a new console application. Inside a folder named `AsyncSamples`,
    run the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的控制台应用程序。在名为 `AsyncSamples` 的文件夹内，运行以下命令：
- en: '[PRE81]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: When the process completes, open the new `AsyncSamples.csproj` in Visual Studio
    Code or your editor of choice.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当进程完成后，在 Visual Studio Code 或你选择的编辑器中打开新的 `AsyncSamples.csproj` 文件。
- en: Add a new class to the project named `TaskSample`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `TaskSample` 的新类
- en: 'Add the following code to the `TaskSample` class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `TaskSample` 类中：
- en: '[PRE82]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now open `Program.cs` and add some code to call `DoThingsAsync`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `Program.cs` 并添加一些代码来调用 `DoThingsAsync`：
- en: '[PRE83]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let’s illustrate the order and hierarchy of the methods being called by our
    project. The `Main` method calls `DoThingsAsync`, which in turn calls `DoFirstThingAsync`
    and `DoSecondThingAsync`. Finally, within `DoFirstThingAsync`, `DoAnotherThingAsync`
    is called. When each of these `async` methods is called with the `await` operator,
    the order of operations is predictable:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的项目调用的方法的顺序和层次结构来举例说明。`Main` 方法调用 `DoThingsAsync`，然后 `DoThingsAsync`
    又依次调用 `DoFirstThingAsync` 和 `DoSecondThingAsync`。最后，在 `DoFirstThingAsync` 中，调用了
    `DoAnotherThingAsync`。当使用 `await` 操作符调用每个这些 `async` 方法时，操作顺序是可预测的：
- en: '![Figure 5.1: The order of operations for awaited methods ](img/Figure_5.1_B18552.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：等待方法的操作顺序](img/Figure_5.1_B18552.jpg)'
- en: 'Figure 5.1: The order of operations for awaited methods'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：等待方法的操作顺序
- en: 'Run the program and examine the order of the console output. Everything should
    be executing in the expected order:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并检查控制台输出的顺序。一切都应该按照预期的顺序执行：
- en: '![Figure 5.2: Examining the output of the AsyncSamples console application
    ](img/Figure_5.2_B18552.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：检查 AsyncSamples 控制台应用程序的输出](img/Figure_5.2_B18552.jpg)'
- en: 'Figure 5.2: Examining the output of the AsyncSamples console application'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：检查 AsyncSamples 控制台应用程序的输出
- en: 'Next, we will add two additional methods to the `TaskSample` class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向 `TaskSample` 类添加两个额外的函数：
- en: '[PRE84]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `DoingThingsWrongAsync` method has removed the `await` from the call to
    `DoFirstThingAsync`. So, the execution of `DoSecondThingAsync` will begin before
    `DoFirstThingAsync` has been completed. That might be OK if none of the subsequent
    code relies on the processing that happens within `DoFirstThingAsync`. However,
    any unhandled exceptions inside a method that is not awaited will not automatically
    bubble up to the `calling` method. The `Task` instance for the call will have
    a `Status` value of `Faulted`, the `IsFaulted` property will be `true`, and the
    `Exception` property will contain the unhandled exception information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoingThingsWrongAsync` 方法已经从对 `DoFirstThingAsync` 的调用中移除了 `await`。因此，`DoSecondThingAsync`
    的执行将在 `DoFirstThingAsync` 完成之前开始。如果后续代码没有依赖于 `DoFirstThingAsync` 内部发生的处理，这可能没问题。然而，任何未处理的异常都不会自动向上冒泡到
    `调用` 方法。对于该调用的 `Task` 实例，其 `Status` 值将为 `Faulted`，`IsFaulted` 属性将为 `true`，而 `Exception`
    属性将包含未处理的异常信息。'
- en: In the preceding case, any unhandled exceptions in `DoFirstThingAsync` will
    go undetected. If you have a case where you are not awaiting a `Task` instance,
    be sure to monitor the status of the `Task` instance in case of exceptions. This
    is one of the reasons why you should never have an `async void` method. It does
    not return a `Task` instance to be awaited.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`DoFirstThingAsync` 中的任何未处理的异常都将不会被检测到。如果你有一个没有等待 `Task` 实例的情况，确保在出现异常的情况下监控
    `Task` 实例的状态。这也是为什么你不应该有 `async void` 方法的原因之一。它不会返回一个 `Task` 实例来等待。
- en: The `DoBlockingThings` method will maintain the correct order of operations,
    but by calling `DoFirstThingAsync().Wait()` instead of awaiting the call, the
    thread executing `DoBlockingThings` will be blocked. It will wait for the call
    to `DoFirstThingAsync` to complete instead of being free to pick up other work
    until the long-running async method completes. Using blocking calls such as `Wait()`
    or `Result` can quickly deplete the available threads in `ThreadPool`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoBlockingThings` 方法将保持操作的正确顺序，但通过调用 `DoFirstThingAsync().Wait()` 而不是等待调用，执行
    `DoBlockingThings` 的线程将被阻塞。它将等待 `DoFirstThingAsync` 的调用完成，而不是在长时间运行的异步方法完成之前自由地执行其他工作。使用
    `Wait()` 或 `Result` 等阻塞调用可以快速耗尽 `ThreadPool` 中可用的线程。'
- en: 'Update `Program.cs` to call all three of the public `TaskSample` methods:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 更新为调用所有三个公共 `TaskSample` 方法：
- en: '[PRE85]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now run the program and examine the console output to see how it is impacted
    by omitting `await` inside `DoingThingsWrongAsync`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行程序并检查控制台输出，以查看省略 `DoingThingsWrongAsync` 内部的 `await` 对其有何影响：
- en: '![Figure 5.3: Console output when calling all the TaskSample methods ](img/Figure_5.3_B18552.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：调用所有 TaskSample 方法时的控制台输出](img/Figure_5.3_B18552.jpg)'
- en: 'Figure 5.3: Console output when calling all the TaskSample methods'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：调用所有 TaskSample 方法时的控制台输出
- en: The output may differ a little each time, depending on how the `ThreadPool`
    threads are allocated. In this case, the second call to `DoFirstThingAsync` remains
    incomplete until the third call to that same method starts. Even though `Program.cs`
    awaits its call to `DoingThingsWrongAsync`, the code inside of that method was
    still executing after the next call to `DoBlockingThingsAsync` was invoked.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会因 `ThreadPool` 线程的分配方式而略有不同。在这种情况下，对 `DoFirstThingAsync` 的第二次调用在第三次调用同一方法开始之前保持未完成状态。即使
    `Program.cs` 等待其 `DoingThingsWrongAsync` 的调用，在该方法内部的代码在 `DoBlockingThingsAsync`
    的下一次调用被触发后仍然在执行。
- en: Things can get very unpredictable when async tasks are not awaited. You should
    always await a task unless you have a good reason not to do so. Next, let’s explore
    some properties and methods available in the `Task` class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步任务没有被等待时，事情可能会变得非常不可预测。除非你有充分的理由不这样做，否则你应该始终等待任务。接下来，让我们探索 `Task` 类中可用的某些属性和方法。
- en: Working with Task objects
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与任务对象一起工作
- en: Working directly with `Task` objects can be extremely useful when introducing
    threading to existing projects. As we saw in the previous section, it is important
    to update the entire call stack when introducing `async` and `await`. On a large
    code base, those changes could be extensive and would require quite a bit of regression
    testing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在将线程引入现有项目时，直接与 `Task` 对象一起工作可能非常有用。正如我们在上一节中看到的，引入 `async` 和 `await` 时更新整个调用栈非常重要。在一个大型代码库中，这些更改可能是广泛的，并且需要进行相当多的回归测试。
- en: You can instead use `Task` and `Task<TResult>` to wrap the existing methods
    that you want to run asynchronously. Both `Task` types represent the asynchronous
    work being done by a method or action. You use `Task` when a method would have
    otherwise returned void. Use `Task<TResult>` with methods that have a non-void
    return type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Task` 和 `Task<TResult>` 来包装你想异步运行的方法。这两种 `Task` 类型代表方法或动作正在执行的非阻塞工作。当你想使用返回
    void 的方法时，使用 `Task`。对于具有非 void 返回类型的方法，使用 `Task<TResult>`。
- en: 'Here are examples of two synchronous method signatures and their async equivalents:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个同步方法签名及其异步等价的例子：
- en: '[PRE86]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We have seen some examples of using `Task` objects in this chapter. Now it is
    time to explore additional properties, methods, and uses of these two types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中看到了一些使用 `Task` 对象的例子。现在，是时候探索这两个类型的额外属性、方法和用途了。
- en: Exploring Task methods
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Task 方法
- en: 'To start, we will discover some commonly used `Task` methods in practical examples.
    Consider the ProcessOrders method that accepts a list of orders to be processed
    and submitted. The four `Task` methods used are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过实际例子发现一些常用的 `Task` 方法。考虑接受要处理和提交的订单列表的 `ProcessOrders` 方法。使用的四个 `Task`
    方法如下：
- en: '`Task.Run`: Runs a method on a thread on the thread pool'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Run`: 在线程池上的线程上运行一个方法'
- en: '`Task.Factory.StartNew`: Runs a method on a thread on the thread pool, with
    `TaskCreationOptions` provided'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew`: 在线程池上的线程上运行一个方法，并提供 `TaskCreationOptions`'
- en: '`processOrdersTask.ContinueWith`: When the `processOrdersTask` completes, it
    will execute the method provided on the same thread pool thread.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processOrdersTask.ContinueWith`: 当 `processOrdersTask` 完成，它将在同一个线程池线程上执行提供的方法。'
- en: '`Task.WaitAll`: This method will block the current thread and wait for all
    tasks in the array.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WaitAll`: 此方法将阻塞当前线程并等待数组中的所有任务。'
- en: 'These methods have been highlighted in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在以下代码中被突出显示：
- en: '[PRE93]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This is what is happening on each line of the preceding example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面例子中每一行发生的事情：
- en: '`Task.Run` will create a new background thread and queue it on `ThreadPool`'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.Run` 将创建一个新的后台线程并将其队列在 `ThreadPool` 上'
- en: '`Task.Factory.StartNew` will also create a new background thread and queue
    it on `ThreadPool`. In addition, we are providing `TaskCreattionOptions.LongRunning`
    as a parameter of `StartNew` to indicate that creating additional threads is warranted
    because this task may take a while to complete. This will prevent delays for other
    tasks queued on `ThreadPool`.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew` 也会创建一个新的后台线程，并将其队列在 `ThreadPool` 上。此外，我们为 `StartNew`
    提供了 `TaskCreattionOptions.LongRunning` 作为参数，以表明创建额外的线程是合理的，因为此任务可能需要一段时间才能完成。这将防止其他任务在
    `ThreadPool` 上排队时的延迟。'
- en: '`ContinueWith` will queue `SendOrders` on a `ThreadPool` thread, but the thread
    will not start until `processOrdersTask` has been completed.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ContinueWith` 将 `SendOrders` 队列在 `ThreadPool` 线程上，但线程不会启动，直到 `processOrdersTask`
    完成。'
- en: '`Task.WaitAll` is the synchronous equivalent of the `async` method, `Task.WhenAll`.
    It will block the current thread until `labelTask` and `sendTask` are complete.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.WaitAll` 是 `async` 方法 `Task.WhenAll` 的同步等价。它将阻塞当前线程，直到 `labelTask` 和
    `sendTask` 完成。'
- en: Finally, `SendConfirmation` is called to notify the customer that their orders
    have been processed and sent.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用 `SendConfirmation` 通知客户他们的订单已处理并发送。
- en: Using tasks in this way can achieve the same result as an `async` method that
    awaits tasks to achieve parallel processing. The main difference is that the current
    thread will be blocked at *step 4* when `WaitAll` is called.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用任务可以达到与等待任务以实现并行处理相同的结果的 `async` 方法。主要区别在于，当调用 `WaitAll` 时，当前线程将在 *步骤
    4* 处被阻塞。
- en: Another useful method we will explore next is `RunSynchronously`. This starts
    a task but executes it synchronously on the current thread. The asynchronous equivalent
    is to call `Start` on a task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探索的另一个有用的方法是 `RunSynchronously`。这个方法启动一个任务，但在当前线程上同步执行。异步等价方法是调用任务上的 `Start`。
- en: 'In this example, the `ProcessData` method accepts a parameter indicating whether
    the data must be processed on the UI thread. It is possible that some data processing
    requires interacting with the UI to present the user with some options or other
    feedback:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ProcessData` 方法接受一个参数，指示数据是否必须在 UI 线程上处理。可能有些数据处理需要与 UI 交互，向用户展示一些选项或其他反馈：
- en: '[PRE106]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Next, let’s explore some of the properties of the `Task` and `Task<TResult>`
    classes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索 `Task` 和 `Task<TResult>` 类的一些属性。
- en: Exploring Task properties
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Task 属性
- en: 'In this section, we will review the properties available on a `Task` object.
    Most of the properties are related to the status of a task, so we will start with
    the `Status` property. The `Status` property returns `TaskStatus`, which is an
    enumeration with eight possible values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾`Task`对象上可用的属性。大多数属性都与任务的状态相关，因此我们将从`Status`属性开始。`Status`属性返回`TaskStatus`，它是一个具有八个可能值的枚举：
- en: '`Created (0)`: The task has been created and initialized but has not been scheduled
    on `ThreadPool`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created (0)`: 任务已被创建和初始化，但尚未在`ThreadPool`上安排。'
- en: '`WaitingForActivation (1)`: The task is waiting to be scheduled by .NET'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingForActivation (1)`: 任务正在等待.NET进行安排'
- en: '`WaitingToRun (2)`: The task has been scheduled but has not started executing
    yet'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingToRun (2)`: 任务已被安排，但尚未开始执行'
- en: '`Running (3)`: The task is currently running.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running (3)`: 任务目前正在运行。'
- en: '`WaitingForChildrenToComplete (4)`: The task has been completed but there are
    attached child tasks that are still running or waiting to run'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingForChildrenToComplete (4)`: 任务已完成，但有附加的子任务仍在运行或等待运行'
- en: '`RanToCompletion (5)`: The task successfully ran to completion'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RanToCompletion (5)`: 任务成功运行到完成'
- en: '`Canceled (6)`: The task was canceled and acknowledged the cancellation'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Canceled (6)`: 任务被取消并确认了取消'
- en: '`Faulted (7)`: An unhandled exception was encountered while executing the task'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Faulted (7)`: 在执行任务时遇到了未处理的异常'
- en: 'The following properties of `Task` and `Task<TResult>` are shortcuts to check
    statuses:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`和`Task<TResult>`的以下属性是检查状态的快捷方式：'
- en: '`IsCanceled`: Returns `true` if the task’s `Status` is `Canceled`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsCanceled`: 如果任务的`Status`是`Canceled`，则返回`true`'
- en: '`IsCompleted`: Returns `true` if the task’s `Status` is `RanToCompletion`,
    `Canceled`, or `Faulted`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsCompleted`: 如果任务的`Status`是`RanToCompletion`、`Canceled`或`Faulted`，则返回`true`'
- en: '`IsCompletedSuccessfully`: Returns `true` if the task’s `Status` is `RanToCompletion`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsCompletedSuccessfully`: 如果任务的`Status`是`RanToCompletion`，则返回`true`'
- en: '`IsFaulted`: Returns `true` if the task’s `Status` is `Faulted`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsFaulted`: 如果任务的`Status`是`Faulted`，则返回`true`'
- en: 'Using these properties can streamline status checks in your code. The remaining
    instance properties of the `Task` object follow:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些属性可以简化代码中的状态检查。`Task`对象的剩余实例属性如下：
- en: '`AsyncState`: Returns the state that was provided when creating the task. If
    no state was provided, this property returns `null`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncState`: 返回创建任务时提供的状态。如果没有提供状态，则此属性返回`null`'
- en: '`CreationOptions`: Returns the `CreationOptions` values that were provided
    when creating the task. If no options were provided, it defaults to `TaskCreationOptions.None`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreationOptions`: 返回创建任务时提供的`CreationOptions`值。如果没有提供选项，则默认为`TaskCreationOptions.None`。'
- en: '`Exception`: Returns an `AggregateException` instance containing unhandled
    exceptions encountered while the task was running. `Wait` or `WaitAll` should
    be called in a `try`/`catch` block that handles the `AggregateException` type.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`: 返回一个包含在任务运行期间遇到的未处理异常的`AggregateException`实例。应在处理`AggregateException`类型的`try`/`catch`块中调用`Wait`或`WaitAll`。'
- en: '`Id`: A system-assigned identifier for the task'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`: 为任务分配的系统标识符'
- en: 'Let’s take a quick look at how to correctly catch an `AggregateException` instance
    and inspect the `Exception` property of the faulted task:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何正确捕获`AggregateException`实例并检查故障任务的`Exception`属性：
- en: '[PRE121]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This code will write the status of the task to the console after completion.
    If an unhandled exception is encountered, the error message will be written to
    the console in the `catch` block.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在完成后将任务的状态写入控制台。如果遇到未处理的异常，错误消息将在`catch`块中写入控制台。
- en: Now that you’re more familiar with the members of `Task` and `Task<TResult>`,
    let’s discuss some use cases for calling synchronous code from async code and
    vice versa.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对`Task`和`Task<TResult>`的成员更加熟悉了，让我们讨论一些从异步代码调用同步代码以及反之亦然的用例。
- en: Interop with synchronous code
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与同步代码的互操作
- en: 'When working with existing projects and introducing async code to the system,
    there will be points where synchronous and asynchronous code intersect. We have
    already seen some examples of how to handle this interop in this chapter. In this
    section, we will focus on that interop in both directions: sync calling async
    and async calling sync.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当与现有项目一起工作并引入异步代码到系统中时，将会有同步和异步代码相交的点。我们已经在本章中看到了一些处理这种互操作性的例子。在本节中，我们将关注双向互操作性：同步调用异步和异步调用同步。
- en: We will create a sample project with classes containing synchronous methods
    representing legacy code and another set of classes with modern `async` methods.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含表示旧代码的同步方法的类和包含现代 `async` 方法的另一组类的示例项目。
- en: Let’s start by discussing how to consume `async` methods in your legacy synchronous
    code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何在旧同步代码中消费 `async` 方法。
- en: Executing async from synchronous methods
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从同步方法执行异步
- en: 'In this example, we will be working with a .NET console application that gets
    a patient and their list of medications. The application will call a synchronous
    `GetPatientAndMedications` method that in turn calls an async `GetPatientInfoAsync`
    method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用一个 .NET 控制台应用程序来获取患者及其药物列表。应用程序将调用同步的 `GetPatientAndMedications` 方法，该方法反过来调用异步的
    `GetPatientInfoAsync` 方法：
- en: Start by creating a new .NET console application
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的 .NET 控制台应用程序
- en: 'Add `Patient`, `Provider`, and `Medication` classes to a `Models` folder and
    `HealthcareService` and `MedicationLoader` classes to a `SyncToAsync` folder:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Patient`、`Provider` 和 `Medication` 类添加到 `Models` 文件夹，并将 `HealthcareService`
    和 `MedicationLoader` 类添加到 `SyncToAsync` 文件夹：
- en: '![Figure 5.4: The initial project structure for calling async from sync code
    ](img/Figure_5.4_B18552.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：从同步代码调用异步的初始项目结构](img/Figure_5.4_B18552.jpg)'
- en: 'Figure 5.4: The initial project structure for calling async from sync code'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：从同步代码调用异步的初始项目结构
- en: 'Add the necessary properties for the model classes:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为模型类添加必要的属性：
- en: '[PRE134]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Create the `GetPatientInfoAsync` method in the `HealthcareService` class. This
    method creates a patient with a provider and two medications after injecting a
    2-second async delay:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HealthcareService` 类中创建 `GetPatientInfoAsync` 方法。此方法在注入 2 秒异步延迟后创建一个带有提供者和两种药物的病人：
- en: '[PRE135]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Add the implementation for the `MedicationLoader` service:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `MedicationLoader` 服务添加实现：
- en: '[PRE136]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `GetPatientAndMedications` method calls `GetPatientInfoAsync` and uses the
    `Result` property to synchronously wait for the `async` method to complete and
    return the value. Using `Result` is the same as using the `Wait()` method on an
    `async` method that returns no value. The current thread is blocked until the
    method completes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPatientAndMedications` 方法调用 `GetPatientInfoAsync` 并使用 `Result` 属性同步等待异步方法完成并返回值。使用
    `Result` 与在返回无值的异步方法上使用 `Wait()` 方法相同。当前线程在方法完成前被阻塞。'
- en: We have wrapped the call in a `try`/`catch` block that handles an `AggregateException`
    instance. If the call was successful, and the `patient` variable is not `null`,
    `ProcessPatientInfo` is called before returning the patient data to the caller.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用封装在一个 `try`/`catch` 块中，该块处理 `AggregateException` 实例。如果调用成功，并且 `patient`
    变量不是 `null`，则在返回患者数据给调用者之前调用 `ProcessPatientInfo`。
- en: 'Add this code to `Program.cs` to call the synchronous method:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到 `Program.cs` 中以调用同步方法：
- en: '[PRE137]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Run the program. You should see this output in the window:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。您应该在窗口中看到以下输出：
- en: '[PRE138]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Next, let’s try to load the same data but with an `async` method calling some
    legacy synchronous code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用异步方法调用一些旧同步代码来加载相同的数据。
- en: Executing synchronous code as async
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将同步代码作为异步执行
- en: 'In this example, we will mirror the previous example. There will be a `PatientLoader`
    instance with async methods calling a `PatientService` instance with a synchronous
    method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将模仿上一个示例。将有一个具有异步方法的 `PatientLoader` 实例调用具有同步方法的 `PatientService` 实例：
- en: Add a `PatientService` class to a new `AsyncToSync` folder in your project.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中添加一个新 `AsyncToSync` 文件夹，并添加 `PatientService` 类：
- en: 'Create a `GetPatientInfo` method with a similar implementation to the `GetPatientInfoAsync`
    method in the previous example:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与上一个示例中的 `GetPatientInfoAsync` 方法具有相似实现的 `GetPatientInfo` 方法：
- en: '[PRE139]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The differences here are that the method is not `async`, it returns a `Patient`
    instance instead of a `Task<Patient>` instance, and we’re injecting a delay with
    `Thread.Sleep` instead of `Task.Delay`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于方法不是 `async`，它返回 `Patient` 实例而不是 `Task<Patient>` 实例，并且我们使用 `Thread.Sleep`
    而不是 `Task.Delay` 注入延迟。
- en: 'Create the `PatientLoader` class in the `AsyncToSync` folder, and start its
    implementation by creating a new instance of `PatientService`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AsyncToSync` 文件夹中创建 `PatientLoader` 类，并开始其实现，通过创建 `PatientService` 的新实例：
- en: '[PRE140]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now create the async version of `ProcessPatientInfo` from the previous example:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从上一个示例创建 `ProcessPatientInfo` 的异步版本：
- en: '[PRE141]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now create the `GetPatientAndMedsAsync` method:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建 `GetPatientAndMedsAsync` 方法：
- en: '[PRE142]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The primary differences from the last example are highlighted. The `synchronous`
    class to `GetPatientInfo` is wrapped in a call to `await Task.Run`, which will
    wait for the call without blocking the current thread from performing other work.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例的主要区别被突出显示。`GetPatientInfo` 的 `synchronous` 类被包裹在一个对 `await Task.Run`
    的调用中，这将等待调用而不阻塞当前线程执行其他工作。
- en: We are now using `Exception` instead of `AggregateException` in the `catch`
    block. You should always use `AggregateException` with blocking `Wait` and `Result`
    calls and use `Exception` with `async` and `await`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 `catch` 块中使用 `Exception` 而不是 `AggregateException`。你应该始终与阻塞的 `Wait` 和 `Result`
    调用一起使用 `AggregateException`，并使用 `Exception` 与 `async` 和 `await` 一起使用。
- en: Finally, the async call to `ProcessPatientInfoAsync` is awaited if the `patient`
    variable is not `null`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 `patient` 变量不是 `null`，则等待对 `ProcessPatientInfoAsync` 的异步调用。
- en: 'Next update `Program.cs` to call the new `PatientLoader` code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来更新 `Program.cs` 以调用新的 `PatientLoader` 代码：
- en: '[PRE143]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Run the program, and the output should look similar to the previous example:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，输出应该类似于上一个示例：
- en: '[PRE144]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: By now, you should have a solid understanding of how to interop between asynchronous
    and synchronous code. Let’s move forward and create an example of loading data
    from several `async` methods in parallel.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经对如何在异步和同步代码之间进行交互有了扎实的理解。让我们继续前进，创建一个从多个 `async` 方法并行加载数据的示例。
- en: Working with multiple background tasks
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个后台任务一起工作
- en: In this section, we will see code samples for loading data from multiple sources
    in parallel, not waiting until the method is ready to return the data to the caller.
    The technique is slightly different for synchronous and asynchronous code, but
    the general idea is the same.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到从多个来源并行加载数据的代码示例，而不是等待方法准备好返回数据给调用者。对于同步和异步代码，技术略有不同，但总体思路是相同的。
- en: 'First, review this method that calls three async methods and uses `Task.WhenAll`
    to wait before returning the patient data:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾这个调用三个异步方法并使用 `Task.WhenAll` 等待返回患者数据的方法：
- en: '[PRE145]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, review this synchronous version of the method, which uses `Task.WaitAll`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，回顾这个方法的同步版本，它使用了 `Task.WaitAll`:'
- en: '[PRE158]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Even this version of the code, which uses a blocking `WaitAll` call, will perform
    faster than making separate synchronous calls to the three methods.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这个使用阻塞 `WaitAll` 调用的代码版本，其执行速度也将快于对三个方法分别进行单独的同步调用。
- en: The complete implementation of this `ParallelPatientLoader` class is available
    in the GitHub repository for this chapter. Let’s finish up the chapter by listing
    some best practices for using `async`, `await`, and `Task` objects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `ParallelPatientLoader` 类的完整实现可以在本章的 GitHub 仓库中找到。让我们通过列出使用 `async`、`await`
    和 `Task` 对象的一些最佳实践来结束本章。
- en: Asynchronous programming best practices
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程最佳实践
- en: 'When working with async code, there are many best practices of which you should
    be aware. In this section, we will list the most important ones to remember in
    your day-to-day development. **David Fowler**, who is a veteran member of the
    ASP.NET team at Microsoft and a .NET expert, maintains an open source list of
    many other best practices. I recommend bookmarking this page for later reference
    while working with your own projects: [https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理异步代码时，有许多最佳实践你应该知道。在本节中，我们将列出你在日常开发中应该记住的最重要的一些最佳实践。**大卫·福勒**（David Fowler），他是微软
    ASP.NET 团队的资深成员，也是 .NET 专家，维护了一个包含许多其他最佳实践的开放源代码列表。我建议在处理你自己的项目时将此页面添加到书签，以供以后参考：[https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynchronous-programming)。
- en: 'These are my top recommendations (in no particular order) to follow when working
    with async code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我（不分先后顺序）在处理异步代码时推荐的最高建议：
- en: Always prefer `async` and `await` over synchronous methods and blocking calls
    such as `Wait()` and `Result`. If you are creating a new project, you should build
    with async in mind from the start.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是优先选择 `async` 和 `await` 而不是同步方法以及像 `Wait()` 和 `Result` 这样的阻塞调用。如果你正在创建一个新的项目，你应该从一开始就考虑使用异步。
- en: Unless you are using `Task.WhenAll` to wait for multiple operations simultaneously,
    you should directly await a method rather than creating a `Task` instance and
    awaiting it.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你使用 `Task.WhenAll` 来同时等待多个操作，否则你应该直接等待一个方法，而不是创建一个 `Task` 实例然后等待它。
- en: Do not use `async` `void`. Your async methods should always return `Task`, `Task<TResult>`,
    `ValueTask`, or `ValueTask<TResult>`. The only exceptions are event handlers that
    have existing signatures that return `void`. Event `Main` methods can be async
    in .NET 6.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用 `async void`。您的异步方法应始终返回 `Task`、`Task<TResult>`、`ValueTask` 或 `ValueTask<TResult>`。唯一的例外是具有返回
    `void` 的现有签名的事件处理器。在 .NET 6 中，`Main` 事件方法可以是异步的。
- en: Do not mix blocking code and asynchronous code. Use `async` calls through the
    call stack.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要混合阻塞代码和异步代码。通过调用堆栈使用 `async` 调用。
- en: Use `Task.Run` instead of `Task.Factory.StartNew` unless you need to pass additional
    parameters to one of the `StartNew` overloaded methods.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非您需要向 `StartNew` 重载方法之一传递额外的参数，否则请使用 `Task.Run` 而不是 `Task.Factory.StartNew`。
- en: Long-running `async` methods should support cancellation. We will discuss cancellation
    in depth in [*Chapter 11*](B18552_11_ePub.xhtml#_idTextAnchor173).
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长运行的 `async` 方法应支持取消。我们将在 [*第 11 章*](B18552_11_ePub.xhtml#_idTextAnchor173)
    中深入讨论取消。
- en: Synchronize the usage of shared data. Your code should add locks to prevent
    any overwriting of data in objects used across threads.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步使用共享数据。您的代码应该添加锁以防止跨线程使用对象中的数据被覆盖。
- en: Always use `async` and `await` for I/O-bound work such as network and file access.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是使用 `async` 和 `await` 进行 I/O 密集型工作，如网络和文件访问。
- en: When you create an `async` method, add the `Async` suffix to its name. This
    helps to differentiate `sync` and `async` methods at a glance. An `async` method
    to return user information should be named `GetUserInfoAsync`, not `GetUserInfo`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您创建一个 `async` 方法时，请将其名称添加 `Async` 后缀。这有助于一眼区分 `sync` 和 `async` 方法。用于返回用户信息的
    `async` 方法应命名为 `GetUserInfoAsync`，而不是 `GetUserInfo`。
- en: Do not use `Thread.Sleep` in async methods. If your code must wait for a fixed
    period, use `await Task.Delay`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要在异步方法中使用 `Thread.Sleep`。如果您的代码必须等待固定的时间段，请使用 `await Task.Delay`。
- en: Those are my 10 rules to get you started, but there are many more best practices
    for async development with .NET. We will discover more of them as we progress
    through the remaining chapters.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我的 10 条启动规则，但还有许多关于使用 .NET 进行异步开发的最佳实践。随着我们继续阅读剩余的章节，我们将发现更多。
- en: Let’s wrap up and review what we have learned about async programming in this
    chapter.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结并回顾一下本章我们学到的关于异步编程的知识。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered quite a bit of information about asynchronous
    development with C# and. NET. We started by covering some of the ways to handle
    I/O-bound and CPU-bound operations in your applications.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了关于使用 C# 和 .NET 进行异步开发的大量信息。我们首先介绍了一些处理应用程序中 I/O 密集型和 CPU 密集型操作的方法。
- en: Next, we created some practical examples that use the `Task` and `Task<TResult>`
    classes and discovered how to work with multiple `Task` objects. You got some
    practical advice for interop between modern asynchronous code and legacy synchronous
    methods. Finally, we covered some of the most important rules to remember when
    working with asynchronous code and `Task` objects.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一些使用 `Task` 和 `Task<TResult>` 类的实用示例，并发现了如何与多个 `Task` 对象一起工作。您得到了一些关于现代异步代码和旧式同步方法之间互操作的实际建议。最后，我们介绍了在处理异步代码和
    `Task` 对象时需要记住的一些最重要的规则。
- en: In the next chapter, [*Chapter 6*](B18552_06_ePub.xhtml#_idTextAnchor098), you
    will learn the ins and outs of parallel programming in .NET using the **Task Parallel
    Library** (**TPL**) and learn how to the avoid common pitfalls of parallel programming.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，[*第 6 章*](B18552_06_ePub.xhtml#_idTextAnchor098)，您将学习如何使用 **Task Parallel
    Library** (**TPL**) 在 .NET 中进行并行编程的细节，并了解如何避免并行编程的常见陷阱。
- en: Questions
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which property of `Task` makes a blocking call to return data from the underlying
    method?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task` 的哪个属性使得阻塞调用能够从底层方法返回数据？'
- en: Which `async` method of the `Task` class should be used to await multiple tasks?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用 `Task` 类的哪个 `async` 方法来等待多个任务？
- en: What is the blocking equivalent of `Task.WhenAll()`?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.WhenAll()` 的阻塞等效方法是什么？'
- en: What type should an `async` method always return?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `async` 方法应该总是返回什么类型？
- en: Are `async` methods more suited to I/O-bound or CPU-bound operations?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async` 方法更适合 I/O 密集型还是 CPU 密集型操作？'
- en: '*True or false*: `Async` methods should never end with `Async` as their suffix.'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*对或错*：`Async` 方法不应该以 `Async` 作为后缀。'
- en: What method can be used to wrap a synchronous method in an `async` call?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种方法可以用来在 `async` 调用中包装同步方法？
