- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: In this chapter, we will learn how to add **authentication** and **authorization**
    to our blog because we don’t want just anyone to be able to create or edit blog
    posts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将 **身份验证** 和 **授权** 添加到我们的博客中，因为我们不希望任何人都能创建或编辑博客文章。
- en: Covering authentication and authorization could take a whole book, so we will
    keep things simple here. This chapter aims to get the built-in authentication
    and authorization functionalities working, building on the already existing functionality
    that’s built into ASP.NET. That means that there is not a lot of Blazor magic
    involved here; many resources already exist that we can take advantage of.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖身份验证和授权可能需要一整本书，所以在这里我们将保持简单。本章的目标是让内置的身份验证和授权功能正常工作，基于已经内置到 ASP.NET 中的功能。这意味着这里没有太多
    Blazor 魔法；已经存在许多我们可以利用的资源。
- en: Almost every system today has some way to log in, whether it is an admin interface
    (like ours) or a member login portal. There are many different login providers,
    such as Google, Twitter, and Microsoft. We can use all of these providers since
    we will just be building on existing architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个系统今天都有一种登录方式，无论是管理员界面（如我们的）还是成员登录门户。有许多不同的登录提供者，如 Google、Twitter 和 Microsoft。我们可以使用所有这些提供者，因为我们只是在现有的架构上构建。
- en: Some sites might already have a database for storing login credentials, but
    for our blog, we will use a service called Auth0 to manage our users. It is a
    very powerful way to add many different social providers (if we want to), and
    we don’t have to manage the users ourselves.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站可能已经有一个用于存储登录凭证的数据库，但对我们博客来说，我们将使用名为 Auth0 的服务来管理我们的用户。这是一种非常强大的方式来添加许多不同的社交提供者（如果我们想的话），而且我们不必自己管理用户。
- en: We can check the option to add authentication when creating our project. The
    authentication works differently when it comes to Blazor Server, Blazor WebAssembly,
    and the API, which we will look at in more detail in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在创建项目时选择添加身份验证的选项。当涉及到 Blazor 服务器、Blazor WebAssembly 和 API 时，身份验证的工作方式不同，我们将在本章中更详细地探讨。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置身份验证
- en: Securing Blazor Server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 Blazor 服务器
- en: Securing Blazor WebAssembly
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 Blazor WebAssembly
- en: Securing the API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 API
- en: Adding authorization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加授权
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have followed the previous chapters or use the `Chapter07` folder
    as a starting point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经遵循了前面的章节，或者以 `Chapter07` 文件夹作为起点。
- en: You can find the source code for this chapter’s end result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08)
    找到本章最终结果的源代码。
- en: Setting up authentication
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置身份验证
- en: There are a lot of built-in functionalities when it comes to authentication.
    The easiest way to add authentication is to select an authentication option when
    creating a project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证方面有许多内置功能。添加身份验证的最简单方法是创建项目时选择身份验证选项。
- en: We need to implement authentication separately for the Blazor Server project
    and the Blazor WebAssembly project because they work differently.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分别对 Blazor 服务器项目和 Blazor WebAssembly 项目实现身份验证，因为它们的工作方式不同。
- en: But there are still things we can share between these two projects. First, we
    need to set up Auth0.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然可以在这两个项目之间共享一些东西。首先，我们需要设置 Auth0。
- en: '**Auth0** is a service that can help us with handling our users. There are
    many different services like this, but Auth0 is a good fit for us. We can connect
    one or more social connectors, which will allow our users to log in with Facebook,
    Twitter, Twitch, or whatever we add to our site.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Auth0** 是一种服务，可以帮助我们处理用户。有许多不同的服务，但 Auth0 对我们来说是一个很好的选择。我们可以连接一个或多个社交连接器，这将允许我们的用户使用
    Facebook、Twitter、Twitch 或我们在网站上添加的任何其他服务进行登录。'
- en: Even though all of this can be achieved by writing code ourselves, integration
    like this is a great way to add authentication quickly and also get a very powerful
    solution. Also, authentication is complex, so don’t write this unless you are
    sure of what you are doing. Auth0 is free for up to 7,000 users (which our blog
    probably won’t reach, especially not the admin interface).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些都可以通过我们自己编写代码来实现，但这种集成方式是快速添加身份验证并获得非常强大解决方案的绝佳方式。此外，身份验证很复杂，所以除非你确定自己在做什么，否则不要编写它。Auth0
    对最多 7,000 个用户免费（我们博客可能达不到这个数字，尤其是管理员界面）。
- en: 'It also has great functionality to add data to our users that we have access
    to. We will do that later in the chapter when we add roles to our users. You’ll
    need to take the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有添加我们有权访问的用户数据的强大功能。我们将在本章后面添加用户角色时进行此操作。你需要执行以下步骤：
- en: Head over to [https://auth0.com](https://auth0.com) and create an account.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://auth0.com](https://auth0.com) 并创建一个账户。
- en: Click the **Create Application** button.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建应用程序**按钮。
- en: Now, it’s time to name our application. Use `MyBlog`, for example. Then, it’s
    time to select what kind of application type we are using. Is it a native app?
    Is it a **single-page web application**, **regular web application**, or **machine-to-machine
    application**?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候给我们的应用程序命名了。例如使用 `MyBlog`。然后，是时候选择我们正在使用哪种应用程序类型了。是原生应用程序吗？是**单页 Web 应用程序**、**常规
    Web 应用程序**还是**机器到机器应用程序**？
- en: This depends on what hosting model we are going to run.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于我们将要运行的主机模型。
- en: The beautiful thing with how we have the project set up right now is that the
    server is going to handle all the authentication and hand that over to WebAssembly
    (if we have a component that is running in InteractiveAuto or InteractiveWebAssembly).
    But it won’t limit the functionality, only what we need to configure when setting
    up our application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前项目设置的美好之处在于服务器将处理所有身份验证并将这些操作交给 WebAssembly（如果我们有一个在 InteractiveAuto 或 InteractiveWebAssembly
    中运行的可组件）。但这不会限制功能，只会限制我们在设置应用程序时需要配置的内容。
- en: If we intend to only run as Blazor Server (InteractiveServer), we should use
    a regular web application. But we might want to change to running everything in
    InteractiveWebAssembly, so let’s not limit ourselves here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算只以 Blazor 服务器（InteractiveServer）运行，我们应该使用常规的 Web 应用程序。但我们可能希望将所有内容都改为在
    InteractiveWebAssembly 中运行，所以在这里不要限制自己。
- en: Select **Single Page Application**, that way we get the option to use our authentication
    in any hosting model.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**单页应用程序**，这样我们就可以在任何主机模型中使用我们的身份验证。
- en: Next, we will choose what technology we are using for our project. We have Apache,
    .NET, Django, Go, and many other choices, but we don’t have a choice for Blazor
    specifically, at least not at the time of writing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将选择我们项目使用的技术。我们有 Apache、.NET、Django、Go 以及许多其他选择，但我们没有针对 Blazor 的特定选择，至少在撰写本文时没有。
- en: Just skip this and click the **Setting** tab.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 只需跳过这一步并点击**设置**选项卡。
- en: Now, we will set up our application. There are a couple of values we need to
    save and use later. You need to make sure that you write down the `Domain`, `Client
    ID`, and `Client Secret`, as we will use those in a bit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置我们的应用程序。我们需要保存并稍后使用一些值。你需要确保你记下了`域名`、`客户端 ID`和`客户端密钥`，因为我们将在稍后使用这些。
- en: If we scroll down, we can change the logo, but we will skip that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向下滚动，我们可以更改徽标，但我们将跳过这一步。
- en: 'Leave `Application Login URI` empty. Starting with .NET 6, the port numbers
    are random, so make sure you add your application’s port number:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持`应用程序登录 URI`为空。从 .NET 6 开始，端口号是随机的，所以请确保添加你应用程序的端口号：
- en: '`Allowed callback URLs`: `https://localhost:PORTNUMBER/callback`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`允许的回调 URL`：`https://localhost:PORTNUMBER/callback`'
- en: '`Allowed logout URLs`: `https://localhost:PORTNUMBER/`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`允许的注销 URL`：`https://localhost:PORTNUMBER/`'
- en: Allowed callback URLs are the URLs `Auth0` will make a call to after the user
    authentication and allowed logout URLs are where the user should be redirected
    after logging out.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的回调 URL 是 Auth0 在用户身份验证后将要调用的 URL，而允许的注销 URL 是用户注销后应重定向到的位置。
- en: Now, press **Save Changes** at the bottom of the page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在页面底部点击**保存更改**。
- en: Configuring our Blazor app
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置我们的 Blazor 应用程序
- en: We are done with configuring Auth0\. Next, we will configure our Blazor application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 Auth0 的配置。接下来，我们将配置我们的 Blazor 应用程序。
- en: There are many ways to store secrets in .NET (a file that is not checked in,
    Azure Key Vault, etc.). You can use the one that you are most familiar with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中存储密钥的方式有很多（一个未签入的文件、Azure Key Vault 等）。你可以使用你最熟悉的一种。
- en: We will keep it very simple and store secrets in our `appsettings.json`. Make
    sure to remember to exclude the file when you check in. You don’t check the secrets
    in source control. You can right-click on the file and select **Git**, **Ignore
    and Untrack Item**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持非常简单，并将机密信息存储在 `appsettings.json` 中。确保在提交时记住排除该文件。您不要将机密信息存入源代码控制。您可以在文件上右键单击并选择
    **Git**，**忽略和取消跟踪项**。
- en: 'To configure our Blazor project, follow these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的 Blazor 项目，请按照以下步骤操作：
- en: 'In the `BlazorWebApp.Client` project, in the root, add a new class called `UserInfo.cs`,
    and add the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp.Client` 项目的根目录下，添加一个名为 `UserInfo.cs` 的新类，并添加以下内容：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is taken from the Blazor template.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Blazor 模板中提取的。
- en: 'In the `BlazorWebApp` project, open `appsettings.json` and add the following
    code to the root of the existing app settings object:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp` 项目中，打开 `appsettings.json` 并将以下代码添加到现有应用程序设置对象的根目录：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are the values we made a note of in the previous section. Replace the
    values with our own values from `Auth0`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们之前章节中记录的值。用我们自己的 `Auth0` 中的值替换这些值。
- en: Since our site is an ASP.NET site with some added Blazor functionality, this
    means we can use a NuGet package to get some of the functionality out of the box.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的网站是一个带有一些附加 Blazor 功能的 ASP.NET 网站，这意味着我们可以使用 NuGet 包来获得一些开箱即用的功能。
- en: In the `BlazorWebApp` project, add a reference to the `Auth0.AspNetCore.Authentication
    NuGet` package.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp` 项目中，添加对 `Auth0.AspNetCore.Authentication NuGet` 包的引用。
- en: 'In the root of the project, create a new class named `PersistingServerAuthenticationStateProvider.cs`,
    and add the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下，创建一个名为 `PersistingServerAuthenticationStateProvider.cs` 的新类，并添加以下代码：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I have taken this file from the Blazor template (when we choose to add authentication
    right away). I added roles to it so if `Auth0` delivers any roles, they will be
    stored in the state as well. Right now, `Auth0` won’t give us any roles, so we
    will get back to roles in a bit. What is happening is when we log in, it will
    save the logged-in user in the `PersistentComponentState` so that we can easily
    transfer the user over to WebAssembly. The server will render the data on the
    DOM, and WebAssembly will then pick that up.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经从 Blazor 模板（当我们选择立即添加身份验证时）中提取了这个文件。我添加了角色，以便如果 `Auth0` 提供任何角色，它们也会存储在状态中。目前，`Auth0`
    不会给我们任何角色，所以我们稍后再回到角色。正在发生的事情是，当我们登录时，它将在 `PersistentComponentState` 中保存已登录用户，这样我们就可以轻松地将用户转移到
    WebAssembly。服务器将在 DOM 上渲染数据，然后 WebAssembly 将获取这些数据。
- en: 'Open `Program.cs` and add the following at the top of the file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 并在文件顶部添加以下代码：
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code just before `WebApplication app = builder.Build();`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WebApplication app = builder.Build();` 之前添加以下代码：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In previous versions of Blazor, we had to first make sure that when our components
    asked for `AuthenticationStateProvider`, we sent back an instance of our `PersistingServerAuthenticationStateProvider`.
    We also add a call to `AddCascadingAuthenticationState`, which will make sure
    to always send an `AuthenticationState` to all our components regardless of hosting
    method.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Blazor 的早期版本中，我们必须首先确保当我们的组件请求 `AuthenticationStateProvider` 时，我们返回一个 `PersistingServerAuthenticationStateProvider`
    的实例。我们还添加了对 `AddCascadingAuthenticationState` 的调用，这将确保无论托管方法如何，都会向所有组件发送 `AuthenticationState`。
- en: 'Also, add the following code just after `app.UseAntiforgery();`. This code
    will allow us to secure our site:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `app.UseAntiforgery();` 之后添加以下代码。这段代码将允许我们保护我们的网站：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `Program.cs`, add the following code just before `app.Run()`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在 `app.Run()` 之前添加以下代码：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When our site redirects to `authentication/login`, the Minimal API endpoint
    will kick off the login functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的网站重定向到 `authentication/login` 时，Minimal API 端点将启动登录功能。
- en: 'We need to add a similar functionality for logging out. Add the following code
    below the previous endpoint from *Step 7*:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加类似的注销功能。在 *步骤 7* 中的上一个端点下方添加以下代码：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It needs to sign out twice, once for the `Auth0` authentication scheme and once
    for the cookie authentication scheme. The configuration is all set. Now, we need
    something to secure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注销两次，一次用于 `Auth0` 认证方案，一次用于 cookie 认证方案。配置全部完成。现在，我们需要一些东西来保护。
- en: Securing our Blazor app
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护我们的 Blazor 应用
- en: Blazor uses `App.razor` for routing. To enable securing Blazor, we need to add
    a couple of components in the app component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 使用 `App.razor` 进行路由。为了启用 Blazor 的保护，我们需要在应用程序组件中添加一些组件。
- en: 'We need to add `CascadingAuthenticationState`, which will send the authentication
    state to all the components that are listening for it. We also need to change
    the route view to `AuthorizeRouteView`, which can have different views depending
    on whether or not you are authenticated:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加`CascadingAuthenticationState`，这将把身份验证状态发送到所有监听它的组件。我们还需要将路由视图更改为`AuthorizeRouteView`，它可以根据您是否已进行身份验证显示不同的视图：
- en: 'In the `BlazorWebApp` project, open `Components/_Imports.razor` and add the
    namespaces:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp`项目中，打开`Components/_Imports.razor`并添加以下命名空间：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `Components/Routes.razor` component and replace everything inside
    the `Router` component with the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Components/Routes.razor`组件，并将`Router`组件内的所有内容替换为以下内容：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In previous versions of Blazor, we had to surround the code with `<CascadingAuthenticationState>`,
    but with .NET 8, that is handled automatically by adding the call to `AddCascadingAuthenticationState`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor的早期版本中，我们不得不将代码包裹在`<CascadingAuthenticationState>`标签内，但使用.NET 8后，这可以通过添加对`AddCascadingAuthenticationState`的调用来自动处理。
- en: 'Now, only two things remain: a page that we can secure and a login link display.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只剩下两件事：一个我们可以保护页面和一个登录链接显示。
- en: In the `Components` folder, add a new Razor component called `LoginStatus.razor`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Components`文件夹中，添加一个名为`LoginStatus.razor`的新Razor组件。
- en: 'Replace the content with the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容替换为以下内容：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`LoginStatus` is a component that will show a login link if we are not authenticated
    and a logout link if we are authenticated.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginStatus`是一个组件，如果未进行身份验证，将显示登录链接；如果已进行身份验证，将显示注销链接。'
- en: 'Open `Components/Layout/MainLayout.razor`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Components/Layout/MainLayout.razor`：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Replace the about link with the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将关于链接替换为以下内容：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, our layout page will show us whether or not we’re logged in and give us
    the opportunity to log in or log out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的布局页面将显示我们是否已登录，并给我们提供登录或注销的机会。
- en: 'In `SharedComponents` and the `BlazorWebApp.Client` project, in the `_Imports`
    file of each project, add the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`和`BlazorWebApp.Client`项目中，在每个项目的`_Imports`文件中添加以下内容：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Add the `authorize` attribute to the component we wish to secure.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`authorize`属性添加到我们希望保护的组件中。
- en: 'We have the following components in the `SharedComponents` project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，我们有以下组件：
- en: '`Pages/Admin/BlogPostEdit.razor`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages/Admin/BlogPostEdit.razor`'
- en: '`Pages/Admin/BlogPostList.razor`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages/Admin/BlogPostList.razor`'
- en: '`Pages/Admin/CategoryList.razor`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages/Admin/CategoryList.razor`'
- en: '`Pages/Admin/TagList.razor (in the BlazorWebApp.Client project)`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages/Admin/TagList.razor`（在`BlazorWebApp.Client`项目中）'
- en: 'In each of the preceding components, add the following attribute:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述每个组件中添加以下属性：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is all it takes, some configuration, and then we are all set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部所需，一些配置，然后我们就可以设置好了。
- en: 'Now, start our `BlazorWebApp` and see if you can access the `/admin/blogposts`
    page (spoiler: you shouldn’t be able to); log in (create a user) and see if you
    can access the page now.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动我们的`BlazorWebApp`并查看您是否可以访问`/admin/blogposts`页面（剧透：您不应该能够访问）；登录（创建用户）并查看您现在是否可以访问该页面。
- en: Our admin interface is secured.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管理界面已经得到了保护。
- en: In the next section, we will secure the Blazor WebAssembly version of our blog
    and the API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将确保我们的Blazor WebAssembly版本博客和API的安全性。
- en: Securing Blazor WebAssembly
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Blazor WebAssembly
- en: In the previous editions of this book, we built two versions of the blog, one
    for Blazor Server and one for Blazor WebAssembly. In this edition, the whole point
    is that we don’t have to choose one over the other. As previously mentioned, there
    are two projects, `BlazorWebApp` and `BlazorWebApp.Client`. In the client project,
    we add all the components we want to be able to run as WebAssembly. Here is the
    really cool part. We have our `TagList` component in the client project. If we
    are running it as InteractiveAuto, it will first render on the server using SignalR
    using the configuration found in the `BlazorWebApp` project. But the next time
    the site runs, it will load the WebAssembly version and use the configuration
    in the `BlazorWebApp.Client` project. So, the same component can use a different
    dependency injection. In one case, it will use direct data access, and in the
    other, it will use the API client we created in the previous chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几版中，我们构建了两个版本的博客，一个用于 Blazor 服务器，一个用于 Blazor WebAssembly。在本版中，整个重点是我们不必在两者之间做出选择。如前所述，有两个项目，`BlazorWebApp`
    和 `BlazorWebApp.Client`。在客户端项目中，我们添加了所有我们希望作为 WebAssembly 运行的组件。这里有一个真正酷的部分。我们在客户端项目中有一个
    `TagList` 组件。如果我们以 InteractiveAuto 运行它，它将首先使用 `BlazorWebApp` 项目的配置在服务器上使用 SignalR
    进行渲染。但下次网站运行时，它将加载 WebAssembly 版本并使用 `BlazorWebApp.Client` 项目的配置。因此，同一个组件可以使用不同的依赖注入。在这种情况下，它将使用直接数据访问，而在另一种情况下，它将使用我们在上一章中创建的
    API 客户端。
- en: 'For us to be able to access our API, we need to set up `HttpClient`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们能够访问我们的 API，我们需要设置 `HttpClient`：
- en: But first, we need to get authentication information from the server. WebAssembly
    doesn’t really log in; it gets the information from the server and uses the authentication
    cookie for additional calls to the server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要从服务器获取身份验证信息。WebAssembly 并不真正登录；它从服务器获取信息并使用身份验证cookie进行对服务器的额外调用。
- en: In the server project, we added a `PersistingServerAuthenticationStateProvider`
    to store information about the logged-in user. On the client, we need to get that
    information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器项目中，我们添加了一个 `PersistingServerAuthenticationStateProvider` 来存储有关登录用户的信息。在客户端，我们需要获取这些信息。
- en: In the `BlazorWebApp.Client` project, add a new class in the root called `PersistentAuthenticationStateProvider.cs`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp.Client` 项目中，在根目录下添加一个名为 `PersistentAuthenticationStateProvider.cs`
    的新类。
- en: 'Replace the code with the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码替换为以下内容：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is also taken from the Blazor template (with authentication). Only minor
    modifications appear here, like adding roles.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也是从 Blazor 模板（带有身份验证）中提取的。这里只进行了少量修改，比如添加角色。
- en: 'In the `BlazorWebApp.Client` project, in `Program.cs`, add the following lines
    just above `builder.Build().RunAsync()`;:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp.Client` 项目中的 `Program.cs` 文件中，在 `builder.Build().RunAsync()`
    之上添加以下行；
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will enable authentication, add cascading `authentication state` to our
    components, and get the logged-in user from the `Persistent Component State`.
    The name of the `HttpClient` is “`Api"`; this is the name we used in *Chapter
    7*, *Creating an API*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用身份验证，将级联 `身份验证状态` 添加到我们的组件中，并从 `Persistent Component State` 中获取登录用户。`HttpClient`
    的名称是 “`Api`”；这是我们 *第7章*，*创建一个API* 中使用的名称。
- en: We also need to set up dependency injection so that when we ask for an `IBlogAPI`,
    we will get the `BlogApiWebClient` that we created in *Chapter 7*, *Creating an
    API*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要设置依赖注入，以便当我们请求一个 `IBlogAPI` 时，我们将得到我们在 *第7章*，*创建一个API* 中创建的 `BlogApiWebClient`。 '
- en: 'In `Program.cs`, add the following code below the `builder.Services.AddSingleton<AuthenticationStateProvider,
    PersistentAuthenticationStateProvider>();` line:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，在 `builder.Services.AddSingleton<AuthenticationStateProvider,
    PersistentAuthenticationStateProvider>();` 行之下添加以下代码：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when we ask for an `IBlogApi`, we will get the API web client that accesses
    the data through an API. The really cool thing here is that, depending on whether
    the component is rendered on the server (Static, InteractiveServer), the client
    (InteractiveWebAssembly), or a combination (InteractiveAuto), it will choose the
    right client for that scenario. We have the ability to choose the one that is
    best suited.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们请求一个 `IBlogApi` 时，我们将得到通过 API 访问数据的 API 客户端。这里真正酷的地方是，根据组件是在服务器（静态、InteractiveServer）上渲染、客户端（InteractiveWebAssembly）上渲染，还是组合（InteractiveAuto）渲染，它将选择适合该场景的正确客户端。我们有选择最适合的那个的能力。
- en: Make sure to add the required namespaces as well.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保添加所需的命名空间。
- en: Now, everything is prepared for us to secure when running in WebAssembly mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪，我们可以为在 WebAssembly 模式下运行进行安全设置了。
- en: This sample is about securing WebAssembly when running with an ASP.NET backend.
    In *Chapter 16*, *Going Deeper into WebAssembly*, we will take a look at how to
    secure a Blazor WebAssembly app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是关于在运行ASP.NET后端时保护WebAssembly。在*第16章*，*深入WebAssembly*中，我们将探讨如何保护Blazor WebAssembly应用程序。
- en: 'Let’s give it a try:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: In the `BlazorWebApp.Client` project, open the `Pages/Admin/TagList.razor`.
    We have been running our component with the InteractiveServer render mode up to
    this point. Now, let’s change that and run it as InteractiveWebAssembly instead.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BlazorWebApp.Client`项目中，打开`Pages/Admin/TagList.razor`。到目前为止，我们一直使用InteractiveServer渲染模式运行我们的组件。现在，让我们将其更改为InteractiveWebAssembly并运行它。
- en: Change `@rendermode InteractiveServer` to `@rendermode InteractiveWebAssembly`.
    That’s it! Now, our component will first render on the server (since we are running
    server pre-rendering), and then WebAssembly will take over and render the component
    again. It will pick up the authentication information stored in the component
    state and use our web API to retrieve the data from our API. This is because the
    WebAssembly application is configured to use `BlogApiWebClient` when we ask for
    an instance of `IBlogApi`. So, the same component is first prerendered on the
    server using direct data access, then again using the web API. Pretty cool!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将`@rendermode InteractiveServer`更改为`@rendermode InteractiveWebAssembly`。就这样！现在，我们的组件将首先在服务器上渲染（因为我们正在运行服务器预渲染），然后WebAssembly将接管并再次渲染组件。它将拾取存储在组件状态中的认证信息，并使用我们的Web
    API从我们的API检索数据。这是因为当请求`IBlogApi`的实例时，WebAssembly应用程序被配置为使用`BlogApiWebClient`。因此，相同的组件首先使用直接数据访问在服务器上预渲染，然后再次使用Web
    API。非常酷！
- en: Now, run the project, navigate to `/Admin/Tags`, and try to edit some tags.
    This component is now running on WebAssembly. You can try to change it to `@rendermode
    InteractiveAuto`. To see the behavior, this will first hook up SignalR and then,
    on the next load, switch to WebAssembly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目，导航到`/Admin/Tags`，并尝试编辑一些标签。这个组件现在正在WebAssembly上运行。您可以尝试将其更改为`@rendermode
    InteractiveAuto`。为了看到行为，这将首先连接SignalR，然后在下一次加载时切换到WebAssembly。
- en: But what if different users have different permissions?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果不同的用户有不同的权限怎么办？
- en: That is where roles come in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，角色派上用场。
- en: Adding roles
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加角色
- en: Blazor Server and Blazor WebAssembly handle roles a bit differently; it’s nothing
    major, but we need to do different implementations. In this chapter, we will take
    a look at implementing it for our current project (per component) and return to
    roles in *Chapter 16*, *Going Deeper into WebAssembly*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor Server和Blazor WebAssembly处理角色的方式略有不同；这不是什么大问题，但我们需要进行不同的实现。在本章中，我们将探讨为我们的当前项目（每个组件）实现它，并在*第16章*，*深入WebAssembly*中返回角色。
- en: Configuring Auth0 by adding roles
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过添加角色配置Auth0
- en: 'Let’s start by adding roles in Auth0:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Auth0中添加角色开始：
- en: Log in to `Auth0`, navigate to **User Management** | **Roles**, and click **Create
    Role**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到`Auth0`，导航到**用户管理** | **角色**，然后点击**创建角色**。
- en: Enter the name `Administrator` and the description `Can do anything` and press
    **Create**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称`管理员`和描述`可以做任何事情`，然后按**创建**。
- en: Go to the **Users** tab, click **Add Users**, search for your user, and then
    click **Assign**. You can also manage roles from the **Users** menu on the left.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**用户**选项卡，点击**添加用户**，搜索您的用户，然后点击**分配**。您也可以从左侧的**用户**菜单管理角色。
- en: By default, roles won’t be sent to the client, so we need to enrich the data
    to include roles.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，角色不会发送到客户端，因此我们需要丰富数据以包括角色。
- en: We do that by adding an action.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个操作来实现这一点。
- en: Go to **Actions**, and then **Flows**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**操作**，然后**流程**。
- en: Flows are a way to execute code in a particular flow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 流程是在特定流程中执行代码的一种方式。
- en: We want `Auth0` to add our roles when we log in.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`Auth0`在我们登录时添加我们的角色。
- en: Select **Login**, and there we will see the flow; in our case, we don’t have
    anything yet.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**登录**，在那里我们将看到流程；在我们的情况下，我们还没有任何内容。
- en: On the right-hand side, click **Custom** and the plus sign. As a small pop-up
    menu appears, select **Build from scratch**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，点击**自定义**和加号。当一个小弹出菜单出现时，选择**从头开始构建**。
- en: Name the action `Add Roles`, leave **Trigger**and **Runtime** as is, and press
    **Create**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将操作命名为`添加角色`，保持**触发器**和**运行时**不变，然后按**创建**。
- en: We will see a window where we can write our action.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个窗口，我们可以在这里编写我们的操作。
- en: 'Replace all the code with the following:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有代码替换为以下内容：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Click **Deploy** and then **Back to flow**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**部署**然后**返回流程**。
- en: Click **Custom** again, and we will see our newly created action.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**自定义**，我们将看到我们刚刚创建的操作。
- en: Drag the **Add Roles** action to the arrow between **Start** and **Complete**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**添加角色**操作拖到**开始**和**完成**之间的箭头上。
- en: Click **Apply**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**。
- en: Now, we have an action that will add the roles to our login token.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个将角色添加到我们的登录令牌中的操作。
- en: Our user is now an administrator. It’s worth noting that roles are a paid feature
    in Auth0 and will only be free during the trial.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户现在是一个管理员。值得注意的是，角色是 Auth0 的付费功能，并且仅在试用期间免费。
- en: Now, let’s set up Blazor to use this new role.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置 Blazor 以使用这个新角色。
- en: Adding roles to Blazor
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将角色添加到 Blazor
- en: Since we are using the Auth0 library, the setup is almost done for Blazor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 Auth0 库，Blazor 的设置几乎已经完成。
- en: 'Let’s modify a component to show whether the user is an administrator:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改一个组件以显示用户是否是管理员：
- en: In the `Components` project, open `Shared/NavMenu.razor`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Components` 项目中，打开 `Shared/NavMenu.razor`。
- en: 'At the top of the component, add the following:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件顶部添加以下内容：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, run our BlazorWebApp project.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行我们的 BlazorWebApp 项目。
- en: If we log in, we should be able to see text to the left saying **Hi Admin!**
    in black text on top of dark blue, so it might not be very visible. We will take
    care of this in *Chapter 9*, *Sharing Code and Resources*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们登录，我们应该能够看到左侧的文字，在深蓝色背景上显示黑色文字“**Hi Admin!**”，这可能不是很明显。我们将在**第 9 章**，**共享代码和资源**中解决这个问题。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to add authentication to our existing site.
    It is easier to add authentication when creating a project. Still, now we have
    a better understanding of what is going on under the hood and how to handle adding
    an external source for authentication.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将身份验证添加到我们现有的网站上。在创建项目时添加身份验证更容易。然而，现在我们对底层发生了什么以及如何处理添加外部身份验证源有了更好的理解。
- en: Throughout the book, we have shared components between the different hosting
    models.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已经在不同的托管模型之间共享了组件。
- en: In the next chapter, we will look at sharing even more things, like static files
    and CSS, and try to make everything look nice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨共享更多内容，例如静态文件和 CSS，并尝试使一切看起来都很漂亮。
