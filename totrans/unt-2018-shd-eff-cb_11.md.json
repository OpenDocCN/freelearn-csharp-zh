["```cs\nProperties \n{ \n    _MainTex (\"Base (RGB)\", 2D) = \"white\" {} \n    _DesatValue (\"Desaturate\", Range(0,1)) = 0.5 \n} \n```", "```cs\nsampler2D _MainTex; \nfixed _DesatValue; \n```", "```cs\nvoid surf (Input IN, inout SurfaceOutputStandard o) \n{ \n  half4 c = tex2D (_MainTex, IN.uv_MainTex); \n  c.rgb = lerp(c.rgb, Luminance(c.rgb), _DesatValue); \n\n  o.Albedo = c.rgb; \n  o.Alpha = c.a; \n} \n```", "```cs\n// Converts color to luminance (grayscale)\ninline half Luminance(half3 rgb)\n{\n    return dot(rgb, unity_ColorSpaceLuminance.rgb);\n}\n```", "```cs\n#ifdef UNITY_COLORSPACE_GAMMA\n#define unity_ColorSpaceGrey fixed4(0.5, 0.5, 0.5, 0.5)\n#define unity_ColorSpaceDouble fixed4(2.0, 2.0, 2.0, 2.0)\n#define unity_ColorSpaceDielectricSpec half4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301)\n#define unity_ColorSpaceLuminance half4(0.22, 0.707, 0.071, 0.0) // Legacy: alpha is set to 0.0 to specify gamma mode\n#else // Linear values\n#define unity_ColorSpaceGrey fixed4(0.214041144, 0.214041144, 0.214041144, 0.5)\n#define unity_ColorSpaceDouble fixed4(4.59479380, 4.59479380, 4.59479380, 2.0)\n#define unity_ColorSpaceDielectricSpec half4(0.04, 0.04, 0.04, 1.0 - 0.04) // standard dielectric reflectivity coef at incident angle (= 4%)\n#define unity_ColorSpaceLuminance half4(0.0396819152, 0.458021790, 0.00609653955, 1.0) // Legacy: alpha is set to 1.0 to specify linear mode\n#endif\n```", "```cs\n#ifndef MY_CG_INCLUDE \n#define MY_CG_INCLUDE \n```", "```cs\n#endif \n```", "```cs\nfixed4 _MyColor; \n\ninline fixed4 LightingHalfLambert(SurfaceOutput s, fixed3 lightDir, fixed atten) \n{ \n    fixed diff = max(0, dot(s.Normal, lightDir)); \n    diff = (diff + 0.5)*0.5; \n\n    fixed4 c; \n    c.rgb = s.Albedo * _LightColor0.rgb * ((diff * _MyColor.rgb) * atten); \n    c.a = s.Alpha; \n    return c; \n} \n#endif \n```", "```cs\n#ifndef MY_CG_INCLUDE \n#define MY_CG_INCLUDE \n\nfixed4 _MyColor; \n\ninline fixed4 LightingHalfLambert(SurfaceOutput s, fixed3 lightDir, fixed atten) \n{ \n    fixed diff = max(0, dot(s.Normal, lightDir)); \n    diff = (diff + 0.5)*0.5; \n\n    fixed4 c; \n    c.rgb = s.Albedo * _LightColor0.rgb * ((diff * _MyColor.rgb) * atten); \n    c.a = s.Alpha; \n    return c; \n} \n#endif \n```", "```cs\nShader \"CookbookShaders/Chapter11/Colorize\" \n```", "```cs\nCGPROGRAM\n#include \"MyCGInclude.cginc\" \n// Physically based Standard lighting model, and enable shadows on all light types\n#pragma surface surf Standard fullforwardshadows\n```", "```cs\nCGPROGRAM \n#include \"MyCGInclude.cginc\" \n#pragma surface surf HalfLambert \n```", "```cs\nProperties \n{ \n    _MainTex (\"Base (RGB)\", 2D) = \"white\" {} \n    _DesatValue (\"Desaturate\", Range(0,1)) = 0.5 \n    _MyColor (\"My Color\", Color) = (1,1,1,1) \n} \n```", "```cs\n void surf (Input IN, inout SurfaceOutput o) \n```", "```cs\nProperties \n{\n  _Color (\"Color\", Color) = (1,1,1,1)\n  _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {}\n  _Glossiness (\"Smoothness\", Range(0,1)) = 0.5\n  _Metallic (\"Metallic\", Range(0,1)) = 0.0\n\n _FurLength (\"Fur Length\", Range (.0002, 1)) = .25\n _Cutoff (\"Alpha Cutoff\", Range(0,1)) = 0.5 // how \"thick\"\n _CutoffEnd (\"Alpha Cutoff end\", Range(0,1)) = 0.5 // how thick they are at the end\n _EdgeFade (\"Edge Fade\", Range(0,1)) = 0.4\n\n _Gravity (\"Gravity Direction\", Vector) = (0,0,1,0)\n _GravityStrength (\"Gravity Strength\", Range(0,1)) = 0.25\n}\n```", "```cs\n#pragma target 3.0\n\nfixed4 _Color;\nsampler2D _MainTex;\nhalf _Glossiness;\nhalf _Metallic;\n\nuniform float _FurLength;\nuniform float _Cutoff;\nuniform float _CutoffEnd;\nuniform float _EdgeFade;\n\nuniform fixed3 _Gravity;\nuniform fixed _GravityStrength;\n\nvoid vert (inout appdata_full v)\n{\n  fixed3 direction = lerp(v.normal, _Gravity * _GravityStrength + v.normal * (1-_GravityStrength), FUR_MULTIPLIER);\n  v.vertex.xyz += direction * _FurLength * FUR_MULTIPLIER * v.color.a;\n  //v.vertex.xyz += v.normal * _FurLength * FUR_MULTIPLIER * v.color.a;\n}\n\nstruct Input {\n  float2 uv_MainTex;\n  float3 viewDir;\n};\n\nvoid surf (Input IN, inout SurfaceOutputStandard o) {\n  fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;\n  o.Albedo = c.rgb;\n  o.Metallic = _Metallic;\n  o.Smoothness = _Glossiness;\n\n  //o.Alpha = step(_Cutoff, c.a);\n  o.Alpha = step(lerp(_Cutoff,_CutoffEnd,FUR_MULTIPLIER), c.a);\n\n  float alpha = 1 - (FUR_MULTIPLIER * FUR_MULTIPLIER);\n  alpha += dot(IN.viewDir, o.Normal) - _EdgeFade;\n\n  o.Alpha *= alpha;\n}\n```", "```cs\nvoid surf (Input IN, inout SurfaceOutputStandard o) {\n  // Albedo comes from a texture tinted by color\n  fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;\n  o.Albedo = c.rgb;\n  // Metallic and smoothness come from slider variables\n  o.Metallic = _Metallic;\n  o.Smoothness = _Glossiness;\n  o.Alpha = c.a;\n}\nENDCG\n\nCGPROGRAM\n#pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert\n#define FUR_MULTIPLIER 0.05\n#include \"FurPass.cginc\"\nENDCG\n```", "```cs\n    CGPROGRAM\n    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert\n    #define FUR_MULTIPLIER 0.05\n    #include \"FurPass.cginc\"\n    ENDCG\n\n    CGPROGRAM\n    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert\n    #define FUR_MULTIPLIER 0.1\n    #include \"FurPass.cginc\"\n    ENDCG\n\n    CGPROGRAM\n    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert\n    #define FUR_MULTIPLIER 0.15\n    #include \"FurPass.cginc\"\n    ENDCG\n\n    // ... 0.2 - 0.85 here\n\n        CGPROGRAM\n    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert\n    #define FUR_MULTIPLIER 0.90\n    #include \"FurPass.cginc\"\n    ENDCG\n\n    CGPROGRAM\n    #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert\n    #define FUR_MULTIPLIER 0.95\n    #include \"FurPass.cginc\"\n    ENDCG\n  }\n\n  Fallback \"Diffuse\"\n}\n```", "```cs\nvoid vert (inout appdata_full v) \n{ \n    fixed3 direction = lerp(v.normal, _Gravity * _GravityStrength + v.normal * (1-_GravityStrength), FUR_MULTIPLIER); \n    v.vertex.xyz += direction * _FurLength * FUR_MULTIPLIER * v.color.a; \n} \n```", "```cs\no.Alpha = step(lerp(_Cutoff,_CutoffEnd,FUR_MULTIPLIER), c.a); \n\nfloat alpha = 1 - (FUR_MULTIPLIER * FUR_MULTIPLIER); \nalpha += dot(IN.viewDir, o.Normal) - _EdgeFade; \n\no.Alpha *= alpha; \n```", "```cs\nshader \" Heatmap\" { \n    Properties { \n        _HeatTex (\"Texture\", 2D) = \"white\" {} \n    } \n    Subshader { \n        Tags {\"Queue\"=\"Transparent\"} \n        Blend SrcAlpha OneMinusSrcAlpha // Alpha blend \n\n        Pass { \n            CGPROGRAM \n            #pragma vertex vert              \n            #pragma fragment frag \n\n            struct vertInput { \n                float4 pos : POSITION; \n            };   \n\n            struct vertOutput { \n                float4 pos : POSITION; \n                fixed3 worldPos : TEXCOORD1; \n            }; \n\n            vertOutput vert(vertInput input) { \n                vertOutput o; \n                o.pos = mul(UNITY_MATRIX_MVP, input.pos); \n                o.worldPos = mul(_Object2World, input.pos).xyz; \n                return o; \n            } \n\n            uniform int _Points_Length = 0; \n            uniform float3 _Points [20];        // (x, y, z) = position\n            uniform float2 _Properties [20];    // x = radius, y = intensity \n\n            sampler2D _HeatTex; \n\n            half4 frag(vertOutput output) : COLOR { \n                // Loops over all the points \n                half h = 0; \n                for (int i = 0; i < _Points_Length; i ++) \n                { \n                    // Calculates the contribution of each point \n                    half di = distance(output.worldPos, _Points[i].xyz); \n\n                    half ri = _Properties[i].x; \n                    half hi = 1 - saturate(di / ri); \n\n                    h += hi * _Properties[i].y; \n                } \n\n                // Converts (0-1) according to the heat texture \n                h = saturate(h); \n                half4 color = tex2D(_HeatTex, fixed2(h, 0.5)); \n                return color; \n            } \n            ENDCG \n        } \n    }  \n    Fallback \"Diffuse\" \n} \n```", "```cs\nusing UnityEngine;\n\npublic class HeatmapDrawer : MonoBehaviour\n{\n\n    public Vector4[] positions;\n    public float[] radiuses;\n    public float[] intensities;\n    public Material material;\n\n    void Start()\n    {\n        material.SetInt(\"_Points_Length\", positions.Length);\n\n        material.SetVectorArray(\"_Points\", positions);\n\n        Vector4[] properties = new Vector4[positions.Length];\n\n        for (int i = 0; i < positions.Length; i++)\n\n        {\n            properties[i] = new Vector2(radiuses[i], intensities[i]);\n        }\n\n        material.SetVectorArray(\"_Properties\", properties);\n\n    }\n}\n```", "```cs\nuniform float3 _Points [20];     \n```", "```cs\nhalf h = 0; \nfor (int i = 0; i < _Points_Length; i ++) \n{ \n    // Calculates the contribution of each point \n    half di = distance(output.worldPos, _Points[i].xyz); \n\n    half ri = _Properties[i].x; \n    half hi = 1 - saturate(di / ri); \n\n    h += hi * _Properties[i].y; \n} \n```"]