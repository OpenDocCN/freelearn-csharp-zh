- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Refactoring Code Flow and Iteration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码流和迭代的重构
- en: While other chapters in *Part 1* focus on refactorings that can be applied to
    entire methods or classes, this chapter focuses on improving the readability and
    efficiency of individual lines of code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一部分的其他章节专注于可以应用于整个方法或类的重构，但本章专注于提高单个代码行的可读性和效率。
- en: Developers spend the majority of their time reading over individual lines of
    code and only a fraction of that time modifying code. So, it is important to make
    our lines of code as maintainable as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者大部分时间都在阅读单个代码行，而只有一小部分时间在修改代码。因此，使我们的代码尽可能易于维护是很重要的。
- en: 'In this chapter, we’ll explore the following topics related to improving small
    pieces of code:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与改进代码小片段相关的一些主题：
- en: Controlling program flow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制程序流程
- en: Instantiating objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化对象
- en: Iterating over collections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历集合
- en: Refactoring LINQ statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构LINQ语句
- en: Reviewing and testing our refactored code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查和测试重构后的代码
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter03/Ch3BeginningCode` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可在GitHub的[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)的`Chapter03/Ch3BeginningCode`文件夹中找到。
- en: Refactoring the boarding app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构登机应用程序
- en: 'This chapter’s code focuses on a pair of applications for Cloudy Skies Airline:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码专注于Cloudy Skies Airline的成对应用程序：
- en: A *Boarding Status Display* app that tells the user if it’s time for them to
    board their flight based on the current boarding group and the person’s ticket,
    military status, and whether or not they need assistance getting down the jetway.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**登机状态显示应用程序**，根据当前登机组和乘客的机票、军事状态以及他们是否需要帮助通过登机桥，告诉用户是否是登机时间。
- en: 'A *Boarding Kiosk* app that allows airline employees to view the passengers
    scheduled to be on the flight and provides information regarding whether each
    passenger has boarded. *Figure 3**.1* shows the application in action:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许航空公司员工查看即将登机的乘客并获取每位乘客登机信息的**登机亭应用程序**。**图3.1**.1展示了应用程序的实际运行情况：
- en: '![Figure 3.1 – The Boarding Kiosk app](img/B21324_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 登机亭应用程序](img/B21324_03_01.jpg)'
- en: Figure 3.1 – The Boarding Kiosk app
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 登机亭应用程序
- en: Since we’re exploring not one but two applications, we’ll meet the application
    code in small chunks as we progress through this chapter. However, feel free to
    peruse it yourself on GitHub if you’d like to orient yourself first.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在探索的不是单一的应用程序，而是两个应用程序，因此我们将随着本章的进展逐步遇到应用程序代码。然而，如果您想先熟悉一下，请随时在GitHub上自行查看。
- en: As we go through this chapter, we’ll take its existing functioning code and
    see how small refactoring steps can improve the maintainability of the code using
    various C# language features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本章，我们将查看其现有的功能代码，并看看通过使用各种C#语言特性的小重构步骤如何提高代码的可维护性。
- en: We’ll start by looking at how refactoring can improve the overall flow of code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看重构如何改进代码的整体流程。
- en: Controlling program flow
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制程序流程
- en: One of the most basic things new developers learn is how programs execute lines
    of code in sequence and how **if statements** and other language features control
    what statements execute next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 新的开发者学习到最基本的事情之一是程序如何按顺序执行代码行，以及**if语句**和其他语言特性如何控制接下来执行哪些语句。
- en: 'In this section, we’ll focus on the `BoardingProcessor` class''s `CanPassengerBoard`
    method. The method starts simple enough:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注`BoardingProcessor`类的`CanPassengerBoard`方法。该方法开始得很简单：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `CanPassengerBoard` takes in a `Passenger` object and returns a string.
    The method also declares a few local variables holding pieces of data from the
    object passed in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CanPassengerBoard`接受一个`Passenger`对象并返回一个字符串。该方法还声明了一些局部变量，用于存储从传入的对象中获取的数据片段。
- en: These variables aren’t necessary and could be removed by performing an inline
    variable refactoring, which we’ll talk about later in this chapter. However, as
    they improve the readability of the code that follows, their existence is largely
    helpful. This is part of the reason why we sometimes introduce local variables,
    as we covered in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量不是必需的，可以通过执行内联变量重构来移除，我们将在本章后面讨论。然而，由于它们提高了后续代码的可读性，它们的存在在很大程度上是有帮助的。这也是我们有时引入局部变量的原因之一，正如我们在[*第2章*](B21324_02.xhtml#_idTextAnchor026)中讨论的那样。
- en: 'The logic that follows gets significantly harder to read, as seen here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如此逻辑的后续部分会变得难以阅读，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method primarily uses `if`/`else` statements with a few scattered variable
    declarations and periodic return statements. These are fundamental structures
    of computer programming, and yet it takes a moment to understand what this code
    truly does.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法主要使用`if`/`else`语句，还有一些散布的变量声明和定期的返回语句。这些是计算机编程的基本结构，但需要一点时间才能理解这段代码真正做了什么。
- en: 'For those not wanting to sort through the logic, this code follows these rules:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不想整理逻辑的人来说，此代码遵循以下规则：
- en: If the plane has departed, return `"``Flight Departed"`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞机已经起飞，则返回`"``Flight Departed"`
- en: If the plane is not yet boarding, return `"Boarding` `Not Started"`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞机尚未开始登机，则返回`"Boarding` `Not Started"`
- en: If the plane is boarding and the passenger needs help or is active military,
    return `"Board Now via` `Priority Lane"`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞机正在登机且乘客需要帮助或为现役军人，则返回`"Board Now via` `Priority Lane"`
- en: If the plane is boarding and the passenger’s group is not boarding yet, return
    `"``Please Wait"`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞机正在登机而乘客的组尚未登机，则返回`"``请等待"`
- en: If the passenger’s group can board, tell them to board either by the normal
    lane or via the priority lane if their boarding group is one of the priority groups
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果乘客的组可以登机，告诉他们通过正常通道登机，或者如果他们的登机组是优先组之一，则通过优先通道登机
- en: However, the code is complex enough that puzzling out these rules can take a
    bit of time, and the complexity results in uncertainty, making it difficult for
    others to understand the rules in their entirety.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码足够复杂，弄清楚这些规则可能需要一些时间，而复杂性导致了不确定性，使得其他人难以完全理解这些规则。
- en: Understanding these rules is important if you’re going to maintain the code.
    So, improving the readability of this code is important to the code’s long-term
    success.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算维护代码，理解这些规则是很重要的。因此，提高代码的可读性对于代码的长期成功至关重要。
- en: Inverting if statements
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转if语句
- en: One of the quickest tricks to simplifying complex logic involving nested `if`
    statements can be to invert the `if` statement and return early.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简化涉及嵌套`if`语句的复杂逻辑的最快技巧之一可能是反转`if`语句并提前返回。
- en: 'Currently, our high-level logic looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的高级逻辑看起来是这样的：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By the time we get back to the `else` statement associated with the plane departed
    check, the reader has forgotten what the original `if` statement was to begin
    with!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回到与飞机起飞检查相关的`else`语句时，读者已经忘记了最初的`if`语句是什么了！
- en: 'Here, since the `else` branch is so simple and easy to understand, it’s helpful
    to invert the `if` statement by taking the following actions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于`else`分支非常简单且易于理解，通过以下操作反转`if`语句是有帮助的：
- en: Swap the contents of the `if` block and the `else` block.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换`if`块和`else`块的内容。
- en: Invert the boolean expression in the `if` statement. When inverting `==`, it
    becomes `!=` and vice versa. In cases where we do a `>` or `<` check, you flip
    the operand and toggle whether equality is included. Under these rules, `>=` becomes
    `<` and `>=` becomes `>`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句中反转布尔表达式。当反转`==`时，它变为`!=`，反之亦然。在执行`>`或`<`检查的情况下，您会翻转操作数并切换是否包含相等性。根据这些规则，`>=`变为`<`，而`<=`变为`>`。
- en: 'In our case, we check that `Status != BoardingStatus.PlaneDeparted`. In this
    case, we’d change `!=` to `==` and wind up with this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们检查`Status != BoardingStatus.PlaneDeparted`。在这种情况下，我们将`!=`改为`==`并得到以下结果：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These steps preserve the program’s existing behavior but change the order of
    the statements in the code. This can increase the readability of our source code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤保留了程序现有的行为，但改变了代码中语句的顺序。这可以提高我们源代码的可读性。
- en: 'If this sounds complicated, don’t worry, because Visual Studio has a **Quick
    Action** refactoring for it called **Invert if**, as shown in *Figure 3**.2*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，不要担心，因为Visual Studio有一个名为**反转if**的**快速重构**操作，如图*图3**.2*所示：
- en: '![Figure 3.2 – The Invert if Quick Action refactoring](img/B21324_03_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 反转if快速重构操作](img/B21324_03_02.jpg)'
- en: Figure 3.2 – The Invert if Quick Action refactoring
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 反转if快速重构操作
- en: 'Performing the refactoring here effectively changes our logic to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里执行重构实际上将我们的逻辑更改为以下内容：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While this is easier to read since the reader no longer must remember what the
    `if` statement even pertains to 17 lines later, the code can be improved further.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于读者不再需要记住`if`语句甚至17行后的内容，所以这更容易阅读，但代码还可以进一步改进。
- en: Dropping else statements after return statements
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在返回语句之后省略else语句
- en: Since the `return` statement always leaves the method immediately, you never
    explicitly *need* an `else` statement after a `return` statement because you know
    that if you get to the `return` statement, logic after the `if` block won’t execute.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`return`语句总是立即退出方法，所以在`return`语句之后你永远不会显式地需要`else`语句，因为你知道如果你到达了`return`语句，`if`块之后的逻辑不会执行。
- en: This lets us remove the `else` keyword and its curly braces. Then, we can outdent
    the code that was previously in the `else` block.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以删除`else`关键字及其大括号。然后，我们可以缩进之前在`else`块中的代码。
- en: 'The resulting code keeps the `if` statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结果代码保留了`if`语句：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After this statement, the code that follows is now at the same indentation
    level as the original `if` statement and is easier to read and understand:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句之后，接下来的代码现在与原始的`if`语句处于相同的缩进级别，更容易阅读和理解：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can repeat this refactoring a few more times if we want to since the code
    has a few more `if`/`return`/`else` sequences.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，我们可以重复这个重构几次，因为代码中还有几个`if`/`return`/`else`序列。
- en: I’ll leave those for the moment since there’s another refactoring I want to
    show you that can help with what we’re seeing here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我会暂时留下这些，因为还有另一个重构我想展示，可以帮助我们处理这里看到的问题。
- en: Restructuring if statements
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新结构化`if`语句
- en: 'Looking at the previous code, some of the logic stands out as repetitive:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看之前的代码，一些逻辑显得重复：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have an `if`/`else` chain where three different things are checking
    whether the flight is currently boarding. Although each of these three `if` statements
    is different, there’s enough overlap between them that it makes me question if
    we could be less repetitive.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`if`/`else`链，其中三个不同的事物正在检查航班是否正在登机。尽管这三个`if`语句各不相同，但它们之间有足够的重叠，这让我质疑我们是否可以减少重复。
- en: 'The first option we could consider might be a simple *introduce local variable*
    refactoring, as we saw in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑的第一个选项可能是一个简单的*引入局部变量*重构，就像我们在[*第二章*](B21324_02.xhtml#_idTextAnchor026)中看到的那样：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I find this code easier to read, even though we gained an extra line from the
    new local variable. However, let’s take a slightly different approach.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个代码更容易阅读，尽管我们因为新的局部变量而多了一行。然而，让我们采取一个稍微不同的方法。
- en: 'Instead of introducing a variable, we can rearrange our if statements to have
    an additional layer of nesting:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是引入一个变量，我们可以重新排列我们的`if`语句以增加一个嵌套层：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, pulling a common condition from a set of `if` statements into an outer
    `if` statement helped clarify those `if` statements, although it did so at the
    expense of an additional degree of nesting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从一组`if`语句中提取一个公共条件到外部的`if`语句有助于澄清这些`if`语句，尽管这样做是以牺牲额外的嵌套级别为代价的。
- en: 'However, this simplification helps spot a few other refactoring opportunities,
    such as combining the `isMilitary` and `needsHelp` checks since they return the
    same value if either is true:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简化有助于发现一些其他的重构机会，例如将`isMilitary`和`needsHelp`检查合并，因为如果其中任何一个为真，它们会返回相同的值：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also drop the `else` statement after the `if`/`return` code to outdent
    our code a bit more, leaving just the boarding group logic:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`if`/`return`代码之后删除`else`语句，以便进一步缩进代码，只留下登机组逻辑：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This looks like another place where we can invert `if` and drop the `else`
    statement to simplify the code even more. Remember that we must change `>=` to
    `<` to do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是我们可以反转`if`并删除`else`语句以进一步简化代码的另一个地方。记住，我们必须将`>=`改为`<`才能做到这一点：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the code is getting significantly easier to read as we simplify
    it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，随着我们简化代码，代码的可读性显著提高。
- en: 'Let’s take a step back and look at our conditional logic after these refactorings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看这些重构之后的条件逻辑：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code is now easier to read and harder to misinterpret. We could invert the
    Boarding status check to return early, but we'll do something else with here later.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在更容易阅读，也更难误解。我们可以反转登机状态检查以提前返回，但在这里我们会做其他的事情。
- en: 'Let’s look at how we can reduce our line count even further through a more
    divisive language feature: the **ternary operator**.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过更分化的语言特性：三元运算符，进一步减少我们的行数。
- en: Using ternary operators
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用三元运算符
- en: If you’re a fan of the ternary operator, you may have noticed an opportunity
    to use one in the code as we’ve been refactoring.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢三元运算符，你可能会注意到在重构过程中我们可以使用它的机会。
- en: For those not familiar or not fully comfortable with the ternary conditional
    operator, think of it as a condensed *if my condition is true use this value,
    otherwise use this other value* type of an operator.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉或不完全熟悉三元条件运算符的人来说，可以将其视为一种“如果我的条件为真使用这个值，否则使用另一个值”类型的运算符。
- en: The syntax for ternary is `boolExpression ? trueValue :` `falseValue;`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '三元运算符的语法是`boolExpression ? trueValue : falseValue;`。'
- en: 'In other words, you could write code without a ternary like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以像这样编写没有三元运算符的代码：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, the same code could be written using a ternary in a single line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相同的代码可以使用单行中的三元运算符来编写：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the ternary operator lets us take six lines of code and condense
    it down to a single line. This conciseness is a key factor for those who like
    using ternaries in their code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，三元运算符让我们将六行代码压缩成一行。这种简洁性是那些喜欢在代码中使用三元运算符的人的关键因素。
- en: Those who are less fond of ternary operators often point out that ternaries
    are difficult to read – particularly when trying to read through code quickly.
    In other words, while they make code more concise, this conciseness can slow you
    down in the long run by making the code less easy to maintain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不太喜欢三元运算符的人经常指出，三元运算符难以阅读——尤其是在快速阅读代码时。换句话说，虽然它们使代码更加简洁，但这种简洁性可能会在长期内减慢你的速度，因为代码的可维护性降低了。
- en: 'Let’s look at a small part of our code and see how a ternary could be applied:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们代码的一小部分，看看三元运算符是如何应用的：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are checking if the current boarding group is a priority group and
    then telling the user to board with the priority lane or to board normally based
    on the result of the `Contains` call.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查当前登机组是否是优先组，然后根据`Contains`调用的结果告诉用户使用优先通道登机或正常登机。
- en: 'Since we’re returning a single value based on the result of a boolean expression,
    we could rewrite the code with a ternary as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是根据布尔表达式的结果返回单个值，我们可以用以下方式重写代码：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This chops five lines of code down to three lines of code or a single line of
    code if you want to put the `?` and `:` segments on the same line as the boolean
    expression.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以将五行代码缩减到三行，或者如果你想在布尔表达式的同一行上放置`?`和`:`部分，则可以缩减到一行代码。
- en: 'You might have noticed that this refactoring now puts the whole block of code
    into a position where you could introduce another ternary based on the boarding
    group, `return "Please Wait"`, if that expression is true, and return the result
    of the earlier ternary expression if the expression is false:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这次重构现在将整个代码块置于一个位置，你可以根据登机组引入另一个三元运算符，`return "Please Wait"`，如果该表达式为真，如果表达式为假，则返回早期三元运算符表达式的结果：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While this is valid C#, I can attest that if a coworker showed this to me in
    code review, I would be tempted to utter some not-very-nice words!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是有效的C#代码，但我可以证实，如果同事在代码审查时向我展示这样的代码，我可能会忍不住说出一些不太礼貌的话！
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember: fewer lines of code don’t always equate to greater maintainability.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：代码行数少并不总是等于更高的可维护性。
- en: At a personal level, my preference is to avoid the ternary in many places and
    always avoid chaining ternaries together. However, I do sometimes use ternaries
    when I feel it is right for a piece of code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在个人层面，我倾向于在很多地方避免使用三元运算符，并且始终避免将三元运算符链式使用。然而，有时当我感觉某个代码片段适合使用三元运算符时，我也会使用它。
- en: For example, sometimes, a method is very simple and can be condensed to a single
    line of code if you use a ternary expression. This particular change lets you
    use the expression-bodied members feature, which we’ll talk about in [*Chapter
    4*](B21324_04.xhtml#_idTextAnchor072).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有时一个方法非常简单，如果你使用三元运算符，就可以将其压缩成一行代码。这个特定的更改让你可以使用表达式主体成员功能，我们将在[*第4章*](B21324_04.xhtml#_idTextAnchor072)中讨论。
- en: 'When I use a ternary, I format my ternary expressions on three separate lines,
    as shown earlier, with the first line containing the boolean expression. The second
    line will feature the `?` operator and the value to use if the expression was
    true, and the third line will feature the `:` operator and the value to use if
    the expression was false:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用三元运算符时，我会像之前展示的那样，将三元运算符表达式格式化为三行，第一行包含布尔表达式。第二行将包含`?`运算符和如果表达式为真时使用的值，第三行将包含`:`运算符和如果表达式为假时使用的值：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I find that this approach strikes a happy medium between the benefits of more
    concise code from the ternary and the penalties of code becoming more difficult
    to read quickly and accurately when using a ternary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这种方法在三元运算符的代码更简洁的优点和三元运算符使代码难以快速和准确地阅读的缺点之间找到了一个平衡点。
- en: Converting if statements into switch statements
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将if语句转换为switch语句
- en: 'The logic of this method is now a lot easier to understand, and simplifying
    it down to this level highlights that we’re doing one of three things, depending
    on the current boarding status:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的逻辑现在更容易理解了，简化到这个层面突显了，根据当前的登机状态，我们正在做三件事情之一：
- en: Notifying the user the flight has departed if its status is `PlaneDeparted`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其状态是`PlaneDeparted`，则通知用户航班已起飞
- en: Checking military status, whether help boarding is needed, and the boarding
    group for `Boarding` status
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查军事状态、是否需要帮助登机以及`Boarding`状态的登机组
- en: Notifying the user that boarding hasn’t started yet for other statuses (`NotStarted`
    is the only other status at the moment)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户其他状态（`NotStarted`是目前唯一的其他状态）的登机尚未开始
- en: When working with enumerated values, this kind of branching logic is common.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当与枚举值一起工作时，这种分支逻辑很常见。
- en: 'In our case, our `enum` value only has three states:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的`enum`值只有三种状态：
- en: BoardingStatus.cs
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: BoardingStatus.cs
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In cases where you find yourself checking the same variable for different values,
    you can usually rewrite them to use a **switch** **statement** instead.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在你发现自己正在检查不同值相同的变量时，你通常可以将它们重写为使用**switch** **语句**。
- en: '`switch` statements are essentially a streamlined series of `if`/`else` `if`/`else`
    types of checks that all check the same value, as our code does with `Status`.
    We’ll see an example of a `switch` statement shortly, but if you’re not familiar
    with them, you can think of them as just a different way of writing a series of
    related `if`/`else` `if` statements.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句本质上是一系列简化的`if`/`else` `if`/`else`类型的检查，它们都检查相同的值，就像我们的代码检查`Status`一样。我们很快就会看到一个`switch`语句的例子，但如果你不熟悉它们，你可以将它们视为编写一系列相关`if`/`else`
    `if`语句的另一种方式。'
- en: 'This can be done manually, or you can use a specific refactoring built into
    Visual Studio if your code is built in an `if`/`else` `if`/`else` type of structure,
    as the following code illustrates:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以手动完成，或者如果你的代码是`if`/`else` `if`/`else`类型的结构，你可以使用Visual Studio中内置的特定重构，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note here that I did add the `else` keyword (in bold in the previous snippet)
    to our earlier code to get into that `if`/`else` `if`/`else` structure, which
    lets Visual Studio identify the refactoring we’re about to use.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在之前的代码中确实添加了`else`关键字（在上一个代码片段中加粗），以便进入那个`if`/`else` `if`/`else`结构，这使得Visual
    Studio能够识别我们即将使用的重构。
- en: 'Once we have the code in this pattern, the `if` statement selected, as shown
    in *Figure 3**.3*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这种模式的代码，选择了`if`语句，如图*图3.3*所示：
- en: '![Figure 3.3 – The Convert to “switch” statement refactoring option](img/B21324_03_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 转换为“switch”语句的重构选项](img/B21324_03_03.jpg)'
- en: Figure 3.3 – The Convert to “switch” statement refactoring option
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 转换为“switch”语句的重构选项
- en: 'This refactoring makes our status-based logic much more apparent:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构使我们的基于状态的逻辑更加明显：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As someone reading this code, I find this a lot easier to scan and interpret
    compared to an `if`/`else if`/`else` chain, even though the logic functions identically.
    With an `if`/`else` `if`/`else` statement, I *may* notice that logic is comparing
    the same value several different times, while a `switch` statement makes it explicit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为阅读此代码的人，我发现与`if`/`else if`/`else`链相比，这种方法更容易扫描和解释，尽管逻辑功能相同。使用`if`/`else` `if`/`else`语句时，我*可能*会注意到逻辑正在多次比较相同的值，而`switch`语句则使这一点明确。
- en: Another benefit you get with a `switch` statement is that it unlocks a built-in
    refactoring option when your switch compares an `enum` value (such as `BoardingStatus`)
    and you’re missing a case for one or more `enum` values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`语句的另一个好处是，当你的`switch`比较一个`enum`值（例如`BoardingStatus`）并且你缺少一个或多个`enum`值的case时，它会解锁一个内置的重构选项。
- en: 'This option shows up in the **Quick Actions** menu for the switch statement
    as **Add missing cases**, as shown in *Figure 3**.4*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项在`switch`语句的**快速操作**菜单中显示为**添加缺失的case**，如图*图3.4*所示：
- en: '![Figure 3.4 – The Add missing cases refactoring option in the Quick Actions
    menu](img/B21324_03_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 快速操作菜单中的添加缺失的case重构选项](img/B21324_03_04.jpg)'
- en: Figure 3.4 – The Add missing cases refactoring option in the Quick Actions menu
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 快速操作菜单中的“添加缺失情况”重构选项
- en: Warning
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: I want to point out that the `NotStarted` status and has it break out of the
    switch instead of returning a value as it previously would have through the `default`
    keyword.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出的是，`NotStarted` 状态应该通过 `break` 语句跳出 `switch`，而不是像之前那样通过 `default` 关键字返回值。
- en: The C# compiler will flag this mistake for us in this case since the method
    won’t return a value for this path, but adding missing cases when a `default`
    case is present in a `switch` statement typically does introduce a change in behavior.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，C# 编译器会为我们标记这个错误，因为该方法不会为这个路径返回值，但在 `switch` 语句中存在 `default` 情况时添加缺失的情况通常会导致行为发生变化。
- en: 'In our case, we can merge the `NotStarted` status with the default case and
    get a more explicit list of options:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可以将 `NotStarted` 状态与默认情况合并，得到一个更明确的选项列表：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code is now significantly easier to read than it was before, and the flow
    of logic by status is now readily apparent.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在比之前更容易阅读，并且通过状态逻辑的流程现在一目了然。
- en: 'In a real-world application, I might change the default case to throw an exception,
    explicitly telling me that a specific `Status` was not supported by this logic.
    This would look something like the following logic:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我可能会将默认情况改为抛出异常，明确告诉我特定的 `Status` 不支持此逻辑。这看起来可能像以下逻辑：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I might also be tempted to perform *extract method* refactoring – as we saw
    in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026) – to move the logic for handling
    the boarding status into its own method. However, I’ll hold off on doing that
    to showcase switch expressions instead.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可能想要执行 *提取方法* 重构——正如我们在 [*第 2 章*](B21324_02.xhtml#_idTextAnchor026) 中所看到的——将处理登机状态的逻辑移动到它自己的方法中。然而，我将推迟这样做，以展示
    `switch` 表达式。
- en: Converting to switch expressions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为 `switch` 表达式
- en: '**Switch expressions** are an evolution of switch statements that rely on **pattern-matching**
    expressions to simplify and expand what’s possible inside switch statements.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Switch 表达式** 是对 `switch` 语句的一种进化，它依赖于 **模式匹配** 表达式来简化并扩展 `switch` 语句内部可能实现的功能。'
- en: '`switch` expressions are a relatively new feature in C# that was released as
    part of C# 8 in 2019\. While that’s more than a few years old at the time of writing,
    I still find switch expressions to be new enough that many C# developers are unfamiliar
    or unpracticed with them.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式是 C# 中相对较新的功能，于 2019 年作为 C# 8 的一部分发布。尽管在撰写本文时已经过去几年了，但我仍然觉得 `switch`
    表达式足够新，以至于许多 C# 开发者对它们不熟悉或不熟练。'
- en: 'A simple `switch` expression looks a lot like a switch statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 `switch` 表达式看起来很像 `switch` 语句：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These `switch` expressions look very similar to switch statements except for
    the following aspects:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `switch` 表达式看起来与 `switch` 语句非常相似，除了以下方面：
- en: They start with the value you want to evaluate followed by the `switch` keyword
    instead of starting with `switch (value)`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们以你想要评估的值开始，后面跟着 `switch` 关键字，而不是以 `switch (value)` 开始
- en: We don’t use the `case` or `break` keywords
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不使用 `case` 或 `break` 关键字
- en: Individual cases have some condition that might be true on the left, an arrow
    notation (`=>`), and then the value to use on the right if the condition on the
    left is true.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个情况有一些条件，可能在左侧为真，然后是一个箭头符号 (`=>`)，以及如果左侧的条件为真，则在右侧使用的值。
- en: Instead of the `default` keyword, we have `_`, indicating any other match
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有使用 `default` 关键字，而是用 `_` 表示任何其他匹配项。
- en: One of the nice things about `switch` expressions is that they’re extremely
    concise while still being somewhat readable. However, there’s more power to `switch`
    expressions than what I’ve shown you so far.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式的一个优点是它们非常简洁，同时仍然具有一定的可读性。然而，`switch` 表达式的功能远不止我之前所展示的。'
- en: You may have noticed the sample `switch` expression I introduced a moment ago
    doesn’t adequately handle the logic for boarding. Specifically, we had rules for
    active military members, people who need assistance boarding, boarding groups,
    and priority lanes, and none of that is represented in the previous block of code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我之前引入的示例 `switch` 表达式没有充分处理登机逻辑。具体来说，我们为现役军人、需要登机帮助的人、登机组和优先通道制定了规则，而这些都没有在前面的代码块中表示出来。
- en: 'Let’s take a look at a `switch` expression that does handle these things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个处理这些情况的 `switch` 表达式：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code is a bit different than the last `switch` expression we saw. Here,
    the `Boarding` status is repeated four times and sometimes accompanied by the
    `when` keyword.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在上一节中看到的 `switch` 表达式略有不同。在这里，`Boarding` 状态重复了四次，有时还伴随着 `when` 关键字。
- en: What this code is doing is using pattern matching to check not just that `Status`
    is `Boarding`, but that other conditions are true as well. Effectively, we’re
    able to check the status and optionally another boolean expression after the `when`
    keyword.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码所做的是使用模式匹配来检查不仅 `Status` 是 `Boarding`，而且其他条件也成立。实际上，我们能够检查状态，并在 `when` 关键字之后可选地检查另一个布尔表达式。
- en: If both things are not true, the `switch` expression evaluates the next line
    in sequence. This makes `switch` expressions a set of matching rules that ensure
    the first rule evaluates to true.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个条件都不成立，`switch` 表达式将按顺序评估下一行。这使得 `switch` 表达式成为一组匹配规则，确保第一条规则评估为真。
- en: Pattern matching
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching is a newer C# syntax that allows you to concisely check different
    properties and aspects of objects and variables. We’ll explore pattern-matching
    syntax more in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209), *Defensive Coding
    Techniques*, but this section serves as a good introduction to some of its capabilities.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种较新的 C# 语法，允许您简洁地检查对象和变量的不同属性和方面。我们将在[*第 10 章*](B21324_10.xhtml#_idTextAnchor209)“防御性编码技术”中更深入地探讨模式匹配语法，但本节将作为对其一些功能的良好介绍。
- en: 'In other words, this `switch` expression checks the following rules and reacts
    to the first one that is true:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个 `switch` 表达式检查以下规则，并对第一个为真的规则做出反应：
- en: The plane has departed.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 飞机已经起飞。
- en: Boarding hasn’t started yet.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登机尚未开始。
- en: Boarding has started and the passenger is active military or needs assistance.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登机已经开始，乘客是现役军人或需要帮助。
- en: The passenger’s boarding group hasn’t been called yet.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘客的登机组尚未被召唤。
- en: The passenger’s group is boarding and it’s a priority lane group.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘客的登机组正在登机，并且是优先通道组。
- en: The passenger’s group is boarding but they’re not in the priority boarding lane.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘客的登机组正在登机，但他们不在优先登机通道。
- en: Any other status
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他任何状态
- en: '`switch` expressions are concise and allow you to mix the structured clarity
    of `switch` statements with the power of pattern matching and the `when` keyword
    to make very readable ordered logic apparent.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式简洁，允许您将 `switch` 语句的结构化清晰性与模式匹配和 `when` 关键字的力量结合起来，使非常易读的有序逻辑明显。'
- en: As with any tool in your programming toolbelt, `switch` expressions won’t be
    the solution to every problem and you and your team may not be as fond of reading
    `switch` expressions as I am. However, they remain a valuable tool in your toolbox
    for simplifying code while keeping it easy to read, maintain, and expand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您编程工具箱中的任何工具一样，`switch` 表达式并不是解决每个问题的方案，您和您的团队可能不会像我一样喜欢阅读 `switch` 表达式。然而，它们仍然是您工具箱中一个宝贵的工具，可以帮助简化代码，同时保持其易于阅读、维护和扩展。
- en: We’ll revisit some of the pattern-matching syntax in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    but let’s move on to looking at what we can do to improve working with collections
    of objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 10 章*](B21324_10.xhtml#_idTextAnchor209)中回顾一些模式匹配语法，但让我们继续看看我们可以如何改进处理对象集合的工作。
- en: Instantiating objects
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化对象
- en: Now that we’ve sufficiently improved our `CanPassengerBoard` method, let’s look
    at how we can create objects and see a few simple improvements you can make that
    will simplify object **instantiation** in your code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经足够改进了 `CanPassengerBoard` 方法，让我们看看我们如何创建对象，并看看您可以进行的一些简单改进，这将简化代码中的对象**实例化**。
- en: Terminology notes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 术语说明
- en: New developers are often tripped up by a handful of phrases that are commonly
    used by developers. For example, in this section, we will talk about instantiating
    objects. This is a common way of phrasing this for developers, but all it means
    is the process of creating a specific *instance* of a class using the `new` keyword.
    When you see the term instantiating, you can think of it simply as creating a
    specific instance of something.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 新的开发者经常被一些开发者常用的短语所困扰。例如，在本节中，我们将讨论实例化对象。这是开发者常用的说法，但这仅仅意味着使用 `new` 关键字创建类的特定*实例*的过程。当您看到术语实例化时，您可以简单地将其视为创建某个特定实例的过程。
- en: This section’s code could come from anywhere, but we’ll focus on code found
    in a pair of methods in the `PassengerTests.cs` file in the test project that
    accompanies this chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的代码可能来自任何地方，但我们将关注本章附带测试项目中 `PassengerTests.cs` 文件中找到的一对方法中的代码。
- en: Replacing var with explicit Types
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 `var` 替换为显式类型
- en: 'The first line of code I want to focus on comes from one of our unit tests:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要关注的代码第一行来自我们的一些单元测试：
- en: PassengerTests.cs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: PassengerTests.cs
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, I’ve deliberately omitted the context of the code from the surrounding
    lines to reinforce a point, and the point is this: take a moment and try to determine
    what data type the `p` variable is.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我故意省略了代码周围的上下文，以强调一个观点，这个观点是：花点时间，尝试确定 `p` 变量的数据类型。
- en: '`p` stores the result of `Build`, which takes in a pair of parameters named
    `first` and `last`, but we can’t make a confident assertion about what type of
    data `p` holds from this line alone.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`p` 存储了 `Build` 的结果，`Build` 接受一个名为 `first` 和 `last` 的参数对，但仅从这一行我们无法自信地断定 `p`
    包含的数据类型。'
- en: This is because `p` was declared with the `var` keyword. The `var` keyword is
    a shorthand way of saying “Hey, compiler, when you’re compiling this code, I want
    you to determine what data type this is going to be and replace the `var` keyword
    in the compiled code with the actual type of the data.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `p` 是用 `var` 关键字声明的。`var` 关键字是一种简写方式，意思是“嘿，编译器，当你编译这段代码时，我希望你确定这个数据类型，并在编译后的代码中将
    `var` 关键字替换为实际的数据类型。”
- en: In other words, `var` is usually a shortcut for not typing out the full name
    of the data type in question. However, it comes with a small penalty in that it
    makes it harder to read what data type the variable contains.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`var` 通常是为了不输入数据类型的完整名称而简化的快捷方式。然而，它带来一个小小的代价，那就是它使得阅读变量包含的数据类型变得更困难。
- en: This makes sense for when you have a complex data type such as `IDictionary<Guid,
    HashSet<string>>`, but it can get a little ridiculous for short type names such
    as `int`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于具有复杂数据类型（如 `IDictionary<Guid, HashSet<string>>`）的情况是有意义的，但对于短类型名（如 `int`）可能会有些荒谬。
- en: Other uses of var
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 的其他用法'
- en: The `var` keyword does have other uses beyond what I’ve described here. For
    example, it can easily store `var` in most codebases.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字确实有其他用途，超出了我这里所描述的。例如，它可以在大多数代码库中轻松存储 `var`。'
- en: Visual Studio does let you hover over the variable declaration and see the actual
    Type being used. In this case, `p` represents a `Passenger` object, but this still
    slows down your reading of the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 允许你悬停在变量声明上，并查看实际使用的类型。在这种情况下，`p` 代表一个 `Passenger` 对象，但这仍然会减慢你的阅读速度。
- en: 'Instead, I recommend that you take advantage of the built-in **Use explicit
    type instead of ‘var’** refactoring. See *Figure 3**.5*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我建议你利用内置的 **使用显式类型代替 'var'** 重构功能。参见 *图 3.5*：
- en: '![Figure 3.5 – Using explicit types](img/B21324_03_05.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 使用显式类型](img/B21324_03_05.jpg)'
- en: Figure 3.5 – Using explicit types
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 使用显式类型
- en: 'This makes your code significantly easier to read:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得你的代码更容易阅读：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, `var` exists for a reason and it was introduced to solve certain
    problems, including redundancy in assignment statements. We’ll take a look at
    the **target-typed new** keyword next that offers a different solution to that
    problem.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`var` 存在是有原因的，它被引入是为了解决某些问题，包括赋值语句中的冗余。接下来，我们将看看 **目标类型的新** 关键字，它为解决这个问题提供了不同的解决方案。
- en: Simplifying creation with target-typed new
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用目标类型的新简化创建
- en: 'One of the things the `var` keyword was built to help with was lines such as
    the following variable instantiation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字被构建来帮助处理如下变量实例化之类的行：'
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we instantiate a new `Passenger` object and assign it to the new passenger
    variable, we repeat ourselves slightly on the left and right-hand sides of the
    assignment operator (`=`) by using the name of the `Passenger` class twice.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个新的 `Passenger` 对象并将其分配给新的乘客变量时，我们在赋值操作符（`=`）的左右两侧稍微重复了 `Passenger` 类的名称。
- en: The `var` keyword allowed us to simplify the creation of this object down to
    the still readable syntax of `var passenger = new Passenger();`. Here, `var` allows
    us to simplify the left-hand side of this assignment statement by abbreviating
    the type that’s used for the new variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字允许我们将创建此对象的简化到仍然可读的语法 `var passenger = new Passenger();`。在这里，`var`
    允许我们通过缩写用于新变量的类型来简化赋值语句的左侧。'
- en: C# 9 introduced the **target-typed new** keyword, which lets us simplify the
    right-hand side of the assignment operator by effectively saying that the type
    of class we’re instantiating is the same as the variable that acts as the target
    of the assignment operator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 引入了**目标类型的新**关键字，它允许我们通过有效地说明我们正在实例化的类的类型与作为赋值运算符目标的作用变量相同，从而简化赋值运算符右侧的语法。
- en: 'In other words, target-typed new is a way of telling C# to create the same
    type as the variable we’ll store the value in. This allows us to avoid `var` and
    not repeat ourselves:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，目标类型的新语法是告诉 C# 创建与我们将要存储值的变量相同类型的对象的一种方式。这允许我们避免使用 `var` 并避免重复：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I love this syntax and tend to use it in all my code. It can cause small bits
    of confusion for other developers the first time they see the feature, but that’s
    a minor one-time penalty for something that keeps your code concise and readable
    at the same time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢这种语法，并且倾向于在我的所有代码中使用它。第一次看到这个特性时，它可能会让其他开发者感到一些困惑，但这只是一个微不足道的单次代价，因为它同时保持了代码的简洁和可读性。
- en: Tip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Visual Studio gives you a **Use ‘new(…)’** option in the **Quick Action** menu
    that will let you change a traditional object instantiation to the target-typed
    new syntax.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 在**快速操作**菜单中提供了一个**使用‘new(…)’**选项，这将允许你将传统的对象实例化转换为目标类型的新语法。
- en: While we’re talking about creating objects, let’s look at how **object initializers**
    can help set properties on objects as you create them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论创建对象时，让我们看看**对象初始化器**如何在创建对象时帮助设置属性。
- en: Using object initializers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象初始化器
- en: 'Let’s take another look at that `Build` method from the previous example while
    focusing on configuring the created passenger object:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看上一个示例中的 `Build` 方法，同时关注配置创建的乘客对象：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code isn’t bad at all, but it does repeat itself a little.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身并不差，但它确实有点重复。
- en: Specifically, the code repeats the information of the object it configures each
    line by putting `passenger.` in front of each property before assigning a value
    to that property.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，代码通过在每行将 `passenger.` 放在属性前面，然后在分配值之前为该属性赋值，重复了它配置的对象的信息。
- en: This is very minimal with only two properties. But imagine a larger object with
    10 or more properties you want to configure. This code would get very repetitive
    and might even distract from the names of the properties that are being configured.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于只有两个属性来说非常简洁。但想象一下，如果你有一个具有10个或更多属性的大型对象需要配置，这段代码会变得非常重复，甚至可能会分散对正在配置的属性名称的注意力。
- en: 'While using a constructor that takes in parameters representing property values
    is one solution (and one we’ll explore in the next chapter), another solution
    is to use an **object initializer**. As you’re likely guessing, Visual Studio
    provides a **Quick Actions** refactoring for this, though the name **Object initialization
    can be simplified** (shown in *Figure 3**.6*) is a bit unusual:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用接受表示属性值的参数的构造函数是一种解决方案（我们将在下一章中探讨），另一种解决方案是使用**对象初始化器**。正如你可能猜到的，Visual
    Studio 为此提供了一个**快速操作**重构，尽管名称**对象初始化可以简化**（如图 3.6 所示）有些不寻常：
- en: '![Figure 3.6 – Simplifying object initialization](img/B21324_03_06.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 简化对象初始化](img/B21324_03_06.jpg)'
- en: Figure 3.6 – Simplifying object initialization
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 简化对象初始化
- en: 'Using this refactoring transforms our code into a sparser format:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种重构可以将我们的代码转换成更简洁的格式：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I love this syntax and it plays very nicely with the `init` and `required`
    properties, which we’ll explore in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    *Defensive Coding Techniques*. However, there is a downside to using object initializers:
    stack traces.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢这种语法，并且它与 `init` 和 `required` 属性配合得非常好，我们将在[*第 10 章*](B21324_10.xhtml#_idTextAnchor209)“防御性编码技术”中探讨这些属性。然而，使用对象初始化器也有一个缺点：堆栈跟踪。
- en: When you have an object initializer that sets several different properties of
    an object and an exception occurs that calculates the value to store, the exception
    doesn’t indicate which line of code the error occurred on or which property was
    about to be updated, only that it occurred somewhere in the initializer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个设置对象多个不同属性的初始化器，并且发生异常来计算要存储的值时，异常不会指出错误发生在哪一行代码或哪个属性即将被更新，而只是表明它在初始化器中的某个地方发生了。
- en: On the other hand, if you were using multiple lines setting individual properties,
    the exception details would identify the line in question. Of course, this might
    be an argument to avoid doing calculations in initializers that might produce
    exceptions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用多行设置单个属性，异常详细信息将标识有问题的行。当然，这可能是一个避免在可能产生异常的初始化器中进行计算的论据。
- en: We’ll revisit initializers more in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)
    when we discuss `init`, `required`, and `with` expressions, but for now, let’s
    move on to talking about collections.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`init`、`required`和`with`表达式时，我们将在[*第10章*](B21324_10.xhtml#_idTextAnchor209)中更详细地回顾初始化器，但就目前而言，让我们继续讨论集合。
- en: Iterating over collections
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'To start exploring collections, let’s go back to the `BoardingProcessor` class
    and look at its `DisplayPassengerBoardingStatus` method. We’ll explore this method
    a bit at a time, starting with its method signature:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始探索集合，让我们回到`BoardingProcessor`类，看看它的`DisplayPassengerBoardingStatus`方法。我们将一次探索这个方法的一部分，从它的方法签名开始：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can see that the method takes in a list of `Passenger` objects and,
    optionally, a nullable boolean `hasBoarded` parameter that can store `true`, `false`,
    or `null`. This `hasBoarded` parameter is used to optionally filter down our list
    of passengers based on its value:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到该方法接受一个`Passenger`对象列表，以及一个可选的可空布尔参数`hasBoarded`，它可以存储`true`、`false`或`null`。这个`hasBoarded`参数用于根据其值可选地过滤我们的乘客列表：
- en: '`true`: Only include passengers who have boarded the plane'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`：仅包括已经登机的乘客'
- en: '`false`: Only include passengers who have not yet boarded'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`：仅包括尚未登机的乘客'
- en: '`null`: Do not filter by boarded status (default option)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`：不按登机状态过滤（默认选项）'
- en: This nullable filtering parameter is a common one I see while building search
    methods and we’ll explore it in more depth again in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101),
    *Object-oriented Refactoring*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建搜索方法时，我经常看到这种可空的过滤参数，我们将在[*第5章*](B21324_05.xhtml#_idTextAnchor101) *面向对象重构*中更深入地探讨它。
- en: 'The next portion of code in `DisplayBoardingStatus` deals with the filtering
    logic:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayBoardingStatus`中的下一部分代码处理过滤逻辑：'
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the portion of code we’ll be focusing on for the rest of this section.
    It builds a new list of passengers that matches the filtering option the user
    selected by iterating over the passengers in `passengers.` and conditionally adds
    it to our new list of passengers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在本节剩余部分重点关注的代码部分。它通过遍历`passengers`中的乘客并条件性地将其添加到我们的新乘客名单中，构建了一个与用户选择的过滤选项相匹配的新乘客名单。
- en: Terminology note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 术语说明
- en: '**Iterating** over something is another term that confuses new developers.
    It just means looping through each item in a collection.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代**某个东西是另一个让新开发者感到困惑的术语。它仅仅意味着遍历集合中的每个项目。'
- en: 'The remainder of the method focuses on displaying passengers to the agent at
    the boarding kiosk:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法剩余部分专注于在登机柜台向代理人显示乘客：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Essentially, for every passenger that we want to display, we write out their
    name, boarding group, and the message they see on their boarding app or `"Onboard"`
    if they’ve already boarded the plane.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于我们要显示的每一位乘客，我们都会写出他们的名字、登机组和他们在登机应用上看到的消息，或者如果他们已经登机，则是`"Onboard"`。
- en: Overall, this method is simple and comes in at less than 20 lines of code long,
    which tends to lead to easy-to-maintain code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个方法很简单，代码行数不到20行，这往往会导致易于维护的代码。
- en: That said, let’s look at a few ways we could improve this code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看我们可以如何改进这段代码。
- en: Introducing foreach
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 foreach
- en: 'Take another look at the code to filter the passenger list into a new list
    of passengers:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看代码，将乘客名单过滤到一个新的乘客名单中：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While this code isn’t very involved, one of the things that jumps out to me
    is that we’re using a `for` loop to enumerate through the passengers. Inside this
    loop, we’re not doing anything with our index variable, `i`, aside from getting
    a passenger out of the list by its index.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码并不复杂，但让我印象深刻的一点是我们正在使用`for`循环来枚举乘客。在这个循环内部，我们除了通过索引从列表中获取乘客之外，并没有对索引变量`i`做任何事情。
- en: Whenever you have a `for` loop like this that isn’t doing anything complex (for
    example, starting anywhere but the beginning of the list, looping in reverse,
    or skipping every other item), you can usually replace the loop with a `foreach`
    loop.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个像这样的`for`循环，它没有做任何复杂的事情（例如，从列表的任何地方开始，反向循环，或者跳过每隔一个项目），你通常可以用`foreach`循环来替换这个循环。
- en: 'To convert a `for` loop into a `foreach` loop, you can select the `for` loop
    and then use the **Convert to ‘foreach’** refactoring feature that’s built into
    Visual Studio (*Figure 3**.7*):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `for` 循环转换为 `foreach` 循环，您可以选中 `for` 循环，然后使用 Visual Studio 中内置的 **转换为‘foreach’**
    重构功能（*图 3**.7*）：
- en: '![Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions
    menu](img/B21324_03_07.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 快速操作菜单中的“转换为‘foreach’”重构选项](img/B21324_03_07.jpg)'
- en: Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions
    menu
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 快速操作菜单中的“转换为‘foreach’”重构选项
- en: 'This moves to a `foreach` loop and gets rid of the variable declaration entirely:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换为 `foreach` 循环，并完全消除了变量声明：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I use `foreach` wherever I can because not only does it remove a variable declaration
    and use of the indexer, but it makes the overall code easier to read.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我在可能的地方都使用 `foreach`，因为它不仅消除了变量声明和使用索引器的需要，而且使整体代码更容易阅读。
- en: '*Almost all* `for` loops start at 0 and loop up to the end of the collection
    one item at a time, but not every `for` loop does this. As a result, whenever
    I read a `for` loop, I need to check if it is a standard `for` loop or if there’s
    something special about it. With a `foreach` loop, I don’t need to do this because
    the syntax doesn’t support it. This increases reading comfort and speed and improves
    the maintainability of your code through simplicity.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*几乎所有* 的 `for` 循环都是从 0 开始，逐个元素地循环到集合的末尾，但并非每个 `for` 循环都是这样。因此，每次我阅读一个 `for`
    循环时，我都需要检查它是否是一个标准的 `for` 循环，或者它是否有特殊之处。使用 `foreach` 循环时，我不需要这样做，因为语法不支持它。这增加了阅读的舒适度和速度，并通过简洁性提高了代码的可维护性。'
- en: Additionally, a `foreach` loop can be used with anything that implements `IEnumerable`,
    while `for` loops require the collection they loop over to have an indexer. This
    means that `foreach` loops can loop over more types of collections than `for`
    loops can.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`foreach` 循环可以与实现 `IEnumerable` 的任何东西一起使用，而 `for` 循环要求它们循环的集合具有索引器。这意味着 `foreach`
    循环可以循环比 `for` 循环更多的集合类型。
- en: Collection interfaces
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 集合接口
- en: .NET provides several collection interfaces, including `IEnumerable`, `ICollection`,
    `IList`, `IReadOnlyList`, and `IReadOnlyCollection`. Knowledge of these collection
    types is helpful but not required to read this book. See the *Further reading*
    section at the end of this chapter for a link to more information on these interfaces,
    but for now, know that an `IEnumerable` interface is just a fancy way of referring
    to something that can be looped over in a foreach loop.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了几个集合接口，包括 `IEnumerable`、`ICollection`、`IList`、`IReadOnlyList` 和 `IReadOnlyCollection`。了解这些集合类型有助于阅读本书，但不是必需的。请参阅本章末尾的
    *进一步阅读* 部分，以获取有关这些接口的更多信息，但就现在而言，要知道 `IEnumerable` 接口只是指可以在 `foreach` 循环中循环的某种东西的一种更复杂的方式。
- en: Converting to for loops
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为 for 循环
- en: While `foreach` loops are fantastic and my default loop in most cases, sometimes,
    you want to have a `for` loop for a little bit of added control. If you ever need
    to loop over a collection in a non-standard way or need to use the index variable
    for something other than reading a variable out of the collection, you usually
    will want to use a `for` loop.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `foreach` 循环很棒，并且在我的大多数情况下是默认循环，但有时你可能想要有一个 `for` 循环以获得更多控制。如果你需要以非标准方式循环集合，或者需要使用索引变量进行除读取集合变量之外的其他操作，你通常将想要使用
    `for` 循环。
- en: 'Visual Studio gives us a `foreach` loops into `for` loops for you. See *Figure
    3**.8*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为我们提供了将 `foreach` 循环转换为 `for` 循环的功能。参见 *图 3**.8*：
- en: '![Figure 3.8 – Converting a foreach loop back to a for loop](img/B21324_03_08.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 将 foreach 循环转换回 for 循环](img/B21324_03_08.jpg)'
- en: Figure 3.8 – Converting a foreach loop back to a for loop
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 将 foreach 循环转换回 for 循环
- en: I don’t find myself using this refactoring very much, but it’s handy when you
    need it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不经常使用这种重构，但当你需要时它很方便。
- en: For now, let’s leave the code in a `foreach` loop and look at how LINQ can help
    us make it better.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时将代码留在 `foreach` 循环中，看看 LINQ 如何帮助我们改进它。
- en: Converting to LINQ
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为 LINQ
- en: You may have noticed that, in *Figure 3**.8*, there were a pair of suggestions
    to convert the `foreach` loop into LINQ.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在 *图 3**.8* 中，有一对建议将 `foreach` 循环转换为 LINQ。
- en: '`IEnumerable`. This allows you to perform quick aggregation, transformation,
    and filtering operations on that collection using arrow functions.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`。这允许你使用箭头函数对该集合执行快速聚合、转换和过滤操作。'
- en: Arrow functions
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Arrow functions (also called Lambda expressions) use “fat arrow” (`=>`) syntax
    to represent small methods in an abbreviated format. This book assumes a basic
    understanding of arrow functions. See the *Further reading* section of this chapter
    if you need more information or want a refresher on how arrow functions work.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数（也称为 Lambda 表达式）使用“胖箭头”(`=>`)语法以缩略格式表示小方法。本书假设你对箭头函数有基本了解。如果你需要更多信息或想要复习箭头函数的工作方式，请参阅本章的*进一步阅读*部分。
- en: 'Let’s look at what happens to our `foreach` loop when we use the `foreach`
    loop’s **Quick** **Actions** menu:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们使用 `foreach` 循环的**快速操作**菜单时，我们的 `foreach` 循环会发生什么变化：
- en: '![Figure 3.9 – Converting a foreach loop to use LINQ](img/B21324_03_09.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 将 foreach 循环转换为使用 LINQ](img/B21324_03_09.jpg)'
- en: Figure 3.9 – Converting a foreach loop to use LINQ
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 将 foreach 循环转换为使用 LINQ
- en: 'This refactoring transforms our `foreach` loop into just a tiny portion of
    code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此重构将我们的 `foreach` 循环转换成极小的一部分代码：
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code takes our `passengers` collection and calls the `Where` extension
    method. The `Where` method will create and return a new `IEnumerable` sequence
    of `passengers` and only includes `passengers` where the arrow function, `p =>
    !hasBoarded.HasValue || p.HasBoarded == hasBoarded`, returns a value of `true`
    for that passenger.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码获取我们的 `passengers` 集合并调用 `Where` 扩展方法。`Where` 方法将创建并返回一个新的 `IEnumerable`
    序列，其中只包含 `passengers`，其中箭头函数 `p => !hasBoarded.HasValue || p.HasBoarded == hasBoarded`
    对该乘客返回值为 `true`。
- en: Extension methods
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Extension methods are static methods defined in static classes that allow you
    to build syntax that looks like it adds new methods to existing types. LINQ relies
    heavily on extension methods attached to various interfaces. We’ll explore creating
    extension methods in [*Chapter 4*](B21324_04.xhtml#_idTextAnchor072).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是在静态类中定义的静态方法，允许你构建看起来像为现有类型添加新方法的语法。LINQ 严重依赖于附加到各种接口的扩展方法。我们将在[*第4章*](B21324_04.xhtml#_idTextAnchor072)中探讨创建扩展方法。
- en: This won’t modify our original collection, instead creating a new collection
    of `Passenger` objects that are then passed into the `filteredPassengers.AddRange`
    method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会修改我们的原始集合，而是创建一个新的 `Passenger` 对象集合，然后将其传递到 `filteredPassengers.AddRange`
    方法中。
- en: While this code is already very brief, we can improve it further by taking advantage
    of a constructor on the generic `List` class.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码已经很简洁了，但我们可以通过利用泛型 `List` 类的构造函数来进一步改进它。
- en: 'The `List<T>` class has a constructor that takes in an `IEnumerable<T>` interface
    and allows you to efficiently create a new list around a sequence of elements.
    This will let us avoid needing the `AddRange` call and helps simplify our code
    down to a single statement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 类有一个构造函数，它接受一个 `IEnumerable<T>` 接口，并允许你围绕一系列元素高效地创建一个新的列表。这将使我们避免需要
    `AddRange` 调用，并有助于将我们的代码简化到单条语句：'
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we wanted to, we could also get rid of the `filteredPassengers` variable
    entirely by filtering passengers down and reassigning it back into itself:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们也可以完全删除 `filteredPassengers` 变量，通过过滤乘客并将其重新赋值回自身：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we perform the `Where` call to generate an `IEnumerable<Passenger>` interface
    containing our passengers and then call the `ToList` method on that `IEnumerable`
    interface to convert it back into a `List` method so that it can be stored in
    the `passengers` parameter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行 `Where` 调用来生成包含我们的乘客的 `IEnumerable<Passenger>` 接口，然后在该 `IEnumerable`
    接口上调用 `ToList` 方法，将其转换回 `List` 方法，以便它可以存储在 `passengers` 参数中。
- en: 'Also, note that any place that was using `filteredPassengers` before will need
    to be updated to use `passengers` instead:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意之前使用 `filteredPassengers` 的任何地方都需要更新为使用 `passengers`：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I love LINQ and find it to be invaluable for creating simple and maintainable
    applications, but it does take some getting used to if you’re not familiar with
    LINQ or not used to reading arrow function (`=>`) notation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 LINQ，并认为它对于创建简单且可维护的应用程序非常有价值，但如果你不熟悉 LINQ 或不习惯阅读箭头函数（`=>`）的表示法，它可能需要一些习惯。
- en: That said, I do see some common mistakes in LINQ code. So, let’s look at a few
    of those before we close out this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我确实在 LINQ 代码中看到了一些常见的错误。因此，在我们结束这一章之前，让我们看看其中的一些。
- en: Refactoring LINQ statements
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构 LINQ 语句
- en: In this final section of this chapter, we’ll review a few of the more common
    optimizations with LINQ code by focusing on some common improvements most codebases
    that use LINQ will benefit from.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将通过关注大多数使用 LINQ 的代码库都将从中受益的一些常见改进，来回顾一些 LINQ 代码中更常见的优化。
- en: Choosing the correct LINQ method
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的LINQ方法
- en: LINQ has several different ways of finding a specific item in a collection.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ有几种不同的方法来在集合中查找特定的项。
- en: 'If you had an `IEnumerable<Passenger>` interface named `people` and wanted
    to find someone by their name, you might write code like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个名为`people`的`IEnumerable<Passenger>`接口，并且想通过他们的名字找到某人，你可能会编写如下代码：
- en: LinqExamples.cs
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: LinqExamples.cs
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code uses the LINQ `FirstOrDefault` method, which searches the collection
    until it finds the first value that the arrow function evaluates as true. In this
    example, it’d find the first person with `FullName` set to `"Matt Eland"`, return
    that value from the `FirstOrDefault` method, and store it in the `Passenger` variable
    named `matt`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了LINQ的`FirstOrDefault`方法，该方法搜索集合直到找到箭头函数评估为`true`的第一个值。在这个例子中，它会找到第一个`FullName`设置为`"Matt
    Eland"`的人，从`FirstOrDefault`方法返回该值，并将其存储在名为`matt`的`Passenger`变量中。
- en: However, if no items returned `true` from the arrow function, `FirstOrDefault`
    will use the default value of the `Passenger` type, which would be null for a
    reference type such as a class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果箭头函数没有返回任何`true`的项，`FirstOrDefault`将使用`Passenger`类型的默认值，对于像类这样的引用类型，这将是一个空值。
- en: Default values
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值
- en: In .NET, the default value of `bool` is `false`, numeric types such as `int`
    and `float` default to `0`, and reference types including `string`, `List`, and
    other classes default to `null`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，`bool`类型的默认值是`false`，数值类型如`int`和`float`默认为`0`，而引用类型包括`string`、`List`和其他类默认为`null`。
- en: In other words, this `FirstOrDefault` call will find Matt if he exists in passengers
    and return him or return `null` if he doesn’t.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个`FirstOrDefault`调用将会找到如果Matt存在于乘客中，则返回他；如果他没有，则返回`null`。
- en: The problem with this is that the very next line attempts to read the value
    of `matt.BoardingGroup`. This is fine if we found the element, but if we didn’t,
    this code will get a `NullReferenceException` error upon trying to access `BoardingGroup`,
    which is likely not what its author intended.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于紧接着的下一行尝试读取`matt.BoardingGroup`的值。如果我们找到了元素，这没问题，但如果我们没有找到，这段代码在尝试访问`BoardingGroup`时将引发`NullReferenceException`错误，这很可能不是其作者的意图。
- en: Note that how we fix this code depends on what our expectations are.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们如何修复这段代码取决于我们的期望是什么。
- en: 'With LINQ, when you are looking for an element in a collection, you need to
    decide on two things:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LINQ，当你在一个集合中查找元素时，你需要决定两件事：
- en: Am I okay with more than one item matching my arrow function or do I need to
    make sure that *at most* one item returns true?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否可以接受多于一个项匹配我的箭头函数，或者我需要确保最多只有一个项返回`true`？
- en: Am I okay with the item I’m looking for not being present at all?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否可以接受我寻找的项目根本不存在？
- en: The first decision governs whether you are making a call to `First` or `Single`.
    With `First`, the logic will find the first element that matches the query and
    return it. However, with `Single`, the logic will keep going past the first match
    to determine if any other element in the collection matches that expression as
    well. If one does match the expression, an `InvalidOperationException` error is
    thrown, telling you that the sequence contains more than one matching element.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个决定决定了你是否调用`First`或`Single`。使用`First`，逻辑将找到与查询匹配的第一个元素并返回它。然而，使用`Single`，逻辑将超出第一个匹配项，以确定集合中的任何其他元素是否也匹配该表达式。如果有一个匹配该表达式，将抛出一个`InvalidOperationException`错误，告诉你序列包含多个匹配元素。
- en: Most developers don’t like seeing exceptions when they’re running their code.
    However, sometimes, you need to know if there’s more than one match to your query.
    In general, it’s better to fail early than fail later in a more confusing spot
    that hides where the program first got off track.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者不喜欢在运行代码时看到异常。然而，有时你需要知道你的查询是否有多于一个匹配项。一般来说，尽早失败比在更混乱的地方失败要好，那里隐藏着程序最初偏离轨道的地方。
- en: The second decision you make when finding an element in a collection involves
    being okay with objects not being present that match the query. If that’s fine,
    then you will generally want to make a call to `FirstOrDefault` or `SingleOrDefault`
    (depending on your decision earlier on whether multiple matches are permissible).
    However, if it is never acceptable to not have a match, then you’ll use `First`
    or `Single` instead of `FirstOrDefault` or `SingleOrDefault`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在集合中查找元素时，你做出的第二个决定是接受不匹配查询的对象。如果这没问题，那么你通常会调用`FirstOrDefault`或`SingleOrDefault`（根据你之前是否允许多个匹配的决定）。然而，如果永远不能接受没有匹配项，那么你将使用`First`或`Single`而不是`FirstOrDefault`或`SingleOrDefault`。
- en: '`First` and `Single` will both throw an `InvalidOperationException` error if
    the sequence contains no matching element. If you use `First` or `Single` and
    nothing in the collection returns `true` from the arrow function, the exception
    will be thrown. This makes it impossible to deal with `null` values with the result
    of `First` or `Single`, which can be very helpful for simplifying your code.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列中没有匹配的元素，`First`和`Single`都会抛出`InvalidOperationException`错误。如果你使用`First`或`Single`，并且集合中没有元素返回箭头函数的`true`，则会抛出异常。这使得无法处理`First`或`Single`的结果中的`null`值，这对于简化代码非常有帮助。
- en: Tip
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Having an `InvalidOperationException` error thrown at the exact position your
    code encounters a problem can be immensely more helpful than encountering a `NullReferenceException`
    error 30 lines later in your code and having to figure out how a value got where
    it was supposed to be.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码在遇到问题时抛出`InvalidOperationException`错误，这通常比在代码中30行后遇到`NullReferenceException`错误并需要找出值是如何到达预期位置的要有用得多。
- en: '`NullReferenceException` error from occurring. We’ll explore this in more depth
    in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 防止出现`NullReferenceException`错误。我们将在[*第10章*](B21324_10.xhtml#_idTextAnchor209)中更深入地探讨这个问题。
- en: Let’s move on and discuss ways of combining LINQ methods.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论组合LINQ方法的方法。
- en: Combining LINQ methods
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合LINQ方法
- en: One of the nice things about LINQ is that it lets you “chain together” different
    methods by calling a LINQ method on the result of another LINQ method. This lets
    you do things such as filter down to a subset of items using `Where`, reorder
    the results with `OrderBy`, and transform them into new objects via `Select`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ的一个优点是它允许你通过在另一个LINQ方法的结果上调用LINQ方法来“链式连接”不同的方法。这让你可以做诸如使用`Where`过滤到项目子集、使用`OrderBy`重新排序结果以及通过`Select`将它们转换成新对象等事情。
- en: However, as .NET has evolved, LINQ has grown a few more specialized overloads
    of its existing methods, which makes some of these chained-together methods unnecessary
    or even inefficient.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着.NET的发展，LINQ为其现有方法增加了一些更专业的重载，这使得一些链式连接的方法变得不必要，甚至效率低下。
- en: 'Look at this block of code as an example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码块为例：
- en: '[PRE43]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At first glance, this code looks fine. Each of these three variable assignments
    is filtering down and then looking at the results of that filtering option. Sure,
    there’s an opportunity to introduce a local variable for `people.Where(p => p.HasBoarded)`,
    but otherwise, the code often looks fine at a glance.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这段代码看起来没问题。这三个变量赋值都是过滤然后查看过滤结果。当然，有引入局部变量`people.Where(p => p.HasBoarded)`的机会，但除此之外，代码在表面上看起来通常没问题。
- en: However, LINQ offers overloaded versions of `Any`, `Count`, `First`, and a few
    other methods that take in a **predicate** (which is just a fancy word for an
    arrow function).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LINQ提供了`Any`、`Count`、`First`和其他一些方法的重载版本，这些方法接受一个**谓词**（这只是一个箭头函数的华丽说法）。
- en: 'These overloaded versions allow you to combine `Where` methods and other methods
    into a more concise format:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重载版本允许你将`Where`方法和其他方法组合成一个更简洁的格式：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Not only is this way of writing things more concise, but these overloads can
    be more efficient in some cases.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种写法不仅更简洁，而且在某些情况下可能更高效。
- en: For example, before, when we were doing `people.Where(p => p.HasBoarded).Any()`,
    this code evaluated left to right, filtering down a large list of items into a
    smaller list of items. Once the entire list had been filtered down, the `Any`
    method call occurred, which returned `true` if at least one item was found in
    that resulting list.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在此之前，当我们执行`people.Where(p => p.HasBoarded).Any()`时，此代码从左到右进行评估，将大量项目过滤成一个更小的项目列表。一旦整个列表被过滤，就会调用`Any`方法，如果结果列表中至少有一个项目，则返回`true`。
- en: Contrast this to the `people.Any(p => p.HasBoarded)` version. This method loops
    over the items and as soon as it sees any element that returns `true` from the
    arrow function, it knows it can stop evaluating because its ultimate result is
    going to be true.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与`people.Any(p => p.HasBoarded)`版本进行对比。这个方法遍历项目，一旦它看到任何从箭头函数返回`true`的元素，它就知道它可以停止评估，因为它的最终结果将是true。
- en: Always look for opportunities to use these specialized LINQ overloads as they
    can result in very concise and even more performant code.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 总是寻找使用这些专用LINQ重载的机会，因为它们可以产生非常简洁甚至更高效的代码。
- en: Transforming with Select
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Select进行转换
- en: Let’s say you wanted to create a list of strings for all the passengers who
    hadn’t boarded the plane yet. For each name, you want it formatted with the person’s
    name and then their boarding group. So, a sample entry might be `"``Priya Gupta-7"`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要创建一个列表，列出所有尚未登机的乘客的字符串。对于每个名字，你想要将其格式化为乘客的名字和登机组。因此，一个示例条目可能是`"Priya Gupta-7"`。
- en: 'You could write this code as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样编写此代码：
- en: '[PRE45]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, LINQ has a method named `Select` that allows you to transform items
    from one form into another, which would be perfect for this case.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LINQ有一个名为`Select`的方法，允许你将项目从一种形式转换为另一种形式，这对于这种情况来说非常完美。
- en: Tip
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For those of you with a JavaScript background, `Select` is similar to the `Map`
    function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有JavaScript背景的人来说，`Select`函数与`Map`函数类似。
- en: 'The `Select` version of this looks like this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Select`版本看起来是这样的：
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, the `Where` call filtered the results down to non-boarded passengers and
    the `Select` call transformed those objects from `Passenger` objects into strings.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Where`调用将结果过滤到未登机的乘客，而`Select`调用将那些对象从`Passenger`对象转换为字符串。
- en: '`Select` isn’t limited to just strings. You can select whatever data type is
    relevant for you, including integers, other objects, lists, or even **anonymous
    types** or **tuples**.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select`不仅限于字符串。你可以选择对你相关的任何数据类型，包括整数、其他对象、列表，甚至是**匿名类型**或**元组**。'
- en: Ultimately, whenever you have a collection of objects in one shape and you need
    those same objects but in a different form, `Select` is a great method to consider.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，无论你有一个形状的对象集合，并且你需要这些相同的对象但以不同的形式，`Select`都是一个值得考虑的好方法。
- en: Reviewing and testing our refactored code
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和测试重构后的代码
- en: While we didn’t modify a lot of code in this chapter, the code we did change
    shrunk in size, thus becoming easier to read, understand, and modify in the process.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这章中没有修改很多代码，但我们修改的代码在尺寸上缩小了，因此在阅读、理解和修改过程中变得更加容易。
- en: This is why we refactor. Refactoring should actively improve the maintainability
    of our applications and pay down strategic pieces of technical debt that threaten
    to introduce bugs and delays in the future.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们要重构。重构应该积极地提高我们应用程序的可维护性，并偿还那些可能在未来引入错误和延迟的战略性技术债务。
- en: Refactored code
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-Csharp](https://github.com/PacktPublishing/Refactoring-with-Csharp)
    repository inside the `Chapter03/Ch3RefactoredCode` folder.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最终的重构代码可在[https://github.com/PacktPublishing/Refactoring-with-Csharp](https://github.com/PacktPublishing/Refactoring-with-Csharp)仓库中的`Chapter03/Ch3RefactoredCode`文件夹中找到。
- en: Since the art of refactoring involves changing the form of code without changing
    its functionality, we must test the application before moving on.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重构的艺术在于在不改变其功能的情况下改变代码的形式，我们必须在继续之前测试应用程序。
- en: We’ll talk more about manual and automated tests in [*Chapter 6*](B21324_06.xhtml#_idTextAnchor133),
    but for now, run the tests by selecting the **Test** menu at the top of Visual
    Studio and then clicking **Run** **All Tests**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B21324_06.xhtml#_idTextAnchor133)中更多地讨论手动和自动测试，但到目前为止，通过在Visual
    Studio顶部选择**测试**菜单，然后点击**运行****所有测试**来运行测试。
- en: 'This will show **Test Explorer** and a sea of green check marks, as shown in
    *Figure 3**.10*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示**测试资源管理器**和一大片绿色勾号，如图*图3.10*所示。
- en: '![Figure 3.10 – Passing tests for this chapter’s code](img/B21324_03_10.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 通过测试本章的代码](img/B21324_03_10.jpg)'
- en: Figure 3.10 – Passing tests for this chapter’s code
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 通过测试本章的代码
- en: Now, let’s summarize what we’ve learned in this chapter.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored refactoring techniques to help better control program
    flow, instantiate objects, iterate over collections, and write more efficient
    code through LINQ.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了重构技术，以帮助更好地控制程序流程、实例化对象、遍历集合，并通过 LINQ 编写更高效的代码。
- en: Each refactoring technique we covered is one tool in your toolbelt that might
    improve the readability and maintainability of your code in the right circumstances.
    As you practice refactoring more, you’ll learn more about when to apply which
    refactoring to improve the code you’re working with.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的每种重构技术都是你工具箱中的一个工具，它可能在适当的情境下提高你代码的可读性和可维护性。随着你不断练习重构，你会了解更多关于何时应用哪种重构来改进你正在工作的代码。
- en: In the next chapter, we’ll move on from improving individual lines of code and
    focus on a slightly bigger picture as we work to refactor entire methods of C#
    code.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从改进单个代码行转向一个更大的视角，当我们努力重构整个 C# 代码的方法时。
- en: Questions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: Is it more important to have concise code or readable code?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简洁的代码和可读的代码哪个更重要？
- en: Scroll through a file of code in a project you are working on. What do you notice
    about the `if` statements in your code?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你正在工作的项目中浏览代码文件。你注意到你的代码中的 `if` 语句有什么特点？
- en: How frequently are nested `if` statements used?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套的 `if` 语句使用频率如何？
- en: Is any logic repeated frequently in conditions of your `if` statements?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的 `if` 语句的条件中是否有任何逻辑被频繁重复？
- en: Do you see any places where inverting the `if` statement or switching to a `switch`
    statement or `switch` expression could improve things?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否看到任何可以通过反转 `if` 语句或切换到 `switch` 语句或 `switch` 表达式来改进的地方？
- en: Do you think your team has been using LINQ to its fullest potential when working
    with collections? What opportunities for improvement do you see?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为你的团队在处理集合时是否已经充分利用了 LINQ 的潜力？你看到了哪些改进的机会？
- en: Further reading
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about the materials discussed in this chapter
    by reading the following resources:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读以下资源来找到更多关于本章讨论的材料的信息：
- en: '*Switch* *Expressions*: [https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression](https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Switch 表达式*：[https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression](https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression)'
- en: '*Differences between .NET Collection* *Interfaces*: [https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/](https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET 集合接口之间的差异*：[https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/](https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/)'
- en: '*Query Syntax and Method Syntax in* *LINQ*: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LINQ 中的查询语法和方法语法*：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq)'
- en: '*Explore Ranges of* *Data*: [https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*探索数据范围*：[https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes](https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes)'
- en: '*Arrow Functions and the Lambda* *Operator*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*箭头函数和 Lambda 操作符*：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator)'
