<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;High Performance Programming Using Parallel and Multithreading in C#"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. High Performance Programming Using Parallel and Multithreading in C#</h1></div></div></div><p>This chapter takes a look at improving your code's performance using multithreading and parallel programming. In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and aborting a low-priority background thread</li><li class="listitem" style="list-style-type: disc">Increasing maximum thread pool size</li><li class="listitem" style="list-style-type: disc">Creating multiple threads</li><li class="listitem" style="list-style-type: disc">Locking one thread until the contended resources are available</li><li class="listitem" style="list-style-type: disc">Invoking parallel calls to methods using <code class="literal">Parallel.Invoke</code></li><li class="listitem" style="list-style-type: disc">Using a parallel <code class="literal">foreach</code> loop to run multiple threads</li><li class="listitem" style="list-style-type: disc">Cancelling a parallel <code class="literal">foreach</code> loop</li><li class="listitem" style="list-style-type: disc">Catching errors in parallel <code class="literal">foreach</code> loops</li><li class="listitem" style="list-style-type: disc">Debugging multiple threads</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Introduction</h1></div></div></div><p>If you can find a single-core CPU in a computer today, it will probably mean that you are standing in a museum. Every new computer today utilizes the advantages of multiple cores. Programmers can take advantage of this extra processing power in their own applications. As applications have grown in size and complexity, in many cases they actually need to utilize multithreading.</p><p>While not every situation is always suited for the implementation of multithreaded code logic, it is good to know how to use multithreading to improve the performance of your applications. This chapter will take you through the fundamentals of this exciting technology in C# programming.</p></div></div>
<div class="section" title="Creating and aborting a low-priority background thread"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Creating and aborting a low-priority background thread</h1></div></div></div><p>The reason we want to have a look at a background thread specifically is because by default, all threads <a class="indexterm" id="id457"/>created by the main app thread or <code class="literal">Thread</code> class constructor are foreground threads. So, what exactly separates a foreground thread from a background thread? Well, background threads are identical to foreground threads with the exception that if all foreground threads are terminated, the background threads are<a class="indexterm" id="id458"/> stopped too. This is useful if you have a process in your application that must not stop the application from terminating. In other words, while your application is running, the background thread must continue to run.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Getting ready</h2></div></div></div><p>We will create a simple application that defines the thread created as a background thread. It will then suspend, resume, and abort the thread.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class library by right-clicking on your solution and selecting <span class="strong"><strong>Add</strong></span> and then <span class="strong"><strong>New Project</strong></span> from the context menu:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_01.jpg"/></div></li><li class="listitem">From the <a class="indexterm" id="id459"/><span class="strong"><strong>Add New Project</strong></span> dialog screen, select<a class="indexterm" id="id460"/> <span class="strong"><strong>Class Library</strong></span> from the installed templates and call your class <code class="literal">Chapter7</code>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_02.jpg"/></div></li><li class="listitem">Your new class library will be added to your solution with a default name <code class="literal">Class1.cs,</code> which<a class="indexterm" id="id461"/> we renamed to <code class="literal">Recipes.cs</code> in <a class="indexterm" id="id462"/>order to distinguish the code properly. You can, however, rename your class to whatever you like if that makes more sense to you.</li><li class="listitem">To rename your class, simply click on the class name in <span class="strong"><strong>Solution Explorer</strong></span> and select <span class="strong"><strong>Rename</strong></span> from the context menu:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_03.jpg"/></div></li><li class="listitem">Visual Studio <a class="indexterm" id="id463"/>will ask you to confirm a rename<a class="indexterm" id="id464"/> of all references to the code element <span class="strong"><strong>Class1</strong></span> in the project. Just click on <span class="strong"><strong>Yes</strong></span>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_04.jpg"/></div></li><li class="listitem">The following class is added to your <code class="literal">Chapter7</code> library project:<div class="informalexample"><pre class="programlisting">namespace Chapter7
{
    public class Recipes
    {
        
    }
}</pre></div></li><li class="listitem">Inside the <code class="literal">Recipes</code> class, add<a class="indexterm" id="id465"/> a method called <code class="literal">DoBackgroundTask()</code> with the <code class="literal">public void</code> modifiers, and add the following console<a class="indexterm" id="id466"/> output to it:<div class="informalexample"><pre class="programlisting">public void DoBackgroundTask()
        {
            WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} has a threadstate of {Thread.CurrentThread.ThreadState} with {Thread.CurrentThread.Priority} priority");
            WriteLine($"Start thread sleep at {DateTime.Now.Second} seconds");
            Thread.Sleep(3000);
            WriteLine($"End thread sleep at {DateTime.Now.Second} seconds");
        }</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Make sure that you have added the <code class="literal">using</code> statements for <code class="literal">System.Threading</code> and <code class="literal">static System.Console</code> to your <code class="literal">using</code> statements.</p></div></div></li><li class="listitem">Inside the console application called <code class="literal">CodeSamples</code>, added previously, add a reference to the <code class="literal">Chapter7</code> class library by right-clicking on <span class="strong"><strong>References</strong></span> under the <code class="literal">CodeSamples</code> project and selecting <span class="strong"><strong>Add Reference</strong></span> from the context menu:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_05.jpg"/></div></li><li class="listitem">In the <span class="strong"><strong>Reference Manager</strong></span> window, select the <code class="literal">Chapter7</code> solution by going to <span class="strong"><strong>Projects</strong></span> | <span class="strong"><strong>Solutions</strong></span>. This<a class="indexterm" id="id467"/> will allow you to<a class="indexterm" id="id468"/> use the classes we just created in your console application:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_06.jpg"/></div></li><li class="listitem">In the <code class="literal">void Main</code> method, create a new instance of your <code class="literal">Recipes</code> class and add it to a new thread called <code class="literal">backgroundThread</code>. Define this newly created thread to be a background thread and then start it. Finally, set the thread to sleep for five seconds. We need to do this because we have created a background<a class="indexterm" id="id469"/> thread that is set to sleep for three seconds. Background threads do not prohibit foreground threads from <a class="indexterm" id="id470"/>terminating. Therefore, if the main application thread (which is by default a foreground thread) terminates before the background thread completes, the application will terminate and also terminate the background thread:<div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
    Chapter7.Recipes oRecipe = new Chapter7.Recipes();
    var backgroundThread = new Thread(oRecipe.DoBackgroundTask);
    backgroundThread.IsBackground = true;
    backgroundThread.Start();
    Thread.Sleep(5000);
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Please note that you might need to add the <code class="literal">using System.Threading</code>; directive.</p></div></div></li><li class="listitem">Run your console application by pressing <span class="emphasis"><em>F5</em></span>. You will see that we have created a background thread with a normal priority:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_07.jpg"/></div></li><li class="listitem">Let's modify<a class="indexterm" id="id471"/> our thread and set its priority down <a class="indexterm" id="id472"/>to low. Add this line of code to your console application: <code class="literal">backgroundThread.Priority = ThreadPriority.Lowest;</code>. This line will downgrade the thread priority:<div class="informalexample"><pre class="programlisting">Chapter7.Recipes oRecipe = new Chapter7.Recipes();
var backgroundThread = new Thread(oRecipe.DoBackgroundTask);
backgroundThread.IsBackground = true;
backgroundThread.Priority = ThreadPriority.Lowest;
backgroundThread.Start();
Thread.Sleep(5000);</pre></div></li><li class="listitem">Run your console application again. This time, you will see that the thread priority has been set to the lowest priority:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_08.jpg"/></div></li><li class="listitem">Go back to your <code class="literal">DoBackgroundTask()</code> method and add <code class="literal">Thread.CurrentThread.Abort();</code> right before <code class="literal">Thread.Sleep(3000);</code> is called. This<a class="indexterm" id="id473"/> line will prematurely kill the<a class="indexterm" id="id474"/> background thread. Your code should look like this:<div class="informalexample"><pre class="programlisting">public void DoBackgroundTask()
{
    WriteLine($"Thread {Thread.CurrentThread.ManagedThreadId} has a threadstate of {Thread.CurrentThread.ThreadState} with {Thread.CurrentThread.Priority} priority");
    WriteLine($"Start thread sleep at {DateTime.Now.Second} seconds");
    Thread.CurrentThread.Abort();
    Thread.Sleep(3000);
    WriteLine($"End thread sleep at {DateTime.Now.Second} seconds");
}</pre></div></li><li class="listitem">When you run your console application, you will see that the thread is aborted before the <code class="literal">Thread.Sleep</code> method is called. Aborting a thread in this way, however, is generally not recommended:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_09.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec107"/>How it works…</h2></div></div></div><p>Being able to create<a class="indexterm" id="id475"/> a background thread is a great way to work on a different thread from the main thread while not interfering with the process of <a class="indexterm" id="id476"/>the main application thread. Another added benefit is that the background thread is terminated as soon as the main application thread is completed. This process ensures that your application will terminate gracefully.</p></div></div>
<div class="section" title="Increasing maximum thread pool size"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Increasing maximum thread pool size</h1></div></div></div><p>The thread pool in .NET resides in the <code class="literal">System.Threading.ThreadPool </code>class. Generally, there is a lot of discussion around creating your own threads as opposed to using the thread pool. Popular thinking dictates that the thread pool should be used for brief jobs. This is because the thread pool is limited in size. There are many other processes in the system that will use the thread pool. You therefore do not want your application to hog all the threads in the thread pool.</p><p>The rule is that you can't set the <a class="indexterm" id="id477"/>number of maximum worker or completion threads to be less than the number of processors on your computer. You are also not allowed to set the maximum worker or completion threads to less than the minimum thread pool size.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Getting ready</h2></div></div></div><p>We will read the number of processors on the current computer. Then, we will get the minimum and maximum allowable thread pool size, generate a random number between the minimum and<a class="indexterm" id="id478"/> maximum thread pool size, and set the maximum number of threads on the thread pool.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec109"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new method called <code class="literal">IncreaseThreadPoolSize()</code> in the <code class="literal">Recipes</code> class:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void IncreaseThreadPoolSize()
    {
        
    }
}</pre></div></li><li class="listitem">Start by adding the code to read the number of processors on the current machine using <code class="literal">Environment.ProcessorCount</code>:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void IncreaseThreadPoolSize()
    {
        int numberOfProcessors = Environment.ProcessorCount;
        WriteLine($"Processor Count = {numberOfProcessors}");
    }
}</pre></div></li><li class="listitem">Next, we will retrieve the maximum and minimum threads available in the thread pool:<div class="informalexample"><pre class="programlisting">int maxworkerThreads;
int maxconcurrentActiveRequests;
int minworkerThreads;
int minconcurrentActiveRequests;
ThreadPool.GetMinThreads(out minworkerThreads, out minconcurrentActiveRequests);
WriteLine($"ThreadPool minimum Worker = {minworkerThreads} and minimum Requests = {minconcurrentActiveRequests}");

ThreadPool.GetMaxThreads(out maxworkerThreads, out maxconcurrentActiveRequests);
WriteLine($"ThreadPool maximum Worker = {maxworkerThreads} and maximum Requests = {maxconcurrentActiveRequests}");</pre></div></li><li class="listitem">Then, we will generate a random number between the maximum and minimum number of threads in the thread pool:<div class="informalexample"><pre class="programlisting">Random rndWorkers = new Random();
int newMaxWorker = rndWorkers.Next(minworkerThreads, maxworkerThreads);
WriteLine($"New Max Worker Thread generated = {newMaxWorker}");

Random rndConRequests = new Random();
int newMaxRequests = rndConRequests.Next(minconcurrentActiveRequests, maxconcurrentActiveRequests);
WriteLine($"New Max Active Requests generated = {newMaxRequests}");</pre></div></li><li class="listitem">We now need to<a class="indexterm" id="id479"/> attempt to set the maximum number of threads in the thread pool by calling the <code class="literal">SetMaxThreads</code> method and setting it to our new random maximum value for the worker threads and the completion port threads. Any requests above this maximum number will be queued until the thread pool threads become active again. If the <code class="literal">SetMaxThreads</code> method is successful, the method will return true; otherwise, it will return <code class="literal">false</code>. It is a good idea to ensure that the <code class="literal">SetMaxThreads</code> method is successful:<div class="informalexample"><pre class="programlisting">bool changeSucceeded = ThreadPool.SetMaxThreads(newMaxWorker, newMaxRequests);
if (changeSucceeded)
{
     WriteLine("SetMaxThreads completed");
     int maxworkerThreadCount;
     int maxconcurrentActiveRequestCount;
     ThreadPool.GetMaxThreads(out maxworkerThreadCount, out maxconcurrentActiveRequestCount);
      WriteLine($"ThreadPool Max Worker = {maxworkerThreadCount} and Max Requests = {maxconcurrentActiveRequestCount}");
}
else
      WriteLine("SetMaxThreads failed");</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Worker threads is the maximum number of worker threads in the thread pool, while the completion port threads is the maximum number of asynchronous I/O threads in the thread pool.</p></div></div></li><li class="listitem">When you have<a class="indexterm" id="id480"/> added all the code in the steps listed, your <code class="literal">IncreaseThreadPoolSize()</code> method should look like this:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void IncreaseThreadPoolSize()
    {
        int numberOfProcessors = Environment.ProcessorCount;
        WriteLine($"Processor Count = {numberOfProcessors}");
            
        int maxworkerThreads;
        int maxconcurrentActiveRequests;
        int minworkerThreads;
        int minconcurrentActiveRequests;
        ThreadPool.GetMinThreads(out minworkerThreads, out minconcurrentActiveRequests);
        WriteLine($"ThreadPool minimum Worker = {minworkerThreads} and minimum Requests = {minconcurrentActiveRequests}");

        ThreadPool.GetMaxThreads(out maxworkerThreads, out maxconcurrentActiveRequests);
        WriteLine($"ThreadPool maximum Worker = {maxworkerThreads} and maximum Requests = {maxconcurrentActiveRequests}");

        Random rndWorkers = new Random();
        int newMaxWorker = rndWorkers.Next(minworkerThreads, maxworkerThreads);
        WriteLine($"New Max Worker Thread generated = {newMaxWorker}");

        Random rndConRequests = new Random();
        int newMaxRequests = rndConRequests.Next(minconcurrentActiveRequests, maxconcurrentActiveRequests);
        WriteLine($"New Max Active Requests generated = {newMaxRequests}");

        bool changeSucceeded = ThreadPool.SetMaxThreads(newMaxWorker, newMaxRequests);
        if (changeSucceeded)
        {
            WriteLine("SetMaxThreads completed");
            int maxworkerThreadCount;
            int maxconcurrentActiveRequestCount;
            ThreadPool.GetMaxThreads(out maxworkerThreadCount, out maxconcurrentActiveRequestCount);
            WriteLine($"ThreadPool Max Worker = {maxworkerThreadCount} and Max Requests = {maxconcurrentActiveRequestCount}");
        }
        else
            WriteLine("SetMaxThreads failed");

    }
}</pre></div></li><li class="listitem">Head on over to<a class="indexterm" id="id481"/> your console application and create a new instance of your <code class="literal">Recipe</code> class, and call the <code class="literal">IncreaseThreadPoolSize()</code> method:<div class="informalexample"><pre class="programlisting">Chapter7.Recipes oRecipe = new Chapter7.Recipes();
oRecipe.IncreaseThreadPoolSize();
Console.ReadLine();</pre></div></li><li class="listitem">Finally, run your console application and take note of the output:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_10.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec110"/>How it works…</h2></div></div></div><p>From the console<a class="indexterm" id="id482"/> application, we can see that the processor count is <code class="literal">8</code>. The minimum number of thread pool threads, therefore, also equals 8. We then read the maximum thread pool size and generate a random number between the minimum and maximum numbers. Lastly, we set the maximum thread pool size to our randomly generated minimum and maximum.</p><p>While this is only a proof of concept and not something one would do in a production application (setting the thread pool to a random number), it clearly illustrates the ability to set the thread pool to a value specified by the developer.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>The code in this recipe was compiled for 32 bit. Try changing your application to a 64-bit application and run the code again. See the difference 64 bit makes.</p></div></div></div></div>
<div class="section" title="Creating multiple threads"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Creating multiple threads</h1></div></div></div><p>Sometimes, we need to<a class="indexterm" id="id483"/> create multiple threads. Before we can continue, however, we need to wait for these threads to complete doing whatever they need to do. For this, the use of tasks is best suited.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Getting ready</h2></div></div></div><p>Make sure that you have added the <code class="literal">using System.Threading.Tasks;</code> statement to the top of your <code class="literal">Recipes</code> class.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec112"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new method called <code class="literal">MultipleThreadWait()</code> in your <code class="literal">Recipes</code> class. Then, create a second method called <code class="literal">RunThread()</code> with the <code class="literal">private</code> modifier, which takes an integer of seconds to make the thread sleep. This will simulate the process of doing some work for a variable amount of time:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void MultipleThreadWait()
    {        

    }

    private void RunThread(int sleepSeconds)
    {        

    }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>In reality, you would probably not call the same method. You could, for all intents and purposes, call three separate methods. Here, however, for the sake of simplicity, we will call the same method with different sleep durations.</p></div></div></li><li class="listitem">Add the following code to your <code class="literal">MultipleThreadWait()</code> method. You will notice that we are creating three tasks that then create three threads. We will then fire off these three threads and make them sleep for <code class="literal">3</code>, <code class="literal">5</code>, and <code class="literal">2</code> seconds. Finally, we will call the <code class="literal">Task.WaitAll</code> method to wait before continuing the execution of the application:<div class="informalexample"><pre class="programlisting">Task thread1 = Task.Factory.StartNew(() =&gt; RunThread(3));
Task thread2 = Task.Factory.StartNew(() =&gt; RunThread(5));
Task thread3 = Task.Factory.StartNew(() =&gt; RunThread(2));

Task.WaitAll(thread1, thread2, thread3);
WriteLine("All tasks completed");</pre></div></li><li class="listitem">Then, in the <code class="literal">RunThread()</code> method, we will read the current thread ID and then make the thread sleep for the amount of milliseconds supplied. This is just the integer value for the seconds multiplied by <code class="literal">1000</code>:<div class="informalexample"><pre class="programlisting">int threadID = Thread.CurrentThread.ManagedThreadId;

WriteLine($"Sleep thread {threadID} for {sleepSeconds} seconds at {DateTime.Now.Second} seconds");
Thread.Sleep(sleepSeconds * 1000);
WriteLine($"Wake thread {threadID} at {DateTime.Now.Second} seconds");</pre></div></li><li class="listitem">When you have<a class="indexterm" id="id484"/> completed the code, your <code class="literal">Recipes</code> class should look like this:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void MultipleThreadWait()
    {
        Task thread1 = Task.Factory.StartNew(() =&gt; RunThread(3));
        Task thread2 = Task.Factory.StartNew(() =&gt; RunThread(5));
        Task thread3 = Task.Factory.StartNew(() =&gt; RunThread(2));

        Task.WaitAll(thread1, thread2, thread3);
        WriteLine("All tasks completed");
    }

    private void RunThread(int sleepSeconds)
    {
        int threadID = Thread.CurrentThread.ManagedThreadId;

        WriteLine($"Sleep thread {threadID} for {sleepSeconds} seconds at {DateTime.Now.Second} seconds");
        Thread.Sleep(sleepSeconds * 1000);
        WriteLine($"Wake thread {threadID} at {DateTime.Now.Second} seconds");
    }
}</pre></div></li><li class="listitem">Finally, add a<a class="indexterm" id="id485"/> new instance of the <code class="literal">Recipe</code> class to your console application and call the <code class="literal">MultipleThreadWait()</code> method:<div class="informalexample"><pre class="programlisting">Chapter7.Recipes oRecipe = new Chapter7.Recipes();
oRecipe.MultipleThreadWait();
Console.ReadLine();</pre></div></li><li class="listitem">Run your console application and view the output produced:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_11.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec113"/>How it works…</h2></div></div></div><p>You will notice that three threads (<code class="literal">thread 9</code>, <code class="literal">thread 10</code>, and <code class="literal">thread 11</code>) are created. These are then<a class="indexterm" id="id486"/> paused by making them sleep for various amounts of time. After each thread wakes, the code waits for all three threads to complete before continuing the execution of the application code.</p></div></div>
<div class="section" title="Locking one thread until the contended resources are available"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Locking one thread until the contended resources are available</h1></div></div></div><p>There are instances where we want to give sole access to a process to a specific thread. We can do this using the<a class="indexterm" id="id487"/> <code class="literal">lock</code> keyword. This will execute this process in a thread-safe manner. Therefore, when a thread runs the process, it will gain exclusive access<a class="indexterm" id="id488"/> to the process for the duration of the lock scope. If another thread tries to gain access to the process inside the locked code, it will be blocked and have to wait its turn until the lock is released.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec114"/>Getting ready</h2></div></div></div><p>For this example, we will use tasks. Make sure that you have added the <code class="literal">using System.Threading.Tasks;</code> statement to the top of your <code class="literal">Recipes</code> class.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec115"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">Recipes</code> class, add an object called <code class="literal">threadLock</code> with the <code class="literal">private</code> modifier. Then, add two methods called <code class="literal">LockThreadExample()</code> and <code class="literal">ContendedResource()</code> that take an integer of seconds to sleep as a parameter:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    private object threadLock = new object();
    public void LockThreadExample()
    {        

    }

    private void ContendedResource(int sleepSeconds)
    {        

    }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>It is considered a best practice to define the object to lock on as private.</p></div></div></li><li class="listitem">Add three tasks to the <code class="literal">LockThreadExample()</code> method. They will create threads that try to access the same section of code simultaneously. This code will wait <a class="indexterm" id="id489"/>until all the threads have completed before terminating the application:<div class="informalexample"><pre class="programlisting">Task thread1 = Task.Factory.StartNew(() =&gt; ContendedResource(3));
Task thread2 = Task.Factory.StartNew(() =&gt; ContendedResource(5));
Task thread3 = Task.Factory.StartNew(() =&gt; ContendedResource(2));

Task.WaitAll(thread1, thread2, thread3);
WriteLine("All tasks completed");</pre></div></li><li class="listitem">In the <code class="literal">ContendedResource()</code> method, create a lock using the <code class="literal">private</code> <code class="literal">threadLock</code> object and then make the thread sleep for the amount of seconds passed to the method as a parameter:<div class="informalexample"><pre class="programlisting">int threadID = Thread.CurrentThread.ManagedThreadId;
lock (threadLock)
{
    WriteLine($"Locked for thread {threadID}");
    Thread.Sleep(sleepSeconds * 1000);
}
WriteLine($"Lock released for thread {threadID}");</pre></div></li><li class="listitem">Back in the console application, add the following code to instantiate a new <code class="literal">Recipes</code> class and call the <code class="literal">LockThreadExample()</code> method:<div class="informalexample"><pre class="programlisting">Chapter7.Recipes oRecipe = new Chapter7.Recipes();
oRecipe.LockThreadExample();
Console.ReadLine();</pre></div></li><li class="listitem">Run the console application and see the information output to the console window:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_12.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec116"/>How it works…</h2></div></div></div><p>We can see that <code class="literal">thread 11</code> gained exclusive access to the contended resource. At the same time, <code class="literal">thread 11</code> and <code class="literal">thread 12</code> tried to access the contended resource locked by <code class="literal">thread 11</code>. This then<a class="indexterm" id="id490"/> caused the other two threads to wait until <code class="literal">thread 11</code> had completed and released the lock. The result of this is that the code is executed in an orderly manner, as can be seen in the console window output. Each thread waits its turn until it can access the resource and lock its thread.</p></div></div>
<div class="section" title="Invoking parallel calls to methods using Parallel.Invoke"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Invoking parallel calls to methods using Parallel.Invoke</h1></div></div></div><p>
<code class="literal">Parallel.Invoke</code> allows us to execute tasks in (you guessed it) parallel. Sometimes, you need to perform operations <a class="indexterm" id="id491"/>simultaneously and, in so doing, speed up processing. You can therefore expect that the total time taken to process the tasks is equal to the longest running process. Using <code class="literal">Parallel.Invoke</code> is quite easy.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec117"/>Getting ready</h2></div></div></div><p>Make sure that you have added the <code class="literal">using System.Threading.Tasks;</code> statement to the top of your <code class="literal">Recipes</code> class.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec118"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start off by creating two methods in the <code class="literal">Recipes</code> class called <code class="literal">ParallelInvoke()</code> and <code class="literal">PerformSomeTask()</code>, which take an integer of seconds to sleep as the parameter:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void ParallelInvoke()
    {        

    }

    private void PerformSomeTask(int sleepSeconds)
    {        

    }
}</pre></div></li><li class="listitem">Add the<a class="indexterm" id="id492"/> following code to the <code class="literal">ParallelInvoke()</code> method. This code will call <code class="literal">Paralell.Invoke</code> to run the <code class="literal">PerformSomeTask()</code> method:<div class="informalexample"><pre class="programlisting">WriteLine($"Parallel.Invoke started at {DateTime.Now.Second} seconds");
Parallel.Invoke(
    () =&gt; PerformSomeTask(3),
    () =&gt; PerformSomeTask(5),
    () =&gt; PerformSomeTask(2)
    );
            
WriteLine($"Parallel.Invoke completed at {DateTime.Now.Second} seconds");</pre></div></li><li class="listitem">In the <code class="literal">PerformSomeTask()</code> method, make the thread sleep for the amount of seconds passed to the method as the parameter (converting the seconds to milliseconds by multiplying it by <code class="literal">1000</code>):<div class="informalexample"><pre class="programlisting">int threadID = Thread.CurrentThread.ManagedThreadId;
WriteLine($"Sleep thread {threadID} for {sleepSeconds} seconds");
Thread.Sleep(sleepSeconds * 1000);
WriteLine($"Thread {threadID} resumed");</pre></div></li><li class="listitem">When you<a class="indexterm" id="id493"/> have added all the code, your <code class="literal">Recipes</code> class should look like this:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void ParallelInvoke()
    {
        WriteLine($"Parallel.Invoke started at {DateTime.Now.Second} seconds");
        Parallel.Invoke(
            () =&gt; PerformSomeTask(3),
            () =&gt; PerformSomeTask(5),
            () =&gt; PerformSomeTask(2)
            );
            
        WriteLine($"Parallel.Invoke completed at {DateTime.Now.Second} seconds");           
    }

    private void PerformSomeTask(int sleepSeconds)
    {        
        int threadID = Thread.CurrentThread.ManagedThreadId;
        WriteLine($"Sleep thread {threadID} for {sleepSeconds} seconds");
        Thread.Sleep(sleepSeconds * 1000);
        WriteLine($"Thread {threadID} resumed");
    }
}</pre></div></li><li class="listitem">In the console application, instantiate a new instance of the <code class="literal">Recipes</code> class and call the <code class="literal">ParallelInvoke()</code> method:<div class="informalexample"><pre class="programlisting">Chapter7.Recipes oRecipe = new Chapter7.Recipes();
oRecipe.ParallelInvoke();
Console.ReadLine();</pre></div></li><li class="listitem">Run the console application and look at the output produced in the console window:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_13.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec119"/>How it works…</h2></div></div></div><p>Because we are<a class="indexterm" id="id494"/> running all these threads in parallel, we can assume that the longest process will denote the total duration of the all the tasks. This means that the total duration of the process will be 5 seconds because the longest task will take 5 seconds to complete (we set <code class="literal">thread 10</code> to sleep for a maximum of 5 seconds).</p><p>As we can see, the time difference between the start and the end of <code class="literal">Parallel.Invoke</code> is exactly 5 seconds.</p></div></div>
<div class="section" title="Using a parallel foreach loop to run multiple threads"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Using a parallel foreach loop to run multiple threads</h1></div></div></div><p>A while ago, during<a class="indexterm" id="id495"/> a work retreat (yes, the company I work for is really that cool), Graham Rook, who is one of my colleagues, showed me a parallel <code class="literal">foreach</code> loop. It certainly speeds up processing a great deal. But here's the rub. It makes no sense using a parallel <code class="literal">foreach</code> loop if you're dealing with small amounts of data or little tasks. The parallel <code class="literal">foreach</code> loop excels when there is bulk processing to do or huge amounts of data to process.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec120"/>Getting ready</h2></div></div></div><p>We will start off by looking at where the parallel <code class="literal">foreach</code> loop does not perform better than the standard <code class="literal">foreach</code> loop. For this, we will create a small list of 500 items and just iterate over the list, writing the items to the console window.</p><p>For the second example that illustrates the power of the parallel <code class="literal">foreach</code> loop, we will use the same list and create a file for each item in the list. The power and benefit of the parallel <code class="literal">foreach</code> loop will be evident in the second example.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec121"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start off by creating two methods in the <code class="literal">Recipes</code> class. Call one method <code class="literal">ReadCollectionForEach()</code> and pass it a parameter of <code class="literal">List&lt;string&gt;</code>. Create a second method called <code class="literal">ReadCollectionParallelForEach()</code> that also accepts a parameter of <code class="literal">List&lt;string&gt;</code>:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public double ReadCollectionForEach(List&lt;string&gt; intCollection)
    {        

    }

    private double ReadCollectionParallelForEach(List&lt;string&gt; intCollection)
    {        

    }
}</pre></div></li><li class="listitem">In the <code class="literal">ReadCollectionForEach()</code> method, add a standard <code class="literal">foreach</code> loop that will iterate <a class="indexterm" id="id496"/>over the collection of strings passed to it and write the value it finds to the console window. Then, clear the console window. Use a timer to keep track of the total seconds elapsed during the <code class="literal">foreach</code> loop:<div class="informalexample"><pre class="programlisting">var timer = Stopwatch.StartNew();
foreach (string integer in intCollection)
{
    WriteLine(integer);
    Clear();
}
return timer.Elapsed.TotalSeconds;</pre></div></li><li class="listitem">In the second method, called <code class="literal">ReadCollectionParallelForEach()</code>, do the same. However, instead of using a standard <code class="literal">foreach</code> loop, add a <code class="literal">Parallel.ForEach</code> loop. You will notice that the <code class="literal">Parallel.ForEach</code> loop looks slightly different. The signature of <code class="literal">Parallel.ForEach</code> requires that you pass it an<a class="indexterm" id="id497"/> enumerable data source (<code class="literal">List&lt;string&gt; intCollection</code>) and define an action, which is the delegate that is invoked for every iteration (<code class="literal">integer</code>):<div class="informalexample"><pre class="programlisting">var timer = Stopwatch.StartNew();
Parallel.ForEach(intCollection, integer =&gt;
{
    WriteLine(integer);
    Clear();
});
return timer.Elapsed.TotalSeconds;</pre></div></li><li class="listitem">When you have added all the required code, your <code class="literal">Recipes</code> class should look like this:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public double ReadCollectionForEach(List&lt;string&gt; intCollection)
    {        
        var timer = Stopwatch.StartNew();
        foreach (string integer in intCollection)
        {
            WriteLine(integer);
            Clear();
        }
        return timer.Elapsed.TotalSeconds;
    }

    public double ReadCollectionParallelForEach(List&lt;string&gt; intCollection)
    {        
        var timer = Stopwatch.StartNew();
        Parallel.ForEach(intCollection, integer =&gt;
        {
            WriteLine(integer);
            Clear();
        });
        return timer.Elapsed.TotalSeconds;
    }
}</pre></div></li><li class="listitem">In the console application, create the <code class="literal">List&lt;string&gt;</code> collection and pass it to the two methods created in the <code class="literal">Recipes</code> class. You will notice that we are only creating a collection of 500 items. After the code is completed, return the time elapsed in seconds and output it to the console window:<div class="informalexample"><pre class="programlisting">List&lt;string&gt; integerList = new List&lt;string&gt;();
for (int i = 0; i &lt;= 500; i++)
{
    integerList.Add(i.ToString());
}
Chapter7.Recipes oRecipe = new Chapter7.Recipes();
double timeElapsed1 = oRecipe.ReadCollectionForEach(integerList);
double timeElapsed2 = oRecipe.ReadCollectionParallelForEach(integerList);
WriteLine($"foreach executed in {timeElapsed1}");
WriteLine($"Parallel.ForEach executed in {timeElapsed2}");</pre></div></li><li class="listitem">Run your application. From the output displayed, you will see that the performance<a class="indexterm" id="id498"/> gain using the <code class="literal">Parallel.ForEach</code> loop is negligible. In fact, in this case, the <code class="literal">Parallel.ForEach</code> loop only improved performance by 0.4516 percent:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_14.jpg"/></div></li><li class="listitem">Let's use a different example now. We will create a process-intensive task and measure the performance gain that the <code class="literal">Parallel.ForEach</code> loop will give us. Create two methods called <code class="literal">CreateWriteFilesForEach()</code> and <code class="literal">CreateWriteFilesParallelForEach()</code>, which both take the <code class="literal">List&lt;string&gt;</code> collection as the parameter:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void CreateWriteFilesForEach(List&lt;string&gt; intCollection)
    {        

    }

    private void CreateWriteFilesParallelForEach(List&lt;string&gt; intCollection)
    {        

    }
}</pre></div></li><li class="listitem">Add the following code to the <code class="literal">CreateWriteFilesForEach()</code> method. This code starts<a class="indexterm" id="id499"/> the timer and executes the standard <code class="literal">foreach</code> loop on the <code class="literal">List&lt;string&gt;</code> object. It then writes the elapsed time out to the console window:<div class="informalexample"><pre class="programlisting">WriteLine($"Start foreach File method");
var timer = Stopwatch.StartNew();
foreach (string integer in intCollection)
{    

}
WriteLine($"foreach File method executed in {timer.Elapsed.TotalSeconds} seconds");</pre></div></li><li class="listitem">Inside the <code class="literal">foreach</code> loop, add the code to check whether a file exists with the specific name created by appending the <code class="literal">integer</code> value to the filename portion of the <code class="literal">filePath</code> variable. Create the file (ensuring that you use <code class="literal">Dispose</code> method in order not to lock the file when trying to write to it) and write some text to the newly created file:<div class="informalexample"><pre class="programlisting">string filePath = $"C:\\temp\\output\\ForEach_Log{integer}.txt";
if (!File.Exists(filePath))
{
    File.Create(filePath).Dispose();
    using (StreamWriter sw = new StreamWriter(filePath, false))
    {
        sw.WriteLine($"{integer}. Log file start: {DateTime.Now.ToUniversalTime().ToString()}");
    }
}</pre></div></li><li class="listitem">Next, add this code to the <code class="literal">CreateWriteFilesParallelForEach()</code> method, which basically performs the same function as the <code class="literal">CreateWriteFilesForEach()</code> method, but uses a <code class="literal">Parallel.ForEach</code> loop to create and write files:<div class="informalexample"><pre class="programlisting">WriteLine($"Start Parallel.ForEach File method");
var timer = Stopwatch.StartNew();
Parallel.ForEach(intCollection, integer =&gt;
{
                    
});
WriteLine($"Parallel.ForEach File method executed in {timer.Elapsed.TotalSeconds} seconds");</pre></div></li><li class="listitem">Add the<a class="indexterm" id="id500"/> slightly modified file-creation code inside the <code class="literal">Parallel.ForEach</code> loop:<div class="informalexample"><pre class="programlisting">string filePath = $"C:\\temp\\output\\ParallelForEach_Log{integer}.txt";
if (!File.Exists(filePath))
{
    File.Create(filePath).Dispose();
    using (StreamWriter sw = new StreamWriter(filePath, false))
    {
        sw.WriteLine($"{integer}. Log file start: {DateTime.Now.ToUniversalTime().ToString()}");
    }
}</pre></div></li><li class="listitem">When you are done, your code needs to look like this:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void CreateWriteFilesForEach(List&lt;string&gt; intCollection)
    {        
        WriteLine($"Start foreach File method");
        var timer = Stopwatch.StartNew();
        foreach (string integer in intCollection)
        {
            string filePath = $"C:\\temp\\output\\ForEach_Log{integer}.txt";
            if (!File.Exists(filePath))
            {
                File.Create(filePath).Dispose();
                using (StreamWriter sw = new StreamWriter(filePath, false))
                {
                    sw.WriteLine($"{integer}. Log file start: {DateTime.Now.ToUniversalTime() .ToString()}");
                }
            }
        }
        WriteLine($"foreach File method executed in {timer.Elapsed.TotalSeconds} seconds");
    }

    public void CreateWriteFilesParallelForEach(List&lt;string&gt; intCollection)
    {        
        WriteLine($"Start Parallel.ForEach File method");
        var timer = Stopwatch.StartNew();
        Parallel.ForEach(intCollection, integer =&gt;
        {
            string filePath = $"C:\\temp\\output\\ParallelForEach_Log {integer}.txt";
            if (!File.Exists(filePath))
            {
                File.Create(filePath).Dispose();
                using (StreamWriter sw = new StreamWriter(filePath, false))
                {
                    sw.WriteLine($"{integer}. Log file start: {DateTime.Now.ToUniversalTime()
                    .ToString()}");
                }
            }                
        });
        WriteLine($"Parallel.ForEach File method executed in {timer.Elapsed.TotalSeconds} seconds");
    }
}</pre></div></li><li class="listitem">Heading<a class="indexterm" id="id501"/> over to the console application, modify the <code class="literal">List&lt;string&gt;</code> object slightly and increase the count from <code class="literal">500</code> to <code class="literal">1000</code>. Then, call the file methods created in the <code class="literal">Recipes</code> class:<div class="informalexample"><pre class="programlisting">List&lt;string&gt; integerList = new List&lt;string&gt;();
for (int i = 0; i &lt;= 1000; i++)
{
    integerList.Add(i.ToString());
}

Chapter7.Recipes oRecipe = new Chapter7.Recipes();
oRecipe.CreateWriteFilesForEach(integerList);
oRecipe.CreateWriteFilesParallelForEach(integerList);
ReadLine();</pre></div></li><li class="listitem">Finally, when you<a class="indexterm" id="id502"/> are ready, make sure that you have the <code class="literal">C:\temp\output</code> directory and that there aren't any other files in that directory. Run your application and review the output to the console window. This time round, we can see that the <code class="literal">Parallel.ForEach</code> loop has made a huge difference. The performance gain is massive and heralds a 60.7074 percent performance increase over the standard <code class="literal">foreach</code> loop:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_15.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec122"/>How it works…</h2></div></div></div><p>From the examples used in this recipe, it is clear that the use of the parallel <code class="literal">foreach</code> loop should be considered carefully. If you are dealing with relatively low volumes of data or non-process intensive transactions, the parallel <code class="literal">foreach</code> loop will not benefit your application's performance much. In some instances, the standard <code class="literal">foreach</code> loop could be much faster than the parallel <code class="literal">foreach</code> loop. If, however, you find your application running into performance issues when processing large amounts of data or running processor-intensive tasks, give the parallel <code class="literal">foreach</code> loop a try. It just might surprise you.</p></div></div>
<div class="section" title="Cancelling a parallel foreach loop"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Cancelling a parallel foreach loop</h1></div></div></div><p>When dealing with parallel <code class="literal">foreach</code> loops, the obvious question is how one would terminate the loop <a class="indexterm" id="id503"/>prematurely based on a certain condition, such as a timeout. As it turns out, the parallel <code class="literal">foreach</code> loop is quite easy to terminate prematurely.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec123"/>Getting ready</h2></div></div></div><p>We will create a method that takes a collection of items and loops through this collection in a parallel <code class="literal">foreach</code> loop. It will also be aware of a timeout value that, if exceeded, will terminate the loop and exit the method.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec124"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start off by creating a new method called <code class="literal">CancelParallelForEach()</code> in the <code class="literal">Recipes</code> class, which takes two parameters. One is a collection of <code class="literal">List&lt;string&gt;</code>, while the other is an integer specifying a timeout value. When the timeout value is exceeded, the <code class="literal">Parallel.ForEach</code> loop must terminate:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void CancelParallelForEach(List&lt;string&gt; intCollection, int timeOut)
    {        

    }    
}</pre></div></li><li class="listitem">Inside the <code class="literal">CancelParallelForEach()</code> method, add a timer to keep track of the elapsed time. This will signal the loop that the timeout threshold has been exceeded and that the loop needs to exit. Create the <code class="literal">Parallel.ForEach</code> method, defining a state. In each iteration, check the elapsed time against the timeout, and if the time is exceeded, break out of the loop:<div class="informalexample"><pre class="programlisting">var timer = Stopwatch.StartNew();
Parallel.ForEach(intCollection, (integer, state) =&gt;
{
    Thread.Sleep(1000);
    if (timer.Elapsed.Seconds &gt; timeOut)
    {
        WriteLine($"Terminate thread {Thread.CurrentThread.ManagedThreadId}.Elapsed time {timer.Elapsed.Seconds} seconds");
        state.Break();
    }
    WriteLine($"Processing item {integer} on thread {Thread.CurrentThread.ManagedThreadId}");
});</pre></div></li><li class="listitem">In the console <a class="indexterm" id="id504"/>application, create the <code class="literal">List&lt;string&gt;</code> object and add <code class="literal">1000</code> items to it. Call the <code class="literal">CancelParallelForEach()</code> method with a timeout of only <code class="literal">5</code> seconds:<div class="informalexample"><pre class="programlisting">List&lt;string&gt; integerList = new List&lt;string&gt;();
for (int i = 0; i &lt;= 1000; i++)
{
    integerList.Add(i.ToString());
}

Chapter7.Recipes oRecipe = new Chapter7.Recipes();
oRecipe.CancelParallelForEach(integerList, 5);
WriteLine($"Parallel.ForEach loop terminated");
ReadLine();</pre></div></li><li class="listitem">Run your console application and review the output results:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_16.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec125"/>How it works…</h2></div></div></div><p>You can see from the console window output that as soon as the elapsed time exceeded the timeout value, the<a class="indexterm" id="id505"/> parallel loop was notified to cease the execution of iterations beyond the current iteration at the system's earliest convenience. Having this kind of control over the <code class="literal">Parallel.ForEach</code> loop allows developers to avoid runaway loops and give the user control to cancel a loop operation by clicking on a button, or automatically having the application terminate when the timeout value has been reached.</p></div></div>
<div class="section" title="Catching errors in parallel foreach loops"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Catching errors in parallel foreach loops</h1></div></div></div><p>With parallel <code class="literal">foreach</code> loops, developers<a class="indexterm" id="id506"/> can wrap the loop in a <code class="literal">try</code> <code class="literal">catch</code> statement. Care needs to be taken, however, because the <code class="literal">Parallel.ForEach</code> will throw <code class="literal">AggregatedException</code>, which has the exceptions it encounters over several threads rolled into one.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec126"/>Getting ready</h2></div></div></div><p>We will create a <code class="literal">List&lt;string&gt;</code> object that contains a collection of machine IP addresses. The <code class="literal">Parallel.ForEach</code> loop will check the IP addresses to see whether the machines on the other<a class="indexterm" id="id507"/> end of the given IP are alive. It does this by pinging the IP address. The method that performs the <code class="literal">Parallel.ForEach</code> loop will also be given the minimum required alive machines as an integer value. If the minimum number of machines alive is not met, an exception is thrown.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec127"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">Recipes</code> class, add a method called <code class="literal">CheckClientMachinesOnline()</code> that takes as parameters a <code class="literal">List&lt;string&gt;</code> collection of IP addresses and an integer that specifies the minimum number of machines required to be online. Add a second method called <code class="literal">MachineReturnedPing()</code> that will receive an IP address to ping. For our purpose, we will just return <code class="literal">false</code> to mimic a dead machine (the ping to the IP address timed out):<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void CheckClientMachinesOnline(List&lt;string&gt; ipAddresses, int minimumLive)
    {        

    }   

    private bool MachineReturnedPing(string ip)
    {            
        return false;
    } 
}</pre></div></li><li class="listitem">Inside the <code class="literal">CheckClientMachinesOnline()</code> method, add the <code class="literal">Parallel.ForEach</code> loop and create the <code class="literal">ParallelOptions</code> variable, which will specify the <a class="indexterm" id="id508"/>degree of parallelism. Wrap all this code inside a <code class="literal">try</code> <code class="literal">catch</code> statement and <a class="indexterm" id="id509"/>catch <code class="literal">AggregateException</code>:<div class="informalexample"><pre class="programlisting">try
{
    int machineCount = ipAddresses.Count();                
    var options = new ParallelOptions();
    options.MaxDegreeOfParallelism = machineCount;
    int deadMachines = 0;

    Parallel.ForEach(ipAddresses, options, ip =&gt;
    {
        
    });
}
catch (AggregateException aex)
{
    WriteLine("An AggregateException has occurred");
    throw;
}</pre></div></li><li class="listitem">Inside the <code class="literal">Parallel.ForEach</code> loop, write the code to check whether the machine is online by calling the <code class="literal">MachineReturnedPing()</code> method. In our example, this method will always return <code class="literal">false</code>. You will notice that we are keeping track of the offline machine count via the <code class="literal">Interlocked.Increment</code> method. This is just a way of incrementing a variable across the threads of the <code class="literal">Parallel.ForEach</code> loop:<div class="informalexample"><pre class="programlisting">if (MachineReturnedPing(ip))
{

}
else
{                        
    if (machineCount - Interlocked.Increment(ref deadMachines) &lt; minimumLive)
    {
        WriteLine($"Machines to check = {machineCount}");
        WriteLine($"Dead machines = {deadMachines}");
        WriteLine($"Minimum machines required = {minimumLive}");
        WriteLine($"Live Machines = {machineCount - deadMachines}");
              
        throw new Exception($"Minimum machines requirement of {minimumLive} not met");
    }
}</pre></div></li><li class="listitem">If you have <a class="indexterm" id="id510"/>added all the code correctly, your <code class="literal">Recipes</code> class <a class="indexterm" id="id511"/>will look like this:<div class="informalexample"><pre class="programlisting">public class Recipes
{
    public void CheckClientMachinesOnline(List&lt;string&gt; ipAddresses, int minimumLive)
    {        
        try
        {
            int machineCount = ipAddresses.Count();                
            var options = new ParallelOptions();
            options.MaxDegreeOfParallelism = machineCount;
            int deadMachines = 0;

            Parallel.ForEach(ipAddresses, options, ip =&gt;
            {
                if (MachineReturnedPing(ip))
                {

                }
                else
                {                        
                    if (machineCount - Interlocked.Increment(ref deadMachines) &lt; minimumLive)
                    {
                        WriteLine($"Machines to check = {machineCount}");
                        WriteLine($"Dead machines = {deadMachines}");
                        WriteLine($"Minimum machines required = {minimumLive}");
                        WriteLine($"Live Machines = {machineCount - deadMachines}");
                
                        throw new Exception($"Minimum machines requirement of {minimumLive} not met");
                    }
                }
            });
        }
        catch (AggregateException aex)
        {
            WriteLine("An AggregateException has occurred");
            throw;
        }
    }   

    private bool MachineReturnedPing(string ip)
    {            
        return false;
    } 
}</pre></div></li><li class="listitem">In the console <a class="indexterm" id="id512"/>application, create the <code class="literal">List&lt;string&gt;</code> object to store a collection of dummy IP addresses. Instantiate your <code class="literal">Recipes</code> class and call the <code class="literal">CheckClientMachinesOnline()</code> method, passing the collection of IP addresses and a<a class="indexterm" id="id513"/> minimum number of machines required to be online to it:<div class="informalexample"><pre class="programlisting">List&lt;string&gt; ipList = new List&lt;string&gt;();
for (int i = 0; i &lt;= 10; i++)
{
    ipList.Add($"10.0.0.{i.ToString()}");
}

try
{
    Chapter7.Recipes oRecipe = new Chapter7.Recipes();
    oRecipe.CheckClientMachinesOnline(ipList, 2);
}
catch (Exception ex)
{
    WriteLine(ex.InnerException.Message);
}
ReadLine();</pre></div></li><li class="listitem">Run your application and review the output in the console window:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_17.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec128"/>How it works…</h2></div></div></div><p>From the console<a class="indexterm" id="id514"/> window output, you can see that the minimum number of machines required to be online was not achieved. The application then threw an<a class="indexterm" id="id515"/> exception and caught it from the <code class="literal">Parallel.ForEach</code> loop. Being able to handle exceptions in parallel loops such as this one is essential to maintain the stability of your application by being able to handle exceptions as they occur.</p><p>We encourage you to play around a little with the <code class="literal">Parallel.ForEach</code> loop and drill into some of the inner methods of the <code class="literal">AggregareException</code> class to really understand it better.</p></div></div>
<div class="section" title="Debugging multiple threads"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Debugging multiple threads</h1></div></div></div><p>Debugging<a class="indexterm" id="id516"/> multiple threads in Visual Studio is tricky, especially since these threads are all running at the same time. Luckily, we have a few tools available to us as developers to use to get a better understanding of what is happening in our multithreaded applications.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec129"/>Getting ready</h2></div></div></div><p>While debugging multithreaded applications, you can access various windows by going to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> in Visual Studio.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec130"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start debugging <a class="indexterm" id="id517"/>your multithreaded application after adding a breakpoint somewhere in the code. You can access various debugging windows by going to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> in Visual Studio:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_18.jpg"/></div></li><li class="listitem">The first window available to you is the <span class="strong"><strong>Threads</strong></span> window. Access it by going to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> in Visual Studio or type <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>H</em></span>. In here, you can right-click on a thread to watch and flag it. If you have given your threads names, you will see that name appear in the <span class="strong"><strong>Name</strong></span> column. To give your thread a name, you could add the following code to your application, which runs the method on a separate thread:<div class="informalexample"><pre class="programlisting">int threadID = Thread.CurrentThread.ManagedThreadId;
Thread.CurrentThread.Name = $"New Thread{threadID}";</pre></div><p>You will also be able to see the currently active thread in the debugger. It will be marked with a yellow arrow. Then, there is the managed ID, which is the same ID you would have used to create the unique thread name earlier on.</p><p>The <span class="strong"><strong>Location</strong></span> <a class="indexterm" id="id518"/>column displays the current method that the thread is in. The <span class="strong"><strong>Threads</strong></span> window allows you to view the stack of the thread by double-clicking on the <span class="strong"><strong>Location</strong></span> field. You can also freeze and thaw threads. Freezing stops a thread from executing, while thawing allows the frozen thread to continue as normal:</p><div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_19.jpg"/></div></li><li class="listitem">The <span class="strong"><strong>Tasks</strong></span> window can be accessed by going to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> or by holding down <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>D</em></span> and then pressing <span class="emphasis"><em>K</em></span>. You will notice that the thread you flagged earlier in the <span class="strong"><strong>Threads</strong></span> window is also flagged here in the <span class="strong"><strong>Tasks</strong></span> window. The status of the task shows the status at that moment and can be <span class="strong"><strong>Active</strong></span>, <span class="strong"><strong>Deadlocked</strong></span>, <span class="strong"><strong>Waiting</strong></span>, <span class="strong"><strong>Scheduled</strong></span>, or <span class="strong"><strong>Completed</strong></span>:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_20.jpg"/></div></li><li class="listitem">The <span class="strong"><strong>Parallel Stacks</strong></span> window can be accessed by going to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> in Visual Studio or by holding down <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>D</em></span>, and then pressing the <span class="emphasis"><em>S</em></span> key. Here, you can see a graphical view of the tasks and threads. You can switch <a class="indexterm" id="id519"/>between the <span class="strong"><strong>Threads</strong></span> and <span class="strong"><strong>Tasks</strong></span> view by making a selection in the dropdown list in the upper-left corner of the <span class="strong"><strong>Parallel Stacks</strong></span> window:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_21.jpg"/></div></li><li class="listitem">Changing the selection to <span class="strong"><strong>Tasks</strong></span> will show you the current tasks in the debug session:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_22.jpg"/></div></li><li class="listitem">The next window, and undoubtedly my favorite is the <span class="strong"><strong>Parallel Watch</strong></span> window. It is in<a class="indexterm" id="id520"/> fact identical to the standard <span class="strong"><strong>Watch</strong></span> window in Visual Studio, but this watches values across all threads in your application. You can type in any valid C# expression into <span class="strong"><strong>Parallel Watch</strong></span> and see the values as they are at that moment in the debug session. As you can see, we have added the <code class="literal">sleepSeconds</code> variable and the name of the thread to the watch:<div class="mediaobject"><img alt="How to do it…" src="graphics/B05391_07_23.jpg"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec131"/>How it works…</h2></div></div></div><p>Being able to use the debugging tools for multithreaded applications effectively in Visual Studio makes it <a class="indexterm" id="id521"/>much easier to understand the structure of your application and helps you identify possible bugs, bottlenecks, and areas of concern.</p><p>We encourage you to learn more about the various debugging windows available to you.</p></div></div></body></html>