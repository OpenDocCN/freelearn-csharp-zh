- en: Sockets and Ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we understand how to handle data streams from remote hosts,
    process those streams asynchronously on background threads, and handle the errors
    that arise from processing that data. Now we''re going to look at the most primitive
    connections you can make with a remote host. In this chapter, we''ll be looking
    at the physical ports through which your machine is going to do this, and we''ll
    be looking at the concept of a socket: the software structure that exposes access
    to a port for network interaction. We''ll examine the WinSocks library for instantiating
    and working with those ports, and we''ll consider the various ways sockets can
    be leveraged by your application code for efficient, low-level communication with
    a target host.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How the `System.Net.Sockets` classes serve as the C# interface to your hardware-level
    network APIs for communication with external machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to establish a connection to a socket exposed by another machine on your
    network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to program server applications that expose sockets to accept external connection
    requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of communicating over serial ports and exposing serial ports to accept
    serial data for processing, and how this can open you up to interesting use cases
    for C# and .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will have a number of samples and driver programs to demonstrate
    the concepts discussed, each of which will be available here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    8](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%208).'
  prefs: []
  type: TYPE_NORMAL
- en: As always, clone the repository locally and begin playing with the source code,
    or writing your own along with the topics in the chapter to get comfortable with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also start using external tools to test and inspect the behavior of
    a sample API. For this, you''ll need to download and install either Postman, which
    can be found here: [https://www.getpostman.com/apps/](https://www.getpostman.com/apps) ,Or
    you''ll need the Insomnia REST client, which can be found here[:](https://www.getpostman.com/apps)
    [https://insomnia.rest/.](https://insomnia.rest/)'
  prefs: []
  type: TYPE_NORMAL
- en: The feature set of each of these applications is almost identical, and each
    will allow you to send arbitrary requests to a local API through an intuitive
    UI. We'll be using them to test out our web software going forward, and I'd recommend
    spending at least a little time getting familiar with some of the basic functionality
    of whichever tool you choose to use. Throughout this chapter I'll be presenting
    screenshots captured from Postman, but that's not an endorsement of Postman over
    Insomnia, and the steps and UI when following along should be virtually identical
    in both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll be using Docker to demonstrate port mapping. While you could
    manage an understanding of the specific concepts of this chapter without this
    tool, I''d strongly recommend downloading and familiarizing yourself with it.
    It is core to the modern web application development experience, and you will
    only benefit from practicing with it. This chapter provides one of the best opportunities
    to do so, and I''d certainly encourage you to try. Docker can be downloaded here:
    [https://hub.docker.com/editions/community/docker-ce-desktop-windows](https://hub.docker.com/editions/community/docker-ce-desktop-windows).'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2HYmX49](http://bit.ly/2HYmX49)
  prefs: []
  type: TYPE_NORMAL
- en: Sockets versus ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we should do as we look at these connection mechanisms is to
    distinguish between the two. While they are two words identifying a common hardware
    interaction, the software or abstract concepts each term identifies are actually
    mutually exclusive. These terms aren't as interchangeable as abstract class and
    interface were in previous chapters, so when we use each term, it will be for
    a specific purpose, and you'll need to know what it is.
  prefs: []
  type: TYPE_NORMAL
- en: Ports – a hardware interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, machines are identified by their IP address, or the hostname
    mapped to that IP address in the DNS registry. So for any given connection between
    machines to be resolved, the initiating host will ultimately need the underlying
    IP address of the target host. However, simply specifying the target IP address
    is insufficient to target a service or application running on the host. It only
    gives us the location of the host itself. That's where ports come in. A port is
    a two byte unsigned integer that identifies a running process on a target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Each application on your host that will interact with remote processes must
    do so on a designated port. Furthermore, no two applications can listen on the
    same port. Every time you want to start up your application and designate it as
    listening for network requests, you must assign it to an unsigned port on your
    machine. If you've ever tried to run multiple instances of an API project on the
    `8099` or `8080` port (or any other common listening port) on your local machine,
    you'll have seen the startup failure message indicating that the target port is
    already in use. That port is occupied, so you'll have to find a different one
    to process transactions targeting your new application.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this should be fairly obvious. If you want to host multiple services
    on a single device, you will need some way of distinguishing between incoming
    requests for service *A* and incoming requests for service B. By designating mutually-exclusive
    listening ports for each hosted application, you move the burden of proper routing
    back to the client. This is perfectly acceptable, since the client already has
    to keep track of the remote hosts URI, and if you remember from our earlier chapter,
    the port number is simply another component of that API. The alternative would
    require an application to serve as an intermediary between your hosted listening
    applications and all incoming network requests. Such an application would have
    to have reasonable knowledge of the state or expectations of each listening application,
    then it will parse every incoming request to identify which expectation the following
    requests meets. It would be just a whole mess of state management that would become
    infeasible incredibly quickly. So instead, we simply add 2-byte address suffixes
    to specify the target listening application built directly into our URI specification.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you know the valid integer values of an unsigned 2-byte `int`, you already
    know the full range of possible exposed ports for a machine. Using this data type,
    a port specification could have a value from `0` to `65535`. However, just because
    a port designation falls within the range for the data-type of a port, it doesn't
    mean you should attempt to listen on it. There are in fact a number of port ranges
    that your user-application code should never attempt to listen on. These are designated
    as reserved ports and typically handle very specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first set of ports that are reserved, and thus unavailable for you to register
    your application to, are called the **well-known ports**. These ports fall between
    `0` and `1023`, and are used for anything from DNS address resolution (the port `53` 
    used to make sure there is still a machine listening at the address listed in
    the registry) to FTP data and control ports (the ports `20` and `21` , respectively).
    If you've done any sort of network programming prior to reading this book, you're
    already likely to be familiar with the fact that the `80` port is the designated
    port for incoming HTTP requests and the `443` port is reserved for HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The other list of ports that you won't be able to register your application
    to is what's known as the **dynamic port range**. Dynamic ports, or private ports,
    are used to establish connections for private or customized services or interactions,
    or used for temporary **Transmission Control Protocol** (**TCP**) or **User Datagram
    Protocol** (**UDP**) interactions between two hosts. When used in a temporary
    context to service a brief need from either machine, the designated port is known
    as an **ephemeral** **port**. These ports cannot be registered with the **Internet
    Assigned Numbers Authority** (**IANA**) for use in general-purpose network interactions
    on a given host. The range for these ports begins at port number `49152` and ends
    at `65535`.
  prefs: []
  type: TYPE_NORMAL
- en: The IANA is a non-profit organization responsible for managing the allocation
    of IP addresses, among other things. As I mentioned in [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml),
    *Networks in a Nutshell*, a centralized system for standards (and names) is important
    to guarantee that every device routes requests for one IP address to the same
    device.
  prefs: []
  type: TYPE_NORMAL
- en: With that specification, that appears to leave everything between and including
    `1024` and `49151` as available for use by your applications. These are what's
    known as **registered ports***.* They are available for assignment by user applications
    or system services as needed, and won't interfere with default behavior from your
    hardware or other connected hosts.
  prefs: []
  type: TYPE_NORMAL
- en: It probably seems like configuring your application to listen within the registered
    port range will be sufficient for use. However, that's still not *quite* the case.
    If you've ever run a JBoss application server (back in the bad old days of bloated
    application servers like JBoss, you probably remember accessing your locally-hosted
    development environment by accessing `http://localhost:8080/my-java-application`,
    or at least that's what I used to have to do. The reason JBoss always configured
    that port specifically is because it actually serves as an alias for the `80`
    port, the HTTP port. The same is true for `8008`. So, even though the ports fall
    within the registered port range, there are specific expectations around their
    behavior. It really just provides a value within the registered ports range for
    users to define default HTTP handlers, since you can't really assign an application
    directly to the `80` port.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ports within the registered port range that will likely be occupied
    by common services and applications on your local machine. Since .NET Core will
    stop if it can't register itself with the designated port, though, you'll notice
    immediately if you need to update your configuration with a different port number.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing multiple applications on a single port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been working in web development for a substantial amount of time,
    you may already be familiar with wrangling the various configurations and settings
    in **Internet Information Services** (**IIS**) or the aforementioned JBoss whenever
    you wanted to deploy a web application on a Windows host. This is what's called
    an **application server**, and it essentially serves as a shared hosting environment
    for any network-exposed applications on your system. When working with IIS, you
    can register any number of applications to respond to requests against a single
    port (`80` for HTTP, or `443` for HTTPS) and distinguish between them with application
    paths in the URI, or sub-domain specifications.
  prefs: []
  type: TYPE_NORMAL
- en: So if you had two applications named, for instance, `TestApp` and `SampleApp`,
    and you wanted to host both on a single machine, but expose both over the HTTP
    port, you would do so by registering them and deploying them within IIS. In doing
    so, you would specify an application directory within IIS, such as `/sample` and
    `/test`. This would tell IIS that any requests to your hostname over the `80`
    port, the request paths had as their first component the `/sample` directory,
    should be routed to your `SampleApp` as though the request went directly to that
    application. This essentially moved the problem of mapping specific ports to mapping
    specific application directories.
  prefs: []
  type: TYPE_NORMAL
- en: While IIS still supports deployment of .NET Core applications, it's much less
    common in modern web-hosting contexts. IIS specifically is known for its convoluted
    configuration schemes and the immense memory and CPU usage footprint it imposes
    on your host machine. That's not to mention the fact that IIS is exclusive to
    Windows operating systems, making portability of IIS hosted applications non-existent.
  prefs: []
  type: TYPE_NORMAL
- en: 'More typically, engineers are embracing a more lightweight approach to hosting
    concerns. With the cross-platform support of the .NET Core  runtime, engineers
    that have the benefit of working in greenfield applications are encouraged to
    pursue more cutting- edge solutions. Typically, .NET Core developers deploy your
    application to a remote host by way of a Docker container. Docker provides an
    isolated hosting context for your application, and exposes the ports your application
    is listening on to the outside world by mapping the container''s internal listening
    ports to an available port on the machine that''s actually running your Docker
    container. You can specify the port you''d like your application to listen on
    within what''s called a **Dockerfile**, which specifies the build and deployment
    steps for a Docker-hosted application. It''s not unlike a PowerShell script or
    bash script for automating common OS-level operations. Once you specify your desired
    port, you can map it to a port on the host machine within the `run` command like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will map from the port `5000` inside our **Docker Container**
    to the `80` port on the host machine, and the `5001` port to the `443` port. So
    from our hosting context, we''ll get a request against the `80` port, and that
    will be listened to by our Docker instance, which will forward the request into
    our running **.NET Core App**, which will be listening on the `5000` port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6214c27-0fca-42c8-8266-d87737cecc75.png)'
  prefs: []
  type: TYPE_IMG
- en: From here, the problem of hosting multiple applications behind a single port
    that was solved by IIS or JBoss is often simply a matter of configuration. If
    your application is cloud-hosted, you can typically do the same sort of route-prefix
    mapping that was provided by IIS. In other contexts, you can host your suite of
    applications behind what's called a **reverse-proxy**.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take the time to look at, and in some cases even build, each of these
    approaches in later chapters. For now though, it is sufficient that you understand
    the nature of ports as a mechanism by which external requests can access specific
    services or applications hosted on a target device. When exposing your application
    to network resources, the specific port over which you do so is typically a matter
    of simple configuration and convention; for now, we'll take a look at how to interact
    with those specific ports in our software through sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets – a software interface to a port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now that we understand how ports are used to route requests to specific processes
    on a host device, how do we set up our applications to actually *accept* requests
    over those ports? This is where a socket comes in.
  prefs: []
  type: TYPE_NORMAL
- en: A socket provides a software interface to a specific port on a specific remote
    host. It's an open connection stream between your application and any remote application
    exposed at the server and port address you specify. Once this connection is established,
    you're free to write (or read) any data to the open stream of that connection
    that you need. Sockets are a versatile concept, implemented in almost any server-side
    programming language, and .NET Core is no different.
  prefs: []
  type: TYPE_NORMAL
- en: 'One key distinction between a socket and its underlying port is that the port
    represents access to a single process on a remote device. Therefore, a port can
    only be registered for a single application. Sockets, however, represent active
    connections to that single resource. Therefore, there can be as many active sockets
    connected to a resource as can be supported by the network and the remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2086663d-49a1-4de5-90de-659a148cc28a.png)'
  prefs: []
  type: TYPE_IMG
- en: So, a port represents a single process running on a remote machine, while a
    socket represents a connection to a process on a remote machine, designated by
    a port number. When we run our applications and intend to expose them to remote
    resources, we must register them to a specific port. If we want to connect to
    our application to an exposed port, we do so with a socket. A port is merely a
    configuration concern, whereas leveraging sockets is an implementation detail,
    so let's take a look now at how to instantiate and leverage sockets for network
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: While I brush aside port registration as *merely* a configuration concern, that
    doesn't mean it's not your responsibility to understand and configure. Full-stack
    network engineering requires you to understand not only how to write your applications,
    but how to properly configure and deploy them to your various preproduction and
    production environments so that others can use them. We'll take a look at application
    deployment in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging sockets in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets in C# are an extremely versatile and flexible concept. As their definition
    indicates, they only expose a connection to a remote resource, and how that connection
    is used is almost entirely up to the developer who establishes it. An instance
    of the `Socket` class in C# provides synchronous and asynchronous data transfer
    of packets of arbitrary collections of bytes. The contents, structure, and even
    protocol used to transmit those packets is up to you (though I do strongly recommend
    that you always leverage asynchronous communication over synchronous communication).
    So, let's look at how we'll use it.
  prefs: []
  type: TYPE_NORMAL
- en: The socket specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to know about a socket is how to initialize it. The most basic
    information necessary to initialize a socket is understanding what kind of socket
    we'll be working with, and what protocol it will be operating on.
  prefs: []
  type: TYPE_NORMAL
- en: The first aspect of that specification, the socket type, tells our code how
    we'll be interacting with the connection once it's established. This is defined
    in a `SocketType` array, located in the `System.Net.Sockets` namespace, which
    defines the full set of valid interaction mechanisms. The values of `enum` include
    `Dgram`, which indicates that we'll be working directly with unordered, connectionless
    datagrams between our software and the connected host; the `Seqpacket` type, which
    operates with ordered, boundary-protected bytes transmitted back and forth over
    a stream; and the `Stream` type, which provides the asynchronous flow of bytes
    over a `Stream` instance that we've become familiar with so far. There are a handful
    of other `SocketType` values, and you can find them and descriptions of what they
    mean, and how they're used on the Microsoft documentation page. For this chapter,
    we'll just be working with a `Stream` type, since that most closely resembles
    the `Stream` classes from the `System.IO` namespace that we're already so familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: A `Socket` can connect and communicate over a wide array of protocols from the
    transmission layer of the OSI network stack. This means that when you're constructing
    a socket, you'll need to specify specifically what protocol you'll be using to
    communicate once the connection is established. This informs the remote host of
    how it should be parsing the primitive datagrams or packets it will be receiving
    once the connection is established (provided the host supports the requested protocol
    in the first place). To define the protocol your `Socket` instance will be using,
    you'll be looking to values of the `ProtocolType` enum found in the `System.Net.Sockets`
    namespace. There are a number of defined values that correspond to well-established
    transmission protocols, including IPv4, IPv6, TCP, UDP, IDP, Raw, and others.
    For the purposes of our code, we'll be connecting to a local application listening
    for HTTP requests, which is handled by the TCP protocol, so we'll specify the
    TCP protocol when we initialize `Socket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And those two pieces of information are the minimum details we''re required
    to specify for a socket, the public constructor signature being as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is also an option to specify what's known as the `AddressFamily` of your
    connection. This can actually be derived from your connection endpoint and provided
    to the constructor for your socket. Typically, for an HTTP resource transmitted
    over TCP, your specification will be `AddressFamily.Osi`, indicating that you're
    using OSI addressing schemes. So now that we know how to initialize a socket,
    let's look at what it takes to connect a socket to a remote endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a socket connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we''ll want to do is set up a simple listening server to which
    we can connect our socket driver program. To do this, we''ll spin up a simple,
    `WebAPI` project and run it. Start by opening up Command Prompt and navigating
    to the directory where you want to create your sample API. Next, create a new
    `WebAPI` with the following command from the .NET Core CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will spin up a new application from scratch that will be ready-made to
    receive and respond to HTTP and HTTPS requests made to your local machine and
    a pre-configured port.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this demonstration, we''ll actually want to disable some
    default functionality in this application. The template for a WebAPI will redirect
    all calls made to the HTTP port to the HTTPS port instead. We want to prevent
    this from happening so the HTTP port, can service requests directly. You''ll see
    why later, but for now you can disable this functionality by opening up your `SampleApp`
    project and navigating to the `Startup.cs` file. Within this file, you''ll find
    a method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of this method, delete or comment out the line of code that reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s done, you can close that folder and ignore its contents for the
    rest of this sample project. Now, let''s run it and test it, first by navigating
    into the folder that was just created, and then calling the CLI `dotnet run` command.
    Once you''ve done that, you should see the following output from your running
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e02c49cd-5085-429f-95eb-02094047f785.png)'
  prefs: []
  type: TYPE_IMG
- en: You can take your time investigating the project template created by the `dotnet
    new` command if you're curious, but we'll be covering WebAPI applications, among
    many others, in much greater detail in the next chapter. For now, it's just important
    that we have an application that's listening for requests and returning responses.
    You can simply take my word on its expected functionality going forward, if you'd
    rather defer learning that until later.
  prefs: []
  type: TYPE_NORMAL
- en: The last three lines of your console output give you some valuable information;
    they tell you the exact host and port through which your application is exposed
    to outside connections. As you can see, the default from new WebAPIs created by
    .NET is going to be port `5000` for incoming HTTP requests, and `5001` for HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that the application is responding to requests, open up Postman
    (or Insomniac, if that was your REST client of choice), and send a GET request
    to `http://localhost:5000/api/values`. You should see the following response in
    your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2185971-58e0-4437-83fa-fe4c12330170.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see a valid response with two strings in a `JSON` array. Once you have
    this, we're ready to connect with `Socket`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console application in the parent directory of `SampleApp`, using
    the `dotnet new console -n SocketTest` command in the CLI. This will be our driver
    application for working with the `Socket` class. The objective of this sample
    project is to connect to our `SampleApp`*,* which is listening on the `5000` port,
    submit a request to the `/api/values` endpoint, and then parse and print the response.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first thing we'll have to do is define an `IPEndPoint` instance for
    `Socket` to connect to. `IPEndPoint` is a specific implementation of the `EndPoint`
    abstract class required by the `Socket.ConnectAsync()` method we'll be using.
    It defines the specific location of the remote resource we intend to connect to,
    and exposes metadata about that endpoint. It also provides the `AddressFamily`
    value for our `Socket` constructor signature. So let's first define that with
    the host address and port, and use it to construct `Socket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need an `IPAddress` instance, which we could build ourselves based
    on the 4 bytes stored in our localhost address of `127.0.0.1`, or we could simply
    request it explicitly from our DNS using the `Dns.GetHostEntry()` method from
    [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml), *DNS and Resource Location*.
    You can do as you please when following along, but since it involves less math,
    I''ll be using the DNS. However, since `AddressList` returned by a host entry
    can have an arbitrarily large list of IP Addresses to which the name could resolve,
    we''ll want to connect to the first address that allows us to, and proceed from
    there. This means looping through `AddressList` until a connection is established.
    So the initial setup to attempt to establish our connection will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing that might jump out to you about this code is that we''re using the
    `async` version of the `Main()` method. This is a feature that was only added
    in version 7.2 of C#, and if your project isn''t configured to target at least
    that version, you''ll encounter build errors. To resolve them, simply modify the
    `PropertyGroup` tag of your `.csproj` file to include the `LangVersion` tag with
    its version set to `latest`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you've made this change, your source code will always target the latest
    minor version of C#. With that in place, you should have no problems running your
    `Main()` method asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make sure things are behaving as expected, you can go ahead and
    run your application, placing a breakpoint on the `break;` operator, and you should
    see that the breakpoint is hit, and so a connection was established between your
    two applications. You'll notice, though, that simply establishing the connection
    didn't trigger any log messages in your running WebAPI application. This is because,
    while a connection was established, no request was made of the resource to which
    we connected. Requests must be sent as a well-formed message over an established
    connection. So now, let's build our request and send it over the connected socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending requests is as simple as calling the `SendAsync()` method on our socket
    with a byte array representing our data buffer to be sent over the connection.
    So for an HTTP request, we have to build our message from scratch. That means
    specifying the method or HTTP verb we''ll be using, the specific URL of our requested
    resource, the size of any content we intend to send over, and any request headers
    we need to attach. I''m sure by now you can already see how tedious it is to work
    directly with sockets. For such a simple request, however, we can easily construct
    our message with a simple utility function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then using this, we can build our byte array just as we did when writing to
    streams. So back in our main method, we''ll get our request message, convert it
    to a byte array, and then send the request to our remote host (*SampleApp*, running
    at `http://localhost:5000`). Add the following lines into the main method after
    the connection has been established by the `Socket` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add this code and then run your application, you''ll know you''ve succeeded
    when you begin to see logging information in the console displayed by your WebAPI
    project, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ef05055-81cf-43ee-a743-062dbb81db9e.png)'
  prefs: []
  type: TYPE_IMG
- en: And just like that, you've managed to send your first transport-level message
    over a socket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to confirm that we're receiving the responses from the server properly,
    we'll try to write to our `SocketTest` application's console the same message
    that we saw earlier in the responses from our Postman (or Insomnia) requests.
    In order to do that, we'll have to use the `ReceiveAsync()` method to accept whatever
    byte arrays were returned by the server in response to our request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with the instances of the `Stream` class we used in earlier chapters,
    the `ReceiveAsync()` method accepts a byte array into which it will write. For
    this, we''ll provide it with an empty array, 512 bytes long. Once we define that,
    we can receive the response from the remote resource, and simply write it to our
    console, one line at a time. Just add the following lines of code to the bottom
    of your `Main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the application now, you should see the message headers, along
    with the body containing the string array we saw earlier in Postman, printed to
    your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45cee704-5e2e-4f03-adc9-9b1814956ce4.png)'
  prefs: []
  type: TYPE_IMG
- en: And just like that, you've successfully executed an HTTP request over TCP from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last order of business is to disconnect from your host, and dispose of
    your socket. Let the last two lines of your application `Main()` method read as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a major courtesy on your part. Even though a port can handle multiple
    connections simultaneously, there is an upper limit to how many connection requests
    it can service at a given point in time. Disconnecting your own Socket frees up
    resources on the remote host for others to take advantage of. While there is a
    maximum time limit for an inactive connection, after which the remote host will
    forcibly cancel the connection, you shouldn't ever let an inactive connection
    remain alive for that long. If you're done with the host, disconnect from the
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I'm sure you already figured out, the simple string of ASCII characters that
    encapsulated the entirety of a response from your remote host is not exactly a
    computer-friendly format. Receiving a response is one thing, but leveraging its
    contents in your application is a whole different kinds of beast. Doing this kind
    of work from scratch every time you needed to access something on a different
    machine would slow the software development life cycle down to a crawl.
  prefs: []
  type: TYPE_NORMAL
- en: This is why .NET Core provides so many functional flexible wrapper and utility
    classes for the specific protocols and interactions you're most likely to deal
    with day to day. So, while I think it's important that you understand exactly
    how to establish and then leverage a direct connection from your application to
    any other application running on any other machine on your network, it's also
    not exactly so common that you'll find yourself needing to do so. As we move into
    the next few chapters, we'll see how the templates and libraries provided by .NET
    Core (and ASP.NET Core, in the case of HTTP) do all the heavy lifting so that
    we don't have to. If you're curious to learn more about low-level network interactions
    in C#, there's an entire ocean of knowledge and use cases that I simply didn't
    have time to cover in this chapter, and I would encourage you to spend some time
    digging in. If this content seemed a bit boring or tedious, though, don't worry.
    It's about to get a lot more fun.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began to leverage and finally build from the foundation
    we've laid in previous chapters, opening up our applications to the full spectrum
    of network functionality available in C#. We learned that any application we write
    that we expect to be used by resources on our network must first be exposed to
    those resources through a port on our host machine. We looked at how ports are
    specified and registered, and learned about some restrictions that exist on how
    we can register our own, looking at the reason for, and the range, of well-known
    port addresses and the range of dynamic or ephemeral ports to which we cannot
    (or at least should not) register our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Once we cemented that concept, we looked at the other side of the connection,
    and started working with sockets. We learned that sockets are a generic in-code
    representation of an active connection to an open port on a remote machine. We
    saw how the simplicity of that concept opened up a wide array of applications
    for socket-based network code and the low-level control it gives over packet-level
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: With the concepts we've covered in this book so far, you have the resources
    necessary to write any network software you could ever need. Understanding the
    nature of asynchronous streams, packet construction and parsing, and socket connections
    to remote resources would be sufficient to implement any piece of networking functionality
    possible. It would be far from ideal, though, using such primitive building blocks.
    That's why the .NET Standard provides so many useful templates, patterns, and
    libraries for the myriad of applications you might have to write, and that's what
    we'll start looking at in the next chapter, starting with HTTP-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the definition of a port?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the range of well-known ports?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the dynamic port range?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one of the primary functions of an application server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the definition of a socket?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the primary distinctions between a socket and a port?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which construct provides the range of protocols over which a socket can connect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the protocols that sockets support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further reading on this subject, many of the books I've recommended in previous
    chapters still apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional insight, though, you can look at *ASP.NET Core 1.0 High Performance*,
    *James Single**ton,* Packt Publishing*.* While the subject of that book is specifically
    application-layer network programming, he addresses the performance benefits of
    managing direct connection I/O, and the subject may be of interest. You can find
    it through *Packt Publishing*, here: [https://www.packtpub.com/application-development/aspnet-core-10-high-performance.](https://www.packtpub.com/application-development/aspnet-core-10-high-performance)'
  prefs: []
  type: TYPE_NORMAL
