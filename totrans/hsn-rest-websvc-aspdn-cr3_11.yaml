- en: Building the Data Access Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数据访问层
- en: Starting from this chapter, we are going to walk through the concrete implementation
    of the web service part using .NET Core. We will cover some key aspects of developing
    real web services—from the design of the data access layer to the implementation
    of the HTTP routes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将通过使用 .NET Core 来具体实现 Web 服务部分。我们将涵盖开发真实 Web 服务的一些关键方面——从数据访问层的设计到 HTTP
    路由的实现。
- en: In this chapter, we will start by defining the data access part. The data access
    part is necessary to store information in a database or data source, and it is
    usually one of the most delicate parts of an application. We will be focusing
    on the implementation of a catalog web service. Additionally, we will explore
    different third-party tools for accessing our data and explain how to set up a
    project and implement a data domain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先定义数据访问部分。数据访问部分是必要的，用于在数据库或数据源中存储信息，并且通常是应用程序中最微妙的部分之一。我们将专注于实现一个目录
    Web 服务。此外，我们还将探索不同的第三方工具来访问我们的数据，并解释如何设置项目和实现数据域。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Designing project entities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计项目实体
- en: Choosing the right tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的工具
- en: Implementing a data access layer using EF Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EF Core 实现数据访问层
- en: Implementing a data access layer using Dapper
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dapper 实现数据访问层
- en: Testing a data layer using the in-memory database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存数据库测试数据层
- en: 'The code in this chapter is available from the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以从以下 GitHub 仓库获取：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).
- en: Setting up the project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Just like previous chapters, we can start by creating a new project using the
    web API template. Let''s open the terminal and execute the following commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的章节一样，我们可以通过使用 Web API 模板来创建一个新的项目。让我们打开终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first `dotnet new` command creates a new solution file named `Catalog.API`.
    The second `dotnet new` instruction creates a new web API project in the `src`
    folder. Finally, the last `dotnet sln` command adds the project to our solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `dotnet new` 命令创建了一个名为 `Catalog.API` 的新解决方案文件。第二个 `dotnet new` 指令在 `src`
    文件夹中创建了一个新的 Web API 项目。最后，最后一个 `dotnet sln` 命令将项目添加到我们的解决方案中。
- en: 'The resulting filesystem structure looks like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的文件系统结构如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `src` folder will contain all our code and the additional projects we will
    add in the book. Later on in this chapter, we will also add a `tests` folder that
    will contain all the tests for our projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 文件夹将包含我们所有的代码以及本书中我们将添加的附加项目。在本章的后面部分，我们还将添加一个 `tests` 文件夹，其中将包含我们项目的所有测试。'
- en: Implementing the domain model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现域模型
- en: As discussed in the *Data transfer* section in [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*, the *domain model* is the representation
    of the data handled by our service. Thinking about a *catalog web service* for
    a music store, the primary data we need to process includes the *entities* used
    by the API*.*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 5 章中在 *数据传输* 部分讨论的，[ASP.NET Core 中的 Web 服务堆栈](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml)，*域模型*
    是我们服务处理的数据的表示。考虑一个 *音乐商店的目录 Web 服务*，我们需要处理的主要数据包括 API 使用的 *实体*。
- en: 'To guarantee reusability and loose coupling, we are going to define the domain
    model of the servicein a separate project. First of all, let''s create a new `Catalog.Domain`
    project inside the `src` folder by executing the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证可重用性和松散耦合，我们将定义服务域模型为一个独立的项目。首先，让我们在 `src` 文件夹中通过执行以下命令创建一个新的 `Catalog.Domain`
    项目：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The above command also specifies the `netstandard2.1` version as target framework.
    Furthermore, after creating the `Catalog.Domain` project, we need to add it to
    our solution:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令还指定了 `netstandard2.1` 版本为目标框架。此外，在创建 `Catalog.Domain` 项目后，我们需要将其添加到我们的解决方案中：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding instruction adds a reference to the `Catalog.Domain` project to
    the `Catalog.API.sln` file. Therefore, we are now ready to design and implement
    the entities of our web service.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令将 `Catalog.Domain` 项目添加到 `Catalog.API.sln` 文件中。因此，我们现在已经准备好设计和实现我们 Web 服务的实体。
- en: Designing entities
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计实体
- en: We can now proceed with the design phase of the entities we need for this implementation.
    Let's start with the `Item` class, which will be the central entity in our domain
    model. It is a representation of a music album, and it contains all the attributes
    and characteristics related to albums, including the *description*, *name*, *release*
    *date*, and *format.* The entity will also provide some additional information
    that is usually present in a catalog, such as available stock, a picture, and
    the price.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行我们需要实现实体的设计阶段。让我们从 `Item` 类开始，它将成为我们领域模型中的中心实体。它代表一张音乐专辑，包含与专辑相关的所有属性和特征，包括
    *描述*、*名称*、*发行* *日期* 和 *格式*。实体还将提供一些通常出现在目录中的附加信息，例如可用库存、图片和价格。
- en: 'Let''s start by designing a diagram to describe our code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设计一个图来描述我们的代码：
- en: '![](img/1390bf3f-dc67-4333-908f-e1df3a3fc65f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1390bf3f-dc67-4333-908f-e1df3a3fc65f.png)'
- en: 'This diagram defines the entities involved in the service:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此图定义了服务中涉及的实体：
- en: '`Item` is the primary entity in our claim. It contains all the information
    about the album and the references to the *artist* and the *genre*.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Item` 是我们声明中的主要实体。它包含关于专辑的所有信息以及指向 *艺术家* 和 *类型* 的引用。'
- en: The `Artist` entity represents the artist associated with the album.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Artist` 实体表示与专辑相关的艺术家。'
- en: The `Genre` entity represents the music genre associated with the album.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Genre` 实体表示与专辑相关的音乐类型。'
- en: The `Money` entity represents the price of the album. This is a complex type
    that contains the amount of *money* and the *currency* it is in.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Money` 实体表示专辑的价格。这是一个复杂类型，包含金额和货币单位。'
- en: Implement entities
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实体
- en: 'Now we have defined which properties and objects are included in the catalog
    service, let''s start by implementing the entities as concrete types. All domain
    models are conventionally stored in the `Entities` folder in the `Catalog.Domain`
    project. The first type we are creating is the `Item` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了目录服务中包含哪些属性和对象，让我们首先实现实体作为具体类型。所有领域模型都传统上存储在 `Catalog.Domain` 项目的 `Entities`
    文件夹中。我们正在创建的第一个类型是 `Item` 类：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we can see that the definition of the `Item` class contains some references
    to the other types. It is crucial to note that the implementation uses the `Guid`
    type to specify `Id`. The primary purpose of that approach is to avoid conflicts
    in the event of a merger between two different data sources or catalogs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到 `Item` 类的定义中包含了对其他类型的引用。需要注意的是，该实现使用 `Guid` 类型来指定 `Id`。这种方法的目的是在两个不同的数据源或目录合并时避免冲突。
- en: 'Let''s proceed by defining the related entities of our domain model:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义我们领域模型的相关实体：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For representational purposes, the following classes are implemented in the
    same fragment of code. Note that they are defined in different files: `Artist.cs`,
    `Genre.cs`, and `Price.cs`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示目的，以下类在相同的代码片段中实现。请注意，它们定义在不同的文件中：`Artist.cs`、`Genre.cs` 和 `Price.cs`。
- en: The preceding code defines the related entities contained in our domain model*.*
    The `Artist` class represents an artist related to an album. It includes `Guid
    id` and `ArtistName`. In the same way, the `Genre` class is another category type
    that represents the genre of a specific album. Finally, the `Price` class represents
    the price (and the currency) of the product.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了领域模型中包含的相关实体*.* `Artist` 类表示与专辑相关的艺术家。它包括 `Guid id` 和 `ArtistName`。同样，`Genre`
    类是另一种类别类型，表示特定专辑的类型。最后，`Price` 类表示产品的价格（以及货币单位）。
- en: Data access using ORMs
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ORM 进行数据访问
- en: Data access is the part of our service that helps us to perform reading or writing
    operations on the data source. The data access section is usually combined with
    an ORM. In general, we can define an ORM as an object-relational mapping tool
    for converting relational data between incompatible type systems using an object-oriented
    programming approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问是我们服务的一部分，帮助我们执行对数据源进行读取或写入操作。数据访问部分通常与 ORM 结合使用。一般来说，我们可以将 ORM 定义为一种面向对象编程方法，用于在互不兼容的类型系统之间转换关系数据。
- en: ORM tools or packages are a bridge between a data source and a web application.
    They map the information represented in relational tables into classes and, consequently,
    objects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 工具或包是数据源和 Web 应用程序之间的桥梁。它们将关系表中的信息映射到类中，从而映射到对象中。
- en: In the .NET ecosystem, we can choose between a vast number of different ORMs.
    The one that is officially maintained by Microsoft is EF Core.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 生态系统中，我们可以选择大量的不同 ORM。由微软官方维护的是 EF Core。
- en: EF Core is an open source ORM powered by Microsoft and the community. It is
    the default ORM used in .NET Core applications and web services. In this chapter,
    we will also have an overview of **Dapper**, an open source micro-ORM powered
    by Stack Exchange and the community. Both EF Core and Dapper are distributed as
    NuGet packages, and, in general, they are very well integrated with the .NET Core
    framework.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 是由微软和社区支持的开放源代码 ORM。它是 .NET Core 应用程序和 Web 服务中使用的默认 ORM。在本章中，我们还将概述由
    Stack Exchange 和社区支持的开放源代码微 ORM **Dapper**。EF Core 和 Dapper 都作为 NuGet 包分发，并且通常与
    .NET Core 框架非常良好地集成。
- en: Finding the right tool for the job
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找适合工作的正确工具
- en: EF Core and Dapper provide an abstraction level over our data source. Nevertheless,
    both of them have some pros and cons. It is essential to bear in mind that, for
    every project we are working on, we should seek to find the right tool for the
    job.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 和 Dapper 都为我们提供了数据源的高级别抽象。尽管如此，它们都有一些优缺点。我们必须牢记，对于我们在做的每一个项目，我们都应该寻找适合这项工作的正确工具。
- en: 'Let''s analyze some pros and cons for these two libraries. Before that, we
    should take a quick look at some demo queries in order to understand the differences
    between the two. The following snippet describes a sample query using EF Core:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这两个库的优缺点。在此之前，我们应该快速查看一些示例查询，以便了解两者之间的差异。以下代码片段描述了一个使用 EF Core 的示例查询：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we search for every `Item` entity with a corresponding
    description. Let''s proceed by taking a Dapper query as an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们搜索每个具有相应描述的 `Item` 实体。让我们以一个 Dapper 查询为例继续进行：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, EF Core provides a high level of abstraction over our data source.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，EF Core 在我们的数据源上提供了高级别的抽象。
- en: 'Moreover, EF Core, by default, allows developers to query data using collections
    (integrated with LINQ). This type of approach is quick and easy, but it comes
    at a cost: EF Core translates queries into the SQL language, and, sometimes, it
    produces SQL queries that are not optimized. EF Core also encourages a code-first
    approach over the database, which means that all the entities that are present
    on the database side are generated using C# code. This may seem easy when you
    have a single object, but it can present maintainability problems when you have
    complex entities.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，EF Core 默认允许开发者使用集合（与 LINQ 集成）查询数据。这种方法快速且简单，但代价是：EF Core 将查询转换为 SQL 语言，有时生成的
    SQL 查询没有优化。EF Core 还鼓励代码优先的方法，这意味着数据库侧的所有实体都使用 C# 代码生成。当你只有一个对象时，这可能看起来很简单，但当实体复杂时，可能会出现可维护性问题。
- en: In complex entities, or applications that use the code-first approach, the code
    that generates database entities is usually implemented in a separate project
    and repository to avoid tight coupling between the database and the entire solution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂实体或使用代码优先方法的程序中，生成数据库实体的代码通常在单独的项目和存储库中实现，以避免数据库与整个解决方案之间的紧密耦合。
- en: 'A common problem with EF Core, though, is the early fetching of resources.
    For example, consider a query such as this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，EF Core 的一个常见问题是资源的早期获取。例如，考虑以下查询：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It produces a SQL query similar to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它生成一个类似于以下查询的 SQL 查询：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, despite the fact we use the `Where` clause, earlier the `ToList`
    method evaluated the query without considering the `Where` clause. To get a better
    result, we should execute the `Where` statement before the evaluation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管我们使用了 `Where` 子句，但之前 `ToList` 方法在评估查询时没有考虑 `Where` 子句。为了得到更好的结果，我们应该在评估之前执行
    `Where` 语句：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This kind of procedure is better both for performance and network reasons. It
    may seem simple enough, but it is quite common that these kinds of error are introduced
    in the codebase in distributed teams, and they can be quite tricky to spot in
    the code review process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种程序在性能和网络方面都更好。它可能看起来足够简单，但在分布式团队中，这些错误在代码库中很常见，而且在代码审查过程中很难发现。
- en: In terms of Dapper, which is a micro-ORM, the abstraction level changes. Dapper
    provides more *transparent* access to the data source. It guarantees, by default,
    a clear way to query your data by using plain SQL or stored procedures. Consequently,
    it also ensures better performance. On the other hand, it is tightly coupled with
    the data source, because it executes queries using the data source query language.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dapper 的层面上，这是一个微型 ORM，抽象级别发生了变化。Dapper 提供了对数据源更**透明**的访问。它默认保证通过使用纯 SQL 或存储过程以清晰的方式查询数据。因此，它也确保了更好的性能。另一方面，它与数据源紧密耦合，因为它使用数据源查询语言执行查询。
- en: In summary, this chapter will cover both EF Core and Dapper libraries. To choose
    between them, you should consider the skills already present in your team and
    how the service can be performance-optimized. If your team has a strong knowledge
    of SQL, you may proceed by implementing stored procedures instead of using EF
    Core. On the other hand, if your team doesn't already have SQL skills, you should
    consider using EF Core.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章将涵盖 EF Core 和 Dapper 库。在选择它们之间，你应该考虑你团队已有的技能以及如何优化服务的性能。如果你的团队对 SQL 有很强的了解，你可以通过实现存储过程而不是使用
    EF Core 来进行。另一方面，如果你的团队还没有 SQL 技能，你应该考虑使用 EF Core。
- en: Implementing a data access layer using EF Core
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EF Core 实现数据访问层
- en: In this section, we will explore how to build a data access layer using the
    repository pattern and EF Core. The **repository pattern** is an additional abstraction
    over our data source. It provides reading and writing operations on data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用仓储模式和 EF Core 构建数据访问层。**仓储模式**是在我们的数据源之上提供的一个额外抽象。它提供了对数据的读取和写入操作。
- en: Defining the repository pattern and unit of work
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义仓储模式和单元工作
- en: 'Before we start, we need to define some interfaces in the `Catalog.Domain`
    project. Let''s proceed by setting a generic interface to determine the unit of
    work of our repository:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要在 `Catalog.Domain` 项目中定义一些接口。让我们通过设置一个泛型接口来确定我们仓储的单元工作：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`IUnitOfWork` defines two methods: `SaveChangesAsync` and `SaveEntitiesAsync`.
    These two methods are used to save changes in our collection to the database effectively.
    These methods are both asynchronous: they return a `Task` type and they accept
    a `CancellationToken` type as a parameter. The `CancellationToken` parameter provides
    a way to stop pending asynchronous operations.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUnitOfWork` 定义了两个方法：`SaveChangesAsync` 和 `SaveEntitiesAsync`。这两个方法用于有效地将我们的集合更改保存到数据库中。这两个方法都是异步的：它们返回
    `Task` 类型，并接受一个 `CancellationToken` 类型的参数。`CancellationToken` 参数提供了一种停止挂起的异步操作的方法。'
- en: In some cases, the repository pattern is implemented in such a way that, when
    you update or create new elements in a collection, those changes are automatically
    saved to the database. I prefer to keep the effective saving operation separate
    from the reading and writing part. This can be achieved using the unit of work
    approach. Therefore, the repository allows the higher layers to perform get, create,
    and update operations on the memory collection, while the *unit of work*implements
    a way to transfer those changes to the database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，仓储模式被实现为，当你更新或创建集合中的新元素时，这些更改会自动保存到数据库中。我更喜欢将有效的保存操作与读取和写入部分分开。这可以通过使用单元工作方法来实现。因此，仓储允许高层在内存集合上执行获取、创建和更新操作，而**单元工作**实现了一种将这些更改传输到数据库的方法。
- en: 'Let''s proceed by defining an `IRepository` interface at the same folder level
    as the `IUnitOfWork` interface defined previously:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，通过在之前定义的 `IUnitOfWork` 接口相同的文件夹级别定义一个 `IRepository` 接口：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, `IRepository` does not implicitly use the `IUnitOfWork` interface.
    Additionally, it exposes the `UnitOfWork` instance as a property of the class.
    This approach guarantees that all the consumers of the `IRepository` interface
    must explicitly update the database by calling the `SaveChangesAsync` or `SaveEntitiesAsync`
    methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`IRepository` 并没有隐式使用 `IUnitOfWork` 接口。此外，它将 `UnitOfWork` 实例作为类的属性暴露出来。这种做法保证了所有
    `IRepository` 接口的消费者都必须显式地通过调用 `SaveChangesAsync` 或 `SaveEntitiesAsync` 方法来更新数据库。
- en: 'The final step is to define the `IItemRepository` interface, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是定义 `IItemRepository` 接口，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interface extends the `IRepository` class and refers to the `Item` entity
    that was defined previously. `IItemRepository` defines reading and writing operations
    over our data source. You may notice that the `Add`, `Update`. This is because
    they only act on the collection stored in the memory of the application, and the
    effective saving operation is performed by the unit of work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口扩展了 `IRepository` 类，并引用了之前定义的 `Item` 实体。`IItemRepository` 定义了对数据源进行读取和写入操作。你可能注意到
    `Add`、`Update` 等，这是因为它们只作用于应用程序内存中存储的集合，而有效的保存操作是由工作单元执行的。
- en: Connecting our repository to the database
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的存储库连接到数据库
- en: 'Once we have defined the `IItemRepository` interfaces and all the abstractions
    in the domain project, we should continue by creating the classes that will represent
    the concrete implementation of the previously defined abstractions. We will also
    create a new `Catalog.Infrastructure` project containing all the implementations
    of our repositories and the classes that represent the layer between our service
    and the database. Let''s create the `Catalog.Infrastructure` project by executing
    the following commands in the `src` folder:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `IItemRepository` 接口和领域项目中所有的抽象，我们应该继续创建代表之前定义的抽象的具体实现的类。我们还将创建一个新的
    `Catalog.Infrastructure` 项目，其中包含我们存储库的所有实现以及代表我们服务和数据库之间层的类。让我们通过在 `src` 文件夹中执行以下命令来创建
    `Catalog.Infrastructure` 项目：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once finished, the folder structure for our solution looks as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的解决方案的文件夹结构如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before proceeding with the implementation of `IItemRepository`, we need to
    add the `Microsoft.EntityFrameworkCore` NuGet package to the `Catalog.Infrastructure`
    project by executing the following command inside the project folder:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现 `IItemRepository` 之前，我们需要通过在项目文件夹内执行以下命令将 `Microsoft.EntityFrameworkCore`
    NuGet 包添加到 `Catalog.Infrastructure` 项目中：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that, we can proceed by adding the reference to the `Catalog.Domain`
    project into the infrastructure project, using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过使用以下命令将 `Catalog.Domain` 项目的引用添加到基础设施项目中继续操作：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: DbContext definition
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DbContext 定义
- en: '`DbContext` is one of the abstractions between our application and the database.
    It enables us to interact with, and perform operations over, data. A `DbContext`
    implementation is also the representation of a session between our application
    and the database, and it can be used to query and save the instances of the application
    entities into our data source. Let''s take a quick look at the `DbContext` implementation
    in the `Catalog.Infrastructure` project:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbContext` 是我们应用程序和数据库之间的一种抽象。它使我们能够与数据交互，并对数据进行操作。`DbContext` 的实现也是我们应用程序和数据库之间会话的表示，我们可以用它来查询并将应用程序实体的实例保存到我们的数据源中。让我们快速看一下
    `Catalog.Infrastructure` 项目中的 `DbContext` 实现：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After taking a quick look at the code, we should mention the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速查看代码后，我们应该提到以下几点：
- en: The `CatalogContext` class represents our unit of work; therefore, it implements
    the `IUnitOfWork` interface.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CatalogContext` 类代表我们的工作单元；因此，它实现了 `IUnitOfWork` 接口。'
- en: It uses the `DbSet<Item>` type to represent the collection of `Item` instances.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `DbSet<Item>` 类型来表示 `Item` 实例的集合。
- en: The constructor of the `CatalogContext` class accepts a mandatory argument,
    which represents `DbContextOptions`. These options are used to specify some key
    information about the connection with the database. This includes the database
    provider to be used, the connection string to that database, and all the tracking
    policies used by the ORM.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CatalogContext` 类的构造函数接受一个强制参数，它代表 `DbContextOptions`。这些选项用于指定有关数据库连接的一些关键信息。这包括要使用的数据库提供程序、数据库的连接字符串以及
    ORM 所使用的所有跟踪策略。'
- en: The `CatalogContext` class also implements `SaveEntitiesAsync`, which calls
    the `SaveChangesAsync` method derived by the `DbContext` class.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CatalogContext` 类还实现了 `SaveEntitiesAsync`，它调用由 `DbContext` 类派生的 `SaveChangesAsync`
    方法。'
- en: Once we have `CatalogContext`, we can continue by implementing the `IItemRepository`
    interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `CatalogContext`，我们就可以继续实现 `IItemRepository` 接口。
- en: Implementing the repository
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现存储库
- en: The following subsection focuses on building the concrete implementation of
    the `IItemRepository` interface. It is vital to note that the `IItemRepository`
    interface is located in the `Catalog.Domain` project and the implementation of
    `ItemRepository` is in the `Catalog.Infrastructure` project*.*
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节重点介绍 `IItemRepository` 接口的具体实现。重要的是要注意，`IItemRepository` 接口位于 `Catalog.Domain`
    项目中，而 `ItemRepository` 的实现位于 `Catalog.Infrastructure` 项目中*.*
- en: 'Once we have built the `DbContext` class, we can proceed by implementing the
    concrete `ItemRepository` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了 `DbContext` 类，我们就可以通过实现具体的 `ItemRepository` 类来继续操作：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code implements the CRUD operations previously defined in the
    `IItemRepository` interface. It also exposes `CategoryContext` using the `IUnitOfWork`
    interface. This kind of approach guarantees that the consumer of `IItemRepository`
    can modify and query our collections and also update the data source with the
    corresponding changes. Let''s walk-through the methods implemented in the preceding
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了在 `IItemRepository` 接口中先前定义的 CRUD 操作。它还通过 `IUnitOfWork` 接口公开了 `CategoryContext`。这种方法的保证是，`IItemRepository`
    的消费者可以修改和查询我们的集合，并使用相应的更改更新数据源。让我们回顾一下上述代码中实现的方法：
- en: The `GetAsync()` method uses the context to retrieve the collection of `Items`
    entities. The method uses the `AsNoTracking()` method explicitly in order to prevent
    the tracking of entities. This extension method can be used every time you don't
    need to perform writing operations on entities, and it is meant for read-only
    data.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAsync()` 方法使用上下文检索 `Items` 实体的集合。该方法显式使用 `AsNoTracking()` 方法以防止跟踪实体。此扩展方法可以在您不需要对实体执行写入操作时使用，并且它适用于只读数据。'
- en: '`GetAsync(Guid id)` overloads the previously mentioned method, and it uses
    `AsNoTracking()` for the same purpose described previously. This method also gets
    details of the related entities (`Genre` and `Artist`) by using the `Include()`
    extension method provided by EF Core.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAsync(Guid id)` 重载了之前提到的方法，并使用 `AsNoTracking()` 实现了之前描述的相同目的。此方法还通过使用 EF
    Core 提供的 `Include()` 扩展方法获取相关实体的详细信息（`Genre` 和 `Artist`）。'
- en: The `Add(Item entity)` method uses the context to add the entity passed as a
    parameter and it returns the added entity to the caller.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add(Item entity)` 方法使用上下文添加作为参数传递的实体，并将添加的实体返回给调用者。'
- en: The `Edit` method updates the target entity from the context and sets `EntityState.Modified`.
    This approach guarantees that, once the entity is in a modified state, it will
    be updated at the saving step.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Edit` 方法从上下文中更新目标实体，并将 `EntityState.Modified` 设置为实体状态。这种方法保证了，一旦实体处于修改状态，它将在保存步骤中被更新。'
- en: The preceding code doesn't implement the `Delete` method. This is because the
    delete process will be implemented later on in the book. We will essentially perform
    a soft deletion of our data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码没有实现 `Delete` 方法。这是因为删除过程将在本书的后续部分实现。我们将执行软删除我们的数据。
- en: Transforming entities into a SQL schema
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实体转换为 SQL 架构
- en: EF Core encourages the code-first approach in our services. The **code-first**
    technique consists of defining some entity classes in C# and using them to generate
    tables on the database side. The same approach is applied to all the relationships
    and constraints that are usually present in a SQL ecosystem, such as the index,
    the primary keys, andthe foreign keys. This section demonstrates how to use this
    kind of approach to generate the database schema.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 鼓励我们在服务中使用代码优先的方法。**代码优先**技术包括在 C# 中定义一些实体类，并使用它们在数据库端生成表。同样的方法应用于通常存在于
    SQL 生态系统中的所有关系和约束，例如索引、主键和外键。本节演示了如何使用这种方法生成数据库架构。
- en: 'First of all, let''s start by taking back our `Item.cs` entity and adding an
    ID that represents the relationship with the other entities:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从我们的 `Item.cs` 实体开始，并添加一个 ID 来表示与其他实体的关系：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code describes the *many-to-one* relationship between the `Item`
    class and the `Artist` class and between the `Item` class and the `Genre` class.
    Additionally, both the `Artist` and `Genre` entities have a collection that refers
    to a collection of `Item` entities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了 `Item` 类与 `Artist` 类以及 `Item` 类与 `Genre` 类之间的 **多对一** 关系。此外，`Artist`
    和 `Genre` 实体都有一个集合，该集合引用了 `Item` 实体的集合。
- en: Let's continue by implementing the constraints of our `Item` entity using the
    Fluent API approach. In general, EF Core ORM implements the Fluent API's technique
    to help us to deal with the constraint's definitions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过使用Fluent API方法实现我们的`Item`实体约束。一般来说，EF Core ORM实现了Fluent API技术，帮助我们处理约束定义。
- en: In general, the Fluent API, also called the **Fluent interface**, is a method
    for composing object-oriented APIs that are essentially based on method chaining.
    The chain between methods produces source code that is very close to written prose;
    for example, `myList.First().Items.Count().ShouldBe(2)`*.* You can see how readable
    this example is; it can be understood by anyone. Most EF Core constraints are
    usually built using this kind of approach.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Fluent API，也称为**Fluent接口**，是一种组合面向对象API的方法，这些API本质上基于方法链。方法之间的链产生接近书面语法的源代码；例如，`myList.First().Items.Count().ShouldBe(2)`*.*
    你可以看看这个例子有多易读；任何人都能理解。大多数EF Core约束通常都是使用这种方法构建的。
- en: 'Let''s proceed by adding a new folder called `SchemaDefinitions` inside our
    `Catalog.Infrastructure` project. The folder will contain all the schema definitions
    implemented for the application and all the definitions of the constraints between
    the entities. For example, in the case of the `Item` entity, we need to create
    a new `ItemEntitySchemaDefinition` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Catalog.Infrastructure`项目中添加一个名为`SchemaDefinitions`的新文件夹。该文件夹将包含为应用程序实现的所有架构定义以及实体之间约束的所有定义。例如，在`Item`实体的情况下，我们需要创建一个新的`ItemEntitySchemaDefinition`类：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the schema definition of the `Item` entity constraints. The class implements
    the `IEntityTypeConfiguration<T>` interface exposed by the `Microsoft.EntityFrameworkCore.SqlServer`
    package. It is necessary to add a new reference to the `Catalog.Infrastructure`
    project by using the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Item`实体约束的架构定义。该类实现了由`Microsoft.EntityFrameworkCore.SqlServer`包公开的`IEntityTypeConfiguration<T>`接口。必须通过以下命令向`Catalog.Infrastructure`项目添加一个新的引用：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The package provides an extension method to interact with a SQL server database:
    the `Configure` method implementation defines rules, which will be applied to
    the `Item` entity. Because of the Fluent API approach, it is easy to understand
    these rules:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该包提供了一个扩展方法来与SQL服务器数据库交互：`Configure`方法实现定义了规则，这些规则将应用于`Item`实体。由于Fluent API方法，这些规则很容易理解：
- en: The `ToTable` method is used to define the name of the SQL table explicitly
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToTable`方法用于显式定义SQL表名。'
- en: The `HasKey` method sets the property as the primary key for this entity type
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasKey`方法将属性设置为该实体类型的键。'
- en: The `IsRequired` method is used to mark all the required features
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsRequired`方法用于标记所有必需的功能。'
- en: EF Core provides different *out-of-box* configurations for our properties; a
    complete list is available at [https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/).
    These properties can be combined to obtain a better result regarding the correct
    representation of our domain model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core为我们提供了不同的**开箱即用**配置选项；完整的列表可在[https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/)找到。这些属性可以组合起来，以获得关于正确表示我们的领域模型更好的结果。
- en: 'The `Configure` method also adds some additional constraints to the *one-to-many*
    relationship between the `Item` entity and the `Artist` and `Genre` entities:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure`方法还向`Item`实体与`Artist`实体和`Genre`实体之间的**一对多**关系添加了一些额外的约束：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This snippet specifies the relationships of the `Item` entity. Note that we
    follow a fluent approach. In this specific case, we are defining a 1-N relationship
    between the `Item` class and the `Artist` and `Genre` classes, by specifying `GenreId`
    and `ArtistId` as the foreign keys.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段指定了`Item`实体的关系。请注意，我们遵循了Fluent方法。在这种情况下，我们通过指定`GenreId`和`ArtistId`作为外键，在`Item`类和`Artist`类以及`Genre`类之间定义了一个1-N关系。
- en: Custom conversions using the Fluent API
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fluent API进行自定义转换。
- en: 'EF Core also provides a way to add custom conversions*.* This approach may
    be useful for providing a custom representation of complex entities. As an example,
    let''s take the following snippet of code declared in `ItemEntitySchemaDefinition`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core还提供了一种添加自定义转换的方法。这种方法可能对于提供复杂实体的自定义表示很有用。例如，让我们看看在`ItemEntitySchemaDefinition`中声明的以下代码片段：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `HasConversion` method offers a way to customize data inserted into the
    database. This method serializes the `Price` field, which is of the `Price` type,
    into a string by using the following format: `34.05:EUR`. On the other hand, when
    the `Price` data is read from the database, the string is deserialized into the
    `Price` type.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasConversion`方法提供了一种自定义数据库中插入数据的方式。此方法通过以下格式将`Price`字段（`Price`类型）序列化为字符串：`34.05:EUR`。另一方面，当从数据库中读取`Price`数据时，字符串被反序列化为`Price`类型。'
- en: Applying the schema definition on the current data context
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前数据上下文中应用架构定义
- en: 'To utilize the schema implemented in the `ItemEntitySchemaDefinition` class,
    we should apply it in the `OnModelCreating` method contained in the `CatalogContext`
    class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用`ItemEntitySchemaDefinition`类中实现的架构，我们应该将其应用于`CatalogContext`类中包含的`OnModelCreating`方法：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code uses the `ApplyConfiguration` extension method to apply configurations
    to the SQL schema during the runtime execution. It is important to note that the
    `OnModelCreating` method implemented in the class always calls the `base.OnModelCreating`
    method of the parent class, in order to preserve the behavior of the extended
    class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`ApplyConfiguration`扩展方法在运行时执行期间将配置应用到SQL架构。需要注意的是，类中实现的`OnModelCreating`方法始终调用父类的`base.OnModelCreating`方法，以保留扩展类的行为。
- en: Generating a schema for the Artist and Genre entities
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为艺术家和流派实体生成架构
- en: 'The preceding process can also be applied to the `Artist` and `Genre` entities.
    The following code shows the definitions of the two entities in the `Catalog.Domain.Entities`
    namespace:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程也可以应用于`Artist`和`Genre`实体。以下代码显示了`Catalog.Domain.Entities`命名空间中两个实体的定义：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Consequently, we can add two files to the `Catalog.Infrastructure` project
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将两个文件添加到`Catalog.Infrastructure`项目中，如下所示：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `GenreEntitySchemaConfiguration.cs` file looks as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenreEntitySchemaConfiguration.cs`文件如下所示：'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Both `GenreEntitySchemaConfiguration` and `ArtistEntitySchemaConfiguration`
    define the keys for our tables using the `HasKey` method. As we have already discussed,
    they use the same fluent approach applied to the `ItemEntitySchemaConfiguration`
    class defined previously. Also, we need to include `GenreEntitySchemaConfiguration`
    and `ArtistEntitySchemaConfiguration` in the `OnModelCreating` method of the `CatalogContext`
    class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenreEntitySchemaConfiguration`和`ArtistEntitySchemaConfiguration`都使用`HasKey`方法定义了我们表的主键。正如我们之前讨论的，它们使用了应用于先前定义的`ItemEntitySchemaConfiguration`类的相同流畅方法。此外，我们还需要将`GenreEntitySchemaConfiguration`和`ArtistEntitySchemaConfiguration`包含在`CatalogContext`类的`OnModelCreating`方法中：'
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I've omitted the full definition of the `CatalogContext` class for brevity.
    The significant change is the extension of the `OnModelCreating` method by applying
    the configuration for the `GenreEntitySchemaConfiguration` and `ArtistEntitySchemaConfiguration`
    classes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我省略了`CatalogContext`类的完整定义。显著的变化是扩展了`OnModelCreating`方法，通过应用`GenreEntitySchemaConfiguration`和`ArtistEntitySchemaConfiguration`类的配置。
- en: Executing migrations
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行迁移
- en: 'The last step in implementing data access using EF Core is to connect a `DbContext`
    instance to the database and run the migrations using the command exposed by the
    .NET CLI. Before doing that, we need to have a working database in our local environment.
    To keep our local development environment as lightweight as possible, this example
    will use a Docker image of Microsoft SQL Server on Linux. It is possible to get
    the Docker image here: [https://hub.docker.com/r/microsoft/mssql-server-linux/](https://hub.docker.com/r/microsoft/mssql-server-linux/).
    If you don''t have any previous experience with Docker, you can follow this guide
    to install and set it up on your local machine: [https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EF Core实现数据访问的最后一个步骤是将`DbContext`实例连接到数据库，并使用.NET CLI公开的命令运行迁移。在这样做之前，我们需要在我们的本地环境中有一个可工作的数据库。为了使我们的本地开发环境尽可能轻量，此示例将使用Linux上的Microsoft
    SQL Server Docker镜像。您可以从这里获取Docker镜像：[https://hub.docker.com/r/microsoft/mssql-server-linux/](https://hub.docker.com/r/microsoft/mssql-server-linux/)。如果您没有任何Docker的先前经验，可以遵循此指南在您的本地机器上安装和设置它：[https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-2017)。
- en: Containers are an excellent way to quickly set up your local environment without
    the need to configure a lot of different tools and systems. Nowadays, Microsoft
    is investing a lot in simplifying their systems and processes, both for developers
    and cloud systems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是快速设置本地环境的一种极好方式，无需配置大量不同的工具和系统。如今，微软在简化他们的系统和流程方面投入了大量资金，无论是针对开发者还是云系统。
- en: 'After running our SQL instance, let''s create a new database called `Store`*,*
    by running the following commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的 SQL 实例后，让我们通过以下命令创建一个名为 `Store` 的新数据库：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A valid alternative to the CLI is to use a SQL editor. One recommended tool
    is the `mssql` extension for VS Code: [https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017).
    Otherwise, you can download this cross-platform SQL editor based on VS Code: [https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 的一个有效替代方案是使用 SQL 编辑器。一个推荐的工具是 VS Code 的 `mssql` 扩展：[https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-develop-use-vscode?view=sql-server-2017)。否则，您可以下载基于
    VS Code 的跨平台 SQL 编辑器：[https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/azure-data-studio/download?view=sql-server-2017)。
- en: Once we get Microsoft SQL Server working in our local environment, we can proceed
    by connecting our service with the database. The `Startup` class already present
    in the `Catalog.API` project will define the connection string and the provider
    used by our service. As we will see, all the migration classes will also be stored
    in the same project. This kind of approach guarantees a unique entry point, `Catalog.API`,
    for our .NET CLI instructions, without being tightly coupled with the database
    logic (`Catalog.Infrastructure`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在本地环境中使 Microsoft SQL Server 运行起来，我们就可以通过将我们的服务与数据库连接来继续操作。`Catalog.API`
    项目中已经存在的 `Startup` 类将定义我们的服务使用的连接字符串和提供者。正如我们将看到的，所有迁移类也将存储在同一个项目中。这种方法保证了我们的
    .NET CLI 指令有一个唯一的入口点，即 `Catalog.API`，而不与数据库逻辑（`Catalog.Infrastructure`）紧密耦合。
- en: 'Before proceeding further, we need to add the `Catalog.Infrastructure` project
    as a reference for the API project by using the following command in the API project
    folder:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要在 API 项目文件夹中使用以下命令将 `Catalog.Infrastructure` 项目添加为 API 项目的引用：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The API project also requires you to refer to the `Microsoft.EntityFrameworkCore.Design`
    NuGet package, which shares design-time components for EF Core tools. We can add
    the latest version of the package by executing the following CLI instruction into
    the `Catalog.API` project folder:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: API 项目还要求您引用 `Microsoft.EntityFrameworkCore.Design` NuGet 包，该包共享 EF Core 工具的设计时组件。我们可以通过在
    `Catalog.API` 项目文件夹中执行以下 CLI 指令来添加包的最新版本：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, we can proceed by adding the database connection in the `Startup`
    class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在 `Startup` 类中添加数据库连接：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `ConfigureServices` method contains the initialization of the SQL connection.
    First of all, it adds the services required by the SQL provider using `AddEntityFameworkSqlServer`.
    Following that, it adds `CatalogContext`, utilizing the `AddContext<T>` generic
    method by passing an action method of the `Action<DbContextOptionsBuilder>` type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices` 方法包含了 SQL 连接的初始化。首先，它使用 `AddEntityFameworkSqlServer` 添加了
    SQL 提供者所需的服务。随后，它添加了 `CatalogContext`，通过传递 `Action<DbContextOptionsBuilder>` 类型的动作方法来利用
    `AddContext<T>` 泛型方法。'
- en: Finally, the action method configures the SQL Server provider by using the `UseSqlServer`
    extension method and passing the connection string for our database. The `MigrationsAssembly`
    method defines where the assemblies should be stored. In this case, it specifies
    that all migrations will be stored in our `Catalog.API` project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，动作方法通过使用 `UseSqlServer` 扩展方法和传递数据库的连接字符串来配置 SQL Server 提供者。`MigrationsAssembly`
    方法定义了组件应该存储的位置。在这种情况下，它指定所有迁移都将存储在我们的 `Catalog.API` 项目中。
- en: 'To keep our `Startup` class clean and readable, we may create a custom extension
    method to initialize the connection to the `Catalog` database. Let''s create a
    new folder called `Extensions` in our `Catalog.API` project*,* add a new `DatabaseExtension`
    class, and move our code into a new `AddCatalogContext` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`Startup`类保持整洁和可读，我们可能需要创建一个自定义扩展方法来初始化对`Catalog`数据库的连接。让我们在`Catalog.API`项目中创建一个新的文件夹名为`Extensions`，添加一个新的`DatabaseExtension`类，并将我们的代码移动到一个新的`AddCatalogContext`方法中：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can simplify the `Startup` class as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化`Startup`类如下：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that the `Startup` class is ready, execute `migrations` in the `Catalog.API`
    project folder using the following commands:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Startup`类已经准备好了，请在`Catalog.API`项目文件夹中使用以下命令执行`migrations`：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first command generates the `Migration` folder and two different files
    inside it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令生成了`Migration`文件夹以及其中的两个不同文件：
- en: '`{timestamp}_InitMigration.cs`: This class creates the tables, constraints,
    and indexes present in the database.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{timestamp}_InitMigration.cs`：此类创建了数据库中存在的表、约束和索引。'
- en: '`CatalogContextModelSnapshot.cs`: This is formed only on the first migration
    command and represents the current state of the entities of the service.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CatalogContextModelSnapshot.cs`：这个文件仅在第一次迁移命令中生成，并代表服务中实体的当前状态。'
- en: 'Every migration class, including the one we just generated, has the following
    structure:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个迁移类，包括我们刚刚生成的类，都具有以下结构：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The class contains two methods: `Up` and `Down`. The `Up` method is called
    during the generation of the database schema. The `Down` method is called during
    the deletion of the schema.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含两个方法：`Up`和`Down`。`Up`方法在生成数据库模式时被调用。`Down`方法在删除模式时被调用。
- en: 'The generated tables and SQL entities are created under the `catalog` schema.
    The `dotnet ef` CLI tool will create a new migration class each time we execute
    the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的表和SQL实体位于`catalog`模式之下。每次我们执行以下命令时，`dotnet ef` CLI工具都会创建一个新的迁移类：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The schema of the database will be refreshed every time we run the EF Core
    update process Core inside our project folder. Therefore, we can proceed by executing
    the following CLI command in the `Catalog.API` project folder:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们在项目文件夹中运行EF Core更新过程时，数据库的模式都会被刷新。因此，我们可以在`Catalog.API`项目文件夹中执行以下CLI命令：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding command creates the SQL schema using the migrations stored in
    the `Migration` folder of the project: it will connect to the database specified
    in the connection string, which is stored in the `AddCatalogContext()` extension
    method. In the next section, we will examine how to move the specified connection
    string into the `appsettings.json` file.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令使用存储在项目`Migration`文件夹中的迁移创建了SQL模式：它将连接到`AddCatalogContext()`扩展方法中指定的数据库。在下一节中，我们将探讨如何将指定的连接字符串移动到`appsettings.json`文件中。
- en: Defining the configuration part
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义配置部分
- en: 'As discussed in [Chapter 2](6127f023-703b-42e3-a76e-b70a7b110b90.xhtml), *Overview
    of ASP.NET Core*, the `appsettings.json` file usually contains the application
    settings. The connection strings are typically stored in that file. Therefore,
    that kind of approach makes our service more reusable and configurable, especially
    when it is already running in a staging or production environment. Let''s move
    the connection string from the `AddCatalogContext` method to the `appsettings.json`
    file in the following way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](6127f023-703b-42e3-a76e-b70a7b110b90.xhtml)“ASP.NET Core概述”中所述，`appsettings.json`文件通常包含应用程序设置。连接字符串通常存储在该文件中。因此，这种做法使我们的服务更具可重用性和可配置性，尤其是在它已经在预发布或生产环境中运行时。让我们以下述方式将连接字符串从`AddCatalogContext`方法移动到`appsettings.json`文件中：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this way, we can read the connection string and pass it to `AddCatalogContext`
    as a parameter using the following syntax:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用以下语法读取连接字符串并将其作为参数传递给`AddCatalogContext`：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Therefore, we need to change the signature of the `AddCatalogContext` extension
    method by adding a `connectionString` parameter as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要通过添加一个`connectionString`参数来更改`AddCatalogContext`扩展方法的签名，如下所示：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can pass the newly defined `connectionString` parameter to the `UseSqlServer`
    extension method. In the next section, we will go on to test the repository logic
    implemented in this section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将新定义的`connectionString`参数传递给`UseSqlServer`扩展方法。在下一节中，我们将继续测试本节中实现的仓库逻辑。
- en: Testing the EF Core repository
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试EF Core仓库
- en: 'This section covers some common testing practices used to test .NET Core applications.
    More specifically, it focuses on testing the repository part of the application.
    First of all, let''s create a new test project by executing the following commands
    in the root folder of the project (the same folder as the `.sln` file):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了用于测试.NET Core应用程序的一些常见测试实践。更具体地说，它侧重于测试应用程序的存储库部分。首先，让我们在项目根目录（与`.sln`文件相同的文件夹）中执行以下命令来创建一个新的测试项目：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As a result, we have created a new `tests` directory, which will contain all
    the test projects of the service. We also created a new `Catalog.Infrastructure.Tests`
    project using the `xunit` template.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个新的`tests`目录，它将包含服务中所有的测试项目。我们还使用`xunit`模板创建了一个新的`Catalog.Infrastructure.Tests`项目。
- en: '`xunit` is a very popular test framework in the .NET ecosystem, and it is the
    default choice for testing in .NET Core framework templates. Because we created
    our project using the `xunit` template, the `Catalog.Infrastructure.Tests.csproj`
    file will contain references to the `xunit` packages:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`xunit`是.NET生态系统中的一个非常流行的测试框架，并且是.NET Core框架模板中的默认选择。由于我们使用`xunit`模板创建了项目，因此`Catalog.Infrastructure.Tests.csproj`文件将包含对`xunit`包的引用：'
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These packages allow us to run unit tests by using the `dotnet test` CLI instruction
    in the test project folder at the solution level, or by using test runner tools
    integrated into our preferred IDE, such as Visual Studio or Rider.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包允许我们通过在解决方案级别的测试项目文件夹中使用`dotnet test` CLI指令或在我们的首选IDE（如Visual Studio或Rider）中集成的测试运行器工具来运行单元测试。
- en: Seeding data using DbContext
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DbContext进行数据种子
- en: Let's continue by looking at another EF Core feature, which allows us to seed
    data. The seeding data technique facilitates testing environments to get a **default**
    snapshot of our integration test database.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨另一个EF Core功能，它允许我们进行数据种子。数据种子技术简化了测试环境，以便获取集成测试数据库的**默认**快照。
- en: 'Let''s walk through an example of database seeding using .NET Core. First of
    all, let''s create a new `Data` folder and add the JSON files that contain the
    test records. For brevity, I''ve included both the `artist.json` file and the
    `genre.json` file in the same snippet of code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个.NET Core数据库种子示例来了解。首先，让我们创建一个新的`Data`文件夹，并添加包含测试记录的JSON文件。为了简洁，我在同一代码片段中包含了`artist.json`文件和`genre.json`文件。
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The aforementioned files contain data related to the `Genre` and `Artist` entities.
    In the same way, we can proceed by creating a new `item.json` file containing
    information about the `Item` entity:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件包含与`Genre`和`Artist`实体相关的数据。同样地，我们可以通过创建一个新的`item.json`文件来包含关于`Item`实体的信息：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These files hold some seed data to add to our database before each test. To
    read them, we need to include the `Newtonsoft.Json` package in the `Catalog.Infrastructure.Tests`
    project using the following command in the project folder:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件包含一些种子数据，需要在每次测试之前添加到我们的数据库中。为了读取它们，我们需要在`Catalog.Infrastructure.Tests`项目中包含`Newtonsoft.Json`包，使用以下命令在项目文件夹中执行：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We should also ensure that the JSON files are copied to the `bin` folder during
    the compilation step by adding the following code to `Catalog.Infrastructure.Tests.csproj`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该确保在编译步骤中将JSON文件复制到`bin`文件夹中，通过在`Catalog.Infrastructure.Tests.csproj`中添加以下代码来实现：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next step is to implement a method to read data from JSON and serialize
    it in our database context. Also, we should add the `Microsoft.EntityFrameworkCore`
    NuGet package to the test project using the following CLI command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现一个从JSON读取数据并将其序列化到我们的数据库上下文中的方法。我们还应该在测试项目中添加`Microsoft.EntityFrameworkCore`
    NuGet包，使用以下CLI命令：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The aforementioned package will provide the EF Core `ModelBuilder` type, which
    is used to generate the mock data used by our tests. Since we will use some of
    the code implemented in the `Catalog.Infrastructure` project, we should also add
    a reference to the test project using the following command in the root of the
    solution:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述包将提供EF Core的`ModelBuilder`类型，该类型用于生成我们测试中使用的模拟数据。由于我们将使用`Catalog.Infrastructure`项目中实现的一些代码，我们应在解决方案根目录下使用以下命令将测试项目添加到引用中：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After that, we can create a new extension method, named `Seed<T>`, inside a
    new `Extensions` folder in the `Catalog.Infrastructure.Tests` project:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在`Catalog.Infrastructure.Tests`项目中的新`Extensions`文件夹内创建一个新的扩展方法，命名为`Seed<T>`。
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: EF Core 2.1 has introduced a new way to perform data seeding in our database
    by exposing the `HasData<T>` method. The preceding code allows us to read a JSON
    file and serialize it into entities referred by `modelBuilder`. This approach
    provides a way to seed our mock database using the data written in the JSON files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 2.1 通过公开 `HasData<T>` 方法引入了一种在数据库中执行数据播种的新方法。前面的代码允许我们读取 JSON 文件并将其序列化为由
    `modelBuilder` 引用的实体。这种方法提供了一种使用 JSON 文件中写入的数据对模拟数据库进行播种的方法。
- en: 'Finally, we can proceed by creating a new context in the `Catalog.Infrastructure.Tests`
    project named `TestCatalogContext`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `Catalog.Infrastructure.Tests` 项目中创建一个新的上下文，命名为 `TestCatalogContext`：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, `TestCatalogContext` class extends the `CatalogContext` class present
    in the `Catalog.Infrastructure` project, and overrides the `OnModelCreating` method
    to call the `Seed<T>` extension method on our entities. Consequently, when a consumer
    initializes the database using `TestCatalogContext`, it will have all the prepopulated
    data written in the JSON.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TestCatalogContext` 类扩展了位于 `Catalog.Infrastructure` 项目的 `CatalogContext`
    类，并重写了 `OnModelCreating` 方法以在实体上调用 `Seed<T>` 扩展方法。因此，当消费者使用 `TestCatalogContext`
    初始化数据库时，它将具有在 JSON 中编写的所有预填充数据。
- en: Note here that the `TestCatalogContext` extends the `DbContextOptions<CatalogContext>`
    option in the constructor in order to initialize the `CatalogContext` base class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，`TestCatalogContext` 在构造函数中扩展了 `DbContextOptions<CatalogContext>` 选项，以便初始化
    `CatalogContext` 基类。
- en: Initializing the testing class
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化测试类
- en: 'Let''s proceed by creating a new testing class in our `Catalog.Infrastructure.Tests`
    project called `ItemRepositoryTests`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Catalog.Infrastructure.Tests` 项目中创建一个新的测试类，命名为 `ItemRepositoryTests`：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `Xunit` framework identifies test classes using the `Fact` attribute. Every
    class that contains a method that has the `Fact` attribute or, as we'll see later
    in this section, the `Theory` attribute, will be considered as a test by the unit
    test runner.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xunit` 框架使用 `Fact` 属性识别测试类。每个包含具有 `Fact` 属性的方法或，如本节稍后所示，具有 `Theory` 属性的类的类都将被视为测试，由单元测试运行器执行。'
- en: 'Let''s continue by adding our first test method. This checks the `GetAsync`
    method of the `ItemRepository` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加我们的第一个测试方法。这个方法检查 `ItemRepository` 类的 `GetAsync` 方法：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This code initializes a new `Options` object using `DbContextOptionsBuilder<T>`,
    which is of the `CatalogContext` type. It also uses the `UseInMemoryDatabase`
    extension method to create a new in-memory database instance with a given name.
    Since `DbContext` is extended by the `CatalogContext` class, which implements
    the `IAsyncDisposable` type, it is possible to use the `await using var` keywords.
    This approach avoids any type of nesting and provides a cleaner way of reading
    code, by avoiding the any use of nesting:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 `DbContextOptionsBuilder<T>` 初始化一个新的 `Options` 对象，其类型为 `CatalogContext`。它还使用
    `UseInMemoryDatabase` 扩展方法创建一个新的具有给定名称的内存数据库实例。由于 `DbContext` 由实现 `IAsyncDisposable`
    类型的 `CatalogContext` 类扩展，因此可以使用 `await using var` 关键字。这种方法避免了任何类型的嵌套，并通过避免使用嵌套来提供更清晰的代码阅读方式：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To build the code, it is necessary to add the following package to the `Catalog.Infrastructure.Tests`
    project:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建代码，需要在 `Catalog.Infrastructure.Tests` 项目中添加以下包：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `UseInMemoryDatabase` extension method is useful for configuring a new
    in-memory database instance. It is important to note that it is not designed to
    be a relational database. Furthermore, it doesn''t perform any database integrity
    checks or constraint checks. For more appropriate testing, we should use the in-memory
    version of SQLite. You can find more information about the SQLite provider in
    the following documentation: [https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseInMemoryDatabase` 扩展方法对于配置新的内存数据库实例很有用。需要注意的是，它不是设计为关系型数据库。此外，它不执行任何数据库完整性检查或约束检查。为了更合适的测试，我们应该使用
    SQLite 的内存版本。您可以在以下文档中找到有关 SQLite 提供程序的更多信息：[https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/sqlite)。'
- en: After the creation of a new `Options` object, the `should_get_data` method creates
    a new instance of `TestCatalogContext`, and calls the `EnsureCreated()` method,
    which ensures that the context exists in the in-memory database. The `EnsureCreate`
    method also implicitly calls the `OnModelCreating` method. After that, the test
    initializes a new `ItemRepository` by using the context and executes the `GetAsync`
    method. Finally, it checks the result using `result.ShouldNotBeNull()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的 `Options` 对象之后，`should_get_data` 方法创建了一个新的 `TestCatalogContext` 实例，并调用了
    `EnsureCreated()` 方法，该方法确保上下文存在于内存数据库中。`EnsureCreate` 方法还隐式地调用了 `OnModelCreating`
    方法。之后，测试通过上下文初始化了一个新的 `ItemRepository`，并执行了 `GetAsync` 方法。最后，它使用 `result.ShouldNotBeNull()`
    检查结果。
- en: 'Note that all test examples in this book use `Shouldly` as an assertion framework.
    `Shouldly` focuses on giving error messages that are concise and straightforward
    when an assertion fails. It is possible to avoid the use of `Shouldly` by using
    the default assertion framework built-in to .NET Core. You can find more information
    about `Shouldly` from the following link: [https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly).
    It is possible to add the `Shouldly` package executing the following CLI instruction
    in the `Catalog.Infrastructure.Tests` project: `dotnet add package Shouldly`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本书中的所有测试示例都使用了 `Shouldly` 作为断言框架。`Shouldly` 专注于在断言失败时提供简洁明了的错误信息。可以通过使用 .NET
    Core 内置的默认断言框架来避免使用 `Shouldly`。有关 `Shouldly` 的更多信息，请参阅以下链接：[https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)。您可以在
    `Catalog.Infrastructure.Tests` 项目中执行以下 CLI 指令来添加 `Shouldly` 包：`dotnet add package
    Shouldly`。
- en: 'Let''s continue by implementing tests for all the methods implemented in the
    `ItemRepository` class:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现 `ItemRepository` 类中所有方法的测试：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding snippet defines tests that cover the `GetAsync` methods. The
    first method, `should_get_data`, tests the `GetAsync()` overload with no parameters,
    while the second method tests the `GetAsync(guid id)` overload. In both cases,
    we use `InMemoryDatabase` to emulate the underlying data source. In the same `ItemRepositoryTests`
    class, it is also possible to define test cases related to create/update actions:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段定义了覆盖 `GetAsync` 方法的测试。第一个方法 `should_get_data` 测试了没有参数的 `GetAsync()`
    重载，而第二个方法测试了 `GetAsync(guid id)` 重载。在这两种情况下，我们使用 `InMemoryDatabase` 来模拟底层数据源。在同一个
    `ItemRepositoryTests` 类中，也可以定义与创建/更新操作相关的测试用例：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, the `ItemRepositoryTests` class provides test coverage for all CRUD
    methods implemented by the `ItemRepository` class. The `should_get_data`, `should_returns_null_with_id_not_present`,
    and `should_return_record_by_id` methods execute the `GetAsync` method and check
    whether the result is what we expect. The `should_add_new_item` and `should_update_item`
    test cases provide test coverage for the `ItemRepository.Add` and `ItemRepository.Update`
    methods. Both the tests initialize a new record of type `Item` and they update
    the database through the methods exposed by the `ItemRepository` type.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ItemRepositoryTests` 类为 `ItemRepository` 类实现的全部 CRUD 方法提供了测试覆盖率。`should_get_data`、`should_returns_null_with_id_not_present`
    和 `should_return_record_by_id` 方法执行 `GetAsync` 方法并检查结果是否符合预期。`should_add_new_item`
    和 `should_update_item` 测试用例为 `ItemRepository.Add` 和 `ItemRepository.Update` 方法提供了测试覆盖率。这两个测试都初始化了一个新的
    `Item` 类型的记录，并通过 `ItemRepository` 类型公开的方法更新数据库。
- en: 'As a result, we can run our tests by executing the following command in the
    `Catalog.Infrastructure.Tests` folder:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在 `Catalog.Infrastructure.Tests` 文件夹中执行以下命令来运行我们的测试：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding command executes tests implemented in the project. Therefore,
    the result will be a report with a list of tests that have succeeded. As an alternative,
    we can also choose to run tests using the tests runner provided by the IDE. Now
    that we have completed the data access part using EF Core combined with the code-first
    approach, we can also take a quick look at Dapper, and how it can be useful by
    providing a more lighter way to access data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令执行了项目中实现的所有测试。因此，结果将是一个包含成功测试列表的报告。作为替代，我们也可以选择使用 IDE 提供的测试运行器来运行测试。现在我们已经使用
    EF Core 和代码优先方法完成了数据访问部分的实现，我们也可以快速了解一下 Dapper，以及它如何通过提供一种更轻量级的数据访问方式来发挥作用。
- en: Implementing a data access layer using Dapper
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dapper 实现数据访问层
- en: Another standard tool that provides a way to implement a data access layer is
    Dapper. We have already taken an overview of Dapper*,* butthis section will cover
    in more detail how to deal with this package and how to use it to implement a
    data access layer. The following process will be more SQL-heavy. We will also
    demonstrate how you can deal with some stored CRUD procedures.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提供实现数据访问层方法的标准化工具是Dapper。我们已经对Dapper进行了概述，但本节将更详细地介绍如何处理这个包以及如何使用它来实现数据访问层。以下过程将更加侧重于SQL。我们还将演示如何处理一些存储CRUD过程。
- en: Note that EF Core also provides a way to query data sources by using stored
    procedures. Moreover, it exposes methods such as `DbSet<TEntity>.FromSql()` or
    `DbContext.Database.ExecuteSqlCommand()`. So, why use Dapper? As mentioned previously,
    Dapper is a micro-ORM that is simple and faster than EF Core. EF is more of a
    multipurpose ORM, and it adds a discrete overhead on each operation performed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，EF Core还提供了一种通过存储过程查询数据源的方法。此外，它公开了`DbSet<TEntity>.FromSql()`或`DbContext.Database.ExecuteSqlCommand()`等方法。那么，为什么使用Dapper呢？如前所述，Dapper是一个简单且比EF
    Core更快的微型ORM。EF更像是一个多用途ORM，它在每个操作上都会增加一些额外的开销。
- en: 'Before starting, let''s create another project inside the `src` folder called
    `Catalog.InfrastructureSP`, by launching the following command inside the `src`
    folder:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们在`src`文件夹内创建另一个名为`Catalog.InfrastructureSP`的项目，通过在`src`文件夹内运行以下命令：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After creating the `Catalog.InfrastructureSP` project, we need to add it to
    our solution:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Catalog.InfrastructureSP`项目之后，我们需要将其添加到我们的解决方案中：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding command includes the `Catalog.InfrastructureSP` project in the
    solution. Once we have set up our new project containing all the alternative implementation
    of the data access layer, we can proceed by implementing the core part of the
    project using a SQL-first approach.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`Catalog.InfrastructureSP`项目包含到解决方案中。一旦我们设置了包含所有数据访问层替代实现的新项目，我们就可以通过使用SQL-first方法来实现项目的核心部分。
- en: Creating stored CRUD procedures
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储CRUD过程
- en: In the current example, we use some stored procedures that implement create*,*
    read*,* and update operations. In this book, we will not go into much detail about
    the SQL server programming model, but it is essential to understand that the code-first
    approach is not the only way to proceed. Stored procedures are an excellent way
    to implement interactions between services and a database.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，我们使用了一些实现创建、读取和更新操作的存储过程。在这本书中，我们不会深入探讨SQL服务器编程模型，但理解代码-first方法不是唯一的方法是至关重要的。存储过程是实现服务与数据库之间交互的一种优秀方式。
- en: Stored procedures are the best way to interact with databases. Developers can
    proceed by executing complex queries and calling the procedure name. This modular
    approach provides some benefits in terms of permission configuration, faster network
    traffic, and faster execution.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程是与数据库交互的最佳方式。开发者可以通过执行复杂查询并调用过程名称来继续操作。这种模块化方法在权限配置、更快的网络流量和更快的执行速度方面提供了一些好处。
- en: 'First of all, let''s create stored procedures to read data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建用于读取数据的存储过程：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first snippet of code defines the `GetAllItems` stored procedure. It returns
    the whole collection of items. For demonstration purposes, the procedure doesn''t
    include any performance optimization. When we perform a `select` query on a large
    table, with a lot of records, it is necessary, at least, to insert a top statement
    to avoid long-running queries and timeout problems. Moreover, in a real-world
    application, it is uncommon to see a query without a specific filter. Let''s continue
    by creating the `GetItemById` procedure:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一个片段定义了`GetAllItems`存储过程。它返回整个项目集合。出于演示目的，该过程不包括任何性能优化。当我们对一个包含大量记录的大表执行`select`查询时，至少需要插入一个top语句以避免长时间运行的查询和超时问题。此外，在现实世界的应用程序中，很少看到没有特定过滤器的查询。让我们继续创建`GetItemById`过程：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: These two procedures are quite simple. The first one selects all the records
    from the `catalog. Item` table. The second one accepts an `Id` as the parameter
    and allows us to retrieve just the corresponding record.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个过程相当简单。第一个过程从`catalog.Item`表中选取所有记录。第二个过程接受一个`Id`作为参数，并允许我们检索相应的记录。
- en: 'The next step is to implement operations to do with creating and updating a
    record. Both implementations are quite simple – the `InsertItem` and `UpdateItem`
    stored procedures wrap `insert` and `update` SQL statements:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现与创建和更新记录相关的操作。两种实现都非常简单——`InsertItem` 和 `UpdateItem` 存储过程封装了 `insert`
    和 `update` SQL 语句：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `InsertItem` stored procedure executes a simple `insert` statement on the
    database by accepting data as parameters of the stored procedure. Let''s proceed
    by defining the `UpdateItem` stored procedure:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertItem` 存储过程通过接受存储过程的参数来在数据库上执行简单的 `insert` 语句。让我们通过定义 `UpdateItem` 存储过程来继续：'
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that both operations use the `output` statement to retrieve the inserted,
    or updated, record as a result of the execution. In that way, we can retrieve
    the updated record from our repository pattern without extra effort.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个操作都使用 `output` 语句来检索执行结果中插入或更新的记录。这样，我们可以从我们的存储库模式中检索更新记录而无需额外努力。
- en: Microsoft SQL Server provides a way to return inserted or deleted data using
    the *output* operator. It returns information from, or expressions based on, each
    row affected by an `INSERT`, `UPDATE`, `DELETE`, or `MERGE` statement.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft SQL Server 提供了一种使用 *output* 操作符返回插入或删除数据的方法。它返回由 `INSERT`、`UPDATE`、`DELETE`
    或 `MERGE` 语句影响的每一行信息。
- en: Finally, to get these scripts working, it is necessary to execute them in our
    database. I suggest using the previously mentioned SQL Operations Studio tool
    or another SQL client to run these scripts in the `Catalog` database.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使这些脚本正常工作，必须在我们的数据库中执行它们。我建议使用之前提到的 SQL Operations Studio 工具或另一个 SQL 客户端来在
    `Catalog` 数据库中运行这些脚本。
- en: Implementing the IItemRepository interface
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 IItemRepository 接口
- en: 'In *Implementing the data access layer using EF Core* section, we used two
    different interfaces to get the jobs done: `IItemRepository`, which contains all
    the CRUD operations, and `IUnitOfWork`, which covers the unit of work pattern.
    For each CRUD operation, we need to call the `IUnitOfWork` interface to save our
    changes in the database. On the other hand, the application of Dapper as a micro-ORM
    doesn''t need to provide a unit of work interface because ORM executes queries
    directly on the database using the stored procedures. For that reason, we don''t
    need to implement the `IRepository` interface anymore and, consequently, we will
    not implement the `IUnitOfWork` interface either.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用 EF Core 实现数据访问层* 部分，我们使用了两个不同的接口来完成工作：`IItemRepository`，它包含所有 CRUD 操作，以及
    `IUnitOfWork`，它涵盖了工作单元模式。对于每个 CRUD 操作，我们需要调用 `IUnitOfWork` 接口来将我们的更改保存到数据库中。另一方面，作为微
    ORM 的 Dapper 应用不需要提供工作单元接口，因为 ORM 直接使用存储过程在数据库上执行查询。因此，我们不再需要实现 `IRepository`
    接口，相应地，我们也不再实现 `IUnitOfWork` 接口。
- en: 'So, as a first step, we should remove the `IRepository` interface implementation
    from our `IItemRepository` interface. Also, in this case, we can see the real
    power of dependency inversion: `Catalog.Domain` does not depend on `Catalog.Infrastructure`*.*
    It can also change the contract and requirements, and it forces `Catalog.Infrastructure`
    to alter its behavior:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为第一步，我们应该从我们的 `IItemRepository` 接口中移除 `IRepository` 接口的实现。此外，在这种情况下，我们可以看到依赖反转的真正力量：`Catalog.Domain`
    不依赖于 `Catalog.Infrastructure`*.* 它也可以更改合同和需求，并迫使 `Catalog.Infrastructure` 改变其行为：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The next step is to add Dapper to our `Catalog.InfrastructureSP` project by
    executing the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 Dapper 添加到我们的 `Catalog.InfrastructureSP` 项目中，通过执行以下命令：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s proceed by implementing the `IItemRepository` interface using the `ItemRepository`
    class in the `Catalog.InfrastructureSP` project:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 `Catalog.InfrastructureSP` 项目中使用 `ItemRepository` 类来实现 `IItemRepository`
    接口：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To initialize our concrete class, it is necessary to pass `connectionString`
    to the SQL database in the constructor of the `ItemRepository` class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化我们的具体类，必须在 `ItemRepository` 类的构造函数中将 `connectionString` 传递给 SQL 数据库。
- en: As you can see, the Dapper approach is entirely different from EF Core. It doesn't
    add any particular overhead to our data source; it merely executes the aforementioned
    stored procedures by filling the requested parameters.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Dapper 方法与 EF Core 完全不同。它不会给我们的数据源添加任何特定的开销；它只是通过填充请求的参数来执行上述存储过程。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter described you how to build a data access layer using EF Core and
    Dapper. It also showed you how to build unit tests using the in-memory database,
    and how to execute migrations with EF Core. I want to reiterate that the choice
    between EF Core and Dapper depends on different parameters: what kind of service
    we are building, the skills of our team members, and the type of infrastructure
    we''re using.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何使用EF Core和Dapper构建数据访问层。它还展示了如何使用内存数据库构建单元测试，以及如何使用EF Core执行迁移。我想重申，EF
    Core和Dapper之间的选择取决于不同的参数：我们正在构建的服务类型、团队成员的技能以及我们使用的类型基础设施。
- en: The topics covered in this chapter provide the necessary knowledge to access
    data sources in .NET Core, using a code-first approach and also the stored-procedure
    approach. The chapter covered the use of technologies such as EF Core and Dapper.
    Additionally, it showed you how to test the data access layer using the in-memory
    approach.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题提供了使用代码优先和存储过程方法访问.NET Core数据源所需的知识。本章介绍了EF Core和Dapper等技术的使用。此外，它还展示了如何使用内存方法测试数据访问层。
- en: In the next chapter, we will demonstrate how to implement handlers and the logic
    of our services.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将演示如何实现处理程序和我们的服务逻辑。
