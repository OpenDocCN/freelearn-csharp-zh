- en: '*Chapter 4*: Threading and Asynchronous Operations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：线程和异步操作'
- en: So far, we have looked at various design principles, patterns, what is new in
    .NET 6, and architecture guidelines that we are going to use during this book.
    In this chapter, we will see how we can take advantage of asynchronous programming
    while building enterprise applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了各种设计原则、模式、.NET 6的新特性以及我们将在这本书中使用的架构指南。在本章中，我们将看到如何在构建企业应用时利用异步编程。
- en: One of the key measures for any web application is *scalability* – that is,
    scaling to reduce the time taken to serve a request, increase the number of requests
    that a server can process, and increase the number of users an application can
    simultaneously serve without increasing the load time. For mobile/desktop apps,
    scaling can improve the responsiveness of the app, allowing users to perform various
    actions without freezing the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Web应用来说，关键指标之一是 *可伸缩性* —— 即通过扩展来减少处理请求所需的时间，增加服务器可以处理的请求数量，以及在不增加加载时间的情况下，应用程序可以同时服务的用户数量。对于移动/桌面应用，扩展可以提高应用的响应速度，使用户能够在不冻结屏幕的情况下执行各种操作。
- en: The proper use of asynchronous programming techniques and parallel constructs
    can do wonders in improving these metrics, and the best thing for this in C# is
    the simplified syntax of the **Task Parallel Library** (**TPL**), async-await,
    with which we can write clean asynchronous code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用异步编程技术和并行结构可以在提高这些指标方面产生奇迹，而在C#中，最好的方法是**任务并行库**（**TPL**）、async-await的简化语法，通过它可以编写干净的异步代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the jargon
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解术语
- en: Demystifying threads, lazy initialization, and `ThreadPool`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阐明线程、延迟初始化和 `ThreadPool`
- en: Understanding locks, semaphores, and `SemaphoreSlim`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解锁、信号量和 `SemaphoreSlim`
- en: Introducing tasks and parallels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍任务和并行
- en: Introducing async-await
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 async-await
- en: Using concurrent collections for parallelism
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发集合实现并行处理
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need a basic understanding of .NET Core, C#, and the basics of LINQ.
    The code examples for this chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解.NET Core、C#和LINQ的基础知识。本章的代码示例可以在此处找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter04)。
- en: 'A few instructions for the code can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有关代码的几个说明可以在此处找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application)。
- en: Understanding the jargon
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解术语
- en: Before we dive into the technicalities of threading and asynchronous operations,
    let's take a real-world example and build an analogy between multitasking in real
    life and parallel programming. Imagine that you are waiting in a queue in a restaurant
    to order food, and while waiting in the queue, you reply to an email. Then, having
    ordered the food and while waiting for it to arrive, you answered a phone call.
    In the restaurant, there are multiple counters where orders are being taken, and
    food is prepared by the chef while orders are being placed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨线程和异步操作的技术细节之前，让我们用一个现实世界的例子来构建一个类比，将现实生活中的多任务处理与并行编程联系起来。想象一下，你在餐厅排队等待点餐，在排队等待的时候回复了一封电子邮件。然后，在点餐后等待食物送达的时候，你接了一个电话。在餐厅里，有多个柜台在接收订单，厨师在订单被接收的同时准备食物。
- en: While you were waiting in line, you concurrently replied to an email. Similarly,
    while you were ordering, the restaurant was parallelly taking orders at many other
    counters. The chef is cooking parallelly while orders are being placed. Also,
    you were given a token to pick up your food from the pickup counter; however,
    depending upon the preparation time of your food, an order placed after yours
    may arrive at the pickup counter before yours.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在排队等待时，你并发地回复了电子邮件。同样，当你下单时，餐厅在许多其他柜台并行地接收订单。厨师在接收订单的同时并行地烹饪。此外，你被给了个凭证去取餐柜台；然而，根据你食物的准备时间，在你之后的订单可能会在你之前到达取餐柜台。
- en: 'When talking about parallel programming, some key terms will appear multiple
    times. This jargon is represented in the following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到并行编程时，一些关键术语会多次出现。这些术语在以下图中表示：
- en: '![Figure 4.1 – Concurrency versus parallelism versus asynchronous'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – 并发与并行与异步'
- en: '](img/Figure_4.1_B18507.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1_B18507.jpg](img/Figure_4.1_B18507.jpg)'
- en: Figure 4.1 – Concurrency versus parallelism versus asynchronous
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.1 – 并发与并行与异步
- en: 'Let''s cover each term:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一解释每个术语：
- en: '**Parallelism**: This entails multiple tasks being performed independently
    at the same time, as in the example of multiple restaurant orders being placed
    from different counters. In terms of enterprise applications, parallelism would
    be multiple threads/tasks being executed at the same time in a multicore CPU.
    However, a single-core CPU also supports parallelism through hyper-threading,
    which usually involves the logical division of a single core into more than one
    core, such as a hyper-threading-enabled dual-core CPU, which acts like a quad-core
    – that is, four cores.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性**：这涉及到同时独立执行多个任务，例如在多个餐厅柜台同时下单的例子中。在企业应用中，并行性意味着在多核 CPU 中同时执行多个线程/任务。然而，单核
    CPU 也通过超线程支持并行性，这通常涉及将单个核心逻辑上划分为多个核心，例如启用超线程的双核 CPU，它表现得像一个四核——也就是说，四个核心。'
- en: '**Concurrency**: This entails doing many tasks at the same time, such as in
    our previous example of replying to an email while queuing for a restaurant counter,
    or the chef seasoning one dish and heating the pan for a second dish. In terms
    of enterprise applications, concurrency involves multiple threads sharing a core
    and, based on their time slicing, executing tasks and performing context switching.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**：这涉及到同时执行许多任务，例如在我们之前的例子中，在排队等待餐厅柜台的同时回复电子邮件，或者厨师为一道菜调味并加热另一道菜的锅。在企业应用中，并发性涉及多个线程共享一个核心，并且根据它们的时间片，执行任务和进行上下文切换。'
- en: '**Asynchronous**: Asynchronous programming is a technique that relies on executing
    tasks asynchronously instead of blocking the current thread while it is waiting.
    In our example, asynchronicity is waiting for your token to be called for you
    to go to the pickup counter while the chef is working on preparing your food.
    But while you''re waiting, you have moved away from the ordering counter, thereby
    allowing other orders to be placed. This is like a task that executes asynchronously
    and frees up resources while waiting on an I/O task (for instance, while waiting
    on data from a database call). The beauty of asynchronicity is that tasks are
    executed either parallelly or concurrently, which is completely abstracted from
    developers by the framework. This lets the developer focus their development efforts
    on the business logic of the application rather than on managing tasks. We will
    see this in the *Tasks and parallels* section.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步性**：异步编程是一种依赖于异步执行任务的技术，而不是在等待时阻塞当前线程。在我们的例子中，异步性是等待你的凭证被叫到你去取餐柜台，而厨师正在准备你的食物。但是当你等待的时候，你已经离开了点餐柜台，从而允许其他订单被下单。这就像一个异步执行的任务，在等待
    I/O 任务（例如，等待数据库调用的数据）时释放资源。异步性的美妙之处在于，任务要么并行执行，要么并发执行，这完全由框架抽象化，从开发者那里屏蔽了。这使得开发者可以将他们的开发努力集中在应用程序的业务逻辑上，而不是管理任务。我们将在“任务与并行”部分看到这一点。'
- en: '`CLR ThreadPool`. In a multicore/multiprocessor system, multithreading helps
    to achieve parallelism by executing newly created threads in different cores.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLR ThreadPool`。在多核/多处理器系统中，多线程有助于通过在不同的核心中执行新创建的线程来实现并行性。'
- en: Now that we understand the key terms in parallel programming, let's move on
    to look at how to create threads and the role of `ThreadPool` in .NET Core.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了并行编程中的关键术语，让我们继续探讨如何在 .NET Core 中创建线程以及 `ThreadPool` 的作用。
- en: Demystifying threads, lazy initialization, and ThreadPool
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除线程、懒加载初始化和ThreadPool的神秘感
- en: A thread is the smallest unit in an operating system, and it executes instructions
    in the processor. A process is a bigger executing container, and the thread inside
    the process is the smallest unit to use processor time and execute instructions.
    The key thing to remember is that whenever your code needs to be executed in a
    process, it should be assigned to a thread. Each processor can only execute one
    instruction at a time; that's why, in a single-core system, at any point time,
    only one thread is being executed. There are scheduling algorithms that are used
    to allocate processor time to a thread. A thread typically has a stack (which
    keeps track of execution history), registers in which to store various variables,
    and counters to hold instructions that need to be executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是操作系统中最小的单位，它在处理器中执行指令。进程是一个更大的执行容器，进程内的线程是使用处理器时间和执行指令的最小单位。要记住的关键点是，每当你的代码需要在进程中执行时，它应该被分配到一个线程上。每个处理器一次只能执行一条指令；这就是为什么在单核系统中，在任何时刻，只有一个线程正在执行。有一些调度算法用于将处理器时间分配给线程。线程通常有一个堆栈（用于跟踪执行历史），一些寄存器用于存储各种变量，以及计数器用于保存需要执行的指令。
- en: 'A quick look at **Task Manager** will give us details regarding the number
    of physical and logical cores, and navigating to **Resource Monitor** will tell
    us about the CPU usage in each core. The following figure shows the details of
    a hyper-threading-enabled quad-core CPU that can execute eight threads in parallel
    at any point in time:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看**任务管理器**将提供有关物理和逻辑核心数量的详细信息，导航到**资源监视器**将告诉我们每个核心的CPU使用情况。以下图显示了启用超线程的四核CPU的详细信息，该CPU在任何时刻可以并行执行八个线程：
- en: '![Figure 4.2 – Task Manager and Resource Monitor'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.2 – 任务管理器和资源监视器'
- en: '](img/Figure_4.2_B18507.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_4.2_B18507.jpg](img/Figure_4.2_B18507.jpg)'
- en: Figure 4.2 – Task Manager and Resource Monitor
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.2 – 任务管理器和资源监视器'
- en: A typical application in .NET Core has one single thread when it is started
    and can add more threads by manually creating them. A quick refresher on how this
    is done will be covered in the following sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的典型应用程序在启动时只有一个线程，可以通过手动创建来添加更多线程。以下几节将简要介绍如何进行此操作。
- en: Working with System.Threading.Thread
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用System.Threading.Thread
- en: 'We can create new threads by creating an instance of `System.Threading.Thread`
    and passing a method delegate. Here is a simple example that simulates retrieving
    data from an API and loading a file from a disk:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建`System.Threading.Thread`的实例并传递一个方法委托来创建新的线程。以下是一个简单的示例，模拟从API检索数据并从磁盘加载文件：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, `FetchDataFromAPI` and `LoadFileFromDisk` are the methods
    that would run on the new thread.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`FetchDataFromAPI`和`LoadFileFromDisk`是将在新线程上运行的方法。
- en: Tip
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: At any point in time, only one thread will be executing on each core – that
    is, only one thread is allotted CPU time. So, to achieve concurrency, the **Operating
    System** (**OS**) does a context switch when a thread that's been allocated CPU
    time is idle or if a high-priority thread arrives in the queue (there may be other
    reasons too, such as if a thread is waiting on a synchronization object or the
    allotted CPU time is reached).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，每个核心上只会有一个线程在执行——也就是说，只有一个线程被分配了CPU时间。因此，为了实现并发，当被分配CPU时间的线程空闲或队列中出现高优先级线程时（也可能有其他原因，例如线程正在等待同步对象或达到分配的CPU时间），操作系统会进行上下文切换。
- en: Since a thread that is switched out won't have completed its work, at some point,
    it will be assigned CPU time again. As such, the OS needs to save the state of
    the thread (its stack, its registers, and so on) and retrieve it again when the
    thread is allotted CPU time. Context switching is usually very expensive and one
    of the key areas of performance improvement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被切换出的线程尚未完成其工作，在某个时刻，它将再次被分配CPU时间。因此，操作系统需要保存线程的状态（其堆栈、寄存器等），并在线程被分配CPU时间时再次检索它。上下文切换通常非常昂贵，是性能改进的关键领域之一。
- en: All the properties and methods of the `Thread` class can be further reviewed
    at [https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-6.0).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-6.0)进一步查看`Thread`类的所有属性和方法。
- en: 'Although managing threads come with the advantage of having more control over
    how they are executed, it also comes with overheads in the form of the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管管理线程带来了对执行方式的更多控制优势，但也伴随着以下开销：
- en: Managing the life cycle of threads, such as creating threads, recycling them,
    and context switching.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理线程的生命周期，例如创建线程、回收它们和上下文切换。
- en: Implementing concepts such as progress tracking/reporting for thread execution.
    Also, cancellation is quite complex and has limited support.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现线程执行的进度跟踪/报告等概念。此外，取消操作相当复杂，并且支持有限。
- en: Exceptions on threads need to be handled appropriately; otherwise, they may
    lead to the application crashing.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要适当地处理线程上的异常；否则，它们可能导致应用程序崩溃。
- en: Debugging, testing, and code maintenance can become a bit complex and, at times,
    can lead to performance issues if not handled correctly.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试、测试和代码维护可能会变得有些复杂，并且如果不正确处理，有时会导致性能问题。
- en: This is where the `ThreadPool` comes into play, which is discussed in the next
    section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`ThreadPool`发挥作用的地方，将在下一节中进行讨论。
- en: ThreadPool
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadPool
- en: 'Threads can be created by making use of pools of threads managed by .NET Core,
    more commonly known as the CLR `ThreadPool`. The CLR `ThreadPool` is a set of
    worker threads that are loaded into your application along with the CLR and take
    care of the thread life cycle, including recycling threads, creating threads,
    and supporting better context switching. The CLR `ThreadPool` can be consumed
    by various APIs available in the `System.Threading.ThreadPool` class. Specifically,
    for scheduling an operation on a thread, there is the `QueueUserWorkItem` method,
    which takes a delegate of the method that needs to be scheduled. In the previous
    code, let''s replace the code for creating a new thread with the following code,
    meaning the application will use `ThreadPool`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用由.NET Core管理的线程池来创建线程，这更广为人知的是CLR `ThreadPool`。CLR `ThreadPool`是一组工作线程，它们与CLR一起加载到您的应用程序中，并负责线程生命周期，包括回收线程、创建线程和支持更好的上下文切换。`System.Threading.ThreadPool`类中的各种API可以消费CLR
    `ThreadPool`。具体来说，对于在某个线程上调度操作，有`QueueUserWorkItem`方法，它接受需要调度的方法的委托。在之前的代码中，让我们将创建新线程的代码替换为以下代码，这意味着应用程序将使用`ThreadPool`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the name suggests, `QueueUserWorkItem` of the `ThreadPool` class does make
    use of queues, whereby any code that is supposed to be executed on the `ThreadPool`
    thread would be queued and then dequeued – that is, assigned to a worker thread
    in a **First-In, First-Out** (**FIFO**) manner.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`ThreadPool`类的`QueueUserWorkItem`确实使用了队列，任何应该在`ThreadPool`线程上执行的计算代码都会被排队，然后出队——即以**先进先出**（**FIFO**）的方式分配给工作线程。
- en: 'The way `ThreadPool` is designed is that it has a global queue, and items are
    queued in it when we do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`的设计方式是它有一个全局队列，我们在执行以下操作时将项目排队到其中：'
- en: Call `QueueUserWorkItem` or a similar method of the `ThreadPool` class using
    a thread that is not part of the `ThreadPool` threads
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不属于`ThreadPool`线程的线程调用`QueueUserWorkItem`或`ThreadPool`类的类似方法
- en: Call through the TPL
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TPL进行调用
- en: When a new thread is created in `ThreadPool`, it maintains its own local queue
    that checks the global queue and dequeues the work item in a FIFO manner; however,
    if the code executing on this thread creates another thread, such as a child thread,
    then that gets queued in the local queue as opposed to the global queue.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`ThreadPool`中创建新线程时，它维护自己的本地队列，该队列检查全局队列并以FIFO（先进先出）的方式出队工作项；然而，如果在此线程上执行的代码创建了另一个线程，例如子线程，那么它将被排队到本地队列而不是全局队列。
- en: The order of execution for operations in the local queue of the worker thread
    is always `ThreadPool`, where *n* is the number of threads in `ThreadPool` – that
    is, *n* local queues – and *1* refers to the global queue.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程本地队列中操作的执行顺序始终是`ThreadPool`，其中*n*是`ThreadPool`中的线程数——即*n*个本地队列——而*1*指的是全局队列。
- en: 'A high-level representation of `ThreadPool` is shown in the following figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图中展示了`ThreadPool`的高级表示：
- en: '![Figure 4.3 – ThreadPool high-level representation'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.3 – ThreadPool high-level representation]'
- en: '](img/Figure_4.3_B18507.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.3_B18507.jpg]'
- en: Figure 4.3 – ThreadPool high-level representation
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – `ThreadPool`的高级表示
- en: 'Apart from `QueueUserWorkItem`, there are a lot of other properties/methods
    available for the `ThreadPool` class, such as these:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`QueueUserWorkItem`之外，`ThreadPool`类还有许多其他属性/方法可用，例如这些：
- en: '`SetMinThreads`: Used to set the minimum worker and asynchronous I/O threads
    that `ThreadPool` will have when the program is started'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetMinThreads`: 用于设置程序启动时`ThreadPool`将拥有的最小工作线程和异步I/O线程数'
- en: '`SetMaxThreads`: Used to set the maximum worker and asynchronous I/O threads
    that `ThreadPool` will have, after which, new requests are queued'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetMaxThreads`: 用于设置`ThreadPool`将拥有的最大工作线程和异步I/O线程数，之后，新的请求将被排队'
- en: All the properties and methods of the `ThreadPool` class can be further reviewed
    at [https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadpool?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadpool?view=net-6.0).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步查看`ThreadPool`类的所有属性和方法，请参阅[https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadpool?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadpool?view=net-6.0)。
- en: 'Although writing multithreaded code via `QueueUserWorkItem` of the `ThreadPool`
    thread simplifies life cycle management for threads, it has its own limitations:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过`ThreadPool`线程的`QueueUserWorkItem`编写多线程代码简化了线程的生命周期管理，但它也有自己的局限性：
- en: We cannot get a response from the work that is scheduled on the `ThreadPool`
    thread, hence the return type of the delegate is void.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法从在`ThreadPool`线程上安排的工作中获得响应，因此代理的返回类型是void。
- en: It is not easy to track the progress of the work that is scheduled on the `ThreadPool`
    thread, so something such as progress reporting isn't easy to achieve.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪在`ThreadPool`线程上安排的工作的进度并不容易，因此像进度报告这样的功能并不容易实现。
- en: It's not meant for long-running requests.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它并不适合长时间运行请求。
- en: '`ThreadPool` threads are always background threads; so, unlike foreground threads,
    if a process is shut down, it will not wait for the `ThreadPool` threads to complete
    their work.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPool`线程始终是后台线程；因此，与前台线程不同，如果进程关闭，它不会等待`ThreadPool`线程完成其工作。'
- en: As there are limitations with `QueueUserWorkItem`, the `ThreadPool` threads
    can also be consumed through the TPL, which we will use in our enterprise application
    and is covered later in this chapter. In .NET Core, the TPL is the preferred approach
    to achieve concurrency/parallelism, as it overcomes all the limitations we have
    seen so far and eventually helps to achieve the goal of allowing your application
    to scale and be responsive.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QueueUserWorkItem`存在局限性，`ThreadPool`线程也可以通过TPL（我们将用于我们的企业应用程序，并在本章后面介绍）来消耗。在.NET
    Core中，TPL是实现并发/并行化的首选方法，因为它克服了我们迄今为止看到的所有局限性，并最终有助于实现允许您的应用程序扩展和响应的目标。
- en: Lazy initialization
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: The lazy initialization of a class is a pattern where the creation of an object
    is deferred until it is used for the first time. This pattern is based on the
    premise that as long as a class's properties are not being used, there is no advantage
    to initializing an object. Hence, this delays object creation and ultimately reduces
    the memory footprint of the application, improving performance. An example of
    this would be creating a database connection object only when you are about to
    retrieve data from a database. Lazy initialization is a good fit for classes that
    hold a lot of data and are potentially expensive to create. For instance, a class
    for loading all the products in an e-commerce application can be lazily initialized
    only when there is a need to list the products.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类的懒加载是一种模式，其中对象的创建被推迟到第一次使用时。这种模式基于以下前提：只要类的属性没有被使用，初始化对象就没有优势。因此，这延迟了对象的创建，并最终减少了应用程序的内存占用，提高了性能。一个例子是在即将从数据库检索数据时创建数据库连接对象。懒加载非常适合持有大量数据且创建成本可能很高的类。例如，一个用于加载电子商务应用程序中所有产品的类可以在需要列出产品时进行懒加载。
- en: 'A typical implementation of such a class, as presented next, restricts the
    initialization of properties in constructors and has one or more methods that
    populate the properties of the class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，此类的一个典型实现限制了在构造函数中初始化属性，并且有一个或多个填充类属性的方法：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Assuming this is a class used to load an image from a disk, there is no use
    in loading the image in the constructor because it cannot be consumed until the
    `GetImage` method is called. So, the lazy initialization pattern suggests that
    instead of initializing the `loadImage` object in the constructor, it should be
    initialized in `GetImage`, which means that the image is loaded into memory only
    when it is needed. This can also be achieved through properties, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是一个用于从磁盘加载图像的类，在构造函数中加载图像是没有用的，因为只有在调用`GetImage`方法之前无法使用它。因此，懒初始化模式建议，而不是在构造函数中初始化`loadImage`对象，它应该在`GetImage`中初始化，这意味着图像只有在需要时才被加载到内存中。这也可以通过属性来实现，如下所示：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, this is something that's typically done with cache objects and
    is also known as the `LoadImage` method or property, it will lead to making a
    call to disk multiple times. So, there is a need for synchronization here through
    locks or some other mechanism, which obviously will add to the maintenance overhead,
    and the class implementation might become even more complex.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这通常是通过缓存对象来完成的，也被称为`LoadImage`方法或属性，它会导致多次调用磁盘。因此，这里需要通过锁或其他机制进行同步，这显然会增加维护开销，并且类的实现可能会变得更加复杂。
- en: So, even though we can implement our own lazy load pattern, in C#, we have the
    `System.Lazy` class to handle such an implementation. One of the key advantages
    of using the `System.Lazy` class is that it is thread-safe.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们可以实现自己的懒加载模式，但在C#中，我们有`System.Lazy`类来处理这种实现。使用`System.Lazy`类的一个关键优点是它是线程安全的。
- en: 'The `System.Lazy` class provides multiple constructors to implement lazy initialization.
    Here are the two most common ways that we can make use of:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Lazy`类提供了多个构造函数来实现懒初始化。以下是我们可以使用的两种最常见方式：'
- en: 'Wrapping the class around `Lazy` and using the `Value` method of that object
    to retrieve data. This is typically used for classes that have initialization
    logic in constructors. Some sample code follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类围绕`Lazy`包装，并使用该对象的`Value`方法来检索数据。这通常用于在构造函数中有初始化逻辑的类。以下是一些示例代码：
- en: '[PRE45]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'While initializing this class, we will use the generic type of the `System.Lazy`
    class and pass the `ImageFile` class as its type and the object of `ImageFile`
    as a delegate:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化这个类时，我们将使用`System.Lazy`类的泛型类型，并将`ImageFile`类作为其类型，以及`ImageFile`对象作为委托：
- en: '[PRE46]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, if you put a breakpoint in the `ImageFile` class's constructor, it would
    be hit only when the `Value` method of the `System.Lazy` class is called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果你在`ImageFile`类的构造函数中设置断点，它只有在调用`System.Lazy`类的`Value`方法时才会被触发。
- en: 'For classes that have a method to load various parameters, we can pass the
    method to the `Lazy` class as a delegate. Taking the previous sample code and
    moving the file-retrieving logic to a separate method is shown here:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有加载各种参数的方法的类，我们可以将方法传递给`Lazy`类作为委托。以下是将之前示例代码中的文件检索逻辑移动到单独方法的示例：
- en: '[PRE47]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And while initializing this class, we pass a Lambda to the generic delegate,
    and that generic delegate is passed to initialize an object of the `System.Lazy`
    class, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化这个类时，我们将一个Lambda传递给泛型委托，然后将该泛型委托传递给初始化`System.Lazy`类的对象，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A func in C# is a type of delegate that takes zero or more parameters and returns
    a value. More details can be found here: [https://docs.microsoft.com/en-us/dotnet/api/system.func-1?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.func-1?view=net-6.0).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的func是一种委托类型，它接受零个或多个参数并返回一个值。更多详细信息可以在这里找到：[https://docs.microsoft.com/en-us/dotnet/api/system.func-1?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.func-1?view=net-6.0)。
- en: Both ways will delay the initializing of the object until the call to the `Value`
    method is made.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式都会延迟对象的初始化，直到调用`Value`方法时。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One important thing that we need to note is that although `Lazy` objects are
    thread-safe, objects created through values aren't thread-safe. So, in this case,
    `lazyImage` is thread-safe, but `image` isn't. Hence, it needs to be synchronized
    in a multithreaded environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的一个重要事项是，尽管`Lazy`对象是线程安全的，但通过值创建的对象并不是线程安全的。因此，在这种情况下，`lazyImage`是线程安全的，但`image`不是。因此，在多线程环境中，它需要被同步。
- en: In general, lazy initialization is a good fit for caching classes and singleton
    classes and can be further extended for objects that are expensive to initialize.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，懒初始化非常适合缓存类和单例类，并且可以进一步扩展用于初始化成本高昂的对象。
- en: All the properties of the `Lazy` class can be further reviewed at [https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-6.0).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-6.0)进一步查看`Lazy`类的所有属性。
- en: Although lazy initialization can be achieved by wrapping the underlying object
    with the `System.Lazy` class, there is also the `LazyInitializer` static class
    available in .NET that can be used for lazy initialization through its `EnsureInitialized`
    method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过将底层对象包装在`System.Lazy`类中来实现懒加载，但在.NET中也有`LazyInitializer`静态类可用，可以通过其`EnsureInitialized`方法进行懒加载。
- en: It has a couple of constructors as mentioned in the MSDN documentation at [https://docs.microsoft.com/en-us/dotnet/api/system.threading.lazyinitializer.ensureinitialized?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.lazyinitializer.ensureinitialized?view=net-6.0).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如MSDN文档中提到的，它有几个构造函数[https://docs.microsoft.com/en-us/dotnet/api/system.threading.lazyinitializer.ensureinitialized?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.lazyinitializer.ensureinitialized?view=net-6.0)。
- en: 'However, the idea is the same, in that it expects an object and a function
    to populate the object. Taking the previous example, if we had to use `LazyInitializer.EnsureInitialized`
    for lazy initialization, we would need to pass the instance of the object and
    the Lambda that creates the actual object to `LazyInitializer.EnsureInitialized`,
    as shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其理念是相同的，即它期望一个对象和一个函数来填充该对象。以之前的例子来说，如果我们必须使用`LazyInitializer.EnsureInitialized`进行懒加载，我们需要将对象的实例和创建实际对象的Lambda表达式传递给`LazyInitializer.EnsureInitialized`，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we are passing two parameters – one is the object that holds the value
    of the property of the `image` class, and the other is the function that creates
    an object of the `image` class and returns the image. So, this is as simple as
    calling the `Value` property of the `System.Lazy` property without having the
    overhead of initializing the object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了两个参数——一个是持有`image`类属性值的对象，另一个是创建`image`类对象并返回图像的函数。因此，这就像调用`System.Lazy`属性的`Value`属性一样简单，而不需要初始化对象的额外开销。
- en: Clearly, a small added advantage of lazy initializing using `LazyInitializer`
    is that there aren't additional objects that aren't created, meaning a smaller
    memory footprint. On the other hand, `System.Lazy` provides much more readable
    code. So, if there are clear *space optimizations*, go with `LazyInitializer`;
    otherwise, use `System.Lazy` for much cleaner and more readable code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用`LazyInitializer`进行懒加载的一个小优势是，没有创建额外的对象，这意味着更小的内存占用。另一方面，`System.Lazy`提供了更易读的代码。因此，如果有明确的*空间优化*，请选择`LazyInitializer`；否则，为了获得更干净、更易读的代码，请使用`System.Lazy`。
- en: Understanding locks, semaphores, and SemaphoreSlim
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解锁、信号量和SemaphoreSlim
- en: In the previous sections, we saw how we can use various APIs in .NET to achieve
    parallelism. However, when we are doing that, we need to take additional care
    with shared variables. Let's take the enterprise e-commerce application that we
    are building in this book. Think about the workflow of purchasing an item. Say
    that two users are planning to buy a product and only one item is available. Let's
    say that both users add the item to the cart and the first user places their order,
    and while the order is being processed through the payment gateway, the second
    user also tries to place their order.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用.NET中的各种API来实现并行性。然而，当我们这样做时，我们需要对共享变量进行额外的注意。让我们考虑本书中构建的企业电子商务应用程序。想想购买商品的流程。比如说有两个用户计划购买一个产品，但只有一个商品可用。假设两个用户都将商品添加到购物车，第一个用户下订单，而订单正在通过支付网关处理时，第二个用户也尝试下订单。
- en: In such cases, the second order should fail (assuming that the first order succeeded)
    because the quantity for the book is now zero; that would happen only if there
    was proper synchronization being applied to the quantity across threads. Also,
    if the first order fails in the payment gateway or the first user cancels their
    transaction, the second order should go through. So, what we are saying here is
    that the quantity should be locked while the first order is being processed and
    should be released only when the order is completed (ending in success or failure).
    Before we get into the handling mechanism, let's quickly recap what the critical
    section is.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第二级应该失败（假设第一级成功），因为书的数量现在是零；这只会发生在对线程间的数量应用了适当的同步时。此外，如果第一级在支付网关失败或第一个用户取消他们的交易，第二级应该通过。所以，我们在这里说的是，数量应该在处理第一级时锁定，并且只有在订单完成后（成功或失败）才释放。在我们深入了解处理机制之前，让我们快速回顾一下什么是临界区。
- en: The critical section and thread safety
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临界区和线程安全
- en: The critical section is the part of an application that reads/writes variables
    that are used by multiple threads. We can think of these as the global variables
    that are used across the application and are modified in different places at different
    times or at the same time. In a multithreaded scenario, at any point in time,
    only one thread should be allowed to modify such variables, and only one thread
    should be allowed to enter the critical section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 临界区是应用程序中读取/写入由多个线程使用的变量的部分。我们可以把它们看作是跨应用程序使用的全局变量，在不同的地方或同一时间被修改。在多线程场景中，在任何给定时间点，只应允许一个线程修改这样的变量，并且只应允许一个线程进入临界区。
- en: 'If there are no such variables/sections in your application, it can be considered
    thread-safe. So, it''s always advisable to identify variables in the application
    that are not thread-safe and handle them accordingly. To protect access to the
    critical section from non-thread-safe variables, there are various constructs
    available, known as **synchronization primitives** or **synchronization constructs**,
    which primarily fall into two categories:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序中没有这样的变量/部分，它可以被认为是线程安全的。因此，始终建议识别应用程序中不是线程安全的变量，并相应地处理它们。为了保护临界区免受非线程安全变量的访问，有各种称为**同步原语**或**同步构造**的结构可用，它们主要分为两大类：
- en: '**Locking constructs**: These allow a thread to enter the critical section
    to protect access to the shared resources, and all other threads wait until the
    lock is freed by the acquired thread.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁定构造**：这些允许一个线程进入临界区以保护对共享资源的访问，其他所有线程都等待获取锁的线程释放锁。'
- en: '**Signaling constructs**: These allow a thread to enter the critical section
    by signaling the availability of resources, as in a producer-consumer model, where
    a producer locks a resource and the consumer waits for a signal rather than polling.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号构造**：这些允许一个线程通过信号资源可用性来进入临界区，例如在生产者-消费者模型中，生产者锁定资源，而消费者等待信号而不是轮询。'
- en: Let's discuss a few synchronization primitives in the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节讨论几个同步原语。
- en: Introducing locks
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍锁
- en: 'A **lock** is a basic class that allows you to achieve synchronization in multithreaded
    code where any variable inside the lock block can be accessed by only one thread.
    In locks, the thread acquiring the lock needs to release the lock, and until then,
    any other thread trying to enter the lock goes into a wait state. A simple lock
    can be created, as shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁**是一个基本类，它允许你在多线程代码中实现同步，其中锁块内的任何变量只能由一个线程访问。在锁中，获取锁的线程需要释放锁，直到那时，任何其他尝试进入锁的线程都将进入等待状态。一个简单的锁可以像以下代码所示那样创建：'
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The thread that is the first to execute this code will acquire the lock and
    release it after the completion of the code block. Locks can also be acquired
    using `Monitor.Enter` and `Monitor.Exit`, and in fact, using a lock compiler internally
    converts the thread to `Monitor.Enter` and `Monitor.Exit`. A few important points
    about locks follow:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行此代码的线程将获取锁，并在代码块完成后释放它。锁也可以使用`Monitor.Enter`和`Monitor.Exit`来获取，实际上，使用锁的编译器内部将线程转换为`Monitor.Enter`和`Monitor.Exit`。以下是一些关于锁的重要点：
- en: They should always be used on the reference type due to their thread affinity.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们的线程亲和性，它们应该始终用于引用类型。
- en: They are very expensive in terms of performance, as they pause the threads that
    want to enter the critical section before allowing them to resume, which adds
    some lag.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在性能上非常昂贵，因为它们在允许线程进入临界区之前会暂停想要进入的线程，这会增加一些延迟。
- en: Double-checking the acquiring lock is also a good practice, similar to how it
    is done in the singleton implementation.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取锁时进行双重检查也是一种良好的实践，类似于在单例实现中执行的方式。
- en: 'Locks do have some problems:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 锁确实存在一些问题：
- en: You need to lock the shared data/object wherever it's being modified or enumerated.
    It's easy to miss critical sections in the application as *critical section* is
    more of a logical term. Compilers will not flag it if there aren't any locks around
    a critical section.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在修改或枚举共享数据/对象的地方加锁。在应用程序中很容易错过临界区，因为**临界区**更是一个逻辑术语。编译器不会标记它，如果临界区周围没有锁的话。
- en: If not handled correctly, you might end up in a deadlock.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理不当，可能会导致死锁。
- en: Scalability is a problem, as only one thread can access a lock at a time, while
    all other threads must wait.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性是一个问题，因为一次只有一个线程可以访问锁，而其他所有线程必须等待。
- en: Note
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: There is another important concept known as **atomicity**. An operation is atomic
    only if there isn't any way to read the intermediate state of a variable or to
    write the intermediate state to a variable. For example, if an integer's value
    is being modified from two to six, any thread reading this integer value will
    only see two or six; none of the threads will see the thread's intermediate state
    where the integer was only partially updated. Any code that is thread-safe automatically
    guarantees atomicity.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个重要的概念称为**原子性**。一个操作只有在没有方法读取变量的中间状态或向变量写入中间状态的情况下才是原子的。例如，如果一个整数的值正在从二修改为六，那么任何读取这个整数值的线程只会看到二或六；没有任何线程会看到整数只部分更新的线程的中间状态。任何线程安全的代码自动保证原子性。
- en: Use concurrent collections, described in a later section, instead of locks,
    as concurrent collections internally handle locking critical sections.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用稍后章节中描述的并发集合，而不是锁，因为并发集合内部处理锁定临界区。
- en: Mutex (Windows only)
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥锁（仅限 Windows）
- en: 'A `System.Threading.Mutex` class, and any thread that wants to enter the critical
    section needs to call the `WaitOne` method. Releasing a mutex happens through
    the `ReleaseMutex` method; so, we basically create an instance of the `System.Threading.Mutex`
    class and call `WaitOne`/`ReleaseMutex` to enter/exit the critical section, respectively.
    A couple of important points about mutexes follow:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.Mutex` 类，任何想要进入临界区的线程都需要调用 `WaitOne` 方法。释放互斥锁通过 `ReleaseMutex`
    方法实现；因此，我们基本上创建一个 `System.Threading.Mutex` 类的实例，并分别调用 `WaitOne`/`ReleaseMutex`
    来进入/退出临界区。关于互斥锁的几个重要点如下：'
- en: Mutexes have thread affinity, so a thread that calls `WaitOne` needs to call
    `ReleaseMutex`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁具有线程亲和性，因此调用 `WaitOne` 的线程需要调用 `ReleaseMutex`。
- en: A constructor of the `System.Threading.Mutex` class is available that accepts
    the name of a mutex, which allows sharing across processes using the name passed
    to the constructor.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Mutex` 类有一个构造函数，它接受互斥锁的名称，这允许通过传递给构造函数的名称在进程间共享。'
- en: Introducing semaphores and SemaphoreSlim
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍信号量和 SemaphoreSlim
- en: A **semaphore** is a non-exclusive lock that supports synchronization by allowing
    multiple threads to enter a critical section. However, unlike exclusive locks,
    a semaphore is used in scenarios where there is a need to restrict access to a
    pool of resources – for example, a database connection pool that allows a fixed
    number of connections between an application and a database.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量**是一种非独占锁，它通过允许多个线程进入临界区来支持同步。然而，与独占锁不同，信号量用于需要限制对资源池访问的场景——例如，允许应用程序和数据库之间固定数量连接的数据库连接池。'
- en: Going back to our example of shopping for a product in an e-commerce application,
    if the available quantity of a product is 10, that means that 10 people can add
    this item to their shopping carts and place orders. If 11 orders are placed concurrently,
    10 users should be allowed to place orders, and the 11th should be put on hold
    until the first 10 orders are completed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们在电子商务应用程序中购买产品的例子，如果产品的可用数量是10，这意味着10个人可以将此商品添加到他们的购物车并下订单。如果有11个并发订单，应该允许10个用户下订单，而第11个用户应该被挂起，直到前10个订单完成。
- en: 'In .NET, a semaphore can be created by creating an instance of the `System.Threading.Semaphore`
    class and passing two parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，可以通过创建 `System.Threading.Semaphore` 类的实例并传递两个参数来创建信号量：
- en: The initial number of active requests
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活请求的初始数量
- en: The total number of concurrently allowed requests
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许并发请求的总数
- en: 'Here is a simple code snippet that creates a semaphore:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的代码片段，用于创建信号量：
- en: '[PRE60]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, `0` means none of the requests has acquired the shared resource
    and a maximum of 10 concurrent requests are allowed. To acquire a shared resource,
    we need to call `WaitOne()`, and to release a resource, we need to call the `Release()`
    method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`0` 表示没有请求获取共享资源，并且允许最多 10 个并发请求。要获取共享资源，我们需要调用 `WaitOne()`，要释放资源，我们需要调用
    `Release()` 方法。
- en: To create semaphores, there is another lightweight class available in .NET,
    and that is `SemaphoreSlim`, the slim version, which usually relies on a concept
    called `SemaphoreSlim` uses a small loop that runs for a few microseconds so that
    it doesn't have to go through the costly process of blocking, context switching,
    and internal kernel transition (semaphores use Windows kernel semaphores to lock
    a resource). Eventually, `SemaphoreSlim` falls back to locking if the shared resource
    still needs to be locked.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建信号量，.NET 中还有一个轻量级的类可用，那就是 `SemaphoreSlim`，这是精简版，它通常依赖于一个称为 `SemaphoreSlim`
    的概念，它使用一个运行几微秒的小循环，这样就不必经历阻塞、上下文切换和内部内核转换（信号量使用 Windows 内核信号量来锁定资源）的高成本过程。最终，如果共享资源仍然需要被锁定，`SemaphoreSlim`
    会回退到锁定。
- en: Creating a `SemaphoreSlim` instance is almost the same as for semaphores; the
    only difference is that for locking, it has `WaitAsync` instead of `WaitOne`.
    There is also `CurrentCount` available, which tells us the number of locks acquired.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `SemaphoreSlim` 实例几乎与信号量相同；唯一的区别是对于锁定，它有 `WaitAsync` 而不是 `WaitOne`。还有一个 `CurrentCount`
    可用，它告诉我们获取了多少个锁。
- en: 'Some key facts about semaphores and `SemaphoreSlim` follow:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于信号量和 `SemaphoreSlim` 的以下关键事实：
- en: As a semaphore is used to access a pool of resources, semaphores and `SemaphoreSlim`
    don't have thread affinity, and any thread can release a resource.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于信号量用于访问资源池，因此信号量和 `SemaphoreSlim` 没有线程亲和性，任何线程都可以释放资源。
- en: The `Semaphore` class in .NET Core supports named semaphores. Named semaphores
    can be used to lock resources across processes; however, the `SemaphoreSlim` class
    does not support named semaphores.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 中的 `Semaphore` 类支持命名信号量。命名信号量可以用于跨进程锁定资源；然而，`SemaphoreSlim` 类不支持命名信号量。
- en: The `SemaphoreSlim` class, unlike `Semaphore`, supports asynchronous methods
    and cancellation, which means it can be used well with async-await methods. The
    async-await keyword helps in writing non-blocking asynchronous methods and is
    covered in the *Introducing async-await* section in this chapter.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `Semaphore` 不同，`SemaphoreSlim` 类支持异步方法和取消，这意味着它可以很好地与 async-await 方法一起使用。async-await
    关键字有助于编写非阻塞的异步方法，并在本章的 *介绍 async-await* 部分中进行了介绍。
- en: Choosing the right synchronization constructs
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的同步构造
- en: 'There are other signaling constructs to cover; the following table gives you
    a high-level view of their usage and real-life examples of them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他信号构造需要覆盖；以下表格提供了它们的使用的高级视图以及它们的实际应用示例：
- en: '![Table 4.1 – A synchronization constructs comparison'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table_4.1 – 同步构造比较'
- en: '](img/Table_4.1_a.jpg)![Table 4.1 – A synchronization constructs comparison'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table_4.1_a.jpg]![Table_4.1 – 同步构造比较'
- en: '](img/Table_4.1_b.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table_4.1_b.jpg]'
- en: Table 4.1 – A synchronization constructs comparison
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 同步构造比较
- en: 'So far, we have covered the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了以下内容：
- en: Various ways of multithreading using the `Thread` and `ThreadPool` classes and
    their limitations
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Thread` 和 `ThreadPool` 类及其限制的多线程方式
- en: The importance of lazy initialization and how it helps in multithreaded environments
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒初始化的重要性以及它在多线程环境中的帮助
- en: The various synchronization constructs that are available in .NET
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 中可用的各种同步构造
- en: We will use these concepts in later chapters when we create some cross-cutting
    components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一些横切组件时，我们将在后面的章节中使用这些概念。
- en: In the next section, we will see how to overcome the limitations of `Thread`
    and `ThreadPool` through tasks and the use of the TPL.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何通过任务和 TPL 的使用来克服 `Thread` 和 `ThreadPool` 的限制。
- en: Introducing tasks and parallels
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍任务和并行
- en: We know that asynchronous programming helps our applications to scale and respond
    better, so implementing asynchronous applications should not be overhead for developers.
    `Thread` and `ThreadPool`, while helping to achieve asynchronicity, add a lot
    of overhead and come with limitations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道异步编程有助于我们的应用程序扩展并更好地响应，因此实现异步应用程序不应给开发者带来额外的开销。`Thread` 和 `ThreadPool` 虽然有助于实现异步性，但增加了许多开销，并带来了限制。
- en: Hence, Microsoft came up with tasks that make it easier to develop asynchronous
    applications. In fact, most of the newer APIs in .NET 6 only support the asynchronous
    way of programming – for example, the **Universal Windows Platform** (**UWP**)
    doesn't even expose APIs to create threads without tasks. As such, understanding
    tasks and the TPL is fundamental to being able to write asynchronous programs
    using C#.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Microsoft 提出了任务，这使得开发异步应用程序变得更加容易。事实上，.NET 6 中大多数新的 API 只支持异步编程方式——例如，**通用
    Windows 平台**（**UWP**）甚至没有提供创建线程的任务 API。因此，理解任务和 TPL 对于能够使用 C# 编写异步程序至关重要。
- en: We will dive deep into these topics in this section, and later, we will see
    how the C# async-await keywords combined with the TPL simplify asynchronous programming.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨这些主题，稍后我们将看到如何将 C# 的 async-await 关键字与 TPL 结合起来简化异步编程。
- en: Introduction to Task and the TPL
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Task 和 TPL 简介
- en: The idea behind asynchronous programming is that none of the threads should
    be waiting on an operation – that is, the framework should have the capability
    to wrap an operation into some abstraction and then resume once the operation
    is completed without blocking any threads. This abstraction is nothing but the
    `Task` class, which is exposed through `System.Threading.Tasks` and helps in writing
    asynchronous code in .NET.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程背后的思想是，没有任何线程应该等待一个操作——也就是说，框架应该具有将操作包装到某种抽象中的能力，然后在操作完成后恢复，而不阻塞任何线程。这种抽象就是
    `Task` 类，它通过 `System.Threading.Tasks` 暴露出来，并有助于在 .NET 中编写异步代码。
- en: 'The `Task` class simplifies wrapping any wait operation, whether it is data
    retrieved from a database, a file being loaded into memory from disk, or any highly
    CPU-intensive operation, and simplifies running it on a separate thread if needs
    be. It has the following important features:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类简化了任何等待操作的包装，无论是从数据库检索的数据、从磁盘加载到内存中的文件，还是任何高度CPU密集型操作，并且如果需要，它简化了在单独的线程上运行的操作。它具有以下重要特性：'
- en: '`Task` supports returning values from an operation once it is completed through
    its generic type, `Task<T>`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task` 通过其泛型类型 `Task<T>` 支持在操作完成后从操作中返回值。'
- en: '`Task` takes care of scheduling threads on `ThreadPool`, partitioning operations,
    and scheduling more than one thread from `ThreadPool` accordingly, all while abstracting
    the complexity of doing it.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task` 负责在 `ThreadPool` 上调度线程、划分操作，并相应地调度来自 `ThreadPool` 的多个线程，同时抽象出执行这些操作的复杂性。'
- en: Reports completion supports cancellation through `CancellationToken` and progress
    reporting through `IProgress`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成报告支持通过 `CancellationToken` 取消操作，并通过 `IProgress` 报告进度。
- en: '`Task` supports creating child tasks and manages relationships between child
    and parent tasks.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task` 支持创建子任务并管理子任务与父任务之间的关系。'
- en: Exceptions are propagated to the calling application, even for multi-hierarchical
    parent/child tasks.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常会传播到调用应用程序，即使是多级父/子任务也是如此。
- en: Most importantly, `Task` supports async-await, which helps in resuming the processing
    in a calling application/method once the operation in the task is completed.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，`Task` 支持异步-等待（async-await），这有助于在任务中的操作完成后，在调用应用程序/方法中恢复处理。
- en: 'The TPL is a group of APIs provided by .NET in `System.Threading.Tasks` and
    `System.Threading`, and it provides ways to create and manage tasks. Tasks can
    be created by creating an object of the `System.Threading.Tasks.Task` class and
    passing a block of code that needs to be executed on the task. We can create a
    task in multiple ways:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 是由 .NET 在 `System.Threading.Tasks` 和 `System.Threading` 中提供的一组 API，它提供了创建和管理任务的方法。可以通过创建
    `System.Threading.Tasks.Task` 类的实例并传递需要在任务上执行的一块代码来创建任务。我们可以以多种方式创建任务：
- en: 'You can create an object of the `Task` class and pass a Lambda expression.
    In this method, it needs to be started explicitly, as shown in the following code:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建 `Task` 类的实例并传递一个 Lambda 表达式。在此方法中，它需要显式启动，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A task can also be created using `Task.Run`, as shown in the following code,
    which supports creating and starting the task without explicitly calling `Start()`:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务也可以使用`Task.Run`创建，如下面的代码所示，它支持创建和启动任务而不需要显式调用`Start()`：
- en: '[PRE62]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another way to create a task is by using `Task.Factory.StartNew`:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务的另一种方式是使用`Task.Factory.StartNew`：
- en: '[PRE63]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In all these methods, a `ThreadPool` thread is used to run the `FetchDataFromAPI`
    method and is referenced via the `dataTask` object, which is returned to the caller
    to track the completion of the operation/exception.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些方法中，都使用`ThreadPool`线程来运行`FetchDataFromAPI`方法，并通过返回给调用者的`dataTask`对象进行引用，以跟踪操作的完成或异常。
- en: 'As this task would asynchronously execute on a `ThreadPool` thread, and as
    all `ThreadPool` threads are background threads, the application wouldn''t wait
    for the `FetchDataFromAPI` method to complete. The TPL exposes a `Wait` method
    to wait on the completion of the task, such as `dataTask.Wait()`. Here is a code
    snippet from a small console application that uses a task:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个任务将在`ThreadPool`线程上异步执行，并且所有`ThreadPool`线程都是后台线程，应用程序不会等待`FetchDataFromAPI`方法完成。TPL提供了一个`Wait`方法来等待任务的完成，例如`dataTask.Wait()`。以下是一个使用任务的简单控制台应用程序的代码片段：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this snippet, we used a Lambda expression. However, it could be a delegate
    or action delegate (in the case of a parameter-less method), so something such
    as the following can also be used to create a task:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用了Lambda表达式。然而，它也可以是一个委托或无参数方法的动作委托，因此以下内容也可以用来创建任务：
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Either way, you receive a reference to the `Task` object and handle it accordingly.
    If a method is returning a value, then we can use a generic version of the `Task`
    class and use the `Result` method to retrieve data from `Task`. For example, if
    `FetchDataFromAPI` returns a string, we can use `Task<String>`, as shown in the
    following snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你都会收到`Task`对象的引用并相应地处理它。如果一个方法返回一个值，那么我们可以使用`Task`类的泛型版本，并使用`Result`方法从`Task`中检索数据。例如，如果`FetchDataFromAPI`返回一个字符串，我们可以使用`Task<String>`，如下面的代码片段所示：
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'There are various additional parameters that each of these methods accepts,
    and a few important ones are as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都接受各种附加参数，以下是一些重要的参数：
- en: Cancellation using an object of the `CancellationToken` class, generated using
    the `CancellationTokenSource` class.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CancellationToken`类的对象进行取消，该对象是通过`CancellationTokenSource`类生成的。
- en: Control the behavior of task creation and execution through the `TaskCreationOptions`
    enum.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`TaskCreationOptions`枚举控制任务创建和执行的行为。
- en: Custom implementation of `TaskScheduler` to control how tasks are queued.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义实现`TaskScheduler`以控制任务的排队方式。
- en: '`TaskCreationOptions` is an enum in the TPL that tells `TaskScheduler` what
    kind of task we are creating. For example, we can create a long-running task,
    as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCreationOptions`是TPL中的一个枚举，它告诉`TaskScheduler`我们正在创建什么类型的任务。例如，我们可以创建一个长时间运行的任务，如下所示：'
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Although this doesn't guarantee any faster output, it acts more like a hint
    to the scheduler to optimize itself. For example, the scheduler can spin up more
    threads if it sees a long-running task being scheduled. All the options for this
    enum can be found at [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-6.0).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这并不能保证输出更快，但它更像是对调度器的一种提示，使其进行自我优化。例如，如果调度器看到有长时间运行的任务正在被调度，它可以启动更多的线程。这个枚举的所有选项都可以在[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-6.0)找到。
- en: '`Task` also supports waiting on multiple tasks at the same time by creating
    and passing all the tasks as parameters to the following methods:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`还支持通过创建和传递所有任务作为参数到以下方法的同时等待多个任务：'
- en: '`WaitAll`: Wait for the completion of all tasks and block the current thread.
    Not recommended for application development.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAll`：等待所有任务的完成并阻塞当前线程。不推荐用于应用程序开发。'
- en: '`WhenAll`: Wait for the completion of all tasks without blocking the current
    thread. Usually used with async-await. Recommended for application development.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WhenAll`：等待所有任务的完成而不阻塞当前线程。通常与`async-await`一起使用。推荐用于应用程序开发。'
- en: '`WaitAny`: Wait for the completion of one of the tasks and block the current
    thread until then. Not recommended for application development.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAny`：等待其中一个任务的完成并阻塞当前线程直到完成。不推荐用于应用程序开发。'
- en: '`WhenAny`: Wait for the completion of one of the tasks without blocking the
    current thread. Usually used with async-await. Not recommended for application
    development.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WhenAny`：等待其中一个任务的完成，而不阻塞当前线程。通常与 async-await 一起使用。不建议用于应用程序开发。'
- en: Tasks, unlike threads, have comprehensive exception handling support. Let's
    see that in the next section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程不同，任务具有全面的异常处理支持。让我们在下一节中看看这一点。
- en: Handling task exceptions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理任务异常
- en: 'Exception handling in tasks is as simple as writing a `try` block around the
    task and then catching the exceptions, which are usually wrapped in `AggregateException`,
    as shown in the following code snippet:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务中的异常处理就像在任务周围写一个 `try` 块，然后捕获异常，这些异常通常被封装在 `AggregateException` 中，如下面的代码片段所示：
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the preceding code, `agex.InnerException` will give you the actual exception,
    as we are waiting on a single task. However, if we are waiting on multiple tasks,
    it would be the `InnerExceptions` collection that we could loop through. Also,
    it comes with a `Handle` callback method, which can be subscribed in a `catch`
    block, and the callback once triggered will have information about the exception.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`agex.InnerException` 将给出实际的异常，因为我们正在等待单个任务。然而，如果我们正在等待多个任务，那么将是 `InnerExceptions`
    集合，我们可以遍历它。此外，它还包含一个 `Handle` 回调方法，可以在 `catch` 块中订阅，一旦触发，回调将包含有关异常的信息。
- en: As shown in the preceding code, for a task to propagate an exception, we need
    to call the `Wait` method or some other blocking construct such as `WhenAll` to
    trigger the `catch` block. However, under the hood, any exception to `Task` is
    actually held in the `Exception` property of the `Task` class, which is of the
    `AggregateException` type and can be observed for any underlying exceptions in
    the task.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，为了使任务传播异常，我们需要调用 `Wait` 方法或其他一些阻塞构造，如 `WhenAll` 来触发 `catch` 块。然而，在底层，任何对
    `Task` 的异常实际上都保存在 `Task` 类的 `Exception` 属性中，它是 `AggregateException` 类型，可以观察任务中的任何底层异常。
- en: Also, if a task is the parent of attached child tasks or nested tasks, or if
    you are waiting on multiple tasks, multiple exceptions can be thrown. To propagate
    all the exceptions back to the calling thread, the `Task` infrastructure wraps
    them in an `AggregateException` instance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果一个任务是附加子任务或嵌套任务的父任务，或者如果你正在等待多个任务，可能会抛出多个异常。为了将所有异常传播回调用线程，`Task` 基础设施将它们封装在
    `AggregateException` 实例中。
- en: More details about handling exceptions can be found at [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于异常处理的详细信息可以在 [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library)
    找到。
- en: Implementing task cancellation
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现任务取消
- en: '.NET provides two primary classes to support the cancellation of a task:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了两个主要的类来支持任务的取消：
- en: '`CancellationTokenSource`: A class that creates a cancellation token and supports
    the cancellation of a token through the `Cancel` method'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`：一个创建取消令牌并支持通过 `Cancel` 方法取消令牌的类'
- en: '`CancellationToken`: A structure that listens to cancellation and triggers
    a notification if a task is canceled'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancellationToken`：一个监听取消的结构，如果任务被取消，则触发通知'
- en: 'For canceling a task, there are two types of cancellation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于取消任务，有两种类型的取消：
- en: One where a task is executed by mistake and needs to be canceled immediately
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个情况是任务被错误地执行并需要立即取消
- en: Another where a task has started and needs to be stopped (aborted) midway
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个情况是任务已经开始，但需要在中途停止（中止）
- en: 'For the former, we can create a task that supports cancellation. We use the
    TPL APIs and pass the cancellation token to the constructor and call the `Cancel`
    method of the `CancellationTokenSource` class if the task needs to be canceled,
    as shown in the following code snippet:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前者，我们可以创建一个支持取消的任务。我们使用 TPL API 并将取消令牌传递给构造函数，如果任务需要取消，就调用 `CancellationTokenSource`
    类的 `Cancel` 方法，如下面的代码片段所示：
- en: '[PRE92]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: All the .NET Core APIs that support asynchronous calling, such as `GetAsync`
    and `PostAsync` of the `HttpClient` class, have overloads to accept cancellation
    tokens. For the latter case (aborting a task), the decision is based on whether
    the operation that would be running supports cancellation or not. Assuming it
    supports cancellation, we can pass the cancellation token to the method and, inside
    the method call, check the `IsCancellationRequested` property of the cancellation
    token and handle it accordingly.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支持异步调用的 .NET Core API，如 `HttpClient` 类的 `GetAsync` 和 `PostAsync`，都有接受取消令牌的重载。对于后一种情况（中止任务），决策基于将要运行的操作是否支持取消。假设它支持取消，我们可以将取消令牌传递给方法，并在方法调用内部检查取消令牌的
    `IsCancellationRequested` 属性，并相应地处理它。
- en: 'Let''s create a simple console application that creates a task that does support
    cancellation. Here, we are creating a `FetchDataFromAPI` method that accepts a
    list of URLs and retrieves data from those URLs. This method also supports cancellation
    using `CancellationToken`. In the implementation, we loop through the list of
    URLs and continue until cancellation is requested or the loop completes all iterations:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的控制台应用程序，创建一个支持取消的任务。在这里，我们创建了一个 `FetchDataFromAPI` 方法，该方法接受一个 URL
    列表并从这些 URL 获取数据。此方法还支持使用 `CancellationToken` 进行取消。在实现中，我们遍历 URL 列表，直到请求取消或循环完成所有迭代：
- en: '[PRE99]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, call `FetchDataFromAPI` with a list of four URLs from the main method,
    as shown in the following code. Here, we are creating `CancellationToken` using
    the `Token` property of the `CancellationTokenSource` class and passing it to
    the `FetchDataFromAPI` method. We are simulating a cancellation after 3 seconds
    so that `FetchDataFromAPI` will be canceled before the fourth URL is retrieved:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从主方法中调用 `FetchDataFromAPI`，使用四个 URL 的列表，如下所示。在这里，我们使用 `CancellationTokenSource`
    类的 `Token` 属性创建 `CancellationToken`，并将其传递给 `FetchDataFromAPI` 方法。我们模拟了 3 秒后的取消，以便在获取第四个
    URL 之前取消 `FetchDataFromAPI`：
- en: '[PRE126]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Once we run this code, we can see output for three URLs and then an exception/break
    (based on whichever line is commented out in the `FetchDataFromAPI` method).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此代码，我们可以看到三个 URL 的输出，然后是一个异常/中断（基于 `FetchDataFromAPI` 方法中注释掉的哪一行）。
- en: In the preceding sample, we have simulated a long-running code block using a
    `for` loop and `Thread.Sleep`, canceled the task, and handled the code accordingly.
    However, there could be a scenario where the long-running code block may not support
    cancellation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 `for` 循环和 `Thread.Sleep` 模拟了长时间运行的代码块，取消了任务，并相应地处理了代码。然而，可能存在一种情况，长时间运行的代码块可能不支持取消。
- en: 'In those cases, we must write a wrapper method that accepts a cancellation
    token and have the wrapper internally call the long-running operation; then, in
    the main method, we call the wrapper code. The following snippet shows a wrapper
    method that makes use of `TaskCompletionSource`, which is another class in the
    TPL. It is used to convert non-task-based asynchronous methods (including even
    the ones based on asynchronous methods) to tasks through the `Task` property available
    in the class. In this case, we will pass the cancellation token to `TaskCompletionSource`
    so that its `Task` is updated accordingly:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些情况下，我们必须编写一个接受取消令牌的包装方法，并在包装器内部调用长时间运行的操作；然后在主方法中，我们调用包装器代码。以下代码片段显示了一个使用
    `TaskCompletionSource` 的包装方法，这是 TPL 中的另一个类。它用于通过类中可用的 `Task` 属性将非任务异步方法（包括基于异步方法的那些）转换为任务。在这种情况下，我们将取消令牌传递给
    `TaskCompletionSource`，以便其 `Task` 得到相应的更新：
- en: '[PRE144]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In this case, `CancellationToken` is tracked through the `Task` property of
    `TaskCompletionSource`, and we created another task to call our long-running operation
    (the one without cancellation token support), and whichever task finishes first
    is the one we return.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CancellationToken` 通过 `TaskCompletionSource` 的 `Task` 属性进行跟踪，我们创建了另一个任务来调用我们的长时间运行的操作（不支持取消令牌支持的操作），并且哪个任务先完成，我们就返回哪个任务。
- en: 'Of course, the `Main` method needs to be updated to call the wrapper, as shown
    here (the rest of the code remains the same):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Main` 方法需要更新为调用包装器，如下所示（其余代码保持不变）：
- en: '[PRE159]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This doesn't cancel the underlying method but still allows the application to
    exit before the underlying operation is completed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会取消底层方法，但仍然允许应用程序在底层操作完成之前退出。
- en: Task cancellation is a very useful mechanism that helps in reducing unwanted
    processing, either in tasks that haven't started yet or ones that have started
    but need to be stopped/aborted. Hence, all the asynchronous APIs in .NET do support
    cancellation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 任务取消是一种非常有用的机制，有助于减少不必要的处理，无论是尚未开始的任务还是已经开始但需要停止/中止的任务。因此，.NET中的所有异步API都支持取消。
- en: Implementing continuations
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现延续
- en: In enterprise applications, most of the time, there will be a need to create
    multiple tasks, build a hierarchy of tasks, create dependent tasks, or create
    child/parent relationships between tasks. Task continuation can be used to define
    such child tasks/sub-tasks. It works like JavaScript promises and supports chaining
    tasks up to multiple levels. Just like promises, the subsequent task in a hierarchy
    executes after the first task, and this can be further chained to multiple levels.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，大多数情况下，需要创建多个任务，构建任务层次结构，创建依赖任务，或创建任务之间的子/父关系。任务延续可以用来定义这样的子任务/子任务。它就像JavaScript的承诺一样工作，并支持将任务链式连接到多个级别。就像承诺一样，层次结构中的后续任务在第一个任务之后执行，并且这可以进一步链式连接到多个级别。
- en: 'There are various ways to achieve task continuation, but the most common way
    is to use the `ContinueWith` method of the `Task` class, as shown in the following
    example:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 实现任务延续有多种方法，但最常见的方法是使用`Task`类的`ContinueWith`方法，如下面的示例所示：
- en: '[PRE169]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: As you might have guessed, here the output would be `4`, and each task executes
    once the preceding task's execution is completed.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，这里的输出将是`4`，并且每个任务都在前一个任务的执行完成后执行。
- en: '`ContinueWith` accepts one important enum called `TaskContinuationOptions`,
    which supports continuation for different conditions. For example, we can pass
    `TaskContinuationOptions.OnlyOnFaulted` as a parameter to create a continuation
    task that executes when there is an exception in the preceding task or pass `TaskContinuationOptions.AttachedToParent`
    to create a continuation task that enforces a parent-child relationship and forces
    a parent task to complete execution only after the child task.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith`接受一个重要的枚举`TaskContinuationOptions`，它支持不同条件下的延续。例如，我们可以将`TaskContinuationOptions.OnlyOnFaulted`作为参数传递，以创建一个在前面任务中发生异常时执行的延续任务，或者传递`TaskContinuationOptions.AttachedToParent`以创建一个强制父-子关系的延续任务，并强制父任务仅在子任务完成后才完成执行。'
- en: 'As with `WhenAll` and `WhenAny`, `ContinueWith` also comes with similar siblings,
    as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WhenAll`和`WhenAny`类似，`ContinueWith`也有类似的兄弟方法，如下所示：
- en: '`Task.Factory.ContinueWhenAll`: This accepts multiple task references as parameters
    and creates a continuation when all the tasks are completed.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.ContinueWhenAll`：这个方法接受多个任务引用作为参数，并在所有任务完成时创建一个延续。'
- en: '`Task.Factory.ContinueWhenAny`: This accepts multiple task references as parameters
    and creates a continuation when one of the referenced tasks is completed.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.ContinueWhenAny`：这个方法接受多个任务引用作为参数，并在其中一个引用的任务完成时创建一个延续。'
- en: Grasping task continuation is critical to understanding the under-the-hood workings
    of async-await, which we will discuss later in this chapter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 理解任务延续对于理解async-await的底层工作原理至关重要，我们将在本章后面讨论这一点。
- en: SynchronizationContext
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步上下文
- en: '`SynchronizationContext` is an abstract class available in `System.Threading`
    that helps in communication between threads. For example, updating a UI element
    from a parallel task requires the thread to rejoin the UI thread and resume execution.
    `SynchronizationContext` provides this abstraction primarily through the `Post`
    method of this class, which accepts a delegate to execute at a later stage. So,
    in the preceding example, if I need to update a UI element, I need to take `SynchronizationContext`
    of the UI thread, call its `Post` method, and pass the necessary data to update
    the UI element.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`SynchronizationContext`是`System.Threading`中可用的一个抽象类，它有助于线程之间的通信。例如，从并行任务更新UI元素需要线程重新加入UI线程并继续执行。`SynchronizationContext`主要通过这个类的`Post`方法提供这种抽象，该方法接受一个在稍后阶段执行的委托。因此，在前面的示例中，如果需要更新UI元素，就需要获取UI线程的`SynchronizationContext`，调用其`Post`方法，并传递必要的更新UI元素的数据。'
- en: As `SynchronizationContext` is an abstract class, there are various derived
    types of it – for instance, Windows Forms has `WindowsFormsSynchronizationContext`
    and WPF has `DispatcherSynchronizationContext`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SynchronizationContext`是一个抽象类，因此有各种派生类型——例如，Windows Forms有`WindowsFormsSynchronizationContext`，而WPF有`DispatcherSynchronizationContext`。
- en: The primary advantage of `SynchronizationContext` being an abstraction is that
    it can be helpful to queue a delegate, irrespective of the overridden implementation
    of the `Post` method.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`SynchronizationContext`的主要优势在于它是一个抽象，这有助于无论`Post`方法的重写实现如何，都可以排队一个委托。'
- en: TaskScheduler
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskScheduler
- en: When we created tasks using the various methods described earlier, we saw that
    a task gets *scheduled* on a `ThreadPool` thread, but the question arises of who
    or what does that. `System.Threading.Tasks.TaskScheduler` is the class available
    in the TPL that takes care of queueing and executing task delegates on a `ThreadPool`
    thread.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用前面描述的各种方法创建任务时，我们看到了任务会在`ThreadPool`线程上被*调度*，但问题是谁或什么负责调度。`System.Threading.Tasks.TaskScheduler`是TPL中可用的类，负责在`ThreadPool`线程上排队和执行任务委托。
- en: 'Of course, this is an abstract class, and the framework comes with two derived
    classes:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个抽象类，框架提供了两个派生类：
- en: '`ThreadPoolTaskScheduler`'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolTaskScheduler`'
- en: '`SynchronizationContextScheduler`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SynchronizationContextScheduler`'
- en: '`TaskScheduler` exposes a `Default` property, which is by default set to `ThreadPoolTaskScheduler`.
    Hence, by default, all tasks are scheduled to `ThreadPool` threads; however, a
    GUI application typically uses `SynchronizationContextScheduler` so that tasks
    can successfully go back and update UI elements.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskScheduler`公开了一个`Default`属性，默认设置为`ThreadPoolTaskScheduler`。因此，默认情况下，所有任务都安排到`ThreadPool`线程上；然而，GUI应用程序通常使用`SynchronizationContextScheduler`，以便任务可以成功返回并更新UI元素。'
- en: .NET Core comes with sophisticated derived types of the `TaskScheduler` and
    `SynchronizationContext` classes. However, they play a major role in async-await,
    and they help in debugging any deadlock-related issues quickly.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core提供了`TaskScheduler`和`SynchronizationContext`类的复杂派生类型。然而，它们在async-await中扮演着重要角色，并有助于快速调试任何与死锁相关的问题。
- en: Note that looking at the internal workings of `TaskScheduler` and `SynchronizationContext`
    is beyond the scope of this book and is left to you to explore as an exercise.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，查看`TaskScheduler`和`SynchronizationContext`的内部工作原理超出了本书的范围，留作练习探索。
- en: Implementing data parallelism
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现数据并行化
- en: Data parallelism is all about partitioning a source collection into multiple
    parallel executable tasks that perform the same operation parallelly. With the
    TPL, this is available in the `Parallel` static class, which exposes methods such
    as `For` and `ForEach` with multiple overloads to handle such execution.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并行化主要涉及将源集合分割成多个并行可执行的任务，这些任务并行执行相同的操作。使用TPL（Task Parallel Library），这可以通过`Parallel`静态类来实现，该类公开了`For`和`ForEach`等方法，并具有多个重载以处理此类执行。
- en: 'Say you have a collection of a million numbers and you need to find the prime
    numbers. Data parallelism can come in handy here, as the collection can be split
    into ranges and evaluated for prime numbers. A typically parallel `for` loop is
    written, as shown in the following snippet:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含一百万个数字的集合，你需要找出其中的素数。数据并行化在这里可以派上用场，因为集合可以被分割成范围，并评估其中的素数。通常的并行`for`循环可以写成如下片段：
- en: '[PRE177]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: However, a more realistic example would be something like an image processing
    application that needs to process each pixel in an image and reduce the brightness
    of each pixel by five points. Such operations can be hugely benefited by data
    parallelism, as each pixel is independent of the others and hence can be processed
    parallelly.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个更现实的例子可能是一个图像处理应用程序，它需要处理图像中的每个像素，并将每个像素的亮度降低五点。此类操作可以从数据并行化中受益匪浅，因为每个像素与其他像素独立，因此可以并行处理。
- en: 'Similarly, there is a `ForEach` method in the `Parallel` static class, which
    can be used as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Parallel`静态类中有一个`ForEach`方法，可以如下使用：
- en: '[PRE181]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Some of the key advantages of data parallelism using `Parallel.For` and `Parallel.ForEach`
    are listed here:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Parallel.For`和`Parallel.ForEach`实现数据并行化的关键优势如下列出：
- en: Good for canceling loops; they work similarly to `break` in a regular `for`
    loop. In `Parallel.For`, this is supported by passing `ParallelStateOptions` to
    the delegate and then calling `ParallelStateOptions.Break`. When `Break` is encountered
    by one of the tasks, the `LowestBreakIteration` property of the `ParallelStateOptions`
    class is set, and all the parallel tasks will iterate until this number is reached.
    `ParallelLoopResult`, which is the return type of `Parallel.For` and `Parallel.ForEach`,
    has the `IsCompleted` property, which states whether the loop executed prematurely.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于取消循环；它们在常规的`for`循环中的`break`操作类似。在`Parallel.For`中，这是通过将`ParallelStateOptions`传递给委托并调用`ParallelStateOptions.Break`来支持的。当某个任务遇到`Break`时，`ParallelStateOptions`类的`LowestBreakIteration`属性被设置，所有并行任务将迭代直到达到这个数字。`ParallelLoopResult`是`Parallel.For`和`Parallel.ForEach`的返回类型，它有一个`IsCompleted`属性，表示循环是否提前执行。
- en: They also support stopping the loop immediately through `ParallelStateOptions.Stop`.
    Also, some of the constructors of `Parallel.For` and `Parallel.ForEach` accept
    cancellation tokens, which can also be used to simulate `ParallelStateOptions.Stop`;
    however, a loop should be wrapped within a `try…catch` block, as `OperationCanceledException`
    would be thrown.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还支持通过`ParallelStateOptions.Stop`立即停止循环。此外，`Parallel.For`和`Parallel.ForEach`的一些构造函数接受取消令牌，也可以用来模拟`ParallelStateOptions.Stop`；然而，循环应该被包裹在一个`try…catch`块中，因为会抛出`OperationCanceledException`。
- en: If one of the tasks throws an exception, all the tasks will complete their current
    iteration and then stop processing. As with tasks, `AggregateException` is thrown
    back.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某个任务抛出异常，所有任务将完成它们的当前迭代，然后停止处理。与任务类似，会抛出`AggregateException`。
- en: Degrees of parallelism are supported by passing `ParallelOptions` and setting
    `MaxDegreeOfParallelism`, which will control the number of cores that tasks can
    parallelly execute on.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递`ParallelOptions`并设置`MaxDegreeOfParallelism`来支持并行度，这将控制任务可以并行执行的核心数。
- en: The custom partitioning of a source collection is supported through range partitioning
    or chunk partitioning.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持通过范围分区或块分区对源集合进行自定义分区。
- en: Supports thread-safe local variables that are scoped to a thread or partition.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持作用域为线程或分区的线程安全局部变量。
- en: Nested `Parallel.For` loops are supported, and their synchronization is automatically
    handled without introducing any manual synchronization.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持嵌套的`Parallel.For`循环，它们的同步会自动处理，而不会引入任何手动同步。
- en: If each iteration uses a shared variable, synchronization needs to be implemented
    explicitly. So, to get the most out of data parallelism, use it for operations
    that can execute independently for each iteration without depending on shared
    resources.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每个迭代使用一个共享变量，则需要显式实现同步。因此，为了最大限度地利用数据并行性，应将其用于每个迭代可以独立执行且不依赖于共享资源的操作。
- en: Tip
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: Data parallelism should be used carefully, as at times it is misused. It's like
    splitting 40 tasks among 4 people. If organizing this work (splitting and consolidating
    it) among 4 people represents much more work than just performing the overall
    work of the 40 tasks, then data parallelism isn't the right choice. For further
    reading, refer to [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library).
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据并行性应谨慎使用，因为有时会被误用。这就像把40个任务分给4个人。如果组织这项工作（分割和合并）给4个人做比完成40个任务的整体工作还要多，那么数据并行性不是正确的选择。有关进一步阅读，请参阅[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library)。
- en: Using Parallel LINQ (PLINQ)
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Parallel LINQ (PLINQ)
- en: 'PLINQ is a parallel implementation of LINQ; this is a set of APIs available
    in the `ParallelEnumerable` class that enables the parallel execution of LINQ
    queries. The simplest way of making a LINQ query run parallelly is to embed the
    `AsParallel` method in the LINQ query. See the following code snippet, which calls
    a method that calculates the prime numbers between 1 and 1,000:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ是LINQ的并行实现；这是一组在`ParallelEnumerable`类中可用的API，它使LINQ查询的并行执行成为可能。使LINQ查询并行运行的最简单方法是在LINQ查询中嵌入`AsParallel`方法。请参见以下代码片段，它调用一个计算1到1,000之间素数的方法：
- en: '[PRE182]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Using LINQ query syntax, this would be as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LINQ查询语法，这将是如下所示：
- en: '[PRE185]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Internally, this query is split into multiple smaller queries that are parallelly
    executed on each processor, hence speeding up the query. The partitioned source
    needs to be merged back on the main thread so that the result (output collection)
    can be looped through for further processing/display.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，此查询被分割成多个更小的查询，这些查询在每个处理器上并行执行，从而加快了查询速度。分区源需要合并回主线程，以便结果（输出集合）可以遍历以进行进一步的处理/显示。
- en: 'Let''s create a console application that prints all prime numbers between a
    given range, using PLINQ combined with `Parallel.For`. Add the following method,
    which takes a number and returns `true` if it''s a prime number and `false` otherwise:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制台应用程序，使用 PLINQ 和 `Parallel.For` 打印给定范围内的所有素数。添加以下方法，该方法接受一个数字，如果它是素数则返回
    `true`，否则返回 `false`：
- en: '[PRE186]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Now, in the main method, add the following code, which creates a list of the
    first 100 numbers that we will loop through using PLINQ before passing it to the
    `CalculatePrime` method; then, we''ll finally display the list of prime numbers
    using `Parallel.ForEach`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在主方法中，添加以下代码，它创建了一个列表，包含我们将使用 PLINQ 遍历的前 100 个数字，然后将其传递给 `CalculatePrime`
    方法；然后，我们将最终使用 `Parallel.ForEach` 显示素数列表：
- en: '[PRE202]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The output for this sample would be a list of prime numbers; however, you can
    see that the output will not be prime numbers in ascending order but in a random
    order, as the `CalculatePrime` method is called with multiple numbers parallelly.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出将是一个素数列表；然而，你可以看到输出将不会是按升序排列的素数，而是随机顺序，因为 `CalculatePrime` 方法是并行调用多个数字的。
- en: 'A diagram of the internal working of the preceding code follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码内部工作原理图如下：
- en: '![Figure 4.4 – PLINQ and Parallel.ForEach'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – PLINQ 和 Parallel.ForEach'
- en: '](img/Figure_4.4_B18507.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B18507.jpg)'
- en: Figure 4.4 – PLINQ and Parallel.ForEach
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – PLINQ 和 Parallel.ForEach
- en: 'PLINQ further provides a method to process the result of each partition/thread
    without the overhead of merging the result into a calling thread using `ForAll`,
    and the preceding code can be further optimized as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 还提供了一个方法，用于处理每个分区/线程的结果，而无需使用 `ForAll` 将结果合并到调用线程中，前面的代码可以进一步优化如下：
- en: '[PRE217]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Tip
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: One of the best tools for playing around with LINQ/PLINQ is LINQPad; I recommend
    that you download it from [https://www.linqpad.net/Download.aspx](https://www.linqpad.net/Download.aspx).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LINQ/PLINQ 中进行实验的最佳工具之一是 LINQPad；我建议您从 [https://www.linqpad.net/Download.aspx](https://www.linqpad.net/Download.aspx)
    下载它。
- en: 'Some of the important things to remember for PLINQ are as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PLINQ，以下是一些重要事项需要记住：
- en: Merging results to the main thread can be configured by using the `WithMergeOption`
    method and passing the appropriate value through the `ParallelMergeOperation`
    enum.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用 `WithMergeOption` 方法并传递 `ParallelMergeOperation` 枚举的适当值来配置将结果合并到主线程。
- en: As with other parallel extensions, any exception is returned as `AggregateException`,
    and the execution of all the iterations stops immediately. Of course, if exceptions
    are swallowed within the delegate instead of them being thrown back, the execution
    can continue.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他并行扩展一样，任何异常都作为 `AggregateException` 返回，并且所有迭代的执行会立即停止。当然，如果异常在委托内部被吞没而没有抛出，则执行可以继续。
- en: There are various other extension methods, such as `AsSequential` and `AsOrdered`,
    and these can be combined in one single LINQ query. For example, based on that,
    `AsSequential` can be combined with `AsParallel` so that some partitions can be
    run sequentially and other partitions can be executed parallelly.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有各种其他扩展方法，例如 `AsSequential` 和 `AsOrdered`，这些可以在单个 LINQ 查询中组合使用。例如，基于此，`AsSequential`
    可以与 `AsParallel` 结合使用，以便某些分区可以顺序执行，而其他分区可以并行执行。
- en: Supports cancellation using the `WithCancellation` method.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用 `WithCancellation` 方法进行取消。
- en: Degrees of parallelism are supported through `WithDegreeOfParallelism`.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `WithDegreeOfParallelism` 支持并行度。
- en: Data parallelism and PLINQ provide a lot of APIs that can be used to quickly
    enable the parallel execution of code without adding any additional overhead to
    the application logic. However, there is a subtle difference between them, as
    explained in the preceding section, and they should be used differently accordingly.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并行和 PLINQ 提供了许多 API，可以用来快速启用代码的并行执行，而无需向应用程序逻辑添加任何额外的开销。然而，它们之间有一个细微的差别，如前所述，因此应根据不同情况进行不同的使用。
- en: Tip
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: PLINQ and the TPL together comprise parallel extensions.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 和 TPL 一起构成了并行扩展。
- en: In this section, we have used `Thread.Sleep` in many places, but that has primarily
    been to simulate long-running operations; however, it is never recommended that
    you use this in production.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在许多地方使用了 `Thread.Sleep`，但这主要是为了模拟长时间运行的操作；然而，在产品环境中使用此方法是不推荐的。
- en: In the next section, we will see how we can club tasks with async-await and
    use async-await in enterprise applications.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将任务与 async-await 结合使用，并在企业应用程序中使用 async-await。
- en: Introducing async-await
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 async-await
- en: So far, we have discussed writing asynchronous code using tasks and how the
    TPL simplifies creating and managing tasks. However, tasks primarily rely on continuation,
    callbacks, or events to continue execution after the completion of a task.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了使用任务编写异步代码以及 TPL 如何简化任务创建和管理。然而，任务主要依赖于延续、回调或事件在任务完成后继续执行。
- en: In enterprise applications, managing such code would be difficult; any runtime
    exceptions would be difficult to debug if too many tasks were chained. That's
    where C# comes in with async-await, a language feature introduced in C# 5.0 that
    simplifies the writing of asynchronous code, makes it more readable and maintainable,
    improves exception handling, and makes things easy to debug. So, let's dive into
    async-await.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，管理此类代码会非常困难；如果任务链太多，任何运行时异常都很难调试。这就是 C# 的 async-await 发挥作用的地方，它是 C#
    5.0 中引入的一种语言特性，简化了异步代码的编写，使其更易于阅读和维护，改进了异常处理，并使调试变得容易。因此，让我们深入了解 async-await。
- en: '`async` is a keyword in C# that is used as a modifier and, when prefixed to
    any method (or Lambda), converts a method into a state machine, enabling the method
    to use the `await` keyword in its body.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 是 C# 中的一个关键字，用作修饰符，当它附加到任何方法（或 Lambda）之前时，会将该方法转换为状态机，使方法能够在其主体中使用
    `await` 关键字。'
- en: '`await` is a keyword in C# that is used as an operator and is followed by an
    expression that returns an awaitable object (usually a task). `await` can be used
    only inside a method that has an `async` modifier, and as soon as a caller encounters
    an `await` statement, control is returned and things are resumed; after `await`,
    the task is completed using continuations.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 是 C# 中的一个关键字，用作运算符，其后跟一个返回可等待对象的表达式（通常是任务）。`await` 只能在具有 `async` 修饰符的方法内部使用，一旦调用者遇到
    `await` 语句，控制权就会返回，并且操作会继续；在 `await` 之后，任务通过延续来完成。'
- en: The task-based asynchronous pattern
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于任务的异步模式
- en: 'The `async` modifier and then use `await` on an asynchronous operation that
    is wrapped in a task (or any custom awaitable type that exposes `GetAwaiter()`).
    To put it simply, this pattern involves representing an asynchronous operation
    using a single method that has an `async` modifier and returns a task; any asynchronous
    operation is further awaited using `await`. The following is a sample code snippet
    that downloads a file asynchronously, which is implemented using the TAP:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` 修饰符，然后在任务（或任何公开 `GetAwaiter()` 的自定义可等待类型）包装的异步操作上使用 `await`。简单来说，这种模式涉及使用单个具有
    `async` 修饰符并返回任务的方法来表示异步操作；任何异步操作都进一步使用 `await` 进行等待。以下是一个示例代码片段，它异步地下载文件，这是使用
    TAP 实现的：
- en: '![Figure 4.5 – A sample asynchronous method using async-await'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 使用 async-await 的异步方法示例'
- en: '](img/Figure_4.5_B18507.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B18507.jpg)'
- en: Figure 4.5 – A sample asynchronous method using async-await
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 使用 async-await 的异步方法示例
- en: 'In the preceding figure, control flows as follows (using the number labels
    in the figure):'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，控制流如下（使用图中的数字标签）：
- en: The application starts execution with the `Main` method. Since `Main` is prefixed
    with the `async` method, it gets transformed into a type that implements a state
    machine. Execution continues until `await` is encountered at `await` `DownloadFileAsync`,
    and the thread is returned to the caller.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序从 `Main` 方法开始执行。由于 `Main` 前缀为 `async` 方法，它被转换为一个实现状态机的类型。执行会继续，直到在 `await
    DownloadFileAsync` 处遇到 `await`，然后线程返回给调用者。
- en: Before returning to the caller, a call to the `DownloadFileAsync` method is
    stored in a `Task` object, and a reference to the `Task` object is also preserved.
    The remaining code of the `Main` method is wrapped inside the continuation of
    this task.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回调用者之前，对 `DownloadFileAsync` 方法的调用被存储在一个 `Task` 对象中，并且 `Task` 对象的引用也被保留。`Main`
    方法的剩余代码被包装在这个任务的延续中。
- en: A `ThreadPool` thread will start executing a `DownloadFileAsync` method, and
    it repeats the same steps – that is, it converts a method into a type that implements
    a state machine, continues execution until `await` is encountered, and then the
    task that is referenced is passed back; the remaining code is moved to the continuation
    of this task.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ThreadPool`线程将开始执行`DownloadFileAsync`方法，并重复相同的步骤——即，将方法转换为实现状态机的类型，直到遇到`await`，然后返回引用的任务；剩余的代码将移动到该任务的后续操作中。'
- en: At some point, when the `DownloadDataTaskAsync` method is completed, the task
    continuation gets triggered and will execute the remaining code.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`DownloadDataTaskAsync`方法完成时，任务后续操作被触发，并将执行剩余的代码。
- en: The process repeats until the task that has the reference of `DownloadFileAsync`
    completes and its continuation is executed, which is `Console.WriteLine("File
    downloaded!!")` in this case, and then the application exits.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程会重复进行，直到具有`DownloadFileAsync`引用的任务完成并执行其后续操作，在这种情况下，后续操作是`Console.WriteLine("File
    downloaded!!")`，然后应用程序退出。
- en: 'At an approximate high level, the code would be transformed as shown here:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大致的高级层面上，代码将转换为如下所示：
- en: '![Figure 4.6 – A transformed sample asynchronous method'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 转换后的示例异步方法'
- en: '](img/Figure_4.6_B18507.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6_B18507.jpg](img/Figure_4.6_B18507.jpg)'
- en: Figure 4.6 – A transformed sample asynchronous method
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 转换后的示例异步方法
- en: Although this is an oversimplification of the under-the-hood workings of async-await,
    we can see the compiler doing a lot of heavy lifting, including generating a type
    that implements a state machine and continuing the execution using the state of
    the callback.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个对异步/await 底层工作原理的过度简化，但我们可以看到编译器做了大量的工作，包括生成一个实现状态机的类型，并使用回调的状态继续执行。
- en: We have seen how simple it is to write async methods, and we will be writing
    many such methods in our enterprise application throughout the course of the book.
    However, async-await is not a silver bullet; it is not an answer to every application
    issue. We need to verify certain factors to make use of async-await. Let's see
    what the principles are for using async-await.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到编写异步方法是多么简单，我们将在本书的整个过程中在我们的企业应用程序中编写许多这样的方法。然而，async-await 并非万能药；它不是每个应用程序问题的答案。我们需要验证某些因素才能使用
    async-await。让我们看看使用 async-await 的原则是什么。
- en: Note
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code would change slightly if there was `SynchronizationContext`.
    For instance, in Windows Forms or WPF apps, continuation is posted on the current
    `SynchronizationContext` using the `Post` method of `SynchronizationContext` or
    `TaskScheduler.FromCurrentSynchronizationContext`. As per the standard naming
    convention, asynchronous methods are suffixed with the word `async` for readability
    purposes, but syntactically, it is not needed.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`SynchronizationContext`，前面的代码会有所不同。例如，在 Windows Forms 或 WPF 应用程序中，使用`SynchronizationContext`的`Post`方法或`TaskScheduler.FromCurrentSynchronizationContext`将后续操作发布到当前`SynchronizationContext`。根据标准命名约定，为了可读性，异步方法后缀为`async`，但从语法上讲，这不是必需的。
- en: Principles of using async-await
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 async-await 的原则
- en: As we start using async-await, there are certain practices that are recommended
    that will enable an application to take advantage of asynchronous principles.
    For example, for nested calls, we should use async-await all the way; do not use
    `.Result` and so on. Here are a few guidelines to help you use async-await effectively.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始使用 async-await，有一些推荐的做法可以使应用程序充分利用异步原则。例如，对于嵌套调用，我们应该一直使用 async-await；不要使用`.Result`等。以下是一些有助于有效使用
    async-await 的指导原则。
- en: Chain async-await all the way
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一直使用 async-await
- en: An asynchronous method implemented using async-await should be triggered from
    an async-await method so that it is properly awaited. If we try to call an asynchronous
    method from a synchronous method using the `Result` method or the `Wait` method
    of a task, it could lead to a deadlock.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 async-await 实现的异步方法应该从 async-await 方法中触发，以便正确地等待。如果我们尝试使用任务的`Result`方法或`Wait`方法从同步方法中调用异步方法，可能会导致死锁。
- en: 'Let''s look at the following code snippet from a WPF application that downloads
    files from the network upon a button click. However, instead of awaiting a call
    to the asynchronous method, we are using the `Result` method of `Task`:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下来自 WPF 应用程序的代码片段，该应用程序在按钮点击时从网络上下载文件。然而，我们不是等待异步方法的调用，而是使用`Task`的`Result`方法：
- en: '[PRE221]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'In this method, the code after `await` `webClient.DownloadDataTaskAsync(url);`
    will never execute, for the following reasons:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，`await` `webClient.DownloadDataTaskAsync(url);` 之后的代码永远不会执行，原因如下：
- en: As soon as await is encountered, the `Task` reference object captures `SynchronizationContext`
    in `TaskAwaitable` through the `GetAwaiter` method.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦遇到 `await`，`Task` 引用对象将通过 `GetAwaiter` 方法捕获 `SynchronizationContext` 在 `TaskAwaitable`
    中。
- en: Once the `async` operation is completed, the continuation of that `await` needs
    to execute on `SynchronizationContext` (through `SynchronizationContext.Post`).
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦 `async` 操作完成，该 `await` 的后续操作需要在 `SynchronizationContext` 上执行（通过 `SynchronizationContext.Post`）。
- en: However, `SynchronizationContext` is already blocked because the call to `task.Result`
    on the click of a button is on the same `SynchronizationContext` and is waiting
    for `DownloadDataTaskAsync` to complete, hence it is causing a deadlock.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，`SynchronizationContext` 已经被阻塞，因为按钮点击时对 `task.Result` 的调用是在同一个 `SynchronizationContext`
    上，并且正在等待 `DownloadDataTaskAsync` 完成，因此它导致了死锁。
- en: So, never block `async` methods; the best way to do `async` is all the way.
    So, in the preceding code, you would change the call to `await` `DownloadFileAsync`
    (and `async void` for button click – `await` needs a method to have an `async`
    modifier).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，永远不要阻塞 `async` 方法；最佳实践是将 `async` 完全实现。所以，在先前的代码中，你需要将调用 `await` `DownloadFileAsync`（以及按钮点击时的
    `async void` – `await` 需要一个带有 `async` 修饰符的方法）进行更改。
- en: Note
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The same code works fine in ASP.NET Core 6 applications without causing a deadlock
    because ASP.NET Core 6 doesn't have `SynchronizationContext`, and continuation
    executes on a `ThreadPool` thread without any involvement of a request context;
    however, blocking asynchronous calls is still not recommended, even in ASP.NET
    Core 6.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 6 应用程序中，相同的代码运行良好，不会导致死锁，因为 ASP.NET Core 6 没有使用 `SynchronizationContext`，并且后续操作在
    `ThreadPool` 线程上执行，而不涉及任何请求上下文；然而，即使在 ASP.NET Core 6 中，也不建议阻塞异步调用。
- en: ConfigureAwait
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConfigureAwait
- en: In the preceding discussion, since we had the end-to-end application code, it
    was easier to find the cause of the deadlock. However, if we are developing a
    library with asynchronous methods that can be used in WPF, ASP.NET Core 6, or
    .NET Framework applications, we need to ensure that the asynchronous code within
    the library does not cause a deadlock, even though the caller may be consuming
    library methods through synchronous methods (`GetAwaiter().GetResult()`).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的讨论中，由于我们有端到端的应用程序代码，因此更容易找到死锁的原因。然而，如果我们正在开发一个库，该库包含可以在 WPF、ASP.NET Core
    6 或 .NET Framework 应用程序中使用的异步方法，我们需要确保库中的异步代码不会导致死锁，即使调用者可能通过同步方法（`GetAwaiter().GetResult()`）消费库方法。
- en: In such cases, `Task` provides a method called `ConfigureAwait` that accepts
    a Boolean value, which, when `true`, will use the original context of the caller
    and, when `false`, will resume operation after `await` without depending on the
    original context. In layman's terms, any code after `await` will execute independently,
    irrespective of the state of the context that initiated the request.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Task` 提供了一个名为 `ConfigureAwait` 的方法，它接受一个布尔值，当为 `true` 时，将使用调用者的原始上下文，当为
    `false` 时，将在 `await` 之后继续操作，而不依赖于原始上下文。用通俗易懂的话来说，`await` 之后的任何代码都将独立执行，不受发起请求的上下文状态的约束。
- en: 'Use `ConfigureAwait(false)`, especially if you are implementing a library method,
    as it will avoid running a continuation on the original context. For library methods,
    it is a must to use `ConfigureAwait(false)`, as they should never depend on the
    calling/original context for the continuation. For example, the following code
    won''t cause a deadlock:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ConfigureAwait(false)`，特别是如果你正在实现库方法，因为它将避免在原始上下文中运行后续操作。对于库方法，必须使用 `ConfigureAwait(false)`，因为它们不应该依赖于调用者/原始上下文来执行后续操作。例如，以下代码不会导致死锁：
- en: '[PRE253]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: By default, every `await` expression has `ConfigureAwait(true)`, so it's recommended
    to call `ConfigureAwait(false)` explicitly as much as possible. Apart from avoiding
    deadlocks, `ConfigureAwait(false)` also improves performance, as there is no marshaling
    of the original context.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个 `await` 表达式都有 `ConfigureAwait(true)`，因此建议尽可能显式地调用 `ConfigureAwait(false)`。除了避免死锁之外，`ConfigureAwait(false)`
    还可以提高性能，因为没有对原始上下文的序列化。
- en: This brings us to the question of whether there is a scenario that needs to
    use `ConfigureAwait(true)`. The answer is that there are scenarios where a custom
    `SynchronizationContext` is being built that needs to be used by a callback, and
    it is then recommended to use `ConfigureAwait(true)`, or at least not use `ConfigureAwait(false)`,
    as the default behavior of any task is the same as `ConfigureAwait(true)`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题，即是否存在需要使用 `ConfigureAwait(true)` 的场景。答案是，确实存在一些场景，其中正在构建一个自定义的 `SynchronizationContext`，该上下文需要被回调使用，这时建议使用
    `ConfigureAwait(true)`，或者至少不要使用 `ConfigureAwait(false)`，因为任何任务的默认行为都是与 `ConfigureAwait(true)`
    相同的。
- en: CPU-bound versus I/O-bound
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU 密集型与 I/O 密集型
- en: Always use async-await for I/O-bound work and the TPL for CPU-bound work to
    achieve asynchrony. I/O operations such as database calls, network calls, and
    filesystem calls can be wrapped in async-await asynchronous methods. However,
    a CPU-intensive operation such as calculating pi is better handled using the TPL.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用 async-await 来处理 I/O 密集型工作，使用 TPL 来处理 CPU 密集型工作以实现异步。例如，数据库调用、网络调用和文件系统调用等
    I/O 操作可以封装在 async-await 异步方法中。然而，像计算 π 这样的 CPU 密集型操作最好使用 TPL 来处理。
- en: Going back to our earlier discussion, the idea of asynchronous programming is
    to release `ThreadPool` threads instead of waiting on the completion of an operation.
    This can very easily be achieved when we represent outbound calls as tasks and
    use async-await.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的讨论，异步编程的想法是释放 `ThreadPool` 线程而不是等待操作的完成。当我们将出站调用表示为任务并使用 async-await
    时，这可以非常容易地实现。
- en: However, for a CPU-intensive operation, a `ThreadPool` thread will continue
    to execute instructions on the worker thread (as it is a CPU-intensive operation
    and needs CPU time) and obviously cannot release that thread. This means that
    wrapping a CPU-intensive operation in async-await is not going to yield any benefit
    and is the same as running it synchronously. So, a better way to handle CPU-intensive
    operations is by using the TPL.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 CPU 密集型操作，`ThreadPool` 线程将继续在工作者线程上执行指令（因为它是一个 CPU 密集型操作，需要 CPU 时间），显然不能释放该线程。这意味着将
    CPU 密集型操作封装在 async-await 中不会带来任何好处，并且与同步运行相同。因此，处理 CPU 密集型操作的一个更好的方法是使用 TPL。
- en: This does not mean we will stop using async-await the moment we encounter a
    CPU-intensive method. The recommended way is to still use async-await to manage
    CPU-bound operations along with the TPL and not break our first principle of using
    async-await all the way.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们遇到 CPU 密集型方法时就会停止使用 async-await。推荐的方式是仍然使用 async-await 来管理 CPU 密集型操作，同时使用
    TPL，并且不要打破我们使用 async-await 的第一条原则。
- en: 'Here is a simple code snippet using async-await to manage CPU-bound work:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 async-await 来管理 CPU 密集型工作的简单代码片段：
- en: '[PRE266]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: As seen in the preceding code, it's still possible to manage CPU-bound work
    with a mix of async-await and the TPL; it's up to the developer to assess all
    the possible options and write their code accordingly.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，仍然可以使用 async-await 和 TPL 的组合来管理 CPU 密集型工作；这取决于开发者评估所有可能的选项并相应地编写代码。
- en: Avoid async void
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用 async void
- en: Always make sure to have `Task` or `Task<T>` as the return type for an asynchronous
    method implemented using async-await instead of `void` if a method is not expected
    to return anything. The reason for this is that `Task` is a complex abstraction
    that handles many things for us, such as exception handling and task completion
    status. However, if an asynchronous method has an `async` `void` return type,
    it is like a fire-and-forget method, and any caller to this method won't be able
    to know the status of the operation, even if there is an exception.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 总是确保使用 `Task` 或 `Task<T>` 作为使用 async-await 实现的异步方法的返回类型，而不是 `void`，如果方法预期不会返回任何内容。原因是
    `Task` 是一个复杂的抽象，为我们处理了许多事情，例如异常处理和任务完成状态。然而，如果一个异步方法有 `async` `void` 返回类型，它就像是一个“点火后忘掉”的方法，任何调用此方法的调用者都无法知道操作的状态，即使有异常发生。
- en: That is because inside an `async` `void` method, as soon as an `await` expression
    is encountered, the call is returned to the caller without any reference to `Task`,
    so there is no reference to raise an exception for. For a UI application such
    as WPF, any exceptions on the `async` `void` method will crash the application;
    however, an exception for this is `async` `void` event handlers.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 `async` `void` 方法内部，一旦遇到 `await` 表达式，调用就会返回给调用者，没有任何关于 `Task` 的引用，因此没有引用可以抛出异常。对于像
    WPF 这样的 UI 应用程序，`async` `void` 方法上的任何异常都会导致应用程序崩溃；然而，对于 `async` `void` 事件处理器来说，这是一个例外。
- en: Another disadvantage with `async` `void` methods is the inability to write unit
    tests and assert them correctly. So, it's always recommended to use async `Task`
    exceptions as top-level event handlers (top-level is key here) because top-level
    events such as a button click or a mouse click are more of a one-way signal and
    are not used any differently in asynchronous code compared to their synchronous
    counterparts.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` `void` 方法的另一个缺点是无法编写单元测试并正确断言。因此，始终建议使用 `async Task` 异常作为顶级事件处理器（顶级事件在这里是关键），因为顶级事件，如按钮点击或鼠标点击，更多的是单向信号，并且在异步代码中与它们的同步对应物没有不同的使用方式。'
- en: 'The same consideration needs to be taken in the case of `async` Lambdas, where
    we need to avoid passing them as an argument to a method that takes the `Action`
    type as its parameters. See the following example:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `async` Lambda 的情况下，也需要考虑相同的因素，我们需要避免将它们作为参数传递给接受 `Action` 类型的参数的方法。以下是一个示例：
- en: '[PRE283]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Here, it''s expected that the value of `elapsedTime` will be somewhere around
    10,000\. However, it''s close to 100 for the same reason – that is, with `Action`
    being a delegate of the `void` return type, the call to `AsyncLambda` is returned
    immediately to the `Main` method (as with any `async` `void` method). This can
    be fixed by changing `AsyncLambda` as follows (or just by changing the parameter
    to `Func<Task>` and handling the wait on `a()` accordingly) and then forcing the
    caller to use `async` all the way:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，预期 `elapsedTime` 的值将在 10,000 左右。然而，它接近 100 的原因相同——那就是，由于 `Action` 是 `void`
    返回类型的委托，对 `AsyncLambda` 的调用会立即返回到 `Main` 方法（就像任何 `async` `void` 方法一样）。这可以通过如下修改
    `AsyncLambda` 来修复（或者只需将参数更改为 `Func<Task>` 并相应地处理 `a()` 的等待），然后强制调用者一路使用 `async`：
- en: '[PRE299]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: A word of caution – if there are methods in your application that accept the
    `Action` type parameters, it's recommended that you have an overload that accepts
    `Func<Task>` or `Func<Task<T>>`. Fortunately, the C# compiler automatically handles
    this and always calls the overload with `Func<Task>` as a parameter.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 注意——如果你的应用程序中有接受 `Action` 类型参数的方法，建议你有一个接受 `Func<Task>` 或 `Func<Task<T>>` 的重载。幸运的是，C#
    编译器自动处理这一点，并且始终调用带有 `Func<Task>` 参数的重载。
- en: Tip
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the Visual Studio 2022 Exception Helper feature to debug `async` exceptions
    that are rethrown by framework code.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022 异常助手功能来调试框架代码重新抛出的 `async` 异常。
- en: Async streams with IAsyncEnumerable
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IAsyncEnumerable 的异步流
- en: 'We all know that `foreach` is used to loop over `IEnumerable<T>` or `IEnumerator<T>`.
    Let''s look at the following code, in which we retrieve all employee IDs from
    a database and loop through each employee to print their ID:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道 `foreach` 用于遍历 `IEnumerable<T>` 或 `IEnumerator<T>`。让我们看看以下代码，其中我们从数据库中检索所有员工
    ID 并遍历每个员工以打印他们的 ID：
- en: '[PRE309]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'The `GetEmployeeIDAsync` implementation is as follows:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetEmployeeIDAsync` 的实现如下：'
- en: '[PRE318]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'Here, you can see that we must use a temporary list until we have received
    all the records from the database, and finally, we return the list. However, if
    there is an iterator in our method, `yield` in C# is an obvious choice, as that
    helps in returning the results immediately and avoiding temporary variables. Now,
    say you used `yield`, as shown in the following code:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们必须使用一个临时列表，直到我们从数据库中接收到所有记录，然后最终返回这个列表。然而，如果我们的方法中有一个迭代器，C# 中的 `yield`
    就是一个明显的选择，因为它有助于立即返回结果并避免使用临时变量。现在，假设你使用了 `yield`，如下面的代码所示：
- en: '[PRE332]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'You would receive the following error upon compilation:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时你会收到以下错误：
- en: '[PRE333]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Hence, there is a need to be able to use `yield` with an `async` method and
    also loop through a collection to call an application asynchronously. That''s
    where C# 8.0 came up with asynchronous streams through `IAsyncEnumerable`, which
    primarily enables you to return data immediately and asynchronously consume a
    collection. So, the preceding code can be changed as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要能够使用 `yield` 与 `async` 方法一起，并且循环遍历集合以异步调用应用程序。这就是 C# 8.0 通过 `IAsyncEnumerable`
    提出异步流的原因，它主要允许你立即返回数据并异步消费集合。因此，前面的代码可以修改如下：
- en: '[PRE334]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: So, here you can see that once a method starts returning, `IAsyncEnumerable`
    loops can be iterated asynchronously, and this is helpful in many situations to
    write cleaner code.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里你可以看到一旦一个方法开始返回，`IAsyncEnumerable` 循环可以异步迭代，这在许多情况下有助于编写更干净的代码。
- en: ThreadPool starvation
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程池饥饿
- en: Say you have an application with asynchronous code. However, you have noticed
    that periodically, during high loads, the response time for requests drastically
    increases. You research it further, but neither is the CPU of your server fully
    utilized nor is the memory of your process high, and it isn't a case of your database
    becoming a bottleneck either. In this case, your application is possibly causing
    what is known as `ThreadPool` starvation.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含异步代码的应用程序。然而，你注意到在高负载期间，请求的响应时间会急剧增加。你进一步研究这个问题，但你的服务器的CPU并没有完全利用，你的进程的内存也没有很高，而且这也不是数据库成为瓶颈的情况。在这种情况下，你的应用程序可能正在导致所谓的`ThreadPool`饥饿。
- en: '`ThreadPool` starvation is a state in which new threads keep being added to
    serve concurrent requests, and eventually, a point is reached where `ThreadPool`
    is unable to add more threads, and requests start seeing delayed response times
    or even start failing in the worst-case scenario. Even if `ThreadPool` can add
    threads at a rate of one or two per second, new requests may be coming at a higher
    rate (as in a burst load on a web application during the holiday season). Hence,
    there is a significant increase in the response time. There are multiple reasons
    why this can happen; a few of them are listed here:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`饥饿是一种状态，其中新线程不断被添加以服务并发请求，最终达到一个点，`ThreadPool`无法添加更多线程，请求开始看到延迟的响应时间，在最坏的情况下甚至开始失败。即使`ThreadPool`可以以每秒一两个线程的速度添加线程，新的请求也可能以更高的速率到来（例如，在假日季节网络应用程序的突发负载期间）。因此，响应时间显著增加。这种情况发生的原因有很多，这里列出了一些：'
- en: The consumption of more threads to speed up long-running CPU-bound work
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗更多线程以加快长时间运行的CPU密集型工作
- en: The calling of an `async` method in a `sync` method using `GetAwaiter().GetResult()`
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`sync`方法中使用`GetAwaiter().GetResult()`调用`async`方法
- en: The incorrect use of synchronization primitives, such as a thread holding a
    lock for a long time and other threads waiting to acquire it
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误使用同步原语，例如一个线程长时间持有锁，而其他线程等待获取它
- en: In all the preceding points, the common thing is blocking code; so, the use
    of blocking code such as `Thread.Sleep` even for a short duration, something such
    as `GetAwaiter().GetResult()`, or trying to allocate more threads for a CPU-bound
    item increases the number of threads in `ThreadPool` and eventually leads to starvation.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的点中，共同点是阻塞代码；因此，即使是短暂的阻塞代码，如`Thread.Sleep`，或者像`GetAwaiter().GetResult()`这样的操作，或者尝试为CPU密集型项分配更多线程，都会增加`ThreadPool`中的线程数量，并最终导致饥饿。
- en: '`ThreadPool` starvation can be further diagnosed using tools such as **PerfView**,
    where you capture a trace for, say, 200 seconds, and verify the growth of threads
    in your process. If you see that your threads are growing at a rapid pace during
    peak load, then there is a possibility of starvation.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**PerfView**等工具进一步诊断`ThreadPool`饥饿，例如捕获200秒的跟踪，并验证你进程中线程的增长情况。如果在高峰负载期间看到你的线程以快速的速度增长，那么可能存在饥饿的情况。
- en: The best way to prevent `ThreadPool` starvation is to use async-await throughout
    the application and never block any `async` calls. Also, the throttling of newly
    created operations can help, as it restricts the number of items that can be queued
    at a time.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 防止`ThreadPool`饥饿的最佳方法是在整个应用程序中使用`async-await`，并且永远不要阻塞任何`async`调用。此外，限制新创建的操作的节流也可以帮助，因为它限制了一次可以排队多少项。
- en: In this section, we discussed two important constructs, async-await and the
    TPL, which when combined make writing asynchronous code simpler. In the next section,
    we will learn about various data structures that are available in .NET 6 to support
    synchronization/thread safety without writing any additional code.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了两个重要的结构，`async-await`和TPL，当它们结合使用时，可以简化异步代码的编写。在下一节中，我们将学习.NET 6中可用的各种数据结构，这些数据结构可以支持同步/线程安全，而无需编写任何额外的代码。
- en: Using concurrent collections for parallelism
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发集合实现并行化
- en: Collections classes are one of the most used types to encapsulate, retrieve,
    and modify enumerated sets of related data. `Dictionary`, `list`, `queue`, and
    `array` are some of the frequently used collection types, but they are not thread-safe.
    These collections are good if you access them from just one thread at a time.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类是最常用的类型之一，用于封装、检索和修改相关数据的枚举集合。`Dictionary`、`list`、`queue`和`array`是一些常用的集合类型，但它们不是线程安全的。如果你一次只从一个线程访问它们，这些集合是好的。
- en: A real-world environment would be multithreaded, and to make it thread-safe,
    you will have to implement various synchronization constructs, as described in
    an earlier section. To solve this problem, Microsoft came up with concurrent collection
    classes, such as `ConcurrentQueue`, `ConcurrentBag`, `ConcurrentDictionary`, and
    `ConcurrentStack`, which are thread-safe, as they internally implement synchronization.
    Let's look at them in detail in the following sections.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，环境将是多线程的，为了使其线程安全，你必须实现各种同步构造，如前文所述。为了解决这个问题，Microsoft 提出了并发集合类，例如 `ConcurrentQueue`、`ConcurrentBag`、`ConcurrentDictionary`
    和 `ConcurrentStack`，它们是线程安全的，因为它们内部实现了同步。让我们在以下章节中详细探讨它们。
- en: ConcurrentDictionary
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentDictionary
- en: Let's stimulate a multithreaded environment using a dictionary. Consider the
    `t1` task as one operation from a client who is adding to the dictionary and the
    `t2` task as a second operation from another client who is reading from the dictionary.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用字典来模拟一个多线程环境。将 `t1` 任务视为一个客户端向字典添加操作的第一个操作，将 `t2` 任务视为另一个客户端从字典读取的第二个操作。
- en: 'We add `Thread.Sleep` in each task to mimic a real-world scenario to ensure
    that one task doesn''t complete before the other in this example. Let''s consider
    an example console application with the following code snippet:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个任务中添加 `Thread.Sleep` 来模拟现实场景，确保在这个例子中一个任务不会在另一个任务完成之前完成。让我们考虑一个具有以下代码片段的示例控制台应用程序：
- en: '[PRE350]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'This is `Task` `t2` as a second operation from another client who is reading
    from the dictionary:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从另一个客户端读取字典的第二个操作 `Task t2`：
- en: '[PRE361]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'Now, both tasks are executed at the same time, as shown in the following:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个任务同时执行，如下所示：
- en: '[PRE371]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'When you run this program, you will get the following exception, which states
    that you cannot modify and enumerate the collection at the same time:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会得到以下异常，指出你不能同时修改和枚举集合：
- en: '![Table 4.2 – The ConcurrentDictionary sample output'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.2 – ConcurrentDictionary 示例输出'
- en: '](img/Table_4.2.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_4.2.jpg)'
- en: Table 4.2 – The ConcurrentDictionary sample output
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 – ConcurrentDictionary 示例输出
- en: 'You may think now that we can add a lock to manage thread synchronization and
    avoid this exception in multithreaded scenarios for thread safety. I added a lock
    to the code wherever the dictionary is modified and enumerated to synchronize
    the threads. Here are the updated code snippets:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能认为我们可以添加一个锁来管理线程同步，以避免在多线程场景中发生这种异常。我在代码中修改和枚举字典的地方添加了一个锁来同步线程。以下是更新的代码片段：
- en: 'First, we have `Task` `t1` as one operation from a client who is adding to
    the dictionary:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有 `Task` `t1` 作为向字典添加操作的客户端的一个操作：
- en: '[PRE381]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'Then, we have `Task` `t2` as a second operation from another client who is
    reading from the dictionary:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有 `Task` `t2` 作为另一个客户端从字典读取的第二个操作：
- en: '[PRE382]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Now, we have both tasks executed at the same time:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们同时执行了两个任务：
- en: '[PRE383]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE383]'
- en: When you run this code, you will not see any exceptions. However, locks have
    some issues, as mentioned earlier, so this code can be rewritten using concurrent
    collections. They internally use a multiple-thread synchronization technique that
    helps to scale well, prevent data corruption, and avoid all the problems with
    locks.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你不会看到任何异常。然而，正如之前提到的，锁有一些问题，因此这段代码可以使用并发集合重写。它们内部使用多线程同步技术，有助于扩展，防止数据损坏，并避免所有与锁相关的问题。
- en: 'We can rewrite our code using `ConcurrentDictionary`, which is available in
    the `System.Collections.Concurrent` namespace. Replace `Dictionary` with `ConcurrentDictionary`
    in the sample code. You can also remove the reference to the `System.Collections.Generic`
    namespace, as `Dictionary` is not used now. Also, remove all the locks. The updated
    code is as follows, where we replace `Dictionary` with `ConcurrentDictionary`
    and remove the lock:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ConcurrentDictionary` 重写我们的代码，它位于 `System.Collections.Concurrent` 命名空间中。在示例代码中将
    `Dictionary` 替换为 `ConcurrentDictionary`。你也可以删除对 `System.Collections.Generic` 命名空间的引用，因为现在不再使用
    `Dictionary`。此外，删除所有锁。更新的代码如下，其中我们将 `Dictionary` 替换为 `ConcurrentDictionary` 并删除锁：
- en: 'We have `Task t1` as one operation from a client who is adding to the dictionary,
    and an explicit lock is not needed with concurrent collections:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `Task t1` 作为向字典添加操作的客户端的一个操作，并且与并发集合一起不需要显式的锁：
- en: '[PRE384]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'Then, we have `Task t2` as a second operation from another client who is reading
    from the dictionary, and an explicit lock is not needed with concurrent collections:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们还有`Task t2`作为来自另一个客户端的第二个操作，该客户端正在从字典中读取，并且在使用并发集合时不需要显式锁：
- en: '[PRE385]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'Now, both tasks are executed at the same time:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这两个任务同时执行：
- en: '[PRE386]'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'When you run the program now, you will not get any exceptions, as all operations
    are thread-safe and atomic in `ConcurrentDictionary`. There is no overhead for
    the developer in implementing the locks and maintaining them as the project grows
    bigger. Here are some caveats with concurrent collections such as `ConcurrentDictionary`
    that you need to bear in mind:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行程序时，你将不会遇到任何异常，因为所有操作在`ConcurrentDictionary`中都是线程安全且原子的。随着项目的扩大，开发者无需为实现锁和维持锁而承担任何开销。以下是一些关于如`ConcurrentDictionary`之类的并发集合的注意事项，你需要牢记：
- en: If two threads call `AddOrUpdate`, there's no guarantee which of the factory
    delegates will be called and even no guarantee that if a factory delegate produces
    an item, the item will be stored in the dictionary.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个线程调用`AddOrUpdate`，无法保证哪个工厂委托将被调用，甚至无法保证如果工厂委托生成了一个项，该项是否会被存储在字典中。
- en: The enumerator obtained by the `GetEnumerator` call is not a snapshot and may
    be modified during enumeration (which doesn't cause any exceptions).
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`GetEnumerator`调用获得的枚举器不是一个快照，枚举过程中可能会对其进行修改（这不会引发任何异常）。
- en: Key and value properties are snapshots of corresponding collections and may
    not correspond to the actual dictionary state.
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键和值属性是对应集合的快照，可能不对应实际的字典状态。
- en: We've looked at `ConcurrentDictionary` in detail; let's look at other concurrent
    collections in the next section.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细地研究了`ConcurrentDictionary`；让我们在下一节中看看其他并发集合。
- en: Producer-consumer concurrent collections
  id: totrans-752
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产者-消费者并发集合
- en: In producer-consumer concurrent collections, one or more threads can produce
    tasks (adding to a queue, stack, or bag, for instance), and one or more other
    threads can consume tasks from the same collection (the queue, stack, or bag).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者-消费者并发集合中，一个或多个线程可以生产任务（例如，向队列、栈或包中添加），一个或多个其他线程可以从同一个集合（队列、栈或包）中消费任务。
- en: '`ConcurrentDictionary`, which we saw in the previous section, is a general-purpose
    collection class where you add an item that you want and specify which item you
    want to read. Other concurrent collections are designed for specific problems:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中看到的`ConcurrentDictionary`是一个通用集合类，你可以添加你想要的项并指定你想要读取的项。其他并发集合是为特定问题设计的：
- en: '`ConcurrentQueue` is for scenarios where you want FIFO.'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentQueue`适用于需要FIFO（先进先出）的场景。'
- en: '`ConcurrentStack` is for scenarios where you want LIFO.'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentStack`适用于需要LIFO（后进先出）的场景。'
- en: '`ConcurrentBag` is for scenarios where you want the same thread producing and
    consuming data stored in the bag and the order doesn''t matter.'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentBag`适用于需要同一线程生产并消费存储在包中的数据，且顺序不重要的场景。'
- en: 'These three collections are also known as **producer-consumer collections**,
    where one or more threads can produce tasks and consume tasks from the same collection,
    as shown in the following figure:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个集合也被称为**生产者-消费者集合**，其中一个或多个线程可以生产任务并从同一个集合中消费任务，如下面的图所示：
- en: '![Figure 4.7 – A producer-consumer concurrent collection'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 生产者-消费者并发集合'
- en: '](img/Figure_4.7_B18507.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B18507.jpg)'
- en: Figure 4.7 – A producer-consumer concurrent collection
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 生产者-消费者并发集合
- en: 'All these three collections implement the `IProducerConsumerCollection<T>`
    interface, and the most important methods are `TryAdd` and `TryTake`, as shown
    here:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个集合都实现了`IProducerConsumerCollection<T>`接口，最重要的方法是`TryAdd`和`TryTake`，如下所示：
- en: '[PRE387]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'Let''s take an example of a producer-consumer and simulate it using `ConcurrentQueue`:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个生产者-消费者为例，并使用`ConcurrentQueue`来模拟它：
- en: '**Producer**: A client sending a request to a web service and the server storing
    a request in a queue'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：向网络服务发送请求的客户端和将请求存储在队列中的服务器。'
- en: '**Consumer**: A worker thread pulling the request from the queue and processing
    it'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：一个工作线程从队列中拉取请求并处理它。'
- en: 'The implementation is shown in the following code:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下所示：
- en: '[PRE391]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'Now, we have `Consumer`, where a `Worker` thread pulls the request from the
    queue and processes it:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有`Consumer`，其中`Worker`线程从队列中拉取请求并处理它：
- en: '[PRE404]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'Both producer and consumer tasks are executed at the same time successfully.
    Wait for all provided tasks to complete execution within the specified number
    of milliseconds. Refer to the following code snippet:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者和消费者任务同时成功执行。等待所有提供的任务在指定的毫秒数内完成执行。请参考以下代码片段：
- en: '[PRE420]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'This is according to the method definition from Microsoft:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 这是根据微软的方法定义：
- en: '`concurrentQueue.Enqueue`: This adds an object to the end of `ConcurrentQueue<T>`.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrentqueue.Enqueue`：这会将一个对象添加到 `ConcurrentQueue<T>` 的末尾。'
- en: '`concurrentQueue.TryDequeue`: This tries to remove and return the object at
    the beginning of `ConcurrentQueue`.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrentqueue.TryDequeue`：这尝试从 `ConcurrentQueue` 的开头移除并返回对象。'
- en: 'When you run the program, you can see `task` `t1` producing requests and `task`
    `t2` polling and then consuming requests. We''ll get into the details in a short
    while. We also said that these classes implement `IProducerConsumerCollection<T>`,
    so we are going to make three changes to the previous code:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你可以看到 `task` `t1` 正在生成请求，而 `task` `t2` 正在轮询然后消费请求。我们将在稍后深入了解。我们还提到，这些类实现了
    `IProducerConsumerCollection<T>`，因此我们将对之前的代码进行三项更改：
- en: Replace `ConcurrentQueue<string>` with `IProducerConsumerCollection<string>`.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `ConcurrentQueue<string>` 替换为 `IProducerConsumerCollection<string>`。
- en: Replace `concurrentQueue.Enqueue` with `concurrentQueue.TryAdd`.
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `concurrentqueue.Enqueue` 替换为 `concurrentqueue.TryAdd`。
- en: Replace `concurrentQueue.TryDequeue` with `concurrentQueue.TryTake`.
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `concurrentQueue.TryDequeue` 替换为 `concurrentQueue.TryTake`。
- en: 'This is how the code looks now:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码现在的样子：
- en: '[PRE428]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'Now, go ahead and run the program. You can see `task` `t1` producing requests
    and `task` `t2` polling and then consuming requests. You can see all 10 requests
    produced by `task` `t1` and consumed by `task` `t2`. But there are two problems:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续运行程序。你可以看到 `task` `t1` 正在生成请求，而 `task` `t2` 正在轮询然后消费请求。你可以看到 `task` `t1`
    生成的所有 10 个请求都被 `task` `t2` 消费。但是有两个问题：
- en: The producer is producing at its own rate, the consumer is consuming at its
    own rate, and there is no synchronization.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者以自己的速率生产，消费者以自己的速率消费，并且没有同步。
- en: There is continuous indefinite polling from the consumer in `task` `t2`, which
    is not good for performance and CPU usage, as we can see by `concurrentQueue.TryTake`.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `task` `t2` 中，消费者进行了连续的不定轮询，这对性能和CPU使用率不利，正如我们通过 `concurrentqueue.TryTake`
    看到的。
- en: This is where `BlockingCollection<T>` comes in handy.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `BlockingCollection<T>` 发挥作用的地方。
- en: The BlockingCollection<T> class
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>` 类'
- en: '`BlockingCollection<T>` supports bounding and blocking. Bounding allows you
    to specify a maximum capacity for a collection. Controlling the maximum size of
    a collection helps to prevent producing threads from moving too far ahead of consuming
    threads. Multiple producing threads can add items to `BlockingCollection<T>` concurrently
    until the collection reaches its maximum size, after which they will be blocked
    until an item is removed by consumers.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>` 支持边界和阻塞。边界允许你为集合指定一个最大容量。控制集合的最大大小有助于防止生产线程比消费线程提前太多。多个生产线程可以并发地向
    `BlockingCollection<T>` 添加项目，直到集合达到其最大大小，之后它们将被阻塞，直到消费者移除一个项目。'
- en: Similarly, multiple consuming threads can remove items from a blocking collection
    concurrently till the collection becomes empty, after which they will be blocked
    until an item is added by producers. A producing thread can invoke the `CompleteAdding`
    method when no more items will be added and indicate that it has completed adding.
    This will help consumers to monitor the `IsCompleted` property to know that no
    more items will be added when the collection is empty.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，多个消费线程可以并发地从阻塞集合中移除项目，直到集合变为空，之后它们将被阻塞，直到生产者添加一个项目。当没有更多项目添加时，生产线程可以调用 `CompleteAdding`
    方法，并指示它已完成添加。这将帮助消费者监控 `IsCompleted` 属性，以了解当集合为空时不再添加更多项目。
- en: When you create a `BlockingCollection<T>` class, along with the bounding capacity,
    you can also specify the type of concurrent collection to use depending upon the
    scenario. By default, the collection type is `ConcurrentQueue<T>` for `BlockingCollection<T>`
    when you don't specify the type.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 `BlockingCollection<T>` 类时，除了边界容量外，你还可以根据场景指定要使用的并发集合类型。默认情况下，当你不指定类型时，`BlockingCollection<T>`
    的集合类型是 `ConcurrentQueue<T>`。
- en: 'Here is a sample code snippet:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例代码片段：
- en: '[PRE444]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: 'Then, the consumer with the `Worker` thread pulls the item from the queue and
    processes it:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，具有 `Worker` 线程的消费线程从队列中拉取项目并处理它：
- en: '[PRE457]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: Now, the producer and consumer thread are accessed concurrently.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生产者和消费者线程可以并发访问。
- en: 'There are a few points to consider in the code:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中需要考虑以下几点：
- en: 'The specified bounding of `5`: `BlockingCollection<string> blockingCollection
    = new BlockingCollection<string>(new ConcurrentQueue<string>(),5);`.'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的边界为 `5`：`BlockingCollection<string> blockingCollection = new BlockingCollection<string>(new
    ConcurrentQueue<string>(),5);`。
- en: 'The producing thread invokes the `CompleteAdding` method when no more items
    will be added to indicate that it has completed adding: `blockingCollection.CompleteAdding();`.'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再添加更多项目时，生产者线程调用 `CompleteAdding` 方法以指示它已完成添加：`blockingCollection.CompleteAdding();`。
- en: 'Consumers monitor the `IsCompleted` property to find out that no more items
    will be added when the collection is empty: `while (!blockingCollection.IsCompleted)`.'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者监控 `IsCompleted` 属性以确定当集合为空时不再添加更多项目：`while (!blockingCollection.IsCompleted)`。
- en: 'Try to remove an item from `BlockingCollection<T>` in the specified time –
    for example, I have gone with 100 milliseconds: `if (blockingCollection.TryTake(out
    string request, 100))`.'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在指定时间内从 `BlockingCollection<T>` 中移除一个项目——例如，我选择了 100 毫秒：`if (blockingCollection.TryTake(out
    string request, 100))`。
- en: This is the power of a blocking collection. Both the producer and consumer are
    decoupled, they can be coded independently by different teams, and at runtime,
    they use a blocking concurrent collection to share data with each other. Plus,
    at the same time, flow is controlled with the bounding capacity so that the producer
    doesn't move too far ahead of consumers.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是阻塞集合的力量。生产者和消费者都是解耦的，它们可以由不同的团队独立编码，在运行时，它们使用阻塞并发集合相互共享数据。此外，同时，通过边界容量控制流量，以确保生产者不会比消费者领先太多。
- en: Note
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In addition to the `TryTake` method that we''ve seen, you can also use a `foreach`
    loop to remove items from a blocking collection. You can read about it here:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们看到的 `TryTake` 方法之外，你还可以使用 `foreach` 循环从阻塞集合中移除项目。你可以在这里了解相关信息：
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-use-foreach-to-remove](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-use-foreach-to-remove)'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-use-foreach-to-remove](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-use-foreach-to-remove)'
- en: 'With blocking collections, there will be scenarios where the consumer will
    have to work with multiple collections and take or add items. The `TakeFromAny`
    and `AddToAny` methods will help you in this scenario. You can read further about
    these two methods here:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在阻塞集合中，可能会出现消费者需要与多个集合一起工作并取或添加项目的情况。`TakeFromAny` 和 `AddToAny` 方法将帮助你在这种情况下。你可以在这里进一步了解这两个方法：
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.takefromany?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.takefromany?view=net-6.0)'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.takefromany?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.takefromany?view=net-6.0)'
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.addtoany?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.addtoany?view=net-6.0)'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.addtoany?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1.addtoany?view=net-6.0)'
- en: Summary
  id: totrans-886
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wrapping up, writing, and maintaining clean asynchronous code is difficult.
    However, with the various constructs available in .NET and C#, developers can
    now write asynchronous code with less framework overhead and focus more on the
    business requirements.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，编写和维护干净的异步代码是困难的。然而，随着 .NET 和 C# 中可用的各种构造，开发者现在可以以更少的框架开销编写异步代码，并更多地关注业务需求。
- en: In this chapter, we covered various ways to write scalable asynchronous code
    using the TPL, async-await, and concurrent collections, and we also covered the
    fundamentals of threads and `ThreadPool` in .NET to understand the framework internals
    and write cleaner code for enterprise applications. Now, we have a deeper understanding
    of multithreading and how to protect shared data in a multithreaded environment.
    We learned about creating tasks and implementing asynchronous functions using
    async-await, and finally, we learned about the concurrent collections available
    in .NET Core and their implementation in various concurrent scenarios.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 TPL、async-await 和并发集合编写可扩展异步代码的各种方法，我们还介绍了 .NET 中线程和 `ThreadPool`
    的基础知识，以了解框架内部结构并为企业应用程序编写更干净的代码。现在，我们对多线程以及如何在多线程环境中保护共享数据有了更深入的了解。我们学习了如何创建任务和实现使用
    async-await 的异步函数，最后，我们学习了 .NET Core 中可用的并发集合及其在各种并发场景中的应用。
- en: In the next chapter, we will look into dependency injection in .NET 6 and how
    it plays a significant role in loosely coupling various low-level classes in enterprise
    applications.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 .NET 6 中的依赖注入及其在松耦合企业应用程序中的各种底层类中发挥的重要作用。
- en: Questions
  id: totrans-890
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In a multithreaded environment, which of the following data structures should
    you use to protect data from getting overwritten/corrupted?
  id: totrans-891
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多线程环境中，以下哪个数据结构应该用来保护数据不被覆盖/损坏？
- en: a. `async`-`await`.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: a. `async`-`await`.
- en: b. Tasks.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: b. 任务。
- en: c. Synchronization constructs such as locks.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: c. 同步结构，如锁。
- en: d. Data never gets corrupted.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: d. 数据永远不会损坏。
- en: '**Answer : a**'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: If you have a WPF application that retrieves data from a REST API, which of
    the following should you implement for better responsiveness?
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个从 REST API 获取数据的 WPF 应用程序，以下哪个应该实现以获得更好的响应性？
- en: a. A concurrent collection
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: a. 并发集合
- en: b. `Parallel.For`
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: b. `Parallel.For`
- en: c. `async`-`await` for the REST API calls
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: c. `async`-`await` 用于 REST API 调用
- en: '**Answer: c**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: Which of the following should be passed to cancel a task?
  id: totrans-902
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个应该传递以取消任务？
- en: a. `CancellationToken`
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: a. `CancellationToken`
- en: b. `ConcurrentDictionary`
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: b. `ConcurrentDictionary`
- en: c. `SemaphoreSlim`
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: c. `SemaphoreSlim`
- en: '**Answer: a**'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: Which of the following is the recommended return type for an asynchronous method
    that uses async-await and does not return anything?
  id: totrans-907
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是使用 async-await 且不返回任何内容的异步方法的推荐返回类型？
- en: a. `async void`
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: a. `async void`
- en: b. `async Task`
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: b. `async Task`
- en: c. `async book`
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: c. `async book`
- en: d. `async Task<bool>`
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: d. `async Task<bool>`
- en: '**Answer: b**'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: Further reading
  id: totrans-913
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/product/hands-on-parallel-programming-with-c-8-and-net-core-3/9781789132410](https://www.packtpub.com/product/hands-on-parallel-programming-with-c-8-and-net-core-3/9781789132410)'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/hands-on-parallel-programming-with-c-8-and-net-core-3/9781789132410](https://www.packtpub.com/product/hands-on-parallel-programming-with-c-8-and-net-core-3/9781789132410)'
- en: '[https://devblogs.microsoft.com/dotnet/configureawait-faq/](https://devblogs.microsoft.com/dotnet/configureawait-faq/)'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/configureawait-faq/](https://devblogs.microsoft.com/dotnet/configureawait-faq/)'
- en: '[http://www.albahari.com/threading/](http://www.albahari.com/threading/)'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.albahari.com/threading/](http://www.albahari.com/threading/)'
- en: '*Dataflow (Task Parallel Library) | Microsoft Docs*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library)'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据流（任务并行库）| Microsoft Docs*：[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library)'
