<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-355"><a id="_idTextAnchor354"/>17</h1>
<h1 id="_idParaDest-356"><a id="_idTextAnchor355"/>Agile Refactoring</h1>
<p>In this final chapter, we’ll talk about refactoring as part of an <em class="italic">agile</em> team, succeeding with larger refactoring efforts, recovering when things go wrong, and incorporating deployment strategies to help make sure they don’t go wrong again.</p>
<p>It’s possible to win many small refactoring battles with small pieces of offending code but lose the overall “war” when you can’t address large-scale design issues. This chapter explores how to continue to fight and win the smaller refactoring battles with your code from sprint to sprint. We will also cover the larger strategic battle of making sure your application has the right design – and correct it to something better when it doesn’t.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Refactoring in an agile environment</li>
<li>Succeeding with agile refactoring strategies</li>
<li>Accomplishing large-scale refactorings</li>
<li>Recovering when refactoring goes wrong</li>
<li>Deploying large-scale refactorings</li>
</ul>
<h1 id="_idParaDest-357"><a id="_idTextAnchor356"/>Refactoring in an agile environment</h1>
<p>Almost all development <a id="_idIndexMarker953"/>teams I work with use some form of <strong class="bold">agile software development</strong> to manage work over time in the form of short sprints, including any <a id="_idIndexMarker954"/>refactoring work.</p>
<p>In this section, we’ll cover the basics of agile workflows and how refactoring can fit into this type of environment. This is important because if refactoring work can’t fit into an agile workflow, refactoring simply won’t happen.</p>
<h2 id="_idParaDest-358"><a id="_idTextAnchor357"/>Key elements of agile teams</h2>
<p>Agile <a id="_idIndexMarker955"/>software development was officially codified in the <em class="italic">Manifesto for Agile Software Development </em>(commonly<a id="_idIndexMarker956"/> called the <em class="italic">Agile Manifesto</em>) and flows from the following core preferences:</p>
<ul>
<li><strong class="bold">Individuals and interactions</strong> over processes and tools</li>
<li><strong class="bold">Working software</strong> over comprehensive documentation</li>
<li><strong class="bold">Customer collaboration</strong> over contract negotiation</li>
<li><strong class="bold">Responding to change</strong> over following a plan</li>
</ul>
<p>Following these guiding principles, the exact “flavor” of agile differs from team to team, but most teams adopt the following key components:</p>
<ul>
<li><strong class="bold">Sprints</strong>: Work<a id="_idIndexMarker957"/> is conducted during fixed-duration periods called sprints. These range anywhere from 1 to 4 weeks, but 2 weeks is the norm.</li>
<li><strong class="bold">User stories</strong>: Work<a id="_idIndexMarker958"/> is tracked in the form of work items or user stories. Many teams require that any code change be associated with at least one work item.</li>
<li><strong class="bold">Backlogs</strong>: The <a id="_idIndexMarker959"/>work for each sprint is taken from a prioritized backlog of user stories the team has previously reviewed and refined.</li>
</ul>
<p>The exact details, roles, and names of things may vary from organization to organization, but these truths generally apply.</p>
<p>This process creates an iterative and cyclical process where the team works on the work items the business considers the most important in one sprint while prioritizing and refining items for the following sprint, as shown in <em class="italic">Figure 17</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 17.1 – The cycle of agile software development" src="img/B21324_17_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – The cycle of agile software development</p>
<p>Agile is <a id="_idIndexMarker960"/>currently the best methodology we’ve found for software engineering in a business setting, but it does pose some unique obstacles to refactoring. See the <em class="italic">Further reading</em> section at the end of this chapter for additional resources on agile.</p>
<h2 id="_idParaDest-359"><a id="_idTextAnchor358"/>Understanding obstacles to refactoring</h2>
<p>Agile is good for getting teams<a id="_idIndexMarker961"/> working on items that are important to the business and working through a prioritized backlog. Unfortunately, agile may not be the best development modality for proactive refactoring work.</p>
<p>Most organizations require all code changes to be associated with at least one user story and developers are expected to be working on user stories when they have spare capacity.</p>
<p>This leaves engineers in a conundrum where they know the areas of code that need to be refactored and have the technical skills and knowledge to refactor them, yet it is not acceptable within the boundaries of their teams for them to proactively improve code outside the bounds of an assigned user story.</p>
<p>This causes technical debt to pile up and eventually decays the team’s velocity by slowing down work items. This also results in a greater number of bugs being introduced because the team has not been allowed to proactively manage the risk inherent in their legacy code.</p>
<p>This isn’t to say that agile is bad. Agile is the best process we’ve found so far to manage work in software engineering teams; however, it has some limitations that must be solved to help organizations achieve both short-term and long-term success.</p>
<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>Succeeding with agile refactoring strategies</h1>
<p>Ongoing refactoring is important in an agile environment, so let’s talk about some ways of making sure code gets refactored regularly.</p>
<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>Dedicated work items for refactoring efforts</h2>
<p>Remember that every line of code<a id="_idIndexMarker962"/> you and your team write should deliver business value, including your refactoring efforts.</p>
<p>Refactoring focuses on delivering value to the business by addressing known areas of technical risk and improving the speed the team can achieve in the future on related work in the targeted area.</p>
<p>Given these facts, it makes sense that refactoring efforts should be represented inside a sprint as user stories. Just as one developer might get a user story about integrating with a new external system for a partner, another developer might get a user story to refactor and establish additional tests around the data access layer.</p>
<p>In <a href="B21324_15.xhtml#_idTextAnchor316"><em class="italic">Chapter 15</em></a>, we discussed tracking technical debt in a risk register. I didn’t make it explicit in that chapter, but you can use the same system that tracks your user stories to track your known technical risks as a specialized type of user story, such as the one shown in <em class="italic">Figure 17</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 17.2 – A technical debt item in Azure DevOps" src="img/B21324_17_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – A technical debt item in Azure DevOps</p>
<p>These technical debt user stories should look just like normal user stories and have the same degree of polish and refinement. However, these user stories should have a different type or a property with a different value so that you can identify technical debt items in your backlog and sprints.</p>
<p>Additionally, it should be the responsibility of the developers on the team to write up these technical debt items and not the product owner, though the team will still need to walk the product owner through what the item is, the rough amount of effort needed to remediate it, and the risk the change is looking to resolve.</p>
<p>Healthy agile teams should take a mixture of short-term and long-term items, with technical debt items typically falling in the long-term bucket.</p>
<p>There may <a id="_idIndexMarker963"/>be times when you cannot do anything but short-term work and there may be times when you work with a product owner that doesn’t understand the risk present in your technical debt. The suggestions from <a href="B21324_15.xhtml#_idTextAnchor316"><em class="italic">Chapter 15</em></a> may help with this, but sometimes, there won’t be an easy answer.</p>
<p>In these times, you may need to shift to a strategy of refactoring any code that changes.</p>
<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>Refactoring code as it changes</h2>
<p>Most of the technical debt I’ve <a id="_idIndexMarker964"/>addressed over my career has come from the conscious decision to refactor any code I touch.</p>
<p>This approach of refactoring code that changes has several key benefits:</p>
<ul>
<li>It ensures the areas that are changed most frequently get refactored.</li>
<li>Since I’m working in that area anyway, I know I will be testing the code in question. This means that these testing efforts will help catch any issues that might be addressed as part of refactoring.</li>
<li>It does not require the overhead of separate user stories for small, trivial refactoring efforts.</li>
</ul>
<p>In my experience, making it part of your policy to clean up and test the code around the areas you touch results in a much cleaner codebase over time.</p>
<p>This approach has its<a id="_idIndexMarker965"/> limitations: when you are making a minor change in one area of code and the code needs serious refactoring efforts, it is typically irresponsible to expand the scope of your work item beyond a certain point.</p>
<p>Additionally, some refactoring efforts cannot be achieved within the context of a single sprint and need more strategic thought and planning behind them.</p>
<h2 id="_idParaDest-363"><a id="_idTextAnchor362"/>Refactoring sprints</h2>
<p>One concept I’ve encountered once o<a id="_idIndexMarker966"/>r twice has been the idea of a <strong class="bold">refactoring sprint</strong>. A refactoring sprint follows the mentality of crop rotation in farming.</p>
<p>I’m no farmer, but my understanding of crop rotation is that you can use a field for several seasons, but over time, that field starts to lose the nutrient values from the soil and becomes less productive as years go on.</p>
<p>To combat this, farmers learned to leave these fields fallow and not grow anything in them for a time, as shown in <em class="italic">Figure 17</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 17.3 – Rotating crops over several years" src="img/B21324_17_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – Rotating crops over several years</p>
<p>Applied to agile development, you might spend several sprints working on normal work items, but after a handful of sprints, you introduce a refactoring sprint where the team’s effort goes into refactoring the areas of code that concern the team the most.</p>
<p>In refactoring sprints, the development team can take on larger-scale efforts than they might otherwise try as part of a standard sprint.</p>
<p>This also has the side effect of re-energizing your developers and getting them ready for another sequence of sprints around a key long-term business objective.</p>
<p>In practicality, I’m not sure how well these sprints work regularly, but I’ve seen teams benefit from them tremendously in special scenarios. These refactoring sprints can be used to tackle larger problems or as a way of recharging the team after a major initiative is completed. I’ve also<a id="_idIndexMarker967"/> seen these sprints used as a way of keeping the team engaged during holiday seasons.</p>
<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>Refactoring sabbaticals</h2>
<p>Most teams I’ve worked with <a id="_idIndexMarker968"/>simply can’t afford to have all their developers work primarily on refactoring efforts, even for a single sprint.</p>
<p>Teams like this may want to take the idea of a refactoring sprint and scale it down so that it applies to just a single team member.</p>
<p>I call this concept a <strong class="bold">refactoring sabbatical</strong>, where the developer effectively splits off of the team for a short time to work on a refactoring project, only to rejoin the larger team in the next sprint.</p>
<p>In a future sprint, another developer gets to spend a sprint working on refactoring efforts while others work on traditional work items, as shown in <em class="italic">Figure 17</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 17.4 – A rotating developer sabbatical over several sprints" src="img/B21324_17_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4 – A rotating developer sabbatical over several sprints</p>
<p>Under this model, the refactoring efforts the developer wants to take on should be pre-approved, reviewed, and tested by other developers on the team.</p>
<p>The developer on “sabbatical” should still be available for questions and work on emergency items. The only major change is that their work for a sprint is self-directed toward known refactoring goals.</p>
<p>This has some of the same morale-boosting effects as a refactoring sprint but on a smaller scale. This also helps prevent teams from over-relying on any one person on the team, because people rotate into and out of sabbaticals frequently.</p>
<p>While this model may see success in small and medium-sized refactorings, it is less effective in large-scale refactorings. We’ll discuss ways of succeeding with larger refactorings next.</p>
<h1 id="_idParaDest-365"><a id="_idTextAnchor364"/>Accomplishing large-scale refactorings</h1>
<p>In my experience, successfully <a id="_idIndexMarker969"/>performing large-scale refactorings is one of the hardest challenges in all of software engineering.</p>
<p>I define large-scale refactoring as something on the scale of replacing an application or a major architectural layer of an application. Moving an application from one database technology to another, replacing a REST API with a gRPC API, upgrading from Web Forms to Blazor, or replacing your entire service layer are all examples of this.</p>
<h2 id="_idParaDest-366"><a id="_idTextAnchor365"/>Why large refactorings are difficult</h2>
<p>These projects are challenging<a id="_idIndexMarker970"/> because they typically take longer than a single sprint to accomplish and must meet feature parity with software that has been developed over the years.</p>
<p>Additionally, software engineering projects are notoriously hard to accurately estimate, which is one of the reasons developers prefer agile software development over more traditional project management <a id="_idIndexMarker971"/>methodologies such as <strong class="bold">waterfall</strong>. Delays in software development projects can be difficult to predict and manifest in the form of unexpected technical obstacles, such as previously unknown limitations of other components or platforms or subtle bugs slowing development.</p>
<p>Because of these factors, large refactoring efforts are significantly harder to achieve than medium refactoring efforts.</p>
<p>Once completed, the results of these efforts can be daunting to move into production environments as well because they represent such a large change. Later in this chapter, we’ll talk about a few ways of reducing this risk, but the decision to replace or upgrade major parts of your application is not one without quality risks.</p>
<p>This problem gets even more pronounced when teams choose to completely rewrite or replace software projects instead of refactoring them.</p>
<h2 id="_idParaDest-367"><a id="_idTextAnchor366"/>The rewrite trap</h2>
<p>Rewrites<a id="_idIndexMarker972"/> take all the problems of large refactoring efforts and multiply them by a factor of at least 10.</p>
<p>In this scenario, you are replacing an application that has been used for some time and typically has a significant number of active users and established features.</p>
<p>It can be a struggle to re-implement years’ worth of features while keeping up with production bugs and other short-term work that must happen to keep the business running smoothly.</p>
<p>When a team is actively working on a rewrite, they usually see little value in targeted refactorings of the current system they’re working on replacing. This means that if a rewrite is canceled or put on hold, the team gets no value out of their investment and still has a legacy system that needs to be supported.</p>
<p>Since software projects are hard to estimate and manage, rewrites frequently take much longer than you expect them to. During this time, your engineers are working primarily on the rewrite, which takes capacity away from other initiatives.</p>
<p>Remember that a rewrite usually provides no intrinsic value to the business or the users until it is active in a production environment and people are working with it live. This is why so few rewrite projects succeed.</p>
<p>You can remediate this by offering early previews of a partial rewrite, but this is not always possible and may not be the best user experience if important features are not present yet in the rewrite.</p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor367"/>Lessons from the ship of Theseus</h2>
<p>There’s a thought experiment about the Greek hero Theseus that is relevant to refactoring software.</p>
<p>In this thought <a id="_idIndexMarker973"/>experiment, <strong class="bold">the ship of Theseus</strong>, our hero, Theseus, sets sail on a long journey by sea. Throughout his long voyages, the crew gradually replaced pieces of the ship with spare materials and materials they made or found on their voyages. This continued for some time until there wasn’t a single piece of the original ship left in his ship as he returned home.</p>
<p>This thought experiment asks whether the ship that came home is the same, and if it isn’t, when did it stop being that ship?</p>
<p>While these are interesting philosophical questions, the concept is relevant to software engineering.</p>
<p>Using refactoring, we can replace the “planks” of our virtual “ship” as technical debt takes hold in various areas. As we gradually refactor the components that need it the most, we continually evolve our software to stay relevant over time.</p>
<p>This is why I view refactoring <a id="_idIndexMarker974"/>code as you write code as a critically important practice in software engineering. Technical debt is an inescapable reality of software and you must keep it in mind with every change you make by doing what you can to prevent it from taking hold and paying down existing debt areas through refactoring.</p>
<p class="callout-heading">Note</p>
<p class="callout">Gradual refactoring only goes so far. Progressive refactoring may help keep your virtual “boat” afloat, but it won’t turn a rowboat into a cruise liner or submarine.</p>
<p>Put more clearly, refactoring won’t help you move from an antiquated technology to a more modern one. Let’s look at a tool that might help with that.</p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor368"/>Upgrading projects with.NET Upgrade Assistant</h2>
<p>As new versions of .NET come out and new technologies emerge within the .NET ecosystem, keeping up can be a challenge.</p>
<p>To address this, Microsoft <a id="_idIndexMarker975"/>introduced <strong class="bold">.NET Upgrade Assistant</strong>, which helps you safely upgrade and modernize your applications. At the time of writing, this tool has been useful with projects written with the following technologies:</p>
<ul>
<li><strong class="bold">ASP.NET</strong></li>
<li><strong class="bold">Universal Windows </strong><strong class="bold">Platform</strong> (<strong class="bold">UWP</strong>)</li>
<li><strong class="bold">Windows Communication </strong><strong class="bold">Foundation</strong> (<strong class="bold">WCF</strong>)</li>
<li><strong class="bold">Windows Forms</strong></li>
<li><strong class="bold">Windows Presentation </strong><strong class="bold">Foundation</strong> (<strong class="bold">WPF</strong>)</li>
</ul>
<p>.NET Upgrade Assistant<a id="_idIndexMarker976"/> can be installed either as a global tool or as a Visual Studio extension, as shown in <em class="italic">Figure 17</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 17.5 – Installing.NET Upgrade Assistant in Visual Studio" src="img/B21324_17_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.5 – Installing.NET Upgrade Assistant in Visual Studio</p>
<p>Once the extension has been installed, you will be able to right-click on a project in <strong class="bold">Solution Explorer</strong> and choose <strong class="bold">Upgrade</strong>.</p>
<p>From there, you’ll be able to configure a set of options on your project that will vary based on the technologies you use. You’ll also be able to configure the scope of the upgrade attempt and include and exclude files of your choosing.</p>
<p>Once the upgrade runs, you’ll see a list of projects and files that were updated and see details in the log, as shown in <em class="italic">Figure 17</em><em class="italic">.6</em>:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 17.6 – .NET Upgrade Assistant in action" src="img/B21324_17_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.6 – .NET Upgrade Assistant in action</p>
<p>You should <a id="_idIndexMarker977"/>make sure your project is properly backed up and in source control before attempting an upgrade and you may need to resolve certain issues yourself, but this tool can be very useful for starting an upgrade in an automated manner.</p>
<p>For applications that can’t be easily upgraded with .NET Upgrade Assistant, you may need some more creative strategies, which we’ll talk about next.</p>
<h2 id="_idParaDest-370"><a id="_idTextAnchor369"/>Refactoring and the strangler fig pattern</h2>
<p>In 2004, Martin Folwer<a id="_idIndexMarker978"/> introduced the <strong class="bold">strangler fig pattern</strong> to the software community in a post he titled <em class="italic">StranglerFigApplication</em>.</p>
<p>In this post, Martin Fowler describes how certain fig trees, such as the Banyan Tree pictured in <em class="italic">Figure 17</em><em class="italic">.7</em>, wrap themselves around other trees and gradually replace the structure of the other tree:</p>
<div><div><img alt="Figure 17.7 – Photo of a banyan tree by Ankit Bhattacharjee" src="img/B21324_17_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.7 – Photo of a banyan tree by Ankit Bhattacharjee</p>
<p>Over time, this<a id="_idIndexMarker979"/> strangler fig assumes more and more of the structure of the tree and it effectively becomes a whole new tree.</p>
<p>In this metaphor, the tree would be the legacy application you’re trying to replace while the various vines from the strangler fig represent your rewrite.</p>
<p>Under this model, you’re not trying to rewrite the entire application and replace it with a freshly rewritten application.</p>
<p>Instead, you take a single <strong class="bold">vertical slice</strong> of<a id="_idIndexMarker980"/> the application encompassing a core set of features and behaviors and you make a new implementation of them in a new technology. This might be a web page or a set of API endpoints, depending on what you’re writing.</p>
<p>Once you’ve rewritten this capability in your new technology, you redirect traffic for that one area from the old application to the new application. This allows you to ship parts of your new application to users incrementally, validate things in production, and then take on another vertical slice of the application.</p>
<p class="callout-heading">Technical details</p>
<p class="callout">There are a few technologies that can help achieve this goal of replacing vertical slices of an application. Azure API Management can help direct web traffic to an appropriate endpoint in API Management. I’ve also seen <a id="_idIndexMarker981"/>people succeed with <strong class="bold">Yet Another Reverse Proxy</strong> (<strong class="bold">YARP</strong>) for these efforts. Links to both can be found in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<p>As you expand your rewrite and validate it works, you can remove portions of the original application so that you no longer need to maintain them.</p>
<p>For areas that your new application doesn’t support yet, you can have it link back to existing areas on the old application.</p>
<p>The strangler fig approach has some<a id="_idIndexMarker982"/> key advantages compared to a full rewrite:</p>
<ul>
<li>It allows you to iteratively deliver your rewrite in stages</li>
<li>It works better in an agile environment</li>
<li>It helps validate risk areas early instead of waiting for the full rewrite</li>
<li>It allows you to remove replaced code from the original if you’d like</li>
<li>It can be rolled out in parallel with the original as a preview</li>
</ul>
<p>Perhaps the biggest benefit of this pattern is that its success chance is significantly higher than attempting a total rewrite.</p>
<p>Let’s talk about what to do when refactoring isn’t as successful.</p>
<h1 id="_idParaDest-371"><a id="_idTextAnchor370"/>Recovering when refactoring goes wrong</h1>
<p>Sometimes, despite your best efforts, refactoring efforts will fail. It may be due to gaps in your tests or mistaken assumptions about new technologies, but a certain percentage of your refactoring attempts will fail.</p>
<h2 id="_idParaDest-372"><a id="_idTextAnchor371"/>The impact of failed refactorings</h2>
<p>Failed refactorings can be<a id="_idIndexMarker983"/> both frustrating and a serious challenge to future refactoring work. After all, a significant barrier to refactoring is the belief that legacy code is so brittle that touching it will break it. When you change code and it breaks, you make it harder to change code in the future.</p>
<p>When refactoring fails, you sometimes get to make a quick patch to address the issue you introduced. In this case, the code is refactored and service gets restored, but you’ve lost some of the team’s trust.</p>
<p>Other times, failures in refactoring result in code getting rolled back to the previous version before you refactored it. Sometimes, you’ll get to make changes, add additional tests, and retry this refactoring, while other times, the team will decide that the refactoring is too dangerous to try again and you’ll lose your shot at improving the code for some time.</p>
<p>Ultimately, this conversation boils down to how much the business trusts you to not make mistakes.</p>
<p>Mistakes in<a id="_idIndexMarker984"/> software development will happen because people are imperfect and make mistakes, assume things without realizing them, and don’t know everything.</p>
<h2 id="_idParaDest-373"><a id="_idTextAnchor372"/>Establishing safety in agile environments</h2>
<p>What you want to do as a <a id="_idIndexMarker985"/>technologist is create an environment where mistakes are infrequent and can easily and safely be caught before they reach production environments.</p>
<p>There are certain things you can do to reduce the odds of breaking software when refactoring:</p>
<ul>
<li><strong class="bold">Testing</strong>: Unit tests, manual tests, and having your peers test your code in a different environment <a id="_idIndexMarker986"/>can help you catch many mistakes and some assumptions.</li>
<li><strong class="bold">Code review</strong>: Teams that review changes before they ship to integration and production environments can catch bad assumptions, mistakes, and poor coding practices. Code review<a id="_idIndexMarker987"/> is also an opportunity for teams to share knowledge and techniques, as well as share knowledge of the codebase across the dev team.</li>
<li><strong class="bold">Code analysis</strong>: Using the <a id="_idIndexMarker988"/>documented best practices in .NET and adhering to your team’s standards, as we talked about in <em class="italic">Part 3</em> of this book, can prevent issues the team has encountered before from recurring.</li>
<li><strong class="bold">Automated tests</strong>: Testing is so important I put it on here twice, but this time, I’m stressing that any <a id="_idIndexMarker989"/>change getting merged into a release branch needs to have automated tests run against it and pass before it can move on. This ensures that tests are reliably and repeatably run.</li>
<li><strong class="bold">Active monitoring</strong>: Regular <a id="_idIndexMarker990"/>monitoring of error and warning logs can help you detect problems early in production and staging environments.</li>
</ul>
<p>Be honest and<a id="_idIndexMarker991"/> transparent when an issue occurs and follow this sequence of steps:</p>
<ol>
<li>Confirm that the issue exists.</li>
<li>Understand the issue enough to resolve it.</li>
<li>Resolve the issue and restore service.</li>
<li>Determine how you could have prevented the issue from occurring.</li>
</ol>
<p>When you look at a bug getting past your defensive practices as a way of improving your processes and identifying gaps, it becomes a learning opportunity for your team.</p>
<p>Unfortunately, these learning opportunities do come with a penalty of lost trust from others due to the issue.</p>
<p>I’ve found that openly and honestly communicating the following things helps encourage understanding and somewhat heal lost trust:</p>
<ul>
<li>The steps your team took to verify the item wouldn’t cause issues before release</li>
<li>The nature of the bug and how it got past your team</li>
<li>What you did to resolve it and restore service</li>
<li>What you’re <a id="_idIndexMarker992"/>doing to ensure that things like it won’t be issues in the future</li>
</ul>
<p>This approach treats everyone with respect, shares understanding, provides opportunities for questions and suggestions, and assures them that the quality of the application is important to you and your team.</p>
<p>Before we close this chapter and this book as a whole, let’s talk about some helpful practices you may want to consider when deploying software.</p>
<h1 id="_idParaDest-374"><a id="_idTextAnchor373"/>Deploying large-scale refactorings</h1>
<p>Let’s talk about some ways of <a id="_idIndexMarker993"/>deploying code that can help you catch any issues that slip through before they become major problems.</p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor374"/>Using feature flags</h2>
<p><strong class="bold">Feature flags</strong> are <a id="_idIndexMarker994"/>configuration<a id="_idIndexMarker995"/> settings that control whether features are active.</p>
<p>When you push out new code that includes a new capability, that code doesn’t have to be immediately available. You can deploy as usual with the new feature area disabled in the configuration.</p>
<p>Once you’re confident the rest of the software is working as intended, you can enable the new feature. If the feature winds up having issues, you can quickly disable it by flipping the feature flag back to its inactive state.</p>
<p>While feature flags are helpful when you’re releasing actual features, you can also use them with major refactoring efforts. For example, a feature flag might govern whether the system uses <code>LegacyBookingSystem</code> or <code>RevisedBookingSystem</code>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Feature flag libraries pair nicely with A/B testing libraries such as Scientist .NET, which we covered in <a href="B21324_09.xhtml#_idTextAnchor189"><em class="italic">Chapter 9</em></a>.</p>
<p>Popular feature<a id="_idIndexMarker996"/> flag tools <a id="_idIndexMarker997"/>include <strong class="bold">Azure App Configuration</strong> and <strong class="bold">Launchdarkly</strong>, but Microsoft also offers an open-source feature management library <a id="_idIndexMarker998"/>called <strong class="bold">.NET </strong><strong class="bold">Feature Management</strong>.</p>
<p>.NET Feature Management is surprisingly capable and integrates directly into your .NET applications, though it lacks some of the web monitoring capabilities a commercial software product might have.</p>
<p>Feature flags add complexity<a id="_idIndexMarker999"/> to your application but give you options for when your features go live. This lets you enable a feature, evaluate it<a id="_idIndexMarker1000"/> for correctness in a production environment, and then either disable it, patch any issues observed, or leave it on.</p>
<h2 id="_idParaDest-376"><a id="_idTextAnchor375"/>Phased rollouts and blue/green deployments</h2>
<p><strong class="bold">Phased rollouts</strong> or <strong class="bold">blue/green deployments</strong> take<a id="_idIndexMarker1001"/> the idea of feature <a id="_idIndexMarker1002"/>flags to a different level. In this model, you have distinct sets of<a id="_idIndexMarker1003"/> servers, typically referred to as <a id="_idIndexMarker1004"/>blue and green environments.</p>
<p>In a blue/green deployment, you might start with 100% of your users using one environment. During this time, you patch the other server with your new update and verify that it appears to be running correctly, as shown in <em class="italic">Figure 17</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 17.8 – Users using the blue environment while the green one is being updated" src="img/B21324_17_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.8 – Users using the blue environment while the green one is being updated</p>
<p>Once you’re sure the new server is operational and running without issue, you can start diverting a percentage of your users onto the new server.</p>
<p>This subset of users represents real production traffic and can be used to monitor the behavior of your new release with a minimal set of users, as shown in <em class="italic">Figure 17</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 17.9 – The blue environment running most users while a subset of users are on green" src="img/B21324_17_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.9 – The blue environment running most users while a subset of users are on green</p>
<p>If the new environment<a id="_idIndexMarker1005"/> starts to have issues, you can quickly move users off of that server and onto the old one, then take the <a id="_idIndexMarker1006"/>new environment offline for maintenance until you’ve addressed the issues and are ready to try again.</p>
<p class="callout-heading">Caution</p>
<p class="callout">When migrating to a new revision and then rolling back to the old one, you must take special care to ensure any database migrations still work appropriately. Tools such as Entity Framework’s up-and-down scripts can help with this.</p>
<p>If the new environment performs without issues, you can gradually “drain” users from the old environment onto the new environment. Eventually, your old environment will be empty and can be taken offline until the next deployment, as shown in <em class="italic">Figure 17</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 17.10 – The green environment handles all traffic and the blue one goes offline" src="img/B21324_17_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.10 – The green environment handles all traffic and the blue one goes offline</p>
<p>The next time a <a id="_idIndexMarker1007"/>deployment occurs, the roles will reverse and users will move from the green environment to the blue <a id="_idIndexMarker1008"/>environment once the blue environment is updated to the next version.</p>
<p>This sounds complex, and to some extent it is, but a lot of this complexity can be automated and managed by your cloud provider. For example, Azure provides blue/green deployments in many of its services, as detailed in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<p>Once you’ve migrated over to a blue/green deployment model, the complexity becomes largely irrelevant, and instead, blue/green deployment becomes another tool in your quality toolbox.</p>
<h2 id="_idParaDest-377"><a id="_idTextAnchor376"/>The value of continuous integration and continuous delivery</h2>
<p>All of this <a id="_idIndexMarker1009"/>added complexity in the form of deployment and feature management sounds intimidating at first, but this level of maturity helps teams perform at very high levels and reduces the impact of any failures on the end users.</p>
<p>This<a id="_idIndexMarker1010"/> complexity can be a problem, but thankfully, <strong class="bold">continuous integration and continuous delivery</strong> (<strong class="bold">CI/CD</strong>) can help manage it.</p>
<p><strong class="bold">CI</strong> is about verifying the correctness of your software any time it changes. This means running code analysis, unit tests, and any other checks you need to do any time a change is about to be merged into an integration branch.</p>
<p><strong class="bold">CD</strong> focuses on <a id="_idIndexMarker1011"/>automating the deployment of software applications in a repeatable and reliable manner. Instead of deployments being done from one specialized developer’s machine, deployments are done using an automated script that is typically run in a cloud environment. Continuous delivery allows you to ship your software in a repeatable and <a id="_idIndexMarker1012"/>reliable manner to whatever environment you want.</p>
<p>Some interpretations of CI/CD also<a id="_idIndexMarker1013"/> include <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) through <a id="_idIndexMarker1014"/>tools <a id="_idIndexMarker1015"/>such as <strong class="bold">Terraform</strong> or <strong class="bold">Bicep</strong>. IaC is used to configure cloud environments that have the same resources, security privileges, and configuration settings based on an IaC script. This means that deployments can be used to create missing cloud resources and secure resources, and generally make it easier for your team to create new environments consistently.</p>
<p>When you put these tools and processes together, you get a well-defined and automated pipeline that checks new code for correctness, runs tests to ensure that the change doesn’t break anything, and can deploy changes to whatever environment you’d like – all without the possibility of human error in the process.</p>
<p>Once you have a broad enough library of unit and integration tests, CI/CD allows you to deploy at whatever pace you’re comfortable with and is how some teams can deploy hundreds of times a day if they want to.</p>
<p>This degree of process maturity gives teams the freedom to innovate at a rapid pace. These added safety nets of quality checks and automation further support refactoring efforts by taking the fear out of making the changes needed to keep your software clean and healthy.</p>
<h1 id="_idParaDest-378"><a id="_idTextAnchor377"/>Case study – Cloudy Skies Airlines</h1>
<p>As we close this book, let’s take <a id="_idIndexMarker1016"/>a final look at our case study company: Cloudy Skies Airlines.</p>
<p>Cloudy Skies started with unmaintainable systems they were afraid to touch for fear of introducing critical bugs. They carried out a systematic review of the technical debt in their codebase and the quality issues the team had encountered in the past year.</p>
<p>As a result, the team was able to prioritize a list of key areas of technical debt and identify critical areas lacking unit tests. Cloudy Skies carried out several refactoring sprints to address the most critical areas first, putting a heavy emphasis on expanding their unit tests.</p>
<p>Once the quality hotspots were largely addressed, Cloudy Skies went back to a standard agile development cadence but allocated about 30% of their work each sprint toward paying down technical debt.</p>
<p>Many of the systems Cloudy Skies used were out of date, but Cloudy Skies was able to use .NET Upgrade Assistant to quickly modernize most of them.</p>
<p>For applications that could not be easily upgraded, development teams began following the strangler fig pattern to build a new application to cover vertical slices of the old application and tools such as YARP to route traffic to the new application where possible.</p>
<p>All of this was supported by<a id="_idIndexMarker1017"/> a culture of trust and transparency and modern application management processes through feature flags and CI/CD.</p>
<p>While it will be some time before the developers are fully proud of their code, Cloudy Skies is heading in the right direction. The team has regained the respect of the larger organization and the added stability and agility is helping the business steer toward sunny horizons.</p>
<h1 id="_idParaDest-379"><a id="_idTextAnchor378"/>Summary</h1>
<p>In this chapter, we explored the unique challenges of refactoring in an agile environment and strategies for including refactoring work inside agile sprints.</p>
<p>We also looked at ways of accomplishing large-scale refactorings and how to respond when things don’t go as planned.</p>
<p>This chapter also touched on some deployment and automation processes that can reduce the impact of issues on end users and minimize the risk of human error through feature flags, blue/green deployments, and CI/CD practices.</p>
<h1 id="_idParaDest-380"><a id="_idTextAnchor379"/>Toward more sustainable software</h1>
<p>This book took you on a journey from the nature of technical debt to the procedures of refactoring. We talked about how to safely test and structure your software and how to evaluate code for best practices, prioritize, and communicate technical debt.</p>
<p>We also talked about how the C# language and features of Visual Studio support you in this journey toward more sustainable software development.</p>
<p>Every year our world changes a little as Microsoft unveils new C# preview features at the beginning of the year and releases them near the end.</p>
<p>These capabilities give us a wide range of capabilities to tackle the development problems of today and tomorrow, but the reality is that software development continues to change.</p>
<p>Software and software development grows more complex each year. Meanwhile, many teams are stuck maintaining yesterday’s code.</p>
<p>It doesn’t have to be this way. You can modernize your software, and you can do it in an agile and responsible way while serving the needs of your business and its customers.</p>
<p>I’ve been writing software in some shape or form for over 35 years now. New developers assume that more experience results in fewer mistakes. While this has some truth to it, I’ve personally found that the more experience I get, the less I trust my ability to not make mistakes.</p>
<p>Make room for yourself – and others – to make mistakes. Mistakes will happen and bugs will reach production, but when they do, you need to learn from them.</p>
<p>It is my sincere hope that you have learned something new from every chapter. Moreover, I want you to emerge from this book with hope – hope that your code can be a source of joy to you, or at least be less afraid to change.</p>
<p>Through the practices outlined in this book, I believe that you and your team can reach a better place through successfully refactoring with C#.</p>
<h1 id="_idParaDest-381"><a id="_idTextAnchor380"/>Questions</h1>
<ol>
<li>How can technical debt be paid down inside of an agile setting?</li>
<li>Why are large rewrites hard? What processes can help with this?</li>
<li>What variances do you see right now in how you deploy and test software?</li>
</ol>
<h1 id="_idParaDest-382"><a id="_idTextAnchor381"/>Further reading</h1>
<p>You can find more information about the materials from this chapter at these URLs:</p>
<ul>
<li><em class="italic">Manifesto for Agile Software Development</em>: <em class="italic">StranglerFigApplication </em><em class="italic">Post</em>: <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">https://martinfowler.com/bliki/StranglerFigApplication.html</a></li>
<li><em class="italic">YARP</em>: <a href="https://github.com/microsoft/reverse-proxy">https://github.com/microsoft/reverse-proxy</a></li>
<li><em class="italic">Azure API </em><em class="italic">Management</em>: <a href="https://learn.microsoft.com/en-us/azure/api-management/api-management-key-concepts">https://learn.microsoft.com/en-us/azure/api-management/api-management-key-concepts</a></li>
<li><em class="italic">Overview of the.NET Upgrade </em><em class="italic">Assistant</em>: <a href="https://learn.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview">https://learn.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview</a></li>
<li><em class="italic">.NET Feature </em><em class="italic">Management</em>: <a href="https://github.com/microsoft/FeatureManagement-Dotnet">https://github.com/microsoft/FeatureManagement-Dotnet</a></li>
<li><em class="italic">Blue-Green Deployment in Azure Container </em><em class="italic">Apps</em>:<em class="italic"> </em><a href="https://learn.microsoft.com/en-us/azure/container-apps/blue-green-deployment">https://learn.microsoft.com/en-us/azure/container-apps/blue-green-deployment</a></li>
<li><em class="italic">Vertical </em><em class="italic">Slices: </em><a href="https://deviq.com/practices/vertical-slices">https://deviq.com/practices/vertical-slices</a></li>
</ul>
</div>
</body></html>