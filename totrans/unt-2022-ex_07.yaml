- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating a 2D Adventure Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个2D冒险游戏
- en: In [*Chapter 3*](B18347_03.xhtml#_idTextAnchor058), you were introduced to Cinemachine
    for creating a quick but powerful camera-follow system. We learned how to implement
    a game mechanic for collecting items and displaying game progression with Unity
    UI, and how to approach game balance while considering win-and-lose conditions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18347_03.xhtml#_idTextAnchor058)中，您被介绍了Cinemachine，用于创建快速但强大的相机跟随系统。我们学习了如何使用Unity
    UI实现收集物品和显示游戏进度的游戏机制，以及如何在考虑胜负条件的同时处理游戏平衡。
- en: By completing the collection game, the previous chapters provided foundational
    knowledge that we’ll continue to build upon in this chapter as we start to make
    a 2D adventure game. We’ll explore importing artwork and creating assets to build
    out a 2D side-on environment and level design using additional Unity 2D tooling,
    namely **Sprite Shape**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成收集游戏，前几章提供了基础知识，我们将在此基础上继续构建，本章我们将开始制作一个2D冒险游戏。我们将探索导入艺术作品并使用额外的Unity 2D工具，即**Sprite
    Shape**，来构建2D侧面环境以及级别设计。
- en: We’ll finish the chapter by adding dynamic moving platforms and triggers that
    will provide secondary actions to create a more engaging player experience, and
    some optimization techniques to keep the game performant and polished for increased
    immersion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加动态移动平台和触发器来结束本章，这些触发器将为玩家提供二级动作，以创造更具吸引力的游戏体验，并采用一些优化技术来保持游戏性能和品质，以增加沉浸感。
- en: In this chapter, we’re going to cover the following main topics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题。
- en: Extending the **Game Design Document** (**GDD**) – Introducing the 2D adventure
    game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展**游戏设计文档**（**GDD**） – 介绍2D冒险游戏
- en: Importing assets to use with Sprite Shape – A different kind of 2D environment
    builder
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将资源导入以用于Sprite Shape – 一种不同类型的2D环境构建器
- en: Level and environment design – Guiding the player
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别和环境设计 – 引导玩家
- en: Moving platforms and triggers – Creating a dynamic interactable environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动平台和触发器 – 创建一个动态可交互的环境
- en: Adding polish to our environment to immerse the player and optimizing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的环境添加细节以增强沉浸感和优化
- en: By the end of this chapter, you’ll have another example of a GDD to use for
    your projects and be able to import and use original artwork to create an environment
    that guides the player while designing a level using Sprite Shape. You’ll also
    be able to create an interactive and dynamic moving environment that is optimized
    and visually polished.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有另一个可用于您项目的GDD示例，并能够导入和使用原始艺术作品来创建一个使用Sprite Shape设计的引导玩家环境。您还将能够创建一个交互性和动态的移动环境，该环境经过优化且视觉效果精美。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along in this chapter with the same artwork created for the project
    in the book, download the assets from the GitHub link provided in this section.
    To follow along with your own artwork, you’ll need to create similar artwork using
    Adobe Photoshop, or a graphics program that can export layered Photoshop PSD/PSB
    files (for example, Gimp, MediBang Paint, or Krita).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中为书中项目创建的相同艺术作品，请从本节提供的GitHub链接下载资源。要使用您自己的艺术作品跟随，您需要使用Adobe Photoshop或能够导出分层Photoshop
    PSD/PSB文件的图形程序（例如，Gimp、MediBang Paint或Krita）创建类似的艺术作品。
- en: Additionally, to follow along with the player input section, you’ll want a compatible
    game controller for your system (although this is optional since keyboard input
    will also be provided).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了跟随玩家输入部分，您可能需要一个与您的系统兼容的游戏控制器（尽管这是可选的，因为也会提供键盘输入）。
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上下载完整的项目[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Extending the GDD – Introducing the 2D adventure game
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展GDD – 介绍2D冒险游戏
- en: We’re continuing with the next game concept now – while continuing with the
    overall theme for the projects in the book – so let’s go ahead and update the
    GDD and extend upon it where needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续下一个游戏概念，同时继续书中项目的整体主题，因此让我们继续更新GDD并在需要的地方扩展它。
- en: 'Let’s first update the following overview sections that we’ve previously covered;
    this will also serve as your introduction to the game:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更新以下之前覆盖的概述部分；这还将作为您对游戏的介绍：
- en: '| **Name** **of game** | Outer World |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **游戏名称** | 外部世界 |'
- en: '| **Describe the gameplay, the core loop,** **and progression.** | Find your
    way to the habitat station while searching for parts of the key required to gain
    access to the entryway and neutralize infected robots that attempt to halt your
    mission. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **描述游戏玩法、核心循环和进度。** | 在寻找进入入口所需的关键部件的同时，找到通往栖息地站的道路，并中和试图阻止你任务的感染机器人。|'
- en: '| **What is the core game mechanic for the** **adventure game?** | The player
    will repeatedly engage in battle with infected robots that impede progress to
    the habitat station. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **冒险游戏的核心游戏机制是什么？** | 玩家将反复与阻碍前往栖息地站的感染机器人战斗。|'
- en: '| **What is the secondary game mechanic for the** **adventure game?** | The
    player will search the environment for hidden parts of a key. The pieces will
    need to be combined correctly as input to gain access to the entryway of the habitat
    station. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **冒险游戏的次要游戏机制是什么？** | 玩家将在环境中寻找隐藏的关键部件。这些部件需要正确组合作为输入，才能获得进入栖息地站入口的权限。|'
- en: '| **What systems need to be implemented to support the** **game mechanics?**
    | The player movement, equipping a weapon with ammo reloading and shooting capabilities,
    a pickup with inventory, puzzle solver, health, and damage |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **需要实现哪些系统来支持游戏机制？** | 玩家移动、装备带有弹药装填和射击能力的武器、带有库存的拾取、谜题解决者、生命值和伤害。|'
- en: Table 4.1 – The GDD for the adventure game
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 冒险游戏的 GDD
- en: We’ve added a new section to the end of the preceding table that takes the game
    mechanic details a step further into the *development requirements* realm. With
    some systems defined, we can start thinking about the code architecture and what
    *problems need solving* – this is where we can apply some design patterns.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面表格的末尾添加了一个新章节，将游戏机制细节进一步扩展到 *开发需求* 领域。在定义了一些系统之后，我们可以开始考虑代码架构以及需要解决的一些
    *问题* – 这是我们应用一些设计模式的地方。
- en: 'Now, instead of a nerf, this time, let’s add a buff for the player:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再添加削弱效果，而是这次为玩家添加一个增益效果：
- en: '| **What is a buff mechanic for the player in the** **adventure game?** | The
    player will be able to collect energy shards (*water diamonds*) scattered throughout
    the environment, which, when a certain quantity has been collected, will give
    a power-up state to all of the weapons (increasing damage dealt). |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **在冒险游戏中，增益机制对玩家意味着什么？** | 玩家将能够收集散布在环境中的能量碎片（*水钻石*），当收集到一定数量时，将为所有武器提供升级状态（增加造成的伤害）。|'
- en: Table 4.2 – Adding a buff to the GDD
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 – 为 GDD 添加增益效果
- en: 'Our player character and the enemies in the game will be much further developed
    compared to the collection game. Let’s add sections in the GDD for these characters’
    bios and details about the player’s challenge structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏玩家角色和敌人将比收集游戏更加完善。让我们在 GDD 中为这些角色的背景和玩家挑战结构添加章节。
- en: '| **Main character:****Describe the main character of the game and how they
    drive the story. Who is this** **player character?** | **Type**: Kryk’zylx race
    of humanoids.**Backstory**: The people of Kryk’zylx have outgrown their home planet
    and are searching the galaxy for suitable planets to colonize. Scouts are sent
    to establish habitat stations on planet surfaces with the potential to sustain
    life.**Goals**: Establish and maintain a habitat station with an automated crew
    of construction and maintenance robots.**Skills**: Power suit jumping and charging.**Weaknesses**:
    Atmosphere not breathable. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **主要角色：****描述游戏中的主要角色以及他们如何推动故事。这位**玩家角色是谁？** | **类型**：Kryk’zylx 人形种族。**背景**：Kryk’zylx
    的人民已经超越了他们的家园星球，正在寻找适合殖民的星球。侦察兵被派往星球表面建立可能维持生命的栖息地站。**目标**：建立并维护一个栖息地站，配备自动化的建筑和维护机器人。**技能**：动力服跳跃和充电。**弱点**：大气不可呼吸。|'
- en: 'Kryk’zylx scouts must wear power suits to survive the planet’s hostile atmosphere
    outside of the habitat station. Here is an example of a power suit helmet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kryk’zylx 侦察兵必须在栖息地站外的星球敌对大气中穿着动力服才能生存。以下是一个动力服头盔的示例：
- en: '![Figure 4.1 – Power suit helmet](img/B18347_04_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 动力服头盔](img/B18347_04_01.jpg)'
- en: Figure 4.1 – Power suit helmet
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 动力服头盔
- en: 'And now, we’ll continue by adding the sections for the details of the player’s
    challenge structure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续添加关于玩家挑战结构的详细章节：
- en: '| **What is the main character’s** **challenge structure?** | Navigate platforms,
    make their way past infected robots, and solve the critical puzzle. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **主角的挑战结构是什么？** | 在平台上导航，避开感染的机器人，并解决关键谜题。|'
- en: '| **Enemy A:****Describe the first enemy in the game and how they drive the
    story. Who is** **this enemy?** | **Type**: Construction Robot, Biped**Backstory**:
    Robot deployed on pre-colonization missions for habitat station construction and
    maintenance.**Goals**: Construction and maintenance.**Skills**: High mobility,
    including onrough terrain.**Weaknesses**: Long charging. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **敌人 A：** 描述游戏中的第一个敌人以及他们如何推动故事发展。**这个敌人是谁？** | **类型**：建筑机器人，两足**背景**：部署在为栖息地站建设和维护的预殖民任务中的机器人。**目标**：建设和维护。**技能**：高机动性，包括在崎岖地形上。**弱点**：充电时间长。|'
- en: '| **Enemy B:****Describe the second enemy in the game and how they drive the
    story. Who is** **this enemy?** | **Type**: Maintenance Robot, Wheeled**Backstory**:
    Robot deployed on pre-colonization missions for habitat maintenance and support.**Goals**:
    Maintenance and personnel support.**Skills**: Quick charging.**Weaknesses**: Limited
    mobility. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **敌人 B：** 描述游戏中的第二个敌人以及他们如何推动故事发展。**这个敌人是谁？** | **类型**：维护机器人，轮式**背景**：部署在为栖息地维护和支持的预殖民任务中的机器人。**目标**：维护和人员支持。**技能**：快速充电。**弱点**：机动性有限。|'
- en: Table 4.3 – Adding character and enemy bios
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3 – 添加角色和敌人生物
- en: 'We will take the document further and introduce a section that gives the environment
    some attention. The description here will help maintain the game’s visual direction
    while the environment and level are being designed and the art assets are created:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步扩展文档，并引入一个关注环境的章节。这里的描述将有助于在设计和创建环境及关卡艺术资源时保持游戏的视觉方向：
- en: '| **Describe the environment in which the game takes place. What does it look
    like, who inhabits it, and what are the points** **of interest?** | The game takes
    place on the surface of a prospective planet to colonize, even though this particular
    planet does not have a breathable atmosphere. The planet comprises areas of purple-red
    rock and thick vegetation (which moves in such a way as to suggest it may have
    the capacity to think). |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **描述游戏发生的环境。它看起来如何，谁居住在那里，以及有哪些** **兴趣点？** | 游戏发生在一个有殖民潜力的行星表面，尽管这个特定的行星没有可呼吸的大气。这个行星由紫色-红色岩石和茂密的植被组成（其移动方式暗示它可能具有思考的能力）。|'
- en: '| **Describe the** **game level(s).** | The game level is a combination of
    static and moving platforms with obstacles needing to be overcome or avoided by
    the player as they make their way to the habitat station. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **描述游戏关卡。** | 游戏关卡是由静态和动态平台以及玩家在前往栖息地站的过程中需要克服或避免的障碍物组成的组合。|'
- en: Table 4.4 – Environment and level
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 – 环境和关卡
- en: 'Let’s add a section on the input controls. Previously, we used the keyboard
    and mouse for the collection game, but this time, we’ll also be adding support
    for input from a game controller:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个关于输入控制的章节。之前，我们使用键盘和鼠标进行收集游戏，但这次，我们还将添加对游戏手柄输入的支持：
- en: '| **Define the input/control** **methods actions.** | **Keyboard**: *W*, *A*,
    *S*, and *D* keys to move; the space bar to jump; the mouse to aim, the left mouse
    button to shoot the primary weapon, and the right mouse button hold/release to
    launch the secondary weapon while aiming with the mouse (the left mouse button
    to cancel); and the *E* key to interact with things.**Game Controller**: The left
    stick/D pad to move; *X* to jump; the right stick to aim and the right trigger
    or *Y* to shoot; the right shoulder hold/release to launch the secondary weapon
    while aiming with the right stick (the right trigger to cancel); and button *A*
    to interact. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **定义输入/控制方法动作。** | **键盘**：*W*、*A*、*S* 和 *D* 键用于移动；空格键用于跳跃；鼠标用于瞄准，左鼠标按钮用于射击主要武器，右鼠标按钮用于在瞄准时发射/释放次要武器（左鼠标按钮用于取消）；*E*
    键用于与物品交互。**游戏手柄**：左摇杆/D 按钮用于移动；*X* 键用于跳跃；右摇杆用于瞄准，右扳机或 *Y* 键用于射击；右肩部用于在瞄准时发射/释放次要武器（右扳机用于取消）；按钮
    *A* 用于交互。|'
- en: Table 4.5 – Input/control methods actions
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5 – 输入/控制方法动作
- en: 'Finally, let’s define how all the pieces interact to make a complete game experience
    for the player:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义所有部件如何相互作用，为玩家提供一个完整的游戏体验：
- en: '| **How do all the** **pieces interact?** | The player interacts with the environment
    through exploration, discovering what is required to reach and enter the habitat
    station using parts of a puzzle key found throughout the level while fending off
    robots that have become infected by the strange plants that cover the planet’s
    surface. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **所有这些部件是如何相互作用的？** | 玩家通过与环境的互动来探索，发现使用整个关卡中找到的谜题钥匙的各个部分来达到并进入栖息地站，同时抵御被覆盖整个星球表面的奇异植物感染的机器人。
    |'
- en: Table 4.6 – Putting all the pieces together
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6 – 将所有部件组合在一起
- en: Full GDD for the 2D adventure game
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 2D冒险游戏的完整GDD
- en: 'To view the full GDD document for the 2D adventure game, visit the project
    GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/GDD](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/GDD)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看2D冒险游戏的完整GDD文档，请访问以下项目GitHub仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/GDD](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/GDD)
- en: Refer to the GDD any time you are unsure about what comes next. So long as you’re
    following what you’ve written, the next steps should come as a natural progression
    you can iterate upon. However, don’t feel like you’re locked into what you’ve
    written as your first draft of the GDD – as a living document, let ideas organically
    change as you work through them, and new ideas come to light (just as I have done
    throughout writing this book!).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在你不确定下一步该做什么的时候，请参考GDD。只要你在遵循你所写的内容，下一步应该是一个自然的进展，你可以在此基础上迭代。然而，不要觉得你被你的GDD初稿所束缚——作为一个活文档，随着你处理它们，想法会自然地变化，新的想法也会浮现（就像我在写这本书的过程中所做的那样！）。
- en: In this section, you learned how to extend upon our GDD to include additional
    details for the main characters in the game and describe the game world and how
    everything works together to create an immersive experience for the player. We’ll
    continue importing original artwork to start building the game level with Sprite
    Shape in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何扩展我们的游戏设计文档（GDD），包括游戏主要角色的额外细节，并描述游戏世界以及如何让一切协同工作，为玩家创造沉浸式的体验。我们将在下一节继续导入原始艺术作品，开始使用Sprite
    Shape构建游戏关卡。
- en: Importing assets to use with Sprite Shape – A different kind of 2D environment
    builder
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将资产导入以用于Sprite Shape – 一种不同的2D环境构建器
- en: The artwork that we’ll be using for the 2D adventure game is an original artwork
    and the result of a collaboration with the artist, Nica Monami. The art assets
    have all been created specifically for this project in the book. Nica has lent
    her talent for creating fantastic painterly-looking art to create a unique environment
    for the game, and I am very excited to be working with these assets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为2D冒险游戏使用的艺术作品是原创艺术作品，是艺术家Nica Monami合作的结果。艺术资产都是为这本书中的这个项目专门创建的。Nica借用了她创作奇幻绘画风格艺术的天赋，为游戏创造了一个独特的环境，我很高兴能与这些资产合作。
- en: '![Figure 4.2 – Original game artwork](img/B18347_04_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 原始游戏艺术作品](img/B18347_04_02.jpg)'
- en: Figure 4.2 – Original game artwork
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 原始游戏艺术作品
- en: Adventure game 2D art assets
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 冒险游戏2D艺术资产
- en: 'To follow along in this chapter, download the art assets from the project GitHub
    here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Art-Assets)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，请从以下项目GitHub下载艺术作品：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Art-Assets)
- en: Nica Monami has permitted the use of the provided game art for learning purposes
    only; commercial use is strictly prohibited. Nica’s portfolio can be viewed on
    ArtStation at [https://www.artstation.com/dnanica213](https://www.artstation.com/dnanica213)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Nica Monami允许仅用于学习目的使用提供的游戏艺术作品；商业用途是严格禁止的。Nica的精选作品可以在ArtStation上查看，网址为[https://www.artstation.com/dnanica213](https://www.artstation.com/dnanica213)
- en: In addition to Sprite Shape – the 2D feature we’ll be using to build out most
    of the adventure game’s level – we’ll cover most of the tooling provided by the
    **2D Animation package**. We’ll first cover importing and performing any required
    prep for the artwork to get started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Sprite Shape——我们将使用它来构建大多数冒险游戏关卡——我们还将介绍**2D动画包**提供的工具中的大部分。我们首先将介绍导入和为艺术作品进行任何必要的准备工作以开始。
- en: Importing and preparing the artwork
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入和准备艺术作品
- en: Let’s start by creating a new Unity project for the adventure game, again using
    the 2D **Universal Render Pipeline** (**URP**) Core template. We’ll continue exploring
    different gameplay styles by making the 2D adventure game a side-on orthographic
    game view (similar in style to many other Mario Bros or Metroid-inspired platformer
    games).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的Unity项目开始，用于冒险游戏，再次使用2D **通用渲染管线**（**URP**）核心模板。我们将通过将2D冒险游戏制作成侧视正交游戏视图（类似于许多其他马里奥兄弟或受《超级马里奥兄弟》启发的平台游戏）来继续探索不同的游戏玩法风格。
- en: Once the project opens, import the artwork under a new `Assets/Sprites` folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 项目打开后，将艺术品导入到新的`Assets/Sprites`文件夹下。
- en: Dutiful organizational reminder
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 忠实的组织提醒
- en: Maintaining an adequately named folder structure can help keep things sorted
    and easy to find and work with later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 维护一个合理命名的文件夹结构可以帮助保持事物井然有序，便于以后查找和使用。
- en: 'Viewing all of the imported Sprite assets – in the event you did lose track
    of something or work with many assets at once – is easily accomplished with the
    **Search by Type** option in the project window’s **Search** tool, as seen in
    the following figure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口的**搜索**工具中的**按类型搜索**选项中查看所有导入的精灵资源——以防你丢失了某个资源或同时处理多个资源——可以轻松完成，如下图所示：
- en: '![Figure 4.3 – Filtering on Sprite in the project window](img/B18347_04_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 在项目窗口中过滤精灵](img/B18347_04_03.jpg)'
- en: Figure 4.3 – Filtering on Sprite in the project window
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 在项目窗口中过滤精灵
- en: 'The image assets imported will serve different purposes and use additional
    Sprite tooling. Here is a quick overview of how we’ll be working with the imported
    assets, by folder, throughout the remainder of this chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的图像资源将用于不同的目的，并使用额外的精灵工具。以下是本章剩余部分我们将如何按文件夹处理导入资源的快速概述：
- en: '`Assets/Sprites/Sprite Shapes`: Images in this folder will be used with Unity’s
    2D **Sprite Shape** tool. Sprite Shape is a spline-based tool that provides the
    ability to make open-ended paths or enclosed shapes that can be used as parts
    of the level that the player character can walk on, adding background elements
    or quickly decorating the environment.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/Sprites/Sprite Shapes`: 此文件夹中的图像将与Unity的2D **Sprite Shape**工具一起使用。Sprite
    Shape是一个基于样条的工具体，它提供了创建开放路径或封闭形状的能力，这些形状可以用作玩家可以行走的关卡部分，添加背景元素或快速装饰环境。'
- en: Additional reading | Unity documentation
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '*2D Sprite* *Shape:* [https://docs.unity3d.com/Packages/com.unity.2d.spriteshape%409.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.spriteshape%409.0/manual/index.xhtml)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*2D精灵* *形状:* [https://docs.unity3d.com/Packages/com.unity.2d.spriteshape%409.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.spriteshape%409.0/manual/index.xhtml)'
- en: '`Assets/Sprites/Sprite Skins`: Images in this folder will be used with Unity’s
    2D `SpriteSkin` component.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/Sprites/Sprite Skins`: 此文件夹中的图像将与Unity的2D `SpriteSkin`组件一起使用。'
- en: Additional reading | Unity documentation
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '*Sprite* *Skin*: [https://docs.unity3d.com/Packages/com.unity.2d.animation%409.0/manual/SpriteSkin.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation%409.0/manual/SpriteSkin.xhtml)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*精灵* *皮肤*: [https://docs.unity3d.com/Packages/com.unity.2d.animation%409.0/manual/SpriteSkin.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.animation%409.0/manual/SpriteSkin.xhtml)'
- en: '`Assets/Sprites/Tilemap`: Images in this folder will be used to create a **Tilemap**;
    we are already familiar with this 2D feature from building the collection game
    in [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/Sprites/Tilemap`: 此文件夹中的图像将被用于创建**瓦片地图**；我们已经在[*第1章*](B18347_01.xhtml#_idTextAnchor015)中构建收集游戏时熟悉了这一2D功能。'
- en: '`Assets/Sprites/Background`: Images in this folder will be used to create our
    game environment’s layered background. We won’t use any particular Unity feature
    this time, but we will use a script to add parallax movement.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/Sprites/Background`: 此文件夹中的图像将被用于创建游戏环境的分层背景。这次我们不会使用任何特定的Unity功能，但我们将使用脚本添加视差移动。'
- en: Background parallax
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 背景视差
- en: Parallax is a technique applied to background images that moves images further
    away from the camera across the frame more slowly than foreground images, creating
    a sense of depth in 2D scenes. This technique was popularized in 2D video games
    starting in the early 1980s (although it was limited in the number of background
    planes due to hardware limitations of the time – thankfully, we’re not stuck with
    the limitations of those that came before us because we have no such limitations
    today).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直透视是一种应用于背景图像的技术，它使图像在帧中相对于前景图像以更慢的速度远离相机移动，从而在2D场景中创造深度感。这种技术在20世纪80年代初期的2D视频游戏中变得流行（尽管由于当时硬件的限制，背景平面的数量有限
    – 幸运的是，我们没有受到前辈的限制，因为我们今天没有这样的限制）。
- en: '`Assets/Sprites/Background/Clouds`: Images in this folder will be used to create
    clouds that continuously scroll and loop across the sky in the background of the
    game environment, furthering the sense of depth and immersion. We’ll use Unity’s
    **Spline** package and the corresponding **Spline Animate** component to make
    this quick and easy work (similar to the moving platforms mentioned earlier).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/Sprites/Background/Clouds`: 该文件夹中的图像将用于创建云朵，这些云朵将在游戏环境的背景中连续滚动并循环，进一步增强深度和沉浸感。我们将使用Unity的**Spline**包和相应的**Spline
    Animate**组件来使这项工作变得快速且简单（类似于之前提到的移动平台）。'
- en: '`Assets/Sprites/Object Elements`: Images in this folder will be used to detail
    the environment and provide some possible special areas of interest. There is
    nothing special here, just the Sprite Renderer and 2D colliders to facilitate
    interactions with the player character.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/Sprites/Object Elements`: 该文件夹中的图像将用于详细描述环境并提供一些可能的特殊兴趣区域。这里没有特别之处，只是包含Sprite
    Renderer和2D碰撞体，以方便与玩家角色进行交互。'
- en: With the fundamental review of the imported assets by folder finished, let’s
    do the prep work for the sprites that require it before usage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对导入资产的基本审查后，让我们在使用之前为需要准备的精灵做一些准备工作。
- en: Preparing the artwork for Sprite Shape
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Sprite Shape准备艺术作品
- en: The Sprite Shape feature creates dynamic and *flexible* shapes that can either
    be open paths or closed and filled areas. The sprite that is assigned for the
    Sprite Shape’s spline path is tiled and deformed along the defined outline. Because
    of the tiling, we need to take some special steps to prepare the sprite used here
    by adding a border at the locations on the left and right edges where it will
    tile seamlessly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Shape功能创建动态且*灵活*的形状，可以是开放路径或封闭并填充的区域。为Sprite Shape的样条路径分配的精灵将被沿定义的轮廓平铺和变形。由于平铺，我们需要采取一些特殊步骤来准备这里使用的精灵，即在它将无缝平铺的左右边缘位置添加边框。
- en: 'Follow these steps while referring to *Figure 4**.4* to ensure that the sprite
    will be compatible and work well with Sprite Shape:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图*4**.4*，按照以下步骤操作，以确保精灵将与Sprite Shape兼容并良好工作：
- en: Select the sprite in the project folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中选择精灵。
- en: In **Import Settings (Inspector)**, click the **Sprite** **Editor** button.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入设置（检查器）**中，点击**精灵** **编辑器**按钮。
- en: Click on the image and drag in both the left and right sides by using the green
    boxes or typing in values into the **L** and **R** fields of **Border** in the
    **Sprite** dialog – for the tileable position in the sprite. Click **Apply** when
    finished.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图像，并使用绿色框或输入**边框**对话框中的**L**和**R**字段中的值，在精灵的平铺位置上向左和右两侧拖动。完成后点击**应用**。
- en: Set the **Mesh Type** to **Full Rect** (this is required for use with Sprite
    Shape and will produce a warning on the Sprite Shape asset if not set accordingly).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**网格类型**设置为**全矩形**（这是使用Sprite Shape所必需的，如果未相应设置，将在Sprite Shape资产上产生警告）。
- en: '![Figure 4.4 – Sprite Editor for Sprite Shape art](img/B18347_04_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – Sprite Shape艺术精灵编辑器](img/B18347_04_04.jpg)'
- en: Figure 4.4 – Sprite Editor for Sprite Shape art
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – Sprite Shape艺术精灵编辑器
- en: Package Manager samples
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器示例
- en: Most packages in the Unity Package Manager have additional content as additional
    installations on their respective Package Manager pages. In Sprite Shape’s case,
    samples and extras that demonstrate many of its capabilities can be imported.
    I encourage you to check out the package samples for additional learning.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Unity包管理器中的大多数包在其各自的包管理器页面上都有额外的内容作为附加安装。在Sprite Shape的情况下，可以导入展示其许多功能的示例和额外内容。我鼓励您查看包示例以进行额外学习。
- en: Preparing artwork for Sprite Skin
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Sprite Skin准备艺术作品
- en: The Sprite Skin feature is commonly used to create rigged limbed characters
    and is imported from a layered Photoshop PSB/PSD file (using the **PSD Importer**
    package). We’ll use this 2D animation package feature in [*Chapter 5*](B18347_05.xhtml#_idTextAnchor096),
    when we create the adventure game’s player character. Still, for now, in this
    chapter, we’re just going to add some movement to some environmental elements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Skin功能通常用于创建有骨架的肢体角色，并且是从分层Photoshop PSB/PSD文件（使用**PSD Importer**包）导入的。我们将在[*第5章*](B18347_05.xhtml#_idTextAnchor096)中使用这个2D动画包功能，当我们创建冒险游戏的角色时。不过，现在在这个章节中，我们只是给一些环境元素添加一些动作。
- en: We’ll be animating individual PNG images imported into the `Sprites/Sprite Skins`
    folder. Aside from keeping these as separate images (for the sake of simplicity),
    there is nothing extra we need to do with the import settings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将动画导入到`Sprites/Sprite Skins`文件夹中的单个PNG图像。除了将这些图像作为单独的图像保留（为了简单起见），我们不需要对导入设置做任何额外操作。
- en: Preparing artwork for Tilemap
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备Tilemap的艺术作品
- en: 'We used Tilemap extensively in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041);
    you should be a pro with it by now! Let’s quickly recap the image preparation
    process by creating a new Tile Palette for the `Tilemap-01` sprite sheet image
    imported to `Sprites/Tilemap`, as seen in the following figure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B18347_02.xhtml#_idTextAnchor041)中广泛使用了Tilemap；现在你应该已经非常熟练了！让我们通过创建一个新的Tile
    Palette来快速回顾图像准备过程，这个Palette是为导入到`Sprites/Tilemap`的`Tilemap-01`sprite sheet图像准备的，如图所示：
- en: '![Figure 4.5 – Slicing the Sprite Sheet for Tilemap tiles](img/B18347_04_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 为Tilemap瓦片切片的Sprite Sheet](img/B18347_04_05.jpg)'
- en: Figure 4.5 – Slicing the Sprite Sheet for Tilemap tiles
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 为Tilemap瓦片切片的Sprite Sheet
- en: 'Use the following steps to prepare the artwork for use with Tilemap:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤准备用于Tilemap的艺术作品：
- en: Select the sprite sheet image in the project folder.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中选择sprite sheet图像。
- en: In **Import Settings (Inspector)**, set **Sprite Mode** to **Multiple**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入设置（检查器）**中，将**Sprite模式**设置为**多个**。
- en: Apply the changes and click the **Sprite** **Editor** button.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用更改并点击**Sprite** **编辑器**按钮。
- en: Select the **Slice** dropdown menu and then select **Grid By Cell Size** for
    **Type** of slicing.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**切片**下拉菜单，然后选择**按单元格大小**作为切片的**类型**。
- en: The supplied Tilemap image uses a 64x64 pixel size grid (same as the collection
    game), so verify the correct size and click **Slice**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 供应的Tilemap图像使用64x64像素大小的网格（与集合游戏相同），因此请验证正确的大小并点击**切片**。
- en: Click **Apply**, or close **Sprite Editor** and save, and that’s it for the
    Tilemap prep work!
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**，或者关闭**Sprite编辑器**并保存，这就是Tilemap准备工作完成！
- en: Normal maps
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正常贴图
- en: A **Normal map** is a special type of image where encoding in the RGB channels
    represents the direction a pixel faces. It’s easy to add fake volume and details
    to achieve a simulated 3D effect using a sprite’s pixels and 2D lights with URP.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**正常贴图**是一种特殊类型的图像，其中RGB通道的编码表示像素的方向。使用精灵的像素和2D灯光，很容易添加虚假体积和细节，以实现模拟的3D效果。'
- en: 'You’ll need to use special third-party software to create normal maps outside
    of Unity, as the following figure shows for a rock that we’ll use in the environment:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity不支持创建正常贴图，您需要使用特殊的第三方软件在Unity之外创建正常贴图，如图中所示，我们将使用环境中的岩石：
- en: '![Figure 4.6 – Normal map image of a rock in Laigter](img/B18347_04_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – Laigter中一块岩石的正常贴图](img/B18347_04_06.jpg)'
- en: Figure 4.6 – Normal map image of a rock in Laigter
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – Laigter中一块岩石的正常贴图
- en: Normal maps generation software
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正常贴图生成软件
- en: The program used to create all of the 2D sprite normal maps for the 2D adventure
    game’s artwork is Laigter (available for free at [https://azagaya.itch.io/laigter](https://azagaya.itch.io/laigter)).
    Other programs that can export 2D normal maps include Photoshop, SpriteIlluminator,
    Sprite Dlight, and Sprite Lamp.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建2D冒险游戏艺术作品的全部2D精灵正常贴图的程序是Laigter（可在[https://azagaya.itch.io/laigter](https://azagaya.itch.io/laigter)免费获取）。其他可以导出2D正常贴图的程序包括Photoshop、SpriteIlluminator、Sprite
    Dlight和Sprite Lamp。
- en: Note that when importing 2D sprite normal maps, **Texture Type** for the image
    import settings will be **Sprite (2D and UI,)** and not **Normal Map** – because
    sprites that will be affected by 2D lights need to have the normal map texture
    assigned in the Sprite Editor (2D lights will also need to have normal maps enabled
    for affecting the sprites).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当导入2D精灵正常贴图时，图像导入设置的**纹理类型**将是**Sprite（2D和UI）**，而不是**正常贴图**——因为受2D灯光影响的精灵需要在Sprite编辑器中分配正常贴图纹理（2D灯光也需要启用正常贴图以影响精灵）。
- en: 'All of the images provided in the example 2D adventure game project have accompanying
    normal maps. For your own images, go ahead and generate the normal maps and then
    assign them to the sprites by following these steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2D冒险游戏项目中的所有图像都附有相应的正常图。对于您自己的图像，请按照以下步骤生成正常图，然后将它们分配给精灵：
- en: Select the sprite in the project folder.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中选择精灵。
- en: Click the **Sprite Editor** button in **Import** **Settings (Inspector)**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**精灵编辑器**按钮进入**导入** **设置（检查器）**。
- en: From the **Sprite Editor** dropdown menu, select **Secondary Texture**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**精灵编辑器**下拉菜单中选择**次级纹理**。
- en: In the **Secondary Texture** dialog that opens, select **_NormalMap** from the
    **Name** dropdown menu.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的**次级纹理**对话框中，从**名称**下拉菜单中选择**_NormalMap**。
- en: Assign the sprite’s normal map image by dragging it into the **Texture** field
    from the project window.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将精灵的正常图图像从项目窗口拖动到**纹理**字段中，分配精灵的正常图图像。
- en: Refer to the preceding *Figure 4**.4* for an example of the **Secondary** **Texture**
    dialog.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的**图4**.4，了解**次级纹理**对话框的示例。
- en: With that, we’ve successfully prepared the project’s imported art assets to
    be used with the 2D tooling used in the coming sections. In the next section,
    we’ll take another look at level design before putting the art to use in creating
    different types of platforms.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就成功地为项目导入的艺术资产做好了准备，以便在接下来的章节中使用2D工具。在下一节中，我们将在使用艺术来创建不同类型的平台之前，再次审视关卡设计。
- en: Level and environment design – Guiding the player
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡和环境设计 – 引导玩家
- en: Let’s take a quick break from the technical aspects of the project and talk
    about some game design concepts again before moving on to the features we’ll use
    to build the game level.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续介绍我们将用于构建游戏关卡的功能之前，让我们暂时从项目的技术方面抽身，再次讨论一些游戏设计概念。
- en: 'Having the GDD is great, but it doesn’t provide any concrete visuals for communicating
    the theme and style of the game. Art can quickly elicit emotional responses and
    build excitement that is hard to compare to the written words of a GDD. For example,
    have a look at this concept art created for the *Outer* *World* game:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有GDD很好，但它不提供任何具体的视觉来传达游戏的主题和风格。艺术可以迅速引发情感反应，并建立难以与GDD的书面文字相比的兴奋感。例如，看看为*Outer*
    *World*游戏创建的概念艺术：
- en: '![Figure 4.7 – Original “Outer World” environment concept art](img/B18347_04_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 原始“外部世界”环境概念艺术](img/B18347_04_07.jpg)'
- en: Figure 4.7 – Original “Outer World” environment concept art
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 原始“外部世界”环境概念艺术
- en: You should immediately have a sense of what it would be like to be a player
    in this environment! Games are often marketed early on with an artist’s rendering
    for visualizing concepts to gain interest and excitement for a project. They are
    also used internally to inspire the production team to build the product.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该立刻感受到在这个环境中作为玩家的感觉！游戏通常在早期通过艺术家的渲染来营销，以可视化概念，以激发对项目的兴趣和兴奋。它们也被内部使用，以激发制作团队构建产品。
- en: With excitement buzzing, let’s introduce a new game design principle to guide
    players and get them to explore this unique environment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在兴奋的氛围中，让我们介绍一个新的游戏设计原则来引导玩家，并让他们探索这个独特的环境。
- en: Signposting
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指引
- en: We’ve discussed guiding the player in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041),
    by introducing shapes to nudge the player in the desired direction. The game design
    principle we’ll present here is focal points in the environment, which is called
    **signposting**. Signposting helps the player know what they should do or tells
    them their destination.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在**第2章**中讨论了引导玩家，通过引入形状来引导玩家走向期望的方向。我们在这里将提出的游戏设计原则是环境中的焦点，这被称为**指引**。指引帮助玩家知道他们应该做什么，或者告诉他们他们的目的地。
- en: We want the player to have a goal in mind as they are playing – the player should
    hardly ever experience the feeling of being lost in the game (only when they are
    spending a long time not progressing, point them in the right direction to avoid
    player frustration or worse, leaving the game). This type of signposting is also
    referred to as a **journey**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家在玩游戏时有明确的目标——玩家几乎不会在游戏中感到迷失（只有当他们长时间没有进步时，引导他们走向正确的方向，以避免玩家感到沮丧或更糟，离开游戏）。这种类型的指引也被称为**旅程**。
- en: 'The journey we’re setting our player on in the adventure game can be seen in
    the following figure, where a habitat station is visible in the distance in the
    background:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒险游戏中，我们为玩家设定的旅程可以在以下图中看到，其中在背景的远处可以看到一个栖息地站：
- en: '![Figure 4.8 – Signposting the habitat station for the player](img/B18347_04_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 为玩家指示栖息地站](img/B18347_04_08.jpg)'
- en: Figure 4.8 – Signposting the habitat station for the player
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 为玩家指示栖息地站
- en: The player has a goal now. Always consider designing the level with a purpose…
    what do we want the player to try to do, what should the player accomplish, or
    where should the player get to?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家有一个目标了。始终考虑以目的来设计水平…我们希望玩家尝试做什么，玩家应该完成什么，或者玩家应该到达哪里？
- en: Keep these things in mind when designing your level using the tools we’ll introduce
    in the following sections, starting with adding the platforms that the player
    will walk on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用以下章节中我们将介绍的工具设计你的水平时，请记住这些事情，首先是添加玩家将行走的平台。
- en: Creating platforms
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建平台
- en: You can’t have a platformer game without platforms! Unity’s 2D tooling provides
    different tools for building platforms for 2D games. We’ve already used Tilemap
    to create a rigid and grid-based level design for the collection game. While we’ll
    still use Tilemap for sections of the adventure game level, we’ll start by creating
    platforms without the same constraints using Sprite Shape.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有平台就无法玩平台游戏！Unity的2D工具集提供了不同的工具来构建2D游戏的平台。我们已经使用Tilemap为收集游戏创建了一个刚性和基于网格的水平设计。虽然我们仍将使用Tilemap为冒险游戏水平的一部分，但我们首先将使用Sprite
    Shape创建没有相同约束的平台。
- en: Creating a closed Sprite Shape profile
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建封闭Sprite Shape配置文件
- en: 'We can use two types of shapes when creating with Sprite Shape: open and closed
    shapes. An open shape provides a sprite outline of the spline path, whereas a
    closed shape includes a fill texture for creating an enclosed shape where both
    sides and a bottom sprite can also be defined.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Sprite Shape创建时，我们可以使用两种类型的形状：开放形状和封闭形状。开放形状提供了样条路径的精灵轮廓，而封闭形状包括填充纹理，用于创建一个封闭的形状，其中也可以定义两侧和底部精灵。
- en: 'Let’s start the level design with a closed Sprite Shape platform where the
    player will spawn. To do so, we’ll start by creating the Sprite Shape profile
    asset in the project before adding the platform to the scene by following these
    steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个封闭的Sprite Shape平台开始，玩家将在其中出生。为此，我们首先在项目中创建Sprite Shape配置文件资产，然后按照以下步骤将平台添加到场景中：
- en: In the project window, within the `Assets/Sprites/Sprite Shapes` folder, select
    **Create** | **2D** | **Sprite Shape Profile** and name it *Platform* *Closed
    1*.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，在`Assets/Sprites/Sprite Shapes`文件夹内，选择**创建** | **2D** | **Sprite Shape
    Profile**，并将其命名为*Platform* *Closed 1*。
- en: Assign the sprite for the top edge of the platform by, first, clicking on the
    blue border of the circle that defines **Angle Ranges**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先点击定义**角度范围**的圆形的蓝色边框，为平台的顶部边缘分配精灵。
- en: Adjust the `45` and an `-45`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`45`和`-45`。
- en: With the region for the top edge now defined, assign the `sprite_strip_rock`
    sprite by dragging it from the project window and into the `SpriteShapeEdge` placeholder).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经定义了顶部边缘的区域，通过从项目窗口拖动并将其拖入`SpriteShapeEdge`占位符，分配`sprite_strip_rock`精灵。
- en: 'Do the same for both the left and right sides of the Sprite Shape, using `45`
    and `135` for the angles, respectively, and `sprite_side_rock` as the sprite,
    as seen in the following figure:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Sprite Shape的左侧和右侧都做同样的处理，分别使用`45`和`135`作为角度，并将`sprite_side_rock`作为精灵，如图所示：
- en: '![Figure 4.9 – Closed Sprite Shape asset properties (top, left, and right)](img/B18347_04_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 关闭的Sprite Shape资产属性（顶部、左侧和右侧）](img/B18347_04_09.jpg)'
- en: Figure 4.9 – Closed Sprite Shape asset properties (top, left, and right)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 关闭的Sprite Shape资产属性（顶部、左侧和右侧）
- en: The last step for creating a closed Sprite Shape is to assign the fill texture,
    so assign the `sprite_fill_rock` sprite to the **Fill** | **Texture** field (replacing
    **Sprite Shape** fill placeholder).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建封闭Sprite Shape的最后一步是为它分配填充纹理，因此将`sprite_fill_rock`精灵分配给**填充** | **纹理**字段（替换**Sprite
    Shape**填充占位符）。
- en: If the size of the sprites assigned is not to your liking, you can revisit the
    sprite import settings and change the **Pixels Per Unit** value to something that
    looks better (this can be adjusted at any time). The images being used for Sprite
    Shape are high resolution, so you have the flexibility to change the size without
    a loss in display quality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配的精灵大小不符合你的喜好，你可以重新访问精灵导入设置，并将**每单位像素**的值更改为看起来更好的值（这可以在任何时候进行调整）。用于精灵形状的图像是高分辨率的，因此你可以灵活地更改大小而不会损失显示质量。
- en: Similarly, we can adjust the scale of the fill texture, but we’ll do that on
    the `SpriteShapeController` component when added to the scene – use the **Fill**
    | **Pixels Per Unit** field to adjust the fill texture scale.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以调整填充纹理的缩放比例，但我们将在这个场景中添加到`SpriteShapeController`组件时进行操作——使用**填充** |
    **每单位像素**字段来调整填充纹理的缩放比例。
- en: With the profile asset created, we can now make the first platform for our player
    by clicking **GameObject** | **2D Object** | **Sprite Shape** | **Closed Shape**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了配置文件资产后，我们现在可以通过点击**GameObject** | **2D Object** | **Sprite Shape** | **Closed
    Shape**来为我们的玩家制作第一个平台。
- en: 'Assign the Sprite Shape asset `SpriteShapeController` component. Adjust the
    spline shape by manipulating and adding or removing knots, as seen in the following
    figure:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配精灵形状资产`SpriteShapeController`组件。通过操纵和添加或删除节点来调整样条形状，如图下所示：
- en: '![Figure 4.10 – Closed Sprite Shape platform in the scene](img/B18347_04_10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 场景中的封闭精灵形状平台](img/B18347_04_10.jpg)'
- en: Figure 4.10 – Closed Sprite Shape platform in the scene
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 场景中的封闭精灵形状平台
- en: The last step required to make this closed Sprite Shape a walkable platform
    for the player character is to add a collider. For Sprite Shape platforms, we
    use the `edge`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个封闭的精灵形状成为玩家角色的可通行平台，最后一步是添加一个碰撞器。对于精灵形状平台，我们使用`edge`。
- en: Once added, select **Sprite Shape Controller** | **Collider** | **Updated Collider**
    to enable it. Then, adjust the **Offset** value to line up with the top edge sprite
    – this can also be adjusted later when the player character is added to the scene.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加后，选择**精灵形状控制器** | **碰撞器** | **更新碰撞器**来启用它。然后，调整**偏移**值以与顶部边缘精灵对齐——这也可以在玩家角色添加到场景后进行调整。
- en: Optimization note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 优化注意事项
- en: By default, the Sprite Shape API allows you to change the spline nodes at runtime.
    If you don’t require runtime changes, you can bake or cache the geometry of the
    spline for a performance boost. So, if you don’t need to modify the spline at
    runtime, select **Sprite Shape Controller**, enable **Edit Spline**, and click
    *Cache Geometry* to bake the mesh. Otherwise, install the Burst package (version
    1.3 or later) from the Package Manager to improve performance when modifying the
    spline at runtime.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，精灵形状API允许你在运行时更改样条节点。如果你不需要运行时更改，你可以烘焙或缓存样条的几何形状以提高性能。所以，如果你不需要在运行时修改样条，选择**精灵形状控制器**，启用**编辑样条**，然后点击*缓存几何形状*来烘焙网格。否则，从包管理器安装Burst包（版本1.3或更高）以提高在运行时修改样条时的性能。
- en: Another thing to note is that Sprite Shape’s Renderer works like any other Sprite
    Renderer component and utilizes **Sorting Layers**. We’ll be using **Sorting Layers**
    throughout the project to properly layer the different artwork that will make
    up the level’s platforms and overall environment. We’ll keep all the level’s platforms
    on the default layer, so we have nothing to change.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，精灵形状的渲染器就像任何其他精灵渲染器组件一样，并使用**排序层**。我们将在整个项目中使用**排序层**来正确分层构成关卡平台和整体环境的各种艺术作品。我们将把所有关卡的平台都放在默认层上，因此我们不需要做任何更改。
- en: Bonus activity
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励活动
- en: Sprite Shape can also be used to distribute a variety of sprites along an updateable
    spline path. Explore Sprite Shape’s features to discover how you can decorate
    the platforms with the *vine* and *toxins* assets provided.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵形状还可以用于在可更新的样条路径上分布各种精灵。探索精灵形状的功能，了解你如何使用提供的*藤蔓*和*毒素*资产来装饰平台。
- en: Now that you’ve learned how to create flexible shaped platforms using Sprite
    Shape, we’ll have a quick review of setting up a Tile Palette to use for drawing
    platforms with Tilemap before moving on to creating dynamic and interactive features
    in the level.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用精灵形状创建灵活形状的平台，在继续创建关卡中的动态和交互式功能之前，我们将快速回顾设置Tile Palette以用于使用地图块绘制平台。
- en: Tilemap
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图块
- en: This section will be a quick refresher for creating platforms in our level design
    using Tilemap since we’ve covered this topic extensively in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将快速回顾使用Tilemap在我们的关卡设计中创建平台，因为我们已经对这个主题进行了广泛的介绍[*第2章*](B18347_02.xhtml#_idTextAnchor041)。
- en: 'To create the tiles to be used for painting using the Tile Palette, follow
    these steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Tile Palette绘制地块，请按照以下步骤操作：
- en: Open the Tile Palette by going to **Window** | **2D** | **Tile Palette**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**窗口** | **2D** | **Tile Palette**打开Tile Palette。
- en: Select `Environment` while using the default properties for a Rectangle Grid.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认的矩形网格属性时，选择`Environment`。
- en: Click the `Assets/Sprites/Tilemap/Tile Palettes`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Assets/Sprites/Tilemap/Tile Palettes`。
- en: From the `Asset/Sprites/Tilemap` folder, click and drag the `Tilemap-01` image
    into the `Assets/Sprites/Tilemap/Tiles` folder when prompted.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，从`Asset/Sprites/Tilemap`文件夹中，点击并拖动`Tilemap-01`图像到`Assets/Sprites/Tilemap/Tiles`文件夹。
- en: 'Now that the tiles we’ll use for the Tilemap portion of our level are created,
    let’s go ahead and make a platform to the right of the Sprite Shape platform using
    these steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用于Tilemap部分关卡的地块，让我们继续使用以下步骤制作位于Sprite Shape平台右侧的平台：
- en: In the **Hierarchy** window, create a new Tilemap by using the **Create** or
    **GameObject** menu and selecting **2D Object** | **Tilemap** | **Rectangular**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，通过使用**创建**或**GameObject**菜单并选择**2D Object** | **Tilemap** | **Rectangular**创建一个新的Tilemap。
- en: We’ll use the same **Default** Sorting Layer on **Tilemap Renderer** as we did
    for the Sprite Shape Renderer.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在**Tilemap Renderer**上使用与Sprite Shape Renderer相同的**默认**排序层。
- en: 'Draw the platform using the brush and flood fill tools while using the correct
    tiles for the top, sides, bottom, and corners, as shown in the following figure:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用刷子和填充工具绘制平台，同时使用正确的地块来绘制顶部、侧面、底部和角落，如图下所示：
- en: '![Figure 4.11 – Tilemap platform added to the scene](img/B18347_04_11.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 添加到场景中的Tilemap平台](img/B18347_04_11.jpg)'
- en: Figure 4.11 – Tilemap platform added to the scene
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 添加到场景中的Tilemap平台
- en: As a last step, add a **Tilemap Collider 2D** component to the Tilemap object,
    so it’s walkable by the player character.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，将**Tilemap Collider 2D**组件添加到Tilemap对象上，以便玩家角色可以行走。
- en: We now have two different styles of platforms we can use to create visually
    distinct areas in the level. In the next section, we’ll take platforms to the
    next level by introducing movement and triggering interactions in the environment
    with a C# script.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两种不同的平台样式可以使用，以在关卡中创建视觉上不同的区域。在下一节中，我们将通过引入运动和用C#脚本在环境中触发交互，将平台提升到新的水平。
- en: Moving platforms and triggers – Creating a dynamic interactable environment
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平台和触发器 – 创建动态交互式环境
- en: Adding moving platforms to our game’s level adds to the visual interest and
    provides additional challenges for the player. Unity again provides tooling that
    makes creating moving platforms a simple and straightforward task right in the
    scene View and without needing to write any code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将移动平台添加到我们的游戏关卡中增加了视觉兴趣，并为玩家提供了额外的挑战。Unity再次提供了工具，使得在场景视图中创建移动平台变得简单直接，而且无需编写任何代码。
- en: We previously used Sprite Shape to make a closed platform, but Sprite Shape
    also allows the creation of open shapes, and that will be perfect here for making
    a small platform that we can move.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用Sprite Shape制作了一个封闭的平台，但Sprite Shape还允许创建开放形状，这对于制作一个可以移动的小平台将非常完美。
- en: Moving a Sprite Shape platform with Splines
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Splines移动Sprite Shape平台
- en: Introduced for the Unity 2022 tech stream, we have a new 2D package called `Spline`
    component is used. And the `Sprite Animate` component is used for moving a platform
    along the spline path and doing so without using any code. Nice!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2022技术流引入了新的2D包，名为`Spline`组件。`Sprite Animate`组件用于沿spline路径移动平台，并且无需使用任何代码。太棒了！
- en: Splines
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Splines
- en: Smooth shapes can be created with splines by having a generated line pass through
    any arbitrary number of control points. Different approaches for interpolating
    the line and providing adjustments between hard edges and rounded corners are
    available, such as Catmull-Rom (helpful in calculating a curve that passes through
    all control points), Bézier curves (which provide handles to adjust the tangents
    of the line in relation to points), and B-Splines (similar to Catmull-Rom splines
    but the generated line does not necessarily pass through the control points).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让生成的线条通过任意数量的控制点，可以使用样条曲线创建平滑形状。提供硬边和圆角之间调整的插值线条的不同方法可用，例如Catmull-Rom（有助于计算通过所有控制点的曲线）、贝塞尔曲线（提供手柄以调整线条相对于点的切线）和B-Splines（类似于Catmull-Rom样条曲线，但生成的线条不一定通过控制点）。
- en: The Unity 2022 **Splines** package specifically supports Linear, Catmull-Rom,
    and Bézier types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2022的**Splines**包专门支持线性、Catmull-Rom和Bézier类型。
- en: To use Splines in our project, we’ll need to verify that the package is installed.
    Open `splines` or find **Splines** in the **Packages** list to select and install.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中使用样条曲线，我们需要验证该包是否已安装。打开`splines`或找到**Splines**在**包**列表中，选择并安装。
- en: The first step of creating a moving platform is creating the platform.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建移动平台的第一步是创建平台。
- en: Creating an open Sprite Shape profile
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建开放的精灵形状配置文件
- en: We already had an introduction to Sprite Shape when we created the closed platform
    in the *Creating a closed Sprite Shape profile* section. Creating an open Sprite
    Shape is even easier!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*创建一个封闭的精灵形状配置文件*部分创建封闭平台时，我们已经对精灵形状进行了介绍。创建开放的精灵形状甚至更容易！
- en: 'Use the following few steps to create an open Sprite Shape profile asset:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下几个步骤创建开放的精灵形状配置文件资产：
- en: In the project window, within the `Assets/Sprites/Sprite Shapes` folder, select
    **Create** | **2D** | **Sprite Shape Profile** and name it *Platform* *Open 1*.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，在`Assets/Sprites/Sprite Shapes`文件夹内，选择**创建** | **2D** | **Sprite Shape
    Profile**并将其命名为*Platform* *Open 1*。
- en: Assign the `sprite_strip_rock` sprite by dragging it from the project window
    and into the `SpriteShapeEdge` placeholder).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从项目窗口拖动`sprite_strip_rock`精灵并将其拖入`SpriteShapeEdge`占位符来分配`sprite_strip_rock`精灵）。
- en: '![Figure 4.12 – Open Sprite Shape asset properties](img/B18347_04_12.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 开放的精灵形状资产属性](img/B18347_04_12.jpg)'
- en: Figure 4.12 – Open Sprite Shape asset properties
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 开放的精灵形状资产属性
- en: With the profile asset created, we can now add our first open Sprite Shape moving
    platform to the scene by clicking **GameObject** | **2D Object** | **Sprite Shape**
    | **Open Shape**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了配置文件资产后，现在我们可以通过点击**GameObject** | **2D Object** | **Sprite Shape** | **Open
    Shape**将第一个开放的精灵形状移动平台添加到场景中。
- en: 'Assign the `SpriteShapeController` component’s **Profile** field, then use
    the **Shape** editing tool in the scene Toolbar overlay to make a small straight
    platform (as seen in *Figure 4**.13*). Hint: Use only two knots with **Tangent
    Mode** set to **Linear**.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配`SpriteShapeController`组件的**配置文件**字段，然后使用场景工具栏覆盖中的**形状**编辑工具制作一个小直平台（如图*图4**.13所示）。提示：使用只有两个节点，并将**切线模式**设置为**线性**。
- en: As before, the last step required to make this open Sprite Shape a walkable
    platform for the player character is to add a collider – we also use the `edge`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，使这个开放的精灵形状成为玩家角色可走的平台所需的最后一步是添加一个碰撞器——我们同样使用`edge`。
- en: Once added, ensure the **Sprite Shape Controller** | **Collider** | **Updated
    Collider** field is enabled, then adjust the **Offset** value to line up with
    the top edge sprite (this can be adjusted at any time).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦添加，请确保**精灵形状控制器** | **碰撞器** | **更新碰撞器**字段已启用，然后调整**偏移**值以与顶部边缘精灵对齐（这可以在任何时候进行调整）。
- en: 'Lastly, let’s keep our moving platforms on the same Sorting Layer as all the
    other platforms in the level: **Default**.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将移动平台保持在与其他平台相同的排序层上：**默认**。
- en: The next step in creating the moving platform is setting the path it will take.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建移动平台的下一步是设置它将采取的路径。
- en: Spline path
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样条路径
- en: Much like how we work with splines to create the Sprite Shape platforms, we
    can use Unity’s **Splines** feature tooling to create generic spline paths for
    any number of gameplay reasons. Here, we’re simply building a path for a platform
    to move between two points (it could be more, but we’re only creating a simple
    vertical or horizontal moving platform).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用样条曲线创建精灵形状平台的方式类似，我们可以使用Unity的**Splines**功能工具来创建通用的样条路径，用于任何数量的游戏玩法原因。在这里，我们只是为平台在两点之间移动创建一个路径（可能更多，但我们只创建一个简单的垂直或水平移动平台）。
- en: In the **Hierarchy** window, use the **Create** menu or click **GameObject**
    | **3D Object** | **Spline** | **Draw Spline Tool…** to add a new Spline to the
    scene (rename it or hit *Enter* to accept the default). Yes, Splines are considered
    3D objects because the spline path’s knots are Vector3 positions (relative to
    the GameObject’s transform position, so they are in **Local Space**). We’ll be
    using them solely in 2D (*X* and *Y* axes) for this project, so just be mindful
    that the *Z* axis should always have a zero value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **层级** 窗口中，使用 **创建** 菜单或单击 **游戏对象** | **3D 对象** | **样条** | **绘制样条工具…** 来向场景添加一个新的样条（重命名它或按
    *Enter* 键以接受默认值）。是的，样条被认为是 3D 对象，因为样条路径的节点是 Vector3 位置（相对于游戏对象的变换位置，因此它们位于 **局部空间**）。我们将仅使用它们在
    2D（*X* 和 *Y* 轴）上为此项目，所以请注意 *Z* 轴的值始终应为零。
- en: With the `0`, `0`, `0`) – the **Spline** object position will be set to the
    clicked position).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `(0, 0, 0)` – **样条** 对象的位置将被设置为点击的位置）。
- en: 'Click to add a second knot some distance below the first one and use the **Sprite
    Inspector** overlay to set its *X* position value to zero so the knots are vertically
    aligned, as seen in the following figure:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 点击在第一个节点下方一定距离处添加第二个节点，并使用 **精灵检查器** 叠加层将它的 *X* 位置值设置为零，以便节点垂直对齐，如图所示：
- en: '![Figure 4.13 – Working with Bezier Splines for an open Sprite Shape platform](img/B18347_04_13.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 使用贝塞尔样条为开放精灵形状平台工作](img/B18347_04_13.jpg)'
- en: Figure 4.13 – Working with Bezier Splines for an open Sprite Shape platform
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 使用贝塞尔样条为开放精灵形状平台工作
- en: Note that the **Spline Inspector** overlay may be docked to the side of the
    scene View when the Spline tool is selected and as shown in *Figure 4**.13*. You
    can click on the icon in the overlay toolbar or drag it into the scene View window
    to work with the selected Spline knot’s properties.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当选择样条工具时，**样条检查器**叠加层可能会停靠在场景视图的侧面，如图 *4*.13* 所示。您可以在叠加工具栏中单击图标或将它拖入场景视图窗口来操作所选样条节点的属性。
- en: If you need to edit the position, or the knot’s **Tangent Mode**, use the **Spline
    Transform** tool, and for adding knots to the spline, use the **Draw Splines**
    tool (both are available in the **Toolbar** overlay when a Spline object is selected
    in **Hierarchy**).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要编辑位置或节点的 **切线模式**，请使用 **样条变换** 工具，并为添加到样条中的节点使用 **绘制样条** 工具（这两个工具都在选择层级中的样条对象时在
    **工具栏** 叠加层中可用）。
- en: Additional reading | Unity documentation | New in Unity 2022
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档 | Unity 2022 新特性
- en: '**Splines**: [https://docs.unity3d.com/Packages/com.unity.splines%401.0/manual/getting-started-with-splines.xhtml](https://docs.unity3d.com/Packages/com.unity.splines%401.0/manual/getting-started-with-splines.xhtml)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**样条**：[https://docs.unity3d.com/Packages/com.unity.splines%401.0/manual/getting-started-with-splines.xhtml](https://docs.unity3d.com/Packages/com.unity.splines%401.0/manual/getting-started-with-splines.xhtml)'
- en: Now it’s time to get things moving!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让事物动起来了！
- en: Spline Animate
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spline Animate
- en: The `Splines` package provides additional components covering some common use
    cases for spline paths. We will use one of them here – the **Spline** **Animate**
    component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Splines` 包提供了覆盖一些常见样条路径用例的附加组件。我们将在这里使用其中之一 – **样条** **动画** 组件。'
- en: A bit of housekeeping is in order to make our moving platform not only easy
    to animate and work with but also so that we can create a prefab that will make
    it quick and easy work to add additional moving platforms throughout the level.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的移动平台不仅易于动画化和操作，而且可以快速轻松地创建预制件，以便在整个关卡中添加额外的移动平台，我们需要做一些整理工作。
- en: 'Right now, we have an open Sprite Shape platform object and a Spline path object
    at the root of the hierarchy. To make this a reusable prefab, where we have the
    most control over the position of the spline path and platform, we’ll want to
    end up with this object hierarchy:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个开放的精灵形状平台对象和一个样条路径对象位于层级结构的根目录。为了使其成为一个可重用的预制件，我们可以在其中对样条路径和平台的位置有最大控制，我们希望最终得到以下对象层级：
- en: '![Figure 4.14 – Hierarchy relationships](img/B18347_04_14.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 层级关系](img/B18347_04_14.jpg)'
- en: Figure 4.14 – Hierarchy relationships
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 层级关系
- en: Use the **Create Empty** or **Create Empty Parent** options available in the
    **Hierarchy** window’s **Create** menu to accomplish this – empty GameObjects
    are a great way to organize or provide an additional way to manipulate objects!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **层级** 窗口 **创建** 菜单中可用的 **创建空对象** 或 **创建空父对象** 选项来完成此操作 – 空游戏对象是组织或提供操纵对象额外方式的好方法！
- en: Just be sure the Spline and platform object’s transform positions are at (`0`,
    `0`, `0`) since we should be using the root object (`Moving Platform 1`) transform
    position to place the platform in the level.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 只确保样条线和平台对象的变换位置在 (`0`, `0`, `0`)，因为我们应该使用根对象（`Moving Platform 1`）的变换位置来放置平台在关卡中。
- en: Part of the reason for creating the object hierarchy this way was to add the
    object we’ll move with the **Sprite Animate** component – the **Platform Mover**
    object. Add the **Spite Animate** component now by selecting **Platform Mover**
    and clicking **Add Component** in the **Inspector** window. Assign the **Spline**
    object to the **Spline** field, select **Spline Object** in the **Align To** field,
    then set **Loop Mode** to **Ping Pong** (so the platform moves back and forth
    between the spline knots).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这种对象层次结构的一部分原因是为了添加我们将要使用 **Sprite Animate** 组件移动的对象 – **Platform Mover**
    对象。现在通过选择 **Platform Mover** 并在 **Inspector** 窗口中点击 **Add Component** 来添加 **Sprite
    Animate** 组件。将 **Spline** 对象分配给 **Spline** 字段，在 **Align To** 字段中选择 **Spline Object**，然后将
    **Loop Mode** 设置为 **Ping Pong**（这样平台会在样条线节点之间来回移动）。
- en: Adjust **Duration** and **Easing** to your liking using the following figure
    as a reference.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下图作为参考，调整 **Duration** 和 **Easing** 到你喜欢的程度。
- en: '![Figure 4.15 – Moving the platform with Spline Animate](img/B18347_04_15.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 使用样条线动画移动平台](img/B18347_04_15.jpg)'
- en: Figure 4.15 – Moving the platform with Spline Animate
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 使用样条线动画移动平台
- en: And that’s it! I said it would be easy to get our platform moving… it just required
    a bit of setup. You can preview the movement of the platform right in the scene
    View without having to enter **Play Mode**. Use the **Play**, **Pause**, and **Reset**
    controls to adjust the duration, type of easing, position of the spline knots,
    and offset position of **Platform Open 1** until you’re satisfied with the positioning
    and movement.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我说过让我们的平台移动起来会很容易……只需要一点设置。你可以在场景视图中预览平台的移动，而无需进入 **Play Mode**。使用 **Play**、**Pause**
    和 **Reset** 控制来调整持续时间、缓动类型、样条线节点的位置以及 **Platform Open 1** 的偏移位置，直到你对定位和移动满意为止。
- en: Finish up by dragging the `Moving Platform 1` object to the `Assets/Prefabs`
    folder in the project window to create the prefab asset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `Moving Platform 1` 对象拖到项目窗口中的 `Assets/Prefabs` 文件夹以创建预制资产。
- en: Triggering actions in the level
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在关卡中触发动作
- en: Games often have interactions that are triggered in the environment when the
    player moves into a specific area or touches something– think rocks falling, doors
    opening, alerting the enemy, turning lights on/off, transitioning to a cutscene,
    or whatever your game requires. This is pretty trivial to add if we leverage the
    Unity physics engine similar to how we previously performed collecting items in
    the collection game.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中经常有当玩家移动到特定区域或触摸某物时在环境中触发的交互 – 想想岩石掉落、门打开、警报敌人、开关灯、过渡到场景或任何你的游戏需要的。如果我们利用
    Unity 物理引擎，就像我们之前在收集游戏中执行收集物品一样，这很容易添加。
- en: 'The process is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: We first add a sprite for the object to our game level.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将对象的精灵添加到游戏关卡中。
- en: Create a collider volume around the object to define a trigger area – using
    the least expensive 2D collider type, the better (e.g., `CircleCollider2D`).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象周围创建一个碰撞体体积来定义触发区域 – 使用最经济的 2D 碰撞体类型，例如 `CircleCollider2D`。
- en: Enable **IsTrigger** on the collider so that it does not physically interact
    with any other objects in the scene.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在碰撞体上启用 **IsTrigger**，这样它就不会与场景中的任何其他对象进行物理交互。
- en: Add a component that will invoke an event when the Unity physics message, `OnTriggerEnter2D()`,
    is called when the player enters the collider.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个组件，当玩家进入碰撞体时，当调用 Unity 物理消息 `OnTriggerEnter2D()` 时将触发事件。
- en: We’re also going to take a designer-friendly approach and make the action assignable
    in the **Inspector** window so we won’t have to create a custom script for every
    type of triggered event. This will make the triggered event component reusable
    anywhere in the game we want the player to trigger an interaction. Yay!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将采取一个对设计师友好的方法，在 **Inspector** 窗口中使动作可分配，这样我们就不必为每种触发事件创建自定义脚本。这将使触发事件组件可以在游戏中任何我们希望玩家触发交互的地方重复使用。太好了！
- en: UnityEvent
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UnityEvent
- en: The event delegate type we’ll use here is **UnityEvent** – we’ve previously
    used **UnityAction**. The difference is that **UnityEvent** is serialized and
    becomes available in the **Inspector** to assign public methods.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用的委托事件类型是 **UnityEvent** – 我们之前使用过 **UnityAction**。区别在于 **UnityEvent**
    是序列化的，并可以在 **Inspector** 中使用来分配公共方法。
- en: Additional reading | Unity documentation
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '*UnityEvent*: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityEvent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityEvent.xhtml)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*UnityEvent*: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityEvent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityEvent.xhtml)'
- en: In Unity 2022, the **UnityEvent** list in the **Inspector** is now reorderable!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 2022中，**Inspector**中的**UnityEvent**列表现在可以重新排序了！
- en: 'Let’s see how this works by creating a new script named `TriggeredEvent`, with
    the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为`TriggeredEvent`的新脚本，并使用以下代码来查看它是如何工作的：
- en: '[PRE0]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break this down, especially since there are several new items worth noting:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下，特别是因为有几个值得注意的新项目：
- en: The class declaration is decorated with the `RequireComponent` attribute. This
    means that when the `TriggeredEvent` script is added as a component to a GameObject,
    it will require that the specified type exists as a sibling component on the GameObject.
    If possible, the required component will be added.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类声明被`RequireComponent`属性装饰。这意味着当`TriggeredEvent`脚本作为组件添加到GameObject时，它将要求在GameObject上存在指定的类型作为同级组件。如果可能，将添加所需组件。
- en: 'In our case, we only specified the base `Collider2D` type that all of the 2D
    colliders inherit from – this allows us to add any type of collider as a trigger
    volume for the triggered event. If we try to add the script to a GameObject that
    does not already have a 2D collider added, we’ll receive this error:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只指定了所有2D碰撞体继承的基础`Collider2D`类型——这允许我们添加任何类型的碰撞体作为触发事件的触发体积。如果我们尝试将脚本添加到尚未添加2D碰撞体的GameObject，我们将收到以下错误：
- en: '![Figure 4.16 – Can’t add script for the required component](img/B18347_04_16.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.16 – Can’t add script for the required component](img/B18347_04_16.jpg)'
- en: Figure 4.16 – Can’t add script for the required component
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.16 – Can’t add script for the required component
- en: The solution is to add a 2D collider (appropriate for the player interaction
    scenario) to the GameObject before adding the `TriggeredEvent` script. For this
    example, we’ve added a `CircleCollider2D`, placed and sized it in front of a peculiar
    rock formation, and triggered a particle system to start playing (as seen in *Figure
    4**.16*).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在添加`TriggeredEvent`脚本之前，将2D碰撞体（适用于玩家交互场景）添加到GameObject中。对于这个例子，我们添加了一个`CircleCollider2D`，将其放置并调整大小在奇特岩石形成之前，并触发一个粒子系统开始播放（如*图4**.16*所示）。
- en: Next is the `IsTriggeredByPlayer` Boolean that we’ll set in the **Inspector**.
    A few lines below it will be used to determine whether only the player can trigger
    the interaction. This field is optional but a quick and easy addition that could
    provide some exciting behavior if, say, enemies or other objects enter the collider
    (think outside the box here for all the different things that could be triggered
    in the environment).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们在**Inspector**中设置的`IsTriggeredByPlayer`布尔值。在其下方几行将用于确定是否只有玩家可以触发交互。这个字段是可选的，但快速且容易添加，如果，比如说，敌人或其他对象进入碰撞体（在这里考虑所有可能触发环境中的不同事情）。
- en: As just discussed, the `UnityEvent` declaration is what allows us, as the developer
    and designer, to add the specific interaction – one or many – in the **Inspector**
    that is invoked when triggered (as seen in the **Inspector** under the darker
    gray **On Triggered ()** section in *Figure 4**.16*).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如刚才讨论的，`UnityEvent`声明允许我们，作为开发者和设计师，在**Inspector**中添加特定的交互——一个或多个——当触发时会被调用（如*图4.16*中**Inspector**下较暗灰色**On
    Triggered ()**部分所示）。16*).
- en: The `if` block determines whether we’ll continue running the triggered code
    or not if we require the event only to be triggered by the player. So if `IsTriggeredByPlayer`
    is set to `true,` the conditional AND operator (`&&`) will evaluate whether the
    object collided is tagged `Player`. And if not, it will stop executing this method’s
    code (by using the `return` statement).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if`块决定了如果只需要玩家触发事件，我们是否会继续运行触发代码。所以如果`IsTriggeredByPlayer`设置为`true`，条件AND运算符(`&&`)将评估碰撞的对象是否被标记为`Player`。如果不是，它将停止执行此方法代码（通过使用`return`语句）。'
- en: '&& (C#)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '&& (C#)'
- en: The conditional AND (**&&**) operator means both statements must logically equate
    to **true** for executing the code in the block. Note that this has “short-circuiting”
    logic, meaning that if the first expression evaluates to **false**, then the second
    expression will not be evaluated.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 条件AND（**&&**）运算符意味着两个语句在逻辑上都必须等于**true**才能执行块中的代码。请注意，这具有“短路”逻辑，意味着如果第一个表达式评估为**false**，则第二个表达式将不会评估。
- en: The other thing to note here is that `Tags.Player` will give you a compiler
    error because the `Tags` type has not been defined yet (identified by a red squiggly
    underline). Let’s fix that now. We’ll use the built-in refactoring tooling in
    the IDE by either right-clicking on the word **Tags** (or clicking anywhere on
    **Tags** and pressing *Alt* + *Enter*, or *Ctrl* + *.*, depending on your IDE).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的另一件事是，`Tags.Player` 将导致编译错误，因为 `Tags` 类型尚未定义（通过红色波浪线下的标识）。现在让我们修复这个问题。我们将通过在
    IDE 中右键单击单词 **Tags**（或单击 **Tags** 上的任何位置并按 *Alt* + *Enter*，或 *Ctrl* + *.*，具体取决于您的
    IDE）来使用 IDE 内置的重构工具。
- en: In the dialog that opens, select **Refactoring...** | **Generate type ‘Tags’**
    | **Generate class ‘Tags’ in a** **new file**.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的对话框中，选择**重构...** | **生成类型‘标签’** | **在** **新文件**中生成类‘标签’。
- en: Optimization note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 优化说明
- en: For performance reasons, you should always use **CompareTag()** over evaluating
    the **.tag** property of a GameObject with the **==** operator.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能原因，你应该始终使用 **CompareTag()** 而不是使用 **==** 操作符来评估 GameObject 的 **.tag** 属性。
- en: 'With the new file created, add a constant for the `Player` tag string like
    the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新文件后，添加一个用于 `Player` 标签字符串的常量，如下所示：
- en: '[PRE1]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this class does not inherit from `MonoBehaviour` because we won’t
    be adding it to a GameObject in the scene. It will be used solely when we need
    to specify an object’s tag anywhere in our code – minimizing the use of string
    literals throughout the code, issues related to simple spelling mistakes that
    are easy to overlook, and providing CodeLens references for everywhere it’s being
    used. Anytime you need to reference a tag for any other object in the game, just
    add it here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类不会从 `MonoBehaviour` 继承，因为我们不会将其添加到场景中的 GameObject。它仅在我们需要在代码的任何地方指定对象的标签时使用
    - 最小化代码中字符串字面量的使用，避免简单的拼写错误，并提供 CodeLens 引用，以便在代码中使用的地方都能找到。任何需要引用游戏中其他对象标签的时候，只需在这里添加即可。
- en: Const (C#)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 常量（C#）
- en: A variable declared as a constant is an immutable value that does not change
    for the program’s life (that is, known at compile time). A **const** (**string**,
    **int**, **float**, etc.) declared with a public accessor is available to other
    classes without an instance reference – similar to how a static variable would
    be used.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为常量的变量是一个不可变的值，在整个程序的生命周期中都不会改变（即在编译时已知）。使用公共访问器声明的 **const**（**string**、**int**、**float**
    等）对于其他类来说是可用的，无需实例引用 - 类似于静态变量的使用方式。
- en: The last line invokes the event(s) assigned in the `OnTriggered?.Invoke();`
    – note that the `?.` (null-conditional) operator is optional here, but I always
    include it for invoked member types for code consistency.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一行调用了在 `OnTriggered?.Invoke();` 中分配的事件（s）- 注意，这里的 `?.`（空条件）操作符是可选的，但我总是包括它以保持代码一致性。
- en: Now, with the setup shown in the following figure, when the player enters the
    collider, particles will spawn from the rock!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下图所示的设置，当玩家进入碰撞体时，粒子将从岩石中产生！
- en: '![Figure 4.17 – TriggerEvent collider with scene View icon](img/B18347_04_17.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 带场景视图图标的 TriggerEvent 碰撞体](img/B18347_04_17.jpg)'
- en: Figure 4.17 – TriggerEvent collider with scene View icon
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 带场景视图图标的 TriggerEvent 碰撞体
- en: With this kind of reusable component for triggering any type of event, it is
    now trivial to add interactions throughout the game level by both developers and
    designers working on the project. Easy-peasy!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种可重复使用的触发任何类型事件的组件，现在对于项目中的开发者和设计师来说，通过添加交互变得非常简单！易如反掌！
- en: In this section, we’ve now finished up with all the 2D feature tooling used
    to create all the walkable platforms, including those moving, as well as interactivity
    in the level. In the next section, we’ll look at finalizing the game’s environment,
    adding polish, and optimizing the draw calls for better performance.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们现在已经完成了所有用于创建所有可通行平台（包括移动平台）以及关卡中交互性的 2D 功能工具。在下一节中，我们将查看最终完成游戏环境、添加细节和优化绘制调用以获得更好的性能。
- en: Adding polish to our environment to immerse the player and optimizing
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的环境添加细节以沉浸玩家并优化
- en: With the tools and techniques introduced in the previous sections, you should
    now explore building out your level design. Closed Sprite Shapes for the primary
    platforms, open Sprite Shapes for platforms that are both static and moving, and
    Tilemap platforms mixed in for a particular area of the level – all used to give
    the player an experience and challenge on their journey to the habitat station
    we provide a signpost for in the background.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前几节中介绍的工具和技术，你现在应该探索构建你的关卡设计。为主要的平台使用封闭的精灵形状，为既是静态又是移动的平台使用开放的精灵形状，并在关卡特定区域混合使用瓦片地图平台——所有这些都被用来给玩家在前往我们背景中提供的栖息站点的旅程中提供体验和挑战。
- en: Platforms on a blank screen are rather dull. Let’s add some polish to the level
    by adding a background and some movement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在空白屏幕上的平台相当单调。让我们通过添加背景和一些运动来为关卡添加一些润色。
- en: Polishing the environment
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境润色
- en: With your game level now well on its way to being defined (we’ll, of course,
    be making plenty of adjustments once we add the player character and can start
    play-testing the level), let’s have a look at finishing and polishing the environment,
    starting with adding the background and foreground elements to more fully flesh
    out the game design – providing immersion and setting the tone for the player
    experience.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的游戏关卡已经很好地定义了（当然，一旦我们添加了玩家角色并开始测试关卡，我们将会进行大量的调整），让我们看看如何完成和润色环境，从添加背景和前景元素开始，以更充分地完善游戏设计——提供沉浸感和为玩家体验设定基调。
- en: Background parallax effect
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景视差效果
- en: As mentioned previously, we’ll be applying a relatively old 2D game design technique
    called parallax to layered images in the background to create depth and a sense
    of immersion in the environment. We’ll accomplish this with a custom C# script
    since Unity does not provide a 2D feature specifically geared toward tackling
    this technique.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将应用一个相对较旧的2D游戏设计技术，即视差，将背景中的分层图像应用于创建深度和沉浸感。我们将使用自定义的C#脚本来实现这一点，因为Unity没有提供专门针对处理此技术的2D功能。
- en: Let’s start by creating a new C# script in the `Assets/Scripts` folder and name
    it `ParallaxLayers`. This script will be a reusable component that we can use
    to add parallax movement to any number of layered images. In the 2D adventure
    game, we’ll use this for the background and a few foreground elements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Assets/Scripts`文件夹中创建一个新的C#脚本开始，并将其命名为`ParallaxLayers`。这个脚本将是一个可重用的组件，我们可以用它为任意数量的分层图像添加视差移动。在2D冒险游戏中，我们将使用它来处理背景和一些前景元素。
- en: 'Let’s have a look at the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE2]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the code item by item:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐项分析代码：
- en: The first public variable declared is a list of the images we’ll use for the
    parallax layers that will be moved at different speeds based on their depth (this
    is how the parallax effect is achieved; objects in the distance appear to move
    slower than nearby objects). We use C# `List<T>` specifying `Layer` as the type,
    where `Layer` is a custom class [object] we declare to hold the reference for
    a specific image and the depth value assigned to it for calculating its movement
    speed relative to the camera movement.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明的第一个公共变量是我们将用于视差层的图像列表，这些图像将根据它们的深度以不同的速度移动（这就是如何实现视差效果；远处的对象看起来比近处的对象移动得慢）。我们使用C#
    `List<T>`指定`Layer`作为类型，其中`Layer`是我们声明的自定义类[对象]，用于保存特定图像及其分配给它的深度值，以计算其相对于相机移动的速度。
- en: List (C#)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表（C#）
- en: '**List<T>** is a collection of strongly typed objects that can be added, accessed
    by index, or returned by methods it provides for searching. Methods are also provided
    for sorting and manipulating objects in different ways.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**List<T>** 是一个强类型对象的集合，可以通过它提供的方法添加、按索引访问或返回。它还提供了排序和以不同方式操作对象的方法。'
- en: 'Additional reading: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读：https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1
- en: Next is the `Layer` nested class declaration with public fields for `Image`
    with a type of `Renderer` (all sprites, meshes, lines, trails, and particles are
    drawn with a component derived from the `Renderer` class) and `ZDepth`, which
    is an `int` value for the image’s distance away from the camera.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`Layer`嵌套类声明，其中包含公共字段`Image`，其类型为`Renderer`（所有精灵、网格、线条、尾迹和粒子都是通过从`Renderer`类派生的组件绘制的），以及`ZDepth`，这是一个表示图像距离相机距离的`int`值。
- en: The `ZDepth` variable declaration is also decorated with the `Tooltip` and `Range`
    attributes (these can be comma delimited in a single `[]` statement). The `Tooltip`
    attribute displays the specified message text when the mouse hovers over the field
    label in the `Range` attribute will limit the values valid for the field between
    the range specified.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ZDepth` 变量声明也装饰了 `Tooltip` 和 `Range` 属性（这些可以在单个 `[]` 语句中以逗号分隔）。`Tooltip` 属性在鼠标悬停在
    `Range` 属性的字段标签上时显示指定的消息文本；`Range` 属性将限制字段的有效值在指定的范围内。'
- en: Additional reading | Unity documentation
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '*Attributes*: [https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*：[https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml)'
- en: The `Layer` class declaration itself is decorated with the `System.Serializable`
    attribute. A class declaration is not available in the `Layers` accessor is public,
    that alone is not enough to serialize the class.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Layer` 类声明本身也装饰了 `System.Serializable` 属性。在 `Layers` 访问器中，类声明不可用，仅此不足以序列化类。'
- en: The private `_camera` member is used to cache the main camera reference because
    we’re getting values from it multiple times in our calculation, and we want this
    to be performant.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有的 `_camera` 成员用于缓存主相机引用，因为我们多次从它获取计算值，并且希望这具有高性能。
- en: '`LateUpdate()` is executed after `Update()` and after the internal animation
    update is processed. After everything in the game loop has been updated, we can
    use `LateUpdate()` to affect those updates further. In this case, we want to move
    the background layers only after the camera movement.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LateUpdate()` 在 `Update()` 之后以及内部动画更新处理之后执行。在游戏循环中的所有更新完成后，我们可以使用 `LateUpdate()`
    进一步影响这些更新。在这种情况下，我们希望在相机移动之后才移动背景层。'
- en: Additional reading | Unity documentation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '*LateUpdate*: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.LateUpdate.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.LateUpdate.xhtml)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*LateUpdate*：[https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.LateUpdate.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.LateUpdate.xhtml)'
- en: '**Order of execution for event** **functions**: [https://docs.unity3d.com/2022.3/Documentation/Manual/ExecutionOrder.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/ExecutionOrder.xhtml)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件函数执行顺序**：[https://docs.unity3d.com/2022.3/Documentation/Manual/ExecutionOrder.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/ExecutionOrder.xhtml)'
- en: Did the camera move? A quick evaluation on the `_cameraLastScreenPosition` Boolean
    value will tell – if not, don’t execute further (using the `return` statement).
    Don’t run code that you don’t have to!
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相机是否移动了？通过快速评估 `_cameraLastScreenPosition` 布尔值即可得知——如果没有移动，则不要执行后续操作（使用 `return`
    语句）。不要运行不必要的代码！
- en: 'This is where the magic happens… using the `foreach` iterator, we’ll go through
    each of the `Layer` items added in the **Inspector** and move it the calculated
    distance relative to how far the camera moved:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方……使用 `foreach` 迭代器，我们将遍历在 **检查器** 中添加的每个 `Layer` 项目，并按照相机移动的距离计算相对距离来移动它：
- en: '[PRE3]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`parallaxSpeed`: we start by getting a ratio for the depth of the image from
    the camera position (order of operations for math), returning the absolute value
    (a positive number), clamping the value to a range of `0` to `1`, and finally
    subtracting the clamped value from `1` to get a percentage of the camera’s movement
    to move the image:'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallaxSpeed`：我们首先从相机位置获取图像深度的比例（数学运算的顺序），返回绝对值（一个正数），将值限制在 `0` 到 `1` 的范围内，最后从
    `1` 减去限制后的值，以获取相机移动的百分比来移动图像：'
- en: '[PRE4]'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`difference`: How far the camera moved from its current position compared to
    its last position:'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference`：相机从当前位置移动到上次位置的移动距离：'
- en: '[PRE5]'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`transform.Translate()`: Move the image horizontally on the *X* axis (due to
    `Vector3.right`) by the distance the camera moved multiplied by the speed factor
    (effectively, speed values closer to `1` move relatively the same distance as
    the camera):'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform.Translate()`：沿 *X* 轴（由于 `Vector3.right`）移动图像，移动距离是相机移动距离乘以速度因子（实际上，接近
    `1` 的速度值移动相对相同的距离）：'
- en: '[PRE6]'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: foreach (C#)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: foreach (C#)
- en: The **foreach** statement iterates over a collection of items and executes its
    code block for each. Each list element is of the type specified when the list
    is declared.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**foreach** 语句遍历一个项目集合，并对每个项目执行其代码块。列表中的每个元素都是声明列表时指定的类型。'
- en: 'Additional reading on C# iteration statements: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#迭代语句的附加阅读：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements)
- en: Finish off by updating the variable that holds the camera’s last position after
    moving.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移动后更新保存摄像机最后位置的变量。
- en: int versus float divide by zero
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 整数与浮点除以零
- en: You might be thinking, *Hey, wait a second, Scott, with the* **Range** *attribute,
    you’re allowing a zero value for distance, and to calculate the parallax speed,
    we’re dividing by the distance. So, if the distance is zero, then won’t that throw
    a divide-by-zero exception error?* What an astute observation to make that point;
    thank you for asking! You would be correct if the camera’s **transform.position.z**
    value is an integer type. It would absolutely throw an exception, but it is a
    float value, so dividing by zero will never throw an exception because, in C#,
    floating-point types are based on the IEEE 754 standard, which allows for numbers
    representing infinity and **Not a** **Number** (**NaN)**.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“嘿，等等，Scott，使用**Range**属性，你允许距离为零的值，而为了计算视差速度，我们正在除以距离。所以，如果距离为零，那么不会抛出除以零异常错误吗？”你提出了一个敏锐的观察点；感谢你的提问！如果摄像机的**transform.position.z**值是整数类型，你会是对的。它确实会抛出异常，但它是一个浮点值，所以除以零永远不会抛出异常，因为在C#中，浮点类型基于IEEE
    754标准，它允许表示无穷大和**非数字**（**NaN**）的数字。
- en: '**Additional** **reading**: [https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加阅读**：[https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0](https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0)'
- en: Now that we have completed our parallax effect script, let’s add the background
    layers to the scene and assign the field values.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了视差效果脚本，让我们将背景层添加到场景中，并分配字段值。
- en: 'The following `ZDepth` value of 10,000 – meaning they’ll appear to be stationary
    – and images closer to the camera having values less than 1,000 – meaning they’ll
    move more closely to the camera movement:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`ZDepth`值为10,000——这意味着它们看起来是静止的——以及靠近摄像机的图像值小于1,000——这意味着它们会更靠近摄像机的移动：
- en: '![Figure 4.18 – Parallax background layers assigned to the Inspector](img/B18347_04_18.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18 – 分配给检查器的视差背景层](img/B18347_04_18.jpg)'
- en: Figure 4.18 – Parallax background layers assigned to the Inspector
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 – 分配给检查器的视差背景层
- en: The preceding figure also shows an object hierarchy we can use to organize the
    images for the background layers (and foreground images using the same technique).
    Drag the background images from `Assets/Sprites/Background` into the scene and
    parent the objects in **Hierarchy** to a **Background** empty GameObject.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图还显示了我们可以用来组织背景层图像（以及使用相同技术的前景图像）的对象层次结构。将`Assets/Sprites/Background`中的背景图像拖到场景中，并将**层次结构**中的对象设置为**背景**空GameObject的父对象。
- en: With the objects in the scene, you can position them and use the Sorting Layer
    and Order in Layer (Sprite Renderer) to set their display. Be sure to add a new
    **Background** Sorting Layer and position it at **Layer 0** so that our platforms’
    **Default** layer will draw in front of the background images.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中的对象，你可以定位它们，并使用排序层和层顺序（Sprite Renderer）来设置它们的显示。务必添加一个新的**背景**排序层，并将其放置在**层0**，这样我们的平台**默认**层就会在背景图像之前绘制。
- en: This is more art than technical so play around with the position and scale,
    background image order, and so on, until things look good!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这更多的是艺术而不是技术，所以可以尝试调整位置和缩放、背景图像顺序等，直到看起来不错！
- en: Now, add the `ZDepth` value for each image – assign higher values for the images
    further in the distance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为每个图像添加`ZDepth`值——为距离更远的图像分配更高的值。
- en: You can test the parallax effect by entering `ZDepth` value so that it works
    within the bounds of your level design.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`ZDepth`值来测试视差效果，以确保它在你的关卡设计范围内工作。
- en: Let’s continue adding polish to the environment with some clouds animated to
    move across the sky. This will be super easy by again leveraging the **Spline**
    **Animate** component.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续用一些在天空中移动的动画云来为环境增添光泽。这再次利用**Spline** **Animate**组件将会非常简单。
- en: Animated clouds
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画云
- en: Earlier in this chapter, you learned how to easy it is to create a moving platform
    using a simple spline path and a component to animate its position. We’ll use
    the same approach to create two layers of different-style clouds moving across
    the sky at different speeds. The only difference here, compared to the platform,
    is that the clouds will start off-screen and loop continuously, instead of a ping-pong
    movement (clouds usually only move in one direction across the sky, after all).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你学习了如何使用简单的样条路径和动画组件轻松创建移动平台。我们将采用相同的方法创建两层不同风格的云层，以不同的速度在天空移动。与平台相比，这里唯一的区别是云层将从屏幕外开始，并持续循环，而不是像乒乓球一样来回移动（毕竟，云层通常只在一个方向上穿越天空）。
- en: 'Use the following steps to create two layers of clouds moving across the sky:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建两层云层在天空中移动：
- en: Add a Spline object to the scene using `90`, `0`, `0`).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`(90, 0, 0)`将Spline对象添加到场景中。
- en: 'Add cloud sprites to the scene and parent along with the Spline to a new empty
    GameObject named `Clouds 1` (you can add as many cloud layers as desired, just
    increment the count, as shown in *Figure 4**.18*). We have two cloud layers, and
    multiple cloud sprites added for the `Clouds` `2` object.*   Add a **Spline Animate**
    component to the cloud image GameObject and set the following properties:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将云精灵添加到场景中，并将其与样条一起设置为名为`Clouds 1`的新空GameObject（你可以添加任意数量的云层，只需按图4.18所示增加计数即可）。我们有两个云层，并为`Clouds
    2`对象添加了多个云精灵。*   将**Spline Animate**组件添加到云层图像GameObject中，并设置以下属性：
- en: Assign the Spline object from **Hierarchy** to the **Spline** field.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**层次结构**中的Spline对象分配到**样条**字段。
- en: Set **Align To** as **Spline Object**.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**对齐到**设置为**样条对象**。
- en: Set the **Duration** field to a value that sets the clouds moving slowly across
    the sky – make sure to set this value to a different time, so multiple cloud layers
    are offset from one another!
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**持续时间**字段设置为使云层在天空中缓慢移动的值 – 确保将此值设置为不同的时间，以便多个云层彼此偏移！
- en: Set **Loop Mode** as **Loop Continuous** because we want the clouds to restart
    the animation over again on the right side once they reach the end knot on the
    left side.![Figure 4.19 – Animated background clouds setup](img/B18347_04_19.jpg)
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**循环模式**设置为**循环连续**，因为我们希望云层在达到左侧的终点节点后，在右侧重新开始动画。![图4.19 – 动画背景云层设置](img/B18347_04_19.jpg)
- en: Figure 4.19 – Animated background clouds setup
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 动画背景云层设置
- en: This is a quick and easy way to bring more life to the environment. The same
    is true for the next 2D tooling feature we’ll introduce to add more polish.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种快速简单的方法，可以让环境更加生动。对于接下来我们将介绍的下一个2D工具功能，也是如此，用于添加更多细节。
- en: Animated environment art with sprite skin
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有精灵皮肤的动画环境艺术
- en: Let’s now set up some of the plant entity’s vines to sway and move in different
    ways in the background, giving the player a sense of presence by the unnatural
    forces at work here.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一些植物实体的藤蔓，使其在背景中以不同的方式摇摆和移动，通过这里不自然的力给玩家一种存在感。
- en: We’ve already imported and prepared artwork to use with `Assets/Sprites/Sprite
    Skins` folder and open **Sprite Editor**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入并准备了与`Assets/Sprites/Sprite Skins`文件夹一起使用的艺术作品，并打开**精灵编辑器**。
- en: 'Use the following steps to create a mesh geometry that is deformable by a set
    of weighted bones:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建一个可由一组加权骨骼变形的网格几何体：
- en: From the **Sprite Editor** dropdown menu, select **Skinning Editor** and enable
    the **Visibility** tool (top-right of the window next to **Revert** **and Apply**).
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**精灵编辑器**下拉菜单中选择**皮肤编辑器**，并启用**可见性**工具（在**还原**和**应用**旁边的窗口右上角）。
- en: Under the **Bones** section (left side of the window), select the **Create**
    **Bone** button.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**骨骼**部分（窗口左侧），选择**创建****骨骼**按钮。
- en: The next step is essential and not apparent in the **Skinning Editor** workflow
    – double-click on the sprite!
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤是至关重要的，但在**皮肤编辑器**的工作流程中并不明显 – 双击精灵！
- en: You should now have a cursor with a red dot at the tip. Start creating bones
    by dragging the bones to the desired length, click to add a new bone, and hit
    the *Esc* key when finished. Refer to *Figure 4**.19* for an example of how to
    approach the bones layout (keep in mind that it is more performant to use fewer
    bones while still allowing for the desired deformation).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有一个尖端带有红色点的光标。通过将骨骼拖动到所需长度来创建骨骼，点击添加新的骨骼，完成时按*Esc*键。参考*图4.19*了解如何布局骨骼（请注意，使用较少的骨骼同时允许所需的变形会更高效）。
- en: 'When satisfied with the bones, select **Auto Geometry** under the **Geometry**
    section and click the **Generate For** **Selected** button:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对骨骼满意时，在 **Geometry** 部分下选择 **Auto Geometry**，然后点击 **Generate For Selected**
    按钮：
- en: '![Figure 4.20 – Animating a vine with Sprite Skinning](img/B18347_04_20.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 使用 Sprite Skinning 动画藤蔓](img/B18347_04_20.jpg)'
- en: Figure 4.20 – Animating a vine with Sprite Skinning
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 使用 Sprite Skinning 动画藤蔓
- en: Lastly, select **Auto Weights** under the **Weights** section and click the
    **Generate** button (bottom-right corner of the window).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 **Weights** 部分下选择 **Auto Weights** 并点击窗口右下角的 **Generate** 按钮。
- en: At this point, click the **Apply** button, and we have created our first Sprite
    Skin. Yay, ready for animation! You can test the deformation in **Skinning Editor**
    by clicking the **Preview Pose** button under the **Pose** section.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，点击 **Apply** 按钮，我们就创建了我们的第一个 Sprite Skin。耶，准备进行动画！您可以通过在 **Pose** 部分下点击
    **Preview Pose** 按钮来在 **Skinning Editor** 中测试变形。
- en: Now that our vine is *skinned*, it’s ready for animating!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将藤蔓 *绑定*，它就准备好进行动画制作了！
- en: Animating a Sprite Skin
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动画 Sprite Skin
- en: 'Let’s now add the vine sprite to the game environment as a background element
    and prepare it to be animated:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将藤蔓精灵添加到游戏环境中作为背景元素，并准备它进行动画：
- en: Drag the vine sprite into the **Scene Hierarchy** as a child of one of your
    background images (so that it will move along with the background parallax), position,
    and set the Sorting Layer and Order in Layer accordingly.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将藤蔓精灵拖动到 **Scene Hierarchy** 中，作为您背景图像的一个子项（这样它就会随着背景的视差移动），定位，并相应地设置排序层和图层顺序。
- en: With the sprite selected, in the `skin`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当精灵被选中时，在 `skin` 中。
- en: In the **Sprite Skin** component, click the **Create** **Bones** button.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Sprite Skin** 组件中，点击 **Create Bones** 按钮。
- en: Now we need to add animation to the vine. While the vine is selected, open the
    `.anim`) that we’ll name `Vine 1 Idle` and save to the `Assets/Animation` folder.
    Put your animator hat on now… because it’s time to animate!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要给藤蔓添加动画。当藤蔓被选中时，打开名为 `Vine 1 Idle` 的 `.anim` 文件并将其保存到 `Assets/Animation`
    文件夹中。现在，请戴上你的动画师帽子……因为现在是时候进行动画制作了！
- en: Using *Figure 4**.20* as a reference, by clicking the red record button (the
    **Animation** window), a keyframe will be recorded in the **Animation** timeline
    any time you rotate or position a bone (using the same transform tools we manipulate
    any object with). Scrub the timeline and repeat the process to get the desired
    movement for the vine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *图 4.20* 为参考，通过点击红色记录按钮（**Animation** 窗口），每当您旋转或定位骨骼（使用我们操纵任何对象的相同变换工具）时，都会在
    **Animation** 时间轴上记录一个关键帧。在时间轴上刮擦并重复此过程以获得藤蔓所需的运动。
- en: Again, this is more art than technical and takes some trial and error. With
    practice, this becomes more intuitive and quicker to achieve good results. Use
    the playback controls and adjust accordingly – you’ve got this!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这更多的是艺术而非技术，需要一些尝试和错误。随着练习，这会变得更加直观，并且更快地实现良好的效果。使用回放控件并相应调整——你做到了！
- en: '![Figure 4.21 – Animating the vine with keyframed bone rotation](img/B18347_04_21.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 使用关键帧骨骼旋转动画藤蔓](img/B18347_04_21.jpg)'
- en: Figure 4.21 – Animating the vine with keyframed bone rotation
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 使用关键帧骨骼旋转动画藤蔓
- en: Additional reading | Unity documentation
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '*Animation*: [https://docs.unity3d.com/2022.3/Documentation/Manual/AnimationSection.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/AnimationSection.xhtml)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画*：[https://docs.unity3d.com/2022.3/Documentation/Manual/AnimationSection.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/AnimationSection.xhtml)'
- en: From the static pictures in this book, you can’t get a proper sense of how creepy
    these vines look when animated! Enter **Play Mode** to experience this yourself
    in your level design, or make sure to check out the completed project code or
    play the game online from the GitHub repo.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 从这本书的静态图片中，您无法真正感受到这些藤蔓在动画中的恐怖样子！进入 **Play Mode** 亲自体验您自己的关卡设计，或者确保检查完成的项目代码或从
    GitHub 仓库在线玩游戏。
- en: Let’s look at how to keep the vine animations performant in our game now.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何保持藤蔓动画在游戏中的性能。
- en: Sprite Skin performance
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Sprite Skin 性能
- en: 'As the last step for increasing animation performance with Sprite Skin, install
    the **Burst** and **Collections** packages to enable **deformation batching**:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 Sprite Skin 提高动画性能的最后一步，安装 **Burst** 和 **Collections** 包以启用 **变形批处理**：
- en: '![Figure 4.22 – Installing Burst and Collections for optimization](img/B18347_04_22.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22 – 为优化安装 Burst 和 Collections](img/B18347_04_22.jpg)'
- en: Figure 4.22 – Installing Burst and Collections for optimization
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 为优化安装 Burst 和 Collections
- en: Continuing on the performance optimization topic, before we move on to importing
    and setting up the player character and enemies for the game, let’s look at optimizing
    the sprite draw calls to help keep our framerate from dropping to unacceptable
    levels.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续性能优化主题之前，在我们开始导入并设置游戏中的玩家角色和敌人之前，让我们看看如何优化精灵绘制调用，以帮助保持我们的帧率不会下降到不可接受的水平。
- en: Optimizing draw calls
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化绘制调用
- en: The most impactful performance optimization we can make is addressing the draw
    calls. This was discussed briefly in a callout in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041)
    in the *Importing Sprites* section when we created a **Sprite Atlas**. Not surprising,
    we’re going to do the same thing here now.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的最具影响力的性能优化是解决绘制调用。这在[*第2章*](B18347_02.xhtml#_idTextAnchor041)的“导入精灵”部分中简要讨论过，当时我们创建了一个**精灵图集**。不出所料，我们现在将做同样的事情。
- en: Sprite Atlas
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精灵图集
- en: Use the `Assets/Sprites` folder, then choose `Sprite Atlas`. Note that we won’t
    be adding any of the 2D sprite normal maps as those will be handled internally
    with the Sprite Atlas in the same way they are in **Sprite Editor**.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Assets/Sprites`文件夹，然后选择`Sprite Atlas`。请注意，我们不会添加任何2D精灵法线贴图，因为它们将以与**精灵编辑器**相同的方式在精灵图集中内部处理。
- en: Assign the individual sprite images from the `Assets/Sprites` folders to the
    `Assets/Sprites/Background` `Normal Maps`).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Assets/Sprites`文件夹中的单个精灵图像分配到`Assets/Sprites/Background` `Normal Maps`）。
- en: When there are too many images to fit into a single texture, Sprite Atlas will
    create additional textures and indicate that with a dropdown indicator labeled
    **#0** in the title bar of the **Preview** window. In some cases (for example,
    larger games), it may be desirable to use multiple Sprite Atlases where you will
    determine which one to bind at runtime.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像太多无法放入单个纹理中时，精灵图集将创建额外的纹理，并在**预览**窗口的标题栏中使用带有**#0**标签的下拉指示器来指示。在某些情况下（例如，较大的游戏），可能需要使用多个精灵图集，您将在运行时确定绑定哪个。
- en: Note for compatibility reasons, while using **Sprite Shape,** we’ll have to
    make sure to disable both **Allow Rotation** and **Tight Packing**.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：出于兼容性原因，在使用**精灵形状**时，我们必须确保禁用**允许旋转**和**紧密包装**。
- en: Additional reading | Unity documentation
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '*Sprite* *Atlas*: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-SpriteAtlas.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-SpriteAtlas.xhtml)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*精灵* *图集*：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-SpriteAtlas.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-SpriteAtlas.xhtml)'
- en: In this section, we looked at polishing the visuals of the *Outer World* 2D
    adventure game by adding a parallax background effect and animated elements. We
    then looked at keeping our game performant by reducing sprite draw calls.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过添加透视背景效果和动画元素来润色了*外世界* 2D冒险游戏的外观。然后，我们通过减少精灵绘制调用来保持游戏性能。
- en: Downloading the completed game code
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成的游戏代码
- en: 'Remember, the example code for this book can be downloaded from the GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，本书的示例代码可以从GitHub仓库在此处下载：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter first covered the game, level, and environment design by introducing
    new elements for the GDD to cover the larger scope of the adventure game, importing
    and prepping artwork for use with Unity’s 2D features, and introducing a new level
    design principle to guide the player to a goal.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了游戏、关卡和环境设计，通过引入新的元素来扩展GDD的范围，以涵盖更大范围的冒险游戏，导入并准备用于Unity 2D功能的艺术作品，并引入一个新的关卡设计原则来引导玩家达到目标。
- en: We continued with the imported artwork by creating static and moving platforms
    to challenge players on their journey. Then, we immersed the player in the game
    world by setting up a parallax background and animated environmental elements.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建静态和移动平台来继续导入的艺术作品，以挑战玩家在他们的旅程中的表现。然后，我们通过设置透视背景和动画环境元素，让玩家沉浸在游戏世界中。
- en: Finally, we optimized the draw calls for the sprites that define all the elements
    of the level and environment with a Sprite Atlas.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用精灵图集优化了定义所有关卡和环境元素的精灵的绘制调用。
- en: In the next chapter, we’ll set up the player character with an imported rig
    using the PSD Importer, which will allow a quick setup of the character for animating.
    We’ll also learn how to add a player weapon that shoots projectiles in an optimized
    way by implementing another feature new for Unity 2022, and start introducing
    the enemy characters the player will be fending off on their journey to the habitat
    station.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用PSD导入器导入一个角色绑定，从而快速设置玩家角色以进行动画制作。我们还将学习如何通过实现Unity 2022新增的功能，以优化的方式添加一个能够发射弹体的玩家武器，并开始介绍玩家在前往栖息地站点的旅途中需要抵御的敌人角色。
